A Formal Study on Backward Compatible Dynamic Software Updates
Jun Shen
Arizona State University jun.shen.1@asu.edu

Rida A. Bazzi
Arizona State University bazzi@asu.edu

arXiv:1503.07235v2 [cs.SE] 10 Sep 2015

Abstract
We study the dynamic software update problem for programs interacting with an environment that is not necessarily updated. We argue that such updates should be backward compatible. We propose a general definition of backward compatibility and cases of backward compatible program update. Based on our detailed study of real world program evolution, we propose classes of backward compatible update for interactive programs, which are included at an average of 32% of all studied program changes. The definitions of update classes are parameterized by our novel framework of program equivalence, which generalizes existing results on program equivalence to non-terminating executions. Our study of backward compatible updates is based on a typed extension of W language. Categories and Subject Descriptors D.3.1 [Formal Definitions and Theory]: Semantics, Syntax; D.2.4 [Software/Program Verification]: Correctness Proof, Formal Methods; F.3.2 [Semantics of Programming Languages]: Operational Semantics, Program Analysis; D.3.3 [Language Constructs and Features]: Input/output, Procedures, functions, and subroutines General Terms Theory

4.1 4.2 4.3

Syntax of the formal language . . . . . . . . . . . Small-step operational semantics of the formal language . . . . . . . . . . . . . . . . . . . . . . . Preliminary terms and notations . . . . . . . . . .

7 7 9 9 9 9 10 10 14 18 18 19 26 37 37 38 40 45 45 45 50 55 56 61 65 66 66 67 67 68 68

Keywords dynamic software update, backward compatibility, program equivalence, proof rule, operational semantic

Contents
1 Introduction 2 Backward compatibility 2.1 Programs and Specifications . . . . . . . . . . . 2.2 Hybrid executions and state mapping . . . . . . 2.3 Backward compatibility . . . . . . . . . . . . . 2.4 Backward compatible program behavior changes . . . . 2 2 2 3 3 4 4 5 6 6 6 6 6 7

5 Program equivalence 5.1 Definitions of execution . . . . . . . . . . . . . . 5.2 Equivalent computation for terminating programs . 5.2.1 Proof rule for equivalent computation for terminating programs . . . . . . . . . . . 5.2.2 Soundness of the proof rule for equivalent computation for terminating programs . . 5.2.3 Supporting lemmas for the soundness proof of equivalent computation for terminating programs . . . . . . . . . . . . . . . . . 5.3 Termination in the same way . . . . . . . . . . . 5.3.1 Proof rule for termination in the same way 5.3.2 Soundness of the proof rule for termination in the same way . . . . . . . . . . . . . . 5.3.3 Supporting lemmas for the soundness proof of termination in the same way . . . . . . 5.4 Behavioral equivalence . . . . . . . . . . . . . . 5.4.1 Proof rule for behavioral equivalence . . . 5.4.2 Soundness of the proof rule for behavioral equivalence . . . . . . . . . . . . . . . . 5.4.3 Supporting lemmas for the soundness proof of behavioral equivalence . . . . . . . . . 5.5 Backward compatible DSU based on program equivalence . . . . . . . . . . . . . . . . . . . . 6 Real world backward compatible update classes: proof rules 6.1 Proof rule for specializing new configuration variables . . . . . . . . . . . . . . . . . . . . . . . . 6.2 Proof rule for enumeration type extension . . . . . 6.3 Proof rule for variable type weakening . . . . . . 6.4 Proof rule for exit on errors . . . . . . . . . . . . 6.5 Proof rule for improved prompt message . . . . . 6.6 Proof rule for missing variable initializations . . . 7 Related Work 8 Conclusion A Type system B Syntactic definitions C Properties of imported variables D Properties of expression evaluation

3 Real world backward compatible update classes: brief description 3.1 Observational equivalence: the old behavior . . . . 3.2 Enum. type extension: old behavior for old input and allowing new input . . . . . . . . . . . . . . 3.3 Variable type weakening: more output when the old program terminates . . . . . . . . . . . . . . . . 3.4 Exit on errors: stopping execution while the old program produces more output . . . . . . . . . . 3.5 Improved prompt messages: functionally equivalent outputs . . . . . . . . . . . . . . . . . . . . 3.6 Missing variable initialization: enforcing restrictions on program states . . . . . . . . . . . . . . 4 Formal programming language

1

2015/9/14

E Properties of remaining execution

69

1. Introduction
Dynamic software update (DSU) allows programs to be updated in the middle of their execution by mapping a state of an old version of the program to that of a newer version. The ability to update programs without having to restart them is useful for high-availability applications that cannot afford the downtime incurred by offline updates [16]. DSU has been an active area of research[5, 16, 22, 25] with much of the published work emphasizing the update mechanism that implements a state mapping which maps the execution state of an old version of the program to that of a new version. DSU safety has not yet been successfully studied. Existing studies on DSU safety are lacking in one way or another: high-level studies are concerned with change management for system components [9, 19] and lower-level studies typically require significant programmer annotations [15, 24, 32] or have a restricted class of applications to which they apply (e.g., controller systems [28]). In this paper, we consider the safety of DSU when applied to possibly non-terminating programs interacting with an environment that is not necessarily updated. For such updates, the new version of the program must be able to interact with the old environment, which means that it should be, in some sense, backward compatible with the old version. A strict definition of backward compatibility would require the new version to exhibit the same I/O behavior as the old version; in other words the two programs are observationally equivalent. It should be immediately clear that a more nuanced definition is needed because observational-equivalence does not allow changes which one would want to allow as backward compatible such as bug fixes, new functionalities, or usability improvement (e.g., improved user messages). Allowing for such differences would be needed in any practical definition of backward compatibility. One contribution of this work is a general definition of backward compatibility, a classification of common backward compatible program behavior changes, as well as classes of program change from real world program evolution. Determining backward compatibility, which allows for differences between two program versions, is requiring one to solve the semantic equivalence problem which has been extensively studied [6, 13, 17, 18, 20, 21, 23, 31]. Unfortunately, existing results turned out to be lacking in one or more aspects which rules out retrofitting them for our setting. In fact, existing work on program equivalence typically guarantees equivalence at the end of an execution. Such equivalence is not adequate for our purposes because it does not allow us to express that a point in the middle of a loop execution of one program corresponds (in a well defined sense) to a point in the middle of a loop execution of another program. The ability to express such correspondences is desirable for dynamic software update. Besides, existing formulations of the program equivalence problem either do not use formal semantics [7, 17, 18], only apply to terminating programs [6, 20], severely restrict the programming model [13, 18, 31], or rely on some form of model checking [21, 23] (which is not appropriate for non-terminating programs with infinite states). Our goal for program equivalence is to establish compile-time conditions ensuring that two programs have the same I/O behavior in all executions. In particular, if one program enters an infinite loop and does not produce a certain output, the other program should not produce that output either. This is different from much of the literature on program equivalence which only guarantees same behavior in terminating executions. The closest work that aims to establish program equivalence for nonterminating programs is that of Godlin and Strichman [13] who give sufficient conditions for semantic equivalence for a language that includes recursive functions, but does not allow loops (loops are extracted as recursive functions). That and the fact that equiv-

alence is enforced on corresponding functions severely limits the applicability of the work to general transformations affecting loops such as loop-invariant code motion, loop fission/fusion. So, as a major component of our formal treatment of backward compatible updates, we set out to develop sufficient conditions for semantic equivalence for programs in a typed extension of the W languages [11] with small-step operational semantics. The syntax of language is extended with arrays and enumeration types and the semantics take into consideration the execution environment to allow various classes of updates. In summary, the paper makes the following contributions: 1. We formally define backward compatibility and identify cases of backward compatible program behavior for typical program update motivation. 2. We identify and formally define classes of program changes that result in backward compatible program update based on empirical study of real world program evolution. 3. We give a formal treatment of the semantic equivalence for nonterminating imperative programs. The rest of the paper is organized as follows. Section 2 proposes the general backward compatibility and cases of backward compatible new program behavior. Then we describe real world update classes that result in backward compatible update in Section 3. Section 4 formally defines our extension of the W language to study backward compatible updates. Section 4.3 shows terms, notations and definitions (e.g., execution) heavily used in the technical result. The technical results on semantic equivalence are presented in Section 5. We propose our formal treatment of real world update classes in Section 6. A more detailed comparison to related work is given in Section 7 . Section 8 concludes the paper.

2. Backward compatibility
2.1 Programs and Specifications Programs are designed to satisfy specifications. Specification can be explicitly provided or implicitly defined by the behavior of a program. Programs interact with their environment by receiving inputs and producing outputs. In this section we introduce enough of a computing model to describe the input/output behavior of programs; In the next section we introduce a specific programming language to reason about specific software updates. An execution of a program consists of a sequence of steps from a finite set of steps, S = Sin  Sinternal  Sout  {halt}. A step of a program can either be an input step in which input is received, an internal step in which the state of the program is modified, an output step in which output is produced, or a halt. We make a distinction between internal state of a program and external state (e.g., application settings) of the local environment in which the program executes. Such external state can include the state of a file system that program can access; we include both as part of the program state. The state of a program is an element of a int set M×I , where the set M = Mint ×Mext , Mint = n k=0 Vk is a cartesian product of nint sets of values, one for each internal ext memory location, and Mext = n k=0 Vk is a cartesian product of next sets of values, one for each external location. The input value last received is an element of the set I of input values. A program executes in an execution environment. An execution environment (Mext0 , I ) specifies an initial value for the external program state Mext0 and a possibly infinite sequence of input values I . The input sequence is assumed to be produced by users that we do not model explicitly. A step of a program P is a mapping that specifies the next program state and the next step to execute. For an internal step sinternal  Sinternal , the mapping is sinternal : M × I 
2 2015/9/14

S × M × {}, which specifies the next step and how the state is modified. The internal steps clear input in the state if any. For an output step sout  Sout , the mapping sout : M  S × O which specifies the next step to execute and the output value produced. O is the set of output values produced by the program. An input step sin  Sin is simply an element of S × I and specifies the next step to execute and the input obtained from the environment. (We simply write sin () to denote the next step and the input received.) Because the input value is received by the program, we do not restrict the next step to execute. We allow the input value to be ignored by the program by two consecutive input steps. When the step is halt, there is no further action as if halt were mapped to itself. Definition 1. (Program) A program P is a tuple (S , M, Mint0 , s0 , I , O), where S is the set of steps as defined above, M is the set of program states, Mint0 is the initial internal state, s0 is the initial step, and I and O are disjoint sets of input and output values. We do not include the initial external state Mext0 in the program definition; we include it in the execution environment of P . Definition 2. (Execution) An execution of a program P = (S , M, Mint0 , s0 , I , O) in execution environment (Mext0 , I ), where I is a possibly infinite sequence of input values from I , is a sequence of configurations C from the infinite set {(M, s, i, Ir , IO)}. A configuration c has the form c = (M, s, i, Ir , IO), where M is a state, s is a step, i is the last input received, Ir is a sequence of remaining input values and IO is the input/output sequence produced so far. The kth configuration ck in an execution is obtained from the (k - 1)th configuration ck-1 = (M, s, i, Ir , IO) where s = halt in one of the following cases: 1. The first configuration c0 is of the form (M0 , s0 , , I, ), where M0 = (Mint0 , Mext0 ); 2. s  Sinternal : ck = (M  , s , , Ir , IO), where (s , M  , ) = s(M, i); 3. s  Sin and the remaining inputs Ir is not empty: ck = (M, s , head(Ir ), tail(Ir ), IO·head(Ir )) where (s , head(Ir )) = s (I r ); 4. s  Sin and the remaining inputs Ir is empty: ck = ck-1 ; 5. s  Sout : ck = (M, s , i, Ir , IO · o ), where (s , o ) = s(M ); In the definition, head(I ) denotes the head (leftmost) element in the sequence I and tail(I ) denotes the remaining sequence without the head. The input value in i is either consumed by the next internal step or updated by another input from the next input step. Execution is stuck if an input step is attempted in state in which there are no remaining inputs. In what follows, we include the execution environment in the execution and we abuse notation to say (Mext0 , I, C ) is an execution of a program P . Specifications We consider specifications that define the input/output behavior of programs. Specifications are not concerned with how fast an output is produced or about the internal state of the program. Definition 3. (Specification) Given a set Mext of external states, a set seq (I ) of input sequences, and a set seq (I  O) of I/O sequences, specification  is a predicate: Mext ×seq (I )×seq (I O)×  {true, f alse}. We define the I/O sequence of a sequence of configurations C to be a sequence IO(C ) of values from I  O such that every finite prefix of IO(C ) is the IO sequence of some configuration c  C and every I/O sequence of a configuration c  C is a finite prefix of IO(C ). An execution (Mext0 , I, C ) of program P satisfies a specification  if (Mext0 , I, IO(C )) = true. A specification distin3

guishes executions into those that satisfy the specification and those that do not. A specification defines the external behavior of a program that is observed by a user. The input sequence and I/O sequence are obviously part of external behavior. We also include Mext in specification domain because a user can have information about the external state. For example, a user who has data stored in the file system considers the program's refusal to access the stored data a violation of the service specification; this is not the case if the user has no stored data. 2.2 Hybrid executions and state mapping DSU is a process of updating software while it is running. This results in a hybrid execution in which part of the execution is that of the old program and part of the execution is for the new program. State mapping is a function  mapping an internal state and a non-halt step of one program P to an internal state and a step of P P P . another program P  ,  : MP int × (S \ {halt})  Mint × S The external state is not mapped because the environment is not necessarily updated. In addition, we cannot change input and output that already occurred and that I/O must be part of the hybrid execution. Definition 4. (Hybrid execution) A hybrid execution (Mext0 , I, CP ; CP  ), produced by DSU using state mapping  from program P to program P  , is an execution (Mext0 , I, CP ) of P   concatenated with an execution (Mext , Ir , CP  ) of P  where the    , Mext ), s , i , Ir , IO ) in CP  is first configuration cP  = ((Mint obtained by applying the state mapping to the last configuration cP = ((Mint , Mext ), s(= halt), i, Ir , IO) in CP as follows:
 · (Mint , s ) =  (Mint , s);    · (i = i)  (Ir = Ir )  (IO = IO)  (Mext  Mext ).

2.3 Backward compatibility In this paper, we consider updates in which the environment is not necessarily updated. It follows that in order for the hybrid execution to be meaningful, the new program should provide functionality expected by both old and new users of the system. In practice, specifications are not explicitly available. Instead, the program is its own specification. This means that the specification that the program satisfies can only be inferred by the external behavior of the program. Bug fixes create a dilemma for dynamic software updates. When a program has a bug, its external behavior does not captures its implicit specification and the update will change the behavior of the program. In what follows, we first discuss what flexibility we can be afforded for a backward compatible update and then we give formal definitions of backward compatibility and state our assumptions for allowing bug fixes. We consider a hybrid execution starting from a program P = (S , Mint × Mext , Mint0 , s0 , I , O) and being updated to a pro     gram P  = (S  , M int × Mext , Mint0 , s0 , I , O ). We examine how the two programs should be related for a meaningful hybrid execution. 1. (Inputs) Input set I  of P  should be a superset of that I of P to allow for old users to interact with P  after the update. It is possible to allow for new input values in I  to accommodate new functionality under the assumption that old users do not generate new input values. Such new input values should be expected to produce erroneous output by old users as they are not part of P 's specification. 2. (Outputs) Output produced by P  should be identical to output produced by P if all the input in an execution comes from the input set of P . This is needed to ensure that interactions between old users and the program P  can make sense from the

2015/9/14

perspective of old users. This is true in the case that the update does not involve a bug fix, but what should be done if the update indeed involves a bug fix and the output produced by the old program was not correct to start with? As far as syntax, a bug fix should not introduce new output values. As far as semantics, we should allow the bug fix to change what output is produced for a given input. We discuss this further under the bug fix heading. In summary, if we ignore bug fixes, the new program should behave as the old program when provided with input meant for the old program. 3. (Bugfix) Handling bug fixes is problematic. If the produced output already violates the fix, then there is no way for the hybrid execution to satisfy the implicit semantics of the program or the semantics of the new program. Some bug fixes can be handled. For example, a bug that causes a program to crash for some input can be fixed to allow the program to continue executing. Applying the fix to a program that has not encountered the bug should not be problematic. Another case is when the program should terminate for some input sequence, but the old program does not terminate. A bug fix that allows the program to terminate should not present a semantic difficulty for old users. In general, we assume that there are valid executions and invalid executions of the old program. I/O sequences produced in invalid executions are not in specification of the program. We assume that an invalid execution will lead to an error configuration not explicitly handled by the program developers. We do not expect the state mapping to change an error configuration into an non-error configuration just as static updating does not fix occurred errors. Besides, we do not attempt to determine if a particular configuration is an error configuration. Such determination is not possible in general and very hard in practice. We simply assume that the configuration at the time of the update is not an error configuration. (which is equivalent to assuming the existence of an oracle JP to determine if a particular configuration is erroneous, JP (CP ) = true if the configuration CP is not erroneous). 4. (New functionality) New functionality is usually accompanied by new inputs/outputs and the expansion of external state. We assume that new functionality is independent of existing functionality in the sense that programs P and P  produce the same I/O sequence when receiving inputs in I only. We therefore assume all new inputs I  \ I are introduced by new functionality. Every external state of P is part of some external state of program P  because of the definition of the specification of P . We only consider expansion of the external state of P for new functionalities in P  where the expansion of external state is independent of values in existing external state. One of the motivating examples is to add application settings for new program feature. In light of the discussion above we give the following definition of backward compatibility in the absence of bug fixes. Definition 5. (Backward compatible hybrid executions) Let P = (S , Mint × Mext , Mint0 , s0 , I , O) be a program satisfying  a specification . We say that a hybrid execution (Mext , I, CP ; CP )         from P to a program P = (S , Mint × Mext , Mint0 , s0 , I , O ) is backward compatible with implicit specification of P if all of the following hold:
· The last configuration in CP is not an error configuration,

· Inputs/outputs/external states of P are a subset of those of

If there is bug fix between programs P  and P , we need to adapt Definition 5 to allow for some executions on input sequences from I to violate the specification of P . Above we identified two cases in which bug fixes are safe (replacing a response with no response or replacing a no response with a correct response without introducing new output values). We omit the definition. We have the backward compatible updates by extending the definition of a backward compatible hybrid execution to all possible hybrid executions. Definition 6. (Backward compatible updates) We say an updated program P  is backward compatible with a program P in configuration C if there is hybrid execution, from configuration C of P to P  that is backward compatible with specification of P . 2.4 Backward compatible program behavior changes With the formal definition of backward compatibility, it is desirable to check what behavior changes of an updated program help ensure a safe update. Backward compatibility is essentially a relation between I/O sequences produced by an old program and those produced by an updated program. We summarized typical possibilities of the relation into six cases in Figure 1 by considering consequence of major update motivation (i.e., new functionality, bug fix and program perfective/preventive needs [1]). According to David Parnas [29], a program is updated to adapt to changing needs. In other words, program changes are to produce more or less or different output according to changing needs. These changes are captured by case 2, 3, 4, 5 and 6 in Figure 1. We also capture outputpreserving changes which are most likely motivated by the program developer's own needs (e.g., software maintainability), which is case 1 in Figure 1. Furthermore, we find that an update is backward compatible if in every execution the new program behavior is one of the six cases in Figure 1. Cases 1 and 2 are obviously backward compatible because an old client is guaranteed to get old responses. Cases 3, 4, 5, and 6 are not obviously backward compatible. Unlike case 1 and 2, case 3, 4 and 5 are backward compatible under specific assumptions on program semantics while case 6 is different. Case 3 is backward compatible because we assume the change is either adding new functionality, or fixing a bug in which the old program hanged or crashed. Similarly, case 4 is backward compatible. Case 5 is backward compatible because different I/O interaction could express the same application semantics. For example, a greeting message could be changed from "hi" to "hello". Case 6 is backward compatible in that the new program makes implicit specification of the program explicit by enforcing restrictions on program state and therefore eliminating undesired I/O sequence. The six cases in Fig. 1 have covered the changes of output, including more or less or different output. There exists more specific cases of backward compatible program behavior changes under various specific assumptions. However, these more specific cases could be attributed to one of the six cases as far as the changes of output are concerned. In conclusion, it is not possible to go much beyond the six cases of backward compatibility in Fig. 1.

P  : I  I  , O  O and Mext  M ext ;

3. Real world backward compatible update classes: brief description
We have studied evolution of three real world programs (i.e., vsftpd, sshd and icecast) to identify real world changes that are backward compatible. We chose these three programs because the programs are widely used in practice [2, 3] and are widely studied in the DSU community [26, 27]. We have studied several years of re-

CP = "C  ; (M, s , i, Ir , IO)" : JP (CP )=true. · The hybrid execution satisfies the specification  of P ,  (Mext , I, IO(CP ; CP )) = true;

4

2015/9/14

Case 1

2

3

4

5 6

Update date Total Class Software version Formal new program behavior vsftpd 1.1.0 ­1.1.1 2002-10-07 16 8 the old behavior including external state extension: vsftpd 1.1.1 ­1.1.2 2002-10-16 8 1 P  P  , or P  = {(Mext , oneseq(I ), oneseq(I  O))  val 8 4 vsftpd 1.1.2 ­1.1.3 2002-11-09 |(Mext , oneseq(I ), oneseq(I  O))  val in P 61 9 vsftpd 1.1.3 ­1.2.0 2003-05-29 and Mext  Mext } where I = I  , O = O and Mext  Mext vsftpd 1.2.0 ­1.2.1 2003-11-13 33 11 the old behavior for old input and consuming inputs 10 6 vsftpd 1.2.1 ­1.2.2 2004-04-26 that are only from new clients: 52 13 vsftpd 1.2.2 ­2.0.0 2004-07-01 P  P   vsftpd 2.0.0 ­2.0.1 2004-07-02 7 4 P  \ P = {(Mext , oneseq(I  ), oneseq(I   O ))  true 23 4 vsftpd 2.0.1 ­2.0.2 2005-03-03 | oneseq(I   O ) includes at least one input in (I  \ I )} =  vsftpd 2.0.2 ­2.0.3 2005-03-19 18 8 where I  I  , O  O and Mext = Mext 14 9 vsftpd 2.0.3 ­2.0.4 2006-01-09 producing more output while the old program terminates: 21 15 vsftpd 2.0.4 ­2.0.5 2006-07-03 P  \ P = {(Mext , oneseq(I ), oneseq(I  O))  false vsftpd 2.0.5 ­2.0.6 2008-02-13 20 9 |(Mext , oneseq(I ), oneseq(I  O))  f = } 16 8 vsftpd 2.0.6 ­2.0.7 2008-07-30  {(Mext , oneseq(I ), oneseq(I  O) oneseq'(I  O))  true vsftpd 2.0.7 ­2.1.0 2009-02-19 53 11 |(Mext , oneseq(I ), oneseq(I  O) oneseq'(I  O))  t = } 21 9 vsftpd 2.1.0 ­2.1.2 2009-05-29 P \ P  = {(Mext , oneseq(I ), oneseq(I  O))  false vsftpd 2.1.2 ­2.2.0 2009-08-13 34 14 |(Mext , oneseq(I ), oneseq(I  O))  t = } Update date Total Class Software version  {(Mext , oneseq(I ), oneseq(I  O) oneseq'(I  O))  true 2009-10-19 21 5 |(Mext , oneseq(I ), oneseq(I  O) oneseq'(I  O))  f = } vsftpd 2.2.0 ­2.2.2 vsftpd 2.2.2 ­2.3.0 2010-08-06 13 3 where I = I  , O = O and Mext = Mext 2010-08-19 5 0 vsftpd 2.3.0 ­2.3.2 termination while the old program produces erroneous output: 2011-03-12 7 0 vsftpd 2.3.2 ­2.3.4 P  \ P = {(Mext , oneseq(I ), oneseq(I  O))  true vsftpd 2.3.4 ­2.3.5 2011-12-19 14 6 |(Mext , oneseq(I ), oneseq(I  O))  t = } 2012-04-10 23 4  {(Mext , oneseq(I ), oneseq(I  O) oneseq'(I  O))  false vsftpd 2.3.5 ­3.0.0 2012-09-19 40 2 |(Mext , oneseq(I ), oneseq(I  O) oneseq'(I  O))  f = } vsftpd 3.0.0 ­3.0.2 sshd 3.5p1 ­3.6p1 2003-03-31 95 34 P \ P  = {(Mext , oneseq(I ), oneseq(I  O))  true sshd 3.6p1 ­3.6.1p1 2003-04-01 13 12 |(Mext , oneseq(I ), oneseq(I  O))  f = } 16 12  {(Mext , oneseq(I ), oneseq(I  O) oneseq'(I  O))  false sshd 3.6.1p1 ­3.6.1p2 2003-04-29 2007-03-07 48 13 |(Mext , oneseq(I ), oneseq(I  O) oneseq'(I  O))  t = } sshd 4.5p1 ­4.6p1 sshd 6.6p1 ­6.7p1 2014-10-06 283 51 where I = I  , O = O and Mext = Mext icecast 0.8.0 ­0.8.1 2004-08-04 4 3 different output that is functionally equivalent to old output: icecast 0.8.1 ­0.8.2 2004-08-04 2 0 (P = P  )  (P  P  ) 2005-11-30 47 10 icecast 2.3.0 ­2.3.1 where I = I  , (O = O )  (O  O ) and Mext = Mext icecast 2.3.1 ­2.3.2 2008-06-02 250 28 enforcing restrictions on program state: 2014-11-19 178 154 icecast 2.4.0 ­2.4.1 P  \ P = {(Mext , oneseq(I ), oneseq(I  O))  false |(Mext , oneseq(I ), oneseq(I  O))  arbi = } P \ P  = {(Mext , oneseq(I ), oneseq(I  O))  true Figure 2: Statistics of classified real world software update |(Mext , oneseq(I ), oneseq(I  O))  arbi = }   where I = I , O = O and Mext = Mext that these update classes are also widespread in other program evolution. Each of the six real world update classes falls in one of the five cases of backward compatibility in Fig. 1. We present informal descriptions of all update classes including required assumptions for the two programs to produce same or equivalent output sequence which guarantees backward compatible DSU. 3.1 Observational equivalence: the old behavior In case 1 in Fig. 1, two programs are backward compatible because the new program keeps all old behaviors ("observational equivalence"). In our study, we differentiate two types of "observational equivalence" based on if assumptions are required. Program equivalence We consider several types of program changes that are allowed by "observational equivalence" without user assumptions. These changes include: loop fission or fusion, statement reordering or duplication, and extra statements unrelated to output(e.g., logging related changes). We incorporate these changes in our framework of program equivalence which ensures two programs produce the same output regardless of whether the programs terminate or not. The details of the formal treatment is in Section 5. Specializing new configuration variables Another update class of "observational equivalence" is "specializing new configuration variables", which is backward compatible under user assumptions.

Figure 1: Six cases of formalized general new program behavior

leases of vsftpd and consecutive updates of sshd and icecast. This is because vsftpd is more widely studied by the DSU community [25­ 27]. Our study of real world program evolution is carried out as follows. We examined every changed function manually to classify updates. For every individual change, we first identified the motivation of the change, then the assumptions under which the change could be considered backward compatible. If the assumption under which the change is considered backward compatible is reasonable, we recorded the change into one particular update class. Finally we summarized common update classes observed in the evolution of studied programs. Fig. 2 shows the statistics from our study of real world program evolution where "total" refers to the number of all updated functions, "class" refers to the number of updated functions with at least one classified update pattern. In summary, 32% of all updated functions include at least one classified program update; the unclassified updates are mostly bug fix that are related to specific program logic. We summarized seven most common real world update classes from all the studied updates in Fig. 3 and we believe

5

2015/9/14

Update class (Case) program equivalence (1) new config. variables (1) enum type extension (2) var. type weakening (3) exit on error (4) improved prompt msgs (5) missing var. init. (6)

Required assumptions for backward compatible update none no redefinitions of new config variables after initialization no inputs from old clients match the extended enum labels no intentional use of value type mismatch and array out of bound correct error check before exit changing prompt messages for more effective communication no intentional use of undefined variables

1: 2: 3: output a old

1': If (1/(a - 5)) then 2': skip 3': output a new Figure 6: Exit-on-error

3.3 Variable type weakening: more output when the old program terminates In program updates, variable types are changed either to allow for larger ranges (weakening) or smaller ranges to save space (strengthening). For example, an integer variable might be changed to become a long variable to avoid integer overflow or a long variable might be changed to an integer variable because the larger range of long is not needed. Type weakening also includes adding a new enumeration value and increasing array size. The kinds of strengthening or weakening that should be allowed are application dependent and would need to be defined by the user in general. The type weakening considered is either changes from type int to long or increase of array size. These updates fix integer overflow or array index out of bound respectively, the case 3 of backward compatibility. Implicitly, we assume that there is no intentional use of integer overflow and array out of bound as program semantics. 3.4 Exit on errors: stopping execution while the old program produces more output One kind of bug fix, which we call exit on error, causes a program to exit in observation of errors that depend on application semantic. Fig. 17 shows an example of exit-on-error update. In the example, the fixed bugs refer to the program semantic error that a = 5. Instead of using an "exit" statement, we rely on the crash from expression evaluations to model the "exit". When errors do not occur, the two programs in Fig. 17 produce the same output sequence. This is case 4 of backward compatibility. Naturally, we assume that all error checks are correct. 3.5 Improved prompt messages: functionally equivalent outputs

Figure 3: Required assumptions for real world backward compatible update classes

1: 2: 3: 4: output a + 2 old

1': If (b) then 2': output a  2 3': else 4': output a + 2 new

Figure 4: Specializing new configuration variables

1: enum id {o1 } 2: a : enum id 3: If (a == o1 ) then 4: output 2 + c 5: 6: old

1': 2': 3': 4': 5': 6':

enum id {o1 , o2 } a : enum id If (a == o1 ) then output 2 + c If (a == o2 ) then output 3 + c new

Figure 5: Enumeration type extension

In this update class, new configuration variables are introduced to generalize functionality. For example, in Fig. 15, a new configuration variable b is used to introduce new code. The two statement sequences in Fig. 15 are equivalent when the new variable b is specialized to 0. In general, if all new code is introduced in a way that is similar to that in Fig. 15 where there is a valuation of new configuration variables under which new code is not executed, and new configuration variables are not redefined after initialization, then the new program and the old program produce the same output sequence. The point is that new functionality is not introduced abruptly in interaction with an old client. Instead new functionality could be enabled for a new client when old clients are not a concern. 3.2 Enum. type extension: old behavior for old input and allowing new input Enumeration types allow developers to list similar items. New code is usually accompanied with the introduction of new enumeration labels. Fig. 16 shows an example of the update. The new enum label o2 gives a new option for matching the value of the variable a, which introduces the new code "output 3 + c". To show enumeration type extensions to be backward compatible, we assume that values of enum variables, used in the If-predicate introducing the new code, are only from inputs that cannot be translated to new enum labels. This is case 2 of the backward compatibility.

In practice, outputs could be classified into prompt outputs and actual outputs. Prompt outputs are those asking clients for inputs, which are constants hardcoded in output statements. Actual outputs are dynamic messages produced by evaluation of non-constant expressions in execution. If the differences between two programs are only the prompt messages that a client receives, we consider that the two programs are equivalent. The prompt messages are the replaceable part of program semantics. We observe cases of improving prompt messages in program evolution for effective communication. The changes of prompt outputs do not matter only for human clients. This is case 5 of backward compatibility. 3.6 Missing variable initialization: enforcing restrictions on program states Another kind of bug fix, which we call missing variable initialization, includes initializations for variables whose arbitrary initial values can affect the output sequence in the old program. Fig. 18 shows an example of missing variable initialization. The initialization b := 2 ensures the value used in "output b + c" not to be undefined. Despite of initialization statements, the two programs are same. In general, initializations of variables only affect rare buggy executions of the old program, where undefined variables affect the output sequence. This update class is case 6 of backward compatibility and we assume that there is no intentional use of undefined variable in the program. When there are no uses of variables with

6

2015/9/14

1: 2: If (a > 0) then 3: b := c + 1 4: output b + c old

1': b := 2 2': If (a > 0) then 3': b := c + 1 4': output b + c new

Values I/O values Inputs Eval. values Param. types Loop Labels

v vio vi verr 

  ::= ::= ::=

ZL  L ZL v io v | error  | array(, n) N

integer values in type long and enum/prompt labels tagged input values values and the runtime error

Figure 7: Missing initialization

looplbl 

Identifier id Enum Items Enumeration Prompt Msg Prompts Base type Variables Left value Expression Statement Stmt Seq. Program

Constant n Label l el ::= l | el1 , el2 EN ::=  | enum id {el} | EN 1 , EN 2 msg ::= l : n | msg 1 , msg 2 P mpt ::=  | {msg }  ::= Int | Long | pmpt | enum id V ::=  |  id |  id[n] | V1 , V2 lval ::= id | id1 [id2 ] | id[n] e ::= id == l | lval | other s ::= lval := e | input id | output e | skip | while (e) {S } S ::= s1 ; ...; sk for k  1 P ::= P mpt; EN ; V ; Sentry

Figure 9: Values, types and domains
Crash flag Overflow flag Type Env. Loop counter Value store f ::= of ::=  ::= loopc::=  ::= | | | m ::= 0|1 0|1  | id :  | id : {l1 , ..., lk } | 1 , 2 (looplbl  (n | )) id  (v | ) values of scalar variables id  (n  (v | )) values of array elements  idI  vio input sequence idIO  (vi | vo ) I/O sequence (f, of, , loopc , )

State

Figure 8: Abstract syntax

Figure 10: Elements of an execution state statements Sentry . Finally, we have a standard type system based on our syntax. 4.2 Small-step operational semantics of the formal language

undefined variables in executions of the old program, the two programs produce the same output sequence.

4. Formal programming language
We present the formal programming language based on which we prove our semantic equivalence results and describe categories of backward compatible changes. We first explain the language syntax, then the language semantics. 4.1 Syntax of the formal language The language syntax is in Figure. 8. We use id to range over the set of identifiers, n to range over integers, l to range over labels. We assume unique identifiers across all syntactic categories, unique labels across all enumeration types and the prompt type. We have base type Int and Long for integer values. The integers defined in type Int are also defined in type Long. Every label defined in the prompt type is related with an integer constant as the actual value used in output statement. We differentiate type Long and Int to define the bug fix of type relaxation from Int to Long to prevent overflow in calculation (e.g., a + b can cause an error with Int but not with Long). The type Int is necessary reflecting the concern of space and time efficiency in practical computation. We also have user-defined enumeration type, prompt type and array type. We explicitly have "id == l" and lval as expressions for convenience of the definition of specific updates. To make our programming language general and to separate the concern of expression evaluation, we parameterize the language by "other" expressions which are unspecified. We have explicit input and output statement because we model the program behavior as the I/O sequence which is the observational behavior of a program. The I/O statement makes it convenient for the argument of program behavior correspondence. In this paper, every I/O value is an integer value which is a common I/O representation [14]. A Statement sequence is defined as s1 ; ...; sk where k > 0 for the convenience of syntax-direct definition from both ends of the sequence. A program is composed of a possibly empty prompt type P mpt, a possibly empty sequence of enumeration types EN , a possibly empty sequence of global variables V and a sequence of entry

Figure 9 shows semantic categories of our language. We consider values to be either labels L or integer numbers ZL defined in type Long. The integer numbers defined ZI of type Int are a proper subset of those in type Long, ZI  ZL . We use the notation ZL+ for the positive integers defined in type Long. We use the notation udf  for an undefined value of type  . Unlike the "undef" in Clight [8], we need to parameterize the undefined value with a type  because we do not have an underlining memory model that can interpret any block content according to a type. An individual value in I/O sequence is an integer number with tag differentiating inputs and outputs, our tags for inputs and outputs are standard notations [14]. The value from expression evaluation is a pair. One of the pair is either a value v or "error" for runtime errors(e.g., division by zero); the other is the overflow flag (i.e., 0 for no overflow). We use notation  for all types that are defined in syntax, including array types. Every loop statement in a program is with a unique label looplbl of a natural number in order to differentiate their executions. The composition of an execution state is in Figure 10. 1. The crash flag f is initially zero and is set to one whenever an exception occurs. Once the crash flag is set, it is not cleared. We only consider unrecoverable crashes. The crash flag is used to make sure that updates do not occur in error states. 2. The overflow flag of is initially zero and is set to one whenever an integer overflow in expression evaluation occurs. Overflow flag is sticky in the sense that once it is set, the flag is not cleared. According to [12], integer overflows are common in mature programs. 3.  is the type environment mapping enumeration type identifers and variable identifiers to their types. Type environment is necessary for checking array index out of bound or checking value mismatch in execution of input/assignment statement. 4. Loop counters loopc are to record the number of iterations for one instance of a loop statement. The loop counters loopc is
7 2015/9/14

(S, m)  (S  , m )

(r, m)  (r  , m )

(E[r ], m)  (E[r  ], m ) Eval. Context E ::= | id[E] | E == l | id := E | id[E] := e | id[v] := E | output E | while (E){S } | If (E) then {St } else {Sf } | E; S

(r, m)  (r  , m )
As-Scl As-Arr As-Err1
f=0 (id) = 

(id := v, m(f, ))  (skip, m([v/id])) f=0 (id, v1 ) = 

Figure 11: Contextual semantic rule

(id[v1 ] := v2 , m(f, ))  (skip, m([v2 /(id, v1 )])) f=0 (  id : array(, n))  ¬(1  v1  n)

(id[v1 ] := v2 , m(f, ))  (id[v1 ] := v2 , m(1/f)) f=0 (id) =  (  id : Int)  (v  (ZL \ ZI )) (id := v, m(f, , ))  (id := v, m(1/f)) f=0 (id, v1 ) =  (  id : array(Int, n))  (v2  (ZL \ ZI )) (id[v1 ] := v2 , m(f, , ))  (id[v1 ] := v2 , m(1/f)) f=0 (v  ZL )  (v = 0)

(r, m)  (r  , m )
E : other    (verr × {0, 1}) Err : other  {id} (unspecified)

As-Err2

Var

f=0

(id) = v

(id, m(f, ))  (v, m) f=0 (id, v1 ) = v2

As-Err3 If-T If-F

Arr-1 Arr-2 Eq-T

(id[v1 ], m(f, ))  (v2 , m) f=0 (  id : array(, n))  ¬(1  v1  n)

(If (v ) then {St } else {Sf }, m(f))  (St , m) f=0 (If (0) then {St } else {Sf }, m(f))  (Sf , m) f=0 (v  ZL )  (v = 0) loopc (n) = k

(id[v1 ], m(f, ))  (id[v1 ], m(1/f)) f=0 (l == l, m(f))  (1, m) f=0 l1 = l2 (l1 == l2 , m(f))  (0, m) f = 0 e = other (e, m(f, ))  (E e , m) f=0 ((error, vof ), m(f))  (0, m(1/f)) f = 0 of = 0 ((v, vof ), m(f, of))  (v, m(vof /of)) f = 0 of = 1 ((v, vof ), m(f, of))  (v, m)

Wh-T

(while n (v ) {S }, m(f, loopc ))  (S ; while n (e) {S }, m(loopc [(k + 1)/n]) f=0 (while
n

Eq-F

Wh-F Seq

loopc (n) = 

(0) {S }, m(f, loopc ))  (skip, m(loopc [0/n]))

EEval ECrash

f=0 (skip; S, m(f))  (S, m)

Crash

f=1 (s, m(f))  (s, m)

Figure 13: SOS rules for Assignment, If, and While statements

EOflow-1 EOflow-2

Figure 12: SOS rules for expressions

5. The value store  is a valuation for scalar variables, array elements, the input sequence variable, and the I/O sequence variable.

not necessary for program executions but are needed for our reasoning of the execution of loops. When a counter entry for loop label n is not defined in loop counters loopc , we write loopc (n) = . Otherwise, we write loopc (n) = .

Execution state m is a composition of elements discussed above. In our SOS rules, we only show components of a state m when necessary (e.g., m(,  )). Figure 11 shows typical contextual rule and Figure 12, 13 and 14 show all SOS rules. Figure 12 shows rules for expression evaluation. We use the expression meaning function E : other    (verr × {0, 1}) to evaluate "other" expressions. In evaluation of expression "other" against a value store  , the expression meaning function E returns a pair (verr , of) where the value verr is either a value v or an "error", of is a flag indicating if there is integer overflow in the evaluation (e.g., 1 if there is overflow). The meaning function E interprets "other" expressions deterministically. In addition, there is a function Use :

other  {id} maps an "other" expression to a set of variables used in the expression; there is a function Err : other  {id} maps an expression to a set of variables whose values decide if the evaluation of expression leads to crash. We assume function Use and Err available. The value returned by the expression meaning function only depends on the values of variables in the use set of the expression and the error evaluation only depends on the variables in the error set. As to integer overflow, there are two ways of handling overflow in practice one is to wrap around overflow using twoscomplement representation (e.g., the gcc option -fwrapv); the other is to generates traps for overflow (e.g., the gcc option -ftrapv). We adopt a combination of the two handling of overflow: the meaning function E wraps the overflow in some representation (e.g., two-complement) and notifies the overflow in return value. Rule EOflow-1 and EOflow-2 update the sticky overflow flag. The evaluation of lval or id == l is shown by respective rules in Figure 12. Figure 13 shows SOS rules for assignment, If, while statements, statement sequence, and crash, which are almost standard. There are four particular crash in execution of assignment statements. One is array out of bound for array access for l-value (e.g., rule As-Err1); the second is assigning a value defined in type Long but not type Int to an Int-typed variable (e.g., rule As-Err2); the third is value mismatch in input statement; the last is expression evaluation exception. As to loop statement, if the predicate expression evaluates to a nonzero integer, corresponding loop counter value increments by one; otherwise, the loop counter value is reset to zero. We

8

2015/9/14

(r, m)  (r  , m )
In-1
f=0 (id) =  hd((idI )) = vio   id : Long (input id, m(f, , ))  (skip, m([vio /id][tl((idI ))/idI ]["(idIO ) · v io "/idIO ]) f=0 hd((idI )) = vio (id) =  (  id : Int)  (vio  ZI )

to be in a statement sequence. We use the symbol  to refer to proper subset relation. We call an "If" statement or a "while" statement as a compound statement; all other statements are simple statements. We introduce terms referring to a part of a compound statement. Let s = "If(e) then{St } else{Sf }" be an "If" statement, we call e in s the predicate expression, St /Sf the true/false branch of s.

In-2

(input id, m(f, , ))  (skip, m([vio /id][tl((idI ))/idI ]["(idIO ) · v io "/idIO ]) f=0 hd((idI )) = vio (id) =  (  id : Int)  (vio  / ZI )

5. Program equivalence
We consider several types of program changes that are allowed by "observational equivalence" without user assumptions. These changes include: statement reordering or duplication, extra statements unrelated to output(e.g., logging related changes), loop fission or fusion, and extra statements unrelated to output. Our program equivalence ensures two programs produce the same output, which means two programs produce same I/O sequence till any output. The program equivalence is established upon two other kinds of equivalence, namely equivalent terminating computation of a variable and equivalent termination behavior. We first define terminating and nonterminating execution. Then we present the framework of program equivalence in three steps in which every later step relies on prior ones. We first propose a proof rule ensuring two programs to compute a variable in the same way. We then suggest a condition ensuring two programs to either both terminate or both do not terminate. Finally we describe a condition ensuring two programs to produce the same output sequence. Our proof rule of program equivalence gives program point mapping as well as program state mapping. Though we express the program equivalence as a whole program relation, it is easy to apply the equivalence check for local changes using our framework under user's various assumptions for equivalence. 5.1 Definitions of execution

In-3

(input id, m(f, , ))  (input id, m(1/f)) f=0 (id) =  hd((idI )) = vio (  id : enum id )  (  id : {l1 , ..., lk })  (1  vio  k) (input id, m(f, , ))  (skip, m([lvio /id, tl((idI ))/idI ]["(idIO ) · v io "/idIO ]) f=0 (id) =  hd((idI )) = vio (  id : enum id )  (  id : {l1 , ..., lk })  ¬(1  vio  k) (input id, m(f, , ))  (input id, m(1/f)) f=0 (idI ) = 

In-4

In-5 In-6 Out-1 Out-2

(input id, m(f, ))  (input id, m(1/f)) f=0 v  ZL

(output v, m(f, ))  (skip, m(["(idIO ) · v "/idIO ])) f=0   id : {l1 , ..., lk }  v = li  {l1 , ..., lk }

(output v, m(f, , ))  (skip, m(["(idIO ) · i"/idIO ])) f=0   pmpt : {l1 : n1 , ..., lk : nk } "l : n"  {l1 : n1 , ..., lk : nk }

Out-3

(output l, m(f, ))  (output n, m)

Figure 14: SOS rules for input/output statements

use rule Crash to treat crash as non-terminating execution, telling apart normally terminating executions and others. Figure 14 shows rules for the execution of input/output statements. As to input, there are conversion from values of type Long to those of Int or enumeration types but not the prompt type. For an enumeration type, the Long-typed value is transformed to the label with index of that value if possible. There is crash when value conversion is impossible. Besides, there is crash when executing input statement with empty input sequence. We use standard list operation hd and tl for fetching the list head(leftmost element) or the list tail(the list by removing its head) respectively [30]. Last, we construct initial state in following steps: First, crash flag f, overflow flag of are zero. Second, type environment is obtained after parsing of the program. Third, every loop counter value in loopc is initially zero. Fourth, every scalar variable or array element has an entry in value store with some initial value if specified. Last, there is initial input sequence and empty I/O sequence. 4.3 Preliminary terms and notations We present terms, notations and definitions for program equivalence and backward compatible update classes. We use Use(e) or Use(S ) to denote used variables in an expression e or a statement sequence S ; Def(S ) denotes the set of defined variables in a statement sequence S . The full definitions of Use and Def are in appendix B. We use symbol  for two different purposes: x  X denotes one variable to be in a set of variables, s  S denotes a statement
9

We define an execution to be a sequence of configurations which are pairs (S, m) where S is a statement sequence and m is a execution state shown in Figure 10. Let (S1 , m1 ), (S2 , m2 ) be two consecutive configurations in an execution, the later configuration (S2 , m2 ) is obtained by applying one semantic rule w.r.t to the configuration (S1 , m1 ), denoted (S1 , m1 )  (S2 , m2 ), called one step (of execution). For our convenience, we use the notation k (S, m)  (S  , m ) for k steps execution where k > 0. When we do not care the exact (finite) number of steps, we write the exe cution as (S, m)  (S  , m ). We express terminating executions, nonterminating executions including crash in Definition 7 and 8. Definition 7. (Termination) A statement sequence S normally  terminates when started in a state m iff (S, m)  (skip, m (f)) where f = 0. Definition 8. (Nontermination) A statement sequence S does not k terminate when started in a state m iff, k > 0 : (S, m)  (Sk , mk ) where Sk = skip. 5.2 Equivalent computation for terminating programs We propose a proof rule under which two terminating programs are computing a variable in the same way. We start by giving the definition of equivalent computation for terminating programs right after this paragraph. Then we present the proof rule of equivalent computation in the same way. We prove that the proof rule ensures equivalent computation for terminating programs by induction on the program size of the two programs in the proof rule. We also list auxiliary lemmas required by the soundness proof for the proof rule for equivalent computation for terminating programs.

2015/9/14

Definition 9. (Equivalent computation for terminating programs) Two statement sequences S1 and S2 compute a variable x equivalently when started in states m1 and m2 respectively, writ ten (S1 , m1 ) x (S2 , m2 ), iff (S1 , m1 )  (skip, m 1 (1 )) and   (S2 , m2 )  (skip, m2 (2 )) imply 1 (x) = 2 (x). 5.2.1 Proof rule for equivalent computation for terminating programs We define a proof rule under which (S1 , m1 ) x (S2 , m2 ) holds for generally constructed initial states m1 and m2 , written S1 S x S2 . Our proof rule for equivalent computation for terminating programs allows updates including statement reordering or duplication, loop fission or fusion, additional statements unrelated to the computation and statements movement across if-branch. Definition 12 includes the recursive proof rule of equivalent computing for terminating programs. The base case is the condition for two simple statements in Definition 11. Definition 10 of imported variables captures the variable def-use chain which is the essence of our equivalence. In Definition 10, the Def and Use refer to variables defined or used in a statement (sequence) or an expression similar to those in the optimization chapter in the dragon book [4]; S i refers to i consecutive copies of a statement sequence S. Definition 10. (Imported variables) The imported variables in a sequence of statements S relative to variables X , written Imp(S, X ), are defined in one of the following cases: 1. Def (S )  X = : Imp (S, X ) = X ; 2. S = "id := e" or "input id" or "output e" and Def(S )  X = : Imp(S, X ) = Use(S )  (X \ Def(S )); 3. S = "If (e) then {St } else {Sf }" and Def(S )  X = : Imp(S, X ) = Use(e)  y X Imp(St , {y })  Imp(Sf , {y }) ; 4. S = "while(e) {S  }" where (Def(S  )  X ) = ): Imp (S, X ) i = i0 Imp (S  , Use(e)  X ); 5. For k > 0, S = s1 ; ...; sk+1 : Imp(S, X ) = Imp(s1 ; ...; sk , Imp(sk+1 , X )) Definition 11. (Base cases of the proof rule for equivalent computation for terminating programs) Two simple statements s1 and s2 satisfy the proof rule of equivalent computation of a variable x, written s1 S x s2 , iff one of the following holds: 1. s1 = s2 ; 2. s1 = s2 and one of the following holds: (a) s1 = "input id1 ", s2 = "input id2 ", x  / {id1 , id2 }; (b) Case a) does not hold and x  / Def(s1 )  Def(s2 );

The generalization of definition S1 S x S2 to a set of variables is as follows.

(d) S1 and S2 do not define the variable x: x  / Def(S1 )  Def(S2 ). 2. S1 and S2 are not both one statement and one of the following holds:   (a) S1 = S1 ; s 1 , S2 = S2 ; s2 and last statements both define the variable x such that both of the following hold:   · y  Imp(s1 , {x})  Imp(s2 , {x}) : S1 S y S2 ; S · s1 x s2 where x  Def(s1 )  Def(s2 ); (b) Last statement in S1 or S2 does not define the variable x:   x / Def(s2 )  (S1 S / Def(s1 )  (S1 S x S2 )  x  x S2 ) ;   (c) S1 = S1 ; s 1 , S2 = S2 ; s2 and there are statements moving f t in/out of If statement: s1 = "If (e) then {S1 } else {S1 }", f t s2 = "If (e) then {S2 } else {S2 }" such that none of the above cases hold and all of the following hold:   · y  Use(e) : S1 S y S2 ; f f  t S  t   · (S1 ; S1  x S2 ; S2 )  (S1 ; S1 S x S2 ; S2 );

Definition 13. Two statement sequences S1 and S2 have equivalent computation of variables X , written S1 S X S2 , iff x  X : S1  S x S2 . 5.2.2 Soundness of the proof rule for equivalent computation for terminating programs We show that if two programs satisfy the proof rule of equivalent computation of a variable x (Definition 12) and their value stores in initial states agree on values of the imported variables relative to x, then the two programs compute the same value of x if they terminate. We start by proving the theorem for the base cases of terminating computation equivalently. Theorem 1. If s1 and s2 are simple statements that satisfy the proof rule for equivalent computation of x, s1 S x s2 , and their initial states m1 (1 ) and m2 (2 ) agree on the values of the imported variables relative to x, y  Imp(s1 , {x})  Imp(s2 , {x}) : s1 (y ) = s2 (y ), then s1 and s2 equivalently compute x when started in states m1 and m2 respectively, (s1 , m1 ) x (s2 , m2 ). Proof. The proof is a case analysis according to the cases in the definition of the proof rule for equivalent computation (i.e., Definition 11).

1. s1 = s2 Since the two statements are identical, they have the same imported variables. By assumption, the imported variables of s1 and s2 have the same initial values, so it is enough to show Definition 12. (Proof rule of equivalent computation for terthat the value of x at the end of the computation only depends minating programs) Two statement sequences S1 and S2 satisfy on the initial values of the imported variables. the proof rule of equivalent computation of a variable x, written (a) s1 = s2 = "skip". In this case, the states before and after S1  S x S2 , iff one of the following holds: the execution of skip are the same and Imp(skip, {x}) = 1. S1 and S2 are one statement and one of the following holds: {x}. (a) S1 and S2 are simple statement: s1 S (b) s1 = s2 = "lval := e". x s2 ; f t t i. lval = x. (b) S1 = "If (e) then {S1 } else {S1 }", S2 = "If (e) then {S2 } else f s1 = s2 = "x := e". By the definition of imported {S2 }" such that all of the following hold: variables, Imp(x := e, {x}) = Use(e). The execution · x  Def(S1 )  Def(S2 ); of s1 proceeds as follows. f f t t S · (S1 S x S2 )  (S1  x S2 ); (x := e, m( ))   (c) S1 = "while n1 (e) {S1 }", S2 = "while n2 (e) {S2 }" (x := E  e , m( )) by the EEval' rule such that both of the following hold: (skip, m( [E  e /x])) by the Assign rule. · x  Def(S1 )  Def(S2 ); The value of x after the full execution is  [(E e  )/x](x)   · y  Imp(S1 , {x})  Imp(S2 , {x}) : S1 S y S2 ; which only depend on the initial values of the imported
10 2015/9/14

variables by the property of the expression meaning function. ii. lval = id. By the definition of imported variables, Imp(s1 , {x}) = Imp(s2 , {x}) = {x}. It follows, by assumption, that  1 (x) = 2 (x) and also s1 terminate, (s1 , m1 (1 ))     (skip, m1 (1 )). Hence, 1 (x) = 1 (x) by Corol lary E.2. Similarly, s2 terminates, (s2 , m2 (2 ))      (skip, m2 (2 )) and 2 (x) = 2 (x). Therefore, 2 (x) =  2 ( x ) = 1 ( x ) = 1 (x) and the theorem holds. (c) s1 = s2 = "input id". i. x  Def(input id) = {id, idI , idIO }. By the In rule, the execution of input id is the following. (input id, m( )) (skip, m( [tl( (idI ))/idI ] [" (idIO ) · hd( (idI ))"/idIO ][hd( (idI ))/id])). The value of x after the execution of "input id" is one of the following: A. tl( (idI )) if x = idI . B. 1 (idIO ) · hd( (idI )) if x = idIO . C. hd( (idI )) if x = id. By the definition of imported variables, Imp(input id, {x}) = {idIO , idI }. So, in all cases, the value of x only depends on the initial values of the imported variables idI and idIO . ii. x  / Def(input id) = {id, idI , idIO }. By same argument in the subcase id = x of case s1 = s2 = "id := e", the theorem holds. (d) s1 = s2 = "output e". i. x = idIO By the definition of imported variables, Imp(output e, {x}) = {idIO }  Use(e). The execution of s1 proceeds as follows. (output e, m( )) (output E e , m( )) (skip, m( [" (idIO ) · E ¯ e "/idIO ])). The value of x after the execution is " (idIO ) · E ¯ e ", which only depends on the initial value of the imported variables of the statement "output e" by the expression meaning function. ii. x = idIO By same argument in the subcase id = x of case s1 = s2 = "id := e", the theorem holds.

Similarly, (s2 , m2 )  (skip, m2 (2 [tl(2 (idI ))/id2 ] ["2 (idIO ) · hd(2 (idI ))"/idIO ][hd(2 (idI ))/id2 ])).  Let 2 = 2 [tl(2 (idI ))/idI ]["2 (idIO )·hd(2 (idI ))"/idIO ] [hd(2 (idI ))/id2 ]. Then the value of x after the execution of s2 is one of the following:  A. 2 (x) = tl(2 (idI )) if x = idI  B. 2 (x) = 2 (idIO ) · hd(2 (idI )) if x = idIO Repeatedly, 2 (idI ) = 1 (idI ) and 2 (idIO ) = 1 (idIO ). Therefore, the theorem holds. ii. x  / {idI , idIO } Repeatedly, x  / {id1 , id2 }. By same argument in the subcase id = x of case s1 = s2 = "id := e", the theorem holds. (b) all the above cases do not hold and x  / Def(s1 )  Def(s2 ) By same argument in the subcase id = x of case s1 = s2 = "id := e", the theorem holds.

Theorem 2. If statement sequence S1 and S2 satisfy the proof rule of equivalent computation of a variable x, S1 S x S2 , and their initial states m1 (1 ) and m2 (2 ) agree on the initial values of the imported variables relative to x, y  Imp(S1 , {x})  Imp(S2 , {x}) : 1 (y ) = 2 (y ), then S1 and S2 equivalently compute the variable x when started in state m1 and m2 respectively, (S1 , m 1 )  x (S2 , m 2 ). Proof. By induction on size(S1 )+size(S2 ), the sum of the program size of S1 and S2 . Base case. S1  S x S2 where S1 and S2 are two simple statements. This theorem holds by theorem 1. Induction step The hypothesis IH is that Theorem 2 holds when size(S1 ) + size(S2 ) = k  2. Then we show that the Theorem holds when size(S1 )+ size(S2 ) = k + 1. The proof is a case analysis according to the cases in the definition of the proof rule of terminating computation of statement sequence. the two big categories enum

1. S1 and S2 are one statement such that one of the following holds: (a) S1 and S2 are If statement that define the variable x: f t t S1 = "If (e) then {S1 } else {S1 }", S2 = "If (e) then {S2 } f else {S2 }" such that all of the following hold: · x  Def(S1 )  Def(S2 ); 2. s1 = s2 t t · S1 S x S2 ; f f S (a) s1 = "input id1 ", s2 = "input id2 ", x  / {id1 , id2 }. · S1  x S2 ; i. x  {idI , idIO }. We first show that the evaluations of the predicate expresBy the definition of imported variables, Imp(s1 , {x}) = sion of S1 and S2 produce the same value when started from Imp(s2 , {x}) = {idIO , idI }. It follows, by assumption, state m1 (1 ) and m2 (2 ), w.l.o.g. say zero. Next, we show f f that 1 (y ) = 2 (y ), y  {idIO , idI }. The execution that S1 started in the state m1 and S2 in the state m2 equivof s1 proceeds as follows. alently compute the variable x. (s 1 , m 1 ) In order to show that the evaluations of predicate ex= (input id1 , m1 (1 )) pression of S1 and S2 produce same value when started (skip, m1 (1 [tl(1 (idI ))/idI ] from state m1 (1 ) and m2 (2 ), we show that the vari["1 (idIO ) · hd(1 (idI ))"/idIO ][hd(1 (idI ))/id1 ])) ables used in predicate expression of S1 and S2 are a subset of imported variables in S1 and S2 relative to  Let 1 = 1 [tl(v )/idI , "1 (idIO )·hd(v)"/idIO , hd(v )/id1 ]. x. This is true by the definition of imported variables, The value of x after the execution of s1 is one of the folUse(e)  Imp(S1 , {x}), Use(e)  Imp(S2 , {x}). By aslowing: sumption, the value stores 1 and 2 agree on the values  A. 1 (x) = tl(1 (idI )) if x = idI . of the variables used in predicate expression of S1 and  B. 1 (x) = 1 (idIO ) · hd(1 (idI )) if x = idIO . S2 , 1 (y ) = 2 (y ), y  Use(e). By the property of
11 2015/9/14

  the values of the imported variables in S1 and S2 relative to the variables Imp(). By Lemma 5.2, we show S1 and S2 compute the variable x equivalently when started from state m1 (m1 c , 1 ) and m 2 (m 2 c , 2 ) respectively. The theorem holds. (c) S1 and S2 do not define the variable x: x  / Def(S1 )  (S1 , m1 (1 )) Def(S2 ). f t = (If (e) then {S1 } else {S1 }, m1 (1 )) By the definition of imported variable, the imported varif t (If ((0, vof )) then {S1 } else {S1 }, m1 (1 )) ables in S1 and S2 relative to x are both x, Imp(S1 , {x}) = by the EEval' rule Imp(S2 , {x}) = {x}. By assumption, the initial values f t 1 and 2 agree on the value of the variable x, 1 (x) = (If (0) then {S1 } else {S1 }, m1 (1 )) 2 (x). In addition, by assumption, execution of S1 and by the E-Oflow1 or E-Oflow2 rule f S2 when started in state m1 (1 ) and m2 (2 ) terminate, (S1 , m1 (1 )) by the If-F rule.      (S1 , m1 (1 ))  (skip, m 1 (1 )), (S2 , m2 (2 ))  (skip, m2 (2 )). f Finally, by Corollary E.2, the value of x is not changed in Similarly, the execution from (s2 , m2 (2 )) gets to (S2 , m2 (2 )).   f f execution of S1 and S2 , 1 ( x ) = 1 ( x ) = 2 ( x ) = 2 (x ). By the hypothesis IH, we show that S1 and S2 compute the The theorem holds. variable x equivalently when started in state m1 (1 ) and 2. S1 and S2 are not both one statement such that one of the m2 (2 ) respectively. To do that, we show that all required following holds: conditions are satisfied for the application of hypothesis IH. f f (a) Last statements both define the variable x such that all of · size(S1 ) + size(S2 ) < k. f t the following hold: Because size(S1 ) = 1+size(S1 )+size(S1 ), size(S2 ) =   f t · S1 S y S2 , y  Imp(s1 , {x})  Imp(s2 , {x}); 1 + size(S2 ) + size(S2 ). · x  Def(s1 )  Def(s2 ); · the value stores 1 and 2 agree on the values of the f f · s1 S imported variables in S1 and S2 relative to x, 1 (y ) = x s2 ;   f f We show that S1 and S2 compute the imported variables in 2 (y ), y  Imp(S1 , {x})  Imp(S2 , {x}). s and s relative to the variable x equivalently when started 1 2 By the definition of imported variables, f f in state m1 (1 ) and m2 (2 ) respectively by the hypothesis Imp(S1 , {x})  Imp(S1 , {x}), Imp(S2 , {x})  Imp(S2 , {x}). IH. To do that, we show the required conditions are satisfied f f By the hypothesis IH, S1 and S2 compute the variable for applying the hypothesis IH. x equivalently when started in state m1 (1 ) and m2 (2 )   · size(S1 ) + size(S2 ) < k. respectively. Therefore, the theorem holds. By the definition of program size, size(s1 )  1, (b) S1 and S2 are while statement that define the variable x:   size(s2 )  1. Hence, size(S1 ) + size(S2 ) < k.   S1 = "while n1 (e) {S1 }", S2 = "while n2 (e) {S2 }" · the executions from (S1 , m1 (1 )) and (S2 , m2 (2 )) such that both of the following hold: terminate respectively, · x  Def(S1 )  Def(S2 );      (S1 , m1 (1 ))  (skip, m  S  1 (1 )), (S2 , m2 (2 ))  · S1 y S2 for y  Imp(S1 , {x})  Imp(S2 , {x});   (skip, m2 (2 )). By Lemma 5.2, we show S1 and S2 compute the variBy assumption, the execution from (S1 , m1 (1 )) and 1 able x equivalently when started from state m1 (mc , 1 )  and (S2 , m2 (2 )) terminate, then the execution of S1 and m2 (m2    c , 2 ) respectively. The point is to show that S2 from state m1 (1 ) and m2 (2 ) terminate, (S1 , m1 (1 ))  all required conditions are satisfied for the application of       (skip, m1 (1 )), (S2 , m2 (2 ))  (skip, m2 (2 )). lemma 5.2. · the initial value stores agree on the values of the vari· loop counter value of S1 and S2 are zero. ables: By our assumption, the loop counter value of S1 and S2   Imp(S1 , Imp(s1 , {x}))  Imp(S2 , Imp(s2 , {x})). are initially zero. By Lemma 5.3, s and s have the same imported 1 2 · S1 and S2 have same imported variables relative to x, variables relative to x , Imp ( s 1 , {x}) = Imp(s2 , {x}) Imp(S1 , {x}) = Imp (S2 , {x}) = Imp(). = Imp(x). By the definition of imported variables, imThis is obtained by Lemma 5.3.  ported variables in S1 relative to Imp(x) are same as the · the initial value store 1 and 2 agree on the values  imported variables in S1 relative to x, Imp(S1 , Imp(s1 , {x})) = of the imported variables in S1 and S2 relative to x,  Imp(S1 , {x}). Similarly, Imp(S2 , Imp(s2 , {x})) = 1 (y ) = 2 (y ), y  Imp(S1 , {x})  Imp(S2 , {x}). Imp(S2 , {x}). Then, by assumption, the initial value By assumption, this holds.  , Imp(s1 , {x})) stores agree on the values of the variables Imp(S1   · S1 and S2 compute the imported variables in S1 and   and  y  Imp ( S , Imp ( s , { x } ))  Imp ( S , Imp (s2 , {x})), 1 1 2   (S  )) y S2 relative to x equivalently, (S1 , mS1  Imp(S2 , Imp(s2 , {x})), 1 (y ) = 2 (y ). 1    (S  )), y  Imp() with value stores S  (S2 , m S 2 By the hypothesis IH, after the full execution of S1 from 2 1   agreeing on the values of the imported variand S2 state m1 (1 ) and the execution of S2 from state m2 (2 ),    (z ) = ables in S1 and S2 relative to Imp(), S1 the value stores agree on the values of the imported variables     in s1 and s2 relative to x, 1 ( y ) = 2 (y ), y  Imp (x) =  (z ), z  Imp(S1 , Imp())  Imp(S2 , Imp()). S 2 Imp ( s , { x } ) = Imp ( s , { x } ) . 1 2 By the definition of program size, the sum of the pro   Then, we show s1 and s2 compute x equivalently. By Corolgram size of S1 and S2 is less than k, size(S1 ) +    lary E.1, s1 and s2 continue execution after the full exsize(S2 ) < k. By the hypothesis IH, S1 and S2 com    ecution of S1 and S2 respectively, (S1 ; s1 , m1 (1 ))  pute the imported variables in S1 and S2 relative to         x equivalently when started in states mS1 (S1 ) and (s1 , m1 (1 )), (S2 ; s2 , m2 (2 ))  (s2 , m2 (2 )). When  (S  ) with value store S  and S  agreeing on s1 and s2 are while statements, by our assumption of unique mS2 2 1 2

expression meaning function E , the predicate expression of S1 and S2 evaluate to the same value when started in states m1 (1 ) and m2 (2 ), E e 1 = E e 2 , w.l.o.g, E e 1 = E e 2 = (0, vof ). Then the execution of S1 proceeds as follows.

12

2015/9/14

 loop labels, s1 is not in S1 . By Corollary E.4, the loop  counter value of s1 is not redefined in the execution of S1 . Similarly, the loop counter value of s2 is not redefined in the  execution of S2 . By the hypothesis IH again, after the full execution of s1 and s2 , the value stores agree on the value        of x, (s1 , m 1 (1 ))  (skip, m1 (1 )), (s2 , m2 (2 ))      (skip, m2 (2 )) such that 1 (x) = 2 (x). The theorem holds. (b) One last statement does not define the variable x: W.l.o.g.,  (x  / Def(s2 ))  (S1 S x S2 ).  We show that S1 and S2 compute the variable x equivalently when started from state m1 (1 ) and m2 (2 ) by the hypothesis IH. First, by the definition of program size,  size(s2 )  1. Hence, size(S1 ) + size(S2 )  k . Next,  by the definition of imported variables, Imp (S2 , {x})  Imp (S2 , {x}). By assumption, 1 (y ) = 2 (y ) for y   Imp (S2 , {x})  Imp (S1 , {x}). By the hypothesis IH, S1  and S2 compute the variable x equivalently when started in   state m1 (1 ) and m2 (2 ) respectively, (S2 , m2 (2 ))       (skip, m2 (2 )), (S1 , m1 (1 ))  (skip, m1 (1 )) such   that 1 ( x ) = 2 (x ). Then, we show that S1 and S2 compute the variable x equivalently after the full execution of s2 . By Corollary E.1, s2 continues execution immediately after the full execu   tion of S2 , (S2 ; s2 , m2 )  (s2 , m 2 ). By assumption, the    execution from (S2 ; s2 , m2 ) terminates, (s2 , m 2 (2 ))   )) . By Corollary E.2, the value of x is not (  (skip, m 2 2   changed in the execution of s2 , 2 ( x ) = 2 (x). Hence,   1 (x) = 2 (x). The theorem holds. (c) There are statements moving in/out of If statement: f t t s1 = "If (e) then {S1 } else {S1 }", s2 = "If (e) then {S2 } f else {S2 }" such that none of the above cases hold and all of the following hold:   · S1 S y S2 for y  Use(e);  t S  t · S1 ; S1  x S2 ; S2 ; f f  S  · S1 ; S1  x S2 ; S2 ; · x  Def(s1 )  Def(s2 );   ; s2 . We first show that, ; s 1 , S2 = S2 Repeatedly S1 = S1   after the full execution of S1 and S2 started in state m1 and m2 , the predicate expression of s1 and s2 evaluate to the f  ; S1 same value, w.l.o.g, zero. Next we show that S1 and S1 compute the variable x equivalently when (1) both started in state m1 and (2) the predicate expression of s1 evaluates  to zero after the full execution of S1 started in state m1 , f  similarly S2 and S2 ; S2 compute the variable x equivalently when (1) both started in the state m2 and (2) the predicate expression of s2 evaluates to zero after the full execution of  when started in state m2 . Last we prove the theorem by S1 f f   showing that S1 ; S1 started in state m1 and S2 ; S2 started in state m2 compute the variable x equivalently.   In order to show that S1 and S2 compute the variables used in predicate expression of s1 and s2 equivalently by the hypothesis IH, we show that all required conditions are satisfied for the application of hypothesis IH.   · size(S1 ) + size(S2 ) < k.   The sum of program size of S1 and S2 are less than k by  the definition of program size for s1 and s2 , size(S1 )+  size(S2 ) < k.     · the execution of S1 and S2 terminate, (S1 , m1 )        (skip, m1 (1 )), and (S2 , m2 )  (skip, m2 (2 )). By assumption, the execution of S1 and S2 from the state m1 and m2 respectively terminate, then the exe-

  cution of S1 and S2 terminate when started in state m1 and m2 respectively. · the initial value stores 1 and 2 agree on the values   of the imported variables in S1 and S2 relative to the variables used in the predicate expression of s1 and s2 .   By Lemma 5.3, the imported variables in S1 and S2 relative to the variables used in predicate expression of s1   and s2 are same, Imp(S1 , Use(e)) = Imp(S2 , Use(e)) = Imp(e). By the definition of imported variable, the im ported variables in S1 relative to the variables used in predicate expression of s1 are a subset of the imported  variables in S1 relative to x respectively, Imp(S1 , Use(e))   Imp(S1 , Imp(s1 , {x})) = Imp(S1 , {x}). Similarly  Imp(S2 , Use(e))  Imp(S2 , {x}). Then, by assumption, the initial value stores agree on the values of the   imported variables in S1 and S2 relative to the variables used in the predicate expression of s1 and s2 ,  1 (y ) = 2 (y ), y  Imp(e) = Imp(S1 , Use(e)) =  Imp(S2 , Use(e)).  By the hypothesis IH, after the full execution of S1 and  S2 , the value stores agree on the values of the variables  used in the predicate expression of s1 and s2 , 1 (y ) =  2 (y ), y  Use(e). By Corollary E.1, s1 and s2 con  tinue execution after the full execution of S1 and S2 respec      tively, (S1 ; s1 , m1 )  (s1 , m1 (1 )), and (S2 ; s2 , m2 )    (s2 , m2 (2 )). By the property of expression meaning function E , expres sion e evaluates to the same value w.r.t value stores 1 and    = 0. Then the execu= E e 2 , w.l.o.g., zero, E e 1 2 tion of s1 proceeds as follows.  (s1 , m 1 (1 )) f t  = (If (e) then {S1 } else {S1 }, m 1 (1 )) f t   (If (0) then {S1 } else {S1 }, m1 (1 )) by the EEval rule. f   (S1 , m1 (1 )) by the If-F rule.

f    Similarly, the execution from (s2 , m 2 (2 )) gets to (S2 , m2 (2 )). f  Then, we show that S1 and S1 ; S1 compute the variable x equivalently when both started from state m1 (1 ). The f  ; S1 started from state m1 also gets to conexecution of S1 f    figuration (S1 , m1 (1 )) because execution of S1 = S1 ; s1  f   and S1 ; S1 share the common execution (S1 , m1 )  f  (skip, m 1 (1 )). By Corollary E.1, S1 continues execution  f f   after the full execution of S1 , (S1 ; S1 , m 1 )  (S1 , m 1 ). f  Therefore, the execution of S1 and S1 ; S1 from state m1 compute the variable x equivalently because both executions get to same intermediate configuration. Similarly, S2 f  and S2 ; S2 compute the variable x equivalently when both started from state m2 (2 ). f f   ; S2 compute the variLastly, we show that S1 ; S1 and S2 able x equivalently when started in states m1 (1 ) and m2 (2 ) respectively by the hypothesis IH. To do that, we show that all required conditions are satisfied for the application of hypothesis IH. f f   · size(S1 ; S1 ) + size(S2 ; S2 ) < k. This is obtained by the definition of program size. f f   · execution of S1 ; S1 and S2 ; S2 terminate when started in state m1 (1 ) and m2 (2 ) respectively. This is obtained by above argument. f f   · 1 (y ) = 2 (y ), y  Imp(S1 ; S1 , {x})Imp(S2 ; S2 , {x}). f  We show that Imp(S1 ; S1 , {x})  Imp(S1 , {x}) as follows. f Imp(S1 , {x})

13

2015/9/14

 Imp(s1 , {x}) (1) by the definition of imported variables.
f  Imp(S1 ; S1 , {x}) f  = Imp(S1 , Imp(S1 , {x})) by Lemma   Imp(S1 , Imp(s1 , {x})) by (1) f  Imp(S2 ; S2 , {x})

C.1

1 i (s1 , m1i (loop1 c , 1i )), loopc (n1 )  i; and       · m2 : (s2 , m2 )  (S2 , m2 (loop2 c ))   2 2i (s2 , m2i (loopc , 2i )), loopc (n2 )  i;

  1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc )) 








Similarly,  Imp(S2 , {x}). Then, by assumption, the initial value stores agree on the values f f   of the imported variables in S1 ; S1 and S2 ; S2 relative to x. Then, by the hypothesis IH, after the full execution of f f   S1 ; S1 and S2 ; S2 , the value stores agree on the value   f f    of x, (S1 ; S1 , m1 )  (skip, m 1 (1 )), (S2 ; S2 , m2 )      (skip, m2 (2 )) such that 1 (x) = 2 (x). In conclusion, after execution of S1 and S2 , the value stores agree on the value of x. Therefore, the theorem holds.

= Imp(S1 , {x}) by the definition of imported variables.

Proof. By induction on i. Base case. i = 1. By assumption, initial loop counters of s1 and s2 are of value zero. Initial value stores 1 and 2 agree on the values of the variables in Imp(x). Then we show one of the following cases hold: 1. The loop counters for s1 and s2 are always less than 1:     1 m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )     2 1  (S2 , m2 (loopc )), loopc (n1 ) < 1 and loop2 c (n2 ) < 1; 2. There are two configurations (s1 , m11 ) and (s2 , m21 ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop counters of s1 and s2 are equal to 1 and value stores agree on the values of imported variables relative to x and, for ev  ery state in execution, (s1 , m1 )  (s1 , m11 ) or (s2 , m2 )  (s2 , m21 ) the loop counters for s1 and s2 are less than or equal to one respectively:  1 (s1 , m11 ), (s2 , m21 ) : (s1 , m1 )  (s1 , m11 (loop1 c , 11 ))  21 (s2 , m2 )  (s2 , m21 (loopc , 21 )) where 21 1 · loop1 c (n1 ) = loopc (n2 ) = 1; and · y  Imp(x) : 11 (y ) = 21 (y ); and     1 11 · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m11 (loopc , 11 )),  1 loopc (n1 )  1; and     2 21 · m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m21 (loopc , 21 )), 2 loopc (n2 )  1. We show evaluations of the predicate expression of s1 and s2 w.r.t value stores 1 and 2 produce same value. By the definij tion of imported variables, Imp(s1 , {x}) = j 0 Imp(S1 , {x}  0 0 Use(e)). By our notation of S , S1 = skip. By the definition of 0 imported variables, Imp(S1 , {x}  Use(e)) = {x}  Use(e). Then Use(e)  Imp(x). By assumption, value stores 1 and 2 agree on the values of the variables in Use(e). By Lemma D.1, the predicate expression e of s1 and s2 evaluates to same value v w.r.t value stores 1 , 2 , E  e 1 = E  e 2 = v . Then there are two possibilities to consider. 1. E  e 1 = E  e 2 = v = 0 The execution from (s1 , m1 (loop1 c , 1 )) proceeds as follows. (s1 , m1 (loop1 c , 1 )) = (while n1 (e) {S1 }, m1 (loop1 c )) (while n1 (0) {S1 }, m1 (loop1 c )) by the EEval' rule (skip, m1 (loop1 c [0/n1 ])) by the Wh-F rule.
2 Similarly, (s2 , m2 (loop2 c , 2 ))  (skip, m2 (loopc [0/n2 ])). In conclusion, the loop counters of s1 and s2 in any states of the execution from (s1 , m1 ) and (s2 , m2 ) respectively are less    1  than 1, m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc ) and     2 1 2 (s 2 , m 2 )  (S2  , m  2 (loopc )), loopc (n1 ) < 1, loopc (n2 ) < 1. 2. E  e 1 = E  e 2 = v = 0 The execution from (s1 , m1 (loop1 c , 1 )) proceeds as follows. 2

5.2.3 Supporting lemmas for the soundness proof of equivalent computation for terminating programs The lemmas include the proof of two while statements computing a variable equivalently used in the proof of Theorem 2 and the property that two programs have same imported variables relative to a variable x if the two programs satisfy the proof rule of equivalent computation of the variable x. From the proof rule of terminating computation of a variable x equivalently, we have the two programs either both define x or both do not. Lemma 5.1. Let s1 = "while n1 (e) {S1 }" and s2 = "while n2 (e) {S2 }" be two while statements with the same set of imported variables relative to a variable x (defined in s1 and s2 ), Imp(x), and whose loop bodies S1 and S2 terminatingly compute the variables in Imp(x) equivalently when started in states that agree on the values of the variables imported by S1 or S2 relative to Imp(x):
· x  Def(s1 )  Def(s2 ); · Imp(s1 , {x}) = Imp(s2 , {x}) = Imp(x); · y  Imp(x), mS1 (S1 ), mS2 (S2 ) :

((z  Imp(S1 , Imp(x))  Imp(S2 , Imp(x)) : S1 (z ) = S2 (z ))  (S1 , mS1 (S1 )) y (S2 , mS2 (S2 ))).

If the executions of s1 and s2 terminate when started in 2 states m1 (loop1 c , 1 ) and m2 (loopc , 2 ) in which s1 and s2 have not already executed (loop counter initially 0: loop1 c (n1 ) = loop2 c (n2 ) = 0), and whose value stores 1 and 2 agree on the values of the variables in Imp(x), y  Imp(x), 1 (y ) = 2 (y ), then, for any positive integer i, one of the following holds: 1. The loop counters for s1 and s2 are always less than i:     1 m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc ) and (s2 , m2 )    2  (S2 , m 2 (loopc )),  1 loopc (n1 ) < i and loop2 c (n2 ) < i; 2. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop counters of s1 and s2 are equal to i and value stores agree on the values of imported variables relative to x and, for ev  ery state in execution, (s1 , m1 )  (s1 , m1i ) or (s2 , m2 )  (s2 , m2i ) the loop counters for s1 and s2 are less than or equal to i respectively:  i (s1 , m1i ), (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (loop1 c , 1i ))   2i (s2 , m2 )  (s2 , m2i (loopc , 2i )) where 2i i · loop1 c (n1 ) = loopc (n2 ) = i; and · y  Imp(x) : 1i (y ) = 2i (y ) and
14

(s1 , m1 (loop1 c , 1 )) = (while n1 (e) {S1 }, m1 (loop1 c , 1 )) (while n1 (v ) {S1 }, m1 (loop1 c , 1 )) by the EEval' rule (S1 ; while n1 (e) {S1 }, m1 (loop1 c [1/(n1 )], 1 )) by the Wh-T rule.

2015/9/14

The induction hypothesis IH is that, for a positive integer i, one of Similarly, (s2 , m2 (loop2 c , 2 ))  (S2 ; while n2 (e){S2 }, m2 2 the following holds: (loopc [1/(n2 )], 2 )). Then, the loop counters of s1 and s2 are 1, value stores 11 and 21 agree on values of variables in 1. The loop counters for s1 and s2 are always less than i: Imp(x): loop1      1 c [1/n1 ](n1 ) = m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc ) and (s2 , m2 )  loop2 c [1/(n2 )](n2 ) = 1; and y  Imp(x), 11 (y ) = 21 (y ).   2 (S2 , m2 (loopc )), By assumption, the execution of s1 terminates when started in  2 loop1 the state m1 (, 1 ), then the execution of S1 terminates when c (n1 ) < i and loopc (n2 ) < i;  1 2. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable started in the state m1 (loopc [1/(n1 )], 1 ), (s1 , m1 )    from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop (S1 ; while n1 (e){S1 }, m1 (loop1 [1 / ( n )] ,  ))  ( skip , m )  1 1 1 c counters of s1 and s2 are equal to i and value stores agree on the  11 )) . ( loop ,  (S1 , m1 (loop1 [1 / ( n )] ,  ))  ( skip , m 11 1 1 11 c c values of imported variables relative to x and, for every state in Similarly, the execution of S2 terminates when started in the   execution, (s1 , m1 )  (s1 , m1i ) and (s2 , m2 )  (s2 , m2i ) 2 state m2 (loopc [1/(n2 )], 2 ), the loop counters for s1 and s2 are less than or equal to i  21 (S2 , m2 (loop2 c [1/(n2 )], 2 ))  (skip, m21 (loopc , 21 )). respectively: We show that, after the full execution of S1 and S2 , the follow i (s1 , m1i ), (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (loop1 c , 1i ))  ing four properties hold.  2i )) where ( loop ,  ( s , m )  ( s , m 11 2 2 2 2 2 i i c · The loop counters of s1 and s2 are of value 1, loopc (n1 ) = 2i i · loop1 1 c (n1 ) = loopc (n2 ) = i; and loop2 c (n2 ) = 1. · y  Imp(x), 1i (y ) = 2i (y ); and By assumption of unique loop labels, s1  / S1 . Then, the     1 loop counter value of n1 is not redefined in the execution of · m 1 : (s1 , m1 )  (S1 , m1 (loopc )  11 1  1 1i S1 by corollary E.4, loopc [1/(n1 )](n1 ) = loopc (n1 ) = 1. (s1 , m1i (loopc , 1i )), loopc (n1 )  i; and Similarly, the loop counter value of n2 is not redefined in     2 · m 2 21 2 : (s2 , m2 )  (S2 , m2 (loopc ))  the execution of S2 , loopc [1/(n2 )](n2 ) = loopc (n2 ) = 1. 2 2i  (s2 , m2i (loopc , 2i )), loopc (n2 )  i. 1 · In any state in the execution (s1 , m1 )  (s1 , m11 (loop1 c , 11 )), the loop counter of s1 is less than or equal to 1. Then we show that, for the positive integer i + 1, one of the The loop counter of s1 is zero in any of the two states in following holds: the one step execution (s1 , m1 )  (while n1 (v ) {S1 }, 1. The loop counters for s1 and s2 are always less than i + 1: m1 (loop1 c , , 1 )), and the loop counter of s1 is 1 in any  1    states in the execution m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )  1   2  (S1 ; while n1 (e) {S1 }, m1 (loopc [i/(n1 )], 1 ))  , m  (S2 2 (loopc )), 1  (s1 , m11 (loop1 1 c , 11 )). loopc (n1 ) < i + 1 and loop2 c (n2 ) < i + 1;  1 · In any state in the executions (s2 , m2 )  (s2 , m21 (loop2 c , 21 )), 2. There are two configurations (s1 , m1i+1 ) and (s2 , m2i+1 ) the loop counter of s2 is less than or equal to 1. reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which By similar argument for the loop counter of s1 . the loop counters of s1 and s2 are equal to i + 1 and value · The value stores 11 and 21 agree on the values of the stores agree on the values of imported variables relative to x  imported variables in s1 and s2 relative to the variable x: and, for every state in executions (s1 , m1 )  (s1 , m1i+1 ) and y  Imp(x), 11 (y ) = 21 (y ).  (s2 , m2 )  (s2 , m2i+1 ) the loop counters for s1 and s2 are We show that the imported variables in S1 relative to those less than or equal to i + 1 respectively: in Imp(x) are a subset of Imp(x).  i+1 , (s1 , m1i+1 ), (s2 , m2i+1 ) : (s1 , m1 )  (s1 , m1i+1 (loop1 c  Imp(S1 , Imp(x)) 2i+1 1i+1 ))  (s2 , m2 )  (s2 , m2i+1 (loopc , 2i+1 )) where = Imp(S1 , Imp(s1 , {x}  Use(e))) by the definition of Imp(x) i+1 i+1 · loop1 (n1 ) = loop2 (n2 ) = i + 1; and j c c = Imp(S1 , j 0 Imp(S1 , {x}  Use(e))) · y  Imp(x), 1i+1 (y ) = 2i+1 (y ); and by the definition of imported variables
j = j 0 Imp(S1 , Imp(S1 , {x}  Use(e))) by Lemma C.2 j = j>0 Imp(S1 , {x}  Use(e)) by Lemma C.1 j  j 0 Imp(S1 , {x}  Use(e)) = Imp(s1 , {x}  Use(e)) = Imp(x).   1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc )) 


2







  2 · m 2 : (s2 , m2 )  (S2 , m2 (loopc )) 
i+1 ,  (s2 , m2i+1 (loop2 2i+1 )), c

1 i+1 ,  (s1 , m1i+1 (loop1 1i+1 )), loopc (n1 )  i + 1; and c 




 loop2 c (n2 )

Similarly, Imp(S2 , Imp(x))  Imp(x). Consequently, the value stores 11 and 21 agree on the values of the imported variables in S1 and S2 relative to those in Imp(x), y  Imp(S1 , Imp(x))  Imp(S2 , Imp(x)), 1 (y ) = 2 (y ). Because S1 and S2 have computation of every variable in Imp(x) equivalently when started in states agreeing on the values of the imported variables relative to Imp(x), then value store 11 and 21 agree on the values of the variables Imp(x), y  Imp(x), 11 (y ) = 21 (y ). It follows that, by corollary E.1,  11 (S1 ; s1 , m1 (loop1 c [1/n1 ], 1 ))  (s1 , m11 (loopc , 11 )) and  2 21 (S2 ; s2 , m2 (loopc [1/n2 ], 2 ))  (s2 , m21 (loopc , 21 )). Induction Step.

 i + 1.

By the hypothesis IH, one of the following holds: 1. The loop counters for s1 and s2 are always less than i:  1    m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc ) and (s2 , m2 )    2  (S2 , m 2 (loopc )),  1 loopc (n1 ) < i and loop2 c (n2 ) < i; When this case holds, then we have the loop counters for s1 and s2 are always less than i + 1:     1 m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc ) and (s2 , m2 )    2  (S2 , m 2 (loopc )),  1 loopc (n1 ) < i + 1 and loop2 c (n2 ) < i + 1. 2. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop counters of s1 and s2 are equal to i and value stores agree on the

15

2015/9/14

· in any state in the executions values of imported variables relative to x and, for every state in    i+1 , 2i+1 )), the loop (s2 , m2i )  (s2 , m2i+1 (loop2 executions (s1 , m1 )  (s1 , m1i ) and (s2 , m2 )  (s2 , m2i ) c counter of s2 is less than or equal to i + 1. the loop counters for s1 and s2 are less than or equal to i respectively: With the hypothesis IH, there are two configurations (s1 , m1i+1 )  i and (s2 , m2i+1 ) reachable from (s1 , m1 ) and (s2 , m2 ), re(s1 , m1i ), (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (loop1 c , 1i ))   i ,  )) where spectively, in which the loop counters of s1 and s2 are equal (s2 , m2 )  (s2 , m2i (loop2 2 i c 2i to i + 1 and value stores agree on the values of imported i · loop1 ( n ) = loop ( n ) = i ; and 1 2 c c variables relative to x and, for every state in executions · y  Imp(x), 1i (y ) = 2i (y ); and   (s1 , m1 )  (s1 , m1i+1 ) and (s2 , m2 )  (s2 , m2i+1 ) the      1 1i · m1 : (s1 , m1 )  (S1 , m1 (loopc )  (s1 , m1i (loopc , loop counters for s1 and s2 are less than or equal to i + 1  , 1i )), loop1 respectively: c (n1 )  i; and     2 2i (s1 , m1i+1 ), (s2 , m2i+1 ) : · m : ( s , m )  ( S , m ( loop ( loop , ))  ( s , m 2 2 2 2 2 2 2 i c c   i+1 , 1i+1 )) ( s1 , m1 )  (s1 , m1i+1 (loop1 ), 2i )), loop2 ( n )  i . 2 c c  2i+1 By similar argument in base case, evaluations of the predicate (s2 , m2 )  (s2 , m2i+1 (loopc , 2i+1 )) where expression of s1 and s2 w.r.t value stores 1i and 2i produce i+1 (n ) = loop2i+1 (n ) = i + 1; and · loop1 1 2 c c same value. Then there are two possibilities: · ( y ) =   y  Imp ( x ) ,  2i+1 (y ); and 1 i+1 (a) E  e 1i = E  e 2i = (0, vof )     1 · m 1 : ( s , m )  ( S , m 1 1 1 1 1 (loopc ))  The execution from (s1 , m1 (loopc , 1 )) proceeds as fol1 1i+1 (s1 , m1i+1 (loopc , 1i+1 )), loopc (n1 )  i +1; and lows.     2 1i · m (s1 , m1i (loopc , 1i )) 2 : (s2 , m2 )  (S2 , m2 (loopc ))  1i 2 2i+1 = (while n1 (e) {S1 }, m1i (loopc , 1i )) (s2 , m2i+1 (loopc , 2i+1 )), loopc (n2 )  i + 1. i (while n1 ((0, vof )) {S1 }, m1i (loop1 c , 1i )) by the EEval' rule i (while n1 (0) {S1 }, m1i (loop1 c , 1i )) by the E-Oflow1 and E-Oflow2 rule i (skip, m1i (loop1 Lemma 5.2. Let s1 = "while n1 (e) {S1 }" and s2 = "while n2 (e) c [0/n1 ], 1i )) by the Wh-F rule. {S2 }" be two while statements with the same set of imported variBy the hypothesis IH, the loop counter of s1 and s2 in any  i ables relative to a variable x (defined in s1 and s2 ), and whose loop )) ,  configuration in executions (s1 , m1 )  (s1 , m1i (loop1 1 i c  bodies S1 and S2 terminatingly compute the variables in Imp(x) i )) respectively are ,  and (s2 , m2 )  (s2 , m2i (loop2 2 i c equivalently when started in states that agree on the values of the less than or equal to i,  variables imported by S1 or S2 relative to Imp(x):   1    1i m1 : (s1 , m1 )  (S1 , m1 (loopc )  (s1 , m1i (loopc ,  · x  Def(s1 )  Def(s2 ); , 1i )), loop1 c (n1 )  i; and   2    2i · Imp(s1 , {x}) = Imp(s2 , {x}) = Imp(x); m2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2i (loopc , · y  Imp(x) mS1 (S1 ) mS2 (S2 ) : 2 ), 2i )), loopc (n2 )  i. ((z  Imp(S1 , Imp(x))Imp(S2 , Imp(x)), S1 (z ) = S2 (z ))  Therefore, the loop counter of s1 and s2 in any configura(( S1 , mS1 (S1 )) y (S2 , mS2 (S2 ))). tion in executions  i )) and \ { ( n ) } ,  (s1 , m1 )  (skip, m1i (loop1 1 1 If the executions of s1 and s2 terminate when started in i c  2 i (s2 , m2 )  (skip, m2i (loop2 states m1 (loop1 c [0/n2 ], 2i )) respectively c , 1 ) and m2 (loopc , 2 ) in which s1 and s2 are less than i + 1. have not already executed (loop counter initially 0: loop1 c (n1 ) = (b) E  e 1i = E  e 2i = v = 0 loop2 c (n2 ) = 0), and whose value stores 1 and 2 agree on i the values of the variables in Imp(x), y  Imp(x) 1 (y ) = The execution from (s1 , m1i (loop1 c , 1i )) proceeds as fol  lows. )) 2 (y ), when s1 and s2 terminate, (s1 , m1 )  (skip, m1i (1  1i    (s1 , m1i (loopc , 1i )) and (s2 , m2 )  (skip, m2i (2 )), value stores 1 and 2 agree on   i the value of x, 1 ( x ) = 2 (x ). = (while n1 (e) {S1 }, m1i (loop1 c , 1i )) 1i (while n1 (v ) {S1 }, m1i (loopc , 1i )) by the EEval' rule i (S1 ; while n1 (e) {S1 }, m1i (loop1 Proof. We show that there must exist a finite integer k such that the c [i + 1/(n1 )] , 1i )) by the Wh-T rule. loop counters of s1 and s2 in executions started in states m1 and 2 m2 is always less than k. By the definition of terminating execui Similarly, (s2 , m2i (loop2 c , 2i ))  (S2 ; while n2 (e){S2 }, tion, there are only finite number of steps in executions of s1 and 2i m2i (loopc [i + 1/(n2 )], 2i )). s2 started in states m1 and m2 respectively. Then, by Lemma E.8, By similar argument in base case, the executions of S1 there must be a finite integer k such that the loop counter of s1 and 1i and S2 terminate when started in states m1i (loopc [i + s2 is always less than k. In the following, we consider k be the i 1/(n1 )], , 1i ) and m2i (loop2 c [i + 1/(n2 )], 2i ) respecsmallest positive integer such that the loop counter of s1 and s2 in  i tively, (S1 ; s1 , m1i (loop1 executions started in states m1 and m2 is always less than k. c [i + 1/(n1 )], 1i ))  i i+1 , 1i+1 )) and (S2 ; s1 , m2i (loop2 (s1 , m1i+1 (loop1 By Lemma 5.1, there are two possibilities: c [i + c  i+1 )) such that ,  1/(n2 )], 2i ))  (s2 , m2i+1 (loop2 2i+1 c 1. The loop counters for s1 and s2 are always less than 1 (k = 1): all of the following holds:     1 i+1 (n ) = loop2i+1 (n ) = i + 1; and · loop1 m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 ) 1 2 c c     2 · y  Imp(x), 1i+1 (y ) = 2i+1 (y ), and  (S2 , m2 (loopc )),  2 · in any state in the execution loop1 c (n1 ) < 1 and loopc (n2 ) < 1;  1i+1 (s1 , m1i )  (s1 , m1i+1 (loopc , 1i+1 )), the loop By the proof in base case of Lemma 5.1, the execution of s1 counter of s1 is less than or equal to i + 1. proceeds as follows:

16

2015/9/14

(s 1 , m 1 ) = (while n1 (e) {S1 }, m1 (loop1 c , 1 )) (while n1 (0) {S1 }, m1 (loop1 c , 1 )) by the EEval' rule (skip, m1 (loop1 c [0/(n1 )], 1 )) by the Wh-F rule. Similarly, the execution of s2 proceeds to   (skip, m2 (loop2 c [0/n2 ], 2 )). Therefore, 1 = 1 and 2 = 2 . By the definition of imported variables, x  Imp(s1 , {x}). By assumption, value stores 1 and 2 agree on the value of x,   1 ( x ) = 1 ( x ) = 2 ( x ) = 2 (x). The lemma holds. 2. For some finite positive k(> 1), both of the following hold: · The loop counters for s1 and s2 are always less than k :     1 m 1 , m2 such that (s1 , m1 )  (S1 , m1 (loopc ) and    2 (s 2 , m 2 )  (S2 , m 2 (loopc )), 1 2 loopc (n1 ) < k and loopc (n2 ) < k; · There are two configuration (s1 , m1k-1 ) and (s2 , m2k-1 ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop counters of s1 and s2 are equal to k - 1 and value stores agree on the values of imported variables  relative to x and, for every state in execution, (s1 , m1 )   (s1 , m1k-1 ) or (s2 , m2 )  (s2 , m2k-1 ) the loop counters for s1 and s2 are less than or equal to k - 1 respectively: (s1 , m1k-1 ), (s2 , m2k-1 ) : 1  (s1 , m1 )  (s1 , m1k-1 (loopck-1 , 1k-1 )) 2k-1  , 2k-1 )) where (s2 , m2 )  (s2 , m2k-1 (loopc
  1 m 1 : (s1 , m1 )  (S1 , m1 (loopc )   1k-1 , 1k-1 )), loop1 (s1 , m1k-1 (loopc c (n1 )  k - 1; and     2 m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  2k-1 2 , 2k-1 )), loopc (n2 )  k - 1; (s2 , m2k-1 (loopc By proof of Lemma 5.1, value stores 1k-1 and 2k-1 agree on the values of the variables in Use(e). By Lemma D.1, E  e 1k-1 = E  e 2k-1 = v . Because the loop counter of s1 and s2 is less than k in executions of s1 and s2 when started in states m1 and m2 , then by our semantic rules, the predicate expression of s1 and s2 must evaluate to zero w.r.t value stores 1k-1 and 2k-1 , E  e 1k-1 = E  e 2k-1 = (0, vof ). Then the execution of s1 proceeds as follows.

Proof. By induction on size(S1 )+size(S2 ), the sum of the program size of S1 and S2 . Base case. S1 and S2 are simple statement. Then the proof is a case analysis according to the cases in the definition of the proof rule of computation equivalently for simple statements. 1. S1 = S2 By the definition of imported variables, same statement have same imported variables relative to same x. 2. S1 = S2 There are two further cases: · S1 = "input id1 ", S2 = "input id2 " and x  / {id1 , id2 }. When x = idI , by the definition of imported variables, Imp(S1 , {idI }) = Imp(S2 , {idI }) = {idI }. When x = idIO , by the definition of imported variables, Imp(S1 , {idIO }) = Imp(S2 , {idIO }) = {idI , idIO }. When x  / {idI , idIO }, by the definition of imported variables, Imp(S1 , {x}) = Imp(S2 , {x}) = {x}. · the above cases do not hold and x  / Def(S1 )  Def(S2 ). By the definition of imported variables, Imp(S1 , {x}) = Imp(S2 , {x}) = {x}. Induction Step. The hypothesis IH is that the lemma holds when size(S1 ) + size(S2 ) = k  2. Then we show the lemma holds when size(S1 )+ size(S2 ) = k +1. The proof is a case analysis based on the cases in the definition of the proof rule of computation equivalently for statement sequence, S1  S x S2 : 1. S1 and S2 are one statement such that one of the following holds: (a) S1 and S2 are If statement that define the variable x: f t t } }else {S1 }", S2 = "If (e) then {S2 S1 = "If (e) then {S1 f else {S2 }" such that all of the following hold: · x  Def(S1 )  Def(S2 ); t t · S1 S x S2 ; f f S · S1  x S2 ; t By the hypothesis IH, the imported variables in S1 and t t t S2 relative to x are same, Imp(S1 , {x}) = Imp(S2 , {x}). f f Similarly, Imp(S1 , {x}) = Imp(S2 , {x}). By the definition of imported variables, Imp(S1 , {x}) = Use(e)  f t Imp(S1 , {x})  Imp(S1 , {x}). Similarly, Imp(S2 , {x}) f t = Use(e)Imp(S2 , {x})Imp(S2 , {x}). Then, the lemma holds. (b) S1 and S2 are while statement that define the variable x:   S1 = "while n1 (e) {S1 }", S2 = "while n2 (e) {S2 }" such that both of the following hold: · x  Def(S1 )  Def(S2 );   · y  Imp(S1 , {x})  Imp(S2 , {x}), S1 S y S2 ; By the definition of imported variables, Imp(S1 , {x}) =  i i0 Imp(S1 , {x}  Use(e)). Similarly, Imp(S2 , {x}) =
 

loopck-1 (n1 ) = loopck-1 (n2 ) = k - 1; and y  Imp(x) : 1k-1 (y ) = 2k-1 (y ); and



1

2



(while n1 (e) {S1 }, m1k-1 (loopck-1 , 1k-1 )) 1 (while n1 ((0, vof )) {S1 }, m1k-1 (loopck-1 , 1k-1 )) by the EEval' rule 1 (while n1 (0) {S1 }, m1k-1 (loopck-1 , 1k-1 )) by the E-Oflow1 or E-Oflow2 rule 1 (skip, m1k-1 (loopck-1 [0/n1 ], 1k-1 )) by the Wh-F rule. Similarly, the execution of s2 proceeds to 2  = 2k-1 , (skip, m2k-1 (loopck-1 [0/n2 ], 2k-1 )). Therefore, 2  1 = 1k-1 . By the definition of imported variables, x   Imp(x). In conclusion, 2 (x) = 2k-1 (x) = 1k-1 (x) =  1 (x ).

1

i0

Lemma 5.3. If two statement sequences S1 and S2 satisfy the proof rule of terminating computation of a variable x equivalently, then S1 and S2 have same imported variables relative to x: (S1 S x S2 )  (Imp(S1 , {x}) = Imp(S2 , {x})).
17

Use(e)) = Imp(S2 i , {x}  Use(e)) by induction on i. Base case.   By our assumption of the notation S 0 , S1 0 = skip, S2 0 = skip.   Then, Imp(S1 0 , {x}Use(e)) = {x}Use(e), Imp(S2 0 , {x} Use(e)) = {x}  Use(e).   Hence, Imp(S1 0 , {x}Use(e)) = Imp(S2 0 , {x}Use(e)). Induction step.

Imp(S2 i , {x}Use(e)). Then, we show that Imp(S1 i , {x} 


2015/9/14

The hypothesis IH2 is that Imp(S1 i , {x}  Use(e)) =  Imp(S2 i , {x}  Use(e)) for i  0.   Then we show that Imp(S1 i +1 , {x}Use(e)) = Imp(S2 i +1 , {x} Use(e)). Imp(S1 i +1 , {x}  Use(e))   = Imp(S1 , Imp(S1 i , {x}  Use(e))) (1) by corollary C.1
 



Imp(S2 i +1 , {x}  Use(e))   = Imp(S2 , Imp(S2 i , {x}  Use(e))) (2) by corollary C.1
 

2. S1 and S2 are not both one statement such that one of the following holds: (a) Last statements both define the variable x such that all of the following hold:   · y  Imp(s1 , {x})  Imp(s2 , {x}), S1 S y S2 ; · x  Def(s1 )  Def(s2 ); · s1 S x s2 ; By the hypothesis IH, we have Imp(s1 , {x}) = Imp(s2 , {x}) = Imp(). Then, by the hypothesis IH again, we have that  , {y }) y  Imp() = Imp(s1 , {x}) = Imp(s2 , {x}), Imp(S1  = Imp(S2 , {y }). By taking the union of all y  Imp(),    Imp(S1 , {y }) and Imp(S2 , {y }), by the Lemma C.2, Imp(S1 ,  Imp()) = Imp(S2 , Imp()). By the definition of imported variables,  , Imp(s1 , {x})), Imp(S2 , {x}) = Imp(S1 , {x}) = Imp(S1  Imp(S2 , Imp(s2 , {x})). Therefore, the lemma holds. (b) One last statement does not define the variable x: w.l.o.g.,  x / Def(s1 )  (S1 S x S2 ) ; By the definition of imported variables, we have Imp(s1 , {x})  = {x}. By the hypothesis IH, Imp(S1 , {x}) = Imp(S2 , {x}) Therefore, by the definition of imported variables, Imp(S1 , {x})   , {x}) = Imp(S2 , {x}). , Imp(s1 , {x})) = Imp(S1 = Imp(S1 (c) There are statements moving in/out of If statement: f t t s1 = "If (e) then {S1 } else {S1 }", s2 = "If (e) then {S2 } f else {S2 }" such that none of the above cases hold and all of the following hold:   · y  Use(e), S1 S y S2 ;  t S  t · S1 ; S1  x S2 ; S2 ; f f   · S1 ; S1 S x S2 ; S2 ; · x  Def(s1 )  Def(s2 ); We show all of the following hold.   i. Imp(S1 , Use(e)) = Imp(S2 , Use(e)). By the hypothesis IH and the assumption that y    Use(e), S1 S y S2 . Then, by Lemma C.2,   Imp(S1 , Use(e)) = Imp(S2 , Use(e)).
18

Imp(S1 i , {x}  Use(e)) = Imp(S2 i , {x}  Use(e)) by the hypothesis IH2   Imp(S1 , Imp(S1 i , {x}  Use(e)))   = Imp(S2 , Imp(S2 i , {x}  Use(e))) by the hypothesis IH  Imp(S1 i +1 , {x}  Use(e))  = Imp(S2 i +1 , {x}  Use(e)) by (1),(2)   Therefore, Imp(S1 i +1 , {x} Use(e)) = Imp(S2 i +1 , {x} Use(e)). In conclusion, Imp(S1 , {x}) = Imp(S2 , {x}). The lemma holds. (c) S1 and S2 do not define the variable x: x  / Def(S1 )  Def(S2 ). By the definition of imported variable, the imported variables in S1 and S2 relative to x is x, Imp(S1 , {x}) = Imp(S2 , {x}) = {x}. The lemma holds.

 t  t ii. Imp(S1 , Imp(S1 , {x})) = Imp(S2 , Imp(S2 , {x})). Because size("If(e) then {St } else {Sf }") = 1 + size(St ) + size(Sf ), then  t  t size(S1 ; S1 ) + size(S2 ; S2 ) < k. By the hypothesis IH,  t  t Imp(S1 ; S1 , {x}) = Imp(S2 ; S2 , {x}). Besides, by Lemma C.1,  t  t Imp(S1 , Imp(S1 , {x})) = Imp(S1 ; S1 , {x})  t  t = Imp(S2 ; S2 , {x}) = Imp(S2 , Imp(S2 , {x})). f f   iii. Imp(S1 , Imp(S1 , {x})) = Imp(S2 , Imp(S2 , {x})). By similar argument in the case that  t  t Imp(S1 , Imp(S1 , {x})) = Imp(S2 , Imp(S2 , {x})). Then, by combining things together, Imp(S1 , {x})  = Imp(S1 , Imp(s1 , {x})) by the definition of imported variables f  t = Imp(S1 , Imp(S1 , {x})  Imp(S1 , {x})  Use(e)) by the definition of imported variables f  t  = Imp(S1 , Imp(S1 , {x}))  Imp(S1 , Imp(S1 , {x}))  Imp(S1 , Use(e)) by Lemma C.2 f  t  = Imp(S2 , Imp(S2 , {x}))  Imp(S2 , Imp(S2 , {x}))  Imp(S2 , Use(e)) by i, ii, iii f  t = Imp(S2 , Imp(S2 , {x})  Imp(S2 , {x})  Use(e)) by Lemma C.2 f  t = Imp(S2 , Imp(S2 , {x})  Imp(S2 , {x})  Use(e)) by the definition of imported variables  = Imp(S2 , Imp(s2 , {x})) by the definition of imported variables = Imp(S2 , {x}). Hence, the lemma holds.

5.3 Termination in the same way We proceed to propose a proof rule under which two statement sequences either both terminate or both do not terminate. We start by giving the definition of termination in the same way. Then we present the proof rule of termination in the same way. Our proof rule of termination in the same way allows updates such as statement duplication or reordering, loop fission or fusion and additional terminating statements. We prove that the proof rule ensures terminating in the same way by induction on the program size of the two programs in the proof rule. We also list auxiliary lemmas required by the proof of termination in the same way. Definition 14. (Termination in the same way) Two statement sequences S1 and S2 terminate in the same way when started in states m1 and m2 respectively, written (S1 , m1 ) H (S2 , m2 ), iff one of the following holds: 2. i  0, (S1 , m1 )  i i where S1 = skip, S2 = skip.
 1. (S1 , m1 )  (skip, m 1 ) and (S2 , m2 )  (skip, m2 ); i i (S1 , mi 1) i   i and (S2 , m2 )  (S2 , mi 2)

5.3.1 Proof rule for termination in the same way We define proof rules under which two statement sequences S1 and S2 terminate in the same way. We summarize the cause of nonterminating execution and then give the proof rule. We consider two causes of nonterminating executions: crash and infinite iterations of loop statements. As to crash [? ], we consider four common causes based on our language: expression evaluation exceptions, the lack of input value, input/assignment value type mismatch and array index out of bound. In essence, the causes of nontermination are partly due to the values of some particular variables during executions. We capture variables affecting each

2015/9/14

source of nontermination; loop deciding variables LVar(S ) are variables affecting the evaluation of a loop statements in the statement sequence S , crash deciding variables CVar(S ) are variables whose values decide if a crash occurs in S . We list the definitions of LVar(S ) and CVar(S ) in Definition 15 and 16. Definition 17 summarizes the variables whose values decide if one program terminates. Definition 15. (Loop deciding variables) The loop deciding variables of a statement sequence S , written LVar(S ), are defined as follows: 1. LVar(S ) =  if s = "while(e) {S  }" and s  S ; 2. LVar("If (e) then {St } else {Sf }") = Use(e)  LVar(St )  LVar(Sf ) if "while(e){S  }"  S ; 3. LVar("while(e){S  }") = Imp(S, Use(e)  LVar(S  )); 4. For k > 0, LVar(s1 ; ...; sk ; sk+1 ) = LVar(s1 ; ...; sk )  Imp(s1 ; ...; sk , LVar(sk+1 )); Definition 16. (Crash deciding variables) The crash deciding variables of a statement sequence S , written CVar(S ), are defined as follows: 1. CVar(skip) = ; 2. CVar(lval := e) = Idx(lval)  Use(e) if (  lval : Int)  (  e : Long); 3. CVar(lval := e) = Idx(lval)Err(e) if (  lval : Int)(  e : Long) does not hold; 4. CVar(input id) = {idI }; 5. CVar(output e) = Err(e); 6. CVar("If (e) then {St } else {Sf }") = Err(e), if CVar(St )  CVar(Sf ) = ; 7. CVar("If (e) then {St } else {Sf }") = Use(e)  CVar(St )  CVar(Sf ), if CVar(St )  CVar(Sf ) = ; 8. CVar("while n (e){S  }") = Imp("while n (e){S  }", Use(e)  CVar(S  )); 9. For k > 0, CVar(s1 ; ...; sk+1 ) = CVar(s1 ; ...; sk )  Imp(s1 ; ...; sk , CVar(sk+1 )); Definition 17. (Termination deciding variables) The termination deciding variables of statement sequence S are CVar(S )LVar(S ), written TVar(S ). Definition 18. (Base cases of the proof rule of termination in the same way) Two simple statements s1 and s2 satisfy the proof rule of termination in the same way, written s1 S H s2 , iff one of the following holds: 1. s1 and s2 are same, s1 = s2 ; 2. s1 and s2 are input statement with same type variable: s1 = "input id1 ", s2 = "input id2 " where (s1  id1 :  )  (s2  id2 :  ); 3. s1 = "output e" or "id1 := e", s2 = "output e" or "id2 := e" where both of the following hold: · There is no possible value mismatch in "id1 := e", ¬(s1  id1 : Int)  ¬(s1  e : Long)  (s1  e : Int). · There is no possible value mismatch in "id2 := e", ¬(s2  id2 : Int)  ¬(s2  e : Long)  (s2  e : Int). Definition 19. (proof rule of termination in the same way) Two statement sequences S1 and S2 satisfy the proof rule of termination in the same way, written S1 S H S2 , iff one of the following holds:

f f t t i. S1 , S1 , S2 , S2 are all sequences of "skip"; f f t t ii. At least one of S1 , S1 , S2 , S2 is not a sequence of f f t t S "skip" such that: (S1 S S ) 2  (S1  H S2 ); H   (c) S1 = "while n1 (e){S1 }", S2 = "while n2 (e){S2 }" and both of the following hold:   · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(S1 ) 

TVar(S2 ); 2. S1 and S2 are not both one statement and one of the following holds:   (a) S1 = S1 ; s1 and S2 = S2 ; s2 and all of the following hold:
  · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(s1 ) 

TVar(s2 );

(b) One last statement is "skip":    (S1 = S1 ; "skip")(S1 S H S2 )  (S2 = S2 ; "skip")  (S1  S S ) . 2 H (c) One last statement is a "duplicate" statement and one of the following holds:   i. S1 = S1 ; s 1 ; S1 ; s1 and all of the following hold:    · S1 ; s 1 ; S1  S H S2 ; S · (s  1 H s1 )  (s1 = "skip");  · Def(s 1 ; S1 )  TVar(s1 ) = ;    ; s2 and all of the following hold: ii. S2 = S2 ; s2 ; S2 S   · S1  H S2 ; s  2 ; S2 ;  S · (s2 H s2 )  (s2 = "skip");  · Def(s 2 ; S2 )  TVar(s2 ) = ;    ; s2 ; s (d) S1 = S1 ; s1 ; s1 and S2 = S2 2 where s1 and s2 are reordered and all of the following hold:
  · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(s1 ; s 1 )

· s1 S H s2 where s1 and s2 are not "skip";

· · · ·

TVar(s2 ; s 2 ).  s1 S H s2 ; S s 1 H s2 ; Def(s1 )  TVar(s 1 ) = ; Def(s2 )  TVar(s 2 ) = ;

5.3.2 Soundness of the proof rule for termination in the same way We show that two statement sequences satisfy the proof rules of termination in the same way, and their initial states agree on the values of their termination deciding variables, then they either both terminate or both do not terminate. Theorem 3. If two simple statements s1 and s2 satisfy the proof rule of termination in the same way, s1 s H s2 , and their initial states m1 (f1 , 1 ) and m2 (f2 , 2 ) with crash flags not set, f1 = f2 = 0, and whose value stores agree on values of the termination deciding variables of s1 and s2 , x  TVar(s1 )  TVar(s2 ) : 1 (x) = 2 (x), when executions of s1 and s2 start in states m1 and m2 respectively, then s1 and s2 terminate in the same way when started in states m1 and m2 respectively: (s1 , m1 ) H (s 2 , m 2 ). Proof. The proof is a case analysis of those cases in the definition of s1 s H s2 . Because s1 is a simple statement and s1 's execution is without function call, we only care the crash variables of s1 in the termination deciding variables of s1 , CVar(s1 ). Similarly, we only care CVar(s2 ).

1. S1 and S2 are both one statement and one of the following holds. (a) S1 and S2 are simple statements: s1 S H s2 ; f t t (b) S1 = "If(e) then {S1 } else {S1 }", S2 = "If(e) then {S2 } f else {S2 }" and one of the following holds:
19

2015/9/14

First s1 and s2 are same: s1 = s2 ; We show the theorem by induction on abstract syntax of s1 and s2 . 1. s1 = s2 = skip. By definition of termination in the same way, both s1 and s2 terminate. The theorem holds. 2. s1 = s2 = "lval := e". There are further cases regarding what lval is. (a) lval = id. By definition, CVar(s1 ) = CVar(s2 ) = Err(e) or Use(e) based on if there is possible value mismatch (e.g., assigning value defined only in type Long to a variable of type Int). There are two subcases. · Left value id is of type Int and expression e is of type Long but not type Int, (  id : Int)  (  e : Long)  ¬(  e : Int). By definition, CVar(s1 ) = CVar(s2 ) = Use(e). By assumption, x  Use(e), 1 (x) = 2 (x). By Lemma D.1, the expression evaluates to the same value w.r.t two pairs of value stores 1 and 2 respectively, Both evaluations of expression lead to crash, E e 1 = E e 2 = (error, vof ). Then the execution of s1 is as follows: (s 1 , m 1 ) = (id := e, m1 (1 )) (id := (error, ), m1 (1 )) by rule EEval' (id := 0, m1 (1/f)) by rule ECrash. i (id := 0, m1 (1/f)) for any i > 0 by rule Crash. Similarly, s2 does not terminate. The theorem holds. Both evaluations of expression lead to no crash, E e 1 = E e 2 = (v, vof ). Then there are cases regarding if value mismatch occurs.  The value v is only defined in type Long, (  v : Long)  ¬(  v : Int). The execution of s1 is as follows: (s 1 , m 1 ) = (id := e, m1 (1 )) (id := (v, vof ), m1 (1 )) by rule EEval (id := v, m1 (1 )) by rule EOflow-1 or EOflow-2. (id := v, m1 (1/f)) by rule Assign-Err. i (id := v, m1 (1/f)) for any i > 0 by rule Crash. Similarly, s2 does not terminate. The theorem holds.  The value v is defined in type Int,   v : Int. Assuming that the variable id is a global one, the execution of s1 is as follows: (s 1 , m 1 ) = (id := e, m1 (1 )) (id := (v, vof ), m1 (1 )) by rule EEval (id := v, m1 (1 )) by rule EOflow-1 or EOflow-2. (skip, m1 (1 (1 [v/id]))) by rule Assign. Similarly, s2 terminate. The theorem holds. When the variable id is a local variable, by similar argument for the global variable, we can show that s1 and s2 terminate. Then the theorem holds. · It is not the case that left value id is of type Int and the expression e is of type Long only, ¬ (  id : Int)  (  e : Long) ¬(  e : Int) . There are two cases based on if there is crash in evaluation of expression e.

Both evaluations of expression lead to crash, E e 1 = E e 2 = (error, vof ). By the same argument in case where left value id is of type Int and the expression e is of type Long only, this  theorem holds. Both evaluations of expression lead to no crash, E e 1 = E e 2 = (v, vof ). By the same argument in subcase of no value mismatch in case where left value id is of type Int and the expression e is of type Long only, this theorem holds. (b) lval = id[n]. There are two subcases based on if n is within the array bound of id. By our assumption, array variable id is of the same bound in two programs. W.l.o.g., we assume id is local variable. i. n is out of bound of array variable id, ((id, n)  v1 )  / 1 and ((id, n)  v2 )  / 2 ; Then the execution of s1 continues as follows: (s 1 , m 1 ) = (id[n] := e, m1 (1 )) (id[n] := e, m1 (1/f) by rule Arr-3 i (id[n] := e, m1 (1/f)) by rule Crash. Similarly, s2 does not terminate. The theorem holds. ii. n is within the bound of array variable id, ((id, n)  v1 )  1 and ((id, n)  v2 )  2 ; There are cases of CVar(s1 ) and CVar(s2 ) based on if there is possible value mismatch exception in s1 and s2 . · Left value id[n] is of type Int and expression e is of type Long but not type Int, (  id[n] : Int)  (  e : Long)  ¬(  e : Int). By definition, CVar(s1 ) = CVar(s2 ) = Use(e). By assumption, x  Use(e), 1 (x) = 2 (x). By Lemma D.1, the expression evaluates to the same value w.r.t two value stores 1 and 2 respectively, Both evaluations of expression lead to crash, E e 1 = E e 2 = (error, vof ). Then the execution of s1 is as follows: (s 1 , m 1 ) = (id[n] := e, m1 (1 )) (id[n] := (error, ), m1 (1 )) by rule EEval' (id[n] := 0, m1 (1/f)) by rule ECrash. i (id[n] := 0, m1 (1/f)) for any i > 0 by rule Crash. Similarly, s2 does not terminate. The theorem holds. Both evaluations of expression lead to no crash, E e 1 = E e 2 = (v, vof ). Then there are cases regarding if value mismatch occurs.  The value v is only defined in type Long, (  v : Long)  ¬(  v : Int). The execution of s1 is as follows: (s 1 , m 1 ) = (id[n] := e, m1 (1 )) (id[n] := (v, vof ), m1 (1 )) by rule EEval' (id[n] := v, m1 (1 )) by rule EOflow-1 or EOflow-2. (id[n] := v, m1 (1/f)) by rule Assign-Err. i (id[n] := v, m1 (1/f)) for any i > 0 by rule Crash.



20

2015/9/14

Similarly, s2 does not terminate. The theorem holds.  The value v is defined in type Int,   v : Int. The execution of s1 is as follows: (s 1 , m 1 ) = (id[n] := e, m1 (1 )) (id[n] := (v, vof ), m1 (1 )) by rule EEval' (id[n] := v, m1 (1 )) by rule EOflow-1 or EOflow-2. (skip, m1 (1 (1 [v/(id, n)]))) by rule Assign-A. Similarly, s2 terminate. The theorem holds. When the variable id is a global variable, by similar argument for the global variable, we can show that s1 and s2 terminate. Then the theorem holds. · It is not the case that left value id is of type Int and the expression e is of type Long only, ¬ (  id : Int)  (  e : Long)  ¬(  e : Int) . There are two cases based on if there is crash in evaluation of expression e. Both evaluations of expression lead to crash, E e 1 = E e 2 = (error, vof ). By the same argument in case where left value id is of type Int and the expression e is of type Long only, this theorem holds. Both evaluations of expression lead to no crash, E e 1 = E e 2 = (v, vof ). By the same argument in subcase of no value mismatch in case where left value id is of type Int and the expression e is of type Long only, this theorem holds. If array variable id is a global variable, by similar argument above, the theorem holds. (c) lval = id1 [id2 ]. By definition, Idx(s1 ) = Idx(s2 ) = {id2 }  CVar(s1 ) = CVar(s2 ). By assumption, 1 (id2 ) = 2 (id2 ) = n. By the same argument in the case where lval = id[n], the theorem holds. 3. s1 = s2 = "input id", By definition, CVar(s1 ) = CVar(s2 ) = {idI }. By assumption 1 (idI ) = 2 (idI ). There are cases regarding if input sequence is empty or not. (a) There is empty input sequence, 1 (idI ) = 2 (idI ) = . Then the execution of s1 continues as follows: (s 1 , m 1 ) = (input id, m1 (1 )) (input id, m1 (1/f)) by rule In-7 i (input id, m1 (1/f)) by rule Crash. Similarly, s2 does not terminate. The theorem holds. (b) There is nonempty input sequence, 1 (idI ) = 2 (idI ) = . There are cases regarding if type of the variable id is Long or not. i. id is of type Long,   id : Long; Assuming id is a local variable, then the execution of s1 continues as follows: (s 1 , m 1 ) = (input id, m1 (1 )) (skip, m1 (1 [vio /id, tl(1 (idI ))/idI , "1 (idIO ) · v io "/idIO ])) by rule In-3. Similarly, s2 terminates. The theorem holds.

When the variable id is a global variable, by similar argument, the theorem holds. ii. id is of type Int or enumeration,   id : Int or enum id ; There are cases regarding if the head of input sequence can be transformed to type of id. Let vio = hd(1 (idI )). · id is of type Int. If vio is not of type Int,   vio : Long and ¬(  vio : Int), then the execution of s1 continues as follows: (s 1 , m 1 ) = (input id, m1 (1 )) (input id, m1 (1/f)) by Rule In-4. i (input id, m1 (1/f)) by Rule crash. Similarly, s2 does not terminate. The theorem holds. If vio is of type Int,   vio : Long and   vio : Int, assuming id is a local variable, then the execution of s1 continues as follows: (s 1 , m 1 ) = (input id, m1 (1 )) (skip, m1 (1 [vio /id, tl(1 (idI ))/idI , "1 (idIO ) · v io "/idIO ])) by Rule In-8. Similarly, s2 terminates. The theorem holds. When id is a global variable, by similar argument, the theorem holds. · If id is of type enum id = {l1 , ..., lk }. If (vio < 1)  (vio > k), then the execution of s1 continues as follows: (s 1 , m 1 ) = (input id, m1 (1 )) (input id, m1 (1/f)) by Rule In-6. i (input id, m1 (1/f)) by Rule crash. Similarly, s2 does not terminate. The theorem holds. When id is a global variable, by similar argument, the theorem holds. If 1  vio  k, assuming id is a local variable, then the execution of s1 continues as follows: (s 1 , m 1 ) = (input id, m1 (1 )) (skip, m1 (1 [lvio /id, tl(1 (idI ))/idI , "1 (idIO ) · v io "/idIO ])) by Rule In-5. Similarly, s2 terminates. The theorem holds. When id is a global variable, by similar argument, the theorem holds. (c) s1 = s2 = "output e"; There are two cases based on if evaluation of expression e crashes. By definition, CVar(s1 ) = CVar(s2 ) = Err(e). By assumption, x  Err(e), 1 (x) = 2 (x). By Lemma D.2, evaluation of the expression e w.r.t two value stores 1 and 2 either both crash or both do not crash. i. There is crash in evaluation of the expression e w.r.t 1 two value stores 1 and 2 , E e 1 = (error, vof ) 2 and E e 2 = (error, vof ). The execution of s1 continues as follows: (s 1 , m 1 ) = (output e, m1 (1 )) 1 (output (error, vof ), m1 (1/f)) by Rule EEval' (output 0, m1 (1/f)) by Rule ECrash. i (output 0, m1 (1/f)) by Rule crash.

21

2015/9/14

Similarly, s2 does not terminate. The theorem holds. ii. There is no crash in evaluation of the expression e 1 w.r.t two value stores 1 and 2 , E e 1 = (v1 , vof ) 2 and E e 2 = (v2 , vof ). According to rule Out-1 and Out-2, there is no exception in transformation of different typed output value. We therefore only show the execution for output value of Int type. The execution of s1 continues as follows: (s 1 , m 1 ) = (output e, m1 (1 )) 1 (output (v1 , vof ), m1 (1/f)) by Rule EEval' 1 (output v1 , m1 (vof /of)) by Rule EOflow-1 or EOflow-2. (skip, m1 (1 [" (idIO ) · v 1 "/idIO ])) by Rule Out-1. Similarly, s2 terminates. Theorem holds. Second s1 and s2 are input statement with same type variable: s1 = "input id1 ", s2 = "input id2 " where (s1  id1 : t)  (s2  id2 : t); The theorem holds by similar argument for the case s1 = s2 = input id. Third s1 = "output e" or "id1 := e", s2 = "output e" or "id2 := e" where both of the following hold: · There is no possible value mismatch in "id1 := e", ¬(s1  id1 : Int)  ¬(s1  e : Long)  (s1  e : Int). · There is no possible value mismatch in "id2 := e", ¬(s2  id2 : Int)  ¬(s2  e : Long)  (s2  e : Int). We show that the evaluations of the expression e w.r.t the value stores 1 and 2 either both raise an exception or both do not. By the definition of crash variables, the crash variables of s1 are those obtained by the function Err(e), CVar(s1 ) = Err(e). Similarly, the termination deciding variables of s2 are Err(e). By assumption, the initial value stores 1 and 2 agree on values of those in CVar(s1 ) and CVar(s2 ), x  Err(e) = (CVar(s1 )  CVar(s2 )) : 1 (x) = 2 (x). By Lemma D.2, the evaluations of expression e w.r.t two value stores, 1 and 2 , either both raise an exception or both do not raise an exception. 1. The evaluations of the expression e raise an exception w.r.t 1 two value stores 1 and 2 , E  e 1 = (error, vof ) , E  e 2 = 2 (error, vof ): We show the execution of s1 proceeds to an configuration where the crash flag is set and then does not terminate. When s1 = "output e", the execution of "output e" proceeds as follows. (output e, m1 (1 )) 1 (output (error, vof ), m1 (1 )) by rule EEval' (output 0, m1 (1/f)) by rule ECrash i (output 0, m1 (1/f)) for any i  0, by rule Crash. When s1 = "id1 := e", the execution of "id1 := e" proceeds as follows. (id1 := e, m1 (1 )) 1 ), m1 (1 )) by rule EEval' (id1 := (error, vof (id1 := 0, m1 (1/f)) by rule ECrash i (id1 := 0, m1 (1/f)) for any i  0, by rule Crash. Similarly, the execution of s2 proceeds to a configuration where the crash flag is set. Then, by the crash rule, the execution of s2 does not terminate. The theorem 3 holds. 2. the evaluations of expression e do not raise an exception 1 ) , E  e 2 = w.r.t two value stores, 1 and 2 , E  e 1 = (v1 , vof 2 (v2 , vof ): We show the execution of s1 terminates.

When s1 = output (e), the execution of output (e) proceeds as follows. W.l.o.g, we assume expression e is of type Int. This is allowed by the condition that it does not hold that (s1  e : Long)  ¬(s1  e : Int). (output e, m1 (1 )) 1 (output (v1 , vof ), m1 (1 )) by rule EEval' 1 (output v1 , m1 (vof /of, 1 )) by rule E-Oflow1 or E-Oflow2 (skip, m1 (1 ["1 (idIO ) · v ¯ 1 "/idIO ])) by rule Out. When s1 = "id1 := e", by assumption, the expression e is of type Int, there is no possible value mismatch in execution of "id1 := e" because the only possible value mismatch occurs when assigning a value of type Long but not Int to a variable of type Int. By the condition ¬(s1  id1 : Int) ¬(s1  e : Long)  (s2  e : Int), when expression e is of type Long, then the variable id1 is not of type Int. In summary, there is no value mismatch. The execution of "id1 := e" proceeds as follows. (id1 := e, m1 (1 )) 1 (id1 := (v1 , vof ), m1 (1 )) by rule EEval' 1 (id1 := v1 , m1 (vof /of, 1 )) by rule EEval' (skip, m1 (1 [v1 /id1 ])) by the rule Assign. When id1 is a variable of enumeration or Long type, by similar argument, the theorem still holds. Similarly, the execution of s2 terminates when started in the state m2 (2 ). Theorem 3 holds.

Theorem 4. If two statement sequences S1 and S2 satisfy the proof rule of termination in the same way, S1 S H S2 , and their respective initial states m1 (f1 , 1 ) and m2 (f2 , 2 ) with crash flags not set, f1 = f2 = 0, and whose value stores agree on values of the termination deciding variables of S1 and S2 , x  TVar(S1 )  TVar(S2 ) : 1 (x) = 2 (x), then S1 and S2 terminate in the same way when started in states m1 and m2 respectively: (S1 , m1 ) H (S2 , m 2 ). Proof. The proof is by induction on size(S1 ) + size(S2 ), the sum of program size of S1 and S2 . Base case. S1 and S2 are simple statement. By Theorem 3, Theorem 4 holds. Induction step. There are two hypotheses. The hypothesis IH is that Theorem 4 holds when size(S1 ) + size(S2 ) = k  2. We show Theorem 4 holds when size(S1 ) + size(S2 ) = k + 1. The proof of Theorem 4 is a case analysis according to the cases in the definition of the proof rule of termination in the same way, S1  S H S2 . 1. S1 and S2 are one statement and one of the following holds.
f t t (a) S1 = "If(e) then {S1 } else {S1 }", S2 = "If(e) then {S2 } f else {S2 }" such that one of the following holds:

f f t t i. S1 , S1 , S2 , S2 are all sequences of "skip"; We show that the evaluation of expression e w.r.t the value store 1 and 2 either both raise an exception or both do not. By the definition of crash/loop variables, f t CVar(S1 ) = CVar(S1 ) = , LVar(S1 ) = . By the definition of termination deciding variables, the termination deciding variables of S1 is the crash variables of S1 , TVar(S1 ) = CVar(S1 ) = Err(e). By assumption, the value stores 1 and 2 agree on the values of those in the crash variables of S1 and S2 , x  Err(e) = TVar(S1 ) = TVar(S2 ), 1 (x) = 2 (x). By

22

2015/9/14

f f We show that S1 and S2 terminate in the same way when started in the state m1 (1 ) and m2 (2 ) ref f spectively. Because S1 S H S2 , by Corollary 5.1, f f the termination deciding variables of S1 and S2 f f are same, TVar(S1 ) = TVar(S2 ). By the definif tion of crash/loop variables, CVar(S1 )  CVar(S1 ) f and LVar(S1 )  LVar(S1 ). Hence, the terminaf tion deciding variables of S1 are a subset of the f termination deciding variables of S1 , TVar(S1 )  f TVar(S1 ). Similarly, TVar(S2 )  TVar(S2 ). Therefore, the value store 1 and 2 agree on the values of those in the termination deciding variables f f f f f f of S1 and S2 , y  TVar(S1 )  TVar(S2 ) : t t , S2 is not a sequence of , S1 , S2 ii. At least one of S1  ( y ) =  ( y ) . In addition, the sum of program size f f 1 2 t S t S "skip" and (S1 H S2 )  (S1 H S2 ); f f of S and S is less than k because program size t 1 2 W.l.o.g., S1 is not of "skip" only. We show that the t t is great than or equal to one, and S of each of S 2 1 evaluation of the expression e w.r.t the value stores 1 f f size(S1 ) + size(S2 ) < k. As is shown, crash flags and 2 either both raise an exception or both produce f are not set. Therefore, by the hypothesis IH, S1 and the same integer value. Then there is either some loop f t t S2 terminate in the same way when started in state statement in S1 or the crash variables of S1 are not  or f both. m1 (f1 , 1 ) and m2 (f2 , 2 ), (S1 , m1 (f1 , 1 )) H t f A. When there is some loop statement in S1 , then, by (S2 , m2 (f2 , 2 )). Hence, Theorem 4 holds.   the definition of loop variables, the loop variables }" }", S2 = "while n2 (e) {S2 (b) S1 = "while n1 (e) {S1 of S1 include all variables used in the predicate exsuch that both of the following hold: t pression of S1 , LVar(S1 ) = Use(e)  LVar(S1 )    · S1 S f H S2 ; LVar(S1 ).   · S1 and S2 have equivalent computation of TVar(S1 )  t B. When the crash variables of S1 are not , then, by TVar(S2 ); the definition of crash variables, the crash variables By Corollary 5.3, we show S1 and S2 terminate in the of S1 include all variables used in the predicate exsame way when started from state m1 (f1 , m1 t c , 1 ) and pression of S1 , CVar(S1 ) = Use(e)  CVar(S1 ) 2 m 2 (f2 , mc , 2 ) respectively. We need to show that all ref CVar(S1 ). quired conditions are satisfied. In summary, all variables used in predicate expression · The crash flags are not set, f1 = f2 = 0. of S1 is a subset of termination deciding variables of · The loop counter value of S1 and S2 are zero: m1 c (n1 ) = S1 , Use(e)  TVar(S1 ). By assumption, the value 2 m ( n 2 ) = 0. c store 1 and 2 agree on the values of those in the · The value stores 1 and 2 agree on the values of those termination deciding variables of S1 and S2 . It follows, in the termination deciding variables of S1 and S2 , x  by the property of expression meaning function E , the TVar(S1 )  TVar(S2 ) : 1 (x) = 2 (x). evaluation of the predicate expression e of S1 and S2 The three above conditions are from assumption. produce the same value w.r.t the value store 1 and 2 , · S1 and S2 have same set of termination deciding variE e 1 = E e 2 . Then either the evaluations of the ables, TVar(S1 ) = TVar(S2 ). predicate expression e of S1 and S2 both crash w.r.t By Corollary 5.1. the value store 1 and 2 , or both evaluations produce   · The loop body S1 of S1 and S2 of S2 terminate in the same integer value, (E e 1 = E e 2 = error)  the same way when started in state mS1 (fS1 , S1 ) and (E e 1 = E e 2 = v = error). We show Theorem 4 mS2 (fS2 , S2 ) with crash flags not set and in which holds in either of the two possibilities. value stores agree on the values of those in the terA. E e 1 = E e 2 = error.   mination deciding variables of S1 and S2 : ((x  The execution of S1 proceeds as follows:   ( x ))  (fS1 = ( x ) =  TVar ( S )  TVar ( S ) :  S S 1 2 2 1 f t   (If(e) then {S1 } else {S1 }, m1 (1 )) , mS2 (fS2 , S2 )). , mS1 (fS1 , S1 )) H (S2 fS2 = 0))  (S1 f t  (If(error) then {S1 } else {S1 }, m1 (1 )) by rule EEval By the definition of program size, size(S1 ) = size(S1 )+ f t    (If(0) then {S1 } else {S1 }, m1 (1/f, 1 )) by rule ECrash 1, size(S2 ) = size(S2 )+1. Then, size(S1 )+size(S2 )<

the property of the expression meaning function E , the evaluation of predicate expression e of S1 and S2 w.r.t value store 1 and 2 either both crash or both do not crash, (E e 1 = E e 2 = error)  (E e 1 = error)  (E e 2 = error) . Then we show that Theorem 4 holds in either of the two possibilities. A. E e 1 = E e 2 = error. The execution of S1 proceeds as follows: f t (If(e) then {S1 } else {S1 }, m1 (1 )) f t (If(error) then {S1 } else {S1 }, m1 (1 )) by rule EEval f t (If(0) then {S1 } else {S1 }, m1 (1/f, 1 )) by rule ECrash i f t (If(0) then {S1 } else {S1 }, m1 (1/f, 1 )) for any i  0, by rule Crash. Similarly, the execution of S2 started in the state m2 (2 ) does not terminate. The theorem 4 holds. B. (E e 1 = error)  (E e 2 = error). W.l.o.g, E e 1 = v1 = 0, E e 2 = 0. Then the execution of S1 proceeds as follows. f t (If(e) then {S1 } else {S1 }, m1 (1 )) f t (If(v1 ) then {S1 } else {S1 }, m1 (1 )) by rule EEval t (S1 , m1 (1 )) by rule If-T  (skip, m 1 ) by rule Skip. Similarly, the execution of S2 started in the state m2 (2 ) terminates. The theorem 4 holds.

f t (If(0) then {S1 } else {S1 }, m1 (1/f, 1 )) for any i  0, by rule Crash. Similarly, the execution of S2 started from state m2 (2 ) does not terminate. The theorem 4 holds. B. E e 1 = E e 2 = v = error, w.l.o.g., v = 0. Then the execution of S1 proceeds as follows: f t (If(e) then {S1 } else {S1 }, m1 (1 )) f t (If(0) then {S1 } else {S1 }, m1 (1 )) by rule EEval f (S1 , m1 (1 )) by rule If-F. Similarly, after two steps of execution, S2 gets to the f configuration (S2 , m2 (2 )).

i

23

2015/9/14

 k. Then, by the hypothesis IH, the loop body S1 of S1  and S2 of S2 terminate in the same way when started in state mS1 (S1 ) and mS2 (S2 ) with crash flags not set and whose value stores agree on values of the termina  tion deciding variables of S1 and S2 . Then, by Corollary 5.3, S1 and S2 terminate in the same 2 way when started in the states m1 (m1 c , 1 ) and m2 (mc , 2 ) respectively. The theorem 4 holds. 2. S1 and S2 are not both one statement and one of the following holds:   (a) S1 = S1 ; s 1 , S2 = S2 ; s2 and all of the following hold:  S  · S1  H S2 ;   · S1 and S2 have equivalent computation of TVar(s1 )  TVar(s2 ); · s1 S H s2 where s1 and s2 are not sequences of "skip";   By the hypothesis IH, we show that S1 and S2 terminate in the same way when started in the states m1 (f1 , 1 ), m2 (f2 , 2 )   respectively, (S1 , m1 (f1 , 1 )) H (S2 , m2 (f2 , 2 )). We need to show all required conditions are satisfied. · Crash flags are not set, f1 = f2 = 0; By assumption.   · size(S1 ) + size(S2 ) < k. By the definition, size(s1 )  1, size(s2 )  1. Hence   size(S1 ) + size(S2 ) < k. · Value stores 1 and 2 agree on values of the termina  tion deciding variables of S1 and S2 .  ) Besides, by the definition of loop/crash variables, LVar(S1   LVar(S1 ) and CVar(S1 )  CVar(S1 ). Hence, TVar(S1 )  TVar(S1 ). Similarly, TVar(S2 )  TVar(S2 ). Then, value stores 1 and 2 agree on the values of those   in the termination deciding variables of S1 and S2 ,   x  TVar(S1 )  TVar(S2 ) : 1 ( x ) = 2 ( x ) .   Then, by the hypothesis IH, S1 and S2 terminate in the same way when started in the states m1 (f1 , 1 ), m2 (f2 , 2 )   , m2 (f2 , 2 )). , m1 (f1 , 1 )) H (S2 respectively, (S1   If the execution of S1 and S2 terminate when started in the states m1 (f1 , 1 ) and m2 (f2 , 2 ) respectively, we show that  and s1 and s2 terminate in the same way. We prove that S1  S2 equivalently compute the termination deciding variables of s1 and s2 by Theorem 2. · Crash flags are not set, f1 = f2 = 0;   By definition of terminating execution of S1 and S2 when started in states m1 and m2 respectively.   · The executions of S1 and S2 terminate when started in the states m1 (1 ) and m2 (2 ).    By assumption, (S1 , m1 (1 ))  (skip, m 1 (1 )) and     (S2 , m2 (2 ))  (skip, m2 (2 )). · s1 and s2 have same termination deciding variables. By Corollary 5.1, s1 and s2 have same termination deciding variables, TVar(s1 ) = TVar(s2 ) = TVar(s). · Value stores 1 and 2 agree on the values of variables   in Imp(S1 , TVar(s))  Imp(S2 , TVar(s)).  By the definition of loop/crash variables, Imp(S1 , LVar(s1 ))   LVar(S1 ) and Imp(S1 , CVar(s1 ))  CVar(S1 ). Hence,  by Lemma C.2, the imported variables in S1 relative to the termination deciding variables of s1 is a subset of the  termination deciding variables of S1 , Imp(S1 , TVar(s))   TVar(S1 ). Similarly, Imp(S2 , TVar(s))  TVar(S2 ). Thus, by assumption, the value stores 1 and 2 agree  on the values of the variables in Imp(S1 , TVar(s))   Imp(S2 , TVar(s)).   By Theorem 2, x  TVar(s) : 1 ( x ) = 2 (x ).

  By Corollary E.1, (S1 ; s1 , m1 (1 ))  (s1 , m 1 (f1 , 1 ))     and (S2 ; s2 , m2 (2 ))  (s2 , m2 (f2 , 2 )). Then, by the hypothesis IH, we show that s1 and s2 terminate in the same    way when started in the states m 1 (1 ) and m2 (2 ). We show that all required conditions are satisfied. size(s1 ) +   size(s2 ) < k because size(S1 )  1, size(S2 )  1 by the definition of program size. If s1 , s2 are loop statement, then,  by the assumption of unique loop labels, s1  / S1 , s2  /  S2 . Then, by Corollary E.4, the loop counter value of s1   and s2 is not redefined in the execution of S1 and S2 respectively. By the hypothesis IH, s1 and s2 terminate in  the same way when started in the states m 1 (f1 , 1 ) and      m 2 (f2 , 2 ), (s1 , m1 (f1 , 1 )) H (s2 , m2 (f2 , 2 )). The theorem 4 holds. (b) One last statement is "skip": w.l.o.g., (s2 = "skip")   (S1  S H S2 ).  We show that S1 and S2 terminate in the same way when started in the states m1 (1 ) and m2 (2 ) respectively by the hypothesis IH. By the definition of crash/loop variables,   CVar(S2 )  CVar(S2 ), LVar(S2 )  LVar(S2 ). Then, by  assumption, x  TVar(S2 )  TVar(S1 ) : 1 (x) = 2 (x). Besides, size (s2 )  1 by the definition of program  size. Then size (S1 ) + size (S2 )  k. By the hypothesis  IH, S1 and S2 terminate in the same way when started in the states m1 (f1 , 1 ), m2 (f2 , 2 ), (S1 , m1 (f1 , 1 )) H  (S2 , m2 (f2 , 2 )).  When the execution of S1 and S2 terminate when started in the states m1 (1 ) and m2 (2 ) respectively, s2 terminates  after the execution of S2 by the definition of terminating execution. (c) One last statement is a "duplicate" statement such that one of the following holds:   W.l.o.g., S2 = S2 ; s 2 ; S2 ; s2 and all of the following hold:    · S1  S S ; s ; S ; 2 2 2 H S · s 2 H s2 ;  · Def(s 2 ; S2 )  TVar(s2 ) = ; · s2 = "skip";   ; s We show that S1 and S2 2 ; S2 terminate in the same way when started in the states m1 (f1 , 1 ), m2 (f2 , 2 ) respectively by the hypothesis IH. The proof is same as that in case a).   We show that s2 terminates if the execution of S2 ; s 2 ; S2  terminates. We need to prove that s2 and s2 start in the states agreeing on the values of variables in TVar(s2 ). By assump      ; s tion, S2 2 ; S2 terminates, (S2 ; s2 ; S2 , m2 (f2 , 2 ))       (skip, m2 (f2 , 2 )). Then, by Corollary E.1, (S2 ; s2 ; S2 ; s2 , m2 (f2 , 2 ))      (s 2 , m  2 (f2 , 2 )). In addition, the execution of S2 and s2   must terminate because the execution of S2 ; s ; S termi2 2 nates,          ))  (S2 ; s2 ; S2 ; s2 , m2 (f2 , 2 ))  (s2 ; S2 ; s2 , m2 (f2 , 2   (s2 , m2 (f2 , 2 )).  By assumptin, Def(s 2 ; S2 )  TVar(s2 ) = . Then, by   Corollary E.2, the value store 2 and 2 agree on values of the termination deciding variables of s2 , x  TVar(s2 ) :   2 ( x ) = 2 (x). By Corollary 5.1, TVar(s 2 ) = TVar(s2 ). Because the execution of s 2 terminates, then the execution  of s2 terminates when started in the state m 2 (f2 , 2 ) by the     hypothesis IH, (s2 , m2 (f2 , 2 ))  (skip, m2 ). In addition, we show that there is no input statement in s2 by contradiction. Suppose there is input statement in s2 . By Lemma 5.11, idI  CVar(s2 ). Hence, the input sequence variable is in the termination deciding variables of s2 , idI  TVar(s2 ). By Corollary 5.1, TVar(s2 ) =



24

2015/9/14

  TVar(s Imp(S2 , TVar(s2 ; s 2 ). Then, there must be one input statement in s2 . 2 ))  TVar(S2 ).  Otherwise, by Lemma 5.2, the input sequence variable is not W.l.o.g, we show that Imp(S1 , TVar(s1 ; s 1 ))  TVar(S1 ).   in the termination deciding variables of s . A contradiction Specifically, we show Imp ( S 2 1 , CVar(s1 ; s1 ))  CVar(S1 ). against the result that idI  TVar(s CVar(s1 ; s ) 2 ). Since there is one 1  input statement in s = CVar(s1 )  Imp(s1 , CVar(s 2 , by Lemma 5.11, idI  Def(s2 ). 1 )) (1)     Thus, by defintion, idI  Def(s2 ; S2 ). Then, Def(s2 ; S2 ) by the defintion of CVar(s1 ; s 1) TVar(s2 ) = . A contradiction. Therefore, there is no input statement in s2 .  Imp(S1 , CVar(s1 ; s 1 ))     (d) S1 = S1 ; s1 ; s 1 ; and S2 = S2 ; s2 ; s2 where s1 and s2 are = Imp(S1 , CVar(s1 )  Imp(s1 , CVar(s 1 ))) by (1)   reordered and all of the following hold: = Imp(S1 , CVar(s1 ))  Imp(S1 , Imp(s1 , CVar(s 1 ))) (2)  S  · S1  H S2 ; by Lemma C.2   · S1 and S2 have equivalent computation of TVar(s1 ; s 1 ) TVar(s2 ; s  2 ). Imp(S1 , CVar(s1 ))   · s1 S s ; H 2  CVar(S1 ; s1 ) by the defintion of CVar(·) S  · s 1 H s2 ;  CVar(S1 ; s1 ; s 1 ) by the defintion of CVar(·) · Def(s1 )  TVar(s 1 ) = ;  · Def(s2 )  TVar(s Imp(S1 , Imp(s1 , CVar(s 1 ))) 2 ) = ;  = Imp(S1 ; s1 , CVar(s The proof is to show that if S1 terminates when started in 1 )) by Lemma C.1   CVar(S1 ; s1 ; s the state m1 , the S2 terminates when started in the state 1 ) by the defintion of CVar(·). m2 , and vice versa. Due to the symmetric conditions, it    is suffice to show one direction that, w.l.o.g., (S1 , m1 )  Imp(S1 , CVar(s1 ))  Imp(S1 , Imp(s1 , CVar(s 1 )))       CVar(S1 ; s1 ; s1 ) by (3) and (4). (skip, m1 )  (S2 , m2 )  (skip, m2 ).   We show that the execution of S2 terminates by the hypothIn conclusion, Imp(S1 , CVar(s1 ; s 1 ))  CVar(S1 ).  esis IH. We need to show that all required conditions are Similarly, Imp(S1 , LVar(s1 ; s 1 ))  LVar(S1 ). Thus,  satisfied. Imp(S1 , TVar(s1 ; s 1 ))  TVar(S1 ). Similarly,    · size(S1 ) + size(S2 ) < k. Imp(S2 , TVar(s2 ; s 2 ))  TVar(S2 ).   This is because size(s1 ; s 1 ) > 1, size(s2 ; s2 ) > 1. Then, by Theorem 2, after terminating execution of S1    · Initial value stores 1 and 2 agree on values of the and S2 , value stores 1 and 2 agree on values of the    , x  and S2 termination deciding variables of S1 termination deciding variables of s1 ; s 1 and s2 ; s2 ,       TVar(S1 )  TVar(S2 ) : 1 (x) = 2 (x). x  TVar(s1 ; s1 )  TVar(s2 ; s2 ) : 1 (x) = 2 (x).  We show that TVar(S1 )  TVar(S1 ). In the following, We show that the execution of s2 terminates by the hypoth we prove that CVar(S1 )  CVar(S1 ). esis IH. By Corollary E.1,         CVar(S1 ) (S1 ; s1 ; s 1 , m1 (1 ))  (s1 ; s1 , m1 (1 )) and (S2 ; s2 ; s2 ,        CVar(S1 ; s1 ) by the defintion of CVar(S1 ; s1 ) m (  ))  ( s ; s , m (  )) . By assumption, S termi2 2 2 2 1 2 2     ; s1 ; s  CVar(S1    1 ) by the defintion of CVar(S1 ; s1 ; s1 ) nates, then s1 terminates, (s1 , m 1 (1 ))  (skip, m1 (1 )).   Similarly, LVar(S1 )  LVar(S1 ). Hence, TVar(S1 )  S  Because s1 H s2 , to apply the induction hypothesis, we  )  TVar(S2 ). By asTVar(S1 ). Similarly, TVar(S2 need to show that all required conditions hold. sumption, initial value stores 1 and 2 agree on values · size(s2 ) + size(s   1 ) < k. of the termination deciding variables of S1 and S2 .   By definition, size(S2 ) > 1, size(S1 ) > 1, size(s1 ) >   By the hypothesis IH, (S1 , m1 (1 )) H (S2 , m2 (2 )).  1 , size ( s ) > 1 . 2  Because the execution of S1 terminates, then S1 termi  · Value stores 1 and 2 agree on values of the termina  nates when started in the state m1 (1 ), (S1 , m1 (1 ))   tion deciding variables of s 1 and s2 . x  TVar(s1 )     (skip, m1 (1 )). Therefore, S2 termiantes when started in   TVar(s2 ) : 1 (x) = 2 (x).    the state m2 (2 ), (S2 , m2 (2 ))  (skip, m 2 (2 )). By Corollary 5.1, TVar(s 1 ) = TVar(s2 ). Because of the   We show that after the execution of S1 and S2 , value stores condition Def(s1 )  TVar(s 1 ) = , by Corollary E.2,   agree on values of the termination deciding variables of value stores 1 and 1 agree on values of the termi      s1 ; s1 and s2 ; s2 , x  TVar(s1 ; s1 )TVar(s2 ; s2 ), 1 (x) = nation deciding variables of s 1 , x  TVar(s1 ) :    2 (x). We split the argument into two steps. 1 ( x ) = 1 (x). By the argument above, x  TVar(s2 ) :    i. We show that TVar(s1 ; s (x). Thus, the condition holds. ( x ) = 2 1 1 ) = TVar(s2 ; s2 ).      By Corollary 5.1, TVar(s1 ) = TVar(s 2 ) and TVar(s1 ) = By the induction hypothesis IH, (s 1 , m1 (1 )) H (s2 , m2 (2 )).  TVar(s2 ). Then we show that TVar(s1 ; s 1 ) = TVar(s1 ) Because the execution of s terminates, then the exeuc1   TVar(s 1 ). To do that, we show that CVar(s1 ; s1 ) = tion of s2 terminates when started in the state m 2 ( 2 ) ,   CVar(s1 )  CVar(s1 ).     )) . (  ))  ( skip , m (  ( s , m 2 2 2 2 2 CVar(s1 ; s 1) We show that the execution of s 2 terminates. This is by the   = CVar(s1 )  Imp(s1 , CVar(s1 )) by the defintion of CVar(s1 ; s1 ) similar argument that s2 terminates.   = CVar(s1 )  CVar(s1 ) by Def(s1 )  TVar(s1 ) =  and In conclusion, S2 terminates when started in the state the defintion of Imp(·). m2 (2 ). The theorem holds.  Similarly, LVar(s1 ; s In addition, we show that it is impossible that s1 and s 1 ) = LVar(s1 )  LVar(s1 ). Thus, 1 both   TVar(s1 ; s ) = TVar ( s )  TVar ( s ) . Similarly, TVar ( s ; s ) = 1 2 include input statements by contradiction. Suppose there 1 1 2  TVar(s2 )  TVar(s are input statements in both s1 and s 2 ). In summary, TVar(s1 ; s1 ) = 1 . By Lemma 5.11,  TVar(s2 ; s ) . id 2 I  Def(s1 )  TVar(s1 ). A contradiction against the  ii. We show that Imp(S1 , TVar(s1 ; s condition that Def(s1 )  TVar(s 1 ))  TVar(S1 ) and 1 ) = . Similarly, there are no input statements in both s2 and s 2.

25

2015/9/14

· There is no possible value mismatch in "id1

5.3.3 Supporting lemmas for the soundness proof of termination in the same way The supporting lemmas include various properties of TVar(S ), two statement sequences satisfying the proof rule of termination in the same way consume the same number of input values when both terminate, and the proof for the case of while statement of theorem 4. The properties of the termination deciding variables
 Lemma 5.4. The crash variables of S1 ; S1 is same as the union of the crash variables of S1 and the imported variables in S1   relative to the crash variables of S1 , CVar(S1 ; S1 ) = CVar(S1 )   Imp(S1 , CVar (S1 )).

:= e", ¬(S1  id1 : Int)  ¬(S1  e : Long)  (S1  e : Int). · There is no possible value mismatch in "id2 := e", ¬(S2  id2 : Int)  ¬(S2  e : Long)  (S2  e : Int).

By the definition of loop variables, LVar(S1 ) = LVar(S2 ) =  in both base cases. Therefore, Lemma 5.6 holds. Induction Step. The hypothesis IH is that Lemma 5.6 holds when size(S1 ) + size(S2 ) = k  2. We show that Lemma 5.6 holds when size(S1 ) + size(S2 ) = k + 1. The proof is a case analysis according to the cases in the definition of (S1 S H S2 ): 1. S1 and S2 are one statement and one of the following holds. f t t (a) S1 = "If(e) then {S1 } else {S1 }", S2 = "If(e) then {S2 } f else {S2 }" such that one of the following holds:

Proof. Let = s1 ; ...; sk for k > 0. We show the lemma by induction on k. Base case. By the definition of CVar(S ), the lemma holds. Induction step. The hypothesis IH is that CVar(S1 ; s1 ; ...; sk ) = CVar(S1 )  Imp(S1 , CVar(s1 ; ...; sk )) for k  1.  Then we show that the lemma holds when S1 = s1 ; ...; sk+1 . CVar(S1 ; s1 ; ...; sk+1 ) = CVar(S1 ; s1 )  Imp(S1 ; s1 , CVar(s2 ; ...; sk+1 )) by IH CVar(S1 ; s1 ) = CVar(S1 )  Imp(S1 , CVar(s1 )) (1) Imp(S1 ; s1 , CVar (s2 ; ...; sk+1 )) = Imp(S1 , Imp(s1 ; CVar (s2 ; ...; sk+1 ))) (2) Combining (1) and (2), we have CVar(S1 ; s1 )  Imp(S1 ; s1 , CVar (s2 ; ...; sk+1 )) = CVar(S1 )  Imp (S1 , CVar (s1 ))  Imp (S1 , Imp(s1 ; CVar (s2 ; ...; sk+1 ))) = CVar(S1 )  Imp(S1 , CVar(s1 )  Imp(s1 ; CVar(s2 ; ...; sk+1 ))) by Lemma C.2 = CVar(S1 )  Imp(S1 , CVar(s1 ; ...; sk+1 )).
 Lemma 5.5. The loop deciding variables of S1 ; S1 is same as the union of the loop deciding variables of S1 and the imported  variables in S1 relative to the loop deciding variables of S1 ,   LVar(S1 ; S1 ) = LVar(S1 )  Imp(S1 , LVar (S1 )).

 S1

By proof of Lemma 5.5 similar to that of lemma 5.4 above. Lemma 5.6. If two statement sequences S1 and S2 satisfy the proof rule of termination in the same way, then S1 and S2 have same loop variables, (S1 S H S2 )  (LVar(S1 ) = LVar(S2 )). Proof. By induction on size(S1 )+size(S2 ), the sum of the program size of S1 and S2 . Base case. S1 and S2 are simple statement. There are three base cases according to the definition of s1 S H s2 . 1. two same simple statements, S1 = S2 ; 2. S1 and S2 are input statement with same type variable: S1 = "input id1 ", S2 = "input id2 " where (S1  id1 : t)  (S2  id2 : t);. 3. S1 = "output e" or "id1 := e", S2 = "output e" or "id2 := e" where both of the following hold:

f f t t i. S1 , S1 , S2 , S2 are all sequences of "skip"; f t By the definition of loop variables, LVar(S1 ) = LVar(S1 )= f t LVar(S2 ) = LVar(S2 ) = . Therefore, by the definition of loop variables, LVar(S1 ) = LVar(S2 ) = . The lemma 5.6 holds. f f t t ii. At least one of S1 , S1 , S2 , S2 is not a sequence of f f t t S S "skip" such that: (S1 H S2 )  (S1 H S2 ); f f t t size(S1 ) + size(S2 ) < k, size(S1 ) + size(S2 ) < k. f t t Then, by the hypothesis IH1, LVar(S1 ) = LVar(S2 ), LVar(S1 )= f f t LVar(S2 ). Consequently, (LVar(S1 )  LVar(S1 )) = f t (LVar(S2 )  LVar(S2 )) = LVar(). When LVar() = , then LVar(S1 ) = LVar(S2 ) =  by the definition of loop variables. When LVar() = , then LVar(S1 ) = LVar(S2 ) = LVar()  Use(e) by the definition of loop variables. The lemma 5.6 holds.   (b) S1 = "while n1 (e){S1 }", S2 = "while n2 (e){S2 }" such that both of the following hold:   · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(S1 )  TVar(S2 );   By the hypothesis IH1, LVar(S1 ) = LVar(S2 ). Then   Use(e)  LVar(S1 ) = Use(e)  LVar(S2 ). Then, we show that:  i   i i  0, Imp(S1 , Use(e)LVar(S1 )) = Imp(S2 , Use(e)  LVar(S2 )) by induction on i. Base case  0  0 By our notation S 0 , S1 = skip, S2 = skip. Then, by the definition of imported variables,  0   Imp(S1 , Use(e)  LVar(S1 )) = Use(e)  LVar(S1 ),  0   Imp(S2 , Use(e)  LVar(S2 )) = Use(e)  LVar(S2 ).  0   0 Then, Imp(S1 , Use(e)  LVar(S1 )) = Imp(S2 , Use(e)   LVar(S2 )). Induction step  i The hypothesis IH3 is that, i  0, Imp(S1 , Use(e)    i  LVar(S1 )) = Imp(S2 , Use(e)  LVar(S2 )).  i+1  Then we show that Imp(S1 , Use(e)  LVar(S1 )) =  i+1  Imp(S2 , Use(e)  LVar(S2 )). By Corollary C.1,  i+1    i Imp(S1 , Use(e)LVar(S1 )) = Imp(S1 , Imp(S1 , Use(e)  LVar(S1 ))),  i+1    i Imp(S2 , Use(e)LVar(S2 )) = Imp(S2 , Imp(S2 , Use(e)  LVar(S2 ))).  i  By the hypothesis IH3, Imp(S1 , Use(e)  LVar(S1 )) =  i  Imp(S2 , Use(e)  LVar(S2 )) = LVar().

26

2015/9/14

Besides, by the definition of loop variables, LVar()  LVar(S1 ), LVar()  LVar(S2 ). Then,   i  Imp(S1 , Imp(S1 , Use(e)  LVar(S1 )))  = Imp(S1 , LVar())  = Imp(S2 , LVar()) by Lemma 5.3   i  = Imp(S2 , Imp(S2 , Use(e)  LVar(S2 ))) In summary, LVar(S1 )) = LVar(S2 ). The lemma 5.6 holds. 2. S1 and S2 are not both one statement and one of the following holds:
  (a) S1 = S1 ; s1 and S2 = S2 ; s2 such that all of the following hold:   · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(s1 ) 

In the following, we show LVar(S1 ) = LVar(S2 ) in three steps.   i. We show LVar(S1 ; s1 ; s 1 ) = LVar(S1 )   Imp(S1 , LVar(s1 ))  Imp(S1 , LVar(s 1 )).
 LVar(S1 ; s1 ; s 1)   = LVar(S1 ; s1 )  Imp(S1 ; s1 , LVar(s 1 )) by the definition of loop variables

 LVar(S1 ; s1 )   = LVar(S1 )  Imp(S1 , LVar(s1 )) (2) by the definition of loop variables  Imp(S1 ; s1 , LVar(s 1 ))  = Imp(S1 , Imp(s1 , LVar(s 1 ))) by Lemma C.1  = Imp(S1 , LVar(s 1 )) (3) by the condition Def(s1 )  TVar(s 1) = 

TVar(s2 );

By the hypothesis IH1, = LVar(s1 ) = LVar(s2 ) = LVar(). Besides,   Imp(S1 , LVar(s1 )) = LVar(S2 , LVar(s2 )) by Lemma 5.3. Therefore, LVar(S1 ) = LVar(S2 ) by the definition of loop variables. The lemma 5.6 holds. (b) One last statement is "skip": w.l.o.g.,  (S1  S H S2 )  (s2 = "skip") .  By the hypothesis IH1, LVar(S1 ) = LVar(S2 ) . Besides, LVar(s2 ) =  by the definition of loop variables. Therefore,   LVar(S1 ) = LVar(S2 ) = LVar(S2 )  Imp(S2 , ). The lemma 5.6 holds. (c) One last statement is a "duplicate" statement such that one of the following holds:   W.l.o.g. S1 = S1 ; s 1 ; S1 ; s1 and all of the following hold:    S · S1 ; s 1 ; S1  H S2 ; S · s 1 H s1 ;  · Def(s 1 ; S1 )  TVar(s1 ) = ; · s2 = "skip";   ; s By the hypothesis IH, LVar(S1 1 ; S1 ) = LVar(S2 ).      Then, we show that LVar(S1 ; s ; S ) 1 1 = LVar(S1 ; s1 ; S1 ; s1 ). By the induction hypothesis IH, LVar(s 1 ) = LVar(s1 ).
  LVar(S1 ; s 1 ; S1 ; s 1 )      ; s )  Imp(S1 = LVar(S1 ; s1 ; S1 1 ; S1 , LVar(s1 )) by the definition of loop variables   Imp(S1 ; s 1 ; S1 , LVar(s1 ))   = Imp(S1 , Imp(s 1 ; S1 , LVar(s1 ))) by Lemma C.1   = Imp(S1 , LVar(s1 )) by Def(s 1 ; S1 )  TVar(s1 ) =    = Imp(S1 , LVar(s 1 )) by LVar(s1 ) = LVar(s1 )   LVar(S1 ; s 1 ) by the definition of loop variables    LVar(S1 ; s 1 ; S1 ) by Lemma 5.5.

· s1 S H s2 where s1 and s2 are not "skip";
 LVar(S1 )

 LVar(S2 ),

  According to (2) and (3), LVar(S1 ; s1 ; s 1 ) = LVar(S1 )   Imp(S1 , LVar(s1 ))  Imp(S1 , LVar(s )) . 1   Similarly, LVar(S2 ; s2 ; s 2 ) = LVar(S2 )    Imp(S2 , LVar(s2 ))  Imp(S2 , LVar(s2 )).   ii. We show that Imp(S1 , LVar(s1 )) = Imp(S2 , LVar(s 2 )).   Imp(S2 , LVar(s2 )). We need to show that LVar(s1 )  LVar(s1 ; s 1 ) and  LVar(s 2 )  LVar(s2 ; s2 ). By the definition of loop variables, LVar(s1 )  LVar(s1 ; s 1 ). By the definition of loop variables again, LVar(s2 ; s 2 ) = LVar(s2 )   Imp(s2 , LVar(s 2 )). Because Def(s2 )  TVar(s2 ) = ,  ) . )) = LVar ( s Imp(s2 , LVar(s 2 2 By the induction hypothesis IH, LVar(s1 ) = LVar(s 2 ).  By Lemma 5.3, x  LVar(s1 ) = LVar(s 2 ), Imp(S1 , {x}) =   , LVar(s1 )) = , {x}). By Lemma C.2, Imp(S1 Imp(S2  Imp(S2 , LVar(s )) . 2   iii. We show that Imp(S1 , LVar(s 1 )) = Imp(S2 , LVar(s2 )).  By the similar argument that Imp(S1 , LVar(s1 )) =  Imp(S2 , LVar(s 2 )).    In conclusion, LVar(S1 ; s1 ; s 1 ) = LVar(S2 ; s2 ; s2 ).

Lemma 5.7. If two statement sequences S1 and S2 satisfy the proof rule of termination in the same way, then S1 and S2 have same crash variables, (S1 S H S2 )  (CVar(S1 ) = CVar(S2 )). By proof similar to those for Lemma 5.6. Corollary 5.1. If two statement sequences S1 and S2 satisfy the proof rule of termination in the same way, then S1 and S2 have same termination deciding variables, (S1 S H S2 )  (TVar(S1 ) = TVar(S2 )). By Lemma 5.6, and 5.7. Properties of the input sequence variable Lemma 5.8. If there is no input statement in a statement sequence S , then the input sequence variable is not in the defined variables of S , ("input x"  S )  idI  / Def(S ). Proof. By induction on abstract syntax of S . Lemma 5.9. If there is no input statement in a statement sequence S , then the input sequence variable is not in the crash variables of S , ("input x"  S )  (idI  / CVar(S )). Proof. By induction on abstract syntax of S .

     In conclusion, LVar(S1 ; s 1 ; S1 ; s1 ) = LVar(S1 ; s1 ; S1 ). The lemma holds.    (d) S1 = S1 ; s1 ; s 1 ; and S2 = S2 ; s2 ; s2 where s1 and s2 are reordered and all of the following hold:   · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(s1 ; s 1 )

· · · ·

  By the hypothesis IH, LVar(S1 ) = LVar(S2 ), LVar(s1 ) =  LVar(s ) , LVar ( s ) = LVar ( s ) . 2 2 1

TVar(s2 ; s 2 ).  s1 S s ; H 2 S s 1 H s2 ; Def(s1 )  TVar(s 1 ) = ; Def(s2 )  TVar(s 2 ) = ;

27

2015/9/14

Lemma 5.10. If there is no input statement in a statement sequence S , then the input sequence variable is in the loop variables of S , ("input x"  S )  (idI  / LVar(S )). Proof. By induction on abstract syntax of S . Corollary 5.2. If there is no input statement in a statement sequence S , then the input sequence variable is in the termination deciding variables of S , ("input x"  S )  (idI  / TVar(S )). By Lemma 5.9 and 5.10. Lemma 5.11. If there is one input statement in a statement sequence S , then the input sequence variable is in the crash variables and defined variables of S , ("input x"  S )  (idI  CVar(S ))  (idI  Def(S )). Proof. By induction on abstract syntax of S . Lemma 5.12. If there is one input statement in a statement sequence S , then the imported variables in S relative to the input sequence variable are a subset of the crash variables of S , ("input x"  S )  (Imp(S, {idI })  CVar(S )).

Imp(S  , {idI }  Use(e)) i  Imp(S  , CVar(S  )  Use(e)) (1) by the hypothesis IH1 Imp(S  , {idI }  Use(e)) i = Imp(S  , Imp(S  , {idI }  Use(e))) (2) by Corollary C.1 Imp(S  , CVar(S  )  Use(e)) i = Imp(S  , Imp(S  , CVar(S  )  Use(e))) (3) by Corollary C.1. Combining (1), (2) and (3): Imp(S  , Imp(S  , {idI }  Use(e))) i  Imp(S  , Imp(S  , CVar(S  )  Use(e))) by Lemma C.2.
i+1 i+1 i i+1 i+1

i

Therefore, Imp(S  , {idI }Use(e))  Imp(S  , CVar(S  ) Use(e)). In conclusion, Imp(S, {idI })  CVar(S ). 4. S = s1 ; ...; sk , for k > 0. By induction on k. Base case. k = 1. Proof. By induction on abstract syntax of S . By above cases, the lemma holds. 1. S = "input x". Induction step. By the definition of CVar(·) and Imp(·), CVar(S ) = Imp(S, {idI }) = The induction hypothesis IH2 is that the lemma holds when {idI }. k > 0. We show that the lemma holds when S = s1 ; ...; sk+1 . 2. S = "If(e) then {St } else {Sf }". By the definition of crash variables, CVar(s1 ; ...; sk+1 ) = W.l.o.g., there is input statement in St , by the induction hyCVar(s1 ; ...; sk )  Imp(s1 ; ...; sk , CVar(sk+1 )).There are two pothesis, Imp(St , {idI })  CVar(St ). There are two subcases possibilities. regarding if input statement is in Sf . (a) "input x"  sk+1 . (a) There is input statement in Sf . By Lemma 5.8, idI  / Def(S ). By the induction hypothesis, Imp(Sf , {idI })  CVar(Sf ). Imp(s1 ; ...; sk+1 , {idI }) Hence, the lemma holds. = Imp(s1 ; ...; sk , {idI }) by idI  / Def(S ) and (b) There is no input statement in Sf . the definition of imported variables By the definition of imported variables, Imp(Sf , {idI }) =  CVar(s1 ; ...; sk ) by the hypothesis IH2 {idI }. By Lemma 5.11, idI  CVar(St ). Therefore, the  CVar(s1 ; ...; sk+1 ) by the definition of crash variables lemma holds. 3. S = "while n (e){S  }". (b) "input x"  sk+1 . By the induction hypothesis, Imp(S  , {idI })  CVar(S  ). Imp(s1 ; ...; sk+1 , {idI }) i By the definition of Imp(·), Imp(S  , {idI }) = i0 Imp(S  , {idI } = Imp(s1 ; ...; sk , Imp(sk+1 , {idI }))  Use(e)). By the definition of CVar(·), CVar(S ) = by the definition of imported variables i  i0 Imp(S , CVar(S )  Use(e)). i Imp(sk+1 , {idI }) By induction on i, we show that, i  0, Imp(S  , {idI }  i   CVar(sk+1 ) by the hypothesis IH2 Use(e))  Imp(S , CVar(S )  Use(e)). Base case i = 0. 0 Imp(s1 ; ...; sk , Imp(sk+1 , {idI })) By notation S  = skip.  Imp(s1 ; ...; sk , CVar(sk+1 )) by Lemma C.2 0  CVar(s1 ; ...; sk+1 ) by the definition of crash variables. Imp(S  , {idI }  Use(e)) = {idI }  Use(e) by the definition of imported variables Imp(S  , CVar(S  )  Use(e)) = CVar(S  )  Use(e) by the definition of imported variables idI  CVar(S ) (1) by Lemma 5.11 Imp(S  , {idI }  Use(e)) 0  Imp(S  , CVar(S  )  Use(e)) by Lemma C.2. Induction step. i The hypothesis IH1 is that Imp(S  , {idI }  Use(e))  i  Imp(S , CVar(S )  Use(e)) for i > 0. i+1 Then we show that Imp(S  , {idI }  Use(e))  i+1   Imp(S , CVar(S )  Use(e))
28
0  0

Lemma 5.13. If two programs S1 and S2 satisfy the proof rule of termination in the same way, then S1 and S2 satisfy the proof rule of terminating computation in the same way of the input sequence, S (S1  S H S2 )  (S1 idI S2 ). Proof. By induction on size(S1 ) + size(S2 ). Base case. S1 and S2 are simple statements. There are three cases. 1. S1 and S2 are "skip": S1 = S2 = "skip"; 2. S1 and S2 are input statement: S1 = "input id1 ", S2 = "input id2 ";

2015/9/14

3. s1 and s2 are with the same expression: s1 = "output e" or "id1 := e", s2 = "output e" or "id2 := e". By definition of the proof rule of equivalent computation, the lemma holds in above three cases. Induction step. The hypothesis IH is that the lemma holds when size(S1 ) + size(S2 ) = k  2. Then, we show that the lemma holds when size(S1 )+size(S2 ) = k + 1. The proof is a case analysis of the cases in the proof rule of termination in the same way. 1. S1 and S2 are one statement and one of the followings holds.
f t t (a) S1 = "If(e) then {S1 } else {S1 }", S2 = "If(e) then {S2 } f else {S2 }" and one of the followings holds:

 }", S2 = "while (b) S1 = "while n1 (e){S1 both of the followings hold:

f f t t i. S1 , S1 , S2 , S2 are all sequences of "skip"; By Lemma 5.8, idI  / Def(S1 )  DefS2 . The lemma holds. f f t t ii. At least one of S1 , S1 , S2 , S2 is not a sequence of "skip" such that: f f t t S (S1 S H S2 )  (S1  H S2 ); f t Because size(S1 ) = 1+size(S1 )+size(S1 ), size(S2 ) = f t t t 1+size(S2 )+size(S2 ). Therefore, size(S1 )+size(S2 )< f f k, size(S1 ) + size(S2 ) < k. By the induction hypothef f t t S sis IH, (S1 S idI S2 )  (S1 idI S2 ). Then, the lemma S holds by the definition of S1 idI S2 . n2  }" and (e){S2

  · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(S1 ) 

i. idI  TVar(s1 ) = TVar(s2 ) Then there is input statement in s1 and s2 . Otherwise, by Lemma 5.2, idI  / TVar(s1 ) = TVar(s2 ). A contradiction. Then, by Lemma 5.11, idI  Def(s1 )  Def(s2 ). By Lemma 5.3, Imp(s1 , {idI }) = Imp(s2 , {idI }). By Lemma 5.12, Imp(s1 , {idI })  CVar(s1 , {idI }).   Therefore, S1 and S2 equivalently compute Imp(s1 , {idI }) Imp(s2 , {idI }). The lemma holds. ii. idI  / TVar(s1 ) = TVar(s2 ). Then, there is no input statement in s1 and s2 . Otherwise, by Lemma 5.11, idI  CVar(s1 ) = CVar(s2 ). A contradiction. Then, by Lemma 5.8, idI  / Def(s1 )    Def(s2 ). By the induction hypothesis IH, S1 S idI S2 . The lemma holds.  (b) One last statement is "skip": W.l.o.g., (S1 S H S2 )  (s 1 = "skip")  By the induction hypothesis, S1 S idI S2 . By definition, idI  / Def(s1 ). The lemma holds. (c) One last statement is a "duplicate" statement such that one of the followings holds:   W.l.o.g., S1 = S1 ; s 1 ; S1 ; s1 and all of the followings hold:    S · S1 ; s 1 ; S1  H S2 ; S · s 1 H s1 ;  · Def(s 1 ; S1 )  TVar(s1 ) = ; · s2 = "skip". S   ; s By the induction hypothesis, S1 1 ; S1 idI S2 . In the proof of Theorem 3, there is no input statement in s2 . Because x : "input x"  / s2 , by Lemma 5.8, idI  / Def(s1 ). The lemma holds.    (d) S1 = S1 ; s1 ; s 1 ; and S2 = S2 ; s2 ; s2 where s1 and s2 are reordered and all of the followings hold:
  · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(s1 ; s 1 )

TVar(S2 );

2. S1 and S2 are not both one statement and one of the followings holds:
  (a) S1 = S1 ; s1 and S2 = S2 ; s2 and all of the followings hold:

  S By the induction hypothesis IH, S1 idI S2 . In addition, by Corollary 5.1, TVar(S1 ) = TVar(S2 ). There are two cases. i. idI  TVar(S1 ) = TVar(S2 ). We show that idI  Def(S1 )  Def(S2 ). If there is no input statement in S1 or S2 , then, by Corollary 5.2, idI  / TVar(S1 )  TVar(S2 ). A contradiction. Thus, there is input statement in S1 and S2 , by Lemma 5.11, idI  Def(S1 )  Def(S2 ). By Lemma 5.12, Imp(S1 , {idI })  CVar(S1 ). Similarly, Imp(S2 , {idI })  TVar(S2 ). Hence, loop bodies of S1 and S2 equivalently compute every of the imported variables in S1 and S2 relative to the input sequence variable, x  Imp(S1 , {idI })Imp(S2 , {idI }),   S1 S x S2 . Thus, the lemma holds. ii. idI  / TVar(S1 ) = TVar(S2 ). Then there is no input statement in S1 and S2 . Otherwise, by Lemma 5.11, (idI  CVar(S1 ))  (idI  CVar(S2 )). A contradiction. Then by Lemma 5.8, idI  / (Def(S1 )  Def(S2 )). Hence, the lemma holds.

· · · ·

TVar(s2 ; s 2 ).  s1 S H s2 ; S s 1 H s2 ; Def(s1 )  TVar(s 1 ) = ; Def(s2 )  TVar(s 2 ) = ;

  · S1 S H S2 ;   · S1 and S2 have equivalent computation of TVar(s1 ) 

TVar(s2 );

By the induction hypothesis IH, s1 S idI s2 . By Corollary 5.1, TVar(s1 ) = TVar(s2 ). There are two cases.

· s1 S H s2 where s1 and s2 are not "skip";

In the proof of Theorem 4, we showed that s1 and s2 do not both include input statement, s2 and s 2 do not both include input statement. There are two subcases. i. There are no input statements in both s1 and s 1. We show that there are no input statements in both  s2 and s 2 . By Corollary 5.1, TVar(s1 ) = TVar(s2 ) and TVar(s ) = TVar ( s ) . By Corollary 5.2, id  / 2 I 1 TVar(s1 )  TVar(s / TVar(s2 )  TVar(s 1 ). Thus, idI  2 ). If there is input statement in s2 or s 2 , then, by Lemma 5.11, idI  / TVar(s2 )  TVar(s 2 ). A contradiction. In summary, there are no input statements in both s2 and s 2. By Lemma 5.8, idI  / Def(s1 ; s / Def(s2 ; s 1 ) and idI  2 ).   By the induction hypothesis, S1 S idI S2 . Therefore, the lemma holds. ii. W.l.o.g, there are input statements in s1 only. By similar argument in the proof of Theorem 4 that s1 and s2 do not both include input statements, we can show that there is no input statement in s2 and there is input statement in s 2. In the following, the proof is of two steps. S  A. We show that s1 ; s 1 idI s2 .  By the induction hypothesis IH, s1 S idI s2 . Because there is no input statement in s , then by 1
29 2015/9/14

 S  Lemma 5.8, idI  / Def(s 1 ). Thus, s1 ; s1 idI s2 by definition.   B. We show that S1 and S2 ; s2 equivalently compute Imp(s1 ; s , { id } )  Imp (s  I 1 2 , {idI }). The argument is of two parts. First, we need to show that Def(s2 )  Imp(s 2 , {idI }) = . By  Lemma 5.12, Imp(s 2 , {idI })  CVar(s2 ). Thus,  Imp(s , { id } )  TVar ( s ) . By assumption, Def(s2 ) I 2 2  TVar(s 2 ) = . Then, Def(s2 )  Imp(s2 , {idI }) = .  By Lemma 5.3, Imp(s1 ; s 1 , {idI }) = Imp(s2 , {idI }).  Thus, Def(s2 )  Imp(s1 ; s1 , {idI }) = .  Second, we show that Imp(s 2 , {idI })  TVar(s2 ; s2 )   and Imp(s1 ; s1 , {idI })  TVar(s1 ; s1 ). By Lemma 5.12,   Imp(s1 ; s 1 , {idI })  TVar(s1 ; s1 ) and Imp(s2 , {idI })    TVar(s2 ). Then we show that TVar(s2 )  TVar(s2 ; s 2 ).  We need to show that CVar(s 2 )  CVar(s2 ; s2 ) and  LVar(s 2 )  LVar(s2 ; s2 ).

· mS1 (fS1 , S1 ) mS2 (fS2 , S2 ) :

(((z  TVar(S1 )  TVar(S2 )), S1 (z ) = S2 (z ))  (fS1 = fS2 = 0))  (S1 , mS1 (fS1 , S1 )) H (S2 , mS2 (fS2 , S2 )).

If s1 and s2 start in the state m1 (f1 , loop1 c , 1 ) and m2 (f2 , loop2 ,  ) respectively in which crash flags are not set, 2 c f1 = f2 = 0, s1 and s2 have not already executed, loop1 c (n1 ) = loop2 c (n2 ) = 0, value stores 1 and 2 agree on values of variables in TVar(s), x  TVar(s) : 1 (x) = 2 (x), then, for any positive integer i, one of the following holds: 1. The loop counters for s1 and s2 are less than i where s1 and s2 terminate in the same way:   1    m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )      2 1 2 (S2 , m2 (loopc )), loopc (n1 ) < i and mc (n2 ) < i and one of the following holds: (a) s1 and s2 both terminate:    (s1 , m1 )  (skip, m 1 ) and (s2 , m2 )  (skip, m2 ). (b) s1 and s2 both do not terminate: k k k > 0 : (s1 , m1 )  (S1k , m1k ) and (s2 , m2 )  (S2k , m2k ) in which S1k = skip, S2k = skip. 2. The loop counters for s1 and s2 are less than or equal to i where s1 and s2 do not terminate such that there are no configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are not set, the loop counters of s1 and s2 are equal to i, and value stores agree on the values of variables in TVar(s):
  1 · m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )), (s2 , m2 )  2 (S2 , m  2 (loopc )) where  1 loopc (n1 )  i, loop2 c (n2 )  i; · k > 0 : k k (s1 , m1 )  (S1k , m1k ), (s2 , m2 )  (S2k , m2k ) where S1k = skip, S2k = skip; and · (s1 , m1i ) (s2 , m2i ) :  i (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i ))  i (s2 , m2 )  (s2 , m2i (f2 , loop2 c , 2i )) where f1 = f2 = 0; and 2i i loop1 c (n1 ) = loopc (n2 ) = i; and x  TVar(s) : 1i (x) = 2i (x).


CVar(s2 ; s 2) = CVar(s2 )  Imp(s2 , CVar(s 2 )) by the definition of crash variables Imp(s2 , CVar(s 2 )) = CVar(s 2 ) (1) by the assumption Def(s2 )  TVar(s 2) =  CVar(s2 )  Imp(s2 , CVar(s 2 )) = CVar(s2 )  CVar(s 2 ) by (1)

  Similarly, LVar(s 2 )  LVar(s2 ; s2 ). Thus, TVar(s2 )   TVar(s2 ; s2 ).  By assumption, x  Imp(s1 ; s 1 , {idI })Imp(s2 , {idI }) :  S   S1 x S2 . In addition, Def(s2 )(Imp(s1 ; s1 , {idI })  Imp(s 2 , {idI })) = . Thus, x  Imp(s1 ; s1 , {idI })   S  Imp(s2 , {idI }) : S1 x S2 ; s2 . The lemma holds.







Lemma 5.14. If two programs S1 and S2 satisfy the proof rule of termination in the same way, and S1 and S2 both terminate when started in their initial states with crash flags not set, f1 = f2 = 0, whose value stores agree on values of variables of the termination deciding variables of S1 and S2 , x  TVar(S1 )  TVar(S2 ), 1 (x) = 2 (x), and S1 and S2 are fed with the same  infinite input sequence, 1 (idI ) = 2 (idI ), (S1 , m1 (f1 , 1 )       (skip, m1 (1 )) and (S2 , m2 (f2 , 2 )  (skip, m2 (2 )), then the execution of S1 and S2 consume the same number of input values,   1 (idI ) = 2 (idI ). Proof. By Lemma 5.13, S1 S idI S2 . By Lemma 5.12, Imp(S1 , idI )  CVar(S1 ) and Imp(S2 , idI )  CVar(S2 ). By assumption, x  Imp(S1 , idI )  Imp(S2 , idI ) : 1 (x) = 2 (x). By Theorem 2,   1 (idI ) = 2 (idI ). Theorem of two loop statements terminating in the same way Lemma 5.15. Let s1 = "while n1 (e){S1 }" and s2 = "while n2 (e){S2 }" be two while statements with the same set of termination deciding variables in program P1 and P2 respectively, whose bodies S1 and S2 satisfy the proof rule of equivalently computation of variables in TVar(s), and S1 and S2 terminate in the same way when started in states with crash flags not set and agreeing on values of variables in TVar(S1 )  TVar(S2 ):
· TVar(s1 ) = TVar(s2 ) = TVar(s); · x  TVar(s) : S1 S x S2 ;
30

3. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to i and value stores agree on the values of variables in  TVar(s), and for every state in execution (s1 , m1 )  (s1 , m1i )  or (s2 , m2 )  (s2 , m2i ), the loop counters for s1 and s2 are less than or equal to i respectively:  i (s1 , m1i ) (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i ))  2i (s2 , m2 )  (s2 , m2i (f2 , loopc , 2i )) where · f1 = f2 = 0; and 2i i · loop1 c (n1 ) = loopc (n2 ) = i; and · x  TVar(s) : 1i (x) = 2i (x); and     1 · m 1 : (s1 , m1 )  (S1 , m1 (mc ))  (s1 , m1i ), 1 loopc (n1 )  i; and     2 · m 2 : (s2 , m2 )  (S2 , m2 (mc ))  (s2 , m2i ), 2 loopc (n2 )  i; Proof. By induction on i. Base case. i = 1.

2015/9/14

By assumption, initial loop counters of s1 and s2 are of value zero. Initial value stores 1 and 2 agree on the values of variables in TVar(s). Then we show one of the following cases hold: 1. The loop counters for s1 and s2 are less than 1, s1 and s2 terminate in the same way:      1 m 1 m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )     2 (S2 , m2 (loopc )),  2 m1 c (n1 ) < 1 and mc (n2 ) < 1 and one of the following holds: (a) s1 and s2 both terminate:    (s1 , m1 )  (skip, m 1 ) and (s2 , m2 )  (skip, m2 ). (b) s1 and s2 both do not terminate: k k k > 0, (s1 , m1 )  (S1k , m1k ) and (s2 , m2 )  (S2k , m2k ) in which S1k = skip, S2k = skip. 2. The loop counters for s1 and s2 are less than or equal to 1, and s1 and s2 do not terminate such that there are no configurations (s1 , m11 ) and (s2 , m21 ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are not set, the loop counters of s1 and s2 are equal to 1 and value stores agree on the values of variables in TVar(s):
  1 · m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )), (s2 , m2 )  2 1 2 (S2 , m  2 (loopc )) where loopc (n1 )  i, loopc (n2 )  i; k k
  

(while n1 (0) {S1 }, m1 (1/f1 )) by the ECrash rule k (while n1 (0) {S1 }, m1 (1/f1 , loop1 c , 1 )), for any k  0, by the Crash rule. Similarly, the execution of s2 started in the state m2 (f2 , loop2 c , 2 ) does not terminate. The loop counters of s1 and s2 are less than 1:      1 m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )    2 1 2 (S2 , m2 (loopc )) where loopc (n1 ) < 1 and loopc (n2 ) < 1. Besides, s1 and s2 both do not terminate when started in states k m1 and m2 , k > 0 : (s1 , m1 )  (S1k , m1k ) and (s2 , m2 ) k  (S2k , m2k ) in which S1k = skip, S2k = skip. 2. E  e 1 = E  e 2 = (0, vof ) The execution of s1 proceeds as follows. (s1 , m1 (loop1 c , 1 )) = (while n1 (e) {S1 }, m1 (loop1 c )) (while n1 ((0, vof )) {S1 }, m1 (loop1 c )) by the EEval' rule )) by the E-Oflow1 or E-Oflow2 rule (while n1 (0) {S1 }, m1 (loop1 c (skip, m1 ) by the Wh-F1 rule.
2







Similarly, (s2 , m2 (loop2 c , 2 ))  (skip, m2 ). The loop counters for s1 and s2 are less than 1: · k > 0 : (s1 , m1 )  (S1k , m1k ), (s2 , m2 )  (S2k , m2k )      1 where S1k = skip, S2k = skip; and m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )       2 1 2 1 (s1 , m11 ), (s2 , m21 ) : (s1 , m1 )  (s1 , m11 (f1 , loop1 , m (S2 2 (loopc )) where loopc (n1 ) < 1 and loopc (n2 ) < 1. c , 11 ))  1 Besides, s and s both terminate when started in states m1 and 1 2 )) where ,  (s2 , m2 )  (s2 , m21 (f2 , loop2 21 c m2 : f1 = f2 = 0; and    21 (s1 , m1 )  (skip, m 1 1 ) and (s2 , m2 )  (skip, m2 ). loop1 c (n1 ) = loopc (n2 ) = 1; and   3. E e 1 = E e 2 = (v, vof ) where v  / {0, error}; x  TVar(s) : 11 (x) = 21 (x). The execution from (s1 , m1 (loop1 c , 1 )) proceeds as follows. 3. There are two configurations (s1 , m11 ) and (s2 , m21 ) reachable from (s1 , m1 ) and (s2 , m2 ) respectively, in which the loop (s1 , m1 (loop1 c , 1 )) counters of s1 and s2 are equal to 1 and value stores agree on = (while n1 (e) {S1 }, m1 (loop1 c , 1 )) the values of variables in TVar(s) and, for every state in execu(while n1 ((v, vof )) {S1 }, m1 (loop1   c , 1 )) by the EEval' rule tion, (s1 , m1 )  (s1 , m11 ) or (s2 , m2 )  (s2 , m21 ) the loop (while n1 (v ) {S1 }, m1 (loop1 c , 1 )) counters for s1 and s2 are less than or equal to 1 respectively: by rule E-Oflow1 or E-Oflow2  1 (s1 , m11 ) (s2 , m21 ) : (s1 , m1 )  (s1 , m11 (f1 , loop1 c , 11 ))  (S1 ; while n1 (e) {S1 }, m1 (loop1 c [1/(n1 )], 1 ))  1 (s2 , m2 )  (s2 , m21 (f2 , loop2 by the Wh-T1 rule. c , 21 )) where · f1 = f2 = 0; and 21 2 1 · loop1 c (n1 ) = loopc (n1 ) = 1; and Similarly, (s2 , m2 (loop2 c , 2 ))  (S2 ; while n2 (e){S2 }, 2 · x  TVar(s) : 11 (x) = 21 (x); and m2 (loopc [1/(n2 )], 2 )). After two steps of executions of s1   1   1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m11 ), loopc (n1 )  and s2 , crash flags are not set, the loop counter value of s1 and s2 are 1, value stores 1 and 2 agree on values of variables in 1; and     2 2 TVar(s). · m : ( s , m )  ( S , m ( loop ) , loop ))  ( s , m ( n )  2 2 2 21 2 2 2 2 c c We show that TVar(S1 )  TVar(s). By definition of loop 1. j variables, LVar(s1 ) = j 0 Imp(S1 , LVar(S1 )  Use(e)). By We show evaluations of the predicate expression of s1 and s2 0 0 notation of S , S = skip. By definition of imported variw.r.t value stores 1 and 2 produce same value. By the definition 0 ables, Imp(S1 , LVar(S1 )  Use(e)) = LVar(S1 )  Use(e). j of loop variables, LVar(s1 ) = j 0 Imp(S1 , LVar(S1 )  Use(e)). Then LVar ( S 1 )  LVar(s). By similar argument, we have 0 0 By our notation of S , S1 = skip. By the definition of loop CVar(S1 )  CVar(s). Hence, TVar(S1 )  TVar(s). Simivariables, Use(e)  LVar(s) = LVar(s1 ). By assumption, value larly, TVar(S2 )  TVar(s). By assumption, S1 and S2 either stores 1 and 2 agree on the values of the variables in Use(e). By both terminate or both do not terminate when started in state 2 Lemma D.1, the predicate expression e of s1 and s2 evaluates to m1 (loop1 c [1/(n1 )], 1 ) and m2 (loopc [1/(n2 )], 2 ) in which   same value v w.r.t value stores 1 , 2 , E e 1 = E e 2 . Then y  TVar(S1 )  TVar(S2 ), 1 (y ) = 2 (y ) and crash flags there are three possibilities. are not set. Then there are two possibilities: (a) S1 and S2 both terminate when started in states m1 ( 1. E  e 1 = E  e 2 = (error, ) 2 loop1 c [1/(n1 )], 1 ) and m2 (loopc [1/(n2 )], 2 ) respectively: The execution from (s1 , m1 (f1 , loop1 ,  )) proceeds as fol1 c  1 1 ( S , m ( loop [1 / ( n )] ,  ))  (skip, m11 (f1 , loop1 lows. 1 1 1 1 c , 11 )) c and  21 (s1 , m1 (f1 , loop1 (S2 , m2 (loop2 c , 1 )) c [1/(n2 )], 2 ))  (skip, m21 (f2 , loopc , 21 )). 1 = (while n1 (e) {S1 }, m1 (f1 , loopc , 1 )) We show that, after the full execution of S1 and S2 , the following five properties hold. (while n1 ((error, )) {S1 }, m1 (f1 , loop1 c , 1 )) by the EEval' rule
31 2015/9/14

m1 (loop1 c [1/(n1 )], 1 ) and By the definition of terminating execution, crash flags m2 (loop2 c [1/(n2 )], 2 ) respectively: k are not set, f1 = f2 = 0.  k > 0 , ( S1 , m1 (loop1 c [1/(n1 )], 1 ))  1 · The loop counter of s1 and s2 are of value 1, loop1 1 ( n ) = 1 1 c (S1k , m11k (loopc k , 11k )) and 1 loop2 c (n2 ) = 1. k (S2 , m2 (loop2 By the assumption of unique loop labels, s1  / S1 . Then, c [1/(n2 )], 2 ))  21 the loop counter value of n1 is not redefined in the (S2k , m21k (loopc k , 21k )) in which S1k = skip, S2k = execution of S1 by corollary E.2, loop1 c [1/n1 ](n1 ) = skip. 1 loop1 By our assumption of unique loop labels, s1  / S1 . Then, c (n1 ) = 1. Similarly, the loop counter value of n2 11 is not redefined in the execution of S2 , loop2 c [1/(n2 )](n2 ) k > 0, loopc k (n1 ) = loop1 c [1/(n1 )](n1 ) = 1. Similarly, 21 = loopc (n2 ) = 1. 21 k > 0, loopc k (n2 )  1 · In any state in the execution (s1 , m1 )  (s1 , m11 (loop1 c , 11 )), = loop2 c [1/(n2 )](n2 ) = 1. In addition, by Lemma E.2, the loop counter of s1 is less than or equal to 1. k k > 0, (S1 ; s1 , m1 (loop1 c [1/(n1 )], 1 ))  As is shown above, the loop counter of s1 is zero 1k (Sk ; s1 , m1k (loopc , 1k )) and in any of the two states in the one step execution k 1 2k (s1 , m1 )  (while n1 (v ) {S1 }, m1 (loopc , 1 )), and (S2 ; s2 , m2 (loop2 c [1/(n2 )], 2 ))  (S2k ; s2 , m2k (loopc , 2k )) the loop counter of s1 is 1 in any states in the execution in which S1k = skip, S2k = skip.  In summary, loop counters of s1 and s2 are less than or (S1 ; while n1 (e) {S1 }, m1 (loop1 c [i/(n1 )], 1 ))  11 equal to 1, and s1 and s2 do not terminate such that there are (s1 , m11 (loopc , 11 )).  no configurations (s1 , m11 ) and (s2 , m21 ) reachable from 1 · In any state in the executions (s2 , m2 )  (s2 , m21 (loop2 c , 21 )), (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags the loop counter of s2 is less than or equal to 1. are not set, the loop counters of s1 and s2 are equal to 1 and By similar argument above. value stores agree on the values of variables in TVar(s). · The value stores 11 and 21 agree on values of the termination deciding variables in s1 and s2 : x  Induction Step. TVar(s), 11 (x) = 21 (x). The induction hypothesis IH is that, for a positive integer i, one of We show that the imported variables in S1 relative to the following holds: those in LVar(s) are a subset of LVar(s) and the imported variables in S1 relative to those in CVar(s) are 1. The loop counters for s1 and s2 are less than i, and s1 and s2 a subset of CVar(s). both terminate in the same way:   LVar(s1 )    1 m 1 m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )  j  = j 0 Imp(S1 , LVar(S1 )  Use(e)) (1)  2 (S2 , m 2 (loopc )), by the definition of loop variables.  1 loopc (n1 ) < i and loop2 c (n2 ) < i and one of the following holds: Imp(S1 , LVar(s)) = Imp(S1 , LVar(s1 )) (a) s1 and s2 both terminate: = Imp(S1 , Imp(s1 , Use(e)  LVar(S1 )))    (s1 , m1 )  (skip, m 1 ) and (s2 , m2 )  (skip, m2 ). by the definition of LVar(s) j (b) s and s both do not terminate: 1 2 = Imp(S1 , j 0 Imp(S1 , LVar(S1 )  Use(e))) by (1) k k j k > 0, (s1 , m1 )  (S1k , m1k ) and (s2 , m2 )  (S2k , m2k ) = j 0 Imp(S1 , Imp(S1 , LVar(S1 )  Use(e))) in which S1k = skip, S2k = skip. by Lemma C.2 2. The loop counters for s1 and s2 are less than or equal to i, and j = j>0 Imp(S1 , LVar(S1 )  Use(e)) by Lemma C.1 s1 and s2 do not terminate such that there are no configurations j  j 0 Imp(S1 , LVar(S1 )  Use(e)) (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), = Imp(s1 , LVar(S1 )  Use(e)) = LVar(s1 ) = LVar(s). respectively, in which crash flags are not set, the loop counters Similarly, Imp(S1 , CVar(s))  CVar(s). Hence, of s1 and s2 are equal to i and value stores agree on the values Imp(S1 , TVar(s))  TVar(s). In the same way, we of variables in TVar(s):   can show that Imp(S2 , TVar(s))  TVar(s). Con 1  · m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )), (s2 , m2 )  sequently, the value stores 11 and 21 agree on the    2 1 2 (S2 , m2 (loopc )) where loopc (n1 )  i, loopc (n2 )  i; values of the imported variables in S1 and S2 relak k tive to those in TVar(s), x  Imp(S1 , TVar(s))  · k > 0 : (s1 , m1 )  (S1k , m1k ), (s2 , m2 )  (S2k , m2k ) Imp(S2 , TVar(s)), 1 (x, ) = 2 (x). Because S1 and where S1k = skip, S2k = skip; and  S2 have equivalent computation of every variable in i · (s1 , m1i ), (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i )) TVar(s) when started in states agreeing on the values  2i )) where ( f , loop ,  ( s , m )  ( s , m 2 2 2 2 2 2 i i c of the imported variables relative to TVar(s), by Thef1 = f2 = 0; and orem 1, value stores 11 and 21 agree on the values 2i i loop1 of the variables TVar(s), x  TVar(s), 11 (x) = c (n1 ) = loopc (n2 ) = i; and  x  TVar ( s ) :  21 (x). 1i (x) = 2i (x). It follows that, by Corollary E.1, 3. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable  from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags (S1 ; while n1 (e){S1 }, m1 (loop1 c [1/(n1 )], 1 ))  11 1 are not set, the loop counters of s1 and s2 are equal to i ( loop (while n1 (e) {S1 }, m11 (loop1 )) = ( s , m )) ,  ,  1 1 1 1 1 1 1 c c and value stores agree on the values of variables in TVar(s) and   (S2 ; while n2 (e) {S2 }, m2 (loop2 and, for every state in execution, (s1 , m1 )  (s1 , m1i ) or c [1/(n2 )], 2 ))   21 21 (while n2 (e) {S2 }, m21 (loopc , 21 )) = (s2 , m21 (loopc , 21 )). (s2 , m2 )  (s2 , m2i ) the loop counters for s1 and s2 are less (b) S1 and S2 do not terminate when started in states than or equal to i respectively:
· The crash flags are not set.

32

2015/9/14

i (s1 , m1i ) (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i ))  2i (s2 , m2 )  (s2 , m2i (f2 , loopc , 2i )) where · f1 = f2 = 0; and 2i i · loop1 c (n1 ) = loopc (n2 ) = i; and · x  TVar(s) : 1i (x) = 2i (x,; and     1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1i ), 1 loopc (n1 )  i; and     2 · m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2i ), 2 loopc (n2 )  i;



1. The loop counters for s1 and s2 are less than i:      1 m 1 m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )   2  (S2 , m2 (loopc )),  2 loop1 c (n1 ) < i and loopc (n2 ) < i and one of the following holds: (a) s1 and s2 both terminate:    (s1 , m1 )  (skip, m 1 ) and (s2 , m2 )  (skip, m2 ). (b) s1 and s2 both do not terminate: k k k > 0, (s1 , m1 )  (S1k , m1k ) and (s2 , m2 )  (S2k , m2k ) in which S1k = skip, S2k = skip. When this case holds, then we have the loop counters for s1 and s2 are less than i + 1, and s1 and s2 both terminate in the same way:      1 m 1 m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )    2 (S2 , m2 (loopc )),  2 loop1 c (n1 ) < i + 1 and loopc (n2 ) < i + 1 and one of the following holds: (a) s1 and s2 both terminate:    (s1 , m1 )  (skip, m 1 ) and (s2 , m2 )  (skip, m2 ). (b) s1 and s2 both do not terminate: k k k > 0, (s1 , m1 )  (S1k , m1k ) and (s2 , m2 )  (S2k , m2k ) in which S1k = skip, S2k = skip. 2. The loop counters for s1 and s2 are less than or equal to i, and s1 and s2 both do not terminate such that there are no configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop counters of s1 and s2 are equal to i and value stores agree on the values of variables in TVar(s):
  1 · m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )), (s2 , m2 )  


Then we show that, for the positive integer i + 1, one of the following holds: 1. The loop counters for s1 and s2 are less than i + 1, and s1 and s2 both terminate in the same way:      1 m 1 m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )     2 (S2 , m2 (loopc )),  2 loop1 c (n1 ) < i + 1 and loopc (n2 ) < i + 1 and one of the following holds: (a) s1 and s2 both terminate:    (s1 , m1 )  (skip, m 1 ) and (s2 , m2 )  (skip, m2 ). (b) s1 and s2 both do not terminate: k k k > 0, (s1 , m1 )  (S1k , m1k ) and (s2 , m2 )  (S2k , m2k ) in which S1k = skip, S2k = skip. 2. The loop counters for s1 and s2 are less than or equal to i + 1, and s1 and s2 do not terminate such that there are no configurations (s1 , m1i+1 ) and (s2 , m2i+1 ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are set, the loop counters of s1 and s2 are equal to i + 1 and value stores agree on the values of variables in TVar(s):
  1 · m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )), (s2 , m2 )  2 (S2 , m  2 (loopc )) where  1 loopc (n1 )  i + 1, loop2 c (n2 )  i + 1; k










· k > 0 : (s1 , m1 )  (S1k , m1k ), (s2 , m2 )  (S2k , m2k )
k

2 1 2 (S2 , m  2 (loopc )) where loopc (n1 )  i, loopc (n2 )  i; k k







· k > 0 : (s1 , m1 )  (S1k , m1k ), (s2 , m2 )  (S2k , m2k ) · (s1 , m1i+1 ), (s2 , m2i+1 ) :


where S1k = skip, S2k = skip; and

3. There are two configurations (s1 , m1i+1 ) and (s2 , m2i+1 ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop counters of s1 and s2 are equal to i + 1 and value stores agree on the values of variables in TVar(s) and, for every   state in execution, (s1 , m1 )  (s1 , m1i+1 ) or (s2 , m2 )  (s2 , m2i+1 ) the loop counters for s1 and s2 are less than or equal to i + 1 respectively: (s1 , m1i+1 ) (s2 , m2i+1 ) :   i+1 ,  (s1 , m1 )  (s1 , m1i+1 (loop1 1i+1 ))  (s2 , m2 )  c i+1 , 2i+1 )) where (s2 , m2i+1 (loop2 c i+1 i+1 · loop1 (n1 ) = loop2 (n2 ) = i + 1; and c c · x  TVar(s) : 1i+1 (x) = 2i+1 (x); and
  1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1i ), 


1i+1 , 1i+1 ))(s2 , m2 )  (s1 , m1 )  (s1 , m1i+1 (f1 , loopc 2i+1 (s2 , m2i+1 (f2 , loopc , 2i+1 )) where f1 = f2 = 0; and i+1 i+1 loop1 (n1 ) = loop2 (n2 ) = i + 1; and c c x  TVar(s) : 1i+1 (x) = 2i+1 (x).



where S1k = skip, S2k = skip; and  i (s1 , m1i ), (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i ))  i )) where ,  (s2 , m2 )  (s2 , m2i (f2 , loop2 2i c f1 = f2 = 0; and 2i i loop1 c (n1 ) = loopc (n2 ) = i; and x  TVar(s) : 1i (x) = 2i (x).



·

loop1 c (n1 )  i + 1; and     2 m 2 : (s2 , m2 )  (S2 , m2 (loopc ))   2 loopc (n2 )  i + 1;



(s2 , m2i ),

By the hypothesis IH, one of the following holds:

When this case holds, we have the loop counter of s1 and s2 are less than i + 1, and s1 and s2 both do not terminate:      1 m 1 m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and (s2 , m2 )    2 (S2 , m2 (loopc )),  2 loop1 c (n1 ) < i + 1 and loopc (n2 ) < i + 1 and s1 and s2 both do not terminate: k k k > 0, (s1 , m1 )  (S1k , m1k ) and (s2 , m2 )  (S2k , m2k ) in which S1k = skip, S2k = skip. 3. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are not set, the loop counters of s1 and s2 are equal to i and value stores agree on the values of variables in TVar(s)  and, for every state in executions (s1 , m1 )  (s1 , m1i ) and  (s2 , m2 )  (s2 , m2i ) the loop counters for s1 and s2 are less than or equal to i respectively:  i (s1 , m1i ) (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i ))  2i (s2 , m2 )  (s2 , m2i (f2 , loopc , 2i )) where · f1 = f2 = 0; and 1i i · loopc (n1 ) = loop2 c (n2 ) = i; and · x  TVar(s), 1i (x) = 2i (x); and
33 2015/9/14

2i i m1i (loop1 c [(i+1)/(n1 )], 1i ) and m2i (loopc [(i+1)/(n2 )], 2i ) respectively. Then there are two possibilities. i i. S1 and S2 terminate when started in states m1i (loop1 c [(i+ · (s2 , m2i ), 1)/(n1 )], 1i ) and i m2i (loop2 c [(i + 1)/(n2 )], 2i ) respectively  By similar argument in base case, evaluations of the predicate i (S1 ; s1 , m1i (loop1 c [(i + 1)/(n1 )], 1i ))  expression of s1 and s2 w.r.t value stores 1i and 2i produce i+1 )) and ,  (s1 , m1i+1 (f1 , loop1 1i+1 c same value. Then there are three possibilities:  i (S2 ; s1 , m2i (loop2 c [(i + 1)/(n2 )], 2i ))  (a) E  e 1i = E  e 2i = (error, ). 2i+1 (s2 , m2i+1 (f2 , loopc , 2i+1 )) such that all of the folThen the execution of s1 proceeds as follows. lowing holds: (s1 , m1i (f1 , 1i )) · f1 = f2 = 0; and = (while n1 (e) {S1 }, m1i (f1 , 1i )) i+1 i+1 · loop1 (n1 ) = loop2 (n2 ) = i + 1; and (while n1 ((error, )) {S1 }, m1i (f1 , 1i )) by the EEval' rule c c · y  TVar(s), 1i+1 (y ) = 2i+1 (y ), and (while n1 (0) {S1 }, m1i (1/f1 )) by the ECrash rule k · in any state in the execution (while n1 (0) {S1 }, m1i (1/f1 )), for any k  0, by the Crash rule.  i+1 , 1i+1 )), the (s1 , m1i )  (s1 , m1i+1 (loop1 c Similarly, the execution of s2 started in the state m2i (2i ) loop counter of s is less than or equal to i + 1. 1 does not terminate. · in any state in the executions The loop counters for s1 and s2 are less than i + 1:   i+1    1 , 2i+1 )), the (s2 , m2i )  (s2 , m2i+1 (loop2 m c 1 m2 such that (s1 , m1 )  (S1 , m1 (loopc )) and  loop counter of s   2 2 is less than or equal to i + 1. (s2 , m2 )  (S2 , m2 (loopc )),  With the hypothesis IH, there are two configurations 2 loop1 c (n1 ) < i + 1 and loopc (n2 ) < i + 1. (s1 , m1i+1 ) and (s2 , m2i+1 ) reachable from (s1 , m1 ) Besides, s1 and s2 both do not terminate when started in and (s2 , m2 ), respectively, in which crash flags are not states m1 and m2 , set, the loop counters of s1 and s2 are equal to i + 1 k k k > 0, (s1 , m1 )  (S1k , m1k ) and (s2 , m2 )  (S2k , m2k ) and value stores agree on the values of TVar(s) and, for  in which S1k = skip, S2k = skip. every state in executions (s1 , m1 )  (s1 , m1i+1 ) and   (b) E e 1i = E e 2i = (0, vof )  (s2 , m2 )  (s2 , m2i+1 ) the loop counters for s1 and i The execution from (s1 , m1i (loop1 c , 1i )) proceeds as fols 2 are less than or equal to i + 1 respectively: lows. (s1 , m1i+1 ) (s2 , m2i+1 ) : i   (s1 , m1i (loop1 i+1 c , 1i )) , 1i+1 ))(s2 , m2 )  (s1 , m1 )  (s1 , m1i+1 (f1 , loop1 c i = (while n1 (e) {S1 }, m1i (loop1 2i+1 c , 1i )) (s2 , m2i+1 (f2 , loopc , 2i+1 )) where i (while n1 ((0, vof )) {S1 }, m1i (loop1 c , 1i )) by rule EEval' · f1 = f2 = 0; and 1i (while n1 (0) {S1 }, m1i (loopc , 1i )) i+1 i+1 · loop1 (n1 ) = loop2 (n2 ) = i + 1; and c c by rule E-Oflow1 or E-Oflow2 · x  TVar(s), 1i+1 (x) = 2i+1 (x); and 1i (skip, m1i (loopc [0/(n1 )], 1i )) by the Wh-F2 rule.     1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  By the hypothesis IH, the loop counter of s1 and s2 in any  i+1  , 1i+1 )), loop1 (s1 , m1i+1 (loop1 i c c (n1 )  i + 1; configuration in executions (s1 , m1 )  (s1 , m1i (loop1 c , 1i )) and  i   and (s2 , m2 )  (s2 , m2i (loop2   2 c , 2i )) respectively are · m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  less than or equal to i,  i+1   , 2i+1 )), loop2 (s2 , m2i+1 (loop2   1 1i c c (n2 )  i + 1. m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1i (loopc ,  ii. S and S do not terminate when started in states 1 2 1 1i )), loopc (n1 )  i; and 2i i m1i (loop1 c [(i + 1)/(n1 )], 1i ) and m2i (loopc [(i +   2   2i m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2i (loopc , ) respectively: 1) / ( n )] ,  2 2i  k 2i )), loop2 i c (n2 )  i. k > 0, (S1 , m1i (loop1 c [(i + 1)/(n1 )], 1i ))  1 Therefore, s1 and s2 both terminate and the loop counter 1 (S1k , m11k (loopc k , 11k )) and of s1 and s2 in any state in executions respectively are less k i than i + 1. (S2 , m2i (loop2 c [(i + 1)/(n2 )], 2i ))  21   / {0, error}; (c) E e 1i = E e 2i = (v, vof ) where v  (S2k , m21k (loopc k , 21k )) in which S1k = skip, S2k = i The execution from (s1 , m1i (loop1 skip. c , 1i )) proceeds as follows. By our assumption of unique loop labels, s1  / S1 . 11 k i )) ,  (s1 , m1i (loop1 Then,  k > 0 , loop ( n ) = 1 c 1 i c i i loop1 = (while n1 (e) {S1 }, m1i (loop1 c [(i + 1)/(n1 )](n1 ) = i + 1. Similarly, k > c , 1i )) 21 i )) by rule EEval' ,  (while n1 ((v, vof )) {S1 }, m1i (loop1 1 0, loopc k (n2 ) = i c 1i 2 (while n1 ((v, vof )) {S1 }, m1i (loopc , 1i )) by rule EEval' loopci [(i + 1)/(n2 )](n2 ) = i + 1. In addition, by i (while n1 (v ) {S1 }, m1i (loop1 Lemma E.2, c , 1i )) k by rule E-Oflow1 or E-Oflow2 i k > 0, (S1 ; s1 , m1i (loop1 c [(i + 1)/(n1 )], 1i ))  i 11 (S1 ; while n1 (e) {S1 }, m1i (loop1 k c [(i + 1)/(n1 )], (S1k ; s1 , m11k (loopc , 11k )) and (S2 ; s2 , m2 (loop2 c [(i+ 1i )) by rule Wh-T. 21 k k 1)/(n2 )], 2 ))  (S2k ; s2 , m21k (loopc , 21k )) in 2 i Similarly, (s2 , m2i (loop2 c , 2i ))  (S2 ; while n2 (e){S2 }, which S1k = skip, S2k = skip. 2i m2i (loopc [(i + 1)/(n2 )], 2i )). In summary, the loop counter of s1 and s2 are less than By similar argument in base case, the executions of S1 equal to i + 1, and s1 and s2 do not terminate such that and S2 terminate in the same way when started in states   1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1i ),







loop1 c (n1 )  i; and     2 m 2 : (s2 , m2 )  (S2 , m2 (loopc ))   2 loopc (n2 )  i.



34

2015/9/14

there are no configurations (s1 , m1i+1 ) and (s2 , m2i+1 ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are not set, the loop counters of s1 and s2 are equal to i + 1 and value stores agree on values of variables in TVar(s).

Corollary 5.3. Let s1 = "while n1 (e){S1 }" and s2 = "while n2 (e){S2 }" be two while statements respectively, with the same set of the termination deciding variables, TVar(s1 ) = TVar(s2 ) = TVar(s), whose bodies S1 and S2 satisfy the proof rule of equivalently computation of variables in TVar(s), x  TVar(s) : (S1 ) S x (S2 ), and whose bodies S1 and S2 terminate in the same way when started in states with crash flags not set and agreeing on values of variables in TVar(S1 )  TVar(S2 ): mS1 (fS1 , S1 ), mS2 (fS2 , S2 ) : (((z  TVar(S1 )  TVar(S2 )), S1 (z ) = S2 (z ))  (fS1 = fS2 = 0))  (S1 , mS1 (fS1 , S1 )) H (S2 , mS2 (fS2 , S2 )). 2 If s1 and s2 start in the state m1 (f1 , loop1 c , 1 ) and m2 (f2 , loopc , , 2 ) respectively in which crash flags are not set, f1 = f2 = 0, s1 and s2 have not already executed, loop1 c (n1 ) = loop2 ( n ) = 0 , value stores  and  agree on values of variables 2 1 2 c in TVar(s), x  TVar(s), 1 (x) = 2 (x), then s1 and s2 terminate in the same way: 1. s1 and s2 both terminate, (s1 , m1 )  (skip, m 1 ), (s 2 , m 2 )  (skip, m 2 ). 2. s1 and s2 both do not terminate, k > 0, (s1 , m1 )  k (S1k , m1k ), (s2 , m2 )  (S2k , m2k ) where S1k = skip, S2k = skip. This is from Lemma 5.15 immediately. Lemma5.16 is necessary only for showing the same I/O sequence in the next section. Lemma 5.16. Let s1 = "while n1 (e){S1 }" and s2 = "while n2 (e){S2 }" be two while statements in program P1 and P2 respectively with the same set of termination deciding variables, TVar(s1 ) = TVar(s2 ) = TVar(s), whose bodies S1 and S2 satisfy the proof rule of equivalently computation of variables in TVar(s), x  TVar(s) : S1 S x S2 and whose bodies S1 and S2 terminate in the same way in executions when started in states with crash flags not set and agreeing on values of variables in TVar(S1 )  TVar(S2 ): mS1 (fS1 , S1 ) mS2 (fS2 , S2 ) : (((z  TVar(S1 )  TVar(S2 )), S1 (z ) = S2 (z ))  (fS1 = fS2 = 0)  (S1 , mS1 (fS1 , S1 )) H (S2 , mS2 (fS2 , S2 )). 2 If s1 and s2 start in the state m1 (f1 , loop1 c , 1 ) and m2 (f2 , loopc , , 2 ) respectively in which crash flags are not set, f1 = f2 = 0, s1 2 and s2 have not already executed, loop1 c (n1 ) = loopc (n2 ) = 0, value stores 1 and 2 agree on values of variables in TVar(s), x  TVar(s), 1 (x) = 2 (x), one of the following holds: 1. s1 and s2 both terminate and the loop counters of s1 and s2 are less than a positive integer i and less than or equal to i - 1:    (s1 , m1 )  (skip, m 1 ), (s2 , m2 )  (skip, m2 ) where both of the following hold: · The loop counters of s1 and s2 are less than a positive integer i:  i > 0 m 1 m2 :   1 1 (s 1 , m 1 )  (S1 , m 1 (loopc )), loopc (n1 ) < i and    2 2 (s 2 , m 2 )  (S2 , m 2 (loopc )), loopc (n2 ) < i. · 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respeck  

tively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to j and value stores agree on the values of variables in TVar(s), and for every state in ex  ecution (s1 , m1 )  (s1 , m1j ) or (s2 , m2 )  (s2 , m2j ), the loop counters for s1 and s2 are less than or equal to j respectively: (s1 , m1j ) (s2 , m2j ) : 1  (s1 , m1 )  (s1 , m1j (f1 , loopcj , 1j )) 2j  (s2 , m2 )  (s2 , m2j (f2 , loopc , 2j )) where f1 = f2 = 0; and 2 1 loopcj (n1 ) = loopcj (n2 ) = j ; and x  TVar(s) : 1j (x) = 2j (x); and
  1 m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1j ),  loop1 c (n1 )  j ; and     2 m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2j ),  loop2 c (n2 )  j . 




2. s1 and s2 both do not terminate, k > 0, (s1 , m1 )  k (S1k , m1k ), (s2 , m2 )  (S2k , m2k ) where S1k = skip, S2k = skip such that one of the following holds: (a) For any positive integer i, there are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to i and value stores agree on the values of variables in TVar(s),  and for every state in execution (s1 , m1 )  (s1 , m1i ) or  (s2 , m2 )  (s2 , m2i ), the loop counters for s1 and s2 are less than or equal to i respectively: i > 0 (s1 , m1i ) (s2 , m2i ) :  i (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i ))  2i (s2 , m2 )  (s2 , m2i (f2 , loopc , 2i )) where · f1 = f2 = 0; and 2i i · loop1 c (n1 ) = loopc (n2 ) = i; and · x  TVar(s) : 1i (x) = 2i (x); and     1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1i ), 1 loopc (n1 )  i; and     2 · m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2i ), 2 loopc (n2 )  i; (b) The loop counters for s1 and s2 are less than a positive integer i and less than or equal to i - 1 such that all of the following hold:
  1 · i > 0, m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )), 
 

k





1 2 (s 2 , m 2 )  (S2 , m  2 (loopc )) where loopc (n1 ) < i,  loop2 ( n ) < i ; 2 c · 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to j and value stores agree on the values of variables in TVar(s), and  for every state in execution (s1 , m1 )  (s1 , m1j ) or  (s2 , m2 )  (s2 , m2j ), the loop counters for s1 and s2 are less than or equal to j respectively: (s1 , m1j ) (s2 , m2j ) : 1  (s1 , m1 )  (s1 , m1j (f1 , loopcj , 1j )) 2  (s2 , m2 )  (s2 , m2j (f2 , loopcj , 2j )) where f1 = f2 = 0; and 2 1 loopcj (n1 ) = loopcj (n2 ) = j ; and x  TVar(s) : 1j (x) = 2j (x); and

35

2015/9/14

(c) The loop counters for s1 and s2 are less than or equal to some positive integer i such that all of the following hold:
  1 · i > 0 m 1 m2 : (s1 , m1 )  (S1 , m1 (loopc )),  2 (S2 , m  2 (loopc ))
 loop1 c (n1 )

  1 m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1j ), 1 loopc (n1 )  j ; and     2 m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2j ), 2 loopc (n2 )  j ;











  1 m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1j ), 1 loopc (n1 )  j ; and     2 m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2j ), 2 loopc (n2 )  j ; · There are no configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are not set, the loop counters of s1 and s2 are equal to i, and value stores agree on the values of variables in TVar(s): (s1 , m1i ) (s2 , m2i ) :  i (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i ))  i (s2 , m2 )  (s2 , m2i (f2 , loop2 c , 2i )) where f1 = f2 = 0; and 2i i loop1 c (n1 ) = loopc (n2 ) = i; and x  TVar(s) : 1i (x) = 2i (x).

where  i, (s 2 , m 2 )   loop2 ( n )  i ; 2 c · 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to j and value stores agree on the values of variables in TVar(s), and  for every state in execution (s1 , m1 )  (s1 , m1j ) or  (s2 , m2 )  (s2 , m2j ), the loop counters for s1 and s2 are less than or equal to j respectively: (s1 , m1j ) (s2 , m2j ) : 1  (s1 , m1 )  (s1 , m1j (f1 , loopcj , 1j )) 2j  (s2 , m2 )  (s2 , m2j (f2 , loopc , 2j )) where f1 = f2 = 0; and 2 1 loopcj (n1 ) = loopcj (n2 ) = j ; and x  TVar(s) : 1j (x) = 2j (x); and





Proof. From lemma 5.15, we have s1 and s2 terminate in the same way when started in states m1 and m2 respectively. Then there are two big cases. 1. s1 and s2 both terminate. Let i be the smallest integer such that the loop counters of s1 and s2 are less than i in the executions. Then there are two possibilities. (a) i = 1. In the proof of Lemma 5.15, the evaluation of the loop predicate of s1 and s2 produce zero w.r.t value stores, 1 and 2 . Then the execution of s1 proceeds as follows: (s1 , m1 (loop1 c , 1 )) = (while n1 (e) {S1 }, m1 (loop1 c )) (while n1 ((0, vof )) {S1 }, m1 (loop1 c )) by rule EEval' (while n1 (0) {S1 }, m1 (loop1 c )) by rule E-Oflow1 or E-Oflow2 (skip, m1 (loop1 c \ {(n1 , )})) by rule Wh-F1 or Wh-F2.

2 Similarly, (s2 , m2 (loop2 c , 2 ))  (skip, m2 (loopc \ {(n2 , , )})). Then the lemma holds because of the initial config2 uration (s1 , m1 (loop1 c , 1 )) and (s2 , m2 (loopc , 2 )). (b) i > 1. Because s1 and s2 terminate, i is the smallest positive integer such that the loop counters of s1 and s2 are less than i, by Lemma 5.15, 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to j and value stores agree on the values of variables in TVar(s),  and for every state in execution, (s1 , m1 )  (s1 , m1j ) or  (s2 , m2 )  (s2 , m2j ) the loop counters for s1 and s2 are less than or equal to j respectively. With the initial configuration (s1 , m1 ) and (s2 , m2 ), the lemma holds. 2. s1 and s2 both do not terminate. There are three possibilities. (a) i > 0, there are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to i and value stores agree on the values of variables in TVar(s), and for every state in execution,   (s1 , m1 )  (s1 , m1i ) or (s2 , m2 )  (s2 , m2i ) the loop counters for s1 and s2 are less than or equal to i respectively. (b) The loop counters of s1 and s2 are less than a positive integer i. Let i be the smallest positive integer such that there is no positive integer j < i that the loop counters of s1 and s2 are less than the positive integer j . This case occurs when s1 and s2 finish the full (i - 1)th iterations and both executions raise an exception in the evaluation of the loop predicate of s1 and s2 for the ith time. There are further two possibilities. i. i = 1. In proof of Lemma 5.15, evaluations of the predicate expression of s1 and s2 raise an exception w.r.t value stores 1 and 2 . The lemma holds. ii. i > 1. By the assumption of initial states (s1 , m1 ) and (s2 , m2 ), when j = 0, initial states (s1 , m1 ) and (s2 , m2 ) have crash flags not set, the loop counters of s1 and s2 are zero and value stores agree on values of variables of s1 and s2 . By Lemma 5.15, 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to j and value stores agree on the values of variables in TVar(s),  and for every state in execution, (s1 , m1 )  (s1 , m1j )  or (s2 , m2 )  (s2 , m2j ) the loop counters for s1 and s2 are less than or equal to j respectively. With the initial configuration (s1 , m1 ) and (s2 , m2 ), the lemma holds. (c) The loop counters of s1 and s2 are less than or equal to a positive integer i. Let i be the smallest positive integer such that the loop counters of s1 and s2 are less than or equal to the positive integer i. There are two possibilities. i. i = 1. In the proof of Lemma 5.15, the execution of s1 proceeds as follows: (s1 , m1 (loop1 c , 1 )) = (while n1 (e) {S1 }, m1 (loop1 c , 1 )) (while n1 ((v, vof )) {S1 }, m1 (loop1 c , 1 )) where v = 0 by rule EEval' (while n1 (v ) {S1 }, m1 (loop1 c , 1 )) by rule E-Oflow1 or E-Oflow2

2

36

2015/9/14

(S1 ; while n1 (e) {S1 }, m1 (loop1 c [1/(n1 )], 1 )) by rule Wh-T . The execution of s2 proceeds to (S2 ; while n2 (e) {S2 }, m2 (loop2 c [1/(n2 )], 2 )). In addition, executions of S1 and S2 do not terminate when started in states m1 (loop1 c [1/(n1 )], 1 ) and m2 (loop2 [1 / ( n )] ,  ) . By Lemma E.2, executions of 2 2 c s1 and s2 do not terminate. ii. i > 1. In the proof of Lemma 5.15, when started in the state i-1 , 1i-1 )) the execution of s1 (s1 , m1i-1 (f1 , loop1 c proceeds as follows: i-1 , 1i-1 )) (s1 , m1i-1 (f1 , loop1 c i-1 , 1i-1 )) = (while n1 (e) {S1 }, m1i-1 (f1 , loop1 c i-1 , 1i-1 )) (while n1 ((v, vof )) {S1 }, m1i-1 (f1 , loop1 c by rule EEval' i-1 , 1i-1 )) (while n1 (v ) {S1 }, m1i-1 (f1 , loop1 c by rule E-Oflow1 or E-Oflow2 (S1 ; while n1 (e) {S1 }, i-1 [i/(n )],  m1i-1 (f1 , loop1 1 1i-1 )) c by rule Wh-T1 or Wh-T2. The execution of s2 proceeds to (S2 ; while n2 (e) {S2 }, i-1 [i/(n2 )], 2i-1 )). In addition, exem2i-1 (f2 , loop2 c cutions of S1 and S2 do not terminate when started in i-1 [i/(n1 )], 1i-1 ) and states m1i-1 (f1 , loop1 c i-1 [ i/ ( n )], 2i-1 ). By Lemma E.2, m2i-1 (f2 , loop2 2 c executions of s1 and s2 do not terminate.

1. Impo (S ) = {idIO }, if (e : "output e"  / S ); 2. Impo ("output e") = {idIO }  Use(e); 3. Impo ("If (e) then {St } else {Sf }") = Use(e)  Impo (St )  Impo (Sf ) if (e : "output e"  S ); 4. Impo ("while n (e){S  }") = Imp("while n (e){S  }", {idIO }) if (e : "output e"  S  ); 5. For k > 0, Impo (s1 ; ...; sk ; sk+1 ) = Imp(s1 ; ...; sk , Impo (sk+1 )) if (e : "output e"  sk+1 ); 6. For k > 0, Impo (s1 ; ...; sk ; sk+1 ) = Impo (s1 ; ...; sk ) if (e : "output e"  / sk+1 ); Definition 22. (Termination deciding variables relative to output) The termination deciding variables in a statement sequence S relative to output, written TVaro (S ), are listed as follows: 1. TVaro (S ) =  if (e : "output e"  / S ); 2. TVaro ("output e") = Err(e); 3. TVaro ("If (e) then {St } else {Sf }") = Use(e)  TVaro (St )  TVaro (Sf ) if (e : "output e"  S ); 4. TVaro ("while n (e){S  }") = TVar("while n (e){S  }") if (e : "output e"  S  ); 5. For k > 0, TVaro (s1 ; ...; sk ; sk+1 ) = TVar(s1 ; ...; sk ) Imp(s1 ; ...; sk , TVaro (sk+1 )) if (e : "output e"  sk+1 ); 6. For k > 0, TVaro (s1 ; ...; sk ; sk+1 ) = TVaro (s1 ; ...; sk ) if (e : "output e"  / sk+1 ); Definition 23. (Output deciding variables) The output deciding variables in a statement sequence S are Impo (S )  TVaro (S ), written OVar(S ). The condition of the behavioral equivalence is defined recursively. The base case is for two same output statements or two statements where the output sequence variable is not defined. The inductive cases are syntax directed considering the syntax of compound statements and statement sequences. Definition 24. (proof rule of behavioral equivalence) Two statement sequences S1 and S2 satisfy the proof rule of behavioral equivalence, written S1 S O S2 , iff one of the following holds:

5.4 Behavioral equivalence We now propose a proof rule under which two programs produce the same output sequence, namely the same I/O sequence till any ith output value. We care about the I/O sequence due to the possible crash from the lack of input. We start by giving the definition of the same output sequence, then we describe the proof rule under which two programs produce the same output sequence, finally we show that our proof rule ensures same output together with the necessary auxiliary lemmas. We use the notation "Out( )" to represent the output sequence in value store  , the I/O sequence  (idIO ) till the rightmost output value. Particularly, when there is no output value in the I/O sequence  (idIO ), Out( ) = . Definition 20. (Same output sequence) Two statement sequences S1 and S2 produce the same output sequence when started in states m1 and m2 respectively, written (S1 , m1 ) O (S2 , m2 ), iff       m 1 m2 such that (S1 , m1 )  (S1 , m1 (1 )) and (S2 , m2 )       (S2 , m2 (2 )), there are states m1 m2 reachable from initial     states m1 and m2 , (S1 , m1 )  (S1 , m 1 (1 )) and (S2 , m2 )         (S2 , m2 (2 )) so that Out(2 ) = Out(1 ) and Out(1 ) = Out(2 ). 5.4.1 Proof rule for behavioral equivalence We show the proof rules of the behavioral equivalence. The output sequence produced in executions of a statement sequence S depends on values of a set of variables in the program, the output deciding variables OVar(S ). The output deciding variables are of two parts: TVaro (S ) are variables affecting the termination of executions of a statement sequence; Impo (S ) are variables affecting values of the I/O sequence produced in executions of a statement sequence. The definitions of TVaro (S ) and Impo (S ) are shown in Definition 21 and 22. Definition 21. (Imported variables relative to output) The imported variables in one program S relative to output, written Impo (S ), are listed as follows:
37

1. S1 and S2 are one statement and one of the following holds: (a) S1 and S2 are simple statement and one of the following holds: i. S1 and S2 are not output statement, e1 e2 : ("output e1 " = S1 )  ("output e2 " = S2 ); or ii. S1 = S2 = "output e". f t t (b) S1 = "If (e) then {S1 } else {S1 }", S2 = "If (e) then {S2 } else f {S2 }" and all of the following hold: · There is an output statement in S1 and S2 , e1 e2 : ("output e1 "  S1 )  ("output e2 "  S2 ); f f t t S · (S1 S O S2 )  (S1  O S2 );   (c) S1 = "while n1 (e) {S1 }" and S2 = "while n2 (e) {S2 }" and all of the following hold: · There is an output statement in S1 and S2 , e1 e2 : ("output e1 "  S1 )  ("output e2 "  S2 );   · S1 S O S2 ;   · S1 and S2 have equivalent computation of OVar(S1 )  OVar(S2 );   · S1 and S2 satisfy the proof rule of termination in the   same way, S1 S H S2 ; (d) Output statements are not in both S1 and S2 , e1 e2 : ("output e1 "  / S1 )  ("output e2 "  / S2 ). 2. S1 and S2 are not both one statement and one of the following holds:

2015/9/14

  (a) S1 = S1 ; s1 and S2 = S2 ; s2 , and all of the following hold:   · S1 S S ; O 2   · S1 and S2 have equivalent computation of OVar(s1 )  OVar(s2 );   · S1 and S2 satisfy the proof rule of termination in the   same way: S1 S H S2 ; · There is an output statement in both s1 and s2 , e1 e2 : ("output e1 "  s1 )  ("output e2 "  s2 ); · s1 S O s2 ; (b) There is no output statement in the last statement in S1 or S2 :   (S1 = S1 ; s 1 )  (S1 S / s1 ) O S2 )  (e : "output e"     (S2 = S2 ; s 2 )  (S1  S / s2 ) ; O S2 )  (e : "output e" 

(output 0, m1 (1/f)) by the ECrash rule i (output 0, m1 (1/f)) for any i > 0 by the Crash rule. Similarly, the execution of S2 does not terminate and there is no change to I/O sequence in execution. Because 1 (idIO ) = 2 (idIO ), then the output sequence in value stores 1 and 2 are same, Out(1 ) = Out(2 ), the theorem holds. (b) E e 1 = E e 2 = (error, vof ) S1 and S2 satisfy the proof rule of equivalent computation of I/O sequence variable and their initial states agree on the values of the imported variables relative to I/O sequence variable. By Theorem 2, S1 and S2 produce the same output sequence after terminating execution when started in state m1 (1 ) and m2 (2 ) respectively. The theorem holds. Induction step. The hypothesis IH is that Theorem 5 holds when size(S1 ) + size(S2 ) = k  2. We show Theorem 5 holds when size(S1 ) + size(S2 ) = k + 1. The proof is a case analysis according to the cases in the definition of the proof rule of behavioral equivalence. 1. S1 and S2 are one statement and one of the following holds:
f t (a) S1 = "If(e) then {S1 } else {S1 }" and S2 = "If(e) then f t {S2 } else {S2 }" and all of the following hold:

5.4.2 Soundness of the proof rule for behavioral equivalence We show that two statement sequences satisfy the proof rule of the behavioral equivalence and their initial states agree on values of their output deciding variables, then the two statement sequences produce the same output sequence when started in their initial states. Theorem 5. Two statement sequences S1 and S2 satisfy the proof rule of the behavioral equivalence, S1 S O S2 . If S1 and S2 start in states m1 (f1 , 1 ) and m2 (f2 , 2 ) where both of the following hold:
· Crash flags are not set, f1 = f2 = 0; · Value stores 1 and 2 agree on values of the output decid-

ing variables of S1 and S2 , id  OVar(S1 )  OVar(S2 ) : 1 (id) = 2 (id); then S1 and S2 produce the same output sequence, (S1 , m 1 )  O (S2 , m 2 ).

· There is an output statement in S1 and S2 : e1 e2 :
t t · S1 S O S2 ; f f S · S1  O S2 ;

("output e1 "  S1 )  ("output e2 "  S2 );

The proof is by induction on the sum of program size of S1 and S2 , size(S1 ) + size(S2 ) and is a case analysis based on S1 S O S2 .

Proof. The proof is by induction on the sum of program size of S1 and S2 , size(S1 ) + size(S2 ) and is a case analysis based on S1 S O S2 . Base case. S1 and S2 are simple statement. There are two cases according to the proof rule of behavioral equivalence because stacks are not changed in executions of S1 and S2 . 1. S1 and S2 are not output statement, e1 e2 : ("output e1 " = S1 )  ("output e2 " = S2 ); By the definition of imported variables relative to output, Impo (S1 ) = Impo (S2 ) = {idIO }. By assumption, initial value stores 1 and 2 agree on the value of the I/O sequence variable, 1 (idIO ) = 2 (idIO ). By definition, Out(1 ) = Out(2 ). By Lemma 5.23, in any state m 1 reachable from m1 , the output  is same as that in m1 , m sequence in m 1 1 : ((S1 , m1 (1 ))      (S1 , m1 (1 )))  (Out(1 ) = Out(1 )). Similarly, for any  state m 2 reachable from m2 , the output sequence in m2 is same as that in m2 . The theorem holds. 2. S1 = S2 = "output e". We show that the expression e evaluates to the same value w.r.t value stores, 1 , 2 . By the definition of imported variables relative to output, Impo (S1 ) = Impo (S2 ) = Use(e)  {idIO }. Then x  Use(e)  {idIO } : 1 (x) = 2 (x) by assumption. By Lemma D.1, E e 1 = E e 2 . Then, there are two possibilities. (a) E e 1 = E e 2 = (error, vof ). The execution of S1 proceeds as follows. (output e, m1 (1 )) = (output (error, vof ), m1 (1 )) by the rule EEval'

By Lemma 5.17, {idIO }  Impo (S1 ). By assumption, value stores 1 and 2 agree on the value of the I/O sequence variable and the I/O sequence variable, 1 (idIO ) = 2 (idIO ). We show that the evaluations of the predicate expression of S1 and S2 w.r.t. initial value store 1 and 2 produce the same value. We need to show that value stores 1 and 2 agree on values of variables used in the predicate expression e of S1 and S2 . Because the output sequence is defined in S1 , by the definition of imported variables relative to f t )  Impo (S1 ). Thus, output, Impo (S1 ) = Use(e)  Impo (S1 Use(e)  OVar(S1 ). By assumption, value stores 1 and 2 agree on values of variables used in the predicate expression e of S1 and S2 , x  Use(e) : 1 (x) = 2 (x). By Lemma D.1, the evaluations of the predicate expression of S1 and S2 w.r.t. pairs value stores, 1 and 2 generate the same value, E  e 1 = E  e 2 . Then there are two possibilities. i. E  e 1 = E  e 2 = (error, vof ). Then the execution of S1 proceeds as follows:
f t (If(e) then {S1 } else {S1 }, m1 (1 )) f t (If((error, vof )) then {S1 } else {S1 }, m1 (1 )) by the EEval' rule f t (If(0) then {S1 } else {S1 }, m1 (1/f)) by the ECrash rule i f t (If(0) then {S1 } else {S1 }, m1 (1/f)) for any i > 0, by the Crash rule. Similarly, the execution of S2 does not terminate and does not redefine I/O sequence. Because 1 (idIO ) = 2 (idIO ), the theorem holds. ii. E  e 1 = E  e 2 = (error, vof ). W.l.o.g., E  e 1 = E  e 2 = (0, vof ). The execution of S1 proceeds as follows.

38

2015/9/14

f t (If(e) then {S1 } else {S1 }, m1 (1 )) f t (If((0, vof )) then {S1 } else {S1 }, m1 (1 )) by the EEval rule f t (If(0) then {S1 } else {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule f (S1 , m1 (1 )) by the If-F rule. f Similarly, the execution of S2 proceeds to (S2 , m2 (2 )) f after two steps. By the hypothesis IH, we show that S1 f and S2 produce the same output sequence when started in states m1 (1 ) and m2 (2 ). We need to show that all required conditions are satisfied. f f · size(S1 ) + size(S2 )  k. f t By definition, size(S1 ) = 1 + size(S1 ) + size(S1 ). f f Therefore, size(S1 ) + size(S2 ) < k. · Value stores 1 and 2 agree on values of the outf f f deciding variables of S1 and S2 , x  OVar(S1 ) f OVar(S2 ) : 1 (x) = 2 (x). By the definition of imported variables relative to f output, Impo (S1 )  Impo (S1 ). Besides, by the f definition of TVaro (S1 ), TVaro (S1 )  TVaro (S1 ). f f Then OVar(S1 )  OVar(S1 ). Similarly, OVar(S2 ) OVar(S2 ).By assumption, the value stores 1 and 2 agree on the values of the out-deciding variables of f f S1 and S2 . f f By the hypothesis IH, S1 and S2 produce the same output sequence when started from state m1 (1 ) and m2 (2 ) respectively. The theorem holds.   (b) S1 = "while n1 (e) {S1 }" and S2 = "while n2 (e) {S2 }" and all of the following hold:

By Lemma 5.19, Impo (S1 ) = Impo (S2 ). By definition, Impo (S1 ) = Imp(S1 , {idIO }) and Impo (S2 ) = Imp(S2 , {idIO }). Thus, Imp(S1 , {idIO }) = Imp(S2 , {idIO }). · The loop body of S1 and S2 produce the same output sequence when started in states with crash flags not set and whose value stores agree on values of the out-deciding        (f1 , 1 ) mS  (f2 , 2 ) : variables of S1 and S2 , mS1 2     ((x  OVar(S1 )  OVar(S2 ) : 1 (x) = 2 (x))          (f1 , 1 )) O (S2 , mS  (f2 , 2 )). (f 1 = f2 = 0))  (S1 , mS1 2  Because size(S1 ) = 1 + size(S1 ), size(S2 ) = 1 +    size(S2 ), then size(S1 ) + size(S2 ) < k. By the hypothesis IH, the condition is satisfied. By Corollary 5.5, S1 and S2 produce the same output sequence when started in states m1 (1 ) and m2 (2 ) respectively. The theorem holds. (c) Output statements are not in both S1 and S2 , e1 e2 : ("output e1 "  / S1 )  ("output e2 "  / S2 ). By Lemma 5.17, {idIO }  Impo (S1 ). By assumption, value stores in initial states m1 , m2 agree on values of the I/O sequence variable, 1 (idIO ) = 2 (idIO ). By Lemma 5.23, the value of output sequence is same in m1   and any state reachable from m1 , m 1 m2 : (S1 , m1 (1 ))         (S1 , m 1 (1 )) and (S2 , m2 (2 ))  (S2 , m2 (2 )), Out(1 ) =  Out(1 ) = Out(2 ) = Out(2 ). The theorem holds.
  2. S1 = S1 ; s1 and S2 = S2 ; s2 are not both one statement and one of the following holds:

(a) There is an output statement in both s1 and s2 , e1 e2 : ("output e1 "  s1 )  ("output e2 "  s2 ), and all of the following hold:
  · S1 S O S2 ;   · S1 and S2 satisfy the proof rule of termination in the

· There is an output statement in S1 and S2 : e1 e2 :
  · S1 S O S2 ; · Both loop bodies satisfy the proof rule of termination in   · S1 and S2 have equivalent computation of OVar(S1 )    the same way: S1 S H S2 ;

("output e1 "  S1 )  ("output e2 "  S2 );

  same way: S1 S H S2 ;   · S1 and S2 have equivalent computation of OVar(s1 )  OVar(s2 ); · s1 S O s2 ;   By the hypothesis IH, we show S1 and S2 produce the same output sequence when started in states m1 (1 ) and m2 (2 ) respectively. We need to show that all required conditions are satisfied.   · size(S1 ) + size(S2 ) < k. By the definition of program size, size(s1 )  1, size(s2 )    ) < k. 1. Then size(S1 ) + size(S2 · Value stores 1 and 2 agree on values of the out   deciding variables of S1 and S2 , x  OVar(S1 )  OVar(S2 ) : 1 ( x ) = 2 ( x ) .  )  TVaro (S1 ). We show that TVaro (S1  TVaro (S1 )   TVar(S1 ) by Lemma 5.20  TVaro (S1 ) by the definition of TVaro (S1 )  We show that Impo (S1 )  Impo (S1 ).  Impo (S1 )   Imp(S1 , {idIO }) (1) by Lemma 5.18

OVar(S2 );

By Corollary 5.5, we show that S1 and S2 produce the same output sequence when started in states m1 (1 ) and m2 (2 ) respectively. We need to show that the required conditions are satisfied. · Crash flags are not set, f1 = f2 = 0. · Value stores 1 and 2 agree on the values of the outdeciding variables of S1 and S2 , x  OVar(S1 )  OVar(S2 ) : 1 (x) = 2 (x). · The loop counter value of S1 and S2 are zero in initial 2 loop counter, loop1 c (n1 ) = loopc (n2 ) = 0. · The loop body of S1 and S2 satisfy the proof rule of   termination in the same way, S1 S H S2 . · The loop body of S1 and S2 satisfy the proof rule of equivalent computation of OVar(S1 )  OVar(S2 ). The above five conditions are from assumption. · S1 and S2 have same set of termination deciding variables, TVar(S1 ) = TVar(S2 ). By the definition of TVaro (S1 ), TVaro (S1 ) = TVar(S1 ) and TVaro (S2 ) = TVar(S2 ). By Lemma 5.21, TVaro (S1 ) = TVaro (S2 ). Thus, TVar(S1 ) = TVar(S2 ). · S1 and S2 have same set of imported variables relative to the I/O sequence variable, Imp(S1 , {idIO }) = Imp(S2 , {idIO }).
39

{idIO }  Impo (sk+1 ) (2) by Lemma 5.17 Combining (1) + (2)  Imp(S1 , {idIO })   Imp(S1 , Impo (s1 )) by Lemma C.2 = Impo (S1 ) by the definition of Impo (S ).
2015/9/14

 Similarly, OVar(S2 )  OVar(S2 ). By assumption, value stores 1 and 2 agree on values of out-deciding vari  ables of S1 and S2 .   By the hypothesis IH, S1 and S2 produce the same output sequence when started in state m1 (1 ) and m2 (2 ) respectively. We show that S1 and S2 produce the same output sequence   if s1 and s2 execute. We need to show that S1 and S2 terminate in the same way when started in states m1 (1 ) and m2 (2 ) respectively. Specifically, we prove that the value stores 1 and 2 agree on the values of termination deciding   variables of S1 and S2 . By definition, the termination decid ing variables in S1 are a subset of the termination deciding  variables relative to output, TVar(S1 )  TVaro (S1 ). Sim ilarly, TVar(S2 )  TVaro (S2 ). By assumption, the value stores 1 and 2 agree on the values of the termination de    ciding variables of S1 and S2 , x  TVar(S1 )  TVar(S2 ) :   1 (x) = 2 (x). By Theorem 4, S1 and S2 terminate in the same way when started in state m1 (1 ) and m2 (2 ) respectively.   If S1 and S2 terminate when started in states m1 (1 ) and   m2 (2 ), by Lemma 5.14, S1 and S2 consume same amount of input values. In addition, we show that value stores agree on values of the out-deciding variables of s1 and s2 by   Theorem 2. We need to show that S1 and S2 start execution  in states agreeing on values of the imported variables in S1  and S2 relative to the out-deciding variables of s1 and s2 .  · Imp(TVaro (s1 ), S1 )  TVaro (S1 ). This is by the definition of TVaro (S1 ).  · Imp(Impo (s1 ), S1 ) = Impo (S1 ). This is by the definition of Impo (S1 ).  relative to the outThus, the imported variables in S1 deciding variables of s1 are a subset of the out-deciding  variables of S1 , Imp(S1 , OVar(s1 ))  OVar(S1 ). Simi larly, Imp(S2 , OVar(s2 ))  OVar(S2 ). By Corollary 5.4, s1 and s2 have same out-deciding variables, OVar(s1 ) =   OVar(s2 ). By assumption, S1 and S2 terminate when   started in states m1 (1 ) and m2 (2 ), (S1 , m1 (1 ))        (skip, m1 (1 )), (S2 , m1 (2 ))  (skip, m2 (2 )). By The  orem 2, value stores 1 and 2 agree on values of the outdeciding variables of s1 and s2 . By the hypothesis IH again, s1 and s2 produce the same    output sequence when started in states m 1 (1 ) and m2 (2 ) respectively. The theorem holds. (b) There is no output statement in the last statement in S1 or  S2 : W.l.o.g., (e : "output e"  / s1 )  ((S1 ) S O (S2 )).  and S2 produce the By the hypothesis IH, we show that S1 same output sequence when started in states m1 (1 ) and m2 (2 ) respectively. We need to show that two required conditions are satisfied.  · size(S1 ) + size(S2 )  k.  size(s1 )  1 by definition. Then size(S1 ) + size(S2 )  k.  · x  OVar(S1 )  OVar(S2 ) : 1 (x) = 2 (x).  By definition of TVaro (S )/Impo (S ), TVaro (S1 ) =  TVaro (S1 ), and Impo (S1 ) = Impo (S1 ) Hence, x   OVar(S1 )  OVar(S2 ) : 1 (x) = 2 (x).  Therefore, S1 and S2 produce the same output sequence when started in state m1 (1 ) and m2 (2 ) respectively,  (S1 , m1 ) O (S2 , m2 ) by the hypothesis IH.  When the execution of S1 terminates, then the output sequence is not changed in the execution of s1 by Lemma 5.23. The theorem holds.

5.4.3 Supporting lemmas for the soundness proof of behavioral equivalence We listed the lemmas and corollaries used in the proof of Theorem 5 below. The supporting lemmas are of two parts. One part is various properties related to the out-deciding variables. The other part is the proof that two loop statements produce the same output sequence. Lemma 5.17. For any statement sequence S , the I/O sequence variable is in imported variable in S relative to output, idIO  Impo (S ). Proof. By structure induction on abstract syntax of S . Lemma 5.18. For any statement sequence S , the imported variables in S relative to output are a subset of the imported variables in S relative to the I/O sequence variable, Impo (S )  Imp(S, {idIO }). Proof. By induction on abstract syntax of S . In every case, there are subcases based on if there is output statement in the statement sequence S or not if necessary. Lemma 5.19. If two statement sequences S1 and S2 satisfy the proof rule of behavioral equivalence, then S1 and S2 have the same set of imported variables relative to output, (S1 S O S2 )  (Impo (S1 ) = Impo (S2 )). Proof. By induction on size(S1 ) + size(S2 ). Lemma 5.20. For any statement sequence S and any variable x, the termination deciding variables in S relative to output is a subset of the termination deciding variables in S , TVaro (S )  TVar(S ). Proof. By induction on abstract syntax of S . In every case, there are subcases based on if there is output statement in the statement sequence S or not if necessary. Lemma 5.21. If two statement sequences S1 and S2 satisfy the proof rule of behavioral equivalence, then S1 and S2 have the same set of termination deciding variables relative to output, (S1 S O S2 )  (TVaro (S1 ) = TVaro (S2 )). Proof. By induction on size(S1 ) + size(S2 ). Corollary 5.4. If two statement sequences S1 and S2 satisfy the proof rule of behavioral equivalence, then S1 and S2 have the same set of out-deciding variables, (S1 S O S2 )  OVar(S1 ) = OVar(S2 ). Proof. By Lemma 5.19, Impo (S1 ) = Impo (S2 ). By Lemma 5.21, TVaro (S1 ) = TVaro (S2 ). Lemma 5.22. In one step execution (S, m( ))  (S  , m (  )), if there is no output statement in S , then the output sequence is same in value store  and   , Out(  ) = Out( ). Proof. By induction on abstract syntax of S and crash flag f in state m. Lemma 5.23. If there is no output statement in S , then, after the  execution (S, m( ))  (S  , m (  )), the output sequence is same in value store  and   , Out(  ) = Out( ).

40

2015/9/14

Proof. By induction on number k of execution steps in the execuk tion (S, m( ))  (S  , m (  )). The proof also relies on the fact that if s  / S , then s  / S. Lemma 5.24. One while statement s = "while n (e){S }" starts in a state m(f, loopc ) in which the loop counter of s is zero, loopc (n) = 0 and the crash flag is not set, f = 0. For any positive integer i, if there is a state m (m c ) reachable from m in which the loop counter is i, loop c (n) = i, then there is a configuration (S ; s, m (f , loop c )) reachable from the configuration (s, m) in which loop counter of s is i, loop c (n) = i and the crash flag is not set, f = 0:  i > 0 : (((s, m(f, mc ))  (S  , m (f , loop c )))  (loopc (n) = 0)  (f = 0)  (loop ( n ) = i ))  c  (s, m(f, loopc ))  (S ; s, m (f, loop c )) where f = 0 and  loopc (n) = i. Proof. The proof is by induction on i. Base case i = 1. We show that the evaluation of the loop predicate of s w.r.t the value store  in the state m(loopc ,  ) produces an nonzero integer value. By our semantic rule, if the evaluation of the predicate expression of s raises an exception, the execution of s proceeds as follows:

the configuration (S ; s, mi (f, loopi c , i )) reachable from (s, m) in which the loop counter is i, loopi ( c n) = i, and the crash flag is not set, f = 0. By the assumption of unique loop labels, s  / S . Then the loop counter of s is not redefined in the execution of S started in state mi (f, loopi c , i ). Because there is a configuration in which the loop counter of s is i + 1, then the execution of S when started  i in the state mi (f, loopi c , i ) terminates, (S, mi (f, loopc , i ))  i+1 i+1 (skip, mi+1 (f, loopc , i+1 )) where f = 0 and loopc (n) = i.  i+1 , i+1 )). By Corollary E.1, (S ; s, mi (f, loopi c , i ))  (s, mi+1 (f, loopc By similar argument in base case, the evaluation of the predicate expression w.r.t the value store i+1 produce nonzero integer value. The execution of s proceeds as follows:
+1 (s, mi+1 (f, loopi , i+1 )) c +1 = (while n (e) {S }, mi+1 (f, loopi , i+1 )) c +1 (while n (E e i+1 ) {S }, mi+1 (f, loopi , i+1 )) c by the EEval rule +1 (S ; while n (e) {S }, mi+1 (f, loopi [(i + 1)/n], i+1 )) c by the Wh-T rule.

The lemma holds. Lemma 5.25. Let s1 = "while n1 (e) {S1 }" and s2 = "while {S2 }" be two while statements and all of the followings hold:
n2

(e )

· There are output statements in s1 and s2 , e1 e2 : ("output e1 "  (s, m(f, loopc ,  )) s1 )  ("output e2 "  s2 ); = (while n (e) {S }, m(loopc ,  )) · s1 and s2 have the same set of termination deciding vari(while n (error) {S }, m(loopc ,  )) by the EEval rule ables relative to output, and the same set of imported variables (while n (0) {S }, m(1/f, loopc ,  )) by the ECrash rule relative to output, (TVaro (s1 ) = TVaro (s2 ) = TVar(s))  k (while n (0) {S }, m(1/f, loopc )) for any k > 0, by the Crash rule. (Impo (s1 ) = Impo (s2 ) = Imp(io)); · Loop bodies S1 and S2 satisfy the proof rule of equivalent Hence, we have a contradiction that there is no configuration in computation of the out-deciding variables of s1 and s2 , x  which the loop counter of s is 1. OVar(s) = TVar(s)  Imp(io) : S1 S x S2 ; When the evaluation of the loop predicate expression of s pro· Loop bodies S and S satisfy the proof rule of termination in 1 2 duce zero, the execution of s proceeds as follows: the same way, S1 S H S2 ; (s, m(f, loopc ,  )) · Loop bodies S1 and S2 produce the same output sequence = (while n (e) {S }, m(loopc ,  )) when started in states with crash flags not set and whose value (while n (0) {S }, m(loopc ,  )) by the EEval rule stores agree on values of variables in OVar(S1 )  OVar(S2 ), (skip, m(loopc [0/n1 ])) by the Wh-F rule. mS1 (f1 , S1 ) mS2 (f2 , S2 ) : ((f1 = f2 = 0)  (x  OVar(S1 )  OVar(S2 ) : S1 (x) = Hence, we have a contradiction that there is no configuration in S2 (x)))  which the loop counter of s is 1. The evaluation of the predicate ((S1 , mS1 (f1 , S1 )) O (S2 , mS2 (f2 , S2 ))). expression of s w.r.t value store  produce nonzero value. The 2 If s1 and s2 start in states m1 (f1 , loop1 execution of s proceeds as follows: c , 1 ), m2 (f2 , loopc , 2 ) respectively with crash flags not set f1 = f2 = 0 and in which s1 2 (s, m(f, loopc ,  )) and s2 have not started execution (loop1 c (n1 ) = loopc (n2 ) = 0), = (while n (e) {S }, m(f, loopc ,  )) value stores 1 and 2 agree on values of variables in OVar(s), (while n (E e  ) {S }, m(f, loopc ,  )) by the EEval rule x  OVar(s) : 1 (x) = 2 (x), then one of the followings holds: (S ; while n (e) {S }, m(f, loopc [1/n1 ],  )) by the Wh-T rule. 1. s1 and s2 both terminate and produce the same output sequence: The lemma holds.      (s1 , m1 )  (skip, m Induction step. 1 (1 )), (s2 , m2 )  (skip, m2 (2 ))    i where 1 (idIO ) = 2 (idIO ). The hypothesis IH is that, if there is a configuration (S , mi (loopc )) k reachable from (s, m) in which the loop counter of s is i, loopi 2. s1 and s2 both do not terminate, k > 0, (s1 , m1 )  c (n) = k )) i > 0, then there is a reachable configuration (S ; s, mi (f, loopi c (S1k , m1k ), (s2 , m2 )  (S2k , m2k ) where S1k = skip, from (s, m) where the loop counter of s is i and the crash flag is S2k = skip and one of the followings holds: not set. +1 (a) For any positive integer i, there are two configurations Then we show that, if there is a configuration (S  , mi+1 (loopi )) c (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and reachable from (s, m) in which the loop counter of s is i + 1, then +1 (s2 , m2 ), respectively, in which both crash flags are not there is a reachable configuration (S ; s, mi+1 (f, loopi )) from c set, the loop counters of s1 and s2 are equal to i and (s, m) where the loop counter of s is i + 1 and the crash flag f is value stores agree on values of variables in OVar(s), and not set.  for every state in execution, (s1 , m1 )  (s1 , m1i ) or By Lemma E.8, the loop counter of s is increasing by one in  one step. Hence, there must be one configuration reachable from (s2 , m2 )  (s2 , m2i ), loop counters for s1 and s2 are (s, m) in which the loop counter of s is i. By hypothesis, there is less than or equal to i respectively:

41

2015/9/14

i > 0 (s1 , m1i ) (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 ,  2i i loop1 c , 1i ))  (s2 , m2 )  (s2 , m2i (f2 , loopc , 2i )) where · f1 = f2 = 0; and 2i i · loop1 c (n1 ) = loopc (n2 ) = i; and · x  OVar(s) : 1i (x) = 2i (x).   1i   1 · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1i (loopc ,  1 1i )), loopc (n1 )  i; and   2i   2 · m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2i (loopc ,  2 2i )), loopc (n2 )  i; (b) The loop counters for s1 and s2 are less than a smallest positive integer i and all of the followings hold:
1  2 (s 2 , m 2 )  (S2 , m 2 (loopc )) where loopc (n1 ) < i, 2 loopc (n2 ) < i; · 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, loop counters of s1 and s2 are equal to j and value stores agree on values of variables in OVar(s): 1  (s1 , m1j ), (s2 , m2j ) : (s1 , m1 )  (s1 , m1j (f1 , loopcj , 2  1j ))  (s2 , m2 )  (s2 , m2j (f2 , loopcj , 2j )) where f1 = f2 = 0; and 2 1 loopcj (n1 ) = loopcj (n2 ) = j ; and x  OVar(s) : 1j (x) = 2j (x). · If i = 1, then the I/O sequence is not redefined in any states reachable from (s1 , m1 ) and (s2 , m2 ).    m : (s1 , m1 (loop1 1 c , 1 ))  (S1 , m1 (1 ))  where 1 (idIO ) = 1 (idIO ).     m : (s2 , m2 (loop2 2 c , 2 ))  (S2 , m2 (2 ))  where 2 (idIO ) = 2 (idIO ).     1 · i > 0 m 1 , m2 : (s1 , m1 )  (S1 , m1 (loopc )), 
 



(s1 , m1j ), (s2 , m2j ) : (s1 , m1 )  (s1 , m1j (f1 , loopcj , 2  1j ))  (s2 , m2 )  (s2 , m2j (f2 , loopcj , 2j )) where f1 = f2 = 0; and 2 1 loopcj (n1 ) = loopcj (n2 ) = j ; and x  OVar(s) : 1j (x) = 2j (x). · If i = 1, then executions from (s1 , m1 ) and (s2 , m2 ) produce the same output sequence: 2 (s1 , m1 (loop1 c , 1 )) O (s2 , m2 (loopc , 2 )). · If i > 1, then executions from (s1 , m1i-1 ) and (s2 , m2i-1 ) produce the same output sequence: 2 1 (s1 , m1i-1 (loopci-1 , 1i-1 )) O (s2 , m2i-1 (loopci-1 , 2i-1 )). Proof. We show that s1 and s2 terminate in the same way when 2 started in states m1 (f1 , loop1 c , 1 ) and m2 (f2 , loopc , 2 ) respectively, (s1 , m1 ) H (s2 , m2 ). In addition, we show that s1 and s2 produce the same output sequence in every possibilities of termination in the same way, (s1 , m1 ) O (s2 , m2 ). By definition, s1 and s2 satisfy the proof rule of termination in the same way because
· Loop bodies S1 and S2 satisfy the proof rule of termination in



1





the same way; By assumption. · Loop bodies S1 and S2 satisfy the proof rule of equivalent computation of those in the termination deciding variables of s1 and s2 , x  TVar(s1 )  TVar(s2 ) : S1 S x S2 ; By the definition of OVar(s), TVaro (s1 )  OVar(s1 ) and TVaro (s2 )  OVar(s2 ). By the definition of TVaro , TVaro (s1 ) = TVar(s1 ) and TVaro (s2 ) = TVar(s2 ). By Lemma 5.16, we show s1 and s2 terminate in the same way 2 when started in states m1 (f1 , loop1 c , 1 ) and m2 (f2 , loopc , 2 ). We need to show that all the required conditions are satisfied.
· Crash flags are not set, f1 = f2 = 0; · Loop counters of s1 and s2 are initially zero, loop1 c (n1 ) =

· If i > 1, then the I/O sequence is not redefined in any

states reachable from (s1 , m1i-1 ) and (s2 , m2i-1 ).
i-1   , m , 1i-1 ))  (S1 m 1 (1 )) 1 : (s1 , m1i-1 (loopc  where 1 (idIO ) = 1i-1 (idIO ). i-1   , m , 2i-1 ))  (S2 m 2 (2 )) 2 : (s2 , m2i-1 (loopc  where 2 (idIO ) = 2i-1 (idIO ).

1



loop2 c (n2 ) = 0;

· s1 and s2 have same set of termination deciding variables,

2



TVar(s1 ) = TVar(s2 ) = TVar(s);
· Value stores 1 and 2 agree on values of variables in TVar(s1 ) =

(c) The loop counters for s1 and s2 are less than or equal to a smallest positive integer i and all of the followings hold:
 2 1 m 2 )  (S2 , m 2 (loopc )) where loopc (n1 )  i, 2 loopc (n2 )  i; · There are no configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are not set, the loop counters of s1 and s2 are equal to i, and value stores agree on values of variables in OVar(s):  i (s1 , m1i ), (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 , loop1 c ,  i )) where ,  1i ))  (s2 , m2 )  (s2 , m2i (f2 , loop2 2i c f1 = f2 = 0; and 2i i loop1 c (n1 ) = loopc (n2 ) = i; and x  OVar(s) : 1i (x) = 2i (x). · 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are not set, the loop counters of s1 and s2 are equal to j and value stores agree on values of variables in OVar(s):  1   · i > 0 m 1 , m2 : (s1 , m1 )  (S1 , m1 (loopc )), (s2 , 
 





TVar(s2 ), x  TVar(s) : 1 (x) = 2 (x); The above four conditions are from assumption. · Loop bodies S1 and S2 terminate in the same way when started in states with crash flags not set and whose value stores agree on values of variables in TVar(S1 )  TVar(S2 ); By Theorem 4. Therefore, by Lemma 5.16, we have one of the followings holds: 1. s1 and s2 both terminate and the loop counters of s1 and s2 are less than a positive integer i such that the loop counters of s1 and s2 are less than or equal to i - 1:    (s1 , m1 )  (skip, m 1 ), (s2 , m2 )  (skip, m2 ). We show that, when s1 and s2 terminate, value stores of s1 and s2 agree on the value of the I/O sequence variable by Lemma 5.2. We need to show all the required conditions hold. · x  Imp(io) : 1 (x) = 2 (x); 2 · loop1 c (n1 ) = loopc (n2 ) = 0; The above two conditions are from assumption. · idIO  Def(s1 )  Def(s2 ); Because there are output statements in s1 and s2 . By the definition of Def(·), the I/O sequence variable is defined in s1 and s2 .

42

2015/9/14

By the definition of Impo (·), Impo (s1 ) = Imp(s1 , {idIO }), Impo (s2 ) = Imp(s2 , {idIO }). · y  Imp(io), mS1 (S1 ) mS2 (S2 ) : ((z  Imp(S1 , Imp(io))  Imp(S2 , Imp(io)), S1 (z ) = S2 (z ))  (S1 , mS1 (S1 )) y (S2 , mS2 (S2 ))). By Theorem 2. In addition, by the semantic rules, the I/O sequence is appended at most by one value in one step. Hence, s1 and s2 produce the same output sequence when started in states m1 and m2 respectively. 2. s1 and s2 both do not terminate, k > 0, (s1 , m1 )  k (S1k , m1k ), (s2 , m2 )  (S2k , m2k ) where S1k = skip, S2k = skip and one of the followings holds: (a) i > 0, there are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to i and value stores agree on the values of variables in TVar(s):  i > 0 (s1 , m1i ) (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 ,  1i i loopc , 1i ))  (s2 , m2 )  (s2 , m2i (f2 , loop2 c , 2i )) where · f1 = f2 = 0; and 2i i · loop1 c (n1 ) = loopc (n2 ) = i; and · x  TVar(s) : 1i (x) = 2i (x).     1 1i · m 1 : (s1 , m1 )  (S1 , m1 (loopc ))  (s1 , m1i (loopc ,  1 1i )), loopc (n1 )  i; and     2 2i · m 2 : (s2 , m2 )  (S2 , m2 (loopc ))  (s2 , m2i (loopc , 2 2i )), loopc (n2 )  i; We show that, for any positive integer i, value stores 1i and 2i agree on values of variables in Imp(io) by the proof of Lemma 5.1. We need to show that all the required conditions are satisfied. · x  Imp(io) : 1 (x) = 2 (x); 2 · loop1 c (n1 ) = loopc (n2 ) = 0; The above two conditions are by assumption. · idIO  Def(s1 )  Def(s2 ); · Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io); The above two conditions are obtained by similar argument in the case that s1 and s2 both terminate. · y  Imp(io), mS1 (S1 ) mS2 (S2 ) : ((z  Imp(S1 , Imp(io))Imp(S2 , Imp(io)), S1 (z ) = S2 (z ))  (S1 , mS1 (S1 )) y (S2 , mS2 (S2 ))). By Theorem 2. We cannot apply Lemma 5.1 directly because s1 and s2 do not terminate. But we can still have the proof closely similar to that of Lemma 5.1 by using the fact that there exists a configuration of arbitrarily large loop counters of s1 and s2 and in which crash flags are not set. Then, i > 0, x  Imp(io) : 1i (x) = 2i (x). In addition, by the semantic rules, the I/O sequence is appended at most by one value in one step. The lemma holds. (b) The loop counters for s1 and s2 are less than a smallest positive integer i and all of the followings hold:
 2 1 m 2 )  (S2 , m 2 (loopc )) where loopc (n1 ) < i, 2 loopc (n2 ) < i; · 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the    1 · i > 0 m 1 , m2 : (s1 , m1 )  (S1 , m1 (loopc )), (s2 , 
 

· Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io);

loop counters of s1 and s2 are equal to j and value stores agree on the values of variables in TVar(s): 1  (s1 , m1j ), (s2 , m2j ) : (s1 , m1 )  (s1 , m1j (f1 , loopcj , 2j  1j ))  (s2 , m2 )  (s2 , m2j (f2 , loopc , 2j )) where f1 = f2 = 0; and 2 1 loopcj (n1 ) = loopcj (n2 ) = j ; and x  TVar(s) : 1j (x) = 2j (x). This case corresponds to the situation that the ith evaluations of the predicate expression of s1 and s2 raise an exception. There are two possibilities regarding the value of i. i. i = 1. s1 and s2 raise an exception in the 1st evaluation of their predicate expression because loop counters of s1 and s2 are less than 1. In the proof of Lemma 5.16, value stores 1 and 2 in states m1 and m2 respectively are not modified in the 1st evaluation of the predicate expression of s1 and s2 . In addition, value stores 1 and 2 are not modified after s1 and s2 both crash according to the rule Crash. We have the corresponding initial state in which value stores 1 and 2 agree on values of variables in OVar(s). Thus, 1 (idIO ) = 2 (idIO ). The lemma holds. ii. i > 1. We show that, for any positive integer 0 < j < i, value stores 1j and 2j agree on values of variables in Imp(s) by the proof of Lemma 5.1. We need to show that all the required conditions are satisfied. · x  Imp(io) : 1 (x) = 2 (x); 2 · loop1 c (n1 ) = loopc (n2 ) = 0; The above two conditions are from assumption. · idIO  Def(s1 )  Def(s2 ); · Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io); The above two conditions are obtained by the same argument in the case that s1 and s2 terminate. · y  Imp(io), mS1 (S1 ) mS2 (S2 ) : ((z  Imp(S1 , Imp(io))Imp(S2 , Imp(io)), S1 (z ) = S2 (z ))  (S1 , mS1 (S1 )) y (S2 , mS2 (S2 ))). By Theorem 2. We cannot apply Lemma 5.1 directly because s1 and s2 do not terminate. But we can still have the proof closely similar to that of Lemma 5.1 by using the fact that there are reachable configurations (s1 , m1i-1 ) and (s2 , m2i-1 ) with the loop counters of s1 and s2 of value i - 1 and crash flags not set. By assumption, there is configuration (s1 , m1i-1 (f1 , i-1 loop1 , 1i-1 )) reachable from (s1 , m1 ) in which the c loop counter of s1 is i - 1 and the crash flag is not set; i-1 , 2i-1 )) there is also a configuration (s2 , m2i-1 (f2 , loop2 c of s2 reachable from (s2 , m2 ) in which the loop counter is i - 1 and the crash flag is not set. In addition, value stores 1i-1 and 2i-1 agree on values of variables in Imp(io). In the proof of Lemma 5.15, the ith evaluations of the predicate expression of s1 and s2 must raise an exception because loop counters of s1 and s2 are less than i. Then the I/O sequence is not redefined in any i-1 , 1i-1 )) state reachable from (s1 , m1i-1 (f1 , loop1 c 2i-1 and (s2 , m2i-1 (f2 , loopc , 2i-1 )) respectively. In addition, by the semantic rules, the I/O sequence is appended at most by one value in one step. The lemma holds.

k





43

2015/9/14

(c) The loop counters for s1 and s2 are less than or equal to a smallest positive integer i and all of the followings hold:
   1 · i > 0 m 1 , m2 : (s1 , m1 )  (S1 , m1 (loopc )), (s2 , m2 )   2 (S2 , m 2 (loopc )) 2 loopc (n2 )  i;









where

loop1 c

(n1 )  i,

· There are no configurations (s1 , m1i ) and (s2 , m2i )

This case corresponds to the situation that, the ith evaluation of the predicate expression of s1 and s2 produce same nonzero integer value and loop bodies S1 and S2 do not terminate after the ith evaluation of the predicate expression of s1 and s2 . There are two possibilities regarding the value of i. i. i = 1. By assumption, we have the initial value stores 1 and 2 agree on values of variables in OVar(s). In the proof of Lemma 5.15, the execution of s1 proceeds as follows: (s1 , m1 (loop1 c , 1 )) = (while n1 (e) {S1 }, m1 (loop1 c , 1 )) (while n1 (v ) {S1 }, m1 (loop1 c , 1 )) by the EEval rule (S1 ; while n1 (e) {S1 }, m1 (loop1 c [1/n1 ], 1 )) by the Wh-T rule.

reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are not set, the loop counters of s1 and s2 are equal to i, and value stores agree on values of variables in TVar(s):  i (s1 , m1i ), (s2 , m2i ) : (s1 , m1 )  (s1 , m1i (f1 , loop1 c , 1i ))  2i (s2 , m2 )  (s2 , m2i (f2 , loopc , 2i )) where f1 = f2 = 0; and 2i i loop1 c (n1 ) = loopc (n2 ) = i; and x  TVar(s) : 1i (x) = 2i (x). · 0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to j and value stores agree on values of variables in TVar(s): 1  (s1 , m1j ), (s2 , m2j ) : (s1 , m1 )  (s1 , m1j (f1 , loopcj , 1j )) 2j  (s2 , m2 )  (s2 , m2j (f2 , loopc , 2j )) where f1 = f2 = 0; and 2 1 loopcj (n1 ) = loopcj (n2 ) = j ; and x  TVar(s) : 1j (x) = 2j (x).

We show that, for any positive integer 0 < j < i, value stores 1j and 2j agree on values of variables in Imp(io) by the proof of Lemma 5.1. We need to show that all the required conditions are satisfied. · x  Imp(io) : 1 (x) = 2 (x); 2 · loop1 c (n1 ) = loopc (n2 ) = 0; The above two conditions are from assumption. · idIO  Def(s1 )  Def(s2 ); · Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io); The above two conditions are obtained by the same argument in the case that s1 and s2 terminate. · y  Imp(io), mS1 (S1 ) mS2 (S2 ) : ((z  Imp(S1 , Imp(io))Imp(S2 , Imp(io)), S1 (z ) = S2 (z ))  (S1 , mS1 (S1 )) y (S2 , mS2 (S2 ))). By Theorem 2. We cannot apply Lemma 5.1 directly because s1 and s2 do not terminate. But we can still have the proof closely similar to that of Lemma 5.1. The reason is that there are  reachable configurations (S1 ; s1 , m 1 ) and (S2 ; s2 , m2 ) with loop counters of s1 and s2 of value i and crash flags not set. This is by Lemma 5.24 because there are configurations reachable from (s1 , m1 ) and (s2 , m2 ) respectively with loop counters of s1 and s2 of i. There are configurations (s1 , m1i-1 ) reachable from (s1 , m1 ) and (s2 , m2i-1 ) reachable from (s2 , m2 ) in which loop counters of s1 and s2 are i- 1 and crash flags are not set and value stores agree on values of variables in Imp(io). Because loop counters of s1 and s2 are less than or equal to i. Then the execution of s1 proceeds as follows:
i-1 , 1i-1 )) (s1 , m1i-1 (loop1 c i-1 , 1i-1 )) = (while n1 (e) {S1 }, m1i-1 (loop1 c i-1 , 1i-1 )) (while n1 (v ) {S1 }, m1i-1 (loop1 c by the EEval rule i-1 [i/n1 ], (S1 ; while n1 (e) {S1 }, m1i-1 (loop1 c 1i-1 )) by the Wh-T rule.

The execution of s2 proceeds to (S2 ; while n2 (e) {S2 }, m2 (loop2 c [1/n2 ], 2 )). Then the execution of S1 and S2 do not terminate when started in states m1 (loop1 c [1/n1 ], 1 ) and m2 (loop2 c [1/n2 ], 2 ). By assumption, value stores 1 and 2 agree on values of the out-deciding variables of s1 and s2 , x  OVar(s1 )  OVar(s2 ) : 1 (x) = 2 (x). By definition, Imp(S1 , {idIO })  Corollary 5.5. Let s1 = "while n1 (e) {S1 }" and s2 = Imp(s1 , {idIO }), CVar(S1 )  CVar(s1 ) and LVar(S1 )  "while n2 (e) {S2 }" be two while statements such that all of the LVar(s1 ). Thus, TVar(S1 )  TVar(s1 ). By Lemma 5.20, followings hold TVaro (S1 )  TVar(S1 ). By Lemma 5.18, Impo (S1 )  · There are output statements in s1 and s2 , e1 e2 : ("output e1 "  Imp(S1 , idIO ). In conclusion, OVar(S1 )  OVar(s1 ). s1 )  ("output e2 "  s2 ); Similarly, OVar(S2 )  OVar(s2 ). Thus, x  OVar(S1 ) · s1 and s2 have same set of termination deciding variables OVar(S2 ) : 1 (x) = 2 (x). Then executions of S1 and and same set of imported variables relative to the I/O seS2 when started from states 2 quence variable, (TVar(s1 ) = TVar(s2 ) = TVar(s))  m1 (loop1 [1 /n ] ,  ) and m ( loop [1 /n ] ,  ) pro1 1 2 2 2 c c (Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io)); duce the same output sequence: 2 · Loop bodies S1 and S2 satisfy the proof rule of equivalent (S1 , m1 (loop1 c [1/n1 ], 1 )) O (S2 , m2 (loopc [1/n2 ], 2 )). computation of those in out-deciding variables of s1 and s2 , In addition, by the semantic rules, the I/O sequence is x  OVar(s) = TVar(s)  Imp(io) : S1 S appended at most by one value in one step. The lemma x S2 ; · Loop bodies S1 and S2 satisfy the proof rule of termination in holds. the same way, S1 S ii. i > 1. H S2 ;
44 2015/9/14

The execution of s2 proceeds to (S2 ; while n2 (e) {S2 }, i-1 [i/n2 ], 2i-1 )). By similar argument in m2i-1 (loop2 c the case i = 1, S2 and S1 produce the same output sei-1 [i/n ],  quence when started in states m1i-1 (loop1 1 1i-1 ) c 2i-1 and m2i-1 (loopc [i/n2 ], 2i-1 ) respectively. In addition, by the semantic rules, the I/O sequence is appended at most by one value in one step. The lemma holds.

· Loop bodies S1 and S2 produce the same output sequence when

2 If s1 and s2 start in states m1 (f1 , loop1 c , 1 ), m2 (f2 , loopc , 2 ) respectively with crash flags not set f1 = f2 = 0 and in which s1 2 and s2 have not started execution (loop1 c (n1 ) = loopc (n2 ) = 0), value stores 1 and 2 agree on values of variables in OVar(s), x  OVar(s) : 1 (x) = 2 (x), then s1 and s2 produce the same output sequence: (s1 , m1 ) O (s2 , m2 ).

started in states with crash flags not set and agreeing on values of variables in OVar(S1 )  OVar(S2 ), mS1 (f1 , S1 ) mS2 (f2 , S 2 ) : ((f1 = f2 = 0)  (x  OVar(S1 )  OVar(S2 ) : S1 (x) = S2 (x)))  ((S1 , mS1 (f1 , S1 )) O (S2 , mS2 (f2 , S2 ))).

1: 2: 3: 4: output a + 2 old

1': If (b) then 2': output a  2 3': else 4': output a + 2 new

Figure 15: Specializing new configuration variables

This is from lemma 5.25. 5.5 Backward compatible DSU based on program equivalence Based on the equivalence result above, we show that there exists backward compatible DSU. We need to show there exists a mapping of old program configurations and new program configurations and the hybrid execution obtained from the configuration mapping is backward compatible. We do not provide a practical algorithm to calculate the state mapping. Instead we only show that there exists new program configurations corresponding to some old program configurations via a simulation. The treatment in this section is informal. The idea is to map a configuration just before an output is produced to a corresponding configuration. Based on the proof rule of same output sequences, not every statement of the old program can correspond to a statement of the new program, but every output statemet of the old program should correspond to an output statement of the new program. Consider configuration C1 of the old program where the leftmost statement (next statement to execute) is an output statement. We can define a corresponding statement of the new program by simulating the execution of the new program on the input consumed so far in C1 . There are two cases. When the leftmost statement in C1 is not included in a loop statement, then it is easy to know when to stop simulation. Otherwise, we have the bijection of loop statements including output statements based on the condition of same output sequences. Therefore, it is easy to know how many iterations of the loop statements including the output statement shall be carried out based on the loop counters in the old program configuration C1 . Based on Theorem 5, there must be a configuration C2 corresponding to C1 . Moreover, the executions starting from configurations C1 and C2 produce the same output sequence based on Theorem 5. In conclusion, we obtain a backward compatible hybrid execution where the state mapping is from C1 to C2 .

Definition 25. (Specializing new configuration variables) A statement sequence S2 includes updates of specializing new configuration variables compared with S1 w.r.t a mapping  of new configuration variables in S2 ,  : {id}  {0, 1}, denoted S2 S  S1 , iff one of the following holds:
f t 1. S2 = "If(id) then{S2 } else{S2 }" where one of the following holds: f (a) ((id) = 0)  (S2 S  S1 ); t (b) ((id) = 1)  (S2 S  S1 ); 2. S1 and S2 produce the same output sequence, S1 S O S2 ; f f t t 3. S1 = "If(e) then{S1 } else{S1 }", S2 = "If(e) then{S2 } else{S2 }" f t S t S f where (S2  S1 )  (S2  S1 );   4. S1 = "while n1 (e) {S1 }", S2 = "while n2 (e) {S2 }" where  S  S2   S1 ; S      S ; s2 where (S2 ; s1 and S2 = S2 5. S1 = S1  S1 )  (S2  H   S1 )  x  Imp(s1 , idIO )  Imp(s1 , idIO ) : (S2 S x  )  (s 2  S S1  s 1 ).

Then we show that executions of two statement sequences produce the same I/O sequence if there are updates of specializing new configuration variables between the two. Lemma 6.1. Let S1 and S2 be two different statement sequences where there are updates of "specializing new configuration variables" in S2 compared with S1 w.r.t a mapping of new configuration variables , S2 S  S1 . If executions of S2 and S1 start in states m2 (f2 , 2 ) and m1 (f1 , 1 ) respectively where all of the following hold:
· Crash flags f2 , f1 are not set, f2 = f1 = 0; · Value stores 1 and 2 agree on output deciding variables in

6. Real world backward compatible update classes: proof rules
We propose our formal treatment for real world update classes. For each update class, we show how the old program and new program produce the same I/O sequence which guarantees backward compatible DSU. 6.1 Proof rule for specializing new configuration variables New configuration variables can be introduced to generalize functionality. Figure 15 shows an example of how a new configuration variable introduces new code. The two statement sequences in Figure 15 are equivalent when the new variable b is specialized to 0. Our generalized formal definition of "specializing new configuration variables" is defined as follows.

both S1 and S2 including the input and I/O sequence variable, id  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1 (id) = 2 (id); · Values of new configuration variables in the value store 2 are matching those in , id  Dom() : (id) = 2 (id); · Values of new configuration variables are not defined in the statement sequence S2 , Dom()  Def(S2 ) = ; then S2 and S1 satisfy all of the following:
· (S1 , m 1 )  H (S2 , m 2 ); · (S1 , m 1 )  O (S2 , m 2 ); · x  {idI , idIO } : (S1 , m1 ) x (S2 , m2 );

Proof. The proof of Lemma 6.1 is by induction on the sum of program sizes of S1 and S2 and is a case analysis based on Definition 25. Base case. f S1 is a simple statement s, S2 = "If(id) then{st 2 } else{s2 }" f t where s2 , s2 are simple statement and one of the following holds: 1. ((id) = 0)  (sf 2 = s ); 2. ((id) = 1)  (st 2 = s );
45 2015/9/14

f f in S1 and S2 as well as the input, I/O sequence variable. f By definition, Use(S1 )  Use(S1 ). So are the cases to f f (If(id) then{st } else { s } , m (  )) 2 2 2 S2 and S2 . In addition, value stores 1 and 2 are not 2 f (If(0) then{st changed in the evaluation of the predicate expression e. 2 } else{s2 }, m2 (2 )) by the rule Var The condition holds. · Values of new configuration variables are consistent (sf 2 , m2 (2 )) by the If-F rule. in the value store 2 and the specialization , id  Dom() : 2 (id) = (id). By Theorem 5 and Theorem 4, this lemma holds. By assumption. Induction step. The induction hypothesis (IH) is that Lemma 6.1 holds when By the hypothesis IH, the lemma holds. the sum of the program size of S1 and S2 is at least 4, size(S1 ) + (c) The evaluation of e reduces to the same nonzero integer size(S2 ) = k  4. value, E  e 1 = E  e 2 = (v, vof ) where v = 0. Then we show that the lemma holds when size(S1 )+size(S2 ) = By arguments similar to the second subcase above. k + 1. There are cases to consider. 3. S1 and S2 are both "while" statements:   S1 = "while n (e) {S1 }", S2 = "while n (e) {S2 }" where 1. S1 and S2 satisfy the condition of same output sequence,  S  S2   S1 ; S S1  O S2 . By Lemma 6.3, we show this lemma holds. We need to show By Theorem 5, the lemma 6.1 holds. that all required conditions are satisfied for the application of 2. S1 and S2 are both "If" statement: Lemma 6.3. f f t t S1 = "If(e) then{S1 } else{S1 }", S2 = "If(e) then{S2 } else{S2 }" · S1 and S2 have same set of output deciding variables, where both of the following hold OVar(S1 ) = OVar(S2 ) = OVar(S ); t S t · S2   S1 ; By Lemma 6.2 and Corollary 5.1. f S f    · S2 · When started in states m   S1 ; 1 (1 ), m2 (1 ) where value stores   1 and 2 agree on values of output deciding variables in By the definition of Use(S1 ), variables used in the predicate exboth S1 and S2 as well as the input sequence variable and pression e are a subset of used variables in S1 and S2 , Use(e)    the I/O sequence variable, then S1 and S2 terminate in the Use(S1 )  Use(S2 ). By assumption, corresponding variables same way, produce the same output sequence, and have used in e are of same value in value stores 1 and 2 . By equivalent computation of defined variables in both S1 and Lemma D.1, the expression evaluates to the same value w.r.t S2 . value stores 1 and 2 . There are three possibilities. By the induction hypothesis IH. This is because the sum of (a) The evaluation of e crashes, E  e 1 = E  e 2 =   the program size of S1 and S2 is less than k. By definition, (error, vof ).  size(S1 ) = 1 + size(S1 ). The execution of S1 continues as follows: f t By Lemma 6.3, this lemma holds. (If(e) then{S1 } else{S1 }, m1 (1 )) f t f t 4. S2 = "If(id) then {S2 } else {S2 }" where one of the following (If((error, vof )) then{S1 } else{S1 }, m1 (1 )) holds: by the rule EEval' f S f t (a) ((id) = 0)  (S2  S1 ); } else{S1 }, m1 (1/f)) (If(0) then{S1 t S by the ECrash rule (b) ((id) = 1)  (S2  S1 ); i f f S t (If(0) then{S1 } else{S1 }, m1 (1/f)) for any i > 0 W.l.o.g, we assume ((id) = 0)  (S2  S1 ); by the Crash rule. Then the execution of S2 proceeds as follows: Similarly, the execution of S2 started from the state m2 (2 ) f t crashes. The lemma holds. (If(id) then{S2 } else{S2 }, m2 (2 )) f t (b) The evaluation of e reduces to zero, E  e 1 = E  e 2 = = (If(0) then{S2 } else{S2 }, m2 (2 )) (0, vof ). by the Var rule f The execution of S1 continues as follows. (S2 , m2 (2 )) f t (If(e) then{S1 } else{S1 }, m1 (1 )) by the If-F rule f t = (If((0, vof )) then{S1 } else{S1 }, m1 (1 )) by the rule EEval' By the induction hypothesis, we show that the lemma holds. f t We need to show the required conditions are satisfied for the (If(0) then{S1 } else{S1 }, m1 (1 )) application of the hypothesis. by the E-Oflow1 or E-Oflow2 rule f S f · S2  S1 (S1 , m1 (1 )) by the If-F rule. By assumption. Similarly, the execution of S2 gets to the configuration f f f · The sum of the program size of S1 and S2 is less than k, (S2 , m2 (2 )). f f By the hypothesis IH, we show the lemma holds. We need size(S1 ) + size(S2 ) < k. f t to show that all conditions are satisfied for the application By definition, size(S2 ) = 1 + size(S2 ) + size(S2 ). Then, f t of the hypothesis IH. size ( S ) + size ( S ) < k + 1 - 1 - size ( S ) < k . 1 2 2 f S f · (S2  S1 ) · Value stores 1 and 2 agree on values of used variables in f By assumption. S2 and S1 as well as the input, I/O sequence variable. f f f · The sum of the program size of S1 and S2 is less than By definition, Use(S2 )  Use(S2 ). In addition, the value f f k, size(S1 ) + size(S2 ) < k. store 2 is not changed in the evaluation of the predicate f t By definition, size(S1 ) = 1+size(S1 )+size(S1 ). Then, expression e. The condition holds. f f size(S1 ) + size(S2 ) < k + 1 - 2 = k - 1. By the hypothesis IH, the lemma holds.

W.l.o.g., we assume that (id) = 0. By assumption, 2 (id) = (id) = 0. Then the execution of S2 proceeds as follows:

· Value stores 1 and 2 agree on values of used variables

46

2015/9/14

5. S1 and S2 are same, S1 = S2 ; By definition, used variables in S1 and S2 are same; defined variables in S1 and S2 are same. By semantic rules, S1 and S2 terminate in the same way, produce the same output sequence and have equivalent computation of defined variables in S1 and S2 . This lemma holds.   6. S1 = S1 ; s1 and S2 = S2 ; s2 where both of the following hold:  S  · S2   S1 ; · s2 S  s1 ;   By Theorem 4 and the hypothesis IH, we show S2 and S1 terminate in the same way and produce the same output sequence     and when S2 and S1 both terminate, S2 and S1 have equivalent  terminating computation of variables used or defined in S2 and  S1 . We show all the required conditions are satisfied for the application of the hypothesis IH.  S  · S2   S1 . By assumption.   · The sum of the program size of S1 and S2 is less than k,   size(S1 ) + size(S2 ) < k.  By definition, size(S2 ) = size(s2 ) + size(S2 ) where   size(s2 ) < 1. Then, size(S2 ) + size(S1 ) < k + 1 - size(s2 ) - size(s1 ) < k. · Value stores 1 and 2 agree on values of output deciding   variables in S2 and S1 including the input, I/O sequence variable.  By definition of TVaro and Impo , OVar(S2 )  OVar(S2 ). The condition holds. · Values of new configuration variables are consistent in the value store 2 and the specialization , id  Dom() : 2 (id) = (id). By assumption. By the hypothesis IH, one of the following holds:   both do not terminate. and S2 (a) S1  By Lemma E.2, executions of S1 = S1 ; s1 and S2 =  S2 ; s2 both do not terminate and produce the same output sequence.   (b) S1 and S2 both terminate.    By assumption, (S2 , m2 (2 ))  (skip, m 2 (2 )),     (S1 , m1 (1 ))  (skip, m1 (1 )).    ; s2 , m2 (2 ))  (s2 , m By Corollary E.1, (S2 2 (2 )),     (S1 ; s1 , m1 (1 ))  (s1 , m1 (1 )). By the hypothesis IH, we show that s2 and s1 terminate in the same way, produce the same output sequence and when s2 and s1 both terminate, s2 and s1 have equivalent computation of variables used or defined in s1 and s2 and the input, and I/O sequence variables. We need to show that all conditions are satisfied for the application of the hypothesis IH. · There are updates of "new configuration variables" between s2 and s1 ; By assumption, s2 S  s1 . · The sum of the program size s2 and s1 is less than or equals to k;   By definition, size(S2 )  1, size(S1 )  1. Therefore,   size(s2 ) + size(s1 ) < k + 1 - size(S2 ) - size(S1 )  k.   · Value stores 1 and 2 agree on values of output deciding variables in s2 and s1 as well as the input, I/O sequence variable. By induction hypothesis IH, OVar(s1 )  OVar(s2 ), then Use(s2 )  Use(s1 ) = Use(s1 ). For any variable  id in OVar(s1 ), if id is in OVar(S1 ), then the value of    id is same after the execution of S1 and S2 , 1 (id) =
47

 1 (id) = 2 (id) = 2 (id). Otherwise, the variable id   is defined in the execution of S1 and S2 , by assumption,   1 (id) = 2 (id). The condition holds. · Values of new configuration variables are consistent  in the value store 2 and the specialization , id   Dom() : 2 (id) = (id). By assumption, Dom()  Def(S2 ). By Corollary E.2, values of new configuration variables are not changed   in the execution of S2 , id  Dom() : 2 (id) = 2 (id) = (id). By the hypothesis IH, the lemma holds.

We list properties of the update of new configuration variables and the proof of backward compatibility for the case of loop statement as follows. We present one auxiliary lemma used in the proof of Lemma 6.1. Lemma 6.2. Let S2 be a statement sequence and S1 where there are updates of "specializing new configuration variables" w.r.t a mapping of new configuration variables , S2 S  S1 . Then the output deciding variables in S1 are a subset of the union of those in S2 , OVar(S1 )  OVar(S2 ). Proof. By induction on the sum of the program size of S1 and S2 .
 Lemma 6.3. Let S1 = while n1 (e) {S1 } and S2 = while n2 (e)  {S2 } be two loop statements where all of the following hold:

 · S2 includes updates of "specializing new configuration vari-

2 If S1 and S2 start in states m1 (loop1 c , 1 ), m2 (loopc , 2 ) respectively, with loop counters of S1 and S2 not initialized (S1 , S2 have not executed yet), value stores agree on values of output deciding variables in S1 and S2 , then, for any positive integer i, one of the following holds:

    ables" compared to S1 , S2 S  S1 where Dom()  Def(S2 ) = . · the output deciding variables in S1 are a subset of those in S2 , OVar(S1 )  OVar(S2 ); · When started in states agreeing on values of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable, x  OVar(S1 )  OVar(S2 )         {idI , idIO } m 1 (1 ) m2 (2 ) : (1 (x) = 2 (x)), S1 and S2 terminate in the same way, produce the same output sequence,  and have equivalent computation of defined variables in S1  and S2 as well as the input sequence variable and the I/O    sequence variable ((S1 , m 1 )  H (S2 , m2 ))  ((S1 , m1 ) O  (S2 , m2 ))  (x  OVar(S1 )  OVar(S2 )  {idI , idIO } :   (S1 , m 1 )  x (S2 , m2 ));

1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))     1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of output deciding variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal i to i, and there are no reachable configurations (S1 , m1 (loop1 c , i 1i )) from (S1 , m1 (1 )), (S2 , m2 (loop2 c , 2i )) from (S2 , m2 (2 )) where all of the following hold:

2015/9/14

i = loop2 c (n2 ) = i. · Value stores 1i and 2i agree on values of output deciding variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x). i 3. There are reachable configurations (S1 , m1 (loop1 c , 1i )) from i (S1 , m1 (1 )), (S2 , m2 (loop2 c , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) 2i = loopc (n2 ) = i. · Value stores 1i and 2i agree on values of output deciding variables in both S1 and S2 including the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x).

i · The loop counters of S1 and S2 are of value i, loop1 c (n1 )

 (while n1 (0) {S1 }, m1 (1/f)) for any i > 0 by the Crash rule.

i

Similarly, the execution of S2 started from the state m2 (2 ) crashes. Therefore S1 and S2 terminate in the same way when started from m1 and m2 respectively. Because 1 (idIO ) = 2 (idIO ), the lemma holds. 2. The evaluation of e reduces to zero, E  e 1 = E  e 2 = (0, vof ). The execution of S1 continues as follows.
 (while n1 (e) {S1 }, m1 (1 ))  = (while n1 ((0, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (0) {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule (skip, m1 (1 )) by the Wh-F rule.

Proof. By induction on i. Base case. We show that, when i = 1, one of the following holds: 1. Loop counters for S1 and S2 are always less than 1 if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))      1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))   2 2 (S2 , m ( loop )) , loop ( n ) < i , S and S terminate in 2 1 2 2 c c the same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. Loop counters of S1 and S2 are of value less than or equal to 1 1 but there are no reachable configurations (S1 , m1 (loop1 c , 1i )) 1 )) from ( S , m from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) 2i c where all of the following hold: 1 · The loop counter of S1 and S2 are of value 1, loop1 c (n1 ) 1 = loop2 ( n ) = 1 . 2 c · Value stores 11 and 21 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 11 (x) = 21 (x). 1 3. There are reachable configuration (S1 , m1 (loop1 c , 1i )) from 1 )) from ( S , m (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) where 2 i c all of the following hold: 1 · The loop counter of S1 and S2 are of value 1, loop1 c (n1 ) 1 = loop2 ( n ) = 1 . 2 c · Value stores 11 and 21 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 11 (x) = 21 (x). By definition, variables used in the predicate expression e of S1 and S2 are used in S1 and S2 , Use(e)  OVar(S1 )  OVar(S2 ). By assumption, value stores 1 and 2 agree on values of variables in Use(e), the predicate expression e evaluates to the same value w.r.t value stores 1 and 2 . There are three possibilities. 1. The evaluation of e crashes, E  e 1 = E  e 2 = (error, vof ). The execution of S1 continues as follows:
 (while n1 (e) {S1 }, m1 (1 ))  (while n1 ((error, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (0) {S1 }, m1 (1/f)) by the ECrash rule

Similarly, the execution of S2 gets to the configuration (skip, m2 (2 )). Loop counters of S1 and S2 are less than 1 and value stores agree on values of used/defined variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable. 3. The evaluation of e reduces to the same nonzero integer value, E  e 1 = E  e 2 = (0, vof ). Then the execution of S1 proceeds as follows:
 }, m1 (1 )) (while n1 (e) {S1  }, m1 (1 )) = (while n1 ((v, vof )) {S1 by the rule EEval'  (while n1 (v ) {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule   }, m1 ( ; while n1 (e) {S1 (S1 loop1  { ( n )  1 } , 1 )) by the Wh-T rule. 1 c

Similarly, the execution of S2 proceeds to the configuration   (S2 ; while n2 (e) {S2 }, m2 (loop2 c  {n2  1}, 2 )).   By the hypothesis IH, we show that S1 and S2 terminate in the same way and produce the same output sequence when 21 1 started in the state m1 (loop1 c , 1 ) and m2 (loopc , 2 ), and   S1 and S2 have equivalent computation of variables used or defined in both statement sequences if both terminate. We need to show that all conditions are satisfied for the application of the hypothesis IH. · variables in the domain of  are not redefined in the execu tion of S2 . The above three conditions are by assumption.   By definition, size(S1 ) = 1 + size(S1 ). Then, size(S1 )+  size(S2 ) = k + 1 - 2 = k - 1. · Value stores 1 and 2 agree on values of used variables in   as well as the input, I/O sequence variable. S1 and S2  By definition, OVar(S1 )  OVar(S1 ). So are the cases  to S2 and S2 . In addition, value stores 1 and 2 are not changed in the evaluation of the predicate expression e. The condition holds. · Values of new configuration variables are consistent in the value store 2 and the specialization , id  Dom() : 2 (id) = (id). By assumption.   By assumption, S1 and S2 terminate in the same way and produce the same output sequence when started in states    m1 (loop c , 1 ) and m2 (loopc , 2 ). In addition, S1 and S2 have  equivalent computation of variables used or defined in S1 and    S2 when started in states m1 (loopc , 1 ) and m2 (loopc , 2 ). Then there are two cases.

48

2015/9/14

  (a) S1 and S2 both do not terminate and produce the same output sequence.   By Lemma E.2, S1 ; S1 and S2 ; S2 both do not terminate and produce the same output sequence.   (b) S1 and S2 both terminate and have equivalent computation   of variables used or defined in S1 and S2 .      By assumption, (S1 , m1 (loopc , 1 ))  (skip, m 1 (loopc , 1 ));       (S2 , m2 (loopc , 2 ))  (skip, m2 (loopc , 2 )) where x      (OVar(S1 )  OVar(S2 ))  {idI , idIO }, 1 ( x ) = 2 (x ). Because S1 and S2 have the same predicate expression, variables used in the predicate expression of S1 and S2  are not in the domain of . By assumption, OVar(S1 )     OVar(S2 )  OVar(S2 )  Dom() and OVar(S1 )   OVar(S2 ). Then variables used in the predicate expression of S1 and S2 are either in variables used or defined in both     S1 and S2 or not. Therefore value stores 2 and 1 agree on values of variables used in the expression e and even variables used or defined in S1 and S2 .

Induction step on iterations The induction hypothesis (IH) is that, when i  1, one of the following holds: 1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))      1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))  2   2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) i )) from ( S , m ( from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 2 )) 2i c where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 ( n ) = i . 2 c · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x). i 3. There are reachable configurations (S1 , m1 (loop1 c , 1i )) from i )) from ( S , m (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) where 2 i c all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) i (n ) = i. = loop2 2 c · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x). Then we show that, when i + 1, one of the following holds: The induction hypothesis (IH) is that, when i  1, one of the following holds: 1. Loop counters for S1 and S2 are always less than i + 1 if any  1  2 1 is present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))       1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i +1, (S2 , m2 (loopc , 2 ))   2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i + 1, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable,

(S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i + 1, and there are no reachable configurations i+1 i+1 , 2i+1 )) (S1 , m1 (loop1 , 1i+1 )) from (S1 , m1 (1 )), (S2 , m2 (loop2 c c from (S2 , m2 (2 )) where all of the following hold: · The loop counters of S1 and S2 are of value i + 1, i+1 (n ) = loop2i+1 (n ) = i + 1. loop1 1 2 c c · Value stores 1i+1 and 2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i+1 (x) = 2i+1 (x). i+1 , 1i )) 3. There are reachable configurations (S1 , m1 (loop1 c i+1 )) from ( S , m from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) 2 i c where all of the following hold: i+1 · The loop counter of S1 and S2 are of value i, loop1 (n1 ) c i+1 = loop2 ( n ) = i + 1 . 2 c · Value stores 1i+1 and 2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i+1 (x) = 2i+1 (x). By hypothesis IH, there is no configuration where loop counters of S1 and S2 are of value i + 1 when any of the following holds: 1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))       1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) 2i from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) 2i = loopc (n2 ) = i. · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x).
i When there are reachable configurations (S1 , m1 (loop1 c , 1i )) 2i from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 )

i = loop2 c (n2 ) = i. i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) 2i = loopc (n2 ) = i. · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x).

By similar argument in base case, we have one of the following holds: 1. Loop counters for S1 and S2 are always less than i + 1 if any  1  2 1 is present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 )) 
49 2015/9/14

1: enum id {o1 } 2: a : enum id 3: If (a == o1 ) then 4: output 2 + c 5: 6: old

1': 2': 3': 4': 5': 6':

enum id {o1 , o2 } a : enum id If (a == o1 ) then output 2 + c If (a == o2 ) then output 3 + c new

2. EN1 , EN2 include more than one enumeration type definitions  EN1 = "enum id {el1 }, EN 1 ", EN2 = "enum id {el 2 }, EN2 " where one of the following holds:  (a) (EN 1  EN2 ) and (el1 = el2 )  (el2 = el1 , el);    (b) (EN1  EN 2 )  (EN1 = EN2 ) and "enum id {el1 }"  "enum id {el2 }". Definition 27. (Enumeration type extension) Let P1 , P2 be two programs where enumeration type definitions EN1 in P1 are a subset of EN2 in P2 , EN1  EN2 and E are new enum labels in P2 . A statement sequence S2 in a program P2 includes updates of enumeration type extension compared with a statement sequence S1 in P1 , written S2 S E S1 , iff one of the following holds:

Figure 16: Enumeration type extension
 

 1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i +1, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i + 1, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i + 1, and there are no reachable configurations i+1 i+1 , (S1 , m1 (loop1 , 1i+1 )) from (S1 , m1 (1 )), (S2 , m2 (loop2 c c 2i+1 )) from (S2 , m2 (2 )) where all of the following hold: i+1 · The loop counters of S1 and S2 are of value i, loop1 (n1 ) c 2i+1 = loopc (n2 ) = i. · Value stores 1i+1 and 2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI +1 , idIO } : 1i+1 (x) = 2i+1 (x). i+1 3. There are reachable configurations (S1 , m1 (loop1 , 1i+1 )) c 2i+1 from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i+1 )) from (S2 , m2 (2 )) where all of the following hold: i+1 · The loop counter of S1 and S2 are of value i, loop1 (n1 ) c i+1 (n ) = i + 1. = loop2 2 c · Value stores 1i+1 and 2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI +1 , idIO } : 1i+1 (x) = 2i+1 (x).



f t } else{S2 }" and all of the following 1. S2 = "If(id==l) then{S2 hold: · l  E; · The variable id is not lvalue in an assignment statement, "id := e"  / P2 ; f · S2 S E S1 ; f f t t 2. S1 = "If(e) then{S1 } else{S1 }", S2 = "If(e) then{S2 } else{S2 }" f f t S t S where (S2 E S1 )  (S2 E S1 );   3. S1 = "while n1 (e) {S1 }", S2 = "while n2 (e) {S2 }" where  S  S2  E S1 ; 4. S1 S O S2 ;      S 5. S1 = S1 ; s1 and S2 = S2 ; s2 where (S2 S E S1 )  (S2  H   S1 )  x  Imp(s1 , idIO )  Imp(s1 , idIO ) : (S2 S x  S1 )  (s 2  S E s 1 ).

We show that two programs terminate in the same way, produce the same output sequence, and have equivalent computation of variables defined in both of them in executions if there are updates of enumeration type extension between them. Lemma 6.4. Let S1 and S2 be two statement sequences in programs P1 and P2 respectively where there are updates of enumeration type extensions in S2 of P2 compared with S1 of P1 , S2 S E S1 . If S1 and S2 start in states m1 (1 ) and m2 (2 ) such that both of the following hold:
· Value stores 1 and 2 agree on values of output deciding vari-

6.2 Proof rule for enumeration type extension Enumeration types allow developers to list similar items. New code is usually accompanied with the introduction of new enumeration labels. Figure 16 shows an example of the update. The new enum label o2 gives a new option for matching the value of the variable a, which introduce the new code b := 3 + c. To show updates "enumeration type extension" to be backward compatible, we assume that values of enum variables, used in the If-predicate introducing the new code, are only from inputs that cannot be translated to new enum labels. In order to have a general definition of the update class, we show a relation between two sequences of enumeration type definitions, called proper subset. Definition 26. (Extension relation of enumeration types) Let EN1 , EN2 be two different sequences of enumeration type definitions. EN1 is a subset of EN2 , written EN1  EN2 , iff one of the following holds: 1. EN1 = "enum id {el1 }", EN2 = "enum id {el2 }" where labels in type "enum id" in EN1 are a subset of those in EN2 , el2 = el1 , el and el = ;

ables in both S1 and S2 including the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1 (x) = 2 (x); · No variables used in S2 are of initial value of enum labels in E , x  Use(S2 ) : (2 (x)  / E ); · No inputs are translated to any label in E during the execution of S2 ; then S1 and S2 terminate in the same way, produce the same output sequence, and when S1 and S2 both terminate, they have equivalent computation of used variables and defined variables,
· (S1 , m 1 )  H (S2 , m 2 ); · (S1 , m 1 )  O (S2 , m 2 ); · x  OVar(S1 )  OVar(S2 ) : (S1 , m1 ) x (S2 , m2 );

Proof. By induction on the sum of the program size of S1 and S2 , size(S1 ) + size(S1 ). Base case. S1 is a simple statement s, and S2 = "If(id==l) then{st 2} else{sf } " where all of the following hold: 2
· l  E; f · st 2 , s2 are two simple statements; f · s2 = s;

50

2015/9/14

We informally argue that the value of the variable id in the predicate expression of S2 only coming from an input value or the initial value. There are three ways a scalar variable is defined: the execution of an assignment statement, the execution of an input statement or the initial value. Because id is not lvalue in an assignment statement, then the value of id is only from the execution of an input statement or the initial value. In addition, by assumption, any output deciding variable is not of the initial value of enum label in E ; no input values are translated into an enum label in E . Then the execution of S2 proceeds as follows:

By the hypothesis IH, we show the lemma holds. We need to show that all conditions are satisfied for the application of the hypothesis IH. f S f · S2 E S1 By assumption. f f · The sum of the program size of S1 and S2 is less than f f k, size(S1 ) + size(S2 ) < k. f t By definition, size(S1 ) = 1+size(S1 )+size(S1 ). Then, f f size(S1 ) + size(S2 ) < k + 1 - 2 = k - 1. · Value stores 1 and 2 agree on values of output def f ciding variables in S1 and S2 including the input, I/O f (If(id==l) then{st 2 } else{s2 }, m2 (2 )) sequence variable. f f (If(0) then{st 2 } else{s2 }, m2 (2 )) By definition, OVar(S1 )  OVar(S1 ). So are the cases f by the rule Eq-F to S and S 2 . In addition, value stores 1 and 2 are not 2 (sf changed in the evaluation of the predicate expression e. 2 , m2 (2 )) by the If-F rule. The condition holds. The value store 2 is not updated in the execution of S2 so far. · There are no inputs translated to enum labels in E in By assumption, value stores 1 and 2 agree on values of output f S2 's execution. deciding variables in both S1 and S2 . By assumption. By Theorem 2 and 4, S1 and S2 terminate in the same way, By the hypothesis IH, the lemma holds. produce the same I/O sequence. The lemma holds. (c) The evaluation of e reduces to the same nonzero integer Induction step. value, E  e 1 = E  e 2 = (0, vof ). The hypothesis is that this lemma holds when the sum k of the By similar to the second subcase above. program size of S1 and S2 are great than or equal to 4, k  4. 2. S1 and S2 are both "while" statements: We then show that this lemma holds when the sum of the   S1 = "while n1 (e) {S1 }", S2 = "while n2 (e) {S2 }" where program size of S1 and S2 is k + 1. There are cases regarding S  S  S2 E S1 . S2  E S1 ; By Lemma 6.6, we show the lemma holds. We need to show all 1. S1 and S2 are both "If" statement: the required conditions for the application of Lemma 6.6 holds f f t t S1 = "If(e) then{S1 } else{S1 }", S2 = "If(e) then{S2 } else{S2 }" (a) No variables are of initial values as new enum labels in E ; where both of the following hold (b) Value stores 1 and 2 agree on values of variables used in t S t · S2  E S1 ; both S1 and S2 ; f S f · S2  E S1 ; (c) Enumeration types in P1 are a subset of those in P2 ; By the definition of Impo (S1 ), variables used in the predicate The above three conditions are by assumption.  expression e are a subset of output deciding variables in S1 (d) The output deciding variables in S1 are a subset of those in  and S2 , Use(e)  OVar(S1 )  OVar(S2 ). By assumption, S2 ; corresponding variables used in e are of same value in value The above condition is by Lemma 6.5. stores 1 and 2 . By Lemma D.1, the expression evaluates to   produce the same output sequence, terminate in and S2 (e) S1 the same value w.r.t value stores 1 and 2 . There are three the same way and have equivalent computation of defined possibilities.   when started in states agreeing and S2 variables in both S1   (a) The evaluation of e crashes, E  e 1 = E  e 2 = on values of variables used in both S1 and S2 ;  (error, vof ). Because size(S1 ) = size(S1 ) + 1, then the condition holds The execution of S1 continues as follows: by the induction hypothesis. f t } else{S1 }, m1 (1 )) (If(e) then{S1 By Lemma 6.6, the lemma holds. f t f t } else{S1 }, m1 (1 )) (If((error, vof )) then{S1 3. S2 = "If(id==l) then {S2 } else {S2 }" such that both of the by the rule EEval' following hold: f t (If(0) then{S1 } else{S1 }, m1 (1/f)) · The label l is in E , l  E ; by the ECrash rule · The variable id is not lvalue in an assignment statement, i f t (If(0) then{S1 } else{S1 }, m1 (1/f)) for any i > 0 "id := e" in S2 ; f by the Crash rule. · There are updates of enumeration type extension from S2 f S Similarly, the execution of S2 started from the state m2 (2 ) to S1 , S2 E S1 ; crashes. The lemma holds. By Lemma 6.6, we show this lemma holds. We need to show all (b) The evaluation of e reduces to zero, E  e 1 = E  e 2 = the conditions are satisfied for the application of Lemma 6.6.   (0, vof ). · S1 and S2 have same set of output deciding variables,   The execution of S1 continues as follows. OVar ( S ) 1 = OVar(S2 ) = OVar(S ); f t  (If(e) then{S1 } else{S1 }, m1 (1 )) · The output deciding variables in S1 are a subset of those in f t    = (If((0, vof )) then{S1 } else{S1 }, m1 (1 )) S2 , OVar(S1 )  OVar(S2 ); by the rule EEval' By Lemma 6.5. f t (If(0) then{S1 } else{S1 }, m1 (1 )) · There are no inputs translated to enum labels in the set E . by the E-Oflow1 or E-Oflow2 rule By assumption. f    (S1 , m1 (1 )) by the If-F rule. · When started in states m 1 (1 ), m2 (1 ) where value stores   1 and 2 agree on values of output deciding variables in Similarly, the execution of S2 gets to the configuration   f both S1 and S2 as well as the input sequence variable and (S2 , m2 (2 )).
51 2015/9/14

the I/O sequence variable, and there are no inputs translated   to enum labels in E , then S1 and S2 produce the same output sequence. By the induction hypothesis IH. This is because the sum of   the program size of S1 and S2 is less than k. By definition,  ). size(S1 ) = 1 + size(S1 f t 4. S2 = "If(id==l) then {S2 } else {S2 }" such that both of the following hold: · The label l is in E , l  E ; · The variable id is not lvalue in an assignment statement, "id := e"  / S2 ; f · There are updates of enumeration type extension from S2 f S to S1 , S2 E S1 ; We informally argue that the value of the variable id in the predicate expression of S2 only coming from an input value or the initial value. There are several ways a scalar variable is defined: the execution of an assignment statement, the execution of an input statement or the initial value. Because id is not lvalue in an assignment statement, then the value of id is only from the execution of an input statement or initial value. In addition, by assumption, any used variable is not of initial value of enum label in E ; no input values are translated into an enum label in E. Then the expression id==l evaluates to 0. The execution of S2 proceeds as follows.
f t (If(id==l) then{S2 } else{S2 }, m2 (2 )) f t (If(v ==l) then{S2 } else{S2 }, m2 (2 )) where v = l by the rule Var f t (If(0) then{S2 } else{S2 }, m1 (2 )) by the Eq-F rule f (S2 , m2 (2 )) by the If-F rule.

 · There are no inputs translated to enum labels in E in S2 's

execution.
 · Initial values of used variables in S2 are not enum labels in

By the hypothesis IH, we show the lemma holds. We need to show the conditions are satisfied for the application of the hypothesis IH. f S · S2  E S1 f · There are no inputs translated to enum labels in E in S2 's execution. · Initial values of used variables in S2 are not enum labels in E. The above three conditions are by assumption. f · The sum of the program size of S1 and S2 is less than k, f size(S1 ) + size(S2 ) < k. f t By definition, size(S1 ) = 1 + size(S1 ) + size(S1 ). Then, f t size(S1 ) + size(S2 ) < k + 1 - 1 - size(S2 ) < k. · Value stores 1 and 2 agree on values of used variables in f both S1 and S2 as well as the input, I/O sequence variable. f By definition, OVar(S2 )  OVar(S2 ). In addition, value stores 1 and 2 are not changed in the evaluation of the predicate expression e. The condition holds. By the hypothesis IH, this lemma holds.   5. S1 = S1 ; s1 and S2 = S2 ; s2 such that both of the following hold:
  · S2 S E S1 ; S · s2 E s1 ;

  By the hypothesis IH, we show S2 and S1 terminate in the same way, produce the same output sequence, and have equivalent computation of defined variables in S1 and S2 . We need to show that all the conditions are satisfied for the application of the hypothesis IH.  S  · S2  E S1 ;

E. The above three conditions are by assumption.   · The sum of the program size of S1 and S2 is less than k,   size(S1 ) + size(S2 ) < k.  By definition, size(S1 ) = size(S1 ) + size(s1 ). Then,   size(S1 ) + size(S2 ) < k + 1 - size(s2 ) - size(s1 ) < k. · Value stores 1 and 2 agree on values of used variables in   both S1 and S2 as well as the input, output, I/O sequence variable.   By definition, OVar(S2 )  OVar(S2 ), OVar(S1 )  OVar(S1 ). In addition, value stores 1 and 2 are not changed in the evaluation of the predicate expression e. The condition holds. By the hypothesis IH, one of the following holds:   (a) S1 and S2 both do not terminate.  By Lemma E.2, executions of S1 = S1 ; s1 and S2 =  S2 ; s2 both do not terminate and produce the same output sequence.   (b) S1 and S2 both terminate.      By assumption, (S2 , m2 (2 ))  (skip, m 2 (2 )), (S1 , m1 (1 ))    (skip, m1 (1 )).    By Corollary E.1, (S2 ; s2 , m2 (2 ))  (s2 , m 2 (2 )),     (S1 ; s1 , m1 (1 ))  (s1 , m1 (1 )). By the hypothesis IH, we show that s2 and s1 terminate in the same way, produce the same output sequence and when s2 and s1 both terminate, s2 and s1 have equivalent computation of variables used or defined in s1 and s2 and the input, output, and I/O sequence variables. We need to show that all conditions are satisfied for the application of the hypothesis IH. · There are updates of "enumeration type extension" between s2 and s1 ; · There are no input values translated into enum labels in E in the execution of s2 ; The above two conditions are by assumption. · The sum of the program size s2 and s1 is less than or equals to k;   )  1. Therefore, )  1, size(S1 By definition, size(S2   size(s2 ) + size(s1 ) < k + 1 - size(S2 ) - size(S1 )  k.   · Value stores 1 and 2 agree on values of used variables in s2 and s1 as well as the input, output, I/O sequence variable. By Lemma 6.5, OVar(s1 )  OVar(s2 ), then OVar(s2 )  OVar(s1 ) = OVar(s1 ). Similarly, by Lemma 6.5,   OVar(S1 )  OVar(S2 ). For any variable id in OVar(s1 ),  if id is not in OVar(S1 ), then the value of id is not    changed in the execution of S1 and S2 , 1 (id) =  1 (id) = 2 (id) = 2 (id). Otherwise, the variable id   is defined in the execution of S1 and S2 , by assumption,   1 (id) = 2 (id). The condition holds. · Values of used variables in s2 are not of value as enum  labels in E , id  OVar(s2 ) : 2 (id)  E . By assumption, initial values of used variables in s2   are not of values as enum labels in E . S2 and S1 have  equivalent computation of defined variables in S2 and  S1 . Because enum labels are not defined in P1 , defined   variables in the execution of S2 and S1 are not of values as enum labels in E . By the hypothesis IH, the lemma holds.

52

2015/9/14

We show a auxiliary lemma telling that the two programs with updates of enumeration type extension have same set of used variables and the same set of defined variables. Lemma 6.5. If there are updates of enumeration type extension in a statement sequence S2 against a statement sequence S1 , S2 S E S1 , then the output deciding variables in S1 are a subset of those in S2 , OVar(S1 )  OVar(S2 ). Proof. By induction on the sum of the program size of S1 and S2 .
 Lemma 6.6. Let S1 = while n1 (e) {S1 } and S2 = while n2 (e)  {S2 } be two loop statements in programs P1 and P2 respectively where all of the following hold:

· Value stores 1i and 2i agree on values of output deciding

variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x).

Proof. By induction on i. Base case. We show that, when i = 1, one of the following holds: 1. Loop counters for S1 and S2 are always less than 1 if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))      1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (Def(S1 )  Def(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m2 ); 2. Loop counters of S1 and S2 are of value less than or equal to 1 1 but there are no reachable configurations (S1 , m1 (loop1 c , 1i )) 1 )) from ( S , m from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) 2 i c where all of the following hold: 1 · The loop counter of S1 and S2 are of value 1, loop1 c (n1 ) 1 = loop2 ) = 1 . ( n 2 c · Value stores 11 and 21 agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 11 (x) = 21 (x). 1 3. There are reachable configuration (S1 , m1 (loop1 c , 1i )) from 21 (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: 1 · The loop counter of S1 and S2 are of value 1, loop1 c (n1 ) 21 = loopc (n2 ) = 1. · Value stores 11 and 21 agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 11 (x) = 21 (x). By definition, variables used in the predicate expression e of S1 and S2 are used in S1 and S2 , Use(e)  Use(S1 )  Use(S2 ). By assumption, value stores 1 and 2 agree on values of variables in Use(e), the predicate expression e evaluates to the same value w.r.t value stores 1 and 2 by Lemma D.2. There are three possibilities. 1. The evaluation of e crashes, E  e 1 = E  e 2 = (error, vof ). The execution of S1 continues as follows:
 (while n1 (e) {S1 }, m1 (1 ))  (while n1 ((error, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (0) {S1 }, m1 (1/f)) by the ECrash rule i  (while n1 (0) {S1 }, m1 (1/f)) for any i > 0 by the Crash rule.

· Enumeration types EN 1 in P1 are a proper subset of EN 2 in

2 If S1 and S2 start in states m1 (loop1 c , 1 ), m2 (loopc , 2 ), with loop counters of S1 and S2 not initialized (S1 , S2 have not executed yet), value stores agree on values of output deciding variables in S1 and S2 as well as the input sequence variable, the I/O sequence variable, initial values of used variables in S2 are not of values as enum labels in E , no inputs are translated into enum labels in E , then, for any positive integer i, one of the following holds:

P2 , EN 1  EN 2 , such that there are a set of enum labels E only defined in P2 ; · When started in states agreeing on values of output deciding   variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, initial values of used  variables in S2 are not enum labels in E , and there are no inputs in S2 's execution translated into any label in E , x   OVar(S1 )  {idI , idIO } m1 (1 ) m2 (2 ) : 1 (x) = 2 (x),   and S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of defined   variables in S1 and S2 as well as the input sequence variable   and the I/O sequence variable ((S1 , m 1 )  H (S2 , m2 ))    ((S1 , m1 ) O (S2 , m2 ))  (x  OVar(S1 )  OVar(S2 )  {idI , idIO } :   (S1 , m 1 )  x (S2 , m2 ));

1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))     1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))   2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of output deciding variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) i )) from ( S , m ( 2 )) from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 2 i c where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 c (n2 ) = i. · Value stores 1i and 2i agree on values of output deciding variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x). i 3. There are reachable configurations (S1 , m1 (loop1 c , 1i )) from 2i (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) i ( n ) = i . = loop2 2 c
53

Similarly, the execution of S2 started from the state m2 (2 ) crashes. Therefore S1 and S2 terminate in the same way when started from m1 and m2 respectively. Because 1 (idIO ) = 2 (idIO ), the lemma holds. 2. The evaluation of e reduces to zero, E  e 1 = E  e 2 = (0, vof ). The execution of S1 continues as follows.

2015/9/14

 (while n1 (e) {S1 }, m1 (1 ))  = (while n1 ((0, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (0) {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule (skip, m1 (1 )) by the Wh-F rule.

of S1 and S2 are either in variables used or defined in both     S1 and S2 or not. Therefore value stores 2 and 1 agree on values of variables used in the expression e and even variables used or defined in S1 and S2 . Induction step on iterations The induction hypothesis (IH) is that, when i  1, one of the following holds: 1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))      1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))     2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (Def(S1 )  Def(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) i )) from ( S , m ( 2 )) from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 2 i c where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 ( n ) = i . 2 c · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 1i (x) = 2i (x). i 3. There are reachable configurations (S1 , m1 (loop1 c , 1i )) from 2i (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) 2i = loopc (n2 ) = i. · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 1i (x) = 2i (x).

Similarly, the execution of S2 gets to the configuration (skip, m2 (2 )). Loop counters of S1 and S2 are less than 1 and value stores agree on values of used/defined variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable. 3. The evaluation of e reduces to the same nonzero integer value, E  e 1 = E  e 2 = (0, vof ). Then the execution of S1 proceeds as follows:
 (while n1 (e) {S1 }, m1 (1 ))  = (while n1 ((v, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (v ) {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule   (S1 ; while n1 (e) {S1 }, m1 ( 1 loopc [1/n1 ], 1 )) by the Wh-T rule.

Similarly, the execution of S2 proceeds to the configuration   (S2 ; while n2 (e) {S2 }, m2 (loop2 c [1/n1 ], 2 )).   By the assumption, we show that S1 and S2 terminate in the same way and produce the same output sequence when started 21 1 in the state m1 (loop1 c , 1 ) and m2 (loopc , 2 ) respectively,   and S1 and S2 have equivalent computation of variables defined in both statement sequences if both terminate. We need to show that all conditions are satisfied for the application of the assumption. · There are no inputs translated into enum labels in E in the  execution of S2 . The above condition is by assumption.  · Initial values of used variables in S2 are not enum labels in E.  By the definition of used variables, Use(S2 )  Use(S2 ). By assumption, initial values of used variables in S2 are not enum labels in E . The condition holds. Then we show that, when i + 1, one of the following holds: The · Value stores 1 and 2 agree on values of used variables induction hypothesis (IH) is that, when i  1, one of the following   in S1 and S2 as well as the input, output, I/O sequence holds: variable.  By definition, Use(S1 )  Use(S1 ). So are the cases to 1. Loop counters for S1 and S2 are always less than i + 1 if any   S2 and S2 . In addition, value stores 1 and 2 are not 1  2 1 is present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))  changed in the evaluation of the predicate expression e. The     1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i +1, (S2 , m2 (loopc , 2 ))  condition holds.    2 2   (S2 , m 2 (loopc )), loopc (n2 ) < i + 1, S1 and S2 terminate and S2 terminate in the same way and By assumption, S1 in the same way, produce the same output sequence, and have produce the same output sequence when started in states    equivalent computation of used/defined variables in both S1 and have and S m1 (loop ,  ) and m ( loop ,  ) . In addition, S 1 2 2 1 2 c c  S2 and the input sequence variable, the I/O sequence variable, and equivalent computation of variables used or defined in S1   (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  S2 when started in states m1 (loop c , 1 ) and m2 (loopc , 2 ). (Def(S1 )  Def(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m2 ); Then there are two cases.   2. The loop counter of S1 and S2 are of value less than or (a) S1 and S2 both do not terminate and produce the same equal to i + 1, and there are no reachable configurations output sequence. i+1 ,    (S1 , m1 (loop1 1i+1 )) from (S1 , m1 (1 )), c By Lemma E.2, S1 ; S1 and S2 ; S2 both do not terminate 2i+1 (S2 , m2 (loopc , 2i+1 )) from (S2 , m2 (2 )) where all of the and produce the same output sequence.   following hold: (b) S1 and S2 both terminate and have equivalent computation   · The loop counters of S1 and S2 are of value i + 1, . and S2 of variables defined in S1  i+1 i+1     loop1 (n1 ) = loop2 (n2 ) = i + 1. By assumption, (S1 , m1 (loop ,  ))  ( skip , m ( loop ,  )) ; c c 1 1 1 c c     ·   and  Value stores  2 1 i+1 agree on values of used varii+1 (S2 , m2 (loopc , 2 ))  (skip, m2 (loopc , 2 )) where x      ables in both S1 and S2 as well as the input sequence vari(Def(S1 )  Def(S2 ))  {idI , idIO }, 1 ( x ) = 2 (x ).    able, and the I/O sequence variable, x  (Use(S1 )  By assumption,Use(S1 )  Use(S2 ) and Def(S1 ) =  Use(S2 ))  {idI , idIO } : 1i+1 (x) = 2i+1 (x). Def(S2 ). Then variables used in the predicate expression
54 2015/9/14

1i+1 3. There are reachable configurations (S1 , m1 (loopc , 1i )) i+1 )) from ( S , m from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) 2 i c where all of the following hold: 1i+1 · The loop counter of S1 and S2 are of value i, loopc (n1 ) 2i+1 = loopc (n2 ) = i + 1. · Value stores 1i+1 and 2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 1i+1 (x) = 2i+1 (x).

By hypothesis IH, there is no configuration where loop counters of S1 and S2 are of value i + 1 when any of the following holds: 1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))      1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (Def(S1 )  Def(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) i from (S1 , m1 (1 )), (S2 , m2 (loop2 c , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) 2i = loopc (n2 ) = i. · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 1i (x) = 2i (x).
i When there are reachable configurations (S1 , m1 (loop1 c , 1i )) i ,  )) from (S , m ( )) from (S1 , m1 (1 )), (S2 , m2 (loop2 2 2 2 2 i c where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 c (n2 ) = i.

ables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 1i+1 (x) = 2i+1 (x). i+1 3. There are reachable configurations (S1 , m1 (loop1 , 1i+1 )) c 2i+1 from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i+1 )) from (S2 , m2 (2 )) where all of the following hold: i+1 · The loop counter of S1 and S2 are of value i, loop1 (n1 ) c i+1 (n ) = i. = loop2 2 c i+1 · The loop counter of S1 and S2 are of value i, loop1 (n1 ) c i+1 (n ) = i. = loop2 2 c · Value stores 1i+1 and 2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI +1 , idIO } : 1i+1 (x) = 2i+1 (x).

· Value stores 1i+1 and 2i+1 agree on values of used vari-

6.3 Proof rule for variable type weakening In programs, variable types are changed either to allow for larger ranges (weakening). For example, an integer variable might be changed to become a long variable to avoid integer overflow. Adding a new enumeration value can is also type weakening. Increasing array size is another example of weakening. Allowing for type weakening is essentially an assumption about the intent behind the update. The kinds of weakening that should be allowed are application dependent and would need to be defined by the user in general. The type weakening considered are either changes of type Int to Long or increase of array size. These updates fix integer overflow or array index out of bound. In order to prove the update of variable type weakening to be backward compatible, we assume that there are no integer overflow and array index out of bound in execution of the old program and the updated program. In conclusion, the old program and the new program produce the same output sequence because the integer overflow and index out of bound errors fixed by the new program do not occur. We formalize the update of variable type weakening, then we show that the updated program produce the same output sequence as the old program in executions if there are no integer overflow or index out of bound exceptions related to variables with type changes. First, we define a relation between variable definitions showing the type weakening. Definition 28. (Cases of type weakening) We say there is type weakening from a sequence of variable definitions V1 to V2 , written V1  V2 , iff one of the following holds: 1. V1 = "Int id", V2 = "Long id"; 2. V1 = " id[n2 ]", V2 = " id[n1 ]" where n2 > n1 ; 3. V1 = V1 , "1 id1 ", V2 = V2 , "2 id2 " where (V1  V2 )  ("1 id1 "  "2 id2 "); 4. V1 = V1 , "1 id1 [n1 ]", V2 = V2 , "2 id2 [n2 ]" where (V1  V2 )  ("1 id1 [n1 ]"  "2 id2 [n2 ]"); The following is the generalized definition of variable type weakening. Definition 29. (Variable type weakening) We say that there are updates of variable type weakening in the program P2 = P mpt; EN ; V2 ; Sentry compared with the program P1 = P mpt; EN ; V1 ; Sentry , written P2 S  P1 , iff V1  V2 . We show that two programs terminate in the same way, produce the same output sequence, and have equivalent computation of defined variables in both programs in valid executions if there are updates of variable type weakening between them.

· Value stores 1i and 2i agree on values of used variables in

both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 1i (x) = 2i (x).

By similar argument in base case, we have one of the following holds: 1. Loop counters for S1 and S2 are always less than i + 1 if any  1  2 1 is present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))     1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i +1, (S2 , m2 (loopc , 2 ))   2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (Def(S1 )  Def(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i + 1, and there are no reachable configurations 2i i (S1 , m1 (loop1 c , 1i )) from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i+1 (n ) · The loop counters of S1 and S2 are of value i, loop1 1 c i+1 = loop2 ( n ) = i + 1 . 2 c
55

2015/9/14

Lemma 6.7. Let P1 = EN ; V1 ; Sentry and P2 = EN ; V2 ; Sentry be two programs where there are updates of variable type weakening, P2 S  P1 . If the programs P1 and P2 start in states m1 (1 ) and m2 (2 ) such that both of the following hold:
· Value stores 1 and 2 agree on values of variables used in

1: 2: 3: output a old

1': If (1/(a - 5)) then 2': skip 3': output a new

Sentry as well as the input sequence variable, the I/O sequence variable, x  Use(Sentry )  {idI , idIO } : 1 (x) = 2 (x); · There is no integer overflow or index out of bound exceptions related to variables of type change; then Sentry in the program P1 and P2 terminate in the same way, produce the same output sequence, and when Sentry both terminate, they have equivalent computation of defined variables in Sentry in both programs as well as the input sequence variable, the I/O sequence variable,
· (Sentry , m1 ) H (Sentry , m2 ); · (Sentry , m1 ) O (Sentry , m2 ); · x  Def(S )  {idI , idIO } :

Figure 17: Exit-on-error 6.4 Proof rule for exit on errors Another bugfix is called "exit-on-error", which causes the program to exit in observation of application-semantic-dependent errors. Figure 17 shows an example of exit-on-error update. In the example, the fixed bugs refer to the program semantic error that a = 5. Instead of using an "exit" statement, we rely on the crash from expression evaluations to formalize the update class. In order to prove the update of exit-on-error to be backward compatible, we assume that there are no application related error in executions of the old program. Therefore, the two programs produce the same output sequence because the extra check does not cause the new program's execution to crash. The following is the generalized definition of the update class "exit-on-error". Definition 30. (Exit on error) We say a statement sequence S2 includes updates of exit-on-err from a statement sequence S1 , written S2  S Exit S1 , iff one of the following holds:
1. S2 = "If(e) then{skip} else{skip}"; S1 ; t } else{S f }", S = "If(e) then{S t } else{S f }" 2. S1 = "If(e) then{S1 2 1 2 2 where both of the following hold t S S t ; · S2 Exit 1 f f · S2 S Exit S1 ;  }", S = "while  3. S1 = "while n1 (e) {S1 2 n2 (e) {S2 }" where  S  S2 Exit S1 ; 4. S1 S O S2 ;  ; s and S = S  ; s such that both of the following hold: 5. S1 = S1 1 2 2 2   · S2  S Exit S1 ;  S S  ; · S2 H 1  S S  ; · x  Imp(s1 , idIO )  Imp(s1 , idIO ) : S2 x 1 · s 2 S s ; 1 Exit

(Sentry , m1 ) x (Sentry , m2 );

Because Sentry are the exactly same in both programs P1 and P2 , we omit the straightforward proof. Instead, we show that, if there is no array index out of bound and integer overflow in executions of the old program, then there is no array index out of bound or integer overflow in executions of updated program due to the increase of array index and change of type Int to Long. Proof. The proof is straightforward because the statement sequence S is same in programs P1 and P2 . The only point is that if there is array index out of bound or integer overflow in execution of S in P1 , then there is no array index out of bound or integer overflow in execution of S in P2 . To show the point, we present the argument for the array index out of bound and integer overflow separately. 1. We show that, as to one expression id1 [id2 ], there is no array index out of bound in P2 if there is no array index out of bound in P1 when P1 and P2 are in states agreeing on values of used variables in P1 and P2 ; (id1 [id2 ], m1 (1 )) (id1 [v ], m1 (1 )) by the rule Var Similarly, (id1 [id2 ], m2 (2 ))  (id1 [v ], m2 (2 )). By Definition 28, the array bound of id1 in P2 is no less than that in P1 , then there is no array out of bound exception in evaluation of id1 [id2 ] in P2 if there is no array out of bound exception in evaluation of id1 [id2 ] in P1 . 2. We show that, as to one expression e, there is no integer overflow in evaluation of e in P2 if there is no integer overflow in evaluation of e in P1 ; (e, m1 (1 )) ((ve , vof ), m1 (1 )) by the rule EEval' When every used variable in the expression e is of same type in P1 and P2 , then the evaluation of the expression e in P2 is of the same result (ve , vof ) in P1 . When every used variable in the expression e is of type Int in P1 and of type Long P2 , then there is no integer overflow in the evaluation of the expression e in P2 if there is no integer overflow in the evaluation of the expression e in P1 . This is because the values of type Long are a superset of those of type Int.

Though the bugfix in Definition 30 is not in rare execution in the first case, the definition shows the basic form of bugfix clearly. We show that two programs terminate in the same way, produce the same output sequence, and have equivalent computation of defined variables in both programs in valid executions if there are updates of exit-on-error between them. Lemma 6.8. Let S1 and S2 be two statement sequences respectively where there are updates of exit-on-error in S2 against S1 , S2  S Exit S1 . If S1 and S2 start in states m1 (1 ) and m2 (2 ) such that both of the following hold:
· Value stores 1 and 2 agree on values of variables used in both

S1 and S2 as well as the input sequence variable and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , idIO } : 1 ( x ) = 2 ( x ) ; · There are no program semantic errors related to the extra check in the update of exit-on-error in the execution of S1 ; then S1 and S2 terminate in the same way, produce the same output sequence, and when S1 and S2 both terminate, they have equivalent computation of defined variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable,
· (S1 , m 1 )  H (S2 , m 2 ); · (S1 , m 1 )  O (S2 , m 2 );
56 2015/9/14

f t (If(0) then{S1 } else{S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule f (S1 , m1 (1 )) by the If-F rule. Proof. By induction on the sum of the program size of S1 and S2 , Similarly, the execution of S2 gets to the configuration f size(S1 ) + size(S2 ). (S2 , m2 (2 )). Base case. S1 = s and S2 = "If(e) then{skip} else{skip}"; s; By the hypothesis IH, we show the lemma holds. We need By assumption, there is no program semantic error related to to show that all conditions are satisfied for the application the update of exit-on-error. Then the evaluation of the predicate of the hypothesis IH. expression e in the first statement of S2 does not crash. W.l.o.g., the f S f · (S2 Exit S1 ) expression e evaluates to zero. Then the execution of S2 proceeds By assumption. as follows. f f · The sum of the program size of S1 and S2 is less than f f k, size(S1 ) + size(S2 ) < k. (If(e) then{skip} else{skip}; s, m2 (2 )) f t (If((0, vof )) then{skip} else{skip}; s, m2 (2 )) By definition, size(S1 ) = 1+size(S1 )+size(S1 ). Then, f f by the rule EEval' size(S1 ) + size(S2 ) < k + 1 - 2 = k - 1. (If(0) then{skip} else{skip}; s, m2 (2 )) · Value stores 1 and 2 agree on values of used variables f f by the rule E-Oflow1 or E-Oflow2. in S1 and S2 as well as the input, I/O sequence variable. (skip; s, m2 (2 )) by the rule If-F f By definition, Use(S1 )  Use(S1 ). So are the cases to (s, m2 (2 )) by the rule Seq. f S2 and S2 . In addition, value stores 1 and 2 are not  changed in the evaluation of the predicate expression e. Value stores 2 are not changed in the execution of (S2 , m2 (2 ))  The condition holds. (s, m2 (2 )). By assumption, 1 and 2 agree on values of used · There are no program semantic error related to the extra variables as well as the input sequence variable, and the I/O secheck in the update of exit-on-error in the execution of quence variable, x  Use(S2 )  Use(S1 )  {idI , idIO } : S2 . 1 (id) = 2 (id). By semantics, S1 and S2 terminate in the same By assumption. way, produce the same output sequence, and have equivalent comBy the hypothesis IH, the lemma holds. putation of defined variables in both S1 and S2 as well as the input (c) The evaluation of e reduces to the same nonzero integer sequence variable, and the I/O sequence variable. Then this lemma value, E  e 1 = E  e 2 = (v, vof ) where v = 0. holds. By similar to the second subcase above. Induction step. 2. S1 and S2 are both "while" statements: The hypothesis is that this lemma holds when the sum k of the   S1 = "while n (e) {S1 }", S2 = "while n (e) {S2 }" where program size of S1 and S2 are great than or equal to 4, k  4.  S  We then show that this lemma holds when the sum of the (S2 exit S1 ); program size of S1 and S2 is k + 1. There are cases to consider. By Lemma 6.10, we show this lemma holds. We need to show that all required conditions are satisfied for the application of 1. S1 and S2 are both "If" statement: Lemma 6.10. f f t t  S1 = "If(e) then{S1 } else{S1 }", S2 = "If(e) then{S2 } else{S2 }" · The output deciding variables in S1 are a subset of those in    where both of the following hold S2 , OVar(S1 ) = OVar(S2 ); t S t · (S2 Exit S1 ); By Lemma 6.9. f f S    · (S2 · When started in states m ); Exit S1 1 (1 ), m2 (1 ) where value stores    1 and 2 agree on values of used variables in both S1 By the definition of Use(S1 ), variables used in the predicate ex as well as the input sequence variable, and the I/O and S2 pression e are a subset of used variables in S1 and S2 , Use(e)    sequence variable, then S1 and S2 terminate in the same Use(S1 )  Use(S2 ). By assumption, corresponding variables way, produce the same output sequence, and have equivaused in e are of same value in value stores 1 and 2 . By lent computation of defined variables in both S1 and S2 as Lemma D.1, the expression evaluates to the same value w.r.t well as the input sequence variable, and the I/O sequence value stores 1 and 2 . There are three possibilities. variable. (a) The evaluation of e crashes, E  e 1 = E  e 2 = By the induction hypothesis IH. This is because the sum of (error, vof ).   is less than k. By definition, the program size of S1 and S2 The execution of S1 continues as follows:  f t size ( S ) = 1 + size ( S ) . 1 1 (If(e) then{S1 } else{S1 }, m1 (1 )) f t By Lemma 6.10, this lemma holds. } else{S1 }, m1 (1 )) (If((error, vof )) then{S1   3. S1 = S1 ; s1 and S2 = S2 ; s2 where both of the following hold: by the rule EEval' f t (If(0) then{S1 } else{S1 }, m1 (1/f))   · (S2 S Exit S1 ); by the ECrash rule S · ( s  s i 2 f Exit 1 ); t (If(0) then{S1 } else{S1 }, m1 (1/f)) for any i > 0   by the Crash rule. By the hypothesis IH, we show S2 and S1 terminate in the  Similarly, the execution of S2 started from the state m2 (2 ) same way and produce the same output sequence and when S2    crashes. The lemma holds. and S1 both terminate, S2 and S1 have equivalent terminating   (b) The evaluation of e reduces to zero, E  e 1 = E  e 2 = computation of variables used or defined in S2 and S1 as well (0, vof ). as the input sequence variable, and the I/O sequence variable. The execution of S1 continues as follows. We show all the required conditions are satisfied for the applif t cation of the hypothesis IH. (If(e) then{S1 } else{S1 }, m1 (1 )) f  S  t · (S2 Exit S1 ). = (If((0, vof )) then{S1 } else{S1 }, m1 (1 )) By assumption. by the rule EEval'

· x  (Def(S1 )  Def(S2 ))  {idI , idIO } :

(S1 , m 1 )  x (S2 , m 2 );

57

2015/9/14

 Lemma 6.10. Let S1 = while n1 (e) {S1 } and S2 = while n2 (e)    size(S1 ) + size(S2 ) < k. {S2 } be two loop statements where all of the following hold:  By definition, size(S2 ) = size(s2 ) + size(S2 ) where   · the output deciding variables in S1 are a subset of those in S2 ,   size(s2 ) < 1. Then, size(S2 ) + size(S1 ) < k +1-   OVar ( S )  OVar ( S ) = OVar ( S ) ; 1 2 size(s2 ) - size(s1 ) < k.    · When started in states m 1 (1 ), m2 (2 ) where · Value stores 1 and 2 agree on values of used variables in   Value stores agree on values of output deciding variables both S2 and S1 as well as the input, I/O sequence variable.     in both S1 and S2 as well as the input sequence variBy definition, Use(S2 )  Use(S2 ), Use(S1 )  Use(S1 ).  able, and the I/O sequence variable, x  OVar(S2 ) The condition holds.       { id , id }  m (  ) m (  ) :  ( x ) =  ( x ) ; I IO 1 1 2 2 1 2 By the hypothesis IH, one of the following holds: There are no program semantic errors related to the extra   (a) S1 and S2 both do not terminate.  check in the update of exit-on-error in executions of S1 and  By Lemma E.2, executions of S1 = S1 ; s1 and S2 =  S ;  2 S2 ; s2 both do not terminate and produce the same output   then S1 and S2 terminate in the same way, produce the same sequence. output sequence, and have equivalent computation of defined   (b) S1 and S2 both terminate.   variables in S1 and S2 as well as the input sequence variable,       By assumption, (S2 , m2 (2 ))  (skip, m2 (2 )), (S1 , m1 (1 ))    and the I/O sequence variable ((S1 , m 1 )  H (S2 , m2 ))    (skip, m1 (1 )).   (( S , m )  ( S , m ))  (  x  OVar ( S )  { id , id 1 O 2 I IO } : 1 2      By Corollary E.1, (S2 ; s2 , m2 (2 ))  (s2 , m 2 (2 )), (S1 , m 1 )  x (S2 , m2 ));     (S1 ; s1 , m1 (1 ))  (s1 , m1 (1 )). 2 If S1 and S2 start in states m1 (loop1 c , 1 ), m2 (loopc , 2 ) reBy the hypothesis IH, we show that s2 and s1 terminate spectively, with loop counters of S1 and S2 not initialized (S1 , S2 in the same way, produce the same output sequence and have not executed yet), value stores agree on values of used variwhen s2 and s1 both terminate, s2 and s1 have equivalent ables in S1 and S2 , and there are no program semantic errors recomputation of variables defined in both s1 and s2 and the lated to the extra check in the update of exit-on-error, then, for any input, and I/O sequence variables. positive integer i, one of the following holds: We need to show that all conditions are satisfied for the application of the hypothesis IH. 1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 · There are updates of "exit-on-error" between s2 and s1 , present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))     s2 S s ; 2 1   1 1 Exit (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))  By assumption, s2 S   2 2 Exit s1 . (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in · The sum of the program size s2 and s1 is less than or the same way, produce the same output sequence, and have equals to k; equivalent computation of output deciding variables in S1 and   By definition, size(S2 )  1, size(S1 )  1. Therefore, S2 and the input sequence variable, the I/O sequence vari  size(s2 ) + size(s1 ) < k + 1 - size(S2 ) - size(S1 )  k. able, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and   · Value stores 1 and 2 agree on values of output dex  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : ciding variables in s2 and s1 as well as the input, I/O (S1 , m 1 )  x (S2 , m 2 ); sequence variable. 2. The loop counter of S1 and S2 are of value less than or equal By Lemma 6.9, OVar(s1 )  OVar(s2 ), then OVar(s2 ) i to i, and there are no reachable configurations (S1 , m1 (loop1 c , OVar(s1 ) = OVar(s1 ). For any variable id in Use(s1 ), i )) from ( S , ,  1i )) from (S1 , m1 (1 )), (S2 , m2 (loop2 2 2  i c if id is not in OVar(S1 ), then the value of id is not m2 (2 )) where all of the following hold:    changed in the execution of S1 and S2 , 1 (id) = i · The loop counters of S1 and S2 are of value i, loop1  c (n1 ) 1 (id) = 2 (id) = 2 (id). Otherwise, the variable id 2i   = loop ( n ) = i . 2 c is defined in the execution of S1 and S2 , by assumption,   · Value stores 1i and 2i agree on values of output deciding (id). The condition holds. (id) = 2 1 variables in S1 and S2 as well as the input sequence vari· There are no program semantic errors related to the extra able, and the I/O sequence variable, x  (OVar(S1 )  check in the update of exit-on-error in the execution of OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x). S2 . i 3. There are reachable configurations (S1 , m1 (loop1 By assumption. c , 1i )) from 2i (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where By the hypothesis IH, the lemma holds. all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 ( n ) = i . 2 c · Value stores 1i and 2i agree on values of output deciding We list the auxiliary lemmas below. One lemma shows that, variables in S1 and S2 including the input sequence variif there are updates of exit-on-error between two statement seable and the I/O sequence variable, x  (OVar(S1 )  quences, then there are same set of defined variables in the two OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x). statement sequences, and the used variables in the update program are the superset of those in the old program. Proof. By induction on i. Lemma 6.9. Let S2 be a statement sequence and S1 where there Base case. are updates of exit-on-error, S2 S Exit S1 . Then output deciding variWe show that, when i = 1, one of the following holds: ables in S1 are a subset of those in S2 , OVar(S1 )  OVar(S2 ). 1. Loop counters for S1 and S2 are always less than 1 if any is  1  2 1 present, m Proof. By induction on the sum of the program size of S1 and 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))     1   1 2 S2 . (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the

  · The sum of the program size of S1 and S2 is less than k,

58

2015/9/14

same way, produce the same output sequence, and have equivalent computation of output deciding variables in S1 and S2 including the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. Loop counters of S1 and S2 are of values less than or equal to 1 1 but there are no reachable configurations (S1 , m1 (loop1 c , 1i )) 1 from (S1 , m1 (1 )), (S2 , m2 (loop2 c , 2i )) from (S2 , m2 (2 )) where all of the following hold: 1 · The loop counter of S1 and S2 are of value 1, loop1 c (n1 ) 21 = loopc (n2 ) = 1. · Value stores 11 and 21 agree on values of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 11 (x) = 21 (x). 1 3. There are reachable configuration (S1 , m1 (loop1 c , 1i )) from 1 )) from ( S , m ,  (S1 , m1 (1 )), (S2 , m2 (loop2 2 2 (2 )) where 2i c all of the following hold: 1 · The loop counter of S1 and S2 are of value 1, loop1 c (n1 ) 1 = loop2 ( n ) = 1 . 2 c · Value stores 11 and 21 agree on values of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 11 (x) = 21 (x). By definition, variables used in the predicate expression e of S1 and S2 are in output deciding variables in S1 and S2 , Use(e)  OVar(S1 )  OVar(S2 ). By assumption, value stores 1 and 2 agree on values of variables in Use(e), the predicate expression e evaluates to the same value w.r.t value stores 1 and 2 by Lemma D.2. There are three possibilities. 1. The evaluation of e crashes, E  e 1 = E  e 2 = (error, vof ). The execution of S1 continues as follows:
 (while n1 (e) {S1 }, m1 (1 ))  (while n1 ((error, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (0) {S1 }, m1 (1/f)) by the ECrash rule i  }, m1 (1/f)) for any i > 0 (while n1 (0) {S1 by the Crash rule.

3. The evaluation of e reduces to the same nonzero integer value, E  e 1 = E  e 2 = (0, vof ). Then the execution of S1 proceeds as follows:
 (while n1 (e) {S1 }, m1 (1 ))  = (while n1 ((v, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (v ) {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule   (S1 ; while n1 (e) {S1 }, m1 ( 1 loopc  {(n1 )  1}, 1 )) by the Wh-T rule.

Similarly, the execution of S2 started from the state m2 (2 ) crashes. Therefore S1 and S2 terminate in the same way when started from m1 and m2 respectively. Because 1 (idIO ) = 2 (idIO ), the lemma holds. 2. The evaluation of e reduces to zero, E  e 1 = E  e 2 = (0, vof ). The execution of S1 continues as follows.
 (while n1 (e) {S1 }, m1 (1 ))  = (while n1 ((0, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (0) {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule (skip, m1 (1 )) by the Wh-F rule.

Similarly, the execution of S2 proceeds to the configuration   (S2 ; while n2 (e) {S2 }, m2 (loop2 c  {(n2 )  1}, 2 )).   By the assumption, we show that S1 and S2 terminate in the same way and produce the same output sequence when started 21 1 in the state m1 (loop1 c , 1 ) and m2 (loopc , 2 ) respectively,   and S1 and S2 have equivalent computation of variables defined in both statement sequences if both terminate. We need to show that all conditions are satisfied for the application of the assumption. · There are no program semantic errors related to the extra  check in the update of exit-on-error in executions of S2 and  S1 . The above two conditions are by assumption. · Value stores 1 and 2 agree on values of output deciding   variables in S1 and S2 including the input, I/O sequence variable.  )  OVar(S1 ). So are the cases By definition, OVar(S1  to S2 and S2 . In addition, value stores 1 and 2 are not changed in the evaluation of the predicate expression e. The condition holds.   terminate in the same way and and S2 By assumption, S1 produce the same output sequence when started in states    m1 (loop c , 1 ) and m2 (loopc , 2 ). In addition, S1 and S2 have  and equivalent computation of output deciding variables in S1   S2 when started in states m1 (loop ,  ) and m ( loop ,  1 2 2 ). c c Then there are two cases.   (a) S1 and S2 both do not terminate and produce the same output sequence.   By Lemma E.2, S1 ; S1 and S2 ; S2 both do not terminate and produce the same output sequence.   (b) S1 and S2 both terminate and have equivalent computation   of output deciding variables in S1 and S2 .      By assumption, (S1 , m1 (loopc , 1 ))  (skip, m 1 (loopc , 1 ));       (S2 , m2 (loopc , 2 ))  (skip, m2 (loopc , 2 )) where x      (OVar(S1 )  OVar(S2 ))  {idI , idIO }, 1 ( x ) = 2 (x ).   By Lemma 6.9, OVar(S1 )  OVar(S2 ). Then variables used in the predicate expression of S1 and S2 are either in   output deciding variables in both S1 and S2 or not. There  fore value stores 2 and 1 agree on values of variables used in the expression e and even output deciding variables in S1 and S2 . Induction step on iterations The induction hypothesis (IH) is that, when i  1, one of the following holds: 1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))     1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of output deciding variables in both S1 and S2

Similarly, the execution of S2 gets to the configuration (skip, m2 (2 )). Loop counters of S1 and S2 are less than 1 and value stores agree on values of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable.

59

2015/9/14

as well as the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) i ,  )) from (S , m ( )) from (S1 , m1 (1 )), (S2 , m2 (loop2 2 2 2 2 i c where all of the followings hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 c (n2 ) = i. · Value stores 1i and 2i agree on values of output deciding variables in S1 and S2 including the input sequence variable, and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x). i 3. There are reachable configurations (S1 , m1 (loop1 c , 1i )) from 2i (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 ( n ) = i . 2 c · Value stores 1i and 2i agree on values of output deciding variables in S1 and S2 including the input sequence variable, and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x)). Then we show that, when i + 1, one of the following holds: 1. Loop counters for S1 and S2 are always less than i + 1 if any  1  2 1 is present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))      1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i +1, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i + 1, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m 1 )  x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i + 1, and there are no reachable configurations i+1 i+1 , (S1 , m1 (loop1 , 1i+1 )) from (S1 , m1 (1 )), (S2 , m2 (loop2 c c 2i+1 )) from (S2 , m2 (2 )) where all of the following hold: · The loop counters of S1 and S2 are of value i + 1, i+1 i+1 loop1 (n1 ) = loop2 (n2 ) = i + 1. c c · Value stores 1i+1 and 2i+1 agree on values of output deciding variables in S1 and S2 including the input sequence variable, and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i+1 (x) = 2i+1 (x). i+1 ,  )) 3. There are reachable configurations (S1 , m1 (loop1 1i c i+1 )) from ( S from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 , m2 (2 )) 2 i c where all of the following hold: i+1 · The loop counter of S1 and S2 are of value i, loop1 (n1 ) c i+1 (n ) = i + 1. = loop2 2 c · Value stores 1i+1 and 2i+1 agree on values of output deciding variables in S1 and S2 including the input sequence variable, and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i+1 (x) = 2i+1 (x). By hypothesis IH and theorem 4 and 5, there is no configuration where loop counters of S1 and S2 are of value i + 1 when any of the following holds: 1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))   1   1 2 (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))   2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the
60

same way, produce the same output sequence, and have equivalent computation of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) i from (S1 , m1 (1 )), (S2 , m2 (loop2 c , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 c (n2 ) = i. · Value stores 1i and 2i agree on values of output deciding variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x).
i When there are reachable configurations (S1 , m1 (loop1 c , 1i )) i )) from ( S , m ,  from (S1 , m1 (1 )), (S2 , m2 (loop2 2 2 (2 )) 2i c where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 )

i = loop2 c (n2 ) = i. · Value stores 1i and 2i agree on values of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i (x) = 2i (x).

By similar argument in base case, we have one of the following holds: 1. Loop counters for S1 and S2 are always less than i + 1 if any  1  2 1 is present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))      1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i +1, (S2 , m2 (loopc , 2 ))     2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of output deciding variables in S1 and S2 including the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : (S1 , m1 ) x (S2 , m 2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i + 1, and there are no reachable configurations 2i i (S1 , m1 (loop1 c , 1i )) from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i+1 · The loop counters of S1 and S2 are of value i, loop1 (n1 ) c i+1 (n ) = i + 1. = loop2 2 c · Value stores 1i+1 and 2i+1 agree on values of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI , idIO } : 1i+1 (x) = 2i+1 (x). i+1 3. There are reachable configurations (S1 , m1 (loop1 , 1i+1 )) c 2i+1 from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i+1 )) from (S2 , m2 (2 )) where all of the following hold: i+1 · The loop counter of S1 and S2 are of value i, loop1 (n1 ) c 2i+1 = loopc (n2 ) = i. · Value stores 1i+1 and 2i+1 agree on values of output deciding variables in S1 and S2 including the input sequence variable, and the I/O sequence variable, x  (OVar(S1 )  OVar(S2 ))  {idI +1 , idIO } : 1i+1 (x) = 2i+1 (x).

2015/9/14

6.5 Proof rule for improved prompt message If the only difference between two programs are the constant messages that the user receives, we consider that the two programs to be equivalent. We realize that in general it is possible to introduce new semantics even by changing constant strings. An old version might have incorrectly labeled output: "median value = 5" instead of "average value = 5, for example. We rule out such possibilities because all non-constant values are guaranteed to be exactly same. In practice, outputs could be classified into prompt outputs and actual outputs. Prompt outputs are those asking clients for inputs, which are constants hardcoded in the output statement. Actual outputs are dynamic messages produced by evaluation of non-constant expression in execution. The changes of prompt outputs are equivalent only for interactions with human clients. In order to prove the update of improved prompt messages to be backward compatible, we assume that the different prompt outputs produced in executions of the old program and the updated program, due to the different constants in output statements, are equivalent. Because the old program and the new program are exactly same except some output statements with different constants as expression e, we could show two programs produce the "equivalent" output sequence under the assumption of equivalent prompt outputs. We formalize the generalized update of improved prompt messages, then we show that the updated program produce the same I/O sequence as the old program in executions without program semantic errors. The following is the definition of the update class of improved prompt messages. Definition 31. (Improved user messages) A program P2 = P mpt2 ; EN ; V ; Sentry includes updates of improved prompt messages compared with a program P1 = P mpt1 ; EN ; V ; Sentry , written P2 S Out P1 , iff P mpt2 = P mpt1 . We give the lemma that two programs terminate in the same way, produce the equivalent output sequence, and have equivalent computation of defined variables in both programs in valid executions if there are updates of improved prompt messages between them. Lemma 6.11. Let P1 = P mpt1 ; EN ; V ; Sentry and P2 = P mpt2 ; EN ; V ; Sentry be two programs where there are updates of improved prompt messages in P2 compared with P1 . If S1 and S2 start in states m1 (1 ) and m2 (2 ) such that both of the following hold:
· Value stores 1 and 2 agree on values of variables used in

programs P1 and P2 have the same entry statement sequence and we have the assumption that different prompt outputs due to the difference of the prompt type are equivalent. Proof. By induction on the sum of the program size of S1 and S2 , size(S1 ) + size(S2 ). Base case. S1 = "output v1 " and S2 = "output v2 "; Then the execution of S2 proceeds as follows. (output v2 , m2 (2 )) (skip, m2 (2 ["2 (idIO ) · v ¯ 2 "/idIO ])) by the rule Out-1 or Out-2 Similarly, (output v1 , m1 (1 ))  (skip, m1 (1 ["1 (idIO )·v ¯ 1 "/idIO ])). By assumption, 2 (idIO )  1 (idIO ). In addition, by assumption, v ¯ ¯ 2  v 1 . Therefore, S1 and S2 terminate in the same way, produce the same output sequence and have equivalent computation of defined variables in S1 and S2 . This lemma holds. Induction step. The hypothesis is that this lemma holds when the sum k of the program size of S1 and S2 are great than or equal to 2, k  2. We then show that this lemma holds when the sum of the program size of S1 and S2 is k + 1. There are cases to consider. 1. S1 and S2 are both "If" statement: f f t t S1 = "If(e) then{S1 } else{S1 }", S2 = "If(e) then{S2 } else{S2 }" where both of the following hold t S t · S2 Out S1 ; f S f · S2 Out S1 ; By the definition of Use(S1 ), variables used in the predicate expression e are a subset of used variables in S1 and S2 , Use(e)  Use(S1 )  Use(S2 ). By assumption, corresponding variables used in e are of same value in value stores 1 and 2 . By Lemma D.1, the expression evaluates to the same value w.r.t value stores (1 and 2 . There are three possibilities. (a) The evaluation of e crashes, E  e 1 = E  e 2 = (error, vof ). The execution of S1 continues as follows: f t (If(e) then{S1 } else{S1 }, m1 (1 )) f t (If((error, vof )) then{S1 } else{S1 }, m1 (1 )) by the rule EEval' f t (If(0) then{S1 } else{S1 }, m1 (1/f)) by the ECrash rule i f t (If(0) then{S1 } else{S1 }, m1 (1/f)) for any i > 0 by the Crash rule. Similarly, the execution of S2 started from the state m2 (2 ) crashes. The lemma holds. (b) The evaluation of e reduces to zero, E  e 1 = E  e 2 = (0, vof ). The execution of S1 continues as follows. f t (If(e) then{S1 } else{S1 }, m1 (1 )) f t = (If((0, vof )) then{S1 } else{S1 }, m1 (1 )) by the rule EEval' f t (If(0) then{S1 } else{S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule f (S1 , m1 (1 )) by the If-F rule. Similarly, the execution of S2 gets to the configuration f (S2 , m2 (2 )). By the hypothesis IH, we show the lemma holds. We need to show that all conditions are satisfied for the application of the hypothesis IH. f S f · S2 Out S1 By assumption.


Sentry in both programs as well as the input sequence variable, x  Use(Sentry )  {idI } : 1 (x) = 2 (x); · Value stores 1 and 2 have "equivalent" I/O sequence, 1 (idIO )  2 (idIO ); · The different prompt outputs in the update of improved prompt messages are equivalent; then S1 and S2 terminate in the same way, produce the equivalent output sequence, and when S1 and S2 both terminate, they have equivalent computation of defined variables in Sentry in both programs as well as the input sequence variable, Sentry in the two programs produce the equivalent I/O sequence variable,
· (Sentry , m1 ) H (Sentry , m2 ); · x  (Def(S1 )  Def(S2 ))  {idI } : (Sentry , m1 ) x

(Sentry , m2 );

· The produced output sequences in executions of Sentry in both

programs are "equivalent", 1 (idIO )  2 (idIO ). The difference between prompt types in P1 and P2 can be either addition/removal of labels as well as the change of the mapping of labels with constants. The proof is straightforward because

61

2015/9/14

f f k, size(S1 ) + size(S2 ) < k. f t By definition, size(S1 ) = 1+size(S1 )+size(S1 ). Then, f f size(S1 ) + size(S2 ) < k + 1 - 2 = k - 1. · Value stores 1 and 2 agree on values of used variables f f in S1 and S2 as well as the input, I/O sequence variable. f By definition, Use(S1 )  Use(S1 ). So are the cases to f S2 and S2 . In addition, value stores 1 and 2 are not changed in the evaluation of the predicate expression e. The condition holds. · Different constants used in output statements are equivalent as output values. By assumption. By the hypothesis IH, the lemma holds. (c) The evaluation of e reduces to the same nonzero integer value, E  e 1 = E  e 2 = (v, vof ) where v = 0. By argument similar to the second subcase above. 2. S1 and S2 are both "while" statements:   S1 = "while n (e) {S1 }", S2 = "while n (e) {S2 }" where  S  S2 Out S1 ; By Lemma 6.13, we show this lemma holds. We need to show that all required conditions are satisfied for the application of Lemma 6.13.    · S1 and S2 have same set of defined variables, Def(S1 ) =  Def(S2 ) = Def(S );   · The used variables in S1 are a subset of those in S2 ,   Use(S1 ) = Use(S2 ); By Lemma 6.12.    · When started in states m 1 (1 ), m2 (1 ) where value stores    and 1 and 2 agree on values of used variables in both S1  S2 as well as the input sequence variable, , and the I/O   terminate in the same and S2 sequence variable, then S1 way, produce the same output sequence, and have equivalent computation of defined variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable. By the induction hypothesis IH. This is because the sum of   the program size of S1 and S2 is less than k. By definition,  size(S1 ) = 1 + size(S1 ). By Lemma 6.13, this lemma holds.   3. S1 = S1 ; s1 and S2 = S2 ; s2 where both of the following hold:   · S2 S Out S1 ; · s2 S Out s1 ;

f f · The sum of the program size of S1 and S2 is less than

  By definition, Use(S2 )  Use(S2 ), Use(S1 )  Use(S1 ). The condition holds. By the hypothesis IH, one of the following holds:   (a) S1 and S2 both do not terminate.  By Lemma E.2, executions of S1 = S1 ; s1 and S2 =  S2 ; s2 both do not terminate and produce the same output sequence.   (b) S1 and S2 both terminate.      By assumption, (S2 , m2 (2 ))  (skip, m 2 (2 )), (S1 , m1 (1 ))    (skip, m1 (1 )).    By Corollary E.1, (S2 ; s2 , m2 (2 ))  (s2 , m 2 (2 )),     (S1 ; s1 , m1 (1 ))  (s1 , m1 (1 )). By the hypothesis IH, we show that s2 and s1 terminate in the same way, produce the "equivalent" output sequence and when s2 and s1 both terminate, s2 and s1 have equivalent computation of variables defined in both s1 and s2 and the input sequence variable; s2 and s1 produce "equivalent" output sequence. We need to show that all conditions are satisfied for the application of the hypothesis IH. · There are updates of "improved prompt messages" in s2 compared with s1 , s2 S Out s1 ; By assumption, s2 S Out s1 . · The sum of the program size s2 and s1 is less than or equals to k;   By definition, size(S2 )  1, size(S1 )  1. Therefore,   size(s2 ) + size(s1 ) < k + 1 - size(S2 ) - size(S1 )  k.   · Value stores 1 and 2 agree on values of used variables in s2 and s1 as well as the input sequence variable; By Lemma 6.9, Use(s1 ) = Use(s2 ), then Use(s2 ) = Use(s1 ) = Use(s). Similarly, by Lemma 6.9,   ). For any variable id in Use(s1 ), if ) = Def(S2 Def(S1  id is not in Def(S1 ), then the value of id is not changed    (id) = 1 (id) = , 1 and S2 in the execution of S1  2 (id) = 2 (id). Otherwise, the variable id is de  fined in the execution of S1 and S2 , by assumption,   1 (id) = 2 (id). The condition holds.  · Values of , the I/O sequence variable in value stores 1  and 2 are equivalent. By assumption. By the hypothesis IH, the lemma holds.

  By the hypothesis IH, we show S2 and S1 terminate in the same  way and produce the equivalent output sequence and when S2    both terminate, S2 and S1 have equivalent terminating and S1   computation of variables defined in S2 and S1 as well as the input sequence variable. By assumption, the different value of the I/O sequence in executions of S1 and S2 are equivalent. We show all the required conditions are satisfied for the application of the hypothesis IH.   S · S2 ; Out S1 · The I/O sequence variable in executions of S1 and S2 are equivalent, 1 (idIO )  2 (idIO ); By assumption.   · The sum of the program size of S1 and S2 is less than k,   size(S1 ) + size(S2 ) < k.  By definition, size(S2 ) = size(s2 ) + size(S2 ) where   size(s2 ) < 1. Then, size(S2 ) + size(S1 ) < k + 1 - size(s2 ) - size(s1 ) < k. · Value stores 1 and 2 agree on values of used variables in   both S2 and S1 as well as the input sequence variable.

We list the auxiliary lemmas below. One lemma shows that, if there are updates of improved prompt messages between two statement sequences, then there are same set of defined variables and used variables in the two statement sequences. The second lemma shows that, if there are updates of improved prompt messages between two loop statements, then the two loop statement terminate in the same way, produce the equivalent output sequence, and have equivalent computation of defined variables in both the old and updated programs as well as the input sequence variable. Lemma 6.12. Let S2 be a statement sequence and S1 where there are updates of "improved prompt messages", S2 S Out S1 . Then used variables in S2 are the same of used variables in S1 , Use(S1 ) = Use(S2 ), defined variables in S2 are the same as used variables in S1 , Def(S1 ) = Def(S2 ). Proof. By induction on the sum of the program size of S1 and S2 .
 Lemma 6.13. Let S1 = while n1 (e) {S1 } and S2 = while n2 (e)  {S2 } be two loop statements where all of the following hold:

62

2015/9/14

2 If S1 and S2 start in states m1 (loop1 c , 1 ), m2 (loopc , 2 ) respectively, with loop counters of S1 and S2 not initialized (S1 , S2 have not executed yet), value stores agree on values of used variables in S1 and S2 , and there are no program semantic errors, then, for any positive integer i, one of the following holds:

  S  pared with S1 , S2 Out S1 ;   · S1 and S2 have same set of defined variables,   Def(S1 ) = Def(S2 ) = Def(S );    · S1 and S2 have same set of used variables, Use(S1 ) =  Use(S2 );    · When started in states m 1 (1 ), m2 (2 ) where Value stores agree on values of used variables in both   S1 and S2 as well as the input sequence variable, x        Use(S1 )  {idI } m 1 ( 1 ) m 2 ( 2 ) : 1 ( x ) = 2 ( x ) ;   Values of the I/O sequence variable in value stores 1 , 2   are equivalent, 1 (idIO )  2 (idIO ));   then S1 and S2 terminate in the same way, produce the "equivalent" output sequence, and have equivalent computation of   defined variables in S1 and S2 as well as the input sequence   variable, ((S1 , m 1 )  H (S2 , m2 ))  (x  Def(S )  {idI } :   (S1 , m 1 )  x (S2 , m2 ));

 · There are updates of improved prompt messages in S2 com-

1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))     1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))   2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the equivalent output sequence, and have equivalent computation of defined variables in both S1 and S2 and the input sequence variable, (S1 , m1 ) H (S2 , m2 ) and x  (Def(S1 )  Def(S2 ))  {idI } : (S1 , m1 ) x (S2 , m2 );S1 and S2 produce the "equivalent" I/O sequence; 2. The loop counter of S1 and S2 are of value less than or equal i to i, and there are no reachable configurations (S1 , m1 (loop1 c , 2i 1i )) from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) 2i = loopc (n2 ) = i. · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 1i (x) = 2i (x). · Values of the I/O sequence variable in value stores 1i (idIO )  2i (idIO ); i 3. There are reachable configurations (S1 , m1 (loop1 c , 1i )) from i )) from ( S , m (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) where 2 i c all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 ( n ) = i . 2 c · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 1i (x) = 2i (x). · Values of the I/O sequence variable in value stores 1i , 2i are equivalent, 1i (idIO )  2i (idIO ); Proof. By induction on i. Base case. We show that, when i = 1, one of the followings holds: 1. Loop counters for S1 and S2 are always less than 1 if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))       1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))   2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the equivalent I/O sequence, and have

equivalent computation of defined variables in both S1 and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and x  Def(S )  {idI } : (S1 , m 1 )  x (S2 , m 2 ); 2. S1 and S2 produce the equivalent output sequence and the equivalent I/O sequence; 3. Loop counters of S1 and S2 are of values less than or equal to 1 1 but there are no reachable configurations (S1 , m1 (loop1 c , 1i )) 1 )) from ( S , m from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) 2 i c where all of the following hold: 1 · The loop counter of S1 and S2 are of value 1, loop1 c (n1 ) 1 = loop2 ( n ) = 1 . 2 c · Value stores 11 and 21 agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 11 (x) = 21 (x). · Values of the I/O sequence variable in value stores 11 and 21 are equivalent, 11 (idIO )  21 (idIO ); 1 4. There are reachable configuration (S1 , m1 (loop1 c , 1i )) from 1 )) from ( S , m (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) where 2 i c all of the following hold: 1 · The loop counter of S1 and S2 are of value 1, loop1 c (n1 ) 1 = loop2 ( n ) = 1 . 2 c · Value stores 11 and 21 agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 11 (x) = 21 (x). · Values of the I/O sequence variable in value stores 11 and 21 are equivalent, 11 (idIO )  21 (idIO ); By definition, variables used in the predicate expression e of S1 and S2 are used in S1 and S2 , Use(e)  Use(S1 )  Use(S2 ). By assumption, value stores 1 and 2 agree on values of variables in Use(e), the predicate expression e evaluates to the same value w.r.t value stores 1 and 2 by Lemma D.2. There are three possibilities. 1. The evaluation of e crashes, E  e 1 = E  e 2 = (error, vof ). The execution of S1 continues as follows:
 (while n1 (e) {S1 }, m1 (1 ))  }, m1 (1 )) (while n1 ((error, vof )) {S1 by the rule EEval'  (while n1 (0) {S1 }, m1 (1/f)) by the ECrash rule i  (while n1 (0) {S1 }, m1 (1/f)) for any i > 0 by the Crash rule.

Similarly, the execution of S2 started from the state m2 (2 ) crashes. Therefore S1 and S2 terminate in the same way when started from m1 and m2 respectively. Because 1 (idIO )  2 (idIO ), the lemma holds. 2. The evaluation of e reduces to zero, E  e 1 = E  e 2 = (0, vof ). The execution of S1 continues as follows.
 (while n1 (e) {S1 }, m1 (1 ))  = (while n1 ((0, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (0) {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule (skip, m1 (1 )) by the Wh-F rule.

Similarly, the execution of S2 gets to the configuration (skip, m2 (2 )). Loop counters of S1 and S2 are less than 1 and value stores agree on values of used/defined variables in both S1 and S2

63

2015/9/14

as well as the input sequence variable and the I/O sequence variable. 3. The evaluation of e reduces to the same nonzero integer value, E  e 1 = E  e 2 = (v, vof ) where v = 0. Then the execution of S1 proceeds as follows:
 (while n1 (e) {S1 }, m1 (1 ))  = (while n1 ((v, vof )) {S1 }, m1 (1 )) by the rule EEval'  (while n1 (v ) {S1 }, m1 (1 )) by the E-Oflow1 or E-Oflow2 rule   (S1 ; while n1 (e) {S1 }, m1 (loop1 c [1/n1 ], 1 )) by the Wh-T rule.

Similarly, the execution of S2 proceeds to the configuration   (S2 ; while n2 (e) {S2 }, m2 (loop2 c [1/n2 ], 2 )).   By the assumption, we show that S1 and S2 terminate in the same way and produce the equivalent I/O sequence when 21 1 started in the state m1 (loop1 c , 1 ) and m2 (loopc , 2 ) respec  tively, and S1 and S2 have equivalent computation of variables defined in both statement sequences if both terminate. We need to show that all conditions are satisfied for the application of the assumption. · Values of the I/O sequence variable in value stores 1 and 2 are equivalent, 1 (idIO )  2 (idIO ); The above two conditions are by assumption. · Value stores 1 and 2 agree on values of used variables in Then we show that, when i + 1, one of the following holds: The   S1 and S2 as well as the input sequence variable. induction hypothesis (IH) is that, when i  1, one of the following  By definition, Use(S1 )  Use(S1 ). So are the cases to holds:  S2 and S2 . In addition, value stores 1 and 2 are not changed in the evaluation of the predicate expression e. The 1. Loop counters for S1 and S2 are always less than i + 1 if any condition holds.  1  2 1 is present, m   1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))  By assumption, S1 and S2 terminate in the same way and    1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i +1, (S2 , m2 (loopc , 2 ))  produce the equivalent output sequence when started in states   2 2     (S2 , m2 (loopc )), loopc (n2 ) < i + 1, S1 and S2 terminate in m1 (loopc , 1 ) and m2 (loopc , 2 ). In addition, S1 and S2 have  the same way, produce the equivalent I/O sequence, and have and equivalent computation of variables used or defined in S1   equivalent computation of defined variables in both S1 and S2 when started in states m1 (loop c , 1 ) and m2 (loopc , 2 ). S2 and the input sequence variable, (S1 , m1 ) H (S2 , m2 ) Then there are two cases.   and (S1 , m1 ) O (S2 , m2 ) and x  (Def(S )  {idI } : (a) S1 and S2 both do not terminate and produce the equivalent (S1 , m1 ) x (S2 , m2 ); S1 and S2 produce the "equivalent" I/O sequence.   I/O sequence variable; By Lemma E.2, S1 ; S1 and S2 ; S2 both do not terminate 2. The loop counter of S1 and S2 are of value less than or and produce the equivalent I/O sequence.   equal to i + 1, and there are no reachable configurations (b) S1 and S2 both terminate and have equivalent computation i+1 i+1   , (S1 , m1 (loop1 , 1i+1 )) from (S1 , m1 (1 )), (S2 , m2 (loop2 of variables defined in S1 and S2 . c c       )) from ( S , m (  )) where all of the following hold:  2 2 2 2i+1 By assumption, (S1 , m1 (loopc , 1 ))  (skip, m1 (loopc , 1 ));      · The loop counters of S1 and S2 are of value i + 1, (S2 , m2 (loop c , 2 ))  (skip, m2 (loopc , 2 )) where x  i+1 i+1     loop1 (n1 ) = loop2 (n2 ) = i + 1. c c (Def(S1 )  Def(S2 ))  {idI }, 1 ( x ) = 2 (x ).    · Value stores 1i+1 and 2i+1 agree on values of used variBy assumption,Use(S1 ) = Use(S2 ) and Def(S1 ) =  ables in both S1 and S2 as well as the input sequence variDef(S2 ). Then variables used in the predicate expression able, x  (Use(S1 )  Use(S2 ))  {idI } : 1i+1 (x) = of S1 and S2 are either in variables used or defined in both     2i+1 (x). or not. Therefore value stores 2 and 1 agree and S2 S1 · Values of the I/O sequence variable in value stores 1i+1 on values of variables used in the expression e and even and 2i+1 are equivalent, 1i+1 (idIO )  2i+1 (idIO ); variables used or defined in S1 and S2 . i+1 By assumption, S1 and S2 produce the equivalent output 3. There are reachable configurations (S1 , m1 (loop1 , 1i )) c sequence. i+1 )) from ( S , m from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) 2 i c where all of the following hold: Induction step on iterations i+1 · The loop counter of S1 and S2 are of value i, loop1 (n1 ) c The induction hypothesis (IH) is that, when i  1, one of the 2i+1 = loop ( n ) = i + 1 . 2 c following holds: · Value stores 1i+1 and 2i+1 agree on values of used vari1. Loop counters for S1 and S2 are always less than i if any is ables in both S1 and S2 as well as the input sequence vari 1  2 1 able, x  (Use(S1 )  Use(S2 ))  {idI } : 1i+1 (x) = present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))    1 1 2 2i+1 (x); (S1 , m 1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))   · Values of the I/O sequence variable in value stores 1i+1   2 2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the and 2i+1 are equivalent, 1i+1 (idIO )  2i+1 (idIO ); same way, and have equivalent computation of defined variables
64 2015/9/14

in both S1 and S2 and the input sequence variable, (S1 , m1 ) H (S2 , m2 ) and x  Def(S )  {idI } : (S1 , m1 ) x (S2 , m2 ); S1 and S2 produce the equivalent I/O sequence; 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) i ,  )) from (S , m ( )) from (S1 , m1 (1 )), (S2 , m2 (loop2 2 2 2 2i c where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 ( n ) = i . 2 c · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 1i (x) = 2i (x). · Values of the I/O sequence variable in value stores 1i and 2i , 1i (idIO )  2i (idIO ); i 3. There are reachable configurations (S1 , m1 (loop1 c , 1i )) from 2i (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) 2i = loopc (n2 ) = i. · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 1i (x) = 2i (x). · Values of the I/O sequence variable in value stores 1i and 2i are equivalent, 1i (idIO )  2i (idIO );

By hypothesis IH, there is no configuration where loop counters of S1 and S2 are of value i + 1 when any of the following holds: 1. Loop counters for S1 and S2 are always less than i if any is  1  2 1 present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))     1 1 2 (S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , 2 ))   2 2 (S2 , m 2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the equivalent I/O sequence, and have equivalent computation of used/defined variables in both S1 and S2 and the input sequence variable, , the I/O sequence variable, (S1 , m1 ) H (S2 , m2 ) and (S1 , m1 ) O (S2 , m2 ) and x  (Def(S1 )  Def(S2 ))  {idI } : (S1 , m1 ) x (S2 , m2 ); S1 and S2 produce , and the I/O sequence variable; 2. The loop counter of S1 and S2 are of value less than or equal to i i, and there are no reachable configurations (S1 , m1 (loop1 c , 1i )) i ,  )) from (S , m ( )) from (S1 , m1 (1 )), (S2 , m2 (loop2 2 2 2 2 i c where all of the following hold: i · The loop counters of S1 and S2 are of value i, loop1 c (n1 ) i (n ) = i. = loop2 2 c · Value stores 1i and 2i agree on values of used variables in both S1 and S2 as well as the input sequence variable, x  (Use(S1 )  Use(S2 ))  {idI , , idIO } : 1i (x) = 2i (x). · Values of the I/O sequence variable in value stores 1i and 2i are equivalent, 1i (idIO )  2i (idIO );
i When there are reachable configurations (S1 , m1 (loop1 c , 1i )) i )) from ( S , m from (S1 , m1 (1 )), (S2 , m2 (loop2 ,  2 2 (2 )) 2i c where all of the following hold: i · The loop counter of S1 and S2 are of value i, loop1 c (n1 ) i = loop2 c (n2 ) = i.

1: 2: If (a > 0) then 3: b := c + 1 4: output b + c old

1': b := 2 2': If (a > 0) then 3': b := c + 1 4': output b + c new

Figure 18: Missing initialization
i+1 · The loop counter of S1 and S2 are of value i, loop1 (n1 ) c i+1 · The loop counter of S1 and S2 are of value i, loop1 (, n1 ) c i+1 = loop2 (n2 ) = i. c

i+1 = loop2 (, n2 ) = i. c · Value stores 1i+1 and 2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 1i+1 (x) = 2i+1 (x); · Values of the I/O sequence variable in value stores 1i+1 and 2i+1 are equivalent, 1i+1 (idIO )  2i+1 (idIO );

6.6 Proof rule for missing variable initializations A kind of bugfix we call missing-initialization includes variable initialization for those in the imported variables relative to the I/O sequence variable in the old program. Figure 18 shows an example of missing-initializations. The initialization b := 2 ensures the value used in "output b + c" is not to be undefined. In general, new variable initializations only affect rare buggy executions of the old program, where there are uses of undefined imported variables relative to the I/O sequence variable in the program. Because DSU is not starting in error state, we assume that, in the proof of backward compatibility, there are no uses of variables with undefined variables in executions of the old program. The following is the definition of the update class "missing initializations". Definition 32. (Missing initializations) A statement sequence S2 includes updates of missing initializations compared with a statement sequence S1 , written S2 S Init S1 , iff S2 = SInit ; S1 where SInit is a sequence of assignment statements of form "lval := v " and Def(SInit )  Imp(S1 , {idIO }); Though the bugfix in the update of missing initializations are not in rare execution in the first case in Definition 32, the definition shows the basic form of bugfix clearly. We show that two statement sequences terminate in the same way, produce the same output sequence, and have equivalent computation of defined variables in both programs in valid executions if there are updates of missing initializations between them. Lemma 6.14. Let S1 and S2 be two statement sequences respectively where there are updates of "missing initializations" in S2 compared with S1 , S2 S Init S1 . If S1 and S2 start in states m1 (1 ) and m2 (2 ) respectively such that both of the following hold:
· Value stores 1 and 2 agree on values of variables used in both

in both S1 and S2 as well as the input sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 1i (x) = 2i (x). · Values of the I/O sequence variable in value stores 1i and 2i are equivalent, 1i (idIO )  2i (idIO );

· Value stores 1i and 2i agree on values of used variables

By similar argument in base case, we have one of the following holds: 1. Loop counters for S1 and S2 are always less than i + 1 if any  1 2  1 is present, m 1 (loopc ) m2 (loopc ) : (S1 , m1 (loopc , 1 ))      1 1 2 (S1 , m 1 (loopc )), loopc (n1 ) < i +1, (S2 , m2 (loopc , 2 ))    2 2 (S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the same way, produce the equivalent I/O sequence, and have equivalent computation of defined variables in both S1 and S2 and the input sequence variable, (S1 , m1 ) H (S2 , m2 ) and x  (Def(S ))  {idI } : (S1 , m1 ) x (S2 , m2 ); 2. The loop counter of S1 and S2 are of value less than or equal to i + 1, and there are no reachable configurations 2i i (S1 , m1 (loop1 c , 1i )) from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i )) from (S2 , m2 (2 )) where all of the following hold: i+1 · The loop counters of S1 and S2 are of value i, loop1 (n1 ) c i+1 (n ) = i + 1. = loop2 2 c · Value stores 1i+1 and 2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable, x  (Use(S1 )  Use(S2 ))  {idI } : 1i+1 (x) = 2i+1 (x). · Values of the I/O sequence variable in value stores 1i+1 and 2i+1 are equivalent, 1i+1 (idIO )  2i+1 (idIO ); 1i+1 3. There are reachable configurations (S1 , m1 (loopc , 1i+1 )) 2i+1 from (S1 , m1 (1 )), (S2 , m2 (loopc , 2i+1 )) from (S2 , m2 (2 )) where all of the following hold:

S1 and S2 as well as the input sequence variable and the I/O sequence variable, id  (Use(S1 )  Use(S2 )) {idI , idIO } : 1 (id) = 2 (id); · defined variables in SInit are of undefined value in value stores 1 , 2 , id  Def(SInit ) : 1 (id) = 2 (id) = Udf  where  is the type of the variable id; · There are no use of variables with undefined values in the execution of S1 ; · There are no crash in execution of SInit ;

65

2015/9/14

then S1 and S2 terminate in the same way, produce the same output sequence, and when S1 and S2 both terminate, they have equivalent computation of used variables and defined variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable,
· (S1 , m 1 )  H (S2 , m 2 ); · (S1 , m 1 )  O (S2 , m 2 ); · x  (Def(S1 )  Def(S2 ))  {idI , idIO } : (S1 , m1 ) x

7. Related Work
We discuss related work on DSU safety and program equivalence in order. Existing studies on DSU safety could be roughly divided into high level studies and low level ones. There are a few studies on high level DSU safety. In [19], Kramer and Magee defined the DSU correctness that the updated system shall "operate as normal instead of progressing to an error state". This is covered by our requirement that hybrid executions conform to the old program's specification and our accommodation for bug fixes. Moreover, our backward compatibility includes I/O behavior, which is more concrete than the behavior in [19]. In [9], Bloom and Day proposed a DSU correctness which allows functionality extension that could not produce past behavior. This is probably because Bloom and Day considered updated environment. On the contrary, we assume that the environment is not updated. In addition, we explicitly present the error state, which is not mentioned in [9]. Panzica La Manna [28] presented a high level correctness only considering scenario-based specifications for controller systems instead of general programs. There are also studies on low level DSU safety. Hayden et al. [15] discussed DSU correctness and concluded that there is only client-oriented correctness. Zhang et al. [32] asked the developers to ensure DSU correctness. Magill et al. [24] did ad-hoc program correlation without definitions of any correctness. We consider that there is general principle of DSU safety. The difference lies at the abstraction of the program behavior. We model program behavior by concrete I/O while others [15, 24, 32] consider a general program behavior. We next discuss existing work on program equivalence. There is a rich literature on program equivalence and we compare our work only with most related work. Our study of program equivalence is inspired by original work of Horwitz et al. [17] on program dependence graphs, but we take a much more formal approach and we consider terminating as well as non-terminating programs with recurring I/O. In [13], Godlin and Strichman have a structured study of program equivalence similar to that of ours. Godlin and Strichman [13] restricted the equivalence to corresponding functions and therefore weakens the applicability to general transformations affecting loops such as loop fission, loop fusion and loop invariant code motion. However, our program equivalence allows loop optimizations such as loop fusion and loop fission. Furthermore, our syntactic conditions imply more program point mapping because we allow corresponding program point in arbitrary nested statements and in the middle of program that does not include function call.

(S2 , m 2 );

Proof. By induction on the sum of the program size of S1 and S2 , size(S1 ) + size(S2 ). Base case. S1 = s and S2 = SInit ; s where SInit = "lval := v " and Def(lval)  Use(s); There are cases regarding lval in SInit . 1. lval = id. Then the execution of S2 proceeds as follows. (id := v ; s, m2 (2 )) (skip; s, m2 (2 [v/(id)])) by the rule As-Scl (s, m2 (2 [v/(id)])) by the rule Seq. By assumption, id  Use(e). By assumption, the value of id is undefined in value store 1 . Then there is no valid execution of S1 . Then it holds that, in valid executions of S1 , S1 and S2 terminate in the same way, produce the same output sequence, and have equivalent computation of defined variables in both S1 and S2 . Then this lemma holds. 2. lval = id[n]. Then the execution of S2 proceeds as follows. (id[n] := v ; s, m2 (2 )) (skip; s, m2 (2 [v/(id, n)])) by the rule As-Err (s, m2 (2 [v/(id, n)])) by the rule Seq. By similar argument above, this lemma holds. 3. lval = id1 [id2 ]. Then the execution of S2 proceeds as follows. (id1 [id2 ] := v ; s, m2 (2 )) (id1 [v1 ] := v ; s, m2 (2 [v/(id, n)])) by the rule Var (skip; s, m2 (2 [v/(id, v1 )])) by the rule As-Arr. (s, m2 (2 [v/(id, v1 )])) by the rule Seq. By similar argument above, this lemma holds. Induction step. The hypothesis is that this lemma holds when the sum k of the program size of S1 and S2 are great than or equal to 3, k  3. We then show that this lemma holds when the sum of the program size of S1 and S2 is k + 1. S2 = SInit ; S1 where SInit is a sequence of assignment statements and Def(SInit )  Imp(S1 , {idIO }); The proof is similar to that in the base case. By assump tion, the execution of SInit does not crash, (SInit , m2 (2 ))    (skip, m2 (2 )) where 2 = 2 [v1 /x1 ]...[vk /xk ] and 1  i  k : xk  Def(SInit ). By assumption, there are no use of variables with undefined values in the execution of S1 by Theorem 5 and Theorem 4, this lemma holds.

8. Conclusion
In this paper, we propose a formal and practical general definition of DSU correction based on I/O sequences, backward compatibility. We devised a formal language and adapt the general definition of DSU correctness for executable programs based on our language. Based on the adapted backward compatibility, we proposed syntactic conditions that help guarantee correct DSUs for both terminating and nonterminating executions. In addition, we formalize typical program updates that are provably backward compatible, covering both new feature and bugfix. In the future, we plan to identify more backward compatible update patterns by studying more open source programs. Though it is dubious if open source programs' evolution history includes typical update patterns, open source programs are the most important source of widely-used programs for our study of DSU. In addition, we plan to develop an algorithm for automatic state mapping based on our syntactic condition of program equivalence and definition of update classes.

66

2015/9/14

References
[1] Software Engineering - Software Life Cycle Processes - Maintenance. Technical Report ISO/IEC 14764:2006(E). 2.4 [2] Openssh users. http://www.openssh.com/users.html , 2015. [Online; accessed 15-Jan-2015]. 3 [3] Vsftpd wikipage. http://en.wikipedia.org/wiki/Vsftpd , 2015. [Online; accessed 15-Jan-2015]. 3 [4] A. V. Aho, R. Sethi, and J. D. Ullman. Compilers: Principles, Techniques, and Tools. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 1986. 5.2.1 [5] J. Arnold and M. F. Kaashoek. KSplice: Automatic Rebootless Kernel Updates. In EuroSys 2009, April 2009. 1 [6] N. Benton. Simple relational correctness proofs for static analyses and program transformations. SIGPLAN Not., 39(1):14­25, Jan. 2004. 1 [7] D. Binkley, S. Horwitz, and T. Reps. The multi-procedure equivalence theorem. Technical report, 1989. 1 [8] S. Blazy and X. Leroy. Mechanized semantics for the clight subset of the c language. Journal of Automated Reasoning, 43(3), 2009. 4.2 [9] T. Bloom and M. Day. Reconfiguration and module replacement in argus: theory and practice. Software Engineering Journal, Mar 1993. 1, 7 [10] L. Cardelli. Type systems. ACM Computing Surveys, 28(1):263­264, 1996. A [11] R. Cartwright and M. Felleisen. The semantics of program dependence. SIGPLAN Not., 24(7):13­27, 1989. 1 [12] W. Dietz, P. Li, J. Regehr, and V. Adve. Understanding integer overflow in c/c++. ICSE 2012, pages 760­770, 2012. 2 [13] B. Godlin and O. Strichman. Inference rules for proving the equivalence of recursive procedures. Acta Informatica, 45(6):403­439, 2008. 1, 7 [14] A. D. Gordon. Functional programming and input/output. Number 8. Cambridge University Press, 1994. 4.1, 4.2 [15] C. M. Hayden, S. Magill, M. Hicks, N. Foster, and J. S. Foster. Specifying and verifying the correctness of dynamic software updates. VSTTE '12, pages 278­293, Jan. 2012. 1, 7 [16] M. Hicks. Dynamic Software Updating. PhD thesis, University of Pennsylvania, August 2001. 1 [17] S. Horwitz, J. Prins, and T. Reps. On the adequacy of program dependence graphs for representing programs. POPL '88, pages 146­ 157. ACM, 1988. 1, 7 [18] C. Karfa, K. Banerjee, D. Sarkar, and C. Mandal. Verification of loop and arithmetic transformations of array-intensive behaviors. Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on, 32(11):1787­1800, Nov 2013. 1 [19] J. Kramer and J. Magee. The evolving philosophers problem: dynamic change management. Software Engineering, IEEE Transactions on, 16, Nov 1990. 1, 7 [20] S. Kundu, Z. Tatlock, and S. Lerner. Proving optimizations correct using parameterized program equivalence. SIGPLAN Not., 44(6). 1 [21] D. Lacey, N. D. Jones, E. Van Wyk, and C. C. Frederiksen. Proving correctness of compiler optimizations by temporal logic. SIGPLAN Not., 37(1):283­294, Jan. 2002. ISSN 0362-1340. 1 [22] Y.-F. Lee and R.-C. Chang. Hotswapping linux kernel modules. Journal of Systems and Software, 79(2):163­175, February 2006. 1 [23] D. Lucanu and V. Rusu. Program equivalence by circular reasoning. In Integrated Formal Methods, volume 7940 of Lecture Notes in Computer Science, pages 362­377. Springer Berlin Heidelberg, 2013. 1 [24] S. Magill, M. Hicks, S. Subramanian, and K. S. McKinley. Automating object transformations for dynamic software updating. SIGPLAN Not., 47(10):265­280, Oct. 2012. 1, 7 [25] K. Makris. Whole-Program Dynamic Software Updating. PhD thesis, Arizona State University, December 2009. 1, 3

[26] K. Makris and R. A. Bazzi. Immediate Multi-Threaded Dynamic Software Updates Using Stack Reconstruction. In Proceedings of the USENIX '09 Annual Technical Conference, June 2009. 3 [27] I. Neamtiu. Practical Dynamic Software Updating. University of Maryland, August 2008. 3 PhD thesis,

[28] V. Panzica La Manna, J. Greenyer, C. Ghezzi, and C. Brenner. Formalizing correctness criteria of dynamic updates derived from specification changes. SEAMS '13, pages 63­72, 2013. 1, 7 [29] D. L. Parnas. Software aging. ICSE '94, Los Alamitos, CA, USA. IEEE Computer Society Press. 2.4 [30] B. C. Pierce. Types and programming languages. MIT press, 2002. 4.2 [31] S. Verdoolaege, G. Janssens, and M. Bruynooghe. Equivalence checking of static affine programs using widening to handle recurrences. ACM Trans. Program. Lang. Syst., 34(3):11:1­11:35, Nov. 2012. 1 [32] M. Zhang, K. Ogata, and K. Futatsugi. Formalization and verification of behavioral correctness of dynamic software updates. Electronic Notes in Theoretical Computer Science, 294:12 ­ 23, 2013. 1, 7

A. Type system
Figure 19 shows an almost standard unsound and incomplete type system. The type system is unsound because of three reasons, (a) the possible value mismatch due to the subtype rule from hte type Int to Long, (b) the implicit subtype between enumeration types and the type Long allowed by our semantics and (c) the possible array index out of bound. The type system is incomplete due to the parameterized "other" expressions. The notation Dom() borrowed from Cardelli [10] in rules Tvar1, Tvar2, Tlabels an Tfundecl refers to the domain of the typing environment , which are identifiers bound to a type in .

B. Syntactic definitions
The syntax-directed definitions listed below make our argument independent of existing program analysis partially. Definition 33. (Idx(lval)) The used variables in index of a left value lval, written Idx(lval), are listed as follows: 1. Idx(id) = ; 2. Idx(id[n]) = ; 3. Idx(id1 [id2 ]) = {id2 };

Definition 34. (Base(lval)) The base of a left value lval, written Base(lval), is listed as follows: 1. Base(id) = {id}; 2. Base(id[n]) = {id}; 3. Base(id1 [id2 ]) = {id1 };

Definition 35. (Use(e)) The set of used variables in an expression e, written Use(e), are listed as follows: 1. Use(lval) = Base(lval)  Idx(lval); 2. Use(id == l) = {id}; 3. Use(other) = Use(other ) where function Use : other  {id} is parameterized; Definition 36. (Use(S )) The used variables in a sequence of statements S , written Use(S ), are listed as follows: 1. 2. 3. 4. 5. 6. Use(skip) = ; Use(lval := e) = Use(e)  Idx(lval); Use(output e) = Use(e)  {idIO }; Use(input id) = {idI , idIO }; Use(If (e) then {St } else {Sf }) = Use(e)Use(St )Use(Sf ); Use(while n (e){S  }) = Use(e)  Use(S  );
2015/9/14

67

TInit




Definition 38. (s  S ) We say a statement s is in a sequence of statements S of a program P , written s  S , if one of the following holds:
(Tlabels)  k1 id  / Dom() EN = EN  , enum id{l1 , ..., lk } , id : {l1 , ..., lk }   pmpt  / Dom()

   (Tvar1)  V = V  ,  id id  / Dom() , id :    (Tprompt)  P mpt = {l1 : n1 , . . . , lk : nk } (Tvar2)  id  / Dom() V = V  ,  id[n] n>0 , id : array(, n)  

1. 2. 3. 4.

S = s; If S = "If(e) then {St } else {Sf }", (s  St )  (s  Sf ); If S = "while(e) {S  }", s  S  ; For k > 0, if S = s1 ; ...; sk ; sk+1 , (s  sk+1 )  (s  s1 ; ...; sk );

, pmpt : {l1 : n1 , . . . , lk : nk }  

We write s  / S if s  S does not hold. We show the definition of program size, which is based of our induction proof. Definition 39. (size(S )) The program size of a statement sequence S , written size(S ), is listed as follows: 1. size("skip") = size("id := e") = size("id1 := call id2 (e )") = size("input id") = size("output e") = 1; 2. size("If(e) then {St } else {Sf }") = 1 + size(St ) + size(Sf ); 3. size("while(e) {S  }") = 1 + size(S  );
k

(Tint)    Int



(Tlong)    Long

(Tenum)   id : {l1 , ..., lk }   enum id

4. For k > 0, size(s1 ; ...; sk =
(Topnd)

size(si );
i=1

e:
, id :   id : 

(Tequiv)   id : {l1 , ..., l, ..., lk }   id : enum id   (id == l) : Long (Tarray2)   id : array(, n) 1kn   id[k] : 

(TSub)   e : Int   e : Long

C. Properties of imported variables
Lemma C.1. Imp(S1 ; S2 , X ) = Imp(S1 , Imp(S2 , X )). Proof. Let statement sequence S2 = s1 ; s2 ; ...; sk for some k > 0. The proof is by induction on k. Corollary C.1. i  Z+ , Imp(S i+1 , X ) = Imp(S, Imp(S i , X )). This is by lemma C.1.

(Tarray1)   id : array(, n)   id : Long   id[id ] :  S (Tassign)   lval :  e:   lval := e (Tif)

(Tinput)   id :   = pmpt   input id

(Toutput) e:   output e (Twhile)   e : Long,   S   while(e){S }

(Tseq)   S1   S2   S1 ; S2

Lemma C.2. Imp(S, A  B ) = Imp(S, A)  Imp(S, B ). Proof. By structural induction on abstract syntax of statement sequence S . Lemma C.3. For statement s = "while(e){S }" and a set of finite number of variables X such that X  Def (s) = , there is  > 0 such that 0i( +1) Imp (S i , X )  1j  Imp(S j , X ). Proof. By contradiction against the fact that is finite number of variables redefined in statement s.

  e : Long   S1   S2   If(e) then {S1 } else {S2 } P (Tprog)

P mpt = {l1 : n1 , ..., lk : nk }  EN = enum id1 {l1 , ..., lr }, ..., enum idk {l 1 , ..., lr }      enum idi , 1  i  k V = 1 id 1 , ..., k idk [n]      id   id j : j , 1  j  k - 1 k : array(k , n)   Sentry   P mpt; EN ; V ; Sentry

D. Properties of expression evaluation
We wrap the two properties of expression evaluation, which is based on the two properties of "other" expression evaluation. In the following, we use the notation E  to expand the domain of the expression meaning function E  : e    (verror , {0, 1}).

Figure 19: Typing rules

7. For k > 0, Use(s1 ; ...; sk+1 ) = Use(s1 ; ...; sk )  Use(sk+1 ); Definition 37. (Def(S )) The defined variables in a sequence of statements S , written Def(S ), are listed as follows: 1. 2. 3. 4. 5. 6. 7. Def(skip) = ; Def(id := e) = {id}; Def(input id) = {idI , idIO , id}; Def(output e) = {idIO }; Def(If (e) then {St } else {Sf }) = Def(St )  Def(Sf ); Def(while n (e){S }) = Def(S ); For k > 0, Def(s1 ; ...; sk+1 ) = Def(s1 ; ...; sk )  Def(sk+1 );

Lemma D.1. If every variable in Use(e) of an expression e has the same value w.r.t two value stores, the expression e evaluates to same value against the two value stores, (x  Use(e) : 1 (x) = 2 (x))  (E  e 1 = E  e 2 ). Proof. The proof is a case analysis of the expression e. 1. e = lval; There are further cases regarding lval. (a) lval = id; By definition, Use(e) = {id}. Besides, there is no integer overflow in both evaluations. The lemma holds trivially. (b) lval = id[n]; By definition, Use(e) = {id}. Because the array has fixed size, by assumption, 1 (id, n) = 2 (id, n) or (id, n, )  / 1 , (id, n, )  / 2 . Besides, there is no integer overflow in both evaluations. The lemma holds.

68

2015/9/14

(c) lval = id1 [id2 ]; By definition, Use(e) = {id1 , id2 }. By assumption, 1 (id2 ) = 2 (id2 ) = n By similar argument to the case lval = id[n], the lemma holds. 2. e = "id == l"; By definition, Use(e) = {id}. W.l.o.g, id is a global variable. By assumption, 1 (id) = 2 (id) = l . If l = l, by rule Eq-T, (l == l, m( ))  (1, m). If l = l, by rule EqF, (l == l, m( ))  (0, m). Besides, there is no integer overflow in both evaluations. The lemma holds. 3. e = other; By definition, Use(e) = Use(e). By assumption, x  Use(e) : 1 (x) = 2 (x)  1 (x) = 2 (x). The lemma holds by parameterized expression meaning function for "other" expression.

(r, m)  (r  , m )
E  : e    (verror × {0, 1}) f=0 (e, m(f, ))  (E  e , m)

EEval'

Figure 20: An extended SOS rule for expressions

Lemma D.2. If every variable in Err(e) of an expression e has same value w.r.t two pairs of (block, value store), x  Err(e) : 1 (x) = 2 (x) then one of the following holds: 1. the expression evaluates to crash against the two value stores, (E  e 1 = (error, vof ))  (E  e 2 = (error, vof )); 2. the expression evaluates to no crash against the two pairs of 1 (block, value store) (E  e 1 = (error, vof ))  (E  e 2 = 2 (error, vof )). Proof. The proof is a case analysis of the expression e. 1. e = lval; There are further cases regarding lval. (a) lval = id; By definition, Err(e) = Idx(e) = . By our semantic, the evaluation of id never crash. Besides, there is no integer overflow in both evaluations. The lemma holds. (b) lval = id[n]; By definition, Err(e) = Idx(e) = . Because the array id1 has a fixed array size, by assumption, either ((id1 , n, v1 )  1 )  ((id1 , n, v2 )  2 ) or ((id1 , n, v1 )  / 1 )  ((id1 , n, v2 )  / 2 ). Besides, there is no integer overflow in both evaluations. The lemma holds. (c) lval = id1 [id2 ] By definition, Err(e) = Idx(e) = {id2 }. By assumption, 1 (id2 ) = 2 (id2 ) = n or 1 (id2 ) = 2 (id2 ) = n. By similar argument to the case lval = id[n], the lemma holds. 2. e = "id == l"; By definition, Err(e) = . W.l.o.g, id is a global variable. Let 1 (id) = l1 , 2 (id) = l2 . W.l.o.g., l1 = l and l2 = l, by rule Eq-T, (l1 == l, m( ))  (1, m) and, by rule EqF, (l2 == l, m( ))  (0, m). Besides, there is no integer overflow in both evaluations. The lemma holds. 3. e = other; By definition, Err(e) = Err(e). By assumption, x  Err(e) : 1 (x) = 2 (x). The lemma holds by the property of parameterized expression meaning function for "other" expression.

With respect to Lemma D.1 and Lemma D.2, we extend semantic rule for expression evaluation as follows.

E. Properties of remaining execution
We assume that crash flag f = 0 in given execution state m(f).
  Lemma E.1. (S1 , m)  (S1 , m  )  (S1 ; S2 , m )  (S1 ; S2 , m  ).

Proof. The proof is by structural induction on abstract syntax of S1 . Case 1. S1 = "skip". By rule Seq, (skip; S2 , m)  (S2 , m) where m = m . Case 2. S1 = "id := e". There are two subcases.  Case 2.1. (e, m)  (v, m) for some value v . By rule Assign, (id := v, m)  (skip, m( [v/x])). Then, by contextual (semantic) rule, (id := v ; S2 , m)  (skip; S2 , m( [v/x])).  Case 2.2. (e, m)  (e , m(1/f)) for some expression e . Then, by rule crash, (id := e , m(1/f))  (id := e , m(1/f)). Then, by contextual rule, (id := e ; S2 , m(1/f))  (id := e ; S2 , m(1/f)). Case 3. S1 = "output e" Case 4. S1 = "input id" By similar argument in Case 2, the lemma holds for case 3 and 4. Case 5. S1 = "If (e) then {St } else {Sf }". Case 5.1. W.l.o.g., expression e in predicate of S1 evaluates to  nonzero in state m, written (e, m)  (0, m). By rule If-T, (If (0) then {St } else {Sf }, m)  (St , m). By contextual (semantic) rule, (If (0) then {St } else {Sf }; S2 , m)  (St ; S2 , m). Case 5.2. Evaluation of expression e in predicate of S1 crashes,  written (e, m)  (e , m(1/f)). Then, by rule crash, (If (e ) then {St } else {Sf }, m(1/f))  (If (e ) then {St } else {Sf }, m(1/f)). Then, by contextual rule, (If (e ) then {St } else {Sf }; S2 , m(1/f))  (If (e ) then {St } else {Sf }; S2 , m(1/f)). Case 6. S1 = "while n (e) {S }". Case 6.1 When expression e in predicate of S1 evaluates to  nonzero value, written (e, m)  (v, m) for some v = 0, then, by rule Wh-T, (while n (e){S }, m)  (S ; while n (e){S }, m(mc [(k + 1)/n])) for some nonnegative integer k. Then, by contextual rule, (while n (e) {S }; S2 , m)  (S ; while n (e) {S }; S2 , m(mc [(k + 1)/n])). Case 6.2 When expression e in predicate of S1 evaluates to  zero, written (e, m)  (0, m), then, by rule Wh-F, (while n (e){S }, m)  (skip, m(mc [0/n])). By contextual rule, (while n (e) {S }; S2 , m)  (skip; S2 , m(mc [0/n])). Case 6.3 Evaluation of expression e in predicate of S1 crashes,  written (e, m)  (e , m). By rule crash, (while n (e ){S }, m(1/f))  (while n (e ){S }, m(1/f)). Then, by contextual rule,

69

2015/9/14

(while (while

n n

(e ){S }; S2 , m(1/f))  (e ){S }; S2 , m(1/f)).
 

  Lemma E.2. (S1 , m)  (S1 , m  )  (S1 ; S2 , m )  (S1 ; S2 , m  ).

Proof. By induction on number of steps k in execution (S1 , m)   (S1 , m  ). Base case. k = 0 and 1. By definition, 0 0 (S1 , m)  (S1 , m), and (S1 ; S2 , m)  (S1 ; S2 , m). By lemma E.1,   (S1 , m )  (S1 , m  )  (S1 ; S2 , m )  (S1 ; S2 , m  ). Induction step. The induction hypothesis IH is that, for k  1, k k   (S1 , m )  (S1 , m  )  (S1 ; S2 , m )  (S1 ; S2 , m  ). Then we show that, k+1 k+1   (S1 , m )  (S1 , m  )  (S1 ; S2 , m )  (S1 ; S2 , m  ). We decompose the k+1 step execution into k   (S1 , m )  (S1 , m )  (S1 , m  ). By lemma E.1,  (S1 ; S2 , m )  (S1 ; S2 , m ). Next, by IH, k   (S1 ; S2 , m )  (S1 ; S2 , m  ). Corollary E.1. (S1 , m)  (skip, m )  (S1 ; S2 , m)  (S2 , m  ). Proof. By lemma E.2,   (S1 , m)  (skip, m )  (S1 ; S2 , m)  (skip; S2 , m ). Then, by rule Seq, (skip; S2 , m )  (S2 , m ). Lemma E.3. If one statement s is not in S , then, after one step of execution (S, m)  (S  , m ), s is not in the S  , (s  / S)  ((S, m)  (S  , m ))  (s  / S  ). Proof. By induction on abstract syntax of S . Lemma E.4. If one statement s is not in S , then, after the execution   (S, m)  (S  , m ), s is not in the S  , (s  / S )  ((S, m)     (S , m ))  (s  / S ). Proof. By induction on the number k of the steps in the execution k (S, m)  (S  , m ). Lemma E.5. If a variable x is not defined in a statement sequence S , then, after one step execution of S , the value of x is not redefined, (x  / Def(S ))  ((S, m( ))  (S  , m (  )))  (x  / Def(S  ))   ( (x) =  (x)) Proof. By structural induction on abstract syntax of statement sequence S , we show the lemma holds. Case 1. S = "id := e". By definition, Def(S ) = {id}. Then id = x by condition that x / Def (S ). Then there are two subcases. Case 1.1 Expression e evaluates to some value v , written  (e, m)  (v, m). Then, by rule Assign, (S, m( ))  (skip, m( [v/id])) where m = m( [v/id]). Hence,   (x) =  (x). Besides, x  / Def (skip) by definition.  Case 1.2 Evaluation of expression e crashes, written (e, m)   (e , m(1/f)). Then, by rule crash,
 

k

(id := e , m(1/f,  ))  (id := e , m(1/f,  )) where m = m(1/f,  ). Hence,   (x) =  (x). Besides, x  / Def(id := e ) by definition. Case 2. S = " output e". Case 3. S = " input id". By similar argument in case 1. Case 4. S = "If (e) then {St } else {Sf }". Def (S ) = Def (Sf )  Def (St ) by definition. Then x  / Def (Sf )  Def (St ). There are two subcases. Case 4.1 W.l.o.g., expression e in predicate of S evaluates to  nonzero value, written (e, m)  (v, m) where v = 0. Then by rule If-T, (If (v ) then {St } else {Sf }, m( ))  (St , m( )) where m = m. Therefore,   (x) =  (x). By argument above, x  / Def (St ). Case 4.2 Evaluation of expression e in predicate of S crashes,  written (e, m)  (e , m(1/f)). Then, by rule crash, (If (e ) then {St } else {Sf }, m(1/f,  ))  (If (e ) then {St } else {Sf }, m(1/f,  )) where m = m(1/f,  ). Therefore,   (x) =  (x). Besides, x  / Def (If (e ) then {St } else {Sf }) = Def (Sf )  Def (St ). Case 5. S = "while n (e) {S  }". Def (S ) = Def (S  ) by definition. Then x  / Def (S  ) by condition x  / Def (S ). There are subcases. Case 5.1 Expression e evaluates to nonzero value, written  (e, m)  (v, m) where v = 0. By rule Wh-T, (while n (v ) {S  }, m( ))  (S  ; while n (e) {S  }, m(mc [(k + 1)/n]),  ) for some nonnegative integer k. Let m = m(mc [(k + 1)/n],  ). Then   (x) =  (x). Besides, x  / Def (S  ; while n (e) {S  }) = Def (S  )  Def (S ), because x  / Def (S  ). Case 5.2 Expression e evaluates to zero in state m, written  (e, m)  (0, m). By rule Wh-F, (while n (0) {S  }, m( ))  (skip, m(mc [0/n],  )) where  m = m(mc [0/n],  ). Therefore,   (x) =  (x). Besides, x  / Def (skip).  Case 5.3 Evaluation of expression e crashes, written (e, m)   (e , m(1/f)). By rule crash (while n (e ) {S  }, m(1/f,  ))  (while n (e ) {S  }, m(1/f,  )) where m = m(1/f,  ). Therefore,   (x) =  (x). Besides, x  / Def(while n (e ) {S  })  = Def (S ) by definition. Case 6. S = S1 ; S2 . By argument in Case 1 to 5, after one step execution ((S1 , m( ))  (S  , m ( ))),   (x) =  (x). By contextual rule, the lemma holds.

Corollary E.2. If a variable x is not defined in a statement sequence S , then, after an execution of S , the value of x is not re defined, (x  / Def(S )  (S, m( ))  (S  , m (  ))  (x  /   Def(S ))   (x) =  (x)). Proof. Let (S, m)  (S  , m ). The proof is by induction on k using lemma E.5.
k

70

2015/9/14

Based on Corollary E.2, we extend the result to array variable elements. Corollary E.3. If an element in an array variable x[i] is not defined in a statement sequence S in a program P = EN ; V ; Sentry , then, after an execution of S , the value of x[i] is not redefined,  (x  / Def(S ))  ((x, i, )   )  (S, m( ))  (S  , m (  ))    (x  / Def(S ))   (x, i) =  (x, i)). Lemma E.6. If all of the following hold: 1. There is no loop of label n in statements S , "while n (e){S  }"  / S; 2. The crash flag is not set, f = 0; 3. There is an entry n in loop counter, (n, )  loopc ; 4. There is one step execution, (S, m(f, loopc ))  (S  , m (loop c ));

then, loop c (n) = loopc (n).

Proof. The proof is by induction on abstract syntax of S , similar to that for lemma E.5. Corollary E.4. If all of the following hold: 1. There is no loop of label n in statements S , "while n (e){S  }"  / S; 2. The crash flag is not set, f = 0; 3. There is an entry n in loop counter, (n, )  loopc ; 4. There is multiple steps execution of stack depth d = 0,  (S, m(f, loopc ))  (S  , m (loop c ));

then, loop c (n) = loopc (n).

Lemma E.7. If all of the following hold: 1. A non-skip statement s is not in S , (s = skip)  (s  / S ); 2. There is one step execution of stack depth d = 0, (S, m)  (S  , m  ), then, s  / S. Proof. By structural induction on abstract syntax of statement sequence S , we show the lemma holds. Case 1. S = "id := e". Then there are two subcases. Case 1.1 Expression e evaluates to some value v , written  (e, m)  (v, m). Then, by rule Assign, (S, m)  (skip, m( [v/id])). Hence, s  / skip by definition.  Case 1.2 Evaluation of expression e crashes, written (e, m)   (e , m(1/f)). By parameterized type rule TExpr,   e . Then, by type rule TAssign,   id := e . Then, by rule crash, (id := e , m(1/f))  (id := e , m(1/f)). Because   s, then s = id := e . Hence, s  / id := e by definition. Case 2. S = " output e". Case 3. S = " input id". By similar argument in case 1. Case 4. S = "If (e) then {St } else {Sf }". s / Sf , s  / St by definition. There are two subcases. Case 4.1 W.l.o.g., expression e in predicate of S evaluates to  nonzero value, written (e, m)  (v, m) where v = 0. Then by rule If-T, (If (v ) then {St } else {Sf }, m)  (St , m). Therefore, s  / St . Case 4.2 Evaluation of expression e in predicate of S crashes,  written (e, m)  (e , m(1/f)). Then, by rule crash,

(If (e ) then {St } else {Sf }, m(1/f))  (If (e ) then {St } else {Sf }, m(1/f)). By parameterized type rule TExpr,   e . By type rule Tif,   If (e ) then {St } else {Sf }. Because   s, then s = If (e ) then {St } else {Sf }. Besides, s  / St , s  / Sf by condition. Therefore, s  / If (e ) then {St } else {Sf }. Case 5. S = "while n (e) {S  }". s / S  by definition. There are subcases. Case 5.1 Expression e evaluates to nonzero value, written  (e, m)  (v, m) where v = 0. By rule Wh-T, (while n (v ) {S  }, m)  (S  ; while n (e) {S  }, m(mc [(k + 1)/n])) for some nonnegative integer k. Then s  / S  ; while n (e) {S  } by definition. Case 5.2 Expression e evaluates to zero in state m, written  (e, m)  (0, m). By rule Wh-F, (while n (0) {S  }, m)  (skip, m(mc [0/n])). Therefore, s  / skip.  Case 5.3 Evaluation of expression e crashes, written (e, m)   (e , m(1/f)). By rule crash, (while n (e ) {S  }, m(1/f))  (while n (e ) {S  }, m(1/f)). Then, by type rule Twhile,   while n (e ) {S  }. Because   s, then s = while n (e ) {S  }. Besides s  / S  , then s  / while n (e ) {S  } by definition. Case 6. S = S1 ; S2 . By argument in Case 1 to 5, after one step execution (S1 , m)  (S  , m  ), s  / S. By contextual rule, (S1 ; S2 , m)  (S  ; S2 , m ). By definition, s  / S2 . Then, by definition, s  / S  ; S2 Lemma E.8. Let s = "while hold:
n

(e) {S  }". If both of the following

· s  S; · (S, m(loopc ))  (S  , m (loop c ));

then one of the following holds: 1. The loop counter of label n is incremented by one, loop c (n) - loopc (n) = 1; 2. There is no entry for label n in loop counter, (n, v )  / loop c;  3. The loop counter of label n is not changed, loopc (n) - loopc (n) = 0; Proof. Let S = s ; S  . The proof is by induction on abstract syntax of s .

71

2015/9/14


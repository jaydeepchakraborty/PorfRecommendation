arXiv:1503.07235v2 [cs.SE] 10 Sep 2015

A Formal Study on Backward Compatible
Dynamic Software Updates
Jun Shen

Rida A. Bazzi

Arizona State University
jun.shen.1@asu.edu

Arizona State University
bazzi@asu.edu

Abstract

4.1
4.2

We study the dynamic software update problem for programs interacting with an environment that is not necessarily updated. We
argue that such updates should be backward compatible. We propose a general definition of backward compatibility and cases of
backward compatible program update. Based on our detailed study
of real world program evolution, we propose classes of backward
compatible update for interactive programs, which are included at
an average of 32% of all studied program changes. The definitions
of update classes are parameterized by our novel framework of program equivalence, which generalizes existing results on program
equivalence to non-terminating executions. Our study of backward
compatible updates is based on a typed extension of W language.

4.3

5 Program equivalence
5.1 Definitions of execution . . . . . . . . . . . . . .
5.2 Equivalent computation for terminating programs .
5.2.1 Proof rule for equivalent computation for
terminating programs . . . . . . . . . . .
5.2.2 Soundness of the proof rule for equivalent
computation for terminating programs . .
5.2.3 Supporting lemmas for the soundness proof
of equivalent computation for terminating
programs . . . . . . . . . . . . . . . . .
5.3 Termination in the same way . . . . . . . . . . .
5.3.1 Proof rule for termination in the same way
5.3.2 Soundness of the proof rule for termination
in the same way . . . . . . . . . . . . . .
5.3.3 Supporting lemmas for the soundness proof
of termination in the same way . . . . . .
5.4 Behavioral equivalence . . . . . . . . . . . . . .
5.4.1 Proof rule for behavioral equivalence . . .
5.4.2 Soundness of the proof rule for behavioral
equivalence . . . . . . . . . . . . . . . .
5.4.3 Supporting lemmas for the soundness proof
of behavioral equivalence . . . . . . . . .
5.5 Backward compatible DSU based on program
equivalence . . . . . . . . . . . . . . . . . . . .

Categories and Subject Descriptors D.3.1 [Formal Definitions
and Theory]: Semantics, Syntax; D.2.4 [Software/Program Verification]: Correctness Proof, Formal Methods; F.3.2 [Semantics of
Programming Languages]: Operational Semantics, Program Analysis; D.3.3 [Language Constructs and Features]: Input/output,
Procedures, functions, and subroutines
General Terms

Theory

Keywords dynamic software update, backward compatibility,
program equivalence, proof rule, operational semantic

Contents
1 Introduction
2 Backward compatibility
2.1 Programs and Specifications . . . . . . . . . . .
2.2 Hybrid executions and state mapping . . . . . .
2.3 Backward compatibility . . . . . . . . . . . . .
2.4 Backward compatible program behavior changes

2
.
.
.
.

3 Real world backward compatible update classes: brief
description
3.1 Observational equivalence: the old behavior . . . .
3.2 Enum. type extension: old behavior for old input
and allowing new input . . . . . . . . . . . . . .
3.3 Variable type weakening: more output when the old
program terminates . . . . . . . . . . . . . . . .
3.4 Exit on errors: stopping execution while the old
program produces more output . . . . . . . . . .
3.5 Improved prompt messages: functionally equivalent outputs . . . . . . . . . . . . . . . . . . . .
3.6 Missing variable initialization: enforcing restrictions on program states . . . . . . . . . . . . . .
4 Formal programming language

Syntax of the formal language . . . . . . . . . . .
Small-step operational semantics of the formal language . . . . . . . . . . . . . . . . . . . . . . .
Preliminary terms and notations . . . . . . . . . .

2
2
3
3
4

7
7
9
9
9
9
10
10
14
18
18
19
26
37
37
38
40
45

4
5

6 Real world backward compatible update classes: proof
rules
6.1 Proof rule for specializing new configuration variables . . . . . . . . . . . . . . . . . . . . . . . .
6.2 Proof rule for enumeration type extension . . . . .
6.3 Proof rule for variable type weakening . . . . . .
6.4 Proof rule for exit on errors . . . . . . . . . . . .
6.5 Proof rule for improved prompt message . . . . .
6.6 Proof rule for missing variable initializations . . .

45
50
55
56
61
65

6

7 Related Work

66

6

8 Conclusion

66

6

A Type system

67

6

B Syntactic definitions

67

6

C Properties of imported variables

68

7

D Properties of expression evaluation

68

1

45

2015/9/14

E Properties of remaining execution

alence is enforced on corresponding functions severely limits the
applicability of the work to general transformations affecting loops
such as loop-invariant code motion, loop fission/fusion. So, as a
major component of our formal treatment of backward compatible updates, we set out to develop sufficient conditions for semantic equivalence for programs in a typed extension of the W languages [11] with small-step operational semantics. The syntax of
language is extended with arrays and enumeration types and the
semantics take into consideration the execution environment to allow various classes of updates.
In summary, the paper makes the following contributions:

69

1. Introduction
Dynamic software update (DSU) allows programs to be updated in
the middle of their execution by mapping a state of an old version
of the program to that of a newer version. The ability to update programs without having to restart them is useful for high-availability
applications that cannot afford the downtime incurred by offline updates [16]. DSU has been an active area of research[5, 16, 22, 25]
with much of the published work emphasizing the update mechanism that implements a state mapping which maps the execution
state of an old version of the program to that of a new version.
DSU safety has not yet been successfully studied. Existing studies on DSU safety are lacking in one way or another: high-level
studies are concerned with change management for system components [9, 19] and lower-level studies typically require significant
programmer annotations [15, 24, 32] or have a restricted class of
applications to which they apply (e.g., controller systems [28]).
In this paper, we consider the safety of DSU when applied to
possibly non-terminating programs interacting with an environment that is not necessarily updated. For such updates, the new
version of the program must be able to interact with the old environment, which means that it should be, in some sense, backward
compatible with the old version. A strict definition of backward
compatibility would require the new version to exhibit the same I/O
behavior as the old version; in other words the two programs are observationally equivalent. It should be immediately clear that a more
nuanced definition is needed because observational-equivalence
does not allow changes which one would want to allow as backward compatible such as bug fixes, new functionalities, or usability improvement (e.g., improved user messages). Allowing for such
differences would be needed in any practical definition of backward
compatibility. One contribution of this work is a general definition
of backward compatibility, a classification of common backward
compatible program behavior changes, as well as classes of program change from real world program evolution.
Determining backward compatibility, which allows for differences between two program versions, is requiring one to solve the
semantic equivalence problem which has been extensively studied [6, 13, 17, 18, 20, 21, 23, 31]. Unfortunately, existing results
turned out to be lacking in one or more aspects which rules out
retrofitting them for our setting. In fact, existing work on program
equivalence typically guarantees equivalence at the end of an execution. Such equivalence is not adequate for our purposes because
it does not allow us to express that a point in the middle of a loop
execution of one program corresponds (in a well defined sense) to
a point in the middle of a loop execution of another program. The
ability to express such correspondences is desirable for dynamic
software update. Besides, existing formulations of the program
equivalence problem either do not use formal semantics [7, 17, 18],
only apply to terminating programs [6, 20], severely restrict the
programming model [13, 18, 31], or rely on some form of model
checking [21, 23] (which is not appropriate for non-terminating
programs with infinite states). Our goal for program equivalence
is to establish compile-time conditions ensuring that two programs
have the same I/O behavior in all executions. In particular, if one
program enters an infinite loop and does not produce a certain output, the other program should not produce that output either. This is
different from much of the literature on program equivalence which
only guarantees same behavior in terminating executions.
The closest work that aims to establish program equivalence for
nonterminating programs is that of Godlin and Strichman [13] who
give sufficient conditions for semantic equivalence for a language
that includes recursive functions, but does not allow loops (loops
are extracted as recursive functions). That and the fact that equiv-

1. We formally define backward compatibility and identify cases
of backward compatible program behavior for typical program
update motivation.
2. We identify and formally define classes of program changes
that result in backward compatible program update based on
empirical study of real world program evolution.
3. We give a formal treatment of the semantic equivalence for
nonterminating imperative programs.
The rest of the paper is organized as follows. Section 2 proposes
the general backward compatibility and cases of backward compatible new program behavior. Then we describe real world update
classes that result in backward compatible update in Section 3. Section 4 formally defines our extension of the W language to study
backward compatible updates. Section 4.3 shows terms, notations
and definitions (e.g., execution) heavily used in the technical result. The technical results on semantic equivalence are presented in
Section 5. We propose our formal treatment of real world update
classes in Section 6. A more detailed comparison to related work is
given in Section 7 . Section 8 concludes the paper.

2. Backward compatibility
2.1 Programs and Specifications
Programs are designed to satisfy specifications. Specification can
be explicitly provided or implicitly defined by the behavior of a
program. Programs interact with their environment by receiving
inputs and producing outputs. In this section we introduce enough
of a computing model to describe the input/output behavior of
programs; In the next section we introduce a specific programming
language to reason about specific software updates.
An execution of a program consists of a sequence of steps from
a finite set of steps, S = Sin ∪ Sinternal ∪ Sout ∪ {halt}. A step
of a program can either be an input step in which input is received,
an internal step in which the state of the program is modified, an
output step in which output is produced, or a halt.
We make a distinction between internal state of a program and
external state (e.g., application settings) of the local environment
in which the program executes. Such external state can include the
state of a file system that program can access; we include both as
part of the program state. The state of a program is an element
Q intof a
set M×I, where the set M = Mint ×Mext , Mint = n
k=0 Vk
is a cartesian product of nint sets
of
values,
one
for
each
internal
Q ext
memory location, and Mext = n
k=0 Vk is a cartesian product of
next sets of values, one for each external location. The input value
last received is an element of the set I of input values.
A program executes in an execution environment. An execution
environment (Mext0 , I) specifies an initial value for the external
program state Mext0 and a possibly infinite sequence of input
values I. The input sequence is assumed to be produced by users
that we do not model explicitly.
A step of a program P is a mapping that specifies the next
program state and the next step to execute. For an internal step
sinternal ∈ Sinternal , the mapping is sinternal : M × I 7→
2

2015/9/14

S × M × {⊥}, which specifies the next step and how the state
is modified. The internal steps clear input in the state if any. For an
output step sout ∈ Sout , the mapping sout : M 7→ S × O which
specifies the next step to execute and the output value produced. O
is the set of output values produced by the program. An input step
sin ∈ Sin is simply an element of S × I and specifies the next step
to execute and the input obtained from the environment. (We simply
write sin () to denote the next step and the input received.) Because
the input value is received by the program, we do not restrict the
next step to execute. We allow the input value to be ignored by the
program by two consecutive input steps. When the step is halt,
there is no further action as if halt were mapped to itself.

guishes executions into those that satisfy the specification and those
that do not.
A specification defines the external behavior of a program that
is observed by a user. The input sequence and I/O sequence are
obviously part of external behavior. We also include Mext in
specification domain because a user can have information about the
external state. For example, a user who has data stored in the file
system considers the program’s refusal to access the stored data a
violation of the service specification; this is not the case if the user
has no stored data.

Definition 1. (Program) A program P is a tuple (S, M, Mint0 , s0 ,
I, O), where S is the set of steps as defined above, M is the set of
program states, Mint0 is the initial internal state, s0 is the initial
step, and I and O are disjoint sets of input and output values.

DSU is a process of updating software while it is running. This
results in a hybrid execution in which part of the execution is that
of the old program and part of the execution is for the new program.
State mapping is a function δ mapping an internal state and a
non-halt step of one program P to an internal state and a step of
P′
P
P′
.
another program P ′ , δ : MP
int × (S \ {halt}) 7→ Mint × S
The external state is not mapped because the environment is not
necessarily updated. In addition, we cannot change input and output
that already occurred and that I/O must be part of the hybrid
execution.

2.2 Hybrid executions and state mapping

We do not include the initial external state Mext0 in the program
definition; we include it in the execution environment of P .
Definition 2. (Execution) An execution of a program P =
(S, M, Mint0 , s0 , I, O) in execution environment (Mext0 , I),
where I is a possibly infinite sequence of input values from I, is a
sequence of configurations C from the infinite set {(M, s, i, Ir , IO)}.
A configuration c has the form c = (M, s, i, Ir , IO), where M is
a state, s is a step, i is the last input received, Ir is a sequence of
remaining input values and IO is the input/output sequence produced so far. The kth configuration ck in an execution is obtained
from the (k − 1)th configuration ck−1 = (M, s, i, Ir , IO) where
s 6= halt in one of the following cases:

Definition 4. (Hybrid execution) A hybrid execution (Mext0 , I,
CP ; CP ′ ), produced by DSU using state mapping δ from program P to program P ′ , is an execution (Mext0 , I, CP ) of P
′
concatenated with an execution (Mext
, Ir′ , CP ′ ) of P ′ where the
′
′
, Mext
), s′ , i′ , Ir′ , IO′ ) in CP ′ is
first configuration cP ′ = ((Mint
obtained by applying the state mapping to the last configuration
cP = ((Mint , Mext ), s(6= halt), i, Ir , IO) in CP as follows:
′
• (Mint
, s′ ) = δ(Mint , s);
′
′
• (i = i) ∧ (Ir′ = Ir ) ∧ (IO′ = IO) ∧ (Mext ⊆ Mext
).

1. The first configuration c0 is of the form (M0 , s0 , ⊥, I, ∅),
where M0 = (Mint0 , Mext0 );
2. s ∈ Sinternal : ck = (M ′ , s′ , ⊥, Ir , IO), where (s′ , M ′ , ⊥) =
s(M, i);
3. s ∈ Sin and the remaining inputs Ir is not empty: ck =
(M, s′ , head(Ir ), tail(Ir ), IO·head(Ir )) where (s′ , head(Ir ))
= s(Ir );
4. s ∈ Sin and the remaining inputs Ir is empty: ck = ck−1 ;
5. s ∈ Sout : ck = (M, s′ , i, Ir , IO · o′ ), where (s′ , o′ ) = s(M );

2.3 Backward compatibility
In this paper, we consider updates in which the environment is not
necessarily updated. It follows that in order for the hybrid execution
to be meaningful, the new program should provide functionality
expected by both old and new users of the system.
In practice, specifications are not explicitly available. Instead,
the program is its own specification. This means that the specification that the program satisfies can only be inferred by the external
behavior of the program. Bug fixes create a dilemma for dynamic
software updates. When a program has a bug, its external behavior does not captures its implicit specification and the update will
change the behavior of the program. In what follows, we first discuss what flexibility we can be afforded for a backward compatible
update and then we give formal definitions of backward compatibility and state our assumptions for allowing bug fixes.
We consider a hybrid execution starting from a program P =
(S, Mint × Mext , Mint0 , s0 , I, O) and being updated to a pro′
gram P ′ = (S ′ , M′int × M′ext , Mint
, s′0 , I ′ , O′ ). We examine
0
how the two programs should be related for a meaningful hybrid
execution.

In the definition, head(I) denotes the head (leftmost) element
in the sequence I and tail(I) denotes the remaining sequence
without the head. The input value in i is either consumed by the
next internal step or updated by another input from the next input
step. Execution is stuck if an input step is attempted in state in
which there are no remaining inputs. In what follows, we include
the execution environment in the execution and we abuse notation
to say (Mext0 , I, C) is an execution of a program P .
Specifications We consider specifications that define the input/output behavior of programs. Specifications are not concerned
with how fast an output is produced or about the internal state of
the program.
Definition 3. (Specification) Given a set Mext of external states,
a set seq(I) of input sequences, and a set seq(I ∪ O) of I/O
sequences, specification Σ is a predicate: Mext ×seq(I)×seq(I∪
O)× 7→ {true, f alse}.

1. (Inputs) Input set I ′ of P ′ should be a superset of that I of P
to allow for old users to interact with P ′ after the update. It is
possible to allow for new input values in I ′ to accommodate
new functionality under the assumption that old users do not
generate new input values. Such new input values should be
expected to produce erroneous output by old users as they are
not part of P ’s specification.

We define the I/O sequence of a sequence of configurations C
to be a sequence IO(C) of values from I ∪ O such that every finite
prefix of IO(C) is the IO sequence of some configuration c ∈ C
and every I/O sequence of a configuration c ∈ C is a finite prefix
of IO(C).
An execution (Mext0 , I, C) of program P satisfies a specification Σ if Σ(Mext0 , I, IO(C)) = true. A specification distin-

2. (Outputs) Output produced by P ′ should be identical to output
produced by P if all the input in an execution comes from
the input set of P . This is needed to ensure that interactions
between old users and the program P ′ can make sense from the

3

2015/9/14

• Inputs/outputs/external states of P are a subset of those of

perspective of old users. This is true in the case that the update
does not involve a bug fix, but what should be done if the update
indeed involves a bug fix and the output produced by the old
program was not correct to start with? As far as syntax, a bug fix
should not introduce new output values. As far as semantics, we
should allow the bug fix to change what output is produced for
a given input. We discuss this further under the bug fix heading.
In summary, if we ignore bug fixes, the new program should
behave as the old program when provided with input meant for
the old program.

P ′ : I ⊆ I ′ , O ⊆ O′ and Mext ⊆ M′ext ;

If there is bug fix between programs P ′ and P , we need to adapt
Definition 5 to allow for some executions on input sequences from
I to violate the specification of P . Above we identified two cases in
which bug fixes are safe (replacing a response with no response or
replacing a no response with a correct response without introducing
new output values). We omit the definition.
We have the backward compatible updates by extending the
definition of a backward compatible hybrid execution to all possible
hybrid executions.

3. (Bugfix) Handling bug fixes is problematic. If the produced output already violates the fix, then there is no way for the hybrid
execution to satisfy the implicit semantics of the program or the
semantics of the new program. Some bug fixes can be handled.
For example, a bug that causes a program to crash for some
input can be fixed to allow the program to continue executing.
Applying the fix to a program that has not encountered the bug
should not be problematic. Another case is when the program
should terminate for some input sequence, but the old program
does not terminate. A bug fix that allows the program to terminate should not present a semantic difficulty for old users.
In general, we assume that there are valid executions and invalid executions of the old program. I/O sequences produced in
invalid executions are not in specification of the program. We
assume that an invalid execution will lead to an error configuration not explicitly handled by the program developers. We do
not expect the state mapping to change an error configuration
into an non-error configuration just as static updating does not
fix occurred errors. Besides, we do not attempt to determine if a
particular configuration is an error configuration. Such determination is not possible in general and very hard in practice. We
simply assume that the configuration at the time of the update
is not an error configuration. (which is equivalent to assuming
the existence of an oracle JP to determine if a particular configuration is erroneous, JP (CP ) = true if the configuration CP
is not erroneous).

Definition 6. (Backward compatible updates) We say an updated
program P ′ is backward compatible with a program P in configuration C if there is hybrid execution, from configuration C of P to
P ′ that is backward compatible with specification of P .
2.4 Backward compatible program behavior changes
With the formal definition of backward compatibility, it is desirable to check what behavior changes of an updated program help
ensure a safe update. Backward compatibility is essentially a relation between I/O sequences produced by an old program and those
produced by an updated program. We summarized typical possibilities of the relation into six cases in Figure 1 by considering consequence of major update motivation (i.e., new functionality, bug fix
and program perfective/preventive needs [1]). According to David
Parnas [29], a program is updated to adapt to changing needs. In
other words, program changes are to produce more or less or different output according to changing needs. These changes are captured by case 2, 3, 4, 5 and 6 in Figure 1. We also capture outputpreserving changes which are most likely motivated by the program developer’s own needs (e.g., software maintainability), which
is case 1 in Figure 1.
Furthermore, we find that an update is backward compatible
if in every execution the new program behavior is one of the six
cases in Figure 1. Cases 1 and 2 are obviously backward compatible
because an old client is guaranteed to get old responses. Cases 3,
4, 5, and 6 are not obviously backward compatible. Unlike case
1 and 2, case 3, 4 and 5 are backward compatible under specific
assumptions on program semantics while case 6 is different. Case
3 is backward compatible because we assume the change is either
adding new functionality, or fixing a bug in which the old program
hanged or crashed. Similarly, case 4 is backward compatible. Case
5 is backward compatible because different I/O interaction could
express the same application semantics. For example, a greeting
message could be changed from “hi” to “hello”. Case 6 is backward
compatible in that the new program makes implicit specification of
the program explicit by enforcing restrictions on program state and
therefore eliminating undesired I/O sequence.
The six cases in Fig. 1 have covered the changes of output, including more or less or different output. There exists more specific
cases of backward compatible program behavior changes under
various specific assumptions. However, these more specific cases
could be attributed to one of the six cases as far as the changes of
output are concerned. In conclusion, it is not possible to go much
beyond the six cases of backward compatibility in Fig. 1.

4. (New functionality) New functionality is usually accompanied
by new inputs/outputs and the expansion of external state. We
assume that new functionality is independent of existing functionality in the sense that programs P and P ′ produce the same
I/O sequence when receiving inputs in I only. We therefore assume all new inputs I ′ \ I are introduced by new functionality.
Every external state of P is part of some external state of program P ′ because of the definition of the specification of P . We
only consider expansion of the external state of P for new functionalities in P ′ where the expansion of external state is independent of values in existing external state. One of the motivating examples is to add application settings for new program
feature.
In light of the discussion above we give the following definition
of backward compatibility in the absence of bug fixes.
Definition 5. (Backward compatible hybrid executions) Let
P = (S, Mint × Mext , Mint0 , s0 , I, O) be a program satisfying
a specification Σ. We say that a hybrid execution (Mext , I, CP ; CP′ )
′
from P to a program P ′ = (S ′ , M′int × M′ext , Mint
, s′0 , I ′ , O′ )
0
is backward compatible with implicit specification of P if all of the
following hold:

3. Real world backward compatible update
classes: brief description
We have studied evolution of three real world programs (i.e., vsftpd, sshd and icecast) to identify real world changes that are backward compatible. We chose these three programs because the programs are widely used in practice [2, 3] and are widely studied in
the DSU community [26, 27]. We have studied several years of re-

• The last configuration in CP is not an error configuration,

CP = “C ′ ; (M, s′ , i, Ir , IO)” : JP (CP )=true.
• The hybrid execution satisfies the specification Σ of P ,
Σ(Mext , I, IO(CP ; CP′ )) = true;

4

2015/9/14

Case
1

2

3

4

5
6

Update date Total Class
Software version
Formal new program behavior
vsftpd 1.1.0 –1.1.1 2002-10-07
16
8
the old behavior including external state extension:
vsftpd 1.1.1 –1.1.2 2002-10-16
8
1
ΣP ⊆ ΣP ′ , or ΣP ′ = {(Mext′ , oneseq(I), oneseq(I ∪ O)) → val
8
4
vsftpd 1.1.2 –1.1.3 2002-11-09
|∃(Mext , oneseq(I), oneseq(I ∪ O)) → val in ΣP
61
9
vsftpd 1.1.3 –1.2.0 2003-05-29
and Mext ⊆ Mext′ } where I = I ′ , O = O′ and Mext ⊆ Mext′
vsftpd 1.2.0 –1.2.1 2003-11-13
33
11
the old behavior for old input and consuming inputs
10
6
vsftpd 1.2.1 –1.2.2 2004-04-26
that are only from new clients:
52
13
vsftpd 1.2.2 –2.0.0 2004-07-01
ΣP ⊆ ΣP ′ ∧
vsftpd 2.0.0 –2.0.1 2004-07-02
7
4
ΣP ′ \ ΣP = {(Mext , oneseq(I ′ ), oneseq(I ′ ∪ O′ )) → true
23
4
vsftpd 2.0.1 –2.0.2 2005-03-03
| oneseq(I ′ ∪ O′ ) includes at least one input in (I ′ \ I)} =
6 ∅
vsftpd 2.0.2 –2.0.3 2005-03-19
18
8
where I ⊂ I ′ , O ⊆ O′ and Mext = Mext′
14
9
vsftpd 2.0.3 –2.0.4 2006-01-09
producing more output while the old program terminates:
21
15
vsftpd 2.0.4 –2.0.5 2006-07-03
ΣP ′ \ ΣP = {(Mext , oneseq(I), oneseq(I ∪ O)) 7→ false
vsftpd 2.0.5 –2.0.6 2008-02-13
20
9
|(Mext , oneseq(I), oneseq(I ∪ O)) ∈ ∆f 6= ∅}
16
8
vsftpd 2.0.6 –2.0.7 2008-07-30
∪ {(Mext , oneseq(I), oneseq(I ∪ O)  oneseq’(I ∪ O)) 7→ true
vsftpd 2.0.7 –2.1.0 2009-02-19
53
11
|(Mext , oneseq(I), oneseq(I ∪ O)  oneseq’(I ∪ O)) ∈ ∆t 6= ∅}
21
9
vsftpd 2.1.0 –2.1.2 2009-05-29
ΣP \ ΣP ′ = {(Mext , oneseq(I), oneseq(I ∪ O)) 7→ false
vsftpd 2.1.2 –2.2.0 2009-08-13
34
14
|(Mext , oneseq(I), oneseq(I ∪ O)) ∈ ∆t 6= ∅}
Update date Total Class
Software version
∪ {(Mext , oneseq(I), oneseq(I ∪ O)  oneseq’(I ∪ O)) 7→ true
2009-10-19
21
5
|(Mext , oneseq(I), oneseq(I ∪ O)  oneseq’(I ∪ O)) ∈ ∆f 6= ∅} vsftpd 2.2.0 –2.2.2
vsftpd 2.2.2 –2.3.0
2010-08-06
13
3
where I = I ′ , O = O′ and Mext = Mext′
2010-08-19
5
0
vsftpd 2.3.0 –2.3.2
termination while the old program produces erroneous output:
2011-03-12
7
0
vsftpd 2.3.2 –2.3.4
ΣP ′ \ ΣP = {(Mext , oneseq(I), oneseq(I ∪ O)) 7→ true
vsftpd 2.3.4 –2.3.5
2011-12-19
14
6
|(Mext , oneseq(I), oneseq(I ∪ O)) ∈ ∆t 6= ∅}
2012-04-10
23
4
∪ {(Mext , oneseq(I), oneseq(I ∪ O)  oneseq’(I ∪ O)) 7→ false vsftpd 2.3.5 –3.0.0
2012-09-19
40
2
|(Mext , oneseq(I), oneseq(I ∪ O)  oneseq’(I ∪ O)) ∈ ∆f 6= ∅} vsftpd 3.0.0 –3.0.2
sshd 3.5p1 –3.6p1
2003-03-31
95
34
ΣP \ ΣP ′ = {(Mext , oneseq(I), oneseq(I ∪ O)) 7→ true
sshd 3.6p1 –3.6.1p1
2003-04-01
13
12
|(Mext , oneseq(I), oneseq(I ∪ O)) ∈ ∆f 6= ∅}
16
12
∪ {(Mext , oneseq(I), oneseq(I ∪ O)  oneseq’(I ∪ O)) 7→ false sshd 3.6.1p1 –3.6.1p2 2003-04-29
2007-03-07
48
13
|(Mext , oneseq(I), oneseq(I ∪ O)  oneseq’(I ∪ O)) ∈ ∆t 6= ∅} sshd 4.5p1 –4.6p1
sshd 6.6p1 –6.7p1
2014-10-06
283
51
where I = I ′ , O = O′ and Mext = Mext′
icecast 0.8.0 –0.8.1
2004-08-04
4
3
different output that is functionally equivalent to old output:
icecast 0.8.1 –0.8.2
2004-08-04
2
0
(ΣP 6= ΣP ′ ) ∧ (ΣP ≡ ΣP ′ )
2005-11-30
47
10
icecast 2.3.0 –2.3.1
where I = I ′ , (O 6= O′ ) ∧ (O ≡ O′ ) and Mext = Mext′
icecast 2.3.1 –2.3.2
2008-06-02
250
28
enforcing restrictions on program state:
2014-11-19
178
154
icecast 2.4.0 –2.4.1
ΣP ′ \ ΣP = {(Mext , oneseq(I), oneseq(I ∪ O)) 7→ false
|(Mext , oneseq(I), oneseq(I ∪ O)) ∈ ∆arbi 6= ∅}
ΣP \ ΣP ′ = {(Mext , oneseq(I), oneseq(I ∪ O)) 7→ true
Figure 2: Statistics of classified real world software update
|(Mext , oneseq(I), oneseq(I ∪ O)) ∈ ∆arbi 6= ∅}
′
′
where I = I , O = O and Mext = Mext′
that these update classes are also widespread in other program evolution. Each of the six real world update classes falls in one of the
five cases of backward compatibility in Fig. 1. We present informal descriptions of all update classes including required assumptions for the two programs to produce same or equivalent output
sequence which guarantees backward compatible DSU.

Figure 1: Six cases of formalized general new program behavior

leases of vsftpd and consecutive updates of sshd and icecast. This is
because vsftpd is more widely studied by the DSU community [25–
27].
Our study of real world program evolution is carried out as follows. We examined every changed function manually to classify
updates. For every individual change, we first identified the motivation of the change, then the assumptions under which the change
could be considered backward compatible. If the assumption under
which the change is considered backward compatible is reasonable,
we recorded the change into one particular update class. Finally we
summarized common update classes observed in the evolution of
studied programs.
Fig. 2 shows the statistics from our study of real world program evolution where “total” refers to the number of all updated
functions, “class” refers to the number of updated functions with
at least one classified update pattern. In summary, 32% of all updated functions include at least one classified program update; the
unclassified updates are mostly bug fix that are related to specific
program logic. We summarized seven most common real world update classes from all the studied updates in Fig. 3 and we believe

3.1 Observational equivalence: the old behavior
In case 1 in Fig. 1, two programs are backward compatible because
the new program keeps all old behaviors (“observational equivalence”). In our study, we differentiate two types of “observational
equivalence” based on if assumptions are required.
Program equivalence We consider several types of program
changes that are allowed by “observational equivalence” without
user assumptions. These changes include: loop fission or fusion,
statement reordering or duplication, and extra statements unrelated to output(e.g., logging related changes). We incorporate these
changes in our framework of program equivalence which ensures
two programs produce the same output regardless of whether the
programs terminate or not. The details of the formal treatment is in
Section 5.
Specializing new configuration variables Another update class
of “observational equivalence” is “specializing new configuration
variables”, which is backward compatible under user assumptions.

5

2015/9/14

Update class (Case)
program equivalence (1)
new config. variables (1)
enum type extension (2)
var. type weakening (3)
exit on error (4)
improved prompt msgs (5)
missing var. init. (6)

1:
2:
3: output a

Required assumptions for backward
compatible update
none
no redefinitions of new config
variables after initialization
no inputs from old clients match
the extended enum labels
no intentional use of value type
mismatch and array out of bound
correct error check before exit
changing prompt messages for
more effective communication
no intentional use of undefined
variables

old

new
Figure 6: Exit-on-error

3.3 Variable type weakening: more output when the old
program terminates
In program updates, variable types are changed either to allow for
larger ranges (weakening) or smaller ranges to save space (strengthening). For example, an integer variable might be changed to become a long variable to avoid integer overflow or a long variable
might be changed to an integer variable because the larger range
of long is not needed. Type weakening also includes adding a new
enumeration value and increasing array size. The kinds of strengthening or weakening that should be allowed are application dependent and would need to be defined by the user in general. The type
weakening considered is either changes from type int to long or
increase of array size. These updates fix integer overflow or array
index out of bound respectively, the case 3 of backward compatibility. Implicitly, we assume that there is no intentional use of integer
overflow and array out of bound as program semantics.

Figure 3: Required assumptions for real world backward compatible update classes

1:
2:
3:
4: output a + 2
old

1’: If (1/(a − 5)) then
2’:
skip
3’: output a

1’: If (b) then
2’:
output a ∗ 2
3’: else
4’:
output a + 2
new

Figure 4: Specializing new configuration variables

3.4 Exit on errors: stopping execution while the old program
produces more output

1: enum id {o1 }
2: a : enum id
3: If (a == o1 ) then
4:
output 2 + c
5:
6:
old

One kind of bug fix, which we call exit on error, causes a program
to exit in observation of errors that depend on application semantic.
Fig. 17 shows an example of exit-on-error update. In the example,
the fixed bugs refer to the program semantic error that a = 5. Instead of using an “exit” statement, we rely on the crash from expression evaluations to model the “exit”. When errors do not occur,
the two programs in Fig. 17 produce the same output sequence.
This is case 4 of backward compatibility. Naturally, we assume that
all error checks are correct.

1’:
2’:
3’:
4’:
5’:
6’:

enum id {o1 , o2 }
a : enum id
If (a == o1 ) then
output 2 + c
If (a == o2 ) then
output 3 + c
new

Figure 5: Enumeration type extension

3.5 Improved prompt messages: functionally equivalent
outputs
In this update class, new configuration variables are introduced to
generalize functionality. For example, in Fig. 15, a new configuration variable b is used to introduce new code. The two statement
sequences in Fig. 15 are equivalent when the new variable b is specialized to 0. In general, if all new code is introduced in a way
that is similar to that in Fig. 15 where there is a valuation of new
configuration variables under which new code is not executed, and
new configuration variables are not redefined after initialization,
then the new program and the old program produce the same output sequence. The point is that new functionality is not introduced
abruptly in interaction with an old client. Instead new functionality could be enabled for a new client when old clients are not a
concern.

In practice, outputs could be classified into prompt outputs and
actual outputs. Prompt outputs are those asking clients for inputs,
which are constants hardcoded in output statements. Actual outputs
are dynamic messages produced by evaluation of non-constant
expressions in execution. If the differences between two programs
are only the prompt messages that a client receives, we consider
that the two programs are equivalent. The prompt messages are
the replaceable part of program semantics. We observe cases of
improving prompt messages in program evolution for effective
communication. The changes of prompt outputs do not matter only
for human clients. This is case 5 of backward compatibility.

3.2 Enum. type extension: old behavior for old input and
allowing new input

Another kind of bug fix, which we call missing variable initialization, includes initializations for variables whose arbitrary initial
values can affect the output sequence in the old program. Fig. 18
shows an example of missing variable initialization. The initialization b := 2 ensures the value used in “output b + c” not to be undefined. Despite of initialization statements, the two programs are
same. In general, initializations of variables only affect rare buggy
executions of the old program, where undefined variables affect the
output sequence. This update class is case 6 of backward compatibility and we assume that there is no intentional use of undefined
variable in the program. When there are no uses of variables with

3.6 Missing variable initialization: enforcing restrictions on
program states

Enumeration types allow developers to list similar items. New code
is usually accompanied with the introduction of new enumeration
labels. Fig. 16 shows an example of the update. The new enum label o2 gives a new option for matching the value of the variable
a, which introduces the new code “output 3 + c”. To show enumeration type extensions to be backward compatible, we assume
that values of enum variables, used in the If-predicate introducing
the new code, are only from inputs that cannot be translated to new
enum labels. This is case 2 of the backward compatibility.

6

2015/9/14

1:
2: If (a > 0) then
3:
b := c + 1
4: output b + c
old

1’: b := 2
2’: If (a > 0) then
3’:
b := c + 1
4’: output b + c
new

Figure 7: Missing initialization

Identifier
id
Enum Items
Enumeration
Prompt Msg
Prompts
Base type
Variables
Left value
Expression
Statement
Stmt Seq.
Program

Values

v

∈

ZL ∪ L

I/O values
Inputs
Eval. values

vio
vi
verr

∈
::=
::=

ZL
v io
v | error

Param. types

τ⊤

::=

τ | array(τ, n)

Loop Labels

looplbl ∈

integer values in type long and
enum/prompt labels
tagged input values
values and the runtime error

N

Figure 9: Values, types and domains

Constant
n
Label
l
el
::= l | el1 , el2
EN ::= ∅ | enum id {el} | EN 1 , EN 2
msg ::= l : n | msg 1 , msg 2
P mpt::= ∅ | {msg}
τ
::= Int | Long | pmpt | enum id
V
::= ∅ | τ id | τ id[n] | V1 , V2
lval ::= id | id1 [id2 ] | id[n]
e
::= id == l | lval | other
s
::= lval := e | input id | output e | skip
| while (e) {S}
S
::= s1 ; ...; sk for k ≥ 1
P
::= P mpt; EN ; V ; Sentry

Crash flag
Overflow flag
Type Env.
Loop counter
Value store

f
::=
of
::=
Γ
::=
loopc::=
σ
::=
|
|
|

0|1
0|1
∅ | id : τ⊤ | id : {l1 , ..., lk } | Γ1 , Γ2
(looplbl 7→ (n | ⊥))
id 7→ (v | ⊥)
values of scalar variables
id 7→ (n 7→ (v | ⊥))
values of array elements
∗
idI 7→ vio
input sequence
idIO 7→ (vi | vo )∗
I/O sequence

State

m

(f, of, Γ, loopc , σ)

::=

Figure 8: Abstract syntax

Figure 10: Elements of an execution state

undefined variables in executions of the old program, the two programs produce the same output sequence.

statements Sentry . Finally, we have a standard type system based
on our syntax.
4.2 Small-step operational semantics of the formal language

4. Formal programming language

Figure 9 shows semantic categories of our language. We consider
values to be either labels L or integer numbers ZL defined in type
Long. The integer numbers defined ZI of type Int are a proper
subset of those in type Long, ZI ⊂ ZL . We use the notation ZL+
for the positive integers defined in type Long. We use the notation
udfJτ K for an undefined value of type τ . Unlike the “undef” in
Clight [8], we need to parameterize the undefined value with a
type τ because we do not have an underlining memory model that
can interpret any block content according to a type. An individual
value in I/O sequence is an integer number with tag differentiating
inputs and outputs, our tags for inputs and outputs are standard
notations [14]. The value from expression evaluation is a pair. One
of the pair is either a value v or “error” for runtime errors(e.g.,
division by zero); the other is the overflow flag (i.e., 0 for no
overflow).
We use notation τ⊤ for all types that are defined in syntax,
including array types.
Every loop statement in a program is with a unique label looplbl
of a natural number in order to differentiate their executions.
The composition of an execution state is in Figure 10.

We present the formal programming language based on which
we prove our semantic equivalence results and describe categories
of backward compatible changes. We first explain the language
syntax, then the language semantics.
4.1 Syntax of the formal language
The language syntax is in Figure. 8. We use id to range over the
set of identifiers, n to range over integers, l to range over labels.
We assume unique identifiers across all syntactic categories, unique
labels across all enumeration types and the prompt type. We have
base type Int and Long for integer values. The integers defined in
type Int are also defined in type Long. Every label defined in the
prompt type is related with an integer constant as the actual value
used in output statement. We differentiate type Long and Int to
define the bug fix of type relaxation from Int to Long to prevent
overflow in calculation (e.g., a + b can cause an error with Int but
not with Long). The type Int is necessary reflecting the concern of
space and time efficiency in practical computation. We also have
user-defined enumeration type, prompt type and array type.
We explicitly have “id == l” and lval as expressions for convenience of the definition of specific updates. To make our programming language general and to separate the concern of expression evaluation, we parameterize the language by “other” expressions which are unspecified.
We have explicit input and output statement because we model
the program behavior as the I/O sequence which is the observational behavior of a program. The I/O statement makes it convenient for the argument of program behavior correspondence. In this
paper, every I/O value is an integer value which is a common I/O
representation [14]. A Statement sequence is defined as s1 ; ...; sk
where k > 0 for the convenience of syntax-direct definition from
both ends of the sequence.
A program is composed of a possibly empty prompt type P mpt,
a possibly empty sequence of enumeration types EN , a possibly
empty sequence of global variables V and a sequence of entry

1. The crash flag f is initially zero and is set to one whenever an
exception occurs. Once the crash flag is set, it is not cleared. We
only consider unrecoverable crashes. The crash flag is used to
make sure that updates do not occur in error states.
2. The overflow flag of is initially zero and is set to one whenever
an integer overflow in expression evaluation occurs. Overflow
flag is sticky in the sense that once it is set, the flag is not
cleared. According to [12], integer overflows are common in
mature programs.
3. Γ is the type environment mapping enumeration type identifers
and variable identifiers to their types. Type environment is necessary for checking array index out of bound or checking value
mismatch in execution of input/assignment statement.
4. Loop counters loopc are to record the number of iterations for
one instance of a loop statement. The loop counters loopc is
7

2015/9/14

(S, m) → (S ′ , m′ )

(r, m) → (r ′ , m′ )

(r, m) → (r ′ , m′ )

(E[r], m) → (E[r ′ ], m′ )
Eval. Context E ::= | id[E] | E == l
| id := E | id[E] := e | id[v] := E | output E
| while (E){S} | If (E) then {St } else {Sf } | E; S

As-Scl
As-Arr

Figure 11: Contextual semantic rule

As-Err1

f=0

f=0

E : other → σ → (verr × {0, 1})
Err : other → {id} (unspecified)

Var

f=0

σ(id) = v

As-Err3

(id, m(f, σ)) → (v, m)
f=0

Arr-1

f=0

f=0

Arr-2
Eq-T

Eq-F

(Γ ⊢ id : array(τ, n)) ∧ ¬(1 ≤ v1 ≤ n)

If-F

(id[v1 ], m(f, Γ)) → (id[v1 ], m(1/f))

f=0
σ(id, v1 ) 6= ⊥
(Γ ⊢ id : array(Int, n)) ∧ (v2 ∈ (ZL \ ZI ))
(id[v1 ] := v2 , m(f, Γ, σ)) → (id[v1 ] := v2 , m(1/f))

f=0
l1 6= l2
(l1 == l2 , m(f)) → (0, m)

Wh-F

f = 0 e = other
(e, m(f, σ)) → (EJeKσ, m)

(v ∈ ZL ) ∧ (v 6= 0)

f=0
(If (0) then {St } else {Sf }, m(f)) → (Sf , m)

Wh-T

ECrash

(id := v, m(f, Γ, σ)) → (id := v, m(1/f))

(If (v) then {St } else {Sf }, m(f)) → (St , m)

f=0
(l == l, m(f)) → (1, m)

EEval

f=0
σ(id) 6= ⊥
(Γ ⊢ id : Int) ∧ (v ∈ (ZL \ ZI ))

f=0

If-T

(Γ ⊢ id : array(τ, n)) ∧ ¬(1 ≤ v1 ≤ n)

(id[v1 ] := v2 , m(f, Γ)) → (id[v1 ] := v2 , m(1/f))

σ(id, v1 ) = v2

(id[v1 ], m(f, σ)) → (v2 , m)

σ(id, v1 ) 6= ⊥

(id[v1 ] := v2 , m(f, σ)) → (skip, m(σ[v2 /(id, v1 )]))

(r, m) → (r ′ , m′ )
As-Err2

σ(id) 6= ⊥

(id := v, m(f, σ)) → (skip, m(σ[v/id]))

Seq

f=0

(v ∈ ZL ) ∧ (v 6= 0)

loopc (n) = k

(whilehni (v) {S}, m(f, loopc )) →
(S; whilehni (e) {S}, m(loopc [(k + 1)/n])
f=0

loopc (n) 6= ⊥

(whilehni (0) {S}, m(f, loopc )) → (skip, m(loopc [0/n]))
f=0
(skip; S, m(f)) → (S, m)

Crash

f=1
(s, m(f)) → (s, m)

f=0
((error, vof ), m(f)) → (0, m(1/f))

EOflow-1

f = 0 of = 0
((v, vof ), m(f, of)) → (v, m(vof /of))

EOflow-2

f = 0 of = 1
((v, vof ), m(f, of)) → (v, m)

Figure 13: SOS rules for Assignment, If, and While statements

other → {id} maps an “other” expression to a set of variables
used in the expression; there is a function Err : other → {id}
maps an expression to a set of variables whose values decide if the
evaluation of expression leads to crash. We assume function Use
and Err available. The value returned by the expression meaning
function only depends on the values of variables in the use set of the
expression and the error evaluation only depends on the variables
in the error set.
As to integer overflow, there are two ways of handling overflow in practice one is to wrap around overflow using twoscomplement representation (e.g., the gcc option -fwrapv); the other
is to generates traps for overflow (e.g., the gcc option -ftrapv). We
adopt a combination of the two handling of overflow: the meaning function E wraps the overflow in some representation (e.g.,
two-complement) and notifies the overflow in return value. Rule
EOflow-1 and EOflow-2 update the sticky overflow flag. The evaluation of lval or id == l is shown by respective rules in Figure 12.
Figure 13 shows SOS rules for assignment, If, while statements,
statement sequence, and crash, which are almost standard. There
are four particular crash in execution of assignment statements.
One is array out of bound for array access for l-value (e.g., rule
As-Err1); the second is assigning a value defined in type Long but
not type Int to an Int-typed variable (e.g., rule As-Err2); the third is
value mismatch in input statement; the last is expression evaluation
exception. As to loop statement, if the predicate expression evaluates to a nonzero integer, corresponding loop counter value increments by one; otherwise, the loop counter value is reset to zero. We

Figure 12: SOS rules for expressions

not necessary for program executions but are needed for our
reasoning of the execution of loops. When a counter entry for
loop label n is not defined in loop counters loopc , we write
loopc (n) = ⊥. Otherwise, we write loopc (n) 6= ⊥.

5. The value store σ is a valuation for scalar variables, array
elements, the input sequence variable, and the I/O sequence
variable.

Execution state m is a composition of elements discussed
above. In our SOS rules, we only show components of a state
m when necessary (e.g., m(Γ, σ)).
Figure 11 shows typical contextual rule and Figure 12, 13 and
14 show all SOS rules.
Figure 12 shows rules for expression evaluation. We use the
expression meaning function E : other → σ → (verr × {0, 1})
to evaluate “other” expressions. In evaluation of expression “other”
against a value store σ, the expression meaning function E returns a
pair (verr , of) where the value verr is either a value v or an “error”, of
is a flag indicating if there is integer overflow in the evaluation (e.g.,
1 if there is overflow). The meaning function E interprets “other”
expressions deterministically. In addition, there is a function Use :

8

2015/9/14

to be in a statement sequence. We use the symbol ⊂ to refer to
proper subset relation.
We call an “If” statement or a “while” statement as a compound statement; all other statements are simple statements. We
introduce terms referring to a part of a compound statement. Let
s = “If(e) then{St } else{Sf }” be an “If” statement, we call e in s
the predicate expression, St /Sf the true/false branch of s.

(r, m) → (r ′ , m′ )
In-1

In-2

In-3

In-4

In-5
In-6
Out-1
Out-2

f=0

f=0
hd(σ(idI )) = vio

hd(σ(idI )) = vio

Γ ⊢ id : Long

σ(id) 6= ⊥
(Γ ⊢ id : Int) ∧ (vio ∈ ZI )

(input id, m(f, Γ, σ)) → (skip,
m(σ[vio /id][tl(σ(idI ))/idI ][“σ(idIO ) · v io ”/idIO ])
f=0
hd(σ(idI )) = vio

5. Program equivalence
We consider several types of program changes that are allowed
by “observational equivalence” without user assumptions. These
changes include: statement reordering or duplication, extra statements unrelated to output(e.g., logging related changes), loop fission or fusion, and extra statements unrelated to output. Our program equivalence ensures two programs produce the same output,
which means two programs produce same I/O sequence till any output. The program equivalence is established upon two other kinds
of equivalence, namely equivalent terminating computation of a
variable and equivalent termination behavior.
We first define terminating and nonterminating execution. Then
we present the framework of program equivalence in three steps in
which every later step relies on prior ones. We first propose a proof
rule ensuring two programs to compute a variable in the same way.
We then suggest a condition ensuring two programs to either both
terminate or both do not terminate. Finally we describe a condition
ensuring two programs to produce the same output sequence. Our
proof rule of program equivalence gives program point mapping as
well as program state mapping. Though we express the program
equivalence as a whole program relation, it is easy to apply the
equivalence check for local changes using our framework under
user’s various assumptions for equivalence.

σ(id) 6= ⊥
(Γ ⊢ id : Int) ∧ (vio ∈
/ ZI )

(input id, m(f, Γ, σ)) → (input id, m(1/f))
f=0
σ(id) 6= ⊥
hd(σ(idI )) = vio
(Γ ⊢ id : enum id′ ) ∧ (Γ ⊢ id′ : {l1 , ..., lk }) ∧ (1 ≤ vio ≤ k)
(input id, m(f, Γ, σ)) → (skip,
m(σ[lvio /id, tl(σ(idI ))/idI ][“σ(idIO ) · v io ”/idIO ])
f=0
σ(id) 6= ⊥
hd(σ(idI )) = vio
(Γ ⊢ id : enum id′ ) ∧ (Γ ⊢ id′ : {l1 , ..., lk }) ∧ ¬(1 ≤ vio ≤ k)
(input id, m(f, Γ, σ)) → (input id, m(1/f))
f=0

σ(idI ) = ∅

(input id, m(f, σ)) → (input id, m(1/f))
f=0

v ∈ ZL

(output v, m(f, σ)) → (skip, m(σ[“σ(idIO ) · v”/idIO ]))
f=0

Γ ⊢ id : {l1 , ..., lk } ∧ v = li ∈ {l1 , ..., lk }

(output v, m(f, Γ, σ)) → (skip, m(σ[“σ(idIO ) · i”/idIO ]))
f=0

Out-3

σ(id) 6= ⊥

(input id, m(f, Γ, σ)) →
(skip, m(σ[vio /id][tl(σ(idI ))/idI ][“σ(idIO ) · v io ”/idIO ])

Γ ⊢ pmpt : {l1 : n1 , ..., lk : nk }
“l : n” ∈ {l1 : n1 , ..., lk : nk }

(output l, m(f, Γ)) → (output n, m)

5.1 Definitions of execution
We define an execution to be a sequence of configurations which
are pairs (S, m) where S is a statement sequence and m is a execution state shown in Figure 10. Let (S1 , m1 ), (S2 , m2 ) be two
consecutive configurations in an execution, the later configuration
(S2 , m2 ) is obtained by applying one semantic rule w.r.t to the
configuration (S1 , m1 ), denoted (S1 , m1 ) → (S2 , m2 ), called
one step (of execution). For our convenience, we use the notation
k
(S, m) → (S ′ , m′ ) for k steps execution where k > 0. When we
do not care the exact (finite) number of steps, we write the exe∗
cution as (S, m) → (S ′ , m′ ). We express terminating executions,
nonterminating executions including crash in Definition 7 and 8.

Figure 14: SOS rules for input/output statements

use rule Crash to treat crash as non-terminating execution, telling
apart normally terminating executions and others.
Figure 14 shows rules for the execution of input/output statements. As to input, there are conversion from values of type Long
to those of Int or enumeration types but not the prompt type. For an
enumeration type, the Long-typed value is transformed to the label
with index of that value if possible. There is crash when value conversion is impossible. Besides, there is crash when executing input
statement with empty input sequence. We use standard list operation hd and tl for fetching the list head(leftmost element) or the list
tail(the list by removing its head) respectively [30].
Last, we construct initial state in following steps: First, crash
flag f, overflow flag of are zero. Second, type environment is obtained after parsing of the program. Third, every loop counter value
in loopc is initially zero. Fourth, every scalar variable or array element has an entry in value store with some initial value if specified.
Last, there is initial input sequence and empty I/O sequence.

Definition 7. (Termination) A statement sequence S normally
∗
terminates when started in a state m iff (S, m) → (skip, m′ (f))
where f = 0.
Definition 8. (Nontermination) A statement sequence S does not
k
terminate when started in a state m iff, ∀k > 0 : (S, m) →
(Sk , mk ) where Sk 6= skip.
5.2 Equivalent computation for terminating programs
We propose a proof rule under which two terminating programs
are computing a variable in the same way. We start by giving the
definition of equivalent computation for terminating programs right
after this paragraph. Then we present the proof rule of equivalent
computation in the same way. We prove that the proof rule ensures
equivalent computation for terminating programs by induction on
the program size of the two programs in the proof rule. We also
list auxiliary lemmas required by the soundness proof for the proof
rule for equivalent computation for terminating programs.

4.3 Preliminary terms and notations
We present terms, notations and definitions for program equivalence and backward compatible update classes.
We use Use(e) or Use(S) to denote used variables in an expression e or a statement sequence S; Def(S) denotes the set of defined
variables in a statement sequence S. The full definitions of Use and
Def are in appendix B.
We use symbol ∈ for two different purposes: x ∈ X denotes
one variable to be in a set of variables, s ∈ S denotes a statement
9

2015/9/14

(d) S1 and S2 do not define the variable x: x ∈
/ Def(S1 ) ∪
Def(S2 ).
2. S1 and S2 are not both one statement and one of the following
holds:
(a) S1 = S1′ ; s1 , S2 = S2′ ; s2 and last statements both define
the variable x such that both of the following hold:
′
• ∀y ∈ Imp(s1 , {x}) ∪ Imp(s2 , {x}) : S1′ ≡S
y S2 ;
S
• s1 ≡x s2 where x ∈ Def(s1 ) ∩ Def(s2 );
(b) Last statement in S1 or S2 does
 not define the variable′ x: S
S
′
x∈
/ Def(s1 ) ∧ (S1 ≡x
/ Def(s2 ) ∧ (S1 ≡x S2 ) ∨ x ∈
S2 ) ;
(c) S1 = S1′ ; s1 , S2 = S2′ ; s2 and there are statements moving
in/out of If statement: s1 = “If (e) then {S1t } else {S1f }”,
s2 = “If (e) then {S2t } else {S2f }” such that none of the
above cases hold and all of the following hold:
′
• ∀y ∈ Use(e) : S1′ ≡S
y S2 ;
f
′
t
S
′
t
′
′
• (S1 ; S1 ≡x S2 ; S2 ) ∧ (S1 ; S1f ≡S
x S2 ; S2 );

Definition 9. (Equivalent computation for terminating programs) Two statement sequences S1 and S2 compute a variable x
equivalently when started in states m1 and m2 respectively, writ∗
ten (S1 , m1 ) ≡x (S2 , m2 ), iff (S1 , m1 ) → (skip, m′1 (σ1′ )) and
∗
′
(S2 , m2 ) → (skip, m2 (σ2′ )) imply σ1′ (x) = σ2′ (x).
5.2.1 Proof rule for equivalent computation for terminating
programs
We define a proof rule under which (S1 , m1 ) ≡x (S2 , m2 ) holds
for generally constructed initial states m1 and m2 , written S1 ≡S
x
S2 . Our proof rule for equivalent computation for terminating programs allows updates including statement reordering or duplication, loop fission or fusion, additional statements unrelated to the
computation and statements movement across if-branch.
Definition 12 includes the recursive proof rule of equivalent
computing for terminating programs. The base case is the condition for two simple statements in Definition 11. Definition 10 of
imported variables captures the variable def-use chain which is the
essence of our equivalence. In Definition 10, the Def and Use refer
to variables defined or used in a statement (sequence) or an expression similar to those in the optimization chapter in the dragon
book [4]; S i refers to i consecutive copies of a statement sequence
S.

The generalization of definition S1 ≡S
x S2 to a set of variables
is as follows.

Definition 13. Two statement sequences S1 and S2 have equivalent computation of variables X, written S1 ≡S
X S2 , iff ∀x ∈ X :
S1 ≡ S
x S2 .

Definition 10. (Imported variables) The imported variables
in a sequence of statements S relative to variables X, written
Imp(S, X), are defined in one of the following cases:

5.2.2 Soundness of the proof rule for equivalent computation
for terminating programs

1. Def (S) ∩ X = ∅: Imp (S, X) = X;
2. S = “id := e” or “input id” or “output e” and Def(S) ∩ X 6=
∅:
Imp(S, X) = Use(S) ∪ (X \ Def(S));
3. S = “If (e) then {St } else
S {Sf }” and Def(S) ∩ X 6= ∅: 
Imp(S, X) = Use(e)∪ y∈X Imp(St , {y})∪Imp(Sf , {y}) ;
4. S = “while(e) {S ′ }” where (Def(S ′ ) ∩ X) 6= ∅): Imp (S, X)
S
i
= i≥0 Imp (S ′ , Use(e) ∪ X);
5. For k > 0, S = s1 ; ...; sk+1 :
Imp(S, X) = Imp(s1 ; ...; sk , Imp(sk+1 , X))

We show that if two programs satisfy the proof rule of equivalent
computation of a variable x (Definition 12) and their value stores
in initial states agree on values of the imported variables relative
to x, then the two programs compute the same value of x if they
terminate. We start by proving the theorem for the base cases of
terminating computation equivalently.
Theorem 1. If s1 and s2 are simple statements that satisfy the
proof rule for equivalent computation of x, s1 ≡S
x s2 , and their initial states m1 (σ1 ) and m2 (σ2 ) agree on the values of the imported
variables relative to x, ∀y ∈ Imp(s1 , {x}) ∪ Imp(s2 , {x}) :
σs1 (y) = σs2 (y), then s1 and s2 equivalently compute x when
started in states m1 and m2 respectively, (s1 , m1 ) ≡x (s2 , m2 ).

Definition 11. (Base cases of the proof rule for equivalent computation for terminating programs) Two simple statements s1
and s2 satisfy the proof rule of equivalent computation of a variable
x, written s1 ≡S
x s2 , iff one of the following holds:

Proof. The proof is a case analysis according to the cases in the
definition of the proof rule for equivalent computation (i.e., Definition 11).

1. s1 = s2 ;
2. s1 =
6 s2 and one of the following holds:
(a) s1 = “input id1 ”, s2 = “input id2 ”, x ∈
/ {id1 , id2 };
(b) Case a) does not hold and x ∈
/ Def(s1 ) ∪ Def(s2 );

1. s1 = s2
Since the two statements are identical, they have the same
imported variables. By assumption, the imported variables of
s1 and s2 have the same initial values, so it is enough to show
Definition 12. (Proof rule of equivalent computation for terthat the value of x at the end of the computation only depends
minating programs) Two statement sequences S1 and S2 satisfy
on the initial values of the imported variables.
the proof rule of equivalent computation of a variable x, written
(a) s1 = s2 = “skip”. In this case, the states before and after
S1 ≡ S
x S2 , iff one of the following holds:
the execution of skip are the same and Imp(skip, {x}) =
1. S1 and S2 are one statement and one of the following holds:
{x}.
(a) S1 and S2 are simple statement: s1 ≡S
(b) s1 = s2 = “lval := e”.
x s2 ;
i. lval = x.
(b) S1 = “If (e) then {S1t } else {S1f }”, S2 = “If (e) then {S2t } else
s1 = s2 = “x := e”. By the definition of imported
{S2f }” such that all of the following hold:
variables, Imp(x := e, {x}) = Use(e). The execution
• x ∈ Def(S1 ) ∩ Def(S2 );
of s1 proceeds as follows.
f
f
t
S
• (S1t ≡S
x S2 ) ∧ (S1 ≡x S2 );
(x := e, m(σ))
(c) S1 = “whilehn1 i (e) {S1′′ }”, S2 = “whilehn2 i (e) {S2′′ }”
→(x := E ′ JeKσ, m(σ)) by the EEval’ rule
such that both of the following hold:
→(skip, m(σ[E ′JeKσ/x])) by the Assign rule.
• x ∈ Def(S1 ) ∩ Def(S2 );
The value of x after the full execution is σ[(E JeKσ)/x](x)
′′
• ∀y ∈ Imp(S1 , {x}) ∪ Imp(S2 , {x}) : S1′′ ≡S
y S2 ;
which only depend on the initial values of the imported
10

2015/9/14

Similarly, (s2 , m2 ) → (skip, m2 (σ2 [tl(σ2 (idI ))/id2 ]
[“σ2 (idIO ) · hd(σ2 (idI ))”/idIO ][hd(σ2 (idI ))/id2 ])).
Let σ2′ = σ2 [tl(σ2 (idI ))/idI ][“σ2 (idIO )·hd(σ2 (idI ))”/idIO ]
[hd(σ2 (idI ))/id2 ]. Then the value of x after the execution of s2 is one of the following:
A. σ2′ (x) = tl(σ2 (idI )) if x = idI
B. σ2′ (x) = σ2 (idIO ) · hd(σ2 (idI )) if x = idIO
Repeatedly, σ2 (idI ) = σ1 (idI ) and σ2 (idIO ) =
σ1 (idIO ). Therefore, the theorem holds.
ii. x ∈
/ {idI , idIO }
Repeatedly, x ∈
/ {id1 , id2 }. By same argument in the
subcase id 6= x of case s1 = s2 = “id := e”, the
theorem holds.
(b) all the above cases do not hold and x ∈
/ Def(s1 ) ∪ Def(s2 )
By same argument in the subcase id 6= x of case s1 = s2 =
“id := e”, the theorem holds.

variables by the property of the expression meaning
function.
ii. lval 6= id.
By the definition of imported variables, Imp(s1 , {x}) =
Imp(s2 , {x}) = {x}. It follows, by assumption, that
∗
σ1 (x) = σ2 (x) and also s1 terminate, (s1 , m1 (σ1 )) →
′
′
′
(skip, m1 (σ1 )). Hence, σ1 (x) = σ1 (x) by Corol∗
lary E.2. Similarly, s2 terminates, (s2 , m2 (σ2 )) →
′
′
′
′
(skip, m2 (σ2 )) and σ2 (x) = σ2 (x). Therefore, σ2 (x) =
σ2 (x) = σ1 (x) = σ1′ (x) and the theorem holds.
(c) s1 = s2 = “input id”.
i. x ∈ Def(input id) = {id, idI , idIO }.
By the In rule, the execution of input id is the following.
(input id, m(σ))
→(skip, m(σ[tl(σ(idI ))/idI ]
[“σ(idIO ) · hd(σ(idI ))”/idIO ][hd(σ(idI ))/id])).
The value of x after the execution of “input id” is one of
the following:
A. tl(σ(idI )) if x = idI .
B. σ1 (idIO ) · hd(σ(idI )) if x = idIO .
C. hd(σ(idI )) if x = id.
By the definition of imported variables, Imp(input id, {x})
= {idIO , idI }. So, in all cases, the value of x only depends on the initial values of the imported variables idI
and idIO .
ii. x ∈
/ Def(input id) = {id, idI , idIO }.
By same argument in the subcase id 6= x of case s1 =
s2 = “id := e”, the theorem holds.
(d) s1 = s2 = “output e”.
i. x = idIO
By the definition of imported variables, Imp(output e, {x}) =
{idIO } ∪ Use(e). The execution of s1 proceeds as follows.
(output e, m(σ))
→(output E JeKσ, m(σ))
¯
→(skip, m(σ[“σ(idIO ) · E JeKσ”/id
IO ])).
¯
The value of x after the execution is “σ(idIO ) · E JeKσ”,
which only depends on the initial value of the imported
variables of the statement “output e” by the expression
meaning function.
ii. x 6= idIO
By same argument in the subcase id 6= x of case s1 =
s2 = “id := e”, the theorem holds.

Theorem 2. If statement sequence S1 and S2 satisfy the proof
rule of equivalent computation of a variable x, S1 ≡S
x S2 , and
their initial states m1 (σ1 ) and m2 (σ2 ) agree on the initial values of the imported variables relative to x, ∀y ∈ Imp(S1 , {x}) ∪
Imp(S2 , {x}) : σ1 (y) = σ2 (y), then S1 and S2 equivalently compute the variable x when started in state m1 and m2 respectively,
(S1 , m1 ) ≡x (S2 , m2 ).
Proof. By induction on size(S1 )+size(S2 ), the sum of the program
size of S1 and S2 .
Base case.
S1 ≡ S
x S2 where S1 and S2 are two simple statements. This
theorem holds by theorem 1.
Induction step
The hypothesis IH is that Theorem 2 holds when size(S1 ) +
size(S2 ) = k ≥ 2.
Then we show that the Theorem holds when size(S1 )+size(S2 ) =
k + 1. The proof is a case analysis according to the cases in the
definition of the proof rule of terminating computation of statement
sequence. the two big categories enum

1. S1 and S2 are one statement such that one of the following
holds:
(a) S1 and S2 are If statement that define the variable x:
S1 = “If (e) then {S1t } else {S1f }”, S2 = “If (e) then {S2t }
else {S2f }” such that all of the following hold:
• x ∈ Def(S1 ) ∩ Def(S2 );
2. s1 6= s2
t
• S1t ≡S
x S2 ;
f
S
(a) s1 = “input id1 ”, s2 = “input id2 ”, x ∈
/ {id1 , id2 }.
• S1 ≡x S2f ;
i. x ∈ {idI , idIO }.
We first show that the evaluations of the predicate expresBy the definition of imported variables, Imp(s1 , {x}) =
sion of S1 and S2 produce the same value when started from
Imp(s2 , {x}) = {idIO , idI }. It follows, by assumption,
state m1 (σ1 ) and m2 (σ2 ), w.l.o.g. say zero. Next, we show
that σ1 (y) = σ2 (y), ∀y ∈ {idIO , idI }. The execution
that S1f started in the state m1 and S2f in the state m2 equivof s1 proceeds as follows.
alently compute the variable x.
(s1 , m1 )
In order to show that the evaluations of predicate ex= (input id1 , m1 (σ1 ))
pression of S1 and S2 produce same value when started
→(skip, m1 (σ1 [tl(σ1 (idI ))/idI ]
from state m1 (σ1 ) and m2 (σ2 ), we show that the vari[“σ1 (idIO ) · hd(σ1 (idI ))”/idIO ][hd(σ1 (idI ))/id1 ]))
ables used in predicate expression of S1 and S2 are a
subset of imported variables in S1 and S2 relative to
′
Let σ1 = σ1 [tl(~v )/idI , “σ1 (idIO )·hd(~v)”/idIO , hd(~v )/id1 ].
x. This is true by the definition of imported variables,
The value of x after the execution of s1 is one of the folUse(e) ⊆ Imp(S1 , {x}), Use(e) ⊆ Imp(S2 , {x}). By aslowing:
sumption, the value stores σ1 and σ2 agree on the values
A. σ1′ (x) = tl(σ1 (idI )) if x = idI .
of the variables used in predicate expression of S1 and
B. σ1′ (x) = σ1 (idIO ) · hd(σ1 (idI )) if x = idIO .
S2 , σ1 (y) = σ2 (y), ∀y ∈ Use(e). By the property of
11

2015/9/14

the values of the imported variables in S1′′ and S2′′ relative to the variables Imp(∆).
By Lemma 5.2, we show S1 and S2 compute the variable
x equivalently when started from state m1 (m1c , σ1 ) and
m2 (m2c , σ2 ) respectively. The theorem holds.
(c) S1 and S2 do not define the variable x: x ∈
/ Def(S1 ) ∪
(S1 , m1 (σ1 ))
Def(S2 ).
f
t
= (If (e) then {S1 } else {S1 }, m1 (σ1 ))
By the definition of imported variable, the imported vari→(If ((0, vof )) then {S1t } else {S1f }, m1 (σ1 ))
ables in S1 and S2 relative to x are both x, Imp(S1 , {x}) =
by the EEval’ rule
Imp(S2 , {x}) = {x}. By assumption, the initial values
σ1 and σ2 agree on the value of the variable x, σ1 (x) =
→(If (0) then {S1t } else {S1f }, m1 (σ1 ))
σ2 (x). In addition, by assumption, execution of S1 and
by the E-Oflow1 or E-Oflow2 rule
S2 when started in state m1 (σ1 ) and m2 (σ2 ) terminate,
→(S1f , m1 (σ1 )) by the If-F rule.
∗
∗
(S1 , m1 (σ1 )) → (skip, m′1 (σ1′ )), (S2 , m2 (σ2 )) → (skip, m′2 (σ2′ )).
f
Finally,
by
Corollary
E.2,
the
value
of
x
is
not
changed
in
Similarly, the execution from (s2 , m2 (σ2 )) gets to (S2 , m2 (σ2 )).
′
′
f
f
execution
of
S
1 and S2 , σ1 (x) = σ1 (x) = σ2 (x) = σ2 (x).
By the hypothesis IH, we show that S1 and S2 compute the
The theorem holds.
variable x equivalently when started in state m1 (σ1 ) and
2.
S
1 and S2 are not both one statement such that one of the
m2 (σ2 ) respectively. To do that, we show that all required
following holds:
conditions are satisfied for the application of hypothesis IH.
(a) Last statements both define the variable x such that all of
• size(S1f ) + size(S2f ) < k.
the following hold:
Because size(S1 ) = 1+size(S1t )+size(S1f ), size(S2 ) =
′
• S1′ ≡S
y S2 , ∀y ∈ Imp(s1 , {x}) ∪ Imp(s2 , {x});
1 + size(S2t ) + size(S2f ).
• x ∈ Def(s1 ) ∩ Def(s2 );
• the value stores σ1 and σ2 agree on the values of the
• s1 ≡S
imported variables in S1f and S2f relative to x, σ1 (y) =
x s2 ;
We show that S1′ and S2′ compute the imported variables in
σ2 (y), ∀y ∈ Imp(S1f , {x}) ∪ Imp(S2f , {x}).
s1 and s2 relative to the variable x equivalently when started
By the definition of imported variables,
in state m1 (σ1 ) and m2 (σ2 ) respectively by the hypothesis
Imp(S1f , {x}) ⊆ Imp(S1 , {x}), Imp(S2f , {x}) ⊆ Imp(S2 , {x}).
IH. To do that, we show the required conditions are satisfied
By the hypothesis IH, S1f and S2f compute the variable
for applying the hypothesis IH.
x equivalently when started in state m1 (σ1 ) and m2 (σ2 )
• size(S1′ ) + size(S2′ ) < k.
respectively. Therefore, the theorem holds.
By the definition of program size, size(s1 ) ≥ 1,
(b) S1 and S2 are while statement that define the variable x:
size(s2 ) ≥ 1. Hence, size(S1′ ) + size(S2′ ) < k.
′′
′′
S1 = “whilehn1 i (e) {S1 }”, S2 = “whilehn2 i (e) {S2 }”
• the executions from (S1 , m1 (σ1 )) and (S2 , m2 (σ2 ))
such that both of the following hold:
terminate respectively,
• x ∈ Def(S1 ) ∩ Def(S2 );
∗
∗
(S1′ , m1 (σ1 )) → (skip, m′′1 (σ1′′ )), (S2′ , m2 (σ2 )) →
′′
S
′′
• S1 ≡y S2 for ∀y ∈ Imp(S1 , {x}) ∪ Imp(S2 , {x});
′′
′′
(skip, m2 (σ2 )).
By Lemma 5.2, we show S1 and S2 compute the variBy assumption, the execution from (S1 , m1 (σ1 )) and
1
able x equivalently when started from state m1 (mc , σ1 )
(S2 , m2 (σ2 )) terminate, then the execution of S1′ and
and m2 (m2c , σ2 ) respectively. The point is to show that
∗
S2′ from state m1 (σ1 ) and m2 (σ2 ) terminate, (S1′ , m1 (σ1 )) →
all required conditions are satisfied for the application of
∗
′′
′′
′
′′
′′
(skip, m1 (σ1 )), (S2 , m2 (σ2 )) → (skip, m2 (σ2 )).
lemma 5.2.
• the initial value stores agree on the values of the vari• loop counter value of S1 and S2 are zero.
ables:
By our assumption, the loop counter value of S1 and S2
Imp(S1′ , Imp(s1 , {x})) ∪ Imp(S2′ , Imp(s2 , {x})).
are initially zero.
By
Lemma 5.3, s1 and s2 have the same imported
• S1 and S2 have same imported variables relative to x,
variables
relative to x, Imp(s1 , {x}) = Imp(s2 , {x})
Imp(S1 , {x}) = Imp (S2 , {x}) = Imp(∆).
= Imp(x). By the definition of imported variables, imThis is obtained by Lemma 5.3.
ported variables in S1′ relative to Imp(x) are same as the
• the initial value store σ1 and σ2 agree on the values
imported variables in S1 relative to x, Imp(S1′ , Imp(s1 , {x})) =
of the imported variables in S1 and S2 relative to x,
Imp(S1 , {x}). Similarly, Imp(S2′ , Imp(s2 , {x})) =
σ1 (y) = σ2 (y), ∀y ∈ Imp(S1 , {x}) ∪ Imp(S2 , {x}).
Imp(S2 , {x}). Then, by assumption, the initial value
By assumption, this holds.
stores agree on the values of the variables Imp(S1′ , Imp(s1 , {x}))
• S1′′ and S2′′ compute the imported variables in S1 and
and
∀y ∈ Imp(S1′ , Imp(s1 , {x})) ∪ Imp(S2′ , Imp(s2 , {x})),
S2 relative to x equivalently, (S1′′ , mS1′′ (σS1′′ )) ≡y
′
Imp(S
2 , Imp(s2 , {x})), σ1 (y) = σ2 (y).
(S2′′ , mS2′′ (σS2′′ )), ∀y ∈ Imp(∆) with value stores σS1′′
By the hypothesis IH, after the full execution of S1′ from
and σS2′′ agreeing on the values of the imported varistate m1 (σ1 ) and the execution of S2′ from state m2 (σ2 ),
ables in S1′′ and S2′′ relative to Imp(∆), σS1′′ (z) =
the value stores agree on the values of the imported variables
in s1 and s2 relative to x, σ1′′ (y) = σ2′′ (y), ∀y ∈ Imp (x) =
σS2′′ (z), ∀z ∈ Imp(S1′′ , Imp(∆)) ∪ Imp(S2′′ , Imp(∆)).
Imp (s1 , {x}) = Imp (s2 , {x}).
By the definition of program size, the sum of the proThen, we show s1 and s2 compute x equivalently. By Corolgram size of S1′ and S2′ is less than k, size(S1′′ ) +
lary E.1, s1 and s2 continue execution after the full exsize(S2′′ ) < k. By the hypothesis IH, S1′′ and S2′′ com∗
ecution of S1′ and S2′ respectively, (S1′ ; s1 , m1 (σ1 )) →
pute the imported variables in S1 and S2 relative to
∗
′′
′′
′
′′
′′
′′
′′
x equivalently when started in states mS1 (σS1 ) and
(s1 , m1 (σ1 )), (S2 ; s2 , m2 (σ2 )) → (s2 , m2 (σ2 )). When
s1 and s2 are while statements, by our assumption of unique
mS2′′ (σS2′′ ) with value store σS1′′ and σS2′′ agreeing on
expression meaning function E , the predicate expression
of S1 and S2 evaluate to the same value when started in
states m1 (σ1 ) and m2 (σ2 ), E JeKσ1 = E JeKσ2 , w.l.o.g,
E JeKσ1 = E JeKσ2 = (0, vof ). Then the execution of S1
proceeds as follows.

12

2015/9/14

loop labels, s1 is not in S1′ . By Corollary E.4, the loop
counter value of s1 is not redefined in the execution of S1′ .
Similarly, the loop counter value of s2 is not redefined in the
execution of S2′ . By the hypothesis IH again, after the full
execution of s1 and s2 , the value stores agree on the value
∗
∗
of x, (s1 , m′′1 (σ1′′ )) → (skip, m′1 (σ1′ )), (s2 , m′′2 (σ2′′ )) →
′
′
′
′
(skip, m2 (σ2 )) such that σ1 (x) = σ2 (x). The theorem
holds.
(b) One last statement does not define the variable x: W.l.o.g.,
′
(x ∈
/ Def(s2 )) ∧ (S1 ≡S
x S2 ).
We show that S1 and S2′ compute the variable x equivalently when started from state m1 (σ1 ) and m2 (σ2 ) by
the hypothesis IH. First, by the definition of program size,
size(s2 ) ≥ 1. Hence, size(S1 ) + size(S2′ ) ≤ k . Next,
by the definition of imported variables, Imp (S2′ , {x}) ⊆
Imp (S2 , {x}). By assumption, σ1 (y) = σ2 (y) for ∀y ∈
Imp (S2′ , {x}) ∪ Imp (S1 , {x}). By the hypothesis IH, S1
and S2′ compute the variable x equivalently when started in
∗
state m1 (σ1 ) and m2 (σ2 ) respectively, (S2′ , m2 (σ2 )) →
∗
′′
′′
′
′
(skip, m2 (σ2 )), (S1 , m1 (σ1 )) → (skip, m1 (σ1 )) such
that σ1′ (x) = σ2′′ (x).
Then, we show that S1 and S2 compute the variable x equivalently after the full execution of s2 . By Corollary E.1,
s2 continues execution immediately after the full execu∗
tion of S2′ , (S2′ ; s2 , m2 ) → (s2 , m′′2 ). By assumption, the
∗
′
execution from (S2 ; s2 , m2 ) terminates, (s2 , m′′2 (σ2′′ )) →
(skip, m′2 (σ2′ )). By Corollary E.2, the value of x is not
changed in the execution of s2 , σ2′ (x) = σ2′′ (x). Hence,
σ1′ (x) = σ2′ (x). The theorem holds.
(c) There are statements moving in/out of If statement:
s1 = “If (e) then {S1t } else {S1f }”, s2 = “If (e) then {S2t }
else {S2f }” such that none of the above cases hold and all
of the following hold:
′
• S1′ ≡S
y S2 for ∀y ∈ Use(e);
′
t
S
• S1 ; S1 ≡x S2′ ; S2t ;
f
′
• S1′ ; S1f ≡S
x S2 ; S2 ;
• x ∈ Def(s1 ) ∩ Def(s2 );
Repeatedly S1 = S1′ ; s1 , S2 = S2′ ; s2 . We first show that,
after the full execution of S1′ and S2′ started in state m1 and
m2 , the predicate expression of s1 and s2 evaluate to the
same value, w.l.o.g, zero. Next we show that S1 and S1′ ; S1f
compute the variable x equivalently when (1) both started
in state m1 and (2) the predicate expression of s1 evaluates
to zero after the full execution of S1′ started in state m1 ,
similarly S2 and S2′ ; S2f compute the variable x equivalently
when (1) both started in the state m2 and (2) the predicate
expression of s2 evaluates to zero after the full execution of
S1′ when started in state m2 . Last we prove the theorem by
showing that S1′ ; S1f started in state m1 and S2′ ; S2f started
in state m2 compute the variable x equivalently.

cution of S1′ and S2′ terminate when started in state m1
and m2 respectively.
• the initial value stores σ1 and σ2 agree on the values
of the imported variables in S1′ and S2′ relative to the
variables used in the predicate expression of s1 and s2 .
By Lemma 5.3, the imported variables in S1′ and S2′ relative to the variables used in predicate expression of s1
and s2 are same, Imp(S1′ , Use(e)) = Imp(S2′ , Use(e)) =
Imp(e). By the definition of imported variable, the imported variables in S1′ relative to the variables used in
predicate expression of s1 are a subset of the imported
variables in S1 relative to x respectively, Imp(S1′ , Use(e)) ⊆
Imp(S1′ , Imp(s1 , {x})) = Imp(S1 , {x}). Similarly
Imp(S2′ , Use(e)) ⊆ Imp(S2 , {x}). Then, by assumption, the initial value stores agree on the values of the
imported variables in S1′ and S2′ relative to the variables used in the predicate expression of s1 and s2 ,
σ1 (y) = σ2 (y), ∀y ∈ Imp(e) = Imp(S1′ , Use(e)) =
Imp(S2′ , Use(e)).
By the hypothesis IH, after the full execution of S1′ and
S2′ , the value stores agree on the values of the variables
used in the predicate expression of s1 and s2 , σ1′′ (y) =
σ2′′ (y), ∀y ∈ Use(e). By Corollary E.1, s1 and s2 continue execution after the full execution of S1′ and S2′ respec∗
∗
tively, (S1′ ; s1 , m1 ) → (s1 , m′′1 (σ1′′ )), and (S2′ ; s2 , m2 ) →
′′
′′
(s2 , m2 (σ2 )).
By the property of expression meaning function E , expression e evaluates to the same value w.r.t value stores σ1′′ and
σ2′′ , w.l.o.g., zero, E JeKσ1′′ = E JeKσ2′′ = 0. Then the execution of s1 proceeds as follows.
(s1 , m′′1 (σ1′′ ))
= (If (e) then {S1t } else {S1f }, m′′1 (σ1′′ ))
→(If (0) then {S1t } else {S1f }, m′′1 (σ1′′ )) by the EEval rule.
→(S1f , m′′1 (σ1′′ )) by the If-F rule.

Similarly, the execution from (s2 , m′′2 (σ2′′ )) gets to (S2f , m′′2 (σ2′′ )).
Then, we show that S1 and S1′ ; S1f compute the variable
x equivalently when both started from state m1 (σ1 ). The
execution of S1′ ; S1f started from state m1 also gets to configuration (S1f , m′′1 (σ1′′ )) because execution of S1 = S1′ ; s1
∗
and S1′ ; S1f share the common execution (S1′ , m1 ) →
f
(skip, m′′1 (σ1′′ )). By Corollary E.1, S1 continues execution
∗
after the full execution of S1′ , (S1′ ; S1f , m1 ) → (S1f , m′′1 ).
f
′
Therefore, the execution of S1 and S1 ; S1 from state m1
compute the variable x equivalently because both executions get to same intermediate configuration. Similarly, S2
and S2′ ; S2f compute the variable x equivalently when both
started from state m2 (σ2 ).
Lastly, we show that S1′ ; S1f and S2′ ; S2f compute the variable x equivalently when started in states m1 (σ1 ) and
m2 (σ2 ) respectively by the hypothesis IH. To do that, we
show that all required conditions are satisfied for the application of hypothesis IH.
• size(S1′ ; S1f ) + size(S2′ ; S2f ) < k.
This is obtained by the definition of program size.
• execution of S1′ ; S1f and S2′ ; S2f terminate when started
in state m1 (σ1 ) and m2 (σ2 ) respectively.
This is obtained by above argument.
• σ1 (y) = σ2 (y), ∀y ∈ Imp(S1′ ; S1f , {x})∪Imp(S2′ ; S2f , {x}).
We show that Imp(S1′ ; S1f , {x}) ⊆ Imp(S1 , {x}) as
follows.
Imp(S1f , {x})

In order to show that S1′ and S2′ compute the variables
used in predicate expression of s1 and s2 equivalently by
the hypothesis IH, we show that all required conditions are
satisfied for the application of hypothesis IH.
• size(S1′ ) + size(S2′ ) < k.
The sum of program size of S1′ and S2′ are less than k by
the definition of program size for s1 and s2 , size(S1′ ) +
size(S2′ ) < k.
∗
• the execution of S1′ and S2′ terminate, (S1′ , m1 ) →
∗
′′
′′
′
′′
′′
(skip, m1 (σ1 )), and (S2 , m2 ) → (skip, m2 (σ2 )).
By assumption, the execution of S1 and S2 from the
state m1 and m2 respectively terminate, then the exe-

13

2015/9/14

⊆ Imp(s1 , {x}) (1) by the definition of imported variables.
Imp(S1′ ; S1f , {x})
= Imp(S1′ , Imp(S1f , {x})) by Lemma
⊆ Imp(S1′ , Imp(s1 , {x})) by (1)

C.1

= Imp(S1 , {x}) by the definition of imported variables.
Imp(S2′ ; S2f , {x})

Similarly,
⊆ Imp(S2 , {x}). Then, by
assumption, the initial value stores agree on the values
of the imported variables in S1′ ; S1f and S2′ ; S2f relative
to x.
Then, by the hypothesis IH, after the full execution of
S1′ ; S1f and S2′ ; S2f , the value stores agree on the value
∗
∗
of x, (S1′ ; S1f , m1 ) → (skip, m′1 (σ1′ )), (S2′ ; S2f , m2 ) →
′
′
′
′
(skip, m2 (σ2 )) such that σ1 (x) = σ2 (x).
In conclusion, after execution of S1 and S2 , the value stores
agree on the value of x. Therefore, the theorem holds.

′

∗

∗

• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) →
′

(s1 , m1i (loop1ci , σ1i )), loop1c (n1 ) ≤ i; and
′
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) →
′
2
2i
(s2 , m2i (loopc , σ2i )), loopc (n2 ) ≤ i;
Proof. By induction on i.
Base case. i = 1.
By assumption, initial loop counters of s1 and s2 are of value
zero. Initial value stores σ1 and σ2 agree on the values of the
variables in Imp(x). Then we show one of the following cases hold:
1. The loop counters for s1 and s2 are always less than 1:
′
∗
∀m′1 , m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 )
′
∗
′
′
2′
1′
→ (S2 , m2 (loopc )), loopc (n1 ) < 1 and loop2c (n2 ) < 1;
2. There are two configurations (s1 , m11 ) and (s2 , m21 ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which the
loop counters of s1 and s2 are equal to 1 and value stores agree
on the values of imported variables relative to x and, for ev∗
∗
ery state in execution, (s1 , m1 ) → (s1 , m11 ) or (s2 , m2 ) →
(s2 , m21 ) the loop counters for s1 and s2 are less than or equal
to one respectively:
∗
∃(s1 , m11 ), (s2 , m21 ) : (s1 , m1 ) → (s1 , m11 (loop1c1 , σ11 ))∧
∗
21
(s2 , m2 ) → (s2 , m21 (loopc , σ21 )) where
• loop1c 1 (n1 ) = loop2c 1 (n2 ) = 1; and
• ∀y ∈ Imp(x) : σ11 (y) = σ21 (y); and
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m11 (loop1c 1 , σ11 )),
′
1
loopc (n1 ) ≤ 1; and
′
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m21 (loop2c 1 , σ21 )),
2′
loopc (n2 ) ≤ 1.

5.2.3 Supporting lemmas for the soundness proof of
equivalent computation for terminating programs
The lemmas include the proof of two while statements computing a
variable equivalently used in the proof of Theorem 2 and the property that two programs have same imported variables relative to a
variable x if the two programs satisfy the proof rule of equivalent
computation of the variable x. From the proof rule of terminating
computation of a variable x equivalently, we have the two programs
either both define x or both do not.
Lemma 5.1. Let s1 = “whilehn1 i (e) {S1 }” and s2 = “whilehn2 i (e)
{S2 }” be two while statements with the same set of imported variables relative to a variable x (defined in s1 and s2 ), Imp(x), and
whose loop bodies S1 and S2 terminatingly compute the variables
in Imp(x) equivalently when started in states that agree on the
values of the variables imported by S1 or S2 relative to Imp(x):

We show evaluations of the predicate expression of s1 and s2
w.r.t value stores σ1 and σ2 produce same S
value. By the definition of imported variables, Imp(s1 , {x}) = j≥0 Imp(S1j , {x} ∪
Use(e)). By our notation of S 0 , S10 = skip. By the definition of
imported variables, Imp(S10 , {x} ∪ Use(e)) = {x} ∪ Use(e). Then
Use(e) ⊆ Imp(x). By assumption, value stores σ1 and σ2 agree
on the values of the variables in Use(e). By Lemma D.1, the predicate expression e of s1 and s2 evaluates to same value v w.r.t value
stores σ1 , σ2 , E ′ JeKσ1 = E ′ JeKσ2 = v. Then there are two possibilities to consider.

• x ∈ Def(s1 ) ∩ Def(s2 );
• Imp(s1 , {x}) = Imp(s2 , {x}) = Imp(x);
• ∀y ∈ Imp(x), ∀mS1 (σS1 ), mS2 (σS2 ) :

((∀z ∈ Imp(S1 , Imp(x)) ∪ Imp(S2 , Imp(x)) : σS1 (z) =
σS2 (z)) ⇒ (S1 , mS1 (σS1 )) ≡y (S2 , mS2 (σS2 ))).

If the executions of s1 and s2 terminate when started in
states m1 (loop1c , σ1 ) and m2 (loop2c , σ2 ) in which s1 and s2
have not already executed (loop counter initially 0: loop1c (n1 ) =
loop2c (n2 ) = 0), and whose value stores σ1 and σ2 agree on the
values of the variables in Imp(x), ∀y ∈ Imp(x), σ1 (y) = σ2 (y),
then, for any positive integer i, one of the following holds:

1. E ′ JeKσ1 = E ′ JeKσ2 = v = 0
The execution from (s1 , m1 (loop1c , σ1 )) proceeds as follows.
(s1 , m1 (loop1c , σ1 ))
= (whilehn1 i (e) {S1 }, m1 (loop1c ))
→(whilehn1 i (0) {S1 }, m1 (loop1c )) by the EEval’ rule
→(skip, m1 (loop1c [0/n1 ])) by the Wh-F rule.

1. The loop counters for s1 and s2 are always less than i:
′
∗
∀m′1 , m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c ) and (s2 , m2 )
′
∗
→ (S2′ , m′2 (loop2c )),
′
′
loop1c (n1 ) < i and loop2c (n2 ) < i;
2. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which the
loop counters of s1 and s2 are equal to i and value stores agree
on the values of imported variables relative to x and, for ev∗
∗
ery state in execution, (s1 , m1 ) → (s1 , m1i ) or (s2 , m2 ) →
(s2 , m2i ) the loop counters for s1 and s2 are less than or equal
to i respectively:
∗
∃(s1 , m1i ), (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (loop1ci , σ1i )) ∧
∗
2i
(s2 , m2 ) → (s2 , m2i (loopc , σ2i )) where
• loop1c i (n1 ) = loop2c i (n2 ) = i; and
• ∀y ∈ Imp(x) : σ1i (y) = σ2i (y) and

2

Similarly, (s2 , m2 (loop2c , σ2 )) → (skip, m2 (loop2c [0/n2 ])).
In conclusion, the loop counters of s1 and s2 in any states of
the execution from (s1 , m1 ) and (s2 , m2 ) respectively are less
′
∗
than 1, ∀m′1 , m′2 such that (s1 , m1 ) → (S1 ′ , m′1 (loop1c ) and
′
′
′
∗
(s2 , m2 ) → (S2 ′ , m′2 (loop2c )), loop1c (n1 ) < 1, loop2c (n2 ) <
1.
2. E ′ JeKσ1 = E ′ JeKσ2 = v 6= 0
The execution from (s1 , m1 (loop1c , σ1 )) proceeds as follows.
(s1 , m1 (loop1c , σ1 ))
= (whilehn1 i (e) {S1 }, m1 (loop1c , σ1 ))
→(whilehn1 i (v) {S1 }, m1 (loop1c , σ1 )) by the EEval’ rule
→(S1 ; whilehn1 i (e) {S1 }, m1 (loop1c [1/(n1 )], σ1 ))
by the Wh-T rule.

14

2015/9/14

2

The induction hypothesis IH is that, for a positive integer i, one of
Similarly, (s2 , m2 (loop2c , σ2 )) → (S2 ; whilehn2 i (e){S2 }, m2
2
the
following holds:
(loopc [1/(n2 )], σ2 )). Then, the loop counters of s1 and s2 are
1, value stores σ11 and σ21 agree on values of variables in
1. The loop counters for s1 and s2 are always less than i:
′
Imp(x): loop1c [1/n1 ](n1 ) =
∗
∗
∀m′1 , m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c ) and (s2 , m2 ) →
loop2c [1/(n2 )](n2 ) = 1; and ∀y ∈ Imp(x), σ11 (y) = σ21 (y).
′
′
2′
(S2 , m2 (loopc )),
By assumption, the execution of s1 terminates when started in
′
′
loop1c (n1 ) < i and loop2c (n2 ) < i;
the state m1 (, σ1 ), then the execution of S1 terminates when
∗
1
2. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable
started in the state m1 (loopc [1/(n1 )], σ1 ), (s1 , m1 ) →
∗
from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop
(S1 ; whilehn1 i (e){S1 }, m1 (loop1c [1/(n1 )], σ1 )) → (skip, m′1 ) ⇒
counters of s1 and s2 are equal to i and value stores agree on the
∗
(S1 , m1 (loop1c [1/(n1 )], σ1 )) → (skip, m11 (loop1c1 , σ11 )).
values of imported variables relative to x and, for every state in
Similarly, the execution of S2 terminates when started in the
∗
∗
execution, (s1 , m1 ) → (s1 , m1i ) and (s2 , m2 ) → (s2 , m2i )
state m2 (loop2c [1/(n2 )], σ2 ),
the loop counters for s1 and s2 are less than or equal to i
∗
(S2 , m2 (loop2c [1/(n2 )], σ2 )) → (skip, m21 (loop2c1 , σ21 )).
respectively:
We show that, after the full execution of S1 and S2 , the follow∗
∃(s1 , m1i ), (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (loop1ci , σ1i )) ∧
ing four properties hold.
∗
2i
(s2 , m2 ) → (s2 , m2i (loopc , σ2i )) where
• The loop counters of s1 and s2 are of value 1, loop1c 1 (n1 ) =
21
• loop1c i (n1 ) = loop2c i (n2 ) = i; and
loopc (n2 ) = 1.
• ∀y ∈ Imp(x), σ1i (y) = σ2i (y); and
By assumption of unique loop labels, s1 ∈
/ S1 . Then, the
′
∗
∗
loop counter value of n1 is not redefined in the execution of
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c ) →
11
1
′
1
1i
S1 by corollary E.4, loopc [1/(n1 )](n1 ) = loopc (n1 ) = 1.
(s1 , m1i (loopc , σ1i )), loopc (n1 ) ≤ i; and
′
Similarly, the loop counter value of n2 is not redefined in
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) →
2
21
the execution of S2 , loopc [1/(n2 )](n2 ) = loopc (n2 ) = 1.
2′
2i
∗
(s2 , m2i (loopc , σ2i )), loopc (n2 ) ≤ i.
• In any state in the execution (s1 , m1 ) → (s1 , m11 (loop1c 1 , σ11 )),
the loop counter of s1 is less than or equal to 1.
Then we show that, for the positive integer i + 1, one of the
The loop counter of s1 is zero in any of the two states in
following holds:
the one step execution (s1 , m1 ) → (whilehn1 i (v) {S1 },
1. The loop counters for s1 and s2 are always less than i + 1:
m1 (loop1c , , σ1 )), and the loop counter of s1 is 1 in any
′
∗
states in the execution
∀m′1 , m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 )
∗
1
′
∗
(S1 ; whilehn1 i (e) {S1 }, m1 (loopc [i/(n1 )], σ1 )) →
→ (S2′ , m′2 (loop2c )),
′
′
(s1 , m11 (loop1c1 , σ11 )).
loop1c (n1 ) < i + 1 and loop2c (n2 ) < i + 1;
∗
• In any state in the executions (s2 , m2 ) → (s2 , m21 (loop2c 1 , σ21 )), 2. There are two configurations (s , m
1
1i+1 ) and (s2 , m2i+1 )
the loop counter of s2 is less than or equal to 1.
reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which
By similar argument for the loop counter of s1 .
the loop counters of s1 and s2 are equal to i + 1 and value
• The value stores σ11 and σ21 agree on the values of the
stores agree on the values of imported variables relative to x
∗
imported variables in s1 and s2 relative to the variable x:
and, for every state in executions (s1 , m1 ) → (s1 , m1i+1 ) and
∀y ∈ Imp(x), σ11 (y) = σ21 (y).
∗
(s2 , m2 ) → (s2 , m2i+1 ) the loop counters for s1 and s2 are
We show that the imported variables in S1 relative to those
less
than
or
equal to i + 1 respectively:
in Imp(x) are a subset of Imp(x).
∗
∃(s1 , m1i+1 ), (s2 , m2i+1 ) : (s1 , m1 ) → (s1 , m1i+1 (loop1ci+1 ,
∗
Imp(S1 , Imp(x))
2i+1
σ1i+1 )) ∧ (s2 , m2 ) → (s2 , m2i+1 (loopc , σ2i+1 )) where
= Imp(S1 , Imp(s
1 , {x} ∪ Use(e))) by the definition of Imp(x)
S
• loop1c i+1 (n1 ) = loop2c i+1 (n2 ) = i + 1; and
j
= Imp(S1 , j≥0 Imp(S1 , {x} ∪ Use(e)))
• ∀y ∈ Imp(x), σ1i+1 (y) = σ2i+1 (y); and
by the definition of imported variables
′
∗
∗
S
j
•
∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) →
= j≥0 Imp(S1 , Imp(S1 , {x} ∪ Use(e))) by Lemma C.2
′
S
(s1 , m1i+1 (loop1ci+1 , σ1i+1 )), loop1c (n1 ) ≤ i + 1; and
= j>0 Imp(S1j , {x} ∪ Use(e)) by Lemma C.1
S
′
∗
∗
j
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) →
⊆ j≥0 Imp(S1 , {x} ∪ Use(e))
2′
2i+1
= Imp(s1 , {x} ∪ Use(e)) = Imp(x).
(s2 , m2i+1 (loopc , σ2i+1 )), loopc (n2 ) ≤ i + 1.
Similarly, Imp(S2 , Imp(x)) ⊆ Imp(x). Consequently,
the value stores σ11 and σ21 agree on the values of the
imported variables in S1 and S2 relative to those in Imp(x),
∀y ∈ Imp(S1 , Imp(x)) ∪ Imp(S2 , Imp(x)), σ1 (y) = σ2 (y).
Because S1 and S2 have computation of every variable in
Imp(x) equivalently when started in states agreeing on the
values of the imported variables relative to Imp(x), then
value store σ11 and σ21 agree on the values of the variables
Imp(x), ∀y ∈ Imp(x), σ11 (y) = σ21 (y).
It follows that, by corollary E.1,
∗
(S1 ; s1 , m1 (loop1c [1/n1 ], σ1 )) → (s1 , m11 (loop1c1 , σ11 )) and
∗
2
(S2 ; s2 , m2 (loopc [1/n2 ], σ2 )) → (s2 , m21 (loop2c1 , σ21 )).

By the hypothesis IH, one of the following holds:
1. The loop counters for s1 and s2 are always less than i:
′
∗
∀m′1 , m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c ) and (s2 , m2 )
′
∗
→ (S2′ , m′2 (loop2c )),
′
′
loop1c (n1 ) < i and loop2c (n2 ) < i;
When this case holds, then we have the loop counters for s1 and
s2 are always less than i + 1:
′
∗
∀m′1 , m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c ) and (s2 , m2 )
′
∗
→ (S2′ , m′2 (loop2c )),
′
′
loop1c (n1 ) < i + 1 and loop2c (n2 ) < i + 1.
2. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable
from (s1 , m1 ) and (s2 , m2 ), respectively, in which the loop
counters of s1 and s2 are equal to i and value stores agree on the

Induction Step.

15

2015/9/14

• in any state in the executions
values of imported variables relative to x and, for every state in
∗
∗
∗
(s2 , m2i ) → (s2 , m2i+1 (loop2ci+1 , σ2i+1 )), the loop
executions (s1 , m1 ) → (s1 , m1i ) and (s2 , m2 ) → (s2 , m2i )
counter of s2 is less than or equal to i + 1.
the loop counters for s1 and s2 are less than or equal to i
respectively:
With the hypothesis IH, there are two configurations (s1 , m1i+1 )
∗
and (s2 , m2i+1 ) reachable from (s1 , m1 ) and (s2 , m2 ), re∃(s1 , m1i ), (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (loop1ci , σ1i )) ∧
∗
2i
spectively, in which the loop counters of s1 and s2 are equal
(s2 , m2 ) → (s2 , m2i (loopc , σ2i )) where
to i + 1 and value stores agree on the values of imported
• loop1c i (n1 ) = loop2c i (n2 ) = i; and
variables
relative to x and, for every state in executions
• ∀y ∈ Imp(x), σ1i (y) = σ2i (y); and
∗
∗
(s1 , m1 ) → (s1 , m1i+1 ) and (s2 , m2 ) → (s2 , m2i+1 ) the
∗
∗
′
′
′
1′
1i
• ∀m1 : (s1 , m1 ) → (S1 , m1 (loopc ) → (s1 , m1i (loopc ,
loop counters for s1 and s2 are less than or equal to i + 1
′
, σ1i )), loop1c (n1 ) ≤ i; and
respectively:
′
∗
∗
∃(s1 , m1i+1 ), (s2 , m2i+1 ) :
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2i (loop2c i ,
′
∗
(s1 , m1 ) → (s1 , m1i+1 (loop1ci+1 , σ1i+1 ))∧
), σ2i )), loop2c (n2 ) ≤ i.
∗
By similar argument in base case, evaluations of the predicate
(s2 , m2 ) → (s2 , m2i+1 (loop2ci+1 , σ2i+1 )) where
expression of s1 and s2 w.r.t value stores σ1i and σ2i produce
• loop1c i+1 (n1 ) = loop2c i+1 (n2 ) = i + 1; and
same value. Then there are two possibilities:
• ∀y ∈ Imp(x), σ1i+1 (y) = σ2i+1 (y); and
(a) E ′ JeKσ1i = E ′ JeKσ2i = (0, vof )
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) →
1
The execution from (s1 , m1 (loopc , σ1 )) proceeds as fol1′
1i+1
(s1 , m1i+1 (loopc , σ1i+1 )), loopc (n1 ) ≤ i+1; and
lows.
′
∗
∗
1i
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) →
(s1 , m1i (loopc , σ1i ))
1i
2′
2i+1
= (whilehn1 i (e) {S1 }, m1i (loopc , σ1i ))
(s2 , m2i+1 (loopc , σ2i+1 )), loopc (n2 ) ≤ i + 1.
→(whilehn1 i ((0, vof )) {S1 }, m1i (loop1ci , σ1i )) by the EEval’ rule
→(whilehn1 i (0) {S1 }, m1i (loop1ci , σ1i ))
by the E-Oflow1 and E-Oflow2 rule
→(skip, m1i (loop1ci [0/n1 ], σ1i )) by the Wh-F rule.
Lemma 5.2. Let s1 = “whilehn1 i (e) {S1 }” and s2 = “whilehn2 i (e)
{S2 }” be two while statements with the same set of imported variBy the hypothesis IH, the loop counter of s1 and s2 in any
∗
configuration in executions (s1 , m1 ) → (s1 , m1i (loop1ci , σ1i )) ables relative to a variable x (defined in s1 and s2 ), and whose loop
∗
bodies S1 and S2 terminatingly compute the variables in Imp(x)
and (s2 , m2 ) → (s2 , m2i (loop2ci , σ2i )) respectively are
equivalently when started in states that agree on the values of the
less than or equal to i,
variables imported by S1 or S2 relative to Imp(x):
∗
∗
1′
′
′
′
1i
∀m1 : (s1 , m1 ) → (S1 , m1 (loopc ) → (s1 , m1i (loopc ,
′
• x ∈ Def(s1 ) ∩ Def(s2 );
, σ1i )), loop1c (n1 ) ≤ i; and
∗
∗
2′
′
′
′
2i
• Imp(s1 , {x}) = Imp(s2 , {x}) = Imp(x);
∀m2 : (s2 , m2 ) → (S2 , m2 (loopc )) → (s2 , m2i (loopc ,
• ∀y ∈ Imp(x) ∀mS1 (σS1 ) mS2 (σS2 ) :
2′
), σ2i )), loopc (n2 ) ≤ i.
((∀z ∈ Imp(S1 , Imp(x))∪Imp(S2 , Imp(x)), σS1 (z) = σS2 (z)) ⇒
Therefore, the loop counter of s1 and s2 in any configura((S
1 , mS1 (σS1 )) ≡y (S2 , mS2 (σS2 ))).
tion in executions
∗
(s1 , m1 ) → (skip, m1i (loop1ci \ {(n1 )}, σ1i )) and
If the executions of s1 and s2 terminate when started in
∗
(s2 , m2 ) → (skip, m2i (loop2ci [0/n2 ], σ2i )) respectively
states m1 (loop1c , σ1 ) and m2 (loop2c , σ2 ) in which s1 and s2
are less than i + 1.
have not already executed (loop counter initially 0: loop1c (n1 ) =
(b) E ′ JeKσ1i = E ′ JeKσ2i = v 6= 0
loop2c (n2 ) = 0), and whose value stores σ1 and σ2 agree on
the values of the variables in Imp(x), ∀y ∈ Imp(x) σ1 (y) =
The execution from (s1 , m1i (loop1ci , σ1i )) proceeds as fol∗
lows.
σ2 (y), when s1 and s2 terminate, (s1 , m1 ) → (skip, m1i (σ1′ ))
∗
(s1 , m1i (loop1ci , σ1i ))
and (s2 , m2 ) → (skip, m2i (σ2′ )), value stores σ1′ and σ2′ agree on
the value of x, σ1′ (x) = σ2′ (x).
= (whilehn1 i (e) {S1 }, m1i (loop1ci , σ1i ))
1i
→(whilehn1 i (v) {S1 }, m1i (loopc , σ1i )) by the EEval’ rule
→(S1 ; whilehn1 i (e) {S1 }, m1i (loop1ci [i + 1/(n1 )]
Proof. We show that there must exist a finite integer k such that the
, σ1i )) by the Wh-T rule.
loop counters of s1 and s2 in executions started in states m1 and
2
m2 is always less than k. By the definition of terminating execuSimilarly, (s2 , m2i (loop2ci , σ2i )) → (S2 ; whilehn2 i (e){S2 },
tion, there are only finite number of steps in executions of s1 and
2i
m2i (loopc [i + 1/(n2 )], σ2i )).
s2 started in states m1 and m2 respectively. Then, by Lemma E.8,
By similar argument in base case, the executions of S1
there must be a finite integer k such that the loop counter of s1 and
1i
and S2 terminate when started in states m1i (loopc [i +
s2 is always less than k. In the following, we consider k be the
1/(n1 )], , σ1i ) and m2i (loop2ci [i + 1/(n2 )], σ2i ) respecsmallest positive integer such that the loop counter of s1 and s2 in
∗
tively, (S1 ; s1 , m1i (loop1ci [i + 1/(n1 )], σ1i )) →
executions started in states m1 and m2 is always less than k.
(s1 , m1i+1 (loop1ci+1 , σ1i+1 )) and (S2 ; s1 , m2i (loop2ci [i +
By Lemma 5.1, there are two possibilities:
∗
1/(n2 )], σ2i )) → (s2 , m2i+1 (loop2ci+1 , σ2i+1 )) such that
1. The loop counters for s1 and s2 are always less than 1 (k = 1):
all of the following holds:
′
∗
• loop1c i+1 (n1 ) = loop2c i+1 (n2 ) = i + 1; and
∀m′1 , m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 )
′
∗
′
′
2
• ∀y ∈ Imp(x), σ1i+1 (y) = σ2i+1 (y), and
→ (S2 , m2 (loopc )),
′
′
• in any state in the execution
loop1c (n1 ) < 1 and loop2c (n2 ) < 1;
∗
1i+1
(s1 , m1i ) → (s1 , m1i+1 (loopc , σ1i+1 )), the loop
By the proof in base case of Lemma 5.1, the execution of s1
counter of s1 is less than or equal to i + 1.
proceeds as follows:

16

2015/9/14

(s1 , m1 )
= (whilehn1 i (e) {S1 }, m1 (loop1c , σ1 ))
→(whilehn1 i (0) {S1 }, m1 (loop1c , σ1 )) by the EEval’ rule
→(skip, m1 (loop1c [0/(n1 )], σ1 )) by the Wh-F rule.

Proof. By induction on size(S1 )+size(S2 ), the sum of the program
size of S1 and S2 .
Base case.
S1 and S2 are simple statement. Then the proof is a case analysis
according to the cases in the definition of the proof rule of computation equivalently for simple statements.

Similarly, the execution of s2 proceeds to
(skip, m2 (loop2c [0/n2 ], σ2 )). Therefore, σ1′ = σ1 and σ2′ =
σ2 .
By the definition of imported variables, x ∈ Imp(s1 , {x}). By
assumption, value stores σ1 and σ2 agree on the value of x,
σ1′ (x) = σ1 (x) = σ2 (x) = σ2′ (x). The lemma holds.
2. For some finite positive k(> 1), both of the following hold:
• The loop counters for s1 and s2 are always less than k:
′
∗
∀m′1 , m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c ) and
′
∗
(s2 , m2 ) → (S2′ , m′2 (loop2c )),
′
′
loop1c (n1 ) < k and loop2c (n2 ) < k;
• There are two configuration (s1 , m1k−1 ) and (s2 , m2k−1 )
reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in
which the loop counters of s1 and s2 are equal to k − 1
and value stores agree on the values of imported variables
∗
relative to x and, for every state in execution, (s1 , m1 ) →
∗
(s1 , m1k−1 ) or (s2 , m2 ) → (s2 , m2k−1 ) the loop counters
for s1 and s2 are less than or equal to k − 1 respectively:
∃(s1 , m1k−1 ), (s2 , m2k−1 ) :
1
∗
(s1 , m1 ) → (s1 , m1k−1 (loopck−1 , σ1k−1 ))∧
2k−1
∗
, σ2k−1 )) where
(s2 , m2 ) → (s2 , m2k−1 (loopc

1. S1 = S2
By the definition of imported variables, same statement have
same imported variables relative to same x.
2. S1 6= S2
There are two further cases:
• S1 = “input id1 ”, S2 = “input id2 ” and x ∈
/ {id1 , id2 }.
When x = idI , by the definition of imported variables,
Imp(S1 , {idI }) = Imp(S2 , {idI }) = {idI }. When x =
idIO , by the definition of imported variables, Imp(S1 , {idIO }) =
Imp(S2 , {idIO }) = {idI , idIO }.
When x ∈
/ {idI , idIO }, by the definition of imported variables, Imp(S1 , {x}) = Imp(S2 , {x}) = {x}.
• the above cases do not hold and x ∈
/ Def(S1 ) ∪ Def(S2 ).
By the definition of imported variables, Imp(S1 , {x}) =
Imp(S2 , {x}) = {x}.
Induction Step.
The hypothesis IH is that the lemma holds when size(S1 ) +
size(S2 ) = k ≥ 2.
Then we show the lemma holds when size(S1 )+size(S2 ) = k +1.
The proof is a case analysis based on the cases in the definition of
the proof rule of computation equivalently for statement sequence,
S1 ≡ S
x S2 :

2

1

loopck−1 (n1 ) = loopck−1 (n2 ) = k − 1; and
∀y ∈ Imp(x) : σ1k−1 (y) = σ2k−1 (y); and
′

∗

∗

∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c ) →
′
1
(s1 , m1k−1 (loopck−1 , σ1k−1 )), loop1c (n1 ) ≤ k − 1;
and
′
∗
∗
∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) →
2k−1
2′
, σ2k−1 )), loopc (n2 ) ≤ k − 1;
(s2 , m2k−1 (loopc
By proof of Lemma 5.1, value stores σ1k−1 and σ2k−1 agree
on the values of the variables in Use(e). By Lemma D.1,
E ′ JeKσ1k−1 = E ′ JeKσ2k−1 = v. Because the loop counter of
s1 and s2 is less than k in executions of s1 and s2 when started
in states m1 and m2 , then by our semantic rules, the predicate
expression of s1 and s2 must evaluate to zero w.r.t value stores
σ1k−1 and σ2k−1 , E ′ JeKσ1k−1 = E ′ JeKσ2k−1 = (0, vof ). Then
the execution of s1 proceeds as follows.

1. S1 and S2 are one statement such that one of the following
holds:
(a) S1 and S2 are If statement that define the variable x:
S1 = “If (e) then {S1t }else {S1f }”, S2 = “If (e) then {S2t }
else {S2f }” such that all of the following hold:
• x ∈ Def(S1 ) ∩ Def(S2 );
t
• S1t ≡S
x S2 ;
f
S
• S1 ≡x S2f ;
By the hypothesis IH, the imported variables in S1t and
S2t relative to x are same, Imp(S1t , {x}) = Imp(S2t , {x}).
Similarly, Imp(S1f , {x}) = Imp(S2f , {x}). By the definition of imported variables, Imp(S1 , {x}) = Use(e) ∪
Imp(S1t , {x}) ∪ Imp(S1f , {x}). Similarly, Imp(S2 , {x})
= Use(e)∪Imp(S2t , {x})∪Imp(S2f , {x}). Then, the lemma
holds.
(b) S1 and S2 are while statement that define the variable x:
S1 = “whilehn1 i (e) {S1′′ }”, S2 = “whilehn2 i (e) {S2′′ }”
such that both of the following hold:
• x ∈ Def(S1 ) ∩ Def(S2 );
′′
• ∀y ∈ Imp(S1 , {x}) ∪ Imp(S2 , {x}), S1′′ ≡S
y S2 ;
By the definition of imported variables, Imp(S1 , {x}) =
S
′′
Imp(S1 i , {x} ∪ Use(e)). Similarly, Imp(S2 , {x}) =
Si≥0
′′ i
′′ i
i≥0 Imp(S2 , {x}∪Use(e)). Then, we show that Imp(S1 , {x} ∪

1

(whilehn1 i (e) {S1 }, m1k−1 (loopck−1 , σ1k−1 ))
1
→(whilehn1 i ((0, vof )) {S1 }, m1k−1 (loopck−1 , σ1k−1 ))
by the EEval’ rule
1
→(whilehn1 i (0) {S1 }, m1k−1 (loopck−1 , σ1k−1 ))
by the E-Oflow1 or E-Oflow2 rule
1
→(skip, m1k−1 (loopck−1 [0/n1 ], σ1k−1 ))
by the Wh-F rule.
Similarly, the execution of s2 proceeds to
2
(skip, m2k−1 (loopck−1 [0/n2 ], σ2k−1 )). Therefore, σ2′ = σ2k−1 ,
′
σ1 = σ1k−1 . By the definition of imported variables, x ∈
Imp(x). In conclusion, σ2′ (x) = σ2k−1 (x) = σ1k−1 (x) =
σ1′ (x).

′′

Use(e)) = Imp(S2 i , {x} ∪ Use(e)) by induction on i.
Base case.
′′
′′
By our assumption of the notation S 0 , S1 0 = skip, S2 0 =
skip.
′′
′′
Then, Imp(S1 0 , {x}∪Use(e)) = {x}∪Use(e), Imp(S2 0 , {x}∪
Use(e)) = {x} ∪ Use(e).
′′
′′
Hence, Imp(S1 0 , {x}∪Use(e)) = Imp(S2 0 , {x}∪Use(e)).
Induction step.

Lemma 5.3. If two statement sequences S1 and S2 satisfy the proof
rule of terminating computation of a variable x equivalently, then
S1 and S2 have same imported variables relative to x: (S1 ≡S
x
S2 ) ⇒ (Imp(S1 , {x}) = Imp(S2 , {x})).
17

2015/9/14

′′

The hypothesis IH2 is that Imp(S1 i , {x} ∪ Use(e)) =
′′
Imp(S2 i , {x} ∪ Use(e)) for i ≥ 0.
′′
′′
Then we show that Imp(S1 i+1 , {x}∪Use(e)) = Imp(S2 i+1 , {x}∪
Use(e)).
′′

Imp(S1 i+1 , {x} ∪ Use(e))
′′
′′
= Imp(S1 , Imp(S1 i , {x} ∪ Use(e))) (1) by corollary C.1
′′

Imp(S2 i+1 , {x} ∪ Use(e))
′′
′′
= Imp(S2 , Imp(S2 i , {x} ∪ Use(e))) (2) by corollary C.1
′′

′′

Imp(S1 i , {x} ∪ Use(e)) = Imp(S2 i , {x} ∪ Use(e))
by the hypothesis IH2
′′
′′
Imp(S1 , Imp(S1 i , {x} ∪ Use(e)))
′′
′′
= Imp(S2 , Imp(S2 i , {x} ∪ Use(e)))
by the hypothesis IH
′′
Imp(S1 i+1 , {x} ∪ Use(e))
′′
= Imp(S2 i+1 , {x} ∪ Use(e)) by (1),(2)
′′
′′
Therefore, Imp(S1 i+1 , {x}∪Use(e)) = Imp(S2 i+1 , {x}∪
Use(e)).
In conclusion, Imp(S1 , {x}) = Imp(S2 , {x}). The lemma
holds.
(c) S1 and S2 do not define the variable x: x ∈
/ Def(S1 ) ∪
Def(S2 ).
By the definition of imported variable, the imported variables in S1 and S2 relative to x is x, Imp(S1 , {x}) =
Imp(S2 , {x}) = {x}. The lemma holds.

2. S1 and S2 are not both one statement such that one of the
following holds:
(a) Last statements both define the variable x such that all of
the following hold:
′
• ∀y ∈ Imp(s1 , {x}) ∪ Imp(s2 , {x}), S1′ ≡S
y S2 ;
• x ∈ Def(s1 ) ∩ Def(s2 );
• s1 ≡S
x s2 ;
By the hypothesis IH, we have Imp(s1 , {x}) = Imp(s2 , {x}) =
Imp(∆). Then, by the hypothesis IH again, we have that
∀y ∈ Imp(∆) = Imp(s1 , {x}) = Imp(s2 , {x}), Imp(S1′ , {y})
= Imp(S2′ , {y}). By taking the union of all ∀y ∈ Imp(∆),
Imp(S1′ , {y}) and Imp(S2′ , {y}), by the Lemma C.2, Imp(S1′ ,
Imp(∆)) = Imp(S2′ , Imp(∆)). By the definition of imported variables,
Imp(S1 , {x}) = Imp(S1′ , Imp(s1 , {x})), Imp(S2 , {x}) =
Imp(S2′ , Imp(s2 , {x})). Therefore, the lemma holds.
(b) One last statement does not define
the variable x: w.l.o.g.,

x∈
/ Def(s1 ) ∧ (S1′ ≡S
x S2 ) ;
By the definition of imported variables, we have Imp(s1 , {x})
= {x}. By the hypothesis IH, Imp(S1′ , {x}) = Imp(S2 , {x})
Therefore, by the definition of imported variables, Imp(S1 , {x})
= Imp(S1′ , Imp(s1 , {x})) = Imp(S1′ , {x}) = Imp(S2 , {x}).
(c) There are statements moving in/out of If statement:
s1 = “If (e) then {S1t } else {S1f }”, s2 = “If (e) then {S2t }
else {S2f }” such that none of the above cases hold and all
of the following hold:
′
• ∀y ∈ Use(e), S1′ ≡S
y S2 ;
′
t
• S1′ ; S1t ≡S
x S2 ; S2 ;
f
′
• S1′ ; S1f ≡S
x S2 ; S2 ;
• x ∈ Def(s1 ) ∩ Def(s2 );
We show all of the following hold.
i. Imp(S1′ , Use(e)) = Imp(S2′ , Use(e)).
By the hypothesis IH and the assumption that ∀y ∈
′
Use(e), S1′ ≡S
y S2 . Then, by Lemma C.2,
Imp(S1′ , Use(e)) = Imp(S2′ , Use(e)).
18

ii. Imp(S1′ , Imp(S1t , {x})) = Imp(S2′ , Imp(S2t , {x})).
Because size(“If(e) then {St } else {Sf }”) = 1 +
size(St ) + size(Sf ), then
size(S1′ ; S1t ) + size(S2′ ; S2t ) < k. By the hypothesis IH,
Imp(S1′ ; S1t , {x}) = Imp(S2′ ; S2t , {x}).
Besides, by Lemma C.1,
Imp(S1′ , Imp(S1t , {x})) = Imp(S1′ ; S1t , {x})
= Imp(S2′ ; S2t , {x}) = Imp(S2′ , Imp(S2t , {x})).
iii. Imp(S1′ , Imp(S1f , {x})) = Imp(S2′ , Imp(S2f , {x})).
By similar argument in the case that
Imp(S1′ , Imp(S1t , {x})) = Imp(S2′ , Imp(S2t , {x})).
Then, by combining things together,
Imp(S1 , {x})
= Imp(S1′ , Imp(s1 , {x}))
by the definition of imported variables
= Imp(S1′ , Imp(S1t , {x}) ∪ Imp(S1f , {x}) ∪ Use(e))
by the definition of imported variables
= Imp(S1′ , Imp(S1t , {x})) ∪ Imp(S1′ , Imp(S1f , {x}))
∪Imp(S1′ , Use(e)) by Lemma C.2
= Imp(S2′ , Imp(S2t , {x})) ∪ Imp(S2′ , Imp(S2f , {x}))
∪Imp(S2′ , Use(e)) by i, ii, iii
= Imp(S2′ , Imp(S2t , {x}) ∪ Imp(S2f , {x}) ∪ Use(e))
by Lemma C.2
= Imp(S2′ , Imp(S2t , {x}) ∪ Imp(S2f , {x}) ∪ Use(e))
by the definition of imported variables
= Imp(S2′ , Imp(s2 , {x}))
by the definition of imported variables
= Imp(S2 , {x}).
Hence, the lemma holds.

5.3 Termination in the same way
We proceed to propose a proof rule under which two statement
sequences either both terminate or both do not terminate. We start
by giving the definition of termination in the same way. Then
we present the proof rule of termination in the same way. Our
proof rule of termination in the same way allows updates such
as statement duplication or reordering, loop fission or fusion and
additional terminating statements. We prove that the proof rule
ensures terminating in the same way by induction on the program
size of the two programs in the proof rule. We also list auxiliary
lemmas required by the proof of termination in the same way.
Definition 14. (Termination in the same way) Two statement
sequences S1 and S2 terminate in the same way when started in
states m1 and m2 respectively, written (S1 , m1 ) ≡H (S2 , m2 ), iff
one of the following holds:
∗

∗

1. (S1 , m1 ) → (skip, m′1 ) and (S2 , m2 ) → (skip, m′2 );
i

(S1i , mi1 )

2. ∀i ≥ 0, (S1 , m1 ) →
where S1i 6= skip, S2i 6= skip.

i

and (S2 , m2 ) → (S2i , mi2 )

5.3.1 Proof rule for termination in the same way
We define proof rules under which two statement sequences S1 and
S2 terminate in the same way. We summarize the cause of nonterminating execution and then give the proof rule.
We consider two causes of nonterminating executions: crash
and infinite iterations of loop statements. As to crash [? ], we consider four common causes based on our language: expression evaluation exceptions, the lack of input value, input/assignment value
type mismatch and array index out of bound. In essence, the causes
of nontermination are partly due to the values of some particular
variables during executions. We capture variables affecting each

2015/9/14

i. S1t , S1f , S2t , S2f are all sequences of “skip”;
ii. At least one of S1t , S1f , S2t , S2f is not a sequence of
f
f
t
S
“skip” such that: (S1t ≡S
H S2 ) ∧ (S1 ≡H S2 );
(c) S1 = “whilehn1 i (e){S1′′ }”, S2 = “whilehn2 i (e){S2′′ }” and
both of the following hold:

source of nontermination; loop deciding variables LVar(S) are variables affecting the evaluation of a loop statements in the statement sequence S, crash deciding variables CVar(S) are variables
whose values decide if a crash occurs in S. We list the definitions
of LVar(S) and CVar(S) in Definition 15 and 16. Definition 17
summarizes the variables whose values decide if one program terminates.

′′
• S1′′ ≡S
H S2 ;
• S1′′ and S2′′ have equivalent computation of TVar(S1 ) ∪

Definition 15. (Loop deciding variables) The loop deciding variables of a statement sequence S, written LVar(S), are defined as
follows:

TVar(S2 );
2. S1 and S2 are not both one statement and one of the following
holds:
(a) S1 = S1′ ; s1 and S2 = S2′ ; s2 and all of the following hold:

1. LVar(S) = ∅ if ∄s = “while(e) {S ′ }” and s ∈ S;
2. LVar(“If (e) then {St } else {Sf }”) = Use(e) ∪ LVar(St ) ∪
LVar(Sf ) if “while(e){S ′ }” ∈ S;
3. LVar(“while(e){S ′ }”) = Imp(S, Use(e) ∪ LVar(S ′ ));
4. For k > 0, LVar(s1 ; ...; sk ; sk+1 ) = LVar(s1 ; ...; sk ) ∪
Imp(s1 ; ...; sk , LVar(sk+1 ));

′
• S1′ ≡S
H S2 ;
• S1′ and S2′ have equivalent computation of TVar(s1 ) ∪

TVar(s2 );

• s1 ≡S
H s2 where s1 and s2 are not “skip”;

Definition 16. (Crash deciding variables) The crash deciding
variables of a statement sequence S, written CVar(S), are defined
as follows:

(b) One last statement is “skip”:

′
S
′
(S1 = S1′ ; “skip”)∧(S
1 ≡H S2 ) ∨ (S2 = S2 ; “skip”)∧

′
(S1 ≡S
S
)
.
2
H
(c) One last statement is a “duplicate” statement and one of the
following holds:
i. S1 = S1′ ; s′1 ; S1′′ ; s1 and all of the following hold:
• S1′ ; s′1 ; S1′′ ≡S
H S2 ;
• (s′1 ≡S
H s1 ) ∧ (s1 6= “skip”);
• Def(s′1 ; S1′′ ) ∩ TVar(s1 ) = ∅;
ii. S2 = S2′ ; s′2 ; S2′′ ; s2 and all of the following hold:
′
′
′′
• S1 ≡ S
H S2 ; s 2 ; S2 ;
′
S
• (s2 ≡H s2 ) ∧ (s2 6= “skip”);
• Def(s′2 ; S2′′ ) ∩ TVar(s2 ) = ∅;
(d) S1 = S1′ ; s1 ; s′1 and S2 = S2′ ; s2 ; s′2 where s1 and s2 are
reordered and all of the following hold:

1. CVar(skip) = ∅;
2. CVar(lval := e) = Idx(lval) ∪ Use(e) if (Γ ⊢ lval :
Int) ∧ (Γ ⊢ e : Long);
3. CVar(lval := e) = Idx(lval)∪Err(e) if (Γ ⊢ lval : Int)∧(Γ ⊢
e : Long) does not hold;
4. CVar(input id) = {idI };
5. CVar(output e) = Err(e);
6. CVar(“If (e) then {St } else {Sf }”) = Err(e), if CVar(St )
∪ CVar(Sf ) = ∅;
7. CVar(“If (e) then {St } else {Sf }”) = Use(e) ∪ CVar(St )
∪ CVar(Sf ), if CVar(St ) ∪ CVar(Sf ) 6= ∅;
8. CVar(“whilehni (e){S ′ }”) = Imp(“whilehni (e){S ′ }”, Use(e) ∪
CVar(S ′ ));
9. For k > 0, CVar(s1 ; ...; sk+1 ) = CVar(s1 ; ...; sk )
∪ Imp(s1 ; ...; sk , CVar(sk+1 ));

′
• S1′ ≡S
H S2 ;
• S1′ and S2′ have equivalent computation of TVar(s1 ; s′1 )∪

Definition 17. (Termination deciding variables) The termination
deciding variables of statement sequence S are CVar(S)∪LVar(S),
written TVar(S).

•
•
•
•

Definition 18. (Base cases of the proof rule of termination in
the same way) Two simple statements s1 and s2 satisfy the proof
rule of termination in the same way, written s1 ≡S
H s2 , iff one of
the following holds:

TVar(s2 ; s′2 ).
′
s1 ≡S
H s2 ;
′
S
s1 ≡H s2 ;
Def(s1 ) ∩ TVar(s′1 ) = ∅;
Def(s2 ) ∩ TVar(s′2 ) = ∅;

5.3.2 Soundness of the proof rule for termination in the same
way

1. s1 and s2 are same, s1 = s2 ;
2. s1 and s2 are input statement with same type variable: s1 =
“input id1 ”, s2 = “input id2 ” where (Γs1 ⊢ id1 : τ ) ∧ (Γs2 ⊢
id2 : τ );
3. s1 = “output e” or “id1 := e”, s2 = “output e” or “id2 := e”
where both of the following hold:
• There is no possible value mismatch in “id1 := e”,
¬(Γs1 ⊢ id1 : Int) ∨ ¬(Γs1 ⊢ e : Long) ∨ (Γs1 ⊢ e : Int).
• There is no possible value mismatch in “id2 := e”,
¬(Γs2 ⊢ id2 : Int) ∨ ¬(Γs2 ⊢ e : Long) ∨ (Γs2 ⊢ e : Int).

We show that two statement sequences satisfy the proof rules of
termination in the same way, and their initial states agree on the
values of their termination deciding variables, then they either both
terminate or both do not terminate.
Theorem 3. If two simple statements s1 and s2 satisfy the proof
rule of termination in the same way, s1 ≡sH s2 , and their initial
states m1 (f1 , σ1 ) and m2 (f2 , σ2 ) with crash flags not set, f1 =
f2 = 0, and whose value stores agree on values of the termination
deciding variables of s1 and s2 , ∀x ∈ TVar(s1 ) ∪ TVar(s2 ) :
σ1 (x) = σ2 (x), when executions of s1 and s2 start in states m1
and m2 respectively, then s1 and s2 terminate in the same way
when started in states m1 and m2 respectively: (s1 , m1 ) ≡H
(s2 , m2 ).

Definition 19. (proof rule of termination in the same way) Two
statement sequences S1 and S2 satisfy the proof rule of termination
in the same way, written S1 ≡S
H S2 , iff one of the following holds:

1. S1 and S2 are both one statement and one of the following
holds.
(a) S1 and S2 are simple statements: s1 ≡S
H s2 ;
(b) S1 = “If(e) then {S1t } else {S1f }”, S2 = “If(e) then {S2t }
else {S2f }” and one of the following holds:

Proof. The proof is a case analysis of those cases in the definition
of s1 ≡sH s2 . Because s1 is a simple statement and s1 ’s execution
is without function call, we only care the crash variables of s1 in
the termination deciding variables of s1 , CVar(s1 ). Similarly, we
only care CVar(s2 ).

19

2015/9/14

√

First s1 and s2 are same: s1 = s2 ;
We show the theorem by induction on abstract syntax of s1 and
s2 .
1. s1 = s2 = skip.
By definition of termination in the same way, both s1 and
s2 terminate. The theorem holds.
2. s1 = s2 = “lval := e”.
There are further cases regarding what lval is.
(a) lval = id.
By definition, CVar(s1 ) = CVar(s2 ) = Err(e) or
Use(e) based on if there is possible value mismatch
(e.g., assigning value defined only in type Long to a
variable of type Int). There are two subcases.
• Left value id is of type Int and expression e is of
type Long but not type Int, (Γ ⊢ id : Int) ∧ (Γ ⊢ e :
Long) ∧ ¬(Γ ⊢ e : Int).
By definition, CVar(s1 ) = CVar(s2 ) = Use(e).
By assumption, ∀x ∈ Use(e), σ1 (x) = σ2 (x). By
Lemma D.1, the expression evaluates to the same
value w.r.t two pairs of value stores σ1 and σ2 respectively,
Both evaluations of expression lead to crash,
E JeKσ1 = E JeKσ2 = (error, vof ).
Then the execution of s1 is as follows:
(s1 , m1 )
= (id := e, m1 (σ1 ))
→(id := (error, ∗), m1 (σ1 )) by rule EEval’
→(id := 0, m1 (1/f)) by rule ECrash.
i
→(id := 0, m1 (1/f)) for any i > 0 by rule Crash.
Similarly, s2 does not terminate. The theorem
holds.
Both evaluations of expression lead to no crash,
E JeKσ1 = E JeKσ2 = (v, vof ).
Then there are cases regarding if value mismatch
occurs.
√
The value v is only defined in type Long, (Γ ⊢
v : Long) ∧ ¬(Γ ⊢ v : Int).
The execution of s1 is as follows:
(s1 , m1 )
= (id := e, m1 (σ1 ))
→(id := (v, vof ), m1 (σ1 )) by rule EEval
→(id := v, m1 (σ1 )) by rule EOflow-1 or EOflow-2.
→(id := v, m1 (1/f)) by rule Assign-Err.
i
→(id := v, m1 (1/f)) for any i > 0 by rule Crash.
Similarly, s2 does not terminate. The theorem
holds.
√
The value v is defined in type Int, Γ ⊢ v : Int.
Assuming that the variable id is a global one, the
execution of s1 is as follows:
(s1 , m1 )
= (id := e, m1 (σ1 ))
→(id := (v, vof ), m1 (σ1 )) by rule EEval
→(id := v, m1 (σ1 )) by rule EOflow-1 or EOflow-2.
→(skip, m1 (σ1 (σ1 [v/id]))) by rule Assign.
Similarly, s2 terminate. The theorem holds.
When the variable id is a local variable, by similar
argument for the global variable, we can show that
s1 and s2 terminate. Then the theorem holds.
• It is not the case that left value id is of type Int and
the expression e is of type Long only,

¬ (Γ ⊢ id : Int)∧(Γ ⊢ e : Long)∧¬(Γ ⊢ e : Int) .
There are two cases based on if there is crash in
evaluation of expression e.

Both evaluations of expression lead to crash,
E JeKσ1 = E JeKσ2 = (error, vof ).
By the same argument in case where left value id is
of type Int and the expression e is of type Long only,
this
√ theorem holds.
Both evaluations of expression lead to no crash,
E JeKσ1 = E JeKσ2 = (v, vof ).
By the same argument in subcase of no value mismatch in case where left value id is of type Int and
the expression e is of type Long only, this theorem
holds.
(b) lval = id[n].
There are two subcases based on if n is within the array
bound of id. By our assumption, array variable id is of
the same bound in two programs. W.l.o.g., we assume
id is local variable.
i. n is out of bound of array variable id, ((id, n) 7→
v1 ) ∈
/ σ1 and ((id, n) 7→ v2 ) ∈
/ σ2 ;
Then the execution of s1 continues as follows:
(s1 , m1 )
= (id[n] := e, m1 (σ1 ))
→(id[n] := e, m1 (1/f) by rule Arr-3
i
→(id[n] := e, m1 (1/f)) by rule Crash.
Similarly, s2 does not terminate. The theorem holds.
ii. n is within the bound of array variable id, ((id, n) 7→
v1 ) ∈ σ1 and ((id, n) 7→ v2 ) ∈ σ2 ;
There are cases of CVar(s1 ) and CVar(s2 ) based on
if there is possible value mismatch exception in s1
and s2 .
• Left value id[n] is of type Int and expression e is of
type Long but not type Int, (Γ ⊢ id[n] : Int) ∧ (Γ ⊢
e : Long) ∧ ¬(Γ ⊢ e : Int).
By definition, CVar(s1 ) = CVar(s2 ) = Use(e).
By assumption, ∀x ∈ Use(e), σ1 (x) = σ2 (x). By
Lemma D.1, the expression evaluates to the same
value w.r.t two value stores σ1 and σ2 respectively,
Both evaluations of expression lead to crash,
E JeKσ1 = E JeKσ2 = (error, vof ).
Then the execution of s1 is as follows:
(s1 , m1 )
= (id[n] := e, m1 (σ1 ))
→(id[n] := (error, ∗), m1 (σ1 )) by rule EEval’
→(id[n] := 0, m1 (1/f)) by rule ECrash.
i
→(id[n] := 0, m1 (1/f)) for any i > 0
by rule Crash.
Similarly, s2 does not terminate. The theorem
holds.
Both evaluations of expression lead to no crash,
E JeKσ1 = E JeKσ2 = (v, vof ).
Then there are cases regarding if value mismatch
occurs.
√
The value v is only defined in type Long, (Γ ⊢
v : Long) ∧ ¬(Γ ⊢ v : Int).
The execution of s1 is as follows:
(s1 , m1 )
= (id[n] := e, m1 (σ1 ))
→(id[n] := (v, vof ), m1 (σ1 )) by rule EEval’
→(id[n] := v, m1 (σ1 ))
by rule EOflow-1 or EOflow-2.
→(id[n] := v, m1 (1/f)) by rule Assign-Err.
i
→(id[n] := v, m1 (1/f)) for any i > 0
by rule Crash.

20

2015/9/14

When the variable id is a global variable, by similar
argument, the theorem holds.
ii. id is of type Int or enumeration, Γ ⊢ id : Int or
enum id′ ;
There are cases regarding if the head of input sequence can be transformed to type of id. Let vio =
hd(σ1 (idI )).
• id is of type Int.
If vio is not of type Int, Γ ⊢ vio : Long and ¬(Γ ⊢
vio : Int), then the execution of s1 continues as
follows:
(s1 , m1 )
= (input id, m1 (σ1 ))
→(input id, m1 (1/f)) by Rule In-4.
i
→(input id, m1 (1/f)) by Rule crash.
Similarly, s2 does not terminate. The theorem
holds.
If vio is of type Int, Γ ⊢ vio : Long and Γ ⊢
vio : Int, assuming id is a local variable, then the
execution of s1 continues as follows:
(s1 , m1 )
= (input id, m1 (σ1 ))
→(skip, m1 (σ1 [vio /id, tl(σ1 (idI ))/idI ,
“σ1 (idIO ) · v io ”/idIO ])) by Rule In-8.
Similarly, s2 terminates. The theorem holds.
When id is a global variable, by similar argument,
the theorem holds.
• If id is of type enum id′ = {l1 , ..., lk }.
If (vio < 1) ∨ (vio > k), then the execution of s1
continues as follows:
(s1 , m1 )
= (input id, m1 (σ1 ))
→(input id, m1 (1/f)) by Rule In-6.
i
→(input id, m1 (1/f)) by Rule crash.
Similarly, s2 does not terminate. The theorem
holds. When id is a global variable, by similar argument, the theorem holds.
If 1 ≤ vio ≤ k, assuming id is a local variable,
then the execution of s1 continues as follows:
(s1 , m1 )
= (input id, m1 (σ1 ))
→(skip, m1 (σ1 [lvio /id, tl(σ1 (idI ))/idI ,
“σ1 (idIO ) · v io ”/idIO ])) by Rule In-5.
Similarly, s2 terminates. The theorem holds. When
id is a global variable, by similar argument, the
theorem holds.
(c) s1 = s2 = “output e”;
There are two cases based on if evaluation of expression e crashes. By definition, CVar(s1 ) = CVar(s2 ) =
Err(e). By assumption, ∀x ∈ Err(e), σ1 (x) = σ2 (x).
By Lemma D.2, evaluation of the expression e w.r.t two
value stores σ1 and σ2 either both crash or both do not
crash.
i. There is crash in evaluation of the expression e w.r.t
1
two value stores σ1 and σ2 , E JeKσ1 = (error, vof
)
2
and E JeKσ2 = (error, vof ).
The execution of s1 continues as follows:
(s1 , m1 )
= (output e, m1 (σ1 ))
1
→(output (error, vof
), m1 (1/f)) by Rule EEval’
→(output 0, m1 (1/f)) by Rule ECrash.
i
→(output 0, m1 (1/f)) by Rule crash.

Similarly, s2 does not terminate. The theorem
holds.
√
The value v is defined in type Int, Γ ⊢ v : Int.
The execution of s1 is as follows:
(s1 , m1 )
= (id[n] := e, m1 (σ1 ))
→(id[n] := (v, vof ), m1 (σ1 )) by rule EEval’
→(id[n] := v, m1 (σ1 ))
by rule EOflow-1 or EOflow-2.
→(skip, m1 (σ1 (σ1 [v/(id, n)])))
by rule Assign-A.
Similarly, s2 terminate. The theorem holds.
When the variable id is a global variable, by similar argument for the global variable, we can show
that s1 and s2 terminate. Then the theorem holds.
• It is not the case that left value id is of type Int and
the expression e is of type Long only,
¬ (Γ
 ⊢ id : Int) ∧ (Γ ⊢ e : Long) ∧ ¬(Γ ⊢ e :
Int) .
There are two cases based on if there is crash in
evaluation of expression e.
Both evaluations of expression lead to crash,
E JeKσ1 = E JeKσ2 = (error, vof ).
By the same argument in case where left value id
is of type Int and the expression e is of type Long
only, this theorem holds.
Both evaluations of expression lead to no crash,
E JeKσ1 = E JeKσ2 = (v, vof ).
By the same argument in subcase of no value
mismatch in case where left value id is of type
Int and the expression e is of type Long only, this
theorem holds.
If array variable id is a global variable, by similar argument above, the theorem holds.
(c) lval = id1 [id2 ].
By definition, Idx(s1 ) = Idx(s2 ) = {id2 } ⊆ CVar(s1 ) =
CVar(s2 ). By assumption, σ1 (id2 ) = σ2 (id2 ) = n. By
the same argument in the case where lval = id[n], the
theorem holds.
3. s1 = s2 = “input id”,
By definition, CVar(s1 ) = CVar(s2 ) = {idI }. By assumption σ1 (idI ) = σ2 (idI ). There are cases regarding if input
sequence is empty or not.
(a) There is empty input sequence, σ1 (idI ) = σ2 (idI ) =
∅.
Then the execution of s1 continues as follows:
(s1 , m1 )
= (input id, m1 (σ1 ))
→(input id, m1 (1/f)) by rule In-7
i
→(input id, m1 (1/f)) by rule Crash.
Similarly, s2 does not terminate. The theorem holds.
(b) There is nonempty input sequence, σ1 (idI ) = σ2 (idI ) 6=
∅.
There are cases regarding if type of the variable id is
Long or not.
i. id is of type Long, Γ ⊢ id : Long;
Assuming id is a local variable, then the execution
of s1 continues as follows:
(s1 , m1 )
= (input id, m1 (σ1 ))
→(skip, m1 (σ1 [vio /id, tl(σ1 (idI ))/idI ,
“σ1 (idIO ) · v io ”/idIO ])) by rule In-3.
Similarly, s2 terminates. The theorem holds.

21

2015/9/14

Similarly, s2 does not terminate. The theorem holds.
ii. There is no crash in evaluation of the expression e
1
w.r.t two value stores σ1 and σ2 , E JeKσ1 = (v1 , vof
)
2
and E JeKσ2 = (v2 , vof ).
According to rule Out-1 and Out-2, there is no exception in transformation of different typed output
value. We therefore only show the execution for output value of Int type. The execution of s1 continues
as follows:
(s1 , m1 )
= (output e, m1 (σ1 ))
1
→(output (v1 , vof
), m1 (1/f)) by Rule EEval’
1
→(output v1 , m1 (vof
/of))
by Rule EOflow-1 or EOflow-2.
→(skip, m1 (σ1 [“σ(idIO ) · v 1 ”/idIO ]))
by Rule Out-1.
Similarly, s2 terminates. Theorem holds.
Second s1 and s2 are input statement with same type variable:
s1 = “input id1 ”, s2 = “input id2 ” where (Γs1 ⊢ id1 :
t) ∧ (Γs2 ⊢ id2 : t);
The theorem holds by similar argument for the case s1 = s2 =
input id.
Third s1 = “output e” or “id1 := e”, s2 = “output e” or “id2 :=
e” where both of the following hold:
• There is no possible value mismatch in “id1 := e”,
¬(Γs1 ⊢ id1 : Int) ∨ ¬(Γs1 ⊢ e : Long) ∨ (Γs1 ⊢ e : Int).
• There is no possible value mismatch in “id2 := e”,
¬(Γs2 ⊢ id2 : Int) ∨ ¬(Γs2 ⊢ e : Long) ∨ (Γs2 ⊢ e : Int).
We show that the evaluations of the expression e w.r.t the value
stores σ1 and σ2 either both raise an exception or both do not.
By the definition of crash variables, the crash variables of s1
are those obtained by the function Err(e), CVar(s1 ) = Err(e).
Similarly, the termination deciding variables of s2 are Err(e).
By assumption, the initial value stores σ1 and σ2 agree on
values of those in CVar(s1 ) and CVar(s2 ), ∀x ∈ Err(e) =
(CVar(s1 ) ∪ CVar(s2 )) : σ1 (x) = σ2 (x). By Lemma D.2, the
evaluations of expression e w.r.t two value stores, σ1 and σ2 ,
either both raise an exception or both do not raise an exception.
1. The evaluations of the expression e raise an exception w.r.t
1
two value stores σ1 and σ2 , E ′ JeKσ1 = (error, vof
), E ′ JeKσ2 =
2
(error, vof ):
We show the execution of s1 proceeds to an configuration
where the crash flag is set and then does not terminate.
When s1 = “output e”, the execution of “output e” proceeds as follows.
(output e, m1 (σ1 ))
1
→(output (error, vof
), m1 (σ1 )) by rule EEval’
→(output 0, m1 (1/f)) by rule ECrash
i
→(output 0, m1 (1/f)) for any i ≥ 0, by rule Crash.
When s1 = “id1 := e”, the execution of “id1 := e”
proceeds as follows.
(id1 := e, m1 (σ1 ))
1
), m1 (σ1 )) by rule EEval’
→(id1 := (error, vof
→(id1 := 0, m1 (1/f)) by rule ECrash
i
→(id1 := 0, m1 (1/f)) for any i ≥ 0, by rule Crash.
Similarly, the execution of s2 proceeds to a configuration
where the crash flag is set. Then, by the crash rule, the
execution of s2 does not terminate. The theorem 3 holds.
2. the evaluations of expression e do not raise an exception
1
), E ′ JeKσ2 =
w.r.t two value stores, σ1 and σ2 , E ′ JeKσ1 = (v1 , vof
2
(v2 , vof ):
We show the execution of s1 terminates.

22

When s1 = output (e), the execution of output (e) proceeds
as follows. W.l.o.g, we assume expression e is of type Int.
This is allowed by the condition that it does not hold that
(Γs1 ⊢ e : Long) ∧ ¬(Γs1 ⊢ e : Int).
(output e, m1 (σ1 ))
1
→(output (v1 , vof
), m1 (σ1 )) by rule EEval’
1
→(output v1 , m1 (vof
/of, σ1 ))
by rule E-Oflow1 or E-Oflow2
→(skip, m1 (σ1 [“σ1 (idIO ) · v¯1 ”/idIO ])) by rule Out.
When s1 = “id1 := e”, by assumption, the expression e is
of type Int, there is no possible value mismatch in execution
of “id1 := e” because the only possible value mismatch
occurs when assigning a value of type Long but not Int to
a variable of type Int. By the condition ¬(Γs1 ⊢ id1 :
Int)∨¬(Γs1 ⊢ e : Long)∨(Γs2 ⊢ e : Int), when expression
e is of type Long, then the variable id1 is not of type Int. In
summary, there is no value mismatch.
The execution of “id1 := e” proceeds as follows.
(id1 := e, m1 (σ1 ))
1
→(id1 := (v1 , vof
), m1 (σ1 )) by rule EEval’
1
→(id1 := v1 , m1 (vof
/of, σ1 )) by rule EEval’
→(skip, m1 (σ1 [v1 /id1 ])) by the rule Assign.
When id1 is a variable of enumeration or Long type, by
similar argument, the theorem still holds.
Similarly, the execution of s2 terminates when started in the
state m2 (σ2 ). Theorem 3 holds.

Theorem 4. If two statement sequences S1 and S2 satisfy the
proof rule of termination in the same way, S1 ≡S
H S2 , and their
respective initial states m1 (f1 , σ1 ) and m2 (f2 , σ2 ) with crash flags
not set, f1 = f2 = 0, and whose value stores agree on values of the
termination deciding variables of S1 and S2 , ∀x ∈ TVar(S1 ) ∪
TVar(S2 ) : σ1 (x) = σ2 (x), then S1 and S2 terminate in the same
way when started in states m1 and m2 respectively: (S1 , m1 ) ≡H
(S2 , m2 ).
Proof. The proof is by induction on size(S1 ) + size(S2 ), the sum
of program size of S1 and S2 .
Base case. S1 and S2 are simple statement. By Theorem 3, Theorem 4 holds.
Induction step.
There are two hypotheses. The hypothesis IH is that Theorem 4
holds when size(S1 ) + size(S2 ) = k ≥ 2.
We show Theorem 4 holds when size(S1 ) + size(S2 ) = k + 1.
The proof of Theorem 4 is a case analysis according to the cases
in the definition of the proof rule of termination in the same way,
S1 ≡ S
H S2 .
1. S1 and S2 are one statement and one of the following holds.
(a) S1 = “If(e) then {S1t } else {S1f }”, S2 = “If(e) then {S2t }
else {S2f }” such that one of the following holds:

i. S1t , S1f , S2t , S2f are all sequences of “skip”;
We show that the evaluation of expression e w.r.t the
value store σ1 and σ2 either both raise an exception or
both do not. By the definition of crash/loop variables,
CVar(S1t ) = CVar(S1f ) = ∅, LVar(S1 ) = ∅. By the
definition of termination deciding variables, the termination deciding variables of S1 is the crash variables
of S1 , TVar(S1 ) = CVar(S1 ) = Err(e). By assumption, the value stores σ1 and σ2 agree on the values
of those in the crash variables of S1 and S2 , ∀x ∈
Err(e) = TVar(S1 ) = TVar(S2 ), σ1 (x) = σ2 (x). By

2015/9/14

the property of the expression meaning function E , the
evaluation of predicate expression e of S1 and S2 w.r.t
value store σ1 and σ2 either both crash or both do not
crash, (E JeKσ1 = E JeKσ2 = error) ∨ (E JeKσ1 6=
error) ∧ (E JeKσ2 6= error) . Then we show that Theorem 4 holds in either of the two possibilities.
A. E JeKσ1 = E JeKσ2 = error.
The execution of S1 proceeds as follows:
(If(e) then {S1t } else {S1f }, m1 (σ1 ))
→(If(error) then {S1t } else {S1f }, m1 (σ1 )) by rule EEval
→(If(0) then {S1t } else {S1f }, m1 (1/f, σ1 )) by rule ECrash
i
→(If(0) then {S1t } else {S1f }, m1 (1/f, σ1 )) for any i ≥ 0,
by rule Crash.
Similarly, the execution of S2 started in the state
m2 (σ2 ) does not terminate. The theorem 4 holds.
B. (E JeKσ1 6= error) ∧ (E JeKσ2 6= error).
W.l.o.g, E JeKσ1 = v1 6= 0, E JeKσ2 = 0. Then the
execution of S1 proceeds as follows.
(If(e) then {S1t } else {S1f }, m1 (σ1 ))
→(If(v1 ) then {S1t } else {S1f }, m1 (σ1 )) by rule EEval
→(S1t , m1 (σ1 )) by rule If-T
∗
→(skip, m′1 ) by rule Skip.
Similarly, the execution of S2 started in the state
m2 (σ2 ) terminates. The theorem 4 holds.

i

→(If(0) then {S1t } else {S1f }, m1 (1/f, σ1 )) for any i ≥ 0,
by rule Crash.
Similarly, the execution of S2 started from state
m2 (σ2 ) does not terminate. The theorem 4 holds.
B. E JeKσ1 = E JeKσ2 = v 6= error, w.l.o.g., v = 0.
Then the execution of S1 proceeds as follows:
(If(e) then {S1t } else {S1f }, m1 (σ1 ))
→(If(0) then {S1t } else {S1f }, m1 (σ1 )) by rule EEval
→(S1f , m1 (σ1 )) by rule If-F.
Similarly, after two steps of execution, S2 gets to the
configuration (S2f , m2 (σ2 )).

We show that S1f and S2f terminate in the same way
when started in the state m1 (σ1 ) and m2 (σ2 ) ref
spectively. Because S1f ≡S
H S2 , by Corollary 5.1,
the termination deciding variables of S1f and S2f
are same, TVar(S1f ) = TVar(S2f ). By the definition of crash/loop variables, CVar(S1f ) ⊆ CVar(S1 )
and LVar(S1f ) ⊆ LVar(S1 ). Hence, the termination deciding variables of S1f are a subset of the
termination deciding variables of S1 , TVar(S1f ) ⊆
TVar(S1 ). Similarly, TVar(S2f ) ⊆ TVar(S2 ). Therefore, the value store σ1 and σ2 agree on the values of those in the termination deciding variables
of S1f and S2f , ∀y ∈ TVar(S1f ) ∪ TVar(S2f ) :
ii. At least one of S1t , S1f , S2t , S2f is not a sequence of
σ
f
f
1 (y) = σ2 (y). In addition, the sum of program size
t
S
“skip” and (S1t ≡S
H S2 ) ∧ (S1 ≡H S2 );
of
S1f and S2f is less than k because program size
t
W.l.o.g., S1 is not of “skip” only. We show that the
of each of S1t and S2t is great than or equal to one,
evaluation of the expression e w.r.t the value stores σ1
f
f
size(S
1 ) + size(S2 ) < k. As is shown, crash flags
and σ2 either both raise an exception or both produce
are not set. Therefore, by the hypothesis IH, S1f and
the same integer value. Then there is either some loop
t
t
S2f terminate in the same way when started in state
statement in S1 or the crash variables of S1 are not ∅ or
both.
m1 (f1 , σ1 ) and m2 (f2 , σ2 ), (S1f , m1 (f1 , σ1 )) ≡H
A. When there is some loop statement in S1t , then, by
(S2f , m2 (f2 , σ2 )). Hence, Theorem 4 holds.
the definition of loop variables, the loop variables
(b) S1 = “whilehn1 i (e) {S1′′ }”, S2 = “whilehn2 i (e) {S2′′ }”
of S1 include all variables used in the predicate exsuch that both of the following hold:
pression of S1 , LVar(S1 ) = Use(e) ∪ LVar(S1t ) ∪
′′
• S1′′ ≡S
H S2 ;
LVar(S1f ).
′′
′′
• S1 and S2 have equivalent computation of TVar(S1 ) ∪
B. When the crash variables of S1t are not ∅, then, by
TVar(S2 );
the definition of crash variables, the crash variables
By Corollary 5.3, we show S1 and S2 terminate in the
of S1 include all variables used in the predicate exsame way when started from state m1 (f1 , m1c , σ1 ) and
pression of S1 , CVar(S1 ) = Use(e) ∪ CVar(S1t ) ∪
2
m
2 (f2 , mc , σ2 ) respectively. We need to show that all reCVar(S1f ).
quired conditions are satisfied.
In summary, all variables used in predicate expression
• The crash flags are not set, f1 = f2 = 0.
of S1 is a subset of termination deciding variables of
• The loop counter value of S1 and S2 are zero: m1c (n1 ) =
S1 , Use(e) ⊆ TVar(S1 ). By assumption, the value
m2c (n2 ) = 0.
store σ1 and σ2 agree on the values of those in the
• The value stores σ1 and σ2 agree on the values of those
termination deciding variables of S1 and S2 . It follows,
in the termination deciding variables of S1 and S2 , ∀x ∈
by the property of expression meaning function E , the
TVar(S1 ) ∩ TVar(S2 ) : σ1 (x) = σ2 (x).
evaluation of the predicate expression e of S1 and S2
The three above conditions are from assumption.
produce the same value w.r.t the value store σ1 and σ2 ,
• S1 and S2 have same set of termination deciding variE JeKσ1 = E JeKσ2 . Then either the evaluations of the
ables, TVar(S1 ) = TVar(S2 ).
predicate expression e of S1 and S2 both crash w.r.t
By Corollary 5.1.
the value store σ1 and σ2 , or both evaluations produce
• The loop body S1′′ of S1 and S2′′ of S2 terminate in
the same integer value, (E JeKσ1 = E JeKσ2 = error) ∨
the same way when started in state mS1 (fS1 , σS1 ) and
(E JeKσ1 = E JeKσ2 = v 6= error). We show Theorem 4
mS2 (fS2 , σS2 ) with crash flags not set and in which
holds in either of the two possibilities.
value
stores agree on the values of those in the terA. E JeKσ1 = E JeKσ2 = error.
mination deciding variables of S1′′ and S2′′ : ((∀x ∈
The execution of S1 proceeds as follows:
TVar(S1′′ ) ∪ TVar(S2′′ ) : σS1 (x) = σS2 (x)) ∧ (fS1 =
(If(e) then {S1t } else {S1f }, m1 (σ1 ))
fS2 = 0)) ⇒ (S1′′ , mS1 (fS1 , σS1 )) ≡H (S2′′ , mS2 (fS2 , σS2 )).
f
t
→(If(error) then {S1 } else {S1 }, m1 (σ1 )) by rule EEval
By the definition of program size, size(S1 ) = size(S1′′ )+
→(If(0) then {S1t } else {S1f }, m1 (1/f, σ1 )) by rule ECrash
1, size(S2 ) = size(S2′′ )+1. Then, size(S1′′ )+size(S2′′ ) <
23

2015/9/14

k. Then, by the hypothesis IH, the loop body S1′′ of S1
and S2′′ of S2 terminate in the same way when started in
state mS1 (σS1 ) and mS2 (σS2 ) with crash flags not set
and whose value stores agree on values of the termination deciding variables of S1′′ and S2′′ .
Then, by Corollary 5.3, S1 and S2 terminate in the same
way when started in the states m1 (m1c , σ1 ) and m2 (m2c , σ2 )
respectively. The theorem 4 holds.
2. S1 and S2 are not both one statement and one of the following
holds:
(a) S1 = S1′ ; s1 , S2 = S2′ ; s2 and all of the following hold:
′
• S1′ ≡S
H S2 ;
′
′
• S1 and S2 have equivalent computation of TVar(s1 ) ∪
TVar(s2 );
• s1 ≡S
H s2 where s1 and s2 are not sequences of “skip”;
By the hypothesis IH, we show that S1′ and S2′ terminate in
the same way when started in the states m1 (f1 , σ1 ), m2 (f2 , σ2 )
respectively, (S1′ , m1 (f1 , σ1 )) ≡H (S2′ , m2 (f2 , σ2 )). We
need to show all required conditions are satisfied.
• Crash flags are not set, f1 = f2 = 0;
By assumption.
• size(S1′ ) + size(S2′ ) < k.
By the definition, size(s1 ) ≥ 1, size(s2 ) ≥ 1. Hence
size(S1′ ) + size(S2′ ) < k.
• Value stores σ1 and σ2 agree on values of the termination deciding variables of S1′ and S2′ .
Besides, by the definition of loop/crash variables, LVar(S1′ ) ⊆
LVar(S1 ) and CVar(S1′ ) ⊆ CVar(S1 ). Hence, TVar(S1′ ) ⊆
TVar(S1 ). Similarly, TVar(S2′ ) ⊆ TVar(S2 ). Then,
value stores σ1 and σ2 agree on the values of those
in the termination deciding variables of S1′ and S2′ ,
∀x ∈ TVar(S1′ ) ∪ TVar(S2′ ) : σ1 (x) = σ2 (x).
Then, by the hypothesis IH, S1′ and S2′ terminate in the
same way when started in the states m1 (f1 , σ1 ), m2 (f2 , σ2 )
respectively, (S1′ , m1 (f1 , σ1 )) ≡H (S2′ , m2 (f2 , σ2 )).
If the execution of S1′ and S2′ terminate when started in the
states m1 (f1 , σ1 ) and m2 (f2 , σ2 ) respectively, we show that
s1 and s2 terminate in the same way. We prove that S1′ and
S2′ equivalently compute the termination deciding variables
of s1 and s2 by Theorem 2.
• Crash flags are not set, f1 = f2 = 0;
By definition of terminating execution of S1′ and S2′
when started in states m1 and m2 respectively.
• The executions of S1′ and S2′ terminate when started in
the states m1 (σ1 ) and m2 (σ2 ).
∗
By assumption, (S1′ , m1 (σ1 )) → (skip, m′1 (σ1′ )) and
∗
′
′
′
(S2 , m2 (σ2 )) → (skip, m2 (σ2 )).
• s1 and s2 have same termination deciding variables.
By Corollary 5.1, s1 and s2 have same termination deciding variables, TVar(s1 ) = TVar(s2 ) = TVar(s).
• Value stores σ1 and σ2 agree on the values of variables
in Imp(S1′ , TVar(s)) ∪ Imp(S2′ , TVar(s)).
By the definition of loop/crash variables, Imp(S1′ , LVar(s1 )) ⊆
LVar(S1 ) and Imp(S1′ , CVar(s1 )) ⊆ CVar(S1 ). Hence,
by Lemma C.2, the imported variables in S1′ relative to
the termination deciding variables of s1 is a subset of the
termination deciding variables of S1 , Imp(S1′ , TVar(s))
⊆ TVar(S1 ). Similarly, Imp(S2′ , TVar(s)) ⊆ TVar(S2 ).
Thus, by assumption, the value stores σ1 and σ2 agree
on the values of the variables in Imp(S1′ , TVar(s)) ∪
Imp(S2′ , TVar(s)).
By Theorem 2, ∀x ∈ TVar(s) : σ1′ (x) = σ2′ (x).
24

∗

By Corollary E.1, (S1′ ; s1 , m1 (σ1 )) → (s1 , m′1 (f1 , σ1′ ))
∗
and (S2′ ; s2 , m2 (σ2 )) → (s2 , m′2 (f2 , σ2′ )). Then, by the hypothesis IH, we show that s1 and s2 terminate in the same
way when started in the states m′1 (σ1′ ) and m′2 (σ2′ ). We
show that all required conditions are satisfied. size(s1 ) +
size(s2 ) < k because size(S1′ ) ≥ 1, size(S2′ ) ≥ 1 by the
definition of program size. If s1 , s2 are loop statement, then,
by the assumption of unique loop labels, s1 ∈
/ S1′ , s2 ∈
/
S2′ . Then, by Corollary E.4, the loop counter value of s1
and s2 is not redefined in the execution of S1′ and S2′ respectively. By the hypothesis IH, s1 and s2 terminate in
the same way when started in the states m′1 (f1 , σ1′ ) and
m′2 (f2 , σ2′ ), (s1 , m′1 (f1 , σ1′ )) ≡H (s2 , m′2 (f2 , σ2′ )). The
theorem 4 holds.
(b) One last statement is “skip”: w.l.o.g., (s2 = “skip”) ∧
′
(S1 ≡S
H S2 ).
We show that S1 and S2′ terminate in the same way when
started in the states m1 (σ1 ) and m2 (σ2 ) respectively by
the hypothesis IH. By the definition of crash/loop variables,
CVar(S2′ ) ⊆ CVar(S2 ), LVar(S2′ ) ⊆ LVar(S2 ). Then, by
assumption, ∀x ∈ TVar(S2′ ) ∪ TVar(S1 ) : σ1 (x) =
σ2 (x). Besides, size (s2 ) ≥ 1 by the definition of program
size. Then size (S1 ) + size (S2′ ) ≤ k. By the hypothesis
IH, S1 and S2′ terminate in the same way when started
in the states m1 (f1 , σ1 ), m2 (f2 , σ2 ), (S1 , m1 (f1 , σ1 )) ≡H
(S2′ , m2 (f2 , σ2 )).
When the execution of S1 and S2′ terminate when started in
the states m1 (σ1 ) and m2 (σ2 ) respectively, s2 terminates
after the execution of S2′ by the definition of terminating
execution.
(c) One last statement is a “duplicate” statement such that one
of the following holds:
W.l.o.g., S2 = S2′ ; s′2 ; S2′′ ; s2 and all of the following hold:
′
′
′′
• S1 ≡ S
H S2 ; s 2 ; S2 ;
′
S
• s2 ≡H s2 ;
• Def(s′2 ; S2′′ ) ∩ TVar(s2 ) = ∅;
• s2 6= “skip”;
We show that S1 and S2′ ; s′2 ; S2′′ terminate in the same way
when started in the states m1 (f1 , σ1 ),
m2 (f2 , σ2 ) respectively by the hypothesis IH. The proof is
same as that in case a).
We show that s2 terminates if the execution of S2′ ; s′2 ; S2′′
terminates. We need to prove that s′2 and s2 start in the states
agreeing on the values of variables in TVar(s2 ). By assump∗
tion, S2′ ; s′2 ; S2′′ terminates, (S2′ ; s′2 ; S2′′ , m2 (f2 , σ2 )) →
′
′
′
′
′′
(skip, m2 (f2 , σ2 )). Then, by Corollary E.1, (S2 ; s2 ; S2 ; s2 , m2 (f2 , σ2 ))
∗
→ (s2 , m′2 (f2 , σ2′ )). In addition, the execution of S2′ and s′2
must terminate because the execution of S2′ ; s′2 ; S2′′ terminates,
∗
∗
(S2′ ; s′2 ; S2′′ ; s2 , m2 (f2 , σ2 )) → (s′2 ; S2′′ ; s2 , m′′2 (f2 , σ2′′ )) →
′
′
(s2 , m2 (f2 , σ2 )).
By assumptin, Def(s′2 ; S2′′ ) ∩ TVar(s2 ) = ∅. Then, by
Corollary E.2, the value store σ2′′ and σ2′ agree on values of
the termination deciding variables of s2 , ∀x ∈ TVar(s2 ) :
σ2′′ (x) = σ2′ (x). By Corollary 5.1, TVar(s′2 ) = TVar(s2 ).
Because the execution of s′2 terminates, then the execution
of s2 terminates when started in the state m′2 (f2 , σ2′ ) by the
∗
hypothesis IH, (s2 , m′2 (f2 , σ2′ )) → (skip, m′′2 ).
In addition, we show that there is no input statement in
s2 by contradiction. Suppose there is input statement in
s2 . By Lemma 5.11, idI ∈ CVar(s2 ). Hence, the input
sequence variable is in the termination deciding variables
of s2 , idI ∈ TVar(s2 ). By Corollary 5.1, TVar(s2 ) =

2015/9/14

TVar(s′2 ). Then, there must be one input statement in s′2 .
Imp(S2′ , TVar(s2 ; s′2 )) ⊆ TVar(S2 ).
Otherwise, by Lemma 5.2, the input sequence variable is not
W.l.o.g, we show that Imp(S1′ , TVar(s1 ; s′1 )) ⊆ TVar(S1 ).
in the termination deciding variables of s′2 . A contradiction
Specifically, we show Imp(S1′ , CVar(s1 ; s′1 )) ⊆ CVar(S1 ).
against the result that idI ∈ TVar(s′2 ). Since there is one
CVar(s1 ; s′1 )
input statement in s′2 , by Lemma 5.11, idI ∈ Def(s′2 ).
= CVar(s1 ) ∪ Imp(s1 , CVar(s′1 )) (1)
Thus, by defintion, idI ∈ Def(s′2 ; S2′′ ). Then, Def(s′2 ; S2′′ )∩
by the defintion of CVar(s1 ; s′1 )
TVar(s2 ) 6= ∅. A contradiction. Therefore, there is no input
statement in s2 .
Imp(S1′ , CVar(s1 ; s′1 ))
(d) S1 = S1′ ; s1 ; s′1 ; and S2 = S2′ ; s2 ; s′2 where s1 and s2 are
= Imp(S1′ , CVar(s1 ) ∪ Imp(s1 , CVar(s′1 ))) by (1)
reordered and all of the following hold:
= Imp(S1′ , CVar(s1 )) ∪ Imp(S1′ , Imp(s1 , CVar(s′1 ))) (2)
′
• S1′ ≡S
H S2 ;
by Lemma C.2
• S1′ and S2′ have equivalent computation of TVar(s1 ; s′1 )∪
′
TVar(s2 ; s2 ).
Imp(S1′ , CVar(s1 ))
′
• s1 ≡S
s
;
H 2
⊆ CVar(S1′ ; s1 ) by the defintion of CVar(·)
• s′1 ≡S
⊆ CVar(S1′ ; s1 ; s′1 ) by the defintion of CVar(·)
H s2 ;
• Def(s1 ) ∩ TVar(s′1 ) = ∅;
• Def(s2 ) ∩ TVar(s′2 ) = ∅;
Imp(S1′ , Imp(s1 , CVar(s′1 )))
= Imp(S1′ ; s1 , CVar(s′1 )) by Lemma C.1
The proof is to show that if S1 terminates when started in
⊆
CVar(S1′ ; s1 ; s′1 ) by the defintion of CVar(·).
the state m1 , the S2 terminates when started in the state
m2 , and vice versa. Due to the symmetric conditions, it
∗
is suffice to show one direction that, w.l.o.g., (S1 , m1 ) →
Imp(S1′ , CVar(s1 )) ∪ Imp(S1′ , Imp(s1 , CVar(s′1 )))
∗
′
′
⊆ CVar(S1′ ; s1 ; s′1 ) by (3) and (4).
(skip, m1 ) ⇒ (S2 , m2 ) → (skip, m2 ).
We show that the execution of S2′ terminates by the hypothIn conclusion, Imp(S1′ , CVar(s1 ; s′1 )) ⊆ CVar(S1 ).
esis IH. We need to show that all required conditions are
Similarly, Imp(S1′ , LVar(s1 ; s′1 )) ⊆ LVar(S1 ). Thus,
satisfied.
Imp(S1′ , TVar(s1 ; s′1 )) ⊆ TVar(S1 ). Similarly,
• size(S1′ ) + size(S2′ ) < k.
Imp(S2′ , TVar(s2 ; s′2 )) ⊆ TVar(S2 ).
This is because size(s1 ; s′1 ) > 1, size(s2 ; s′2 ) > 1.
Then, by Theorem 2, after terminating execution of S1′
• Initial value stores σ1 and σ2 agree on values of the
and S2′ , value stores σ1′ and σ2′ agree on values of the
termination deciding variables of S1′ and S2′ , ∀x ∈
termination deciding variables of s1 ; s′1 and s2 ; s′2 ,
TVar(S1′ ) ∪ TVar(S2′ ) : σ1 (x) = σ2 (x).
∀x ∈ TVar(s1 ; s′1 ) ∪ TVar(s2 ; s′2 ) : σ1′ (x) = σ2′ (x).
We show that TVar(S1′ ) ⊆ TVar(S1 ). In the following,
We show that the execution of s2 terminates by the hypothwe prove that CVar(S1′ ) ⊆ CVar(S1 ).
esis IH. By Corollary E.1,
∗
CVar(S1′ )
(S1′ ; s1 ; s′1 , m1 (σ1 )) → (s1 ; s′1 , m′1 (σ1′ )) and (S2′ ; s2 ; s′2 ,
′
′
∗
′
⊆ CVar(S1 ; s1 ) by the defintion of CVar(S1 ; s1 )
m2 (σ2 )) → (s2 ; s2 , m′2 (σ2′ )). By assumption, S1 termi∗
⊆ CVar(S1′ ; s1 ; s′1 ) by the defintion of CVar(S1′ ; s1 ; s′1 )
nates, then s1 terminates, (s1 , m′1 (σ1′ )) → (skip, m′′1 (σ1′′ )).
Similarly, LVar(S1′ ) ⊆ LVar(S1 ). Hence, TVar(S1′ ) ⊆
S
′
Because s1 ≡H s2 , to apply the induction hypothesis, we
TVar(S1 ). Similarly, TVar(S2′ ) ⊆ TVar(S2 ). By asneed to show that all required conditions hold.
sumption, initial value stores σ1 and σ2 agree on values
• size(s2 ) + size(s′1 ) < k.
′
′
of the termination deciding variables of S1 and S2 .
By definition, size(S2′ ) > 1, size(S1′ ) > 1, size(s1 ) >
By the hypothesis IH, (S1′ , m1 (σ1 )) ≡H (S2′ , m2 (σ2 )).
1, size(s′2 ) > 1.
Because the execution of S1 terminates, then S1′ termi• Value stores σ1′′ and σ2′ agree on values of the termina∗
nates when started in the state m1 (σ1 ), (S1′ , m1 (σ1 )) →
tion deciding variables of s′1 and s2 . ∀x ∈ TVar(s′1 ) ∪
(skip, m′1 (σ1′ )). Therefore, S2′ termiantes when started in
TVar(s2 ) : σ1′′ (x) = σ2′ (x).
∗
the state m2 (σ2 ), (S2′ , m2 (σ2 )) → (skip, m′2 (σ2′ )).
By Corollary 5.1, TVar(s′1 ) = TVar(s2 ). Because of the
We show that after the execution of S1′ and S2′ , value stores
condition Def(s1 ) ∩ TVar(s′1 ) = ∅, by Corollary E.2,
agree on values of the termination deciding variables of
value stores σ1′′ and σ1′ agree on values of the termis1 ; s′1 and s2 ; s′2 , ∀x ∈ TVar(s1 ; s′1 )∪TVar(s2 ; s′2 ), σ1′ (x) =
nation deciding variables of s′1 , ∀x ∈ TVar(s′1 ) :
σ2′ (x). We split the argument into two steps.
σ1′′ (x) = σ1′ (x). By the argument above, ∀x ∈ TVar(s2 ) :
i. We show that TVar(s1 ; s′1 ) = TVar(s2 ; s′2 ).
σ1′ (x) = σ2′ (x). Thus, the condition holds.
By Corollary 5.1, TVar(s1 ) = TVar(s′2 ) and TVar(s′1 ) =
By the induction hypothesis IH, (s′1 , m′′1 (σ1′′ )) ≡H (s2 , m′2 (σ2′ )).
TVar(s2 ). Then we show that TVar(s1 ; s′1 ) = TVar(s1 )∪
Because the execution of s′1 terminates, then the exeucTVar(s′1 ). To do that, we show that CVar(s1 ; s′1 ) =
tion of s2 terminates when started in the state m′2 (σ2′ ),
∗
CVar(s1 ) ∪ CVar(s′1 ).
′′
′′
′
′
(s
2 , m2 (σ2 )) → (skip, m2 (σ2 )).
CVar(s1 ; s′1 )
We
show
that
the
execution
of
s′2 terminates. This is by the
= CVar(s1 ) ∪ Imp(s1 , CVar(s′1 )) by the defintion of CVar(s1 ; s′1 ) similar argument that s2 terminates.
= CVar(s1 ) ∪ CVar(s′1 ) by Def(s1 ) ∩ TVar(s′1 ) = ∅ and
In conclusion, S2 terminates when started in the state
the defintion of Imp(·).
m2 (σ2 ). The theorem holds.
Similarly, LVar(s1 ; s′1 ) = LVar(s1 ) ∪ LVar(s′1 ). Thus,
In addition, we show that it is impossible that s1 and s′1 both
TVar(s1 ; s′1 ) = TVar(s1 )∪TVar(s′1 ). Similarly, TVar(s2 ; s′2 ) =
include input statements by contradiction. Suppose there
TVar(s2 ) ∪ TVar(s′2 ). In summary, TVar(s1 ; s′1 ) =
are input statements in both s1 and s′1 . By Lemma 5.11,
TVar(s2 ; s′2 ).
idI ∈ Def(s1 ) ∩ TVar(s′1 ). A contradiction against the
ii. We show that Imp(S1′ , TVar(s1 ; s′1 )) ⊆ TVar(S1 ) and
condition that Def(s1 ) ∩ TVar(s′1 ) = ∅. Similarly, there
are no input statements in both s2 and s′2 .
25

2015/9/14

• There is no possible value mismatch in “id1

:= e”,
¬(ΓS1 ⊢ id1 : Int) ∨ ¬(ΓS1 ⊢ e : Long) ∨ (ΓS1 ⊢ e : Int).
• There is no possible value mismatch in “id2 := e”,
¬(ΓS2 ⊢ id2 : Int) ∨ ¬(ΓS2 ⊢ e : Long) ∨ (ΓS2 ⊢ e : Int).

5.3.3 Supporting lemmas for the soundness proof of
termination in the same way
The supporting lemmas include various properties of TVar(S),
two statement sequences satisfying the proof rule of termination
in the same way consume the same number of input values when
both terminate, and the proof for the case of while statement of
theorem 4.

By the definition of loop variables, LVar(S1 ) = LVar(S2 ) = ∅ in
both base cases. Therefore, Lemma 5.6 holds.
Induction Step.
The hypothesis IH is that Lemma 5.6 holds when size(S1 ) +
size(S2 ) = k ≥ 2.
We show that Lemma 5.6 holds when size(S1 ) + size(S2 ) =
k + 1.
The proof is a case analysis according to the cases in the definition of (S1 ≡S
H S2 ):

The properties of the termination deciding variables
Lemma 5.4. The crash variables of S1 ; S1′ is same as the union
of the crash variables of S1 and the imported variables in S1
relative to the crash variables of S1′ , CVar(S1 ; S1′ ) = CVar(S1 ) ∪
Imp(S1 , CVar (S1′ )).

1. S1 and S2 are one statement and one of the following holds.
(a) S1 = “If(e) then {S1t } else {S1f }”, S2 = “If(e) then {S2t }
else {S2f }” such that one of the following holds:

S1′

Proof. Let
= s1 ; ...; sk for k > 0. We show the lemma by
induction on k.
Base case.
By the definition of CVar(S), the lemma holds.
Induction step.
The hypothesis IH is that CVar(S1 ; s1 ; ...; sk ) = CVar(S1 ) ∪
Imp(S1 , CVar(s1 ; ...; sk )) for k ≥ 1.
Then we show that the lemma holds when S1′ = s1 ; ...; sk+1 .

i. S1t , S1f , S2t , S2f are all sequences of “skip”;
By the definition of loop variables, LVar(S1t ) = LVar(S1f ) =
LVar(S2t ) = LVar(S2f ) = ∅. Therefore, by the definition of loop variables, LVar(S1 ) = LVar(S2 ) = ∅. The
lemma 5.6 holds.
ii. At least one of S1t , S1f , S2t , S2f is not a sequence of
f
f
t
S
“skip” such that: (S1t ≡S
H S2 ) ∧ (S1 ≡H S2 );
f
t
t
size(S1 ) + size(S2 ) < k, size(S1 ) + size(S2f ) < k.
Then, by the hypothesis IH1, LVar(S1t ) = LVar(S2t ), LVar(S1f ) =
LVar(S2f ). Consequently, (LVar(S1t ) ∪ LVar(S1f )) =
(LVar(S2t ) ∪ LVar(S2f )) = LVar(∆). When LVar(∆) =
∅, then LVar(S1 ) = LVar(S2 ) = ∅ by the definition of loop variables. When LVar(∆) 6= ∅, then
LVar(S1 ) = LVar(S2 ) = LVar(∆) ∪ Use(e) by the
definition of loop variables. The lemma 5.6 holds.
(b) S1 = “whilehn1 i (e){S1′′ }”, S2 = “whilehn2 i (e){S2′′ }” such
that both of the following hold:
′′
• S1′′ ≡S
H S2 ;
′′
′′
• S1 and S2 have equivalent computation of TVar(S1 ) ∪
TVar(S2 );
By the hypothesis IH1, LVar(S1′′ ) = LVar(S2′′ ). Then
Use(e) ∪ LVar(S1′′ ) = Use(e) ∪ LVar(S2′′ ). Then, we show
that:
i
i
∀i ≥ 0, Imp(S1′′ , Use(e)∪LVar(S1′′ )) = Imp(S2′′ , Use(e)∪
′′
LVar(S2 )) by induction on i.
Base case
0
0
By our notation S 0 , S1′′ = skip, S2′′ = skip. Then, by the
definition of imported variables,
0
Imp(S1′′ , Use(e) ∪ LVar(S1′′ )) = Use(e) ∪ LVar(S1′′ ),
′′ 0
Imp(S2 , Use(e) ∪ LVar(S2′′ )) = Use(e) ∪ LVar(S2′′ ).
0
0
Then, Imp(S1′′ , Use(e)∪LVar(S1′′ )) = Imp(S2′′ , Use(e)∪
′′
LVar(S2 )).
Induction step
i
The hypothesis IH3 is that, ∀i ≥ 0, Imp(S1′′ , Use(e) ∪
′′
′′ i
′′
LVar(S1 )) = Imp(S2 , Use(e) ∪ LVar(S2 )).
i+1
Then we show that Imp(S1′′ , Use(e) ∪ LVar(S1′′ )) =
′′ i+1
Imp(S2
, Use(e) ∪ LVar(S2′′ )).
By Corollary C.1,
i+1
i
Imp(S1′′ , Use(e)∪LVar(S1′′ )) = Imp(S1′′ , Imp(S1′′ , Use(e)∪
LVar(S1′′ ))),
i+1
i
Imp(S2′′ , Use(e)∪LVar(S2′′ )) = Imp(S2′′ , Imp(S2′′ , Use(e)∪
′′
LVar(S2 ))).
i
By the hypothesis IH3, Imp(S1′′ , Use(e) ∪ LVar(S1′′ )) =
′′ i
′′
Imp(S2 , Use(e) ∪ LVar(S2 )) = LVar(∆).

CVar(S1 ; s1 ; ...; sk+1 )
= CVar(S1 ; s1 ) ∪ Imp(S1 ; s1 , CVar(s2 ; ...; sk+1 )) by IH
CVar(S1 ; s1 )
= CVar(S1 ) ∪ Imp(S1 , CVar(s1 )) (1)
Imp(S1 ; s1 , CVar (s2 ; ...; sk+1 ))
= Imp(S1 , Imp(s1 ; CVar (s2 ; ...; sk+1 ))) (2)
Combining (1) and (2), we have
CVar(S1 ; s1 ) ∪ Imp(S1 ; s1 , CVar (s2 ; ...; sk+1 ))
= CVar(S1 ) ∪ Imp (S1 , CVar (s1 ))
∪ Imp (S1 , Imp(s1 ; CVar (s2 ; ...; sk+1 )))
= CVar(S1 ) ∪ Imp(S1 , CVar(s1 ) ∪ Imp(s1 ; CVar(s2 ; ...; sk+1 )))
by Lemma C.2
= CVar(S1 ) ∪ Imp(S1 , CVar(s1 ; ...; sk+1 )).
Lemma 5.5. The loop deciding variables of S1 ; S1′ is same as
the union of the loop deciding variables of S1 and the imported
variables in S1 relative to the loop deciding variables of S1′ ,
LVar(S1 ; S1′ ) = LVar(S1 ) ∪ Imp(S1 , LVar (S1′ )).
By proof of Lemma 5.5 similar to that of lemma 5.4 above.
Lemma 5.6. If two statement sequences S1 and S2 satisfy the proof
rule of termination in the same way, then S1 and S2 have same loop
variables, (S1 ≡S
H S2 ) ⇒ (LVar(S1 ) = LVar(S2 )).
Proof. By induction on size(S1 )+size(S2 ), the sum of the program
size of S1 and S2 .
Base case.
S1 and S2 are simple statement. There are three base cases
according to the definition of s1 ≡S
H s2 .
1. two same simple statements, S1 = S2 ;
2. S1 and S2 are input statement with same type variable: S1 =
“input id1 ”, S2 = “input id2 ” where (ΓS1 ⊢ id1 : t) ∧ (ΓS2 ⊢
id2 : t);.
3. S1 = “output e” or “id1 := e”, S2 = “output e” or “id2 := e”
where both of the following hold:

26

2015/9/14

Besides, by the definition of loop variables, LVar(∆) ⊆
LVar(S1 ), LVar(∆) ⊆ LVar(S2 ).
Then,
i
Imp(S1′′ , Imp(S1′′ , Use(e) ∪ LVar(S1′′ )))
′′
= Imp(S1 , LVar(∆))
= Imp(S2′′ , LVar(∆)) by Lemma 5.3
i
= Imp(S2′′ , Imp(S2′′ , Use(e) ∪ LVar(S2′′ )))
In summary, LVar(S1 )) = LVar(S2 ). The lemma 5.6 holds.

In the following, we show LVar(S1 ) = LVar(S2 ) in three
steps.
i. We show LVar(S1′ ; s1 ; s′1 ) = LVar(S1′ )
∪Imp(S1′ , LVar(s1 )) ∪ Imp(S1′ , LVar(s′1 )).
LVar(S1′ ; s1 ; s′1 )
= LVar(S1′ ; s1 ) ∪ Imp(S1′ ; s1 , LVar(s′1 ))
by the definition of loop variables

LVar(S1′ ; s1 )
= LVar(S1′ ) ∪ Imp(S1′ , LVar(s1 )) (2)
by the definition of loop variables

2. S1 and S2 are not both one statement and one of the following
holds:
(a) S1 = S1′ ; s1 and S2 = S2′ ; s2 such that all of the following
hold:

Imp(S1′ ; s1 , LVar(s′1 ))
= Imp(S1′ , Imp(s1 , LVar(s′1 ))) by Lemma C.1
= Imp(S1′ , LVar(s′1 )) (3)
by the condition Def(s1 ) ∩ TVar(s′1 ) = ∅

′
• S1′ ≡S
H S2 ;
′
′
• S1 and S2 have equivalent computation of TVar(s1 ) ∪

TVar(s2 );

• s1 ≡S
H s2 where s1 and s2 are not “skip”;

LVar(S1′ )

According to (2) and (3), LVar(S1′ ; s1 ; s′1 ) = LVar(S1′ )∪
Imp(S1′ , LVar(s1 )) ∪ Imp(S1′ , LVar(s′1 )).
Similarly, LVar(S2′ ; s2 ; s′2 ) = LVar(S2′ )∪
Imp(S2′ , LVar(s2 )) ∪ Imp(S2′ , LVar(s′2 )).
ii. We show that Imp(S1′ , LVar(s1 )) = Imp(S2′ , LVar(s′2 )).
Imp(S2′ , LVar(s′2 )).
We need to show that LVar(s1 ) ⊆ LVar(s1 ; s′1 ) and
LVar(s′2 ) ⊆ LVar(s2 ; s′2 ). By the definition of loop
variables, LVar(s1 ) ⊆ LVar(s1 ; s′1 ). By the definition
of loop variables again, LVar(s2 ; s′2 ) = LVar(s2 ) ∪
Imp(s2 , LVar(s′2 )). Because Def(s2 ) ∩ TVar(s′2 ) = ∅,
Imp(s2 , LVar(s′2 )) = LVar(s′2 ).
By the induction hypothesis IH, LVar(s1 ) = LVar(s′2 ).
By Lemma 5.3, ∀x ∈ LVar(s1 ) = LVar(s′2 ), Imp(S1′ , {x}) =
Imp(S2′ , {x}). By Lemma C.2, Imp(S1′ , LVar(s1 )) =
Imp(S2′ , LVar(s′2 )).
iii. We show that Imp(S1′ , LVar(s′1 )) = Imp(S2′ , LVar(s2 )).
By the similar argument that Imp(S1′ , LVar(s1 )) =
Imp(S2′ , LVar(s′2 )).
In conclusion, LVar(S1′ ; s1 ; s′1 ) = LVar(S2′ ; s2 ; s′2 ).

LVar(S2′ ),

By the hypothesis IH1,
=
LVar(s1 ) =
LVar(s2 ) = LVar(∆). Besides,
Imp(S1′ , LVar(s1 )) = LVar(S2′ , LVar(s2 )) by Lemma 5.3.
Therefore, LVar(S1 ) = LVar(S2 ) by the definition of loop
variables. The lemma 5.6 holds.
(b) One last statement is “skip”: w.l.o.g.,

′
(S1 ≡S
H S2 ) ∧ (s2 = “skip”) .
By the hypothesis IH1, LVar(S1 ) = LVar(S2′ ) . Besides,
LVar(s2 ) = ∅ by the definition of loop variables. Therefore,
LVar(S1 ) = LVar(S2 ) = LVar(S2′ ) ∪ Imp(S2′ , ∅). The
lemma 5.6 holds.
(c) One last statement is a “duplicate” statement such that one
of the following holds:
W.l.o.g. S1 = S1′ ; s′1 ; S1′′ ; s1 and all of the following hold:
• S1′ ; s′1 ; S1′′ ≡S
H S2 ;
• s′1 ≡S
H s1 ;
• Def(s′1 ; S1′′ ) ∩ TVar(s1 ) = ∅;
• s2 6= “skip”;
By the hypothesis IH, LVar(S1′ ; s′1 ; S1′′ ) = LVar(S2 ).
Then, we show that LVar(S1′ ; s′1 ; S1′′ ) = LVar(S1′ ; s′1 ; S1′′ ; s1 ).
By the induction hypothesis IH, LVar(s′1 ) = LVar(s1 ).
LVar(S1′ ; s′1 ; S1′′ ; s1 )
= LVar(S1′ ; s′1 ; S1′′ ) ∪ Imp(S1′ ; s′1 ; S1′′ , LVar(s1 ))
by the definition of loop variables

Lemma 5.7. If two statement sequences S1 and S2 satisfy the proof
rule of termination in the same way, then S1 and S2 have same
crash variables, (S1 ≡S
H S2 ) ⇒ (CVar(S1 ) = CVar(S2 )).
By proof similar to those for Lemma 5.6.

Imp(S1′ ; s′1 ; S1′′ , LVar(s1 ))
= Imp(S1′ , Imp(s′1 ; S1′′ , LVar(s1 ))) by Lemma C.1
= Imp(S1′ , LVar(s1 )) by Def(s′1 ; S1′′ ) ∩ TVar(s1 ) = ∅
= Imp(S1′ , LVar(s′1 )) by LVar(s′1 ) = LVar(s1 )
⊆ LVar(S1′ ; s′1 ) by the definition of loop variables
⊆ LVar(S1′ ; s′1 ; S1′′ ) by Lemma 5.5.

Corollary 5.1. If two statement sequences S1 and S2 satisfy
the proof rule of termination in the same way, then S1 and S2
have same termination deciding variables, (S1 ≡S
H S2 ) ⇒
(TVar(S1 ) = TVar(S2 )).
By Lemma 5.6, and 5.7.

In conclusion, LVar(S1′ ; s′1 ; S1′′ ; s1 ) = LVar(S1′ ; s′1 ; S1′′ ).
The lemma holds.
(d) S1 = S1′ ; s1 ; s′1 ; and S2 = S2′ ; s2 ; s′2 where s1 and s2 are
reordered and all of the following hold:

Properties of the input sequence variable
Lemma 5.8. If there is no input statement in a statement sequence
S, then the input sequence variable is not in the defined variables
of S, (∄“input x” ∈ S) ⇒ idI ∈
/ Def(S).

′
• S1′ ≡S
H S2 ;
′
′
• S1 and S2 have equivalent computation of TVar(s1 ; s′1 )∪

•
•
•
•

TVar(s2 ; s′2 ).
′
s1 ≡S
H s2 ;
′
S
s1 ≡H s2 ;
Def(s1 ) ∩ TVar(s′1 ) = ∅;
Def(s2 ) ∩ TVar(s′2 ) = ∅;

Proof. By induction on abstract syntax of S.
Lemma 5.9. If there is no input statement in a statement sequence
S, then the input sequence variable is not in the crash variables of
S, (∄“input x” ∈ S) ⇒ (idI ∈
/ CVar(S)).

By the hypothesis IH, LVar(S1′ ) = LVar(S2′ ), LVar(s1 ) =
LVar(s′2 ), LVar(s′1 ) = LVar(s2 ).

Proof. By induction on abstract syntax of S.

27

2015/9/14

i

Imp(S ′ , {idI } ∪ Use(e))
i
⊆ Imp(S ′ , CVar(S ′ ) ∪ Use(e)) (1) by the hypothesis IH1

Lemma 5.10. If there is no input statement in a statement sequence
S, then the input sequence variable is in the loop variables of S,
(∄“input x” ∈ S) ⇒ (idI ∈
/ LVar(S)).

i+1

Imp(S ′ , {idI } ∪ Use(e))
i
= Imp(S ′ , Imp(S ′ , {idI } ∪ Use(e))) (2) by Corollary C.1

Proof. By induction on abstract syntax of S.
Corollary 5.2. If there is no input statement in a statement sequence S, then the input sequence variable is in the termination
deciding variables of S, (∄“input x” ∈ S) ⇒ (idI ∈
/ TVar(S)).

i+1

Imp(S ′ , CVar(S ′ ) ∪ Use(e))
i
= Imp(S ′ , Imp(S ′ , CVar(S ′ ) ∪ Use(e))) (3) by Corollary C.1.

By Lemma 5.9 and 5.10.
Lemma 5.11. If there is one input statement in a statement sequence S, then the input sequence variable is in the crash variables and defined variables of S, (∃“input x” ∈ S) ⇒ (idI ∈
CVar(S)) ∧ (idI ∈ Def(S)).

Combining (1), (2) and (3):
i

Imp(S ′ , Imp(S ′ , {idI } ∪ Use(e)))
i
⊆ Imp(S ′ , Imp(S ′ , CVar(S ′ ) ∪ Use(e))) by Lemma C.2.

Proof. By induction on abstract syntax of S.

i+1

i+1

Therefore, Imp(S ′ , {idI }∪Use(e)) ⊆ Imp(S ′ , CVar(S ′ )∪
Use(e)).
In conclusion, Imp(S, {idI }) ⊆ CVar(S).
4. S = s1 ; ...; sk , for k > 0.
By induction on k.
Base case. k = 1.
Proof. By induction on abstract syntax of S.
By above cases, the lemma holds.
1. S = “input x”.
Induction step.
By the definition of CVar(·) and Imp(·), CVar(S) = Imp(S, {idI }) =
The induction hypothesis IH2 is that the lemma holds when
{idI }.
k > 0. We show that the lemma holds when S = s1 ; ...; sk+1 .
2. S = “If(e) then {St } else {Sf }”.
By the definition of crash variables, CVar(s1 ; ...; sk+1 ) =
W.l.o.g., there is input statement in St , by the induction hyCVar(s1 ; ...; sk ) ∪ Imp(s1 ; ...; sk , CVar(sk+1 )).There are two
pothesis, Imp(St , {idI }) ⊆ CVar(St ). There are two subcases
possibilities.
regarding if input statement is in Sf .
(a) ∄“input x” ∈ sk+1 .
(a) There is input statement in Sf .
By Lemma 5.8, idI ∈
/ Def(S).
By the induction hypothesis, Imp(Sf , {idI }) ⊆ CVar(Sf ).
Imp(s1 ; ...; sk+1 , {idI })
Hence, the lemma holds.
= Imp(s1 ; ...; sk , {idI }) by idI ∈
/ Def(S) and
(b) There is no input statement in Sf .
the definition of imported variables
By the definition of imported variables, Imp(Sf , {idI }) =
⊆ CVar(s1 ; ...; sk ) by the hypothesis IH2
{idI }. By Lemma 5.11, idI ∈ CVar(St ). Therefore, the
⊆ CVar(s1 ; ...; sk+1 ) by the definition of crash variables
lemma holds.
3. S = “whilehni (e){S ′ }”.
(b) ∃“input x” ∈ sk+1 .
By the induction hypothesis, Imp(S ′ , {idI }) ⊆ CVar(S ′ ).
S
Imp(s1 ; ...; sk+1 , {idI })
i
By the definition of Imp(·), Imp(S ′ , {idI }) = i≥0 Imp(S ′ , {idI }∪
= Imp(s1 ; ...; sk , Imp(sk+1 , {idI }))
′
Use(e)). By the definition of CVar(·), CVar(S ) =
by the definition of imported variables
S
′i
′
i≥0 Imp(S , CVar(S ) ∪ Use(e)).
i
Imp(sk+1 , {idI })
By induction on i, we show that, ∀i ≥ 0, Imp(S ′ , {idI } ∪
′i
′
⊆ CVar(sk+1 ) by the hypothesis IH2
Use(e)) ⊆ Imp(S , CVar(S ) ∪ Use(e)).
Base case i = 0.
0
Imp(s1 ; ...; sk , Imp(sk+1 , {idI }))
By notation S ′ = skip.
⊆ Imp(s1 ; ...; sk , CVar(sk+1 )) by Lemma C.2
0
⊆ CVar(s1 ; ...; sk+1 ) by the definition of crash variables.
Imp(S ′ , {idI } ∪ Use(e))
= {idI } ∪ Use(e) by the definition of imported variables

Lemma 5.12. If there is one input statement in a statement sequence S, then the imported variables in S relative to the input sequence variable are a subset of the crash variables of S,
(∃“input x” ∈ S) ⇒ (Imp(S, {idI }) ⊆ CVar(S)).

0

Imp(S ′ , CVar(S ′ ) ∪ Use(e))
= CVar(S ′ ) ∪ Use(e) by the definition of imported variables

Lemma 5.13. If two programs S1 and S2 satisfy the proof rule of
termination in the same way, then S1 and S2 satisfy the proof rule
of terminating computation in the same way of the input sequence,
S
(S1 ≡S
H S2 ) ⇒ (S1 ≡idI S2 ).

′

idI ⊆ CVar(S ) (1) by Lemma 5.11
0

Imp(S ′ , {idI } ∪ Use(e))
0
⊆ Imp(S ′ , CVar(S ′ ) ∪ Use(e)) by Lemma C.2.

Proof. By induction on size(S1 ) + size(S2 ).
Base case. S1 and S2 are simple statements.
There are three cases.

Induction step.
i
The hypothesis IH1 is that Imp(S ′ , {idI } ∪ Use(e)) ⊆
′i
′
Imp(S , CVar(S ) ∪ Use(e)) for i > 0.
i+1
Then we show that Imp(S ′ , {idI } ∪ Use(e))
′ i+1
′
⊆ Imp(S
, CVar(S ) ∪ Use(e))

1. S1 and S2 are “skip”: S1 = S2 = “skip”;
2. S1 and S2 are input statement: S1 = “input id1 ”, S2 =
“input id2 ”;

28

2015/9/14

i. idI ∈ TVar(s1 ) = TVar(s2 )
Then there is input statement in s1 and s2 . Otherwise, by
Lemma 5.2, idI ∈
/ TVar(s1 ) = TVar(s2 ). A contradiction. Then, by Lemma 5.11, idI ∈ Def(s1 ) ∩ Def(s2 ).
By Lemma 5.3, Imp(s1 , {idI }) = Imp(s2 , {idI }).
By Lemma 5.12, Imp(s1 , {idI }) ⊆ CVar(s1 , {idI }).
Therefore, S1′ and S2′ equivalently compute Imp(s1 , {idI })∪
Imp(s2 , {idI }). The lemma holds.
ii. idI ∈
/ TVar(s1 ) = TVar(s2 ).
Then, there is no input statement in s1 and s2 . Otherwise, by Lemma 5.11, idI ∈ CVar(s1 ) = CVar(s2 ). A
contradiction. Then, by Lemma 5.8, idI ∈
/ Def(s1 ) ∪
′
Def(s2 ). By the induction hypothesis IH, S1′ ≡S
idI S2 .
The lemma holds.
(b) One laststatement is “skip”: W.l.o.g., (S1′ ≡S
H S2 )∧(s1 =
“skip”)
By the induction hypothesis, S1′ ≡S
idI S2 . By definition,
idI ∈
/ Def(s1 ). The lemma holds.
(c) One last statement is a “duplicate” statement such that one
of the followings holds:
W.l.o.g., S1 = S1′ ; s′1 ; S1′′ ; s1 and all of the followings hold:
• S1′ ; s′1 ; S1′′ ≡S
H S2 ;
• s′1 ≡S
H s1 ;
• Def(s′1 ; S1′′ ) ∩ TVar(s1 ) = ∅;
• s2 6= “skip”.
By the induction hypothesis, S1′ ; s′1 ; S1′′ ≡S
idI S2 . In the
proof of Theorem 3, there is no input statement in s2 . Because ∀x : “input x” ∈
/ s2 , by Lemma 5.8, idI ∈
/ Def(s1 ).
The lemma holds.
(d) S1 = S1′ ; s1 ; s′1 ; and S2 = S2′ ; s2 ; s′2 where s1 and s2 are
reordered and all of the followings hold:

3. s1 and s2 are with the same expression: s1 = “output e” or
“id1 := e”, s2 = “output e” or “id2 := e”.
By definition of the proof rule of equivalent computation, the
lemma holds in above three cases.
Induction step.
The hypothesis IH is that the lemma holds when size(S1 ) +
size(S2 ) = k ≥ 2.
Then, we show that the lemma holds when size(S1 )+size(S2 ) =
k + 1. The proof is a case analysis of the cases in the proof rule of
termination in the same way.
1. S1 and S2 are one statement and one of the followings holds.
(a) S1 = “If(e) then {S1t } else {S1f }”, S2 = “If(e) then {S2t }
else {S2f }” and one of the followings holds:

i. S1t , S1f , S2t , S2f are all sequences of “skip”;
By Lemma 5.8, idI ∈
/ Def(S1 ) ∩ DefS2 . The lemma
holds.
ii. At least one of S1t , S1f , S2t , S2f is not a sequence of
“skip” such that:
f
f
t
S
(S1t ≡S
H S2 ) ∧ (S1 ≡H S2 );
Because size(S1 ) = 1+size(S1t )+size(S1f ), size(S2 ) =
1+size(S2t )+size(S2f ). Therefore, size(S1t )+size(S2t ) <
k, size(S1f ) + size(S2f ) < k. By the induction hypothef
f
t
S
sis IH, (S1t ≡S
idI S2 ) ∧ (S1 ≡idI S2 ). Then, the lemma
S
holds by the definition of S1 ≡idI S2 .

(b) S1 = “whilehn1 i (e){S1′′ }”, S2 = “whilehn2 i (e){S2′′ }” and
both of the followings hold:
′′
• S1′′ ≡S
H S2 ;
′′
′′
• S1 and S2 have equivalent computation of TVar(S1 ) ∪

TVar(S2 );

′
• S1′ ≡S
H S2 ;
• S1′ and S2′ have equivalent computation of TVar(s1 ; s′1 )∪

′′
By the induction hypothesis IH, S1′′ ≡S
idI S2 . In addition,
by Corollary 5.1, TVar(S1 ) = TVar(S2 ). There are two
cases.
i. idI ∈ TVar(S1 ) = TVar(S2 ).
We show that idI ∈ Def(S1 ) ∩ Def(S2 ). If there is
no input statement in S1 or S2 , then, by Corollary 5.2,
idI ∈
/ TVar(S1 ) ∩ TVar(S2 ). A contradiction. Thus,
there is input statement in S1 and S2 , by Lemma 5.11,
idI ∈ Def(S1 ) ∩ Def(S2 ).
By Lemma 5.12, Imp(S1 , {idI }) ⊆ CVar(S1 ). Similarly, Imp(S2 , {idI }) ⊆ TVar(S2 ). Hence, loop bodies
of S1 and S2 equivalently compute every of the imported variables in S1 and S2 relative to the input sequence variable, ∀x ∈ Imp(S1 , {idI })∪Imp(S2 , {idI }),
′′
S1′′ ≡S
x S2 . Thus, the lemma holds.
ii. idI ∈
/ TVar(S1 ) = TVar(S2 ).
Then there is no input statement in S1 and S2 . Otherwise, by Lemma 5.11, (idI ∈ CVar(S1 )) ∨ (idI ∈
CVar(S2 )). A contradiction. Then by Lemma 5.8, idI ∈
/
(Def(S1 ) ∩ Def(S2 )). Hence, the lemma holds.

•
•
•
•

TVar(s2 ; s′2 ).
′
s1 ≡S
H s2 ;
′
S
s1 ≡H s2 ;
Def(s1 ) ∩ TVar(s′1 ) = ∅;
Def(s2 ) ∩ TVar(s′2 ) = ∅;

In the proof of Theorem 4, we showed that s1 and s2 do not
both include input statement, s2 and s′2 do not both include
input statement. There are two subcases.
i. There are no input statements in both s1 and s′1 .
We show that there are no input statements in both
s2 and s′2 . By Corollary 5.1, TVar(s1 ) = TVar(s′2 )
and TVar(s′1 ) = TVar(s2 ). By Corollary 5.2, idI ∈
/
TVar(s1 )∪TVar(s′1 ). Thus, idI ∈
/ TVar(s2 )∪TVar(s′2 ).
If there is input statement in s2 or s′2 , then, by Lemma 5.11,
idI ∈
/ TVar(s2 ) ∪ TVar(s′2 ). A contradiction. In summary, there are no input statements in both s2 and s′2 .
By Lemma 5.8, idI ∈
/ Def(s1 ; s′1 ) and idI ∈
/ Def(s2 ; s′2 ).
′
By the induction hypothesis, S1′ ≡S
S
.
Therefore,
the
2
idI
lemma holds.
ii. W.l.o.g, there are input statements in s1 only.
By similar argument in the proof of Theorem 4 that s1
and s2 do not both include input statements, we can
show that there is no input statement in s2 and there is
input statement in s′2 .
In the following, the proof is of two steps.
′
A. We show that s1 ; s′1 ≡S
idI s2 .
′
By the induction hypothesis IH, s1 ≡S
idI s2 . Because there is no input statement in s′1 , then by

2. S1 and S2 are not both one statement and one of the followings
holds:
(a) S1 = S1′ ; s1 and S2 = S2′ ; s2 and all of the followings hold:

′
• S1′ ≡S
H S2 ;
′
′
• S1 and S2 have equivalent computation of TVar(s1 ) ∪

TVar(s2 );

• s1 ≡S
H s2 where s1 and s2 are not “skip”;

By the induction hypothesis IH, s1 ≡S
idI s2 . By Corollary 5.1, TVar(s1 ) = TVar(s2 ). There are two cases.

29

2015/9/14

′
Lemma 5.8, idI ∈
/ Def(s′1 ). Thus, s1 ; s′1 ≡S
idI s2
by definition.
B. We show that S1′ and S2′ ; s2 equivalently compute
Imp(s1 ; s′1 , {idI }) ∪ Imp(s′2 , {idI }).
The argument is of two parts. First, we need to
show that Def(s2 ) ∩ Imp(s′2 , {idI }) = ∅. By
Lemma 5.12, Imp(s′2 , {idI }) ⊆ CVar(s′2 ). Thus,
Imp(s′2 , {idI }) ⊆ TVar(s′2 ). By assumption, Def(s2 )∩
TVar(s′2 ) = ∅. Then, Def(s2 )∩Imp(s′2 , {idI }) = ∅.
By Lemma 5.3, Imp(s1 ; s′1 , {idI }) = Imp(s′2 , {idI }).
Thus, Def(s2 ) ∩ Imp(s1 ; s′1 , {idI }) = ∅.
Second, we show that Imp(s′2 , {idI }) ⊆ TVar(s2 ; s′2 )
and Imp(s1 ; s′1 , {idI }) ⊆ TVar(s1 ; s′1 ). By Lemma 5.12,
Imp(s1 ; s′1 , {idI }) ⊆ TVar(s1 ; s′1 ) and Imp(s′2 , {idI }) ⊆
TVar(s′2 ). Then we show that TVar(s′2 ) ⊆ TVar(s2 ; s′2 ).
We need to show that CVar(s′2 ) ⊆ CVar(s2 ; s′2 ) and
LVar(s′2 ) ⊆ LVar(s2 ; s′2 ).

CVar(s2 ; s′2 )
= CVar(s2 ) ∪ Imp(s2 , CVar(s′2 ))
by the definition of crash variables
Imp(s2 , CVar(s′2 ))
= CVar(s′2 ) (1) by the assumption
Def(s2 ) ∩ TVar(s′2 ) = ∅
CVar(s2 ) ∪ Imp(s2 , CVar(s′2 ))
= CVar(s2 ) ∪ CVar(s′2 ) by (1)

• ∀mS1 (fS1 , σS1 ) mS2 (fS2 , σS2 ) :

(((∀z ∈ TVar(S1 ) ∪ TVar(S2 )), σS1 (z) = σS2 (z)) ∧ (fS1 =
fS2 = 0)) ⇒
(S1 , mS1 (fS1 , σS1 )) ≡H (S2 , mS2 (fS2 , σS2 )).

If s1 and s2 start in the state m1 (f1 , loop1c , σ1 ) and
m2 (f2 , loop2c , σ2 ) respectively in which crash flags are not set,
f1 = f2 = 0, s1 and s2 have not already executed, loop1c (n1 ) =
loop2c (n2 ) = 0, value stores σ1 and σ2 agree on values of variables
in TVar(s), ∀x ∈ TVar(s) : σ1 (x) = σ2 (x), then, for any positive
integer i, one of the following holds:
1. The loop counters for s1 and s2 are less than i where s1 and s2
terminate in the same way:
′
∗
∗
∀m′1 m′2 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
′
′
′
′
2
1
2′
(S2 , m2 (loopc )), loopc (n1 ) < i and mc (n2 ) < i and one
of the following holds:
(a) s1 and s2 both terminate:
∗
∗
(s1 , m1 ) → (skip, m′′1 ) and (s2 , m2 ) → (skip, m′′2 ).
(b) s1 and s2 both do not terminate:
k
k
∀k > 0 : (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 ) →
(S2k , m2k ) in which S1k 6= skip, S2k 6= skip.
2. The loop counters for s1 and s2 are less than or equal to i
where s1 and s2 do not terminate such that there are no configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and
(s2 , m2 ), respectively, in which crash flags are not set, the loop
counters of s1 and s2 are equal to i, and value stores agree on
the values of variables in TVar(s):

Similarly, LVar(s′2 ) ⊆ LVar(s2 ; s′2 ). Thus, TVar(s′2 ) ⊆
TVar(s2 ; s′2 ).
By assumption, ∀x ∈ Imp(s1 ; s′1 , {idI })∪Imp(s′2 , {idI }) :
′
′
S1′ ≡S
x S2 . In addition, Def(s2 )∩(Imp(s1 ; s1 , {idI })∪
Imp(s′2 , {idI })) = ∅. Thus, ∀x ∈ Imp(s1 ; s′1 , {idI })∪
′
Imp(s′2 , {idI }) : S1′ ≡S
x S2 ; s2 . The lemma holds.

Lemma 5.14. If two programs S1 and S2 satisfy the proof rule
of termination in the same way, and S1 and S2 both terminate
when started in their initial states with crash flags not set, f1 =
f2 = 0, whose value stores agree on values of variables of the
termination deciding variables of S1 and S2 , ∀x ∈ TVar(S1 ) ∪
TVar(S2 ), σ1 (x) = σ2 (x), and S1 and S2 are fed with the same
∗
infinite input sequence, σ1 (idI ) = σ2 (idI ), (S1 , m1 (f1 , σ1 ) →
∗
′
′
′
′
(skip, m1 (σ1 )) and (S2 , m2 (f2 , σ2 ) → (skip, m2 (σ2 )), then the
execution of S1 and S2 consume the same number of input values,
σ1′ (idI ) = σ2′ (idI ).
Proof. By Lemma 5.13, S1 ≡S
idI S2 . By Lemma 5.12, Imp(S1 , idI ) ⊆
CVar(S1 ) and Imp(S2 , idI ) ⊆ CVar(S2 ). By assumption, ∀x ∈
Imp(S1 , idI ) ∪ Imp(S2 , idI ) : σ1 (x) = σ2 (x). By Theorem 2,
σ1′ (idI ) = σ2′ (idI ).
Theorem of two loop statements terminating in the same way
Lemma 5.15. Let s1 = “whilehn1 i (e){S1 }” and
s2 = “whilehn2 i (e){S2 }” be two while statements with the same
set of termination deciding variables in program P1 and P2 respectively, whose bodies S1 and S2 satisfy the proof rule of equivalently
computation of variables in TVar(s), and S1 and S2 terminate in
the same way when started in states with crash flags not set and
agreeing on values of variables in TVar(S1 ) ∪ TVar(S2 ):
• TVar(s1 ) = TVar(s2 ) = TVar(s);
• ∀x ∈ TVar(s) : S1 ≡S
x S2 ;

∗

′

∗

• ∀m′1 m′2 : (s1 , m1 ) → (S1 , m′1 (loop1c )), (s2 , m2 ) →
′

(S2 , m′2 (loop2c )) where
′
′
loop1c (n1 ) ≤ i, loop2c (n2 ) ≤ i;
• ∀k > 0 :
k
k
(s1 , m1 ) → (S1k , m1k ), (s2 , m2 ) → (S2k , m2k ) where
S1k 6= skip, S2k 6= skip; and
• ∄(s1 , m1i ) (s2 , m2i ) :
∗
(s1 , m1 ) → (s1 , m1i (f1 , loop1ci , σ1i ))∧
∗
(s2 , m2 ) → (s2 , m2i (f2 , loop2ci , σ2i )) where
f1 = f2 = 0; and
loop1ci (n1 ) = loop2ci (n2 ) = i; and
∀x ∈ TVar(s) : σ1i (x) = σ2i (x).

3. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which both
crash flags are not set, the loop counters of s1 and s2 are
equal to i and value stores agree on the values of variables in
∗
TVar(s), and for every state in execution (s1 , m1 ) → (s1 , m1i )
∗
or (s2 , m2 ) → (s2 , m2i ), the loop counters for s1 and s2 are
less than or equal to i respectively:
∗
∃(s1 , m1i ) (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 , loop1ci , σ1i ))∧
∗
2i
(s2 , m2 ) → (s2 , m2i (f2 , loopc , σ2i )) where
• f1 = f2 = 0; and
• loop1c i (n1 ) = loop2c i (n2 ) = i; and
• ∀x ∈ TVar(s) : σ1i (x) = σ2i (x); and
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (m1c )) → (s1 , m1i ),
1′
loopc (n1 ) ≤ i; and
′
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (m2c )) → (s2 , m2i ),
2′
loopc (n2 ) ≤ i;
Proof. By induction on i.
Base case. i = 1.

30

2015/9/14

By assumption, initial loop counters of s1 and s2 are of value
zero. Initial value stores σ1 and σ2 agree on the values of variables
in TVar(s). Then we show one of the following cases hold:
1. The loop counters for s1 and s2 are less than 1, s1 and s2
terminate in the same way:
′
∗
∗
∀m′1 m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
′
′
′
2
(S2 , m2 (loopc )),
′
′
m1c (n1 ) < 1 and m2c (n2 ) < 1 and one of the following holds:
(a) s1 and s2 both terminate:
∗
∗
(s1 , m1 ) → (skip, m′′1 ) and (s2 , m2 ) → (skip, m′′2 ).
(b) s1 and s2 both do not terminate:
k
k
∀k > 0, (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 ) → (S2k , m2k )
in which S1k 6= skip, S2k 6= skip.
2. The loop counters for s1 and s2 are less than or equal to 1,
and s1 and s2 do not terminate such that there are no configurations (s1 , m11 ) and (s2 , m21 ) reachable from (s1 , m1 ) and
(s2 , m2 ), respectively, in which crash flags are not set, the loop
counters of s1 and s2 are equal to 1 and value stores agree on
the values of variables in TVar(s):
′

∗

∗

• ∀m′1 m′2 : (s1 , m1 ) → (S1 , m′1 (loop1c )), (s2 , m2 ) →
′

′

′

(S2 , m′2 (loopc2 )) where loop1c (n1 ) ≤ i, loop2c (n2 ) ≤ i;

→(whilehn1 i (0) {S1 }, m1 (1/f1 )) by the ECrash rule
k
→(whilehn1 i (0) {S1 }, m1 (1/f1 , loop1c , σ1 )),
for any k ≥ 0, by the Crash rule.
Similarly, the execution of s2 started in the state m2 (f2 , loop2c , σ2 )
does not terminate.
The loop counters of s1 and s2 are less than 1:
′
∗
∗
∀m′1 m′2 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
′
′
2′
1′
2′
(S2 , m2 (loopc )) where loopc (n1 ) < 1 and loopc (n2 ) < 1.
Besides, s1 and s2 both do not terminate when started in states
k
m1 and m2 , ∀k > 0 : (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 )
k
→ (S2k , m2k ) in which S1k 6= skip, S2k 6= skip.
2. E ′ JeKσ1 = E ′ JeKσ2 = (0, vof )
The execution of s1 proceeds as follows.
(s1 , m1 (loop1c , σ1 ))
= (whilehn1 i (e) {S1 }, m1 (loop1c ))
→(whilehn1 i ((0, vof )) {S1 }, m1 (loop1c )) by the EEval’ rule
→(whilehn1 i (0) {S1 }, m1 (loop1c )) by the E-Oflow1 or E-Oflow2 rule
→(skip, m1 ) by the Wh-F1 rule.
2

Similarly, (s2 , m2 (loop2c , σ2 )) → (skip, m2 ).
The loop counters for s1 and s2 are less than 1:
• ∀k > 0 : (s1 , m1 ) → (S1k , m1k ), (s2 , m2 ) → (S2k , m2k )
′
∗
∗
where S1k 6= skip, S2k 6= skip; and
∀m′1 m′2 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
′
′
′
∗
∄(s1 , m11 ), (s2 , m21 ) : (s1 , m1 ) → (s1 , m11 (f1 , loop1c1 , σ11 ))∧ (S2′ , m′2 (loop2c )) where loop1c (n1 ) < 1 and loop2c (n2 ) < 1.
∗
Besides, s1 and s2 both terminate when started in states m1 and
(s2 , m2 ) → (s2 , m21 (f2 , loop2c1 , σ21 )) where
m2 :
f1 = f2 = 0; and
∗
∗
(s1 , m1 ) → (skip, m′′1 ) and (s2 , m2 ) → (skip, m′′2 ).
loop1c1 (n1 ) = loop2c1 (n2 ) = 1; and
′
′
3. E JeKσ1 = E JeKσ2 = (v, vof ) where v ∈
/ {0, error};
∀x ∈ TVar(s) : σ11 (x) = σ21 (x).
The execution from (s1 , m1 (loop1c , σ1 )) proceeds as follows.
3. There are two configurations (s1 , m11 ) and (s2 , m21 ) reachable from (s1 , m1 ) and (s2 , m2 ) respectively, in which the loop
(s1 , m1 (loop1c , σ1 ))
counters of s1 and s2 are equal to 1 and value stores agree on
= (whilehn1 i (e) {S1 }, m1 (loop1c , σ1 ))
the values of variables in TVar(s) and, for every state in execu→(whilehn1 i ((v, vof )) {S1 }, m1 (loop1c , σ1 )) by the EEval’ rule
∗
∗
tion, (s1 , m1 ) → (s1 , m11 ) or (s2 , m2 ) → (s2 , m21 ) the loop
→(whilehn1 i (v) {S1 }, m1 (loop1c , σ1 ))
counters for s1 and s2 are less than or equal to 1 respectively:
by rule E-Oflow1 or E-Oflow2
∗
1
∃(s1 , m11 ) (s2 , m21 ) : (s1 , m1 ) → (s1 , m11 (f1 , loop1c1 , σ11 ))∧
→(S
1 ; whilehn1 i (e) {S1 }, m1 (loopc [1/(n1 )], σ1 ))
∗
(s2 , m2 ) → (s2 , m21 (f2 , loop2c1 , σ21 )) where
by the Wh-T1 rule.
• f1 = f2 = 0; and
2
• loop1c 1 (n1 ) = loop2c 1 (n1 ) = 1; and
Similarly, (s2 , m2 (loop2c , σ2 )) → (S2 ; whilehn2 i (e){S2 },
2
• ∀x ∈ TVar(s) : σ11 (x) = σ21 (x); and
m2 (loopc [1/(n2 )], σ2 )). After two steps of executions of s1
′
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m11 ), loop1c (n1 ) ≤ and s2 , crash flags are not set, the loop counter value of s1 and
s2 are 1, value stores σ1 and σ2 agree on values of variables in
1; and
′
′
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m21 ), loop2c (n2 ) ≤ TVar(s).
We show that TVar(SS
1 ) ⊆ TVar(s). By definition of loop
1.
variables, LVar(s1 ) = j≥0 Imp(S1j , LVar(S1 ) ∪ Use(e)). By
We show evaluations of the predicate expression of s1 and s2
notation of S 0 , S 0 = skip. By definition of imported variw.r.t value stores σ1 and σ2 produce
same value. By the definition
S
ables, Imp(S10 , LVar(S1 ) ∪ Use(e)) = LVar(S1 ) ∪ Use(e).
of loop variables, LVar(s1 ) = j≥0 Imp(S1j , LVar(S1 ) ∪ Use(e)).
Then
LVar(S1 ) ⊆ LVar(s). By similar argument, we have
By our notation of S 0 , S10 = skip. By the definition of loop
CVar(S1 ) ⊆ CVar(s). Hence, TVar(S1 ) ⊆ TVar(s). Simivariables, Use(e) ⊆ LVar(s) = LVar(s1 ). By assumption, value
larly, TVar(S2 ) ⊆ TVar(s). By assumption, S1 and S2 either
stores σ1 and σ2 agree on the values of the variables in Use(e). By
both terminate or both do not terminate when started in state
Lemma D.1, the predicate expression e of s1 and s2 evaluates to
m1 (loop1c [1/(n1 )], σ1 ) and m2 (loop2c [1/(n2 )], σ2 ) in which
′
′
same value v w.r.t value stores σ1 , σ2 , E JeKσ1 = E JeKσ2 . Then
∀y ∈ TVar(S1 ) ∪ TVar(S2 ), σ1 (y) = σ2 (y) and crash flags
there are three possibilities.
are not set. Then there are two possibilities:
(a) S1 and S2 both terminate when started in states m1 (
1. E ′ JeKσ1 = E ′ JeKσ2 = (error, ∗)
loop1c [1/(n1 )], σ1 ) and m2 (loop2c [1/(n2 )], σ2 ) respectively:
The execution from (s1 , m1 (f1 , loop1c , σ1 )) proceeds as fol∗
1
11
(S
lows.
1 , m1 (loopc [1/(n1 )], σ1 )) → (skip, m11 (f1 , loopc , σ11 ))
and
∗
(s1 , m1 (f1 , loop1c , σ1 ))
(S2 , m2 (loop2c [1/(n2 )], σ2 )) → (skip, m21 (f2 , loop2c1 , σ21 )).
1
= (whilehn1 i (e) {S1 }, m1 (f1 , loopc , σ1 ))
We show that, after the full execution of S1 and S2 , the
following five properties hold.
→(whilehn1 i ((error, ∗)) {S1 }, m1 (f1 , loop1c , σ1 )) by the EEval’ rule
k

k

31

2015/9/14

m1 (loop1c [1/(n1 )], σ1 ) and
By the definition of terminating execution, crash flags
m2 (loop2c [1/(n2 )], σ2 ) respectively:
k
are not set, f1 = f2 = 0.
∀k > 0, (S1 , m1 (loop1c [1/(n1 )], σ1 )) →
• The loop counter of s1 and s2 are of value 1, loop1c 1 (n1 ) =
11
(S1k , m11k (loopc k , σ11k )) and
loop2c1 (n2 ) = 1.
k
(S2 , m2 (loop2c [1/(n2 )], σ2 )) →
By the assumption of unique loop labels, s1 ∈
/ S1 . Then,
21
the loop counter value of n1 is not redefined in the
(S2k , m21k (loopc k , σ21k )) in which S1k 6= skip, S2k 6=
execution of S1 by corollary E.2, loop1c [1/n1 ](n1 ) =
skip.
loop1c1 (n1 ) = 1. Similarly, the loop counter value of n2
By our assumption of unique loop labels, s1 ∈
/ S1 . Then,
11
is not redefined in the execution of S2 , loop2c [1/(n2 )](n2 )
∀k > 0, loopc k (n1 ) = loop1c [1/(n1 )](n1 ) = 1. Similarly,
21
= loopc (n2 ) = 1.
21
∀k > 0, loopc k (n2 )
∗
• In any state in the execution (s1 , m1 ) → (s1 , m11 (loop1c 1 , σ11 )),
= loop2c [1/(n2 )](n2 ) = 1. In addition, by Lemma E.2,
the loop counter of s1 is less than or equal to 1.
k
∀k > 0, (S1 ; s1 , m1 (loop1c [1/(n1 )], σ1 )) →
As is shown above, the loop counter of s1 is zero
1k
(Sk ; s1 , m1k (loopc , σ1k )) and
in any of the two states in the one step execution
k
1
(s1 , m1 ) → (whilehn1 i (v) {S1 }, m1 (loopc , σ1 )), and
(S2 ; s2 , m2 (loop2c [1/(n2 )], σ2 )) → (S2k ; s2 , m2k (loop2ck , σ2k ))
the loop counter of s1 is 1 in any states in the execution
in which S1k 6= skip, S2k 6= skip.
∗
In summary, loop counters of s1 and s2 are less than or
(S1 ; whilehn1 i (e) {S1 }, m1 (loop1c [i/(n1 )], σ1 )) →
equal to 1, and s1 and s2 do not terminate such that there are
(s1 , m11 (loop1c1 , σ11 )).
∗
no configurations (s1 , m11 ) and (s2 , m21 ) reachable from
21
• In any state in the executions (s2 , m2 ) → (s2 , m21 (loopc , σ21 )),
(s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags
the loop counter of s2 is less than or equal to 1.
are not set, the loop counters of s1 and s2 are equal to 1 and
By similar argument above.
value stores agree on the values of variables in TVar(s).
• The value stores σ11 and σ21 agree on values of the
termination deciding variables in s1 and s2 : ∀x ∈
Induction Step.
TVar(s), σ11 (x) = σ21 (x).
The induction hypothesis IH is that, for a positive integer i, one of
We show that the imported variables in S1 relative to
the following holds:
those in LVar(s) are a subset of LVar(s) and the imported variables in S1 relative to those in CVar(s) are
1. The loop counters for s1 and s2 are less than i, and s1 and s2
a subset of CVar(s).
both terminate in the same way:
′
∗
∗
LVar(s1 )
S
∀m′1 m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
j
′
= j≥0 Imp(S1 , LVar(S1 ) ∪ Use(e)) (1)
(S2′ , m′2 (loop2c )),
by the definition of loop variables.
′
′
loop1c (n1 ) < i and loop2c (n2 ) < i and one of the following
holds:
Imp(S1 , LVar(s)) = Imp(S1 , LVar(s1 ))
(a)
s1 and s2 both terminate:
= Imp(S1 , Imp(s1 , Use(e) ∪ LVar(S1 )))
∗
∗
(s1 , m1 ) → (skip, m′′1 ) and (s2 , m2 ) → (skip, m′′2 ).
by the definition
of
LVar(s)
S
(b) s1 and s2 both do not terminate:
= Imp(S1 , j≥0 Imp(S1j , LVar(S1 ) ∪ Use(e))) by (1)
k
k
S
j
∀k > 0, (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 ) → (S2k , m2k )
= j≥0 Imp(S1 , Imp(S1 , LVar(S1 ) ∪ Use(e)))
in which S1k 6= skip, S2k 6= skip.
by
S Lemma C.2
2.
The
loop counters for s1 and s2 are less than or equal to i, and
j
= j>0 Imp(S1 , LVar(S1 ) ∪ Use(e)) by Lemma C.1
S
s1 and s2 do not terminate such that there are no configurations
j
⊆ j≥0 Imp(S1 , LVar(S1 ) ∪ Use(e))
(s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and (s2 , m2 ),
= Imp(s1 , LVar(S1 ) ∪ Use(e)) = LVar(s1 ) = LVar(s).
respectively, in which crash flags are not set, the loop counters
Similarly, Imp(S1 , CVar(s)) ⊆ CVar(s). Hence,
of s1 and s2 are equal to i and value stores agree on the values
Imp(S1 , TVar(s)) ⊆ TVar(s). In the same way, we
of variables in TVar(s):
′
∗
∗
can show that Imp(S2 , TVar(s)) ⊆ TVar(s). Con• ∀m′1 m′2 : (s1 , m1 ) → (S1 , m′1 (loop1c )), (s2 , m2 ) →
sequently, the value stores σ11 and σ21 agree on the
′
′
′
2
1
2′
(S2 , m2 (loopc )) where loopc (n1 ) ≤ i, loopc (n2 ) ≤ i;
values of the imported variables in S1 and S2 relak
k
tive to those in TVar(s), ∀x ∈ Imp(S1 , TVar(s)) ∪
• ∀k > 0 : (s1 , m1 ) → (S1k , m1k ), (s2 , m2 ) → (S2k , m2k )
Imp(S2 , TVar(s)), σ1 (x, ) = σ2 (x). Because S1 and
where S1k 6= skip, S2k 6= skip; and
∗
S2 have equivalent computation of every variable in
• ∄(s1 , m1i ), (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 , loop1c i , σ1i ))∧
TVar(s) when started in states agreeing on the values
∗
2i
(s2 , m2 ) → (s2 , m2i (f2 , loopc , σ2i )) where
of the imported variables relative to TVar(s), by Thef1 = f2 = 0; and
orem 1, value stores σ11 and σ21 agree on the values
loop1ci (n1 ) = loop2ci (n2 ) = i; and
of the variables TVar(s), ∀x ∈ TVar(s), σ11 (x) =
∀x ∈ TVar(s) : σ1i (x) = σ2i (x).
σ21 (x).
It follows that, by Corollary E.1,
3. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable
∗
from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags
(S1 ; whilehn1 i (e){S1 }, m1 (loop1c [1/(n1 )], σ1 )) →
(whilehn1 i (e) {S1 }, m11 (loop1c1 , σ11 )) = (s1 , m11 (loop1c1 , σ11 )) are not set, the loop counters of s1 and s2 are equal to i
and value stores agree on the values of variables in TVar(s)
and
∗
∗
(S2 ; whilehn2 i (e) {S2 }, m2 (loop2c [1/(n2 )], σ2 )) →
and, for every state in execution, (s1 , m1 ) → (s1 , m1i ) or
∗
21
21
(whilehn2 i (e) {S2 }, m21 (loopc , σ21 )) = (s2 , m21 (loopc , σ21 )). (s2 , m2 ) → (s2 , m2i ) the loop counters for s1 and s2 are less
(b) S1 and S2 do not terminate when started in states
than or equal to i respectively:
• The crash flags are not set.

32

2015/9/14

∗

∃(s1 , m1i ) (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 , loop1ci , σ1i ))∧
∗
(s2 , m2 ) → (s2 , m2i (f2 , loop2ci , σ2i )) where
• f1 = f2 = 0; and
• loop1c i (n1 ) = loop2c i (n2 ) = i; and
• ∀x ∈ TVar(s) : σ1i (x) = σ2i (x,; and
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1i ),
1′
loopc (n1 ) ≤ i; and
′
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2i ),
2′
loopc (n2 ) ≤ i;

1. The loop counters for s1 and s2 are less than i:
′
∗
∗
∀m′1 m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
′
2′
′
(S2 , m2 (loopc )),
′
′
loop1c (n1 ) < i and loop2c (n2 ) < i and one of the following
holds:
(a) s1 and s2 both terminate:
∗
∗
(s1 , m1 ) → (skip, m′′1 ) and (s2 , m2 ) → (skip, m′′2 ).
(b) s1 and s2 both do not terminate:
k
k
∀k > 0, (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 ) → (S2k , m2k )
in which S1k 6= skip, S2k 6= skip.

Then we show that, for the positive integer i + 1, one of the
following holds:
1. The loop counters for s1 and s2 are less than i + 1, and s1 and
s2 both terminate in the same way:
′
∗
∗
∀m′1 m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
′
′
′
2
(S2 , m2 (loopc )),
′
′
loop1c (n1 ) < i + 1 and loop2c (n2 ) < i + 1 and one of the
following holds:
(a) s1 and s2 both terminate:
∗
∗
(s1 , m1 ) → (skip, m′′1 ) and (s2 , m2 ) → (skip, m′′2 ).
(b) s1 and s2 both do not terminate:
k
k
∀k > 0, (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 ) → (S2k , m2k )
in which S1k 6= skip, S2k 6= skip.
2. The loop counters for s1 and s2 are less than or equal to
i + 1, and s1 and s2 do not terminate such that there are
no configurations (s1 , m1i+1 ) and (s2 , m2i+1 ) reachable from
(s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags are
set, the loop counters of s1 and s2 are equal to i + 1 and value
stores agree on the values of variables in TVar(s):
′

∗

∗

• ∀m′1 m′2 : (s1 , m1 ) → (S1 , m′1 (loop1c )), (s2 , m2 ) →

k

k

∗

∗

(s1 , m1 ) → (s1 , m1i+1 (f1 , loopc1i+1 , σ1i+1 ))∧(s2 , m2 ) →
(s2 , m2i+1 (f2 , loop2ci+1 , σ2i+1 )) where
f1 = f2 = 0; and
loop1ci+1 (n1 ) = loop2ci+1 (n2 ) = i + 1; and
∀x ∈ TVar(s) : σ1i+1 (x) = σ2i+1 (x).

When this case holds, we have the loop counter of s1 and s2 are
less than i + 1, and s1 and s2 both do not terminate:
′
∗
∗
∀m′1 m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
′
′
2′
(S2 , m2 (loopc )),
′
′
loop1c (n1 ) < i + 1 and loop2c (n2 ) < i + 1 and s1 and s2 both
do not terminate:
k
k
∀k > 0, (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 ) → (S2k , m2k )
in which S1k 6= skip, S2k 6= skip.
3. There are two configurations (s1 , m1i ) and (s2 , m2i ) reachable
from (s1 , m1 ) and (s2 , m2 ), respectively, in which crash flags
are not set, the loop counters of s1 and s2 are equal to i
and value stores agree on the values of variables in TVar(s)
∗
and, for every state in executions (s1 , m1 ) → (s1 , m1i ) and
∗
(s2 , m2 ) → (s2 , m2i ) the loop counters for s1 and s2 are less
than or equal to i respectively:
∗
∃(s1 , m1i ) (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 , loop1ci , σ1i ))∧
∗
2i
(s2 , m2 ) → (s2 , m2i (f2 , loopc , σ2i )) where
• f1 = f2 = 0; and
• loopc1i (n1 ) = loop2c i (n2 ) = i; and
• ∀x ∈ TVar(s), σ1i (x) = σ2i (x); and

3. There are two configurations (s1 , m1i+1 ) and (s2 , m2i+1 )
reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in which
the loop counters of s1 and s2 are equal to i + 1 and value
stores agree on the values of variables in TVar(s) and, for every
∗
∗
state in execution, (s1 , m1 ) → (s1 , m1i+1 ) or (s2 , m2 ) →
(s2 , m2i+1 ) the loop counters for s1 and s2 are less than or
equal to i + 1 respectively:
∃(s1 , m1i+1 ) (s2 , m2i+1 ) :
∗
∗
(s1 , m1 ) → (s1 , m1i+1 (loop1ci+1 , σ1i+1 )) ∧ (s2 , m2 ) →
(s2 , m2i+1 (loop2ci+1 , σ2i+1 )) where
• loop1c i+1 (n1 ) = loop2c i+1 (n2 ) = i + 1; and
• ∀x ∈ TVar(s) : σ1i+1 (x) = σ2i+1 (x); and
∗

• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1i ),
′

•

k

where S1k 6= skip, S2k 6= skip; and
∗
∄(s1 , m1i ), (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 , loop1ci , σ1i ))∧
∗
(s2 , m2 ) → (s2 , m2i (f2 , loop2ci , σ2i )) where
f1 = f2 = 0; and
loop1ci (n1 ) = loop2ci (n2 ) = i; and
∀x ∈ TVar(s) : σ1i (x) = σ2i (x).

k

where S1k 6= skip, S2k 6= skip; and

loop1c (n1 ) ≤ i + 1; and
′
∗
∗
∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) →
′
2
loopc (n2 ) ≤ i + 1;

∗

′

• ∀k > 0 : (s1 , m1 ) → (S1k , m1k ), (s2 , m2 ) → (S2k , m2k )

• ∄(s1 , m1i+1 ), (s2 , m2i+1 ) :

′

′

(S2 , m′2 (loop2c )) where loop1c (n1 ) ≤ i, loop2c (n2 ) ≤ i;

• ∀k > 0 : (s1 , m1 ) → (S1k , m1k ), (s2 , m2 ) → (S2k , m2k )

∗

′

∗

• ∀m′1 m′2 : (s1 , m1 ) → (S1 , m′1 (loop1c )), (s2 , m2 ) →
′

′

(S2 , m′2 (loop2c )) where
′
′
loop1c (n1 ) ≤ i + 1, loop2c (n2 ) ≤ i + 1;

When this case holds, then we have the loop counters for s1 and
s2 are less than i + 1, and s1 and s2 both terminate in the same
way:
′
∗
∗
∀m′1 m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and (s2 , m2 ) →
′
′
2′
(S2 , m2 (loopc )),
′
′
loop1c (n1 ) < i + 1 and loop2c (n2 ) < i + 1 and one of the
following holds:
(a) s1 and s2 both terminate:
∗
∗
(s1 , m1 ) → (skip, m′′1 ) and (s2 , m2 ) → (skip, m′′2 ).
(b) s1 and s2 both do not terminate:
k
k
∀k > 0, (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 ) → (S2k , m2k )
in which S1k 6= skip, S2k 6= skip.
2. The loop counters for s1 and s2 are less than or equal to i, and
s1 and s2 both do not terminate such that there are no configurations (s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and
(s2 , m2 ), respectively, in which the loop counters of s1 and s2
are equal to i and value stores agree on the values of variables
in TVar(s):

(s2 , m2i ),

By the hypothesis IH, one of the following holds:

33

2015/9/14

∗

′

∗

m1i (loop1ci [(i+1)/(n1 )], σ1i ) and m2i (loop2ci [(i+1)/(n2 )], σ2i )
respectively. Then there are two possibilities.
i. S1 and S2 terminate when started in states m1i (loop1ci [(i+
•
(s2 , m2i ),
1)/(n1 )], σ1i ) and
m2i (loop2ci [(i + 1)/(n2 )], σ2i ) respectively
∗
By similar argument in base case, evaluations of the predicate
(S1 ; s1 , m1i (loop1ci [(i + 1)/(n1 )], σ1i )) →
expression of s1 and s2 w.r.t value stores σ1i and σ2i produce
(s1 , m1i+1 (f1 , loop1ci+1 , σ1i+1 )) and
same value. Then there are three possibilities:
∗
(S2 ; s1 , m2i (loop2ci [(i + 1)/(n2 )], σ2i )) →
(a) E ′ JeKσ1i = E ′ JeKσ2i = (error, ∗).
2i+1
(s2 , m2i+1 (f2 , loopc , σ2i+1 )) such that all of the folThen the execution of s1 proceeds as follows.
lowing
holds:
(s1 , m1i (f1 , σ1i ))
• f1 = f2 = 0; and
= (whilehn1 i (e) {S1 }, m1i (f1 , σ1i ))
• loop1c i+1 (n1 ) = loop2c i+1 (n2 ) = i + 1; and
→(whilehn1 i ((error, ∗)) {S1 }, m1i (f1 , σ1i )) by the EEval’ rule
• ∀y ∈ TVar(s), σ1i+1 (y) = σ2i+1 (y), and
→(whilehn1 i (0) {S1 }, m1i (1/f1 )) by the ECrash rule
k
• in any state in the execution
→(whilehn1 i (0) {S1 }, m1i (1/f1 )), for any k ≥ 0, by the Crash rule.
∗
(s1 , m1i ) → (s1 , m1i+1 (loop1ci+1 , σ1i+1 )), the
Similarly, the execution of s2 started in the state m2i (σ2i )
loop counter of s1 is less than or equal to i + 1.
does not terminate.
• in any state in the executions
The loop counters for s1 and s2 are less than i + 1:
∗
′
∗
(s2 , m2i ) → (s2 , m2i+1 (loop2ci+1 , σ2i+1 )), the
∀m′1 m′2 such that (s1 , m1 ) → (S1′ , m′1 (loop1c )) and
′
∗
loop counter of s2 is less than or equal to i + 1.
(s2 , m2 ) → (S2′ , m′2 (loop2c )),
With the hypothesis IH, there are two configurations
1′
2′
loopc (n1 ) < i + 1 and loopc (n2 ) < i + 1.
(s1 , m1i+1 ) and (s2 , m2i+1 ) reachable from (s1 , m1 )
Besides, s1 and s2 both do not terminate when started in
and (s2 , m2 ), respectively, in which crash flags are not
states m1 and m2 ,
set, the loop counters of s1 and s2 are equal to i + 1
k
k
∀k > 0, (s1 , m1 ) → (S1k , m1k ) and (s2 , m2 ) → (S2k , m2k )
and value stores agree on the values of TVar(s) and, for
∗
in which S1k 6= skip, S2k 6= skip.
every state in executions (s1 , m1 ) → (s1 , m1i+1 ) and
′
′
(b) E JeKσ1i = E JeKσ2i = (0, vof )
∗
(s2 , m2 ) → (s2 , m2i+1 ) the loop counters for s1 and
The execution from (s1 , m1i (loop1ci , σ1i )) proceeds as fols
2 are less than or equal to i + 1 respectively:
lows.
∃(s1 , m1i+1 ) (s2 , m2i+1 ) :
∗
∗
(s1 , m1i (loop1ci , σ1i ))
(s1 , m1 ) → (s1 , m1i+1 (f1 , loop1ci+1 , σ1i+1 ))∧(s2 , m2 ) →
= (whilehn1 i (e) {S1 }, m1i (loop1ci , σ1i ))
2i+1
(s2 , m2i+1 (f2 , loopc , σ2i+1 )) where
→(whilehn1 i ((0, vof )) {S1 }, m1i (loop1ci , σ1i )) by rule EEval’
• f1 = f2 = 0; and
1i
→(whilehn1 i (0) {S1 }, m1i (loopc , σ1i ))
• loop1c i+1 (n1 ) = loop2c i+1 (n2 ) = i + 1; and
by rule E-Oflow1 or E-Oflow2
• ∀x ∈ TVar(s), σ1i+1 (x) = σ2i+1 (x); and
→(skip, m1i (loop1ci [0/(n1 )], σ1i )) by the Wh-F2 rule.
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) →
By the hypothesis IH, the loop counter of s1 and s2 in any
′
∗
(s1 , m1i+1 (loop1ci+1 , σ1i+1 )), loop1c (n1 ) ≤ i + 1;
configuration in executions (s1 , m1 ) → (s1 , m1i (loop1ci , σ1i ))
and
∗
′
∗
∗
and (s2 , m2 ) → (s2 , m2i (loop2ci , σ2i )) respectively are
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) →
less than or equal to i,
′
′
∗
∗
(s2 , m2i+1 (loop2ci+1 , σ2i+1 )), loop2c (n2 ) ≤ i + 1.
∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1i (loop1ci ,
′
ii.
S
and
S2 do not terminate when started in states
1
σ1i )), loop1c (n1 ) ≤ i; and
2i
1i
(loop
m
1
′
i
c [(i + 1)/(n1 )], σ1i ) and m2i (loopc [(i +
∗
∗
∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2i (loop2ci ,
)
respectively:
1)/(n
)],
σ
2
2i
′
k
σ2i )), loop2c (n2 ) ≤ i.
∀k > 0, (S1 , m1i (loop1ci [(i + 1)/(n1 )], σ1i )) →
1
Therefore, s1 and s2 both terminate and the loop counter
1
(S1k , m11k (loopc k , σ11k )) and
of s1 and s2 in any state in executions respectively are less
k
than i + 1.
(S2 , m2i (loop2ci [(i + 1)/(n2 )], σ2i )) →
21
′
′
/ {0, error};
(c) E JeKσ1i = E JeKσ2i = (v, vof ) where v ∈
(S2k , m21k (loopc k , σ21k )) in which S1k 6= skip, S2k 6=
The execution from (s1 , m1i (loop1ci , σ1i )) proceeds as folskip.
lows.
By our assumption of unique loop labels, s1 ∈
/ S1 .
11
(s1 , m1i (loop1ci , σ1i ))
Then, ∀k > 0, loopc k (n1 ) =
loop1ci [(i + 1)/(n1 )](n1 ) = i + 1. Similarly, ∀k >
= (whilehn1 i (e) {S1 }, m1i (loop1ci , σ1i ))
21
→(whilehn1 i ((v, vof )) {S1 }, m1i (loop1ci , σ1i )) by rule EEval’
0, loopc k (n2 ) =
1i
2
→(whilehn1 i ((v, vof )) {S1 }, m1i (loopc , σ1i )) by rule EEval’
loopci [(i + 1)/(n2 )](n2 ) = i + 1. In addition, by
→(whilehn1 i (v) {S1 }, m1i (loop1ci , σ1i ))
Lemma E.2,
k
by rule E-Oflow1 or E-Oflow2
∀k > 0, (S1 ; s1 , m1i (loop1ci [(i + 1)/(n1 )], σ1i )) →
11
→(S1 ; whilehn1 i (e) {S1 }, m1i (loop1ci [(i + 1)/(n1 )],
k
(S1k ; s1 , m11k (loopc , σ11k )) and (S2 ; s2 , m2 (loop2c [(i+
σ1i )) by rule Wh-T.
21
k
1)/(n2 )], σ2 )) → (S2k ; s2 , m21k (loopc k , σ21k )) in
2
2i
Similarly, (s2 , m2i (loopc , σ2i )) → (S2 ; whilehn2 i (e){S2 },
which S1k 6= skip, S2k 6= skip.
m2i (loop2ci [(i + 1)/(n2 )], σ2i )).
In summary, the loop counter of s1 and s2 are less than
By similar argument in base case, the executions of S1
equal to i + 1, and s1 and s2 do not terminate such that
and S2 terminate in the same way when started in states
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1i ),
′

loop1c (n1 ) ≤ i; and
′
∗
∗
∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) →
′
2
loopc (n2 ) ≤ i.

34

2015/9/14

there are no configurations (s1 , m1i+1 ) and (s2 , m2i+1 )
reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in
which crash flags are not set, the loop counters of s1 and
s2 are equal to i + 1 and value stores agree on values of
variables in TVar(s).

tively, in which both crash flags are not set, the loop counters of s1 and s2 are equal to j and value stores agree on
the values of variables in TVar(s), and for every state in ex∗
∗
ecution (s1 , m1 ) → (s1 , m1j ) or (s2 , m2 ) → (s2 , m2j ),
the loop counters for s1 and s2 are less than or equal to j
respectively:
∃(s1 , m1j ) (s2 , m2j ) :
1
∗
(s1 , m1 ) → (s1 , m1j (f1 , loopcj , σ1j ))∧
2j
∗
(s2 , m2 ) → (s2 , m2j (f2 , loopc , σ2j )) where
f1 = f2 = 0; and
2
1
loopcj (n1 ) = loopcj (n2 ) = j; and
∀x ∈ TVar(s) : σ1j (x) = σ2j (x); and

Corollary 5.3. Let s1 = “whilehn1 i (e){S1 }” and
s2 = “whilehn2 i (e){S2 }” be two while statements respectively,
with the same set of the termination deciding variables, TVar(s1 ) =
TVar(s2 ) = TVar(s), whose bodies S1 and S2 satisfy the proof
rule of equivalently computation of variables in TVar(s), ∀x ∈
TVar(s) : (S1 ) ≡S
x (S2 ), and whose bodies S1 and S2 terminate
in the same way when started in states with crash flags not set and
agreeing on values of variables in TVar(S1 ) ∪ TVar(S2 ):
∀mS1 (fS1 , σS1 ), mS2 (fS2 , σS2 ) :
(((∀z ∈ TVar(S1 )∪TVar(S2 )), σS1 (z) = σS2 (z))∧(fS1 = fS2 =
0)) ⇒ (S1 , mS1 (fS1 , σS1 )) ≡H (S2 , mS2 (fS2 , σS2 )).
If s1 and s2 start in the state m1 (f1 , loop1c , σ1 ) and m2 (f2 , loop2c ,
, σ2 ) respectively in which crash flags are not set, f1 =
f2 = 0, s1 and s2 have not already executed, loop1c (n1 ) =
loop2c (n2 ) = 0, value stores σ1 and σ2 agree on values of variables
in TVar(s), ∀x ∈ TVar(s), σ1 (x) = σ2 (x), then s1 and s2
terminate in the same way:
∗

′

∗

∗

∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1j ),
′
loop1c (n1 ) ≤ j; and
′
∗
∗
∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2j ),
′
loop2c (n2 ) ≤ j.

k

2. s1 and s2 both do not terminate, ∀k > 0, (s1 , m1 ) →
k
(S1k , m1k ), (s2 , m2 ) → (S2k , m2k ) where S1k 6= skip,
S2k 6= skip such that one of the following holds:
(a) For any positive integer i, there are two configurations
(s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and
(s2 , m2 ), respectively, in which both crash flags are not
set, the loop counters of s1 and s2 are equal to i and
value stores agree on the values of variables in TVar(s),
∗
and for every state in execution (s1 , m1 ) → (s1 , m1i ) or
∗
(s2 , m2 ) → (s2 , m2i ), the loop counters for s1 and s2 are
less than or equal to i respectively:
∀i > 0 ∃(s1 , m1i ) (s2 , m2i ) :
∗
(s1 , m1 ) → (s1 , m1i (f1 , loop1ci , σ1i ))∧
∗
(s2 , m2 ) → (s2 , m2i (f2 , loop2ci , σ2i )) where
• f1 = f2 = 0; and
• loop1c i (n1 ) = loop2c i (n2 ) = i; and
• ∀x ∈ TVar(s) : σ1i (x) = σ2i (x); and
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1i ),
1′
loopc (n1 ) ≤ i; and
′
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2i ),
2′
loopc (n2 ) ≤ i;
(b) The loop counters for s1 and s2 are less than a positive
integer i and less than or equal to i − 1 such that all of the
following hold:

∗

1. s1 and s2 both terminate, (s1 , m1 ) → (skip, m′1 ), (s2 , m2 ) →
(skip, m′2 ).
k

2. s1 and s2 both do not terminate, ∀k > 0, (s1 , m1 ) →
k
(S1k , m1k ), (s2 , m2 ) → (S2k , m2k ) where S1k 6= skip,
S2k 6= skip.
This is from Lemma 5.15 immediately.
Lemma5.16 is necessary only for showing the same I/O sequence in the next section.
Lemma 5.16. Let s1 = “whilehn1 i (e){S1 }” and
s2 = “whilehn2 i (e){S2 }” be two while statements in program
P1 and P2 respectively with the same set of termination deciding
variables, TVar(s1 ) = TVar(s2 ) = TVar(s), whose bodies S1 and
S2 satisfy the proof rule of equivalently computation of variables
in TVar(s), ∀x ∈ TVar(s) : S1 ≡S
x S2 and whose bodies S1
and S2 terminate in the same way in executions when started in
states with crash flags not set and agreeing on values of variables
in TVar(S1 ) ∪ TVar(S2 ):
∀mS1 (fS1 , σS1 ) mS2 (fS2 , σS2 ) :
(((∀z ∈ TVar(S1 )∪TVar(S2 )), σS1 (z) = σS2 (z))∧(fS1 = fS2 =
0)
⇒ (S1 , mS1 (fS1 , σS1 )) ≡H (S2 , mS2 (fS2 , σS2 )).
If s1 and s2 start in the state m1 (f1 , loop1c , σ1 ) and m2 (f2 , loop2c ,
, σ2 ) respectively in which crash flags are not set, f1 = f2 = 0, s1
and s2 have not already executed, loop1c (n1 ) = loop2c (n2 ) = 0,
value stores σ1 and σ2 agree on values of variables in TVar(s),
∀x ∈ TVar(s), σ1 (x) = σ2 (x), one of the following holds:

′

∗

• ∃i > 0, ∀m′1 m′2 : (s1 , m1 ) → (S1 , m′1 (loop1c )),
∗

′

′

(s2 , m2 ) → (S2 , m′2 (loop2c )) where loop1c (n1 ) < i,
′
loop2c (n2 ) < i;
• ∀0 < j < i, there are two configurations (s1 , m1j )
and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ),
respectively, in which both crash flags are not set, the
loop counters of s1 and s2 are equal to j and value
stores agree on the values of variables in TVar(s), and
∗
for every state in execution (s1 , m1 ) → (s1 , m1j ) or
∗
(s2 , m2 ) → (s2 , m2j ), the loop counters for s1 and s2
are less than or equal to j respectively:
∃(s1 , m1j ) (s2 , m2j ) :
1
∗
(s1 , m1 ) → (s1 , m1j (f1 , loopcj , σ1j ))∧
2
∗
(s2 , m2 ) → (s2 , m2j (f2 , loopcj , σ2j )) where
f1 = f2 = 0; and
2
1
loopcj (n1 ) = loopcj (n2 ) = j; and
∀x ∈ TVar(s) : σ1j (x) = σ2j (x); and

1. s1 and s2 both terminate and the loop counters of s1 and s2
are less than a positive integer i and less than or equal to i − 1:
∗
∗
(s1 , m1 ) → (skip, m′1 ), (s2 , m2 ) → (skip, m′2 ) where both of
the following hold:
• The loop counters of s1 and s2 are less than a positive
integer i:
∃i > 0 ∀m′1 m′2 :
′
′
∗
(s1 , m1 ) → (S1′ , m′1 (loop1c )), loop1c (n1 ) < i and
′
′
∗
(s2 , m2 ) → (S2′ , m′2 (loop2c )), loop2c (n2 ) < i.
• ∀0 < j < i, there are two configurations (s1 , m1j ) and
(s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ), respec-

35

2015/9/14

′

∗

∗

2

∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1j ),
′
loop1c (n1 ) ≤ j; and
′
∗
∗
∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2j ),
2′
loopc (n2 ) ≤ j;

Similarly, (s2 , m2 (loop2c , σ2 )) → (skip, m2 (loop2c \ {(n2 ,
, ∗)})). Then the lemma holds because of the initial configuration (s1 , m1 (loop1c , σ1 )) and (s2 , m2 (loop2c , σ2 )).
(b) i > 1.
Because s1 and s2 terminate, i is the smallest positive integer such that the loop counters of s1 and s2 are less than
i, by Lemma 5.15, ∀0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 )
and (s2 , m2 ), respectively, in which both crash flags are
not set, the loop counters of s1 and s2 are equal to j and
value stores agree on the values of variables in TVar(s),
∗
and for every state in execution, (s1 , m1 ) → (s1 , m1j ) or
∗
(s2 , m2 ) → (s2 , m2j ) the loop counters for s1 and s2 are
less than or equal to j respectively. With the initial configuration (s1 , m1 ) and (s2 , m2 ), the lemma holds.
2. s1 and s2 both do not terminate. There are three possibilities.
(a) ∀i > 0, there are two configurations (s1 , m1i ) and (s2 , m2i )
reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in
which both crash flags are not set, the loop counters of
s1 and s2 are equal to i and value stores agree on the values
of variables in TVar(s), and for every state in execution,
∗
∗
(s1 , m1 ) → (s1 , m1i ) or (s2 , m2 ) → (s2 , m2i ) the loop
counters for s1 and s2 are less than or equal to i respectively.
(b) The loop counters of s1 and s2 are less than a positive
integer i.
Let i be the smallest positive integer such that there is no
positive integer j < i that the loop counters of s1 and s2 are
less than the positive integer j. This case occurs when s1
and s2 finish the full (i−1)th iterations and both executions
raise an exception in the evaluation of the loop predicate of
s1 and s2 for the ith time. There are further two possibilities.
i. i = 1.
In proof of Lemma 5.15, evaluations of the predicate
expression of s1 and s2 raise an exception w.r.t value
stores σ1 and σ2 . The lemma holds.
ii. i > 1. By the assumption of initial states (s1 , m1 )
and (s2 , m2 ), when j = 0, initial states (s1 , m1 ) and
(s2 , m2 ) have crash flags not set, the loop counters of
s1 and s2 are zero and value stores agree on values of
variables of s1 and s2 .
By Lemma 5.15, ∀0 < j < i, there are two configurations (s1 , m1j ) and (s2 , m2j ) reachable from (s1 , m1 )
and (s2 , m2 ), respectively, in which both crash flags are
not set, the loop counters of s1 and s2 are equal to j and
value stores agree on the values of variables in TVar(s),
∗
and for every state in execution, (s1 , m1 ) → (s1 , m1j )
∗
or (s2 , m2 ) → (s2 , m2j ) the loop counters for s1 and
s2 are less than or equal to j respectively. With the initial
configuration (s1 , m1 ) and (s2 , m2 ), the lemma holds.
(c) The loop counters of s1 and s2 are less than or equal to a
positive integer i.
Let i be the smallest positive integer such that the loop
counters of s1 and s2 are less than or equal to the positive
integer i. There are two possibilities.
i. i = 1.
In the proof of Lemma 5.15, the execution of s1 proceeds as follows:
(s1 , m1 (loop1c , σ1 ))
= (whilehn1 i (e) {S1 }, m1 (loop1c , σ1 ))
→(whilehn1 i ((v, vof )) {S1 }, m1 (loop1c , σ1 )) where v 6= 0
by rule EEval’
→(whilehn1 i (v) {S1 }, m1 (loop1c , σ1 ))
by rule E-Oflow1 or E-Oflow2

(c) The loop counters for s1 and s2 are less than or equal to
some positive integer i such that all of the following hold:
′

∗

• ∃i > 0 ∀m′1 m′2 : (s1 , m1 ) → (S1 , m′1 (loop1c )),
∗

′
(S2 , m′2 (loop2c ))

′
loop1c (n1 )

where
≤ i,
(s2 , m2 ) →
′
loop2c (n2 ) ≤ i;
• ∀0 < j < i, there are two configurations (s1 , m1j )
and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ),
respectively, in which both crash flags are not set, the
loop counters of s1 and s2 are equal to j and value
stores agree on the values of variables in TVar(s), and
∗
for every state in execution (s1 , m1 ) → (s1 , m1j ) or
∗
(s2 , m2 ) → (s2 , m2j ), the loop counters for s1 and s2
are less than or equal to j respectively:
∃(s1 , m1j ) (s2 , m2j ) :
1
∗
(s1 , m1 ) → (s1 , m1j (f1 , loopcj , σ1j ))∧
2j
∗
(s2 , m2 ) → (s2 , m2j (f2 , loopc , σ2j )) where
f1 = f2 = 0; and
2
1
loopcj (n1 ) = loopcj (n2 ) = j; and
∀x ∈ TVar(s) : σ1j (x) = σ2j (x); and
∗

′

∗

∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1j ),
′
loop1c (n1 ) ≤ j; and
′
∗
∗
∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2j ),
2′
loopc (n2 ) ≤ j;
• There are no configurations (s1 , m1i ) and (s2 , m2i )
reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in
which crash flags are not set, the loop counters of s1 and
s2 are equal to i, and value stores agree on the values of
variables in TVar(s):
∄(s1 , m1i ) (s2 , m2i ) :
∗
(s1 , m1 ) → (s1 , m1i (f1 , loop1ci , σ1i ))∧
∗
(s2 , m2 ) → (s2 , m2i (f2 , loop2ci , σ2i )) where
f1 = f2 = 0; and
loop1ci (n1 ) = loop2ci (n2 ) = i; and
∀x ∈ TVar(s) : σ1i (x) = σ2i (x).
Proof. From lemma 5.15, we have s1 and s2 terminate in the same
way when started in states m1 and m2 respectively. Then there are
two big cases.
1. s1 and s2 both terminate.
Let i be the smallest integer such that the loop counters of s1
and s2 are less than i in the executions. Then there are two
possibilities.
(a) i = 1.
In the proof of Lemma 5.15, the evaluation of the loop
predicate of s1 and s2 produce zero w.r.t value stores, σ1
and σ2 . Then the execution of s1 proceeds as follows:
(s1 , m1 (loop1c , σ1 ))
= (whilehn1 i (e) {S1 }, m1 (loop1c ))
→(whilehn1 i ((0, vof )) {S1 }, m1 (loop1c )) by rule EEval’
→(whilehn1 i (0) {S1 }, m1 (loop1c ))
by rule E-Oflow1 or E-Oflow2
→(skip, m1 (loop1c \ {(n1 , ∗)}))
by rule Wh-F1 or Wh-F2.

36

2015/9/14

→(S1 ; whilehn1 i (e) {S1 }, m1 (loop1c [1/(n1 )], σ1 ))
by rule Wh-T .
The execution of s2 proceeds to
(S2 ; whilehn2 i (e) {S2 }, m2 (loop2c [1/(n2 )], σ2 )). In
addition, executions of S1 and S2 do not terminate when
started in states m1 (loop1c [1/(n1 )], σ1 ) and
m2 (loop2c [1/(n2 )], σ2 ). By Lemma E.2, executions of
s1 and s2 do not terminate.
ii. i > 1.
In the proof of Lemma 5.15, when started in the state
(s1 , m1i−1 (f1 , loop1ci−1 , σ1i−1 )) the execution of s1
proceeds as follows:
(s1 , m1i−1 (f1 , loop1ci−1 , σ1i−1 ))
= (whilehn1 i (e) {S1 }, m1i−1 (f1 , loop1ci−1 , σ1i−1 ))
→(whilehn1 i ((v, vof )) {S1 }, m1i−1 (f1 , loop1ci−1 , σ1i−1 ))
by rule EEval’
→(whilehn1 i (v) {S1 }, m1i−1 (f1 , loop1ci−1 , σ1i−1 ))
by rule E-Oflow1 or E-Oflow2
→(S1 ; whilehn1 i (e) {S1 },
m1i−1 (f1 , loop1ci−1 [i/(n1 )], σ1i−1 ))
by rule Wh-T1 or Wh-T2.
The execution of s2 proceeds to (S2 ; whilehn2 i (e) {S2 },
m2i−1 (f2 , loop2ci−1 [i/(n2 )], σ2i−1 )). In addition, executions of S1 and S2 do not terminate when started in
states m1i−1 (f1 , loop1ci−1 [i/(n1 )], σ1i−1 ) and
m2i−1 (f2 , loop2ci−1 [i/(n2 )], σ2i−1 ). By Lemma E.2,
executions of s1 and s2 do not terminate.

1. Impo (S) = {idIO }, if (∀e : “output e” ∈
/ S);
2. Impo (“output e”) = {idIO } ∪ Use(e);
3. Impo (“If (e) then {St } else {Sf }”) = Use(e) ∪ Impo (St ) ∪
Impo (Sf ) if (∃e : “output e” ∈ S);
4. Impo (“whilehni (e){S ′′ }”) = Imp(“whilehni (e){S ′′ }”, {idIO })
if (∃e : “output e” ∈ S ′′ );
5. For k > 0, Impo (s1 ; ...; sk ; sk+1 ) = Imp(s1 ; ...; sk , Impo (sk+1 ))
if (∃e : “output e” ∈ sk+1 );
6. For k > 0, Impo (s1 ; ...; sk ; sk+1 ) = Impo (s1 ; ...; sk ) if (∀e :
“output e” ∈
/ sk+1 );
Definition 22. (Termination deciding variables relative to output) The termination deciding variables in a statement sequence S
relative to output, written TVaro (S), are listed as follows:
1. TVaro (S) = ∅ if (∀e : “output e” ∈
/ S);
2. TVaro (“output e”) = Err(e);
3. TVaro (“If (e) then {St } else {Sf }”) = Use(e) ∪ TVaro (St ) ∪
TVaro (Sf ) if (∃e : “output e” ∈ S);
4. TVaro (“whilehni (e){S ′′ }”) = TVar(“whilehni (e){S ′′ }”) if
(∃e : “output e” ∈ S ′′ );
5. For k > 0, TVaro (s1 ; ...; sk ; sk+1 ) = TVar(s1 ; ...; sk )
∪Imp(s1 ; ...; sk , TVaro (sk+1 )) if (∃e : “output e” ∈ sk+1 );
6. For k > 0, TVaro (s1 ; ...; sk ; sk+1 ) = TVaro (s1 ; ...; sk ) if
(∀e : “output e” ∈
/ sk+1 );
Definition 23. (Output deciding variables) The output deciding
variables in a statement sequence S are Impo (S) ∪ TVaro (S),
written OVar(S).
The condition of the behavioral equivalence is defined recursively. The base case is for two same output statements or two
statements where the output sequence variable is not defined. The
inductive cases are syntax directed considering the syntax of compound statements and statement sequences.

5.4 Behavioral equivalence
We now propose a proof rule under which two programs produce
the same output sequence, namely the same I/O sequence till any
ith output value. We care about the I/O sequence due to the possible
crash from the lack of input. We start by giving the definition of the
same output sequence, then we describe the proof rule under which
two programs produce the same output sequence, finally we show
that our proof rule ensures same output together with the necessary
auxiliary lemmas. We use the notation “Out(σ)” to represent the
output sequence in value store σ, the I/O sequence σ(idIO ) till the
rightmost output value. Particularly, when there is no output value
in the I/O sequence σ(idIO ), Out(σ) = ∅.

Definition 24. (proof rule of behavioral equivalence) Two statement sequences S1 and S2 satisfy the proof rule of behavioral
equivalence, written S1 ≡S
O S2 , iff one of the following holds:

1. S1 and S2 are one statement and one of the following holds:
(a) S1 and S2 are simple statement and one of the following
holds:
i. S1 and S2 are not output statement, ∀e1 e2 :
(“output e1 ” 6= S1 ) ∧ (“output e2 ” 6= S2 ); or
ii. S1 = S2 = “output e”.
(b) S1 = “If (e) then {S1t } else {S1f }”, S2 = “If (e) then {S2t } else
{S2f }” and all of the following hold:
• There is an output statement in S1 and S2 ,
∃e1 e2 : (“output e1 ” ∈ S1 ) ∧ (“output e2 ” ∈ S2 );
f
f
t
S
• (S1t ≡S
O S2 ) ∧ (S1 ≡O S2 );
′′
(c) S1 = “whilehn1 i (e) {S1 }” and S2 = “whilehn2 i (e) {S2′′ }”
and all of the following hold:
• There is an output statement in S1 and S2 ,
∃e1 e2 : (“output e1 ” ∈ S1 ) ∧ (“output e2 ” ∈ S2 );
′′
• S1′′ ≡S
O S2 ;
′′
′′
• S1 and S2 have equivalent computation of OVar(S1 ) ∪
OVar(S2 );
• S1′′ and S2′′ satisfy the proof rule of termination in the
′′
same way, S1′′ ≡S
H S2 ;
(d) Output statements are not in both S1 and S2 ,
∀e1 e2 : (“output e1 ” ∈
/ S1 ) ∧ (“output e2 ” ∈
/ S2 ).
2. S1 and S2 are not both one statement and one of the following
holds:

Definition 20. (Same output sequence) Two statement sequences
S1 and S2 produce the same output sequence when started in
states m1 and m2 respectively, written (S1 , m1 ) ≡O (S2 , m2 ), iff
∗
∗
∀m′1 m′2 such that (S1 , m1 ) → (S1′ , m′1 (σ1′ )) and (S2 , m2 ) →
′
′
′
′′
′′
(S2 , m2 (σ2 )), there are states m1 m2 reachable from initial
∗
∗
states m1 and m2 , (S1 , m1 ) → (S1′′ , m′′1 (σ1′′ )) and (S2 , m2 ) →
′′
′′
′′
′′
′
′′
(S2 , m2 (σ2 )) so that Out(σ2 ) = Out(σ1 ) and Out(σ1 ) = Out(σ2′ ).
5.4.1 Proof rule for behavioral equivalence
We show the proof rules of the behavioral equivalence. The output sequence produced in executions of a statement sequence S
depends on values of a set of variables in the program, the output
deciding variables OVar(S). The output deciding variables are of
two parts: TVaro (S) are variables affecting the termination of executions of a statement sequence; Impo (S) are variables affecting
values of the I/O sequence produced in executions of a statement
sequence. The definitions of TVaro (S) and Impo (S) are shown in
Definition 21 and 22.
Definition 21. (Imported variables relative to output) The imported variables in one program S relative to output, written
Impo (S), are listed as follows:
37

2015/9/14

(a) S1 = S1′ ; s1 and S2 = S2′ ; s2 , and all of the following hold:
′
• S1′ ≡S
O S2 ;
′
• S1 and S2′ have equivalent computation of OVar(s1 ) ∪
OVar(s2 );
• S1′ and S2′ satisfy the proof rule of termination in the
′
same way: S1′ ≡S
H S2 ;
• There is an output statement in both s1 and s2 ,
∃e1 e2 : (“output e1 ” ∈ s1 ) ∧ (“output e2 ” ∈ s2 );
• s1 ≡S
O s2 ;
(b) There is no output statement in the last statement in S1 or
S2 :

(S1 = S1′ ; s1 ) ∧ (S1′ ≡S
/ s1 )
O S2 ) ∧ (∀e : “output e” ∈
′
∨ (S2 = S2′ ; s2 )∧(S1 ≡S
/ s2 ) ;
O S2 )∧(∀e : “output e” ∈

→(output 0, m1 (1/f)) by the ECrash rule
i
→(output 0, m1 (1/f)) for any i > 0 by the Crash rule.
Similarly, the execution of S2 does not terminate and
there is no change to I/O sequence in execution. Because
σ1 (idIO ) = σ2 (idIO ), then the output sequence in value
stores σ1 and σ2 are same, Out(σ1 ) = Out(σ2 ), the theorem holds.
(b) E JeKσ1 = E JeKσ2 6= (error, vof )
S1 and S2 satisfy the proof rule of equivalent computation
of I/O sequence variable and their initial states agree on the
values of the imported variables relative to I/O sequence
variable. By Theorem 2, S1 and S2 produce the same output
sequence after terminating execution when started in state
m1 (σ1 ) and m2 (σ2 ) respectively. The theorem holds.

5.4.2 Soundness of the proof rule for behavioral equivalence

Induction step.
The hypothesis IH is that Theorem 5 holds when size(S1 ) +
size(S2 ) = k ≥ 2.
We show Theorem 5 holds when size(S1 ) + size(S2 ) = k + 1.
The proof is a case analysis according to the cases in the definition
of the proof rule of behavioral equivalence.

We show that two statement sequences satisfy the proof rule of the
behavioral equivalence and their initial states agree on values of
their output deciding variables, then the two statement sequences
produce the same output sequence when started in their initial
states.
Theorem 5. Two statement sequences S1 and S2 satisfy the proof
rule of the behavioral equivalence, S1 ≡S
O S2 . If S1 and S2 start in
states m1 (f1 , σ1 ) and m2 (f2 , σ2 ) where both of the following hold:

1. S1 and S2 are one statement and one of the following holds:
(a) S1 = “If(e) then {S1t } else {S1f }” and S2 = “If(e) then
{S2t } else {S2f }” and all of the following hold:

• Crash flags are not set, f1 = f2 = 0;
• Value stores σ1 and σ2 agree on values of the output decid-

• There is an output statement in S1 and S2 : ∃e1 e2 :

ing variables of S1 and S2 , ∀id ∈ OVar(S1 ) ∪ OVar(S2 ) :
σ1 (id) = σ2 (id);

(“output e1 ” ∈ S1 ) ∧ (“output e2 ” ∈ S2 );

t
• S1t ≡S
O S2 ;
f
S
• S1 ≡O S2f ;

then S1 and S2 produce the same output sequence,
(S1 , m1 ) ≡O (S2 , m2 ).

By Lemma 5.17, {idIO } ∈ Impo (S1 ). By assumption,
value stores σ1 and σ2 agree on the value of the I/O sequence variable and the I/O sequence variable, σ1 (idIO ) =
σ2 (idIO ).
We show that the evaluations of the predicate expression of
S1 and S2 w.r.t. initial value store σ1 and σ2 produce the
same value. We need to show that value stores σ1 and σ2
agree on values of variables used in the predicate expression
e of S1 and S2 . Because the output sequence is defined
in S1 , by the definition of imported variables relative to
output, Impo (S1 ) = Use(e) ∪ Impo (S1t ) ∪ Impo (S1f ). Thus,
Use(e) ⊆ OVar(S1 ). By assumption, value stores σ1 and σ2
agree on values of variables used in the predicate expression
e of S1 and S2 , ∀x ∈ Use(e) : σ1 (x) = σ2 (x). By
Lemma D.1, the evaluations of the predicate expression of
S1 and S2 w.r.t. pairs value stores, σ1 and σ2 generate
the same value, E ′ JeKσ1 = E ′ JeKσ2 . Then there are two
possibilities.
i. E ′ JeKσ1 = E ′ JeKσ2 = (error, vof ).
Then the execution of S1 proceeds as follows:

The proof is by induction on the sum of program size of S1 and
S2 , size(S1 ) + size(S2 ) and is a case analysis based on S1 ≡S
O S2 .

Proof. The proof is by induction on the sum of program size of
S1 and S2 , size(S1 ) + size(S2 ) and is a case analysis based on
S1 ≡S
O S2 .
Base case.
S1 and S2 are simple statement. There are two cases according
to the proof rule of behavioral equivalence because stacks are not
changed in executions of S1 and S2 .
1. S1 and S2 are not output statement, ∀e1 e2 : (“output e1 ” 6=
S1 ) ∧ (“output e2 ” 6= S2 );
By the definition of imported variables relative to output,
Impo (S1 ) = Impo (S2 ) = {idIO }. By assumption, initial value
stores σ1 and σ2 agree on the value of the I/O sequence variable,
σ1 (idIO ) = σ2 (idIO ). By definition, Out(σ1 ) = Out(σ2 ).
By Lemma 5.23, in any state m′1 reachable from m1 , the output
∗
sequence in m′1 is same as that in m1 , ∀m′1 : ((S1 , m1 (σ1 )) →
′
′
′
′
(S1 , m1 (σ1 ))) ⇒ (Out(σ1 ) = Out(σ1 )). Similarly, for any
state m′2 reachable from m2 , the output sequence in m′2 is
same as that in m2 . The theorem holds.
2. S1 = S2 = “output e”.
We show that the expression e evaluates to the same value w.r.t
value stores, σ1 , σ2 . By the definition of imported variables relative to output, Impo (S1 ) = Impo (S2 ) = Use(e) ∪ {idIO }.
Then ∀x ∈ Use(e) ∪ {idIO } : σ1 (x) = σ2 (x) by assumption. By Lemma D.1, E JeKσ1 = E JeKσ2 . Then, there are two
possibilities.
(a) E JeKσ1 = E JeKσ2 = (error, vof ).
The execution of S1 proceeds as follows.
(output e, m1 (σ1 ))
= (output (error, vof ), m1 (σ1 )) by the rule EEval’

(If(e) then {S1t } else {S1f }, m1 (σ1 ))
→(If((error, vof )) then {S1t } else {S1f }, m1 (σ1 ))
by the EEval’ rule
→(If(0) then {S1t } else {S1f }, m1 (1/f))
by the ECrash rule
i
→(If(0) then {S1t } else {S1f }, m1 (1/f))
for any i > 0, by the Crash rule.
Similarly, the execution of S2 does not terminate and
does not redefine I/O sequence. Because σ1 (idIO ) =
σ2 (idIO ), the theorem holds.
ii. E ′ JeKσ1 = E ′ JeKσ2 6= (error, vof ).
W.l.o.g., E ′ JeKσ1 = E ′ JeKσ2 = (0, vof ). The execution
of S1 proceeds as follows.

38

2015/9/14

(If(e) then {S1t } else {S1f }, m1 (σ1 ))
→(If((0, vof )) then {S1t } else {S1f }, m1 (σ1 ))
by the EEval rule
→(If(0) then {S1t } else {S1f }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(S1f , m1 (σ1 )) by the If-F rule.

By Lemma 5.19, Impo (S1 ) = Impo (S2 ). By definition, Impo (S1 ) = Imp(S1 , {idIO }) and Impo (S2 ) =
Imp(S2 , {idIO }). Thus, Imp(S1 , {idIO }) = Imp(S2 , {idIO }).
• The loop body of S1 and S2 produce the same output sequence when started in states with crash flags not set and
whose value stores agree on values of the out-deciding
variables of S1′′ and S2′′ , ∀mS1′′ (f′′1 , σ1′′ ) mS2′′ (f′′2 , σ2′′ ) :
((∀x ∈ OVar(S1′′ ) ∪ OVar(S2′′ ) : σ1′′ (x) = σ2′′ (x)) ∧
(f′′1 = f′′2 = 0)) ⇒ (S1′′ , mS1′′ (f′′1 , σ1′′ )) ≡O (S2′′ , mS2′′ (f′′2 , σ2′′ )).
Because size(S1 ) = 1 + size(S1′′ ), size(S2 ) = 1 +
size(S2′′ ), then size(S1′′ ) + size(S2′′ ) < k. By the hypothesis IH, the condition is satisfied.
By Corollary 5.5, S1 and S2 produce the same output sequence when started in states m1 (σ1 ) and m2 (σ2 ) respectively. The theorem holds.
(c) Output statements are not in both S1 and S2 , ∀e1 e2 :
(“output e1 ” ∈
/ S1 ) ∧ (“output e2 ” ∈
/ S2 ).
By Lemma 5.17, {idIO } ⊆ Impo (S1 ). By assumption,
value stores in initial states m1 , m2 agree on values of
the I/O sequence variable, σ1 (idIO ) = σ2 (idIO ). By
Lemma 5.23, the value of output sequence is same in m1
∗
and any state reachable from m1 , ∀m′1 m′2 : (S1 , m1 (σ1 )) →
∗
(S1′ , m′1 (σ1′ )) and (S2 , m2 (σ2 )) → (S2′ , m′2 (σ2′ )), Out(σ1′ ) =
Out(σ1 ) = Out(σ2 ) = Out(σ2′ ). The theorem holds.

Similarly, the execution of S2 proceeds to (S2f , m2 (σ2 ))
after two steps. By the hypothesis IH, we show that S1f
and S2f produce the same output sequence when started
in states m1 (σ1 ) and m2 (σ2 ). We need to show that all
required conditions are satisfied.
• size(S1f ) + size(S2f ) ≤ k.
By definition, size(S1 ) = 1 + size(S1t ) + size(S1f ).
Therefore, size(S1f ) + size(S2f ) < k.
• Value stores σ1 and σ2 agree on values of the outdeciding variables of S1f and S2f , ∀x ∈ OVar(S1f ) ∪
OVar(S2f ) : σ1 (x) = σ2 (x).
By the definition of imported variables relative to
output, Impo (S1f ) ⊆ Impo (S1 ). Besides, by the
definition of TVaro (S1 ), TVaro (S1f ) ⊆ TVaro (S1 ).
Then OVar(S1f ) ⊆ OVar(S1 ). Similarly, OVar(S2f ) ⊆
OVar(S2 ).By assumption, the value stores σ1 and σ2
agree on the values of the out-deciding variables of
S1f and S2f .
By the hypothesis IH, S1f and S2f produce the same
output sequence when started from state m1 (σ1 ) and
m2 (σ2 ) respectively. The theorem holds.
(b) S1 = “whilehn1 i (e) {S1′′ }” and S2 = “whilehn2 i (e) {S2′′ }”
and all of the following hold:

2. S1 = S1′ ; s1 and S2 = S2′ ; s2 are not both one statement and
one of the following holds:
(a) There is an output statement in both s1 and s2 , ∃e1 e2 :
(“output e1 ” ∈ s1 ) ∧ (“output e2 ” ∈ s2 ), and all of the
following hold:
′
• S1′ ≡S
O S2 ;
′
• S1 and S2′ satisfy the proof rule of termination in the

• There is an output statement in S1 and S2 : ∃e1 e2 :

(“output e1 ” ∈ S1 ) ∧ (“output e2 ” ∈ S2 );

′
same way: S1′ ≡S
H S2 ;
′
′
• S1 and S2 have equivalent computation of OVar(s1 ) ∪
OVar(s2 );
• s1 ≡S
O s2 ;

′′
• S1′′ ≡S
O S2 ;
• Both loop bodies satisfy the proof rule of termination in
′′
the same way: S1′′ ≡S
H S2 ;

• S1′′ and S2′′ have equivalent computation of OVar(S1 ) ∪

OVar(S2 );

By Corollary 5.5, we show that S1 and S2 produce the same
output sequence when started in states m1 (σ1 ) and m2 (σ2 )
respectively. We need to show that the required conditions
are satisfied.
• Crash flags are not set, f1 = f2 = 0.
• Value stores σ1 and σ2 agree on the values of the outdeciding variables of S1 and S2 , ∀x ∈ OVar(S1 ) ∪
OVar(S2 ) : σ1 (x) = σ2 (x).
• The loop counter value of S1 and S2 are zero in initial
loop counter, loop1c (n1 ) = loop2c (n2 ) = 0.
• The loop body of S1 and S2 satisfy the proof rule of
′′
termination in the same way, S1′′ ≡S
H S2 .
• The loop body of S1 and S2 satisfy the proof rule of
equivalent computation of OVar(S1 ) ∪ OVar(S2 ).
The above five conditions are from assumption.
• S1 and S2 have same set of termination deciding variables, TVar(S1 ) = TVar(S2 ).
By the definition of TVaro (S1 ), TVaro (S1 ) = TVar(S1 )
and TVaro (S2 ) = TVar(S2 ). By Lemma 5.21, TVaro (S1 ) =
TVaro (S2 ). Thus, TVar(S1 ) = TVar(S2 ).
• S1 and S2 have same set of imported variables relative
to the I/O sequence variable,
Imp(S1 , {idIO }) = Imp(S2 , {idIO }).
39

By the hypothesis IH, we show S1′ and S2′ produce the same
output sequence when started in states m1 (σ1 ) and m2 (σ2 )
respectively. We need to show that all required conditions
are satisfied.
• size(S1′ ) + size(S2′ ) < k.
By the definition of program size, size(s1 ) ≥ 1, size(s2 ) ≥
1. Then size(S1′ ) + size(S2′ ) < k.
• Value stores σ1 and σ2 agree on values of the outdeciding variables of S1′ and S2′ , ∀x ∈ OVar(S1′ ) ∪
OVar(S2′ ) : σ1 (x) = σ2 (x).
We show that TVaro (S1′ ) ⊆ TVaro (S1 ).
TVaro (S1′ )
⊆ TVar(S1′ ) by Lemma 5.20
⊆ TVaro (S1 ) by the definition of TVaro (S1 )
We show that Impo (S1′ ) ⊆ Impo (S1 ).
Impo (S1′ )
⊆ Imp(S1′ , {idIO }) (1) by Lemma 5.18
{idIO } ⊆ Impo (sk+1 ) (2) by Lemma 5.17
Combining (1) + (2)
Imp(S1′ , {idIO })
⊆ Imp(S1′ , Impo (s1 )) by Lemma C.2
= Impo (S1 ) by the definition of Impo (S).
2015/9/14

Similarly, OVar(S2′ ) ⊆ OVar(S2 ). By assumption, value
stores σ1 and σ2 agree on values of out-deciding variables of S1′ and S2′ .
By the hypothesis IH, S1′ and S2′ produce the same output
sequence when started in state m1 (σ1 ) and m2 (σ2 ) respectively.
We show that S1 and S2 produce the same output sequence
if s1 and s2 execute. We need to show that S1′ and S2′ terminate in the same way when started in states m1 (σ1 ) and
m2 (σ2 ) respectively. Specifically, we prove that the value
stores σ1 and σ2 agree on the values of termination deciding
variables of S1′ and S2′ . By definition, the termination deciding variables in S1′ are a subset of the termination deciding
variables relative to output, TVar(S1′ ) ⊆ TVaro (S1 ). Similarly, TVar(S2′ ) ⊆ TVaro (S2 ). By assumption, the value
stores σ1 and σ2 agree on the values of the termination deciding variables of S1′ and S2′ , ∀x ∈ TVar(S1′ )∪TVar(S2′ ) :
σ1 (x) = σ2 (x). By Theorem 4, S1′ and S2′ terminate in the
same way when started in state m1 (σ1 ) and m2 (σ2 ) respectively.
If S1′ and S2′ terminate when started in states m1 (σ1 ) and
m2 (σ2 ), by Lemma 5.14, S1′ and S2′ consume same amount
of input values. In addition, we show that value stores agree
on values of the out-deciding variables of s1 and s2 by
Theorem 2. We need to show that S1′ and S2′ start execution
in states agreeing on values of the imported variables in S1′
and S2′ relative to the out-deciding variables of s1 and s2 .
• Imp(TVaro (s1 ), S1′ ) ⊆ TVaro (S1 ).
This is by the definition of TVaro (S1 ).
• Imp(Impo (s1 ), S1′ ) = Impo (S1 ).
This is by the definition of Impo (S1 ).
Thus, the imported variables in S1′ relative to the outdeciding variables of s1 are a subset of the out-deciding
variables of S1 , Imp(S1′ , OVar(s1 )) ⊆ OVar(S1 ). Similarly, Imp(S2′ , OVar(s2 )) ⊆ OVar(S2 ). By Corollary 5.4,
s1 and s2 have same out-deciding variables, OVar(s1 ) =
OVar(s2 ). By assumption, S1′ and S2′ terminate when
∗
started in states m1 (σ1 ) and m2 (σ2 ), (S1′ , m1 (σ1 )) →
∗
′
′
′
′
′
(skip, m1 (σ1 )), (S2 , m1 (σ2 )) → (skip, m2 (σ2 )). By Theorem 2, value stores σ1′ and σ2′ agree on values of the outdeciding variables of s1 and s2 .
By the hypothesis IH again, s1 and s2 produce the same
output sequence when started in states m′1 (σ1′ ) and m′2 (σ2′ )
respectively. The theorem holds.
(b) There is no output statement in the last statement in S1 or
S2 : W.l.o.g., (∀e : “output e” ∈
/ s1 ) ∧ ((S1′ ) ≡S
O (S2 )).
By the hypothesis IH, we show that S1′ and S2 produce the
same output sequence when started in states m1 (σ1 ) and
m2 (σ2 ) respectively. We need to show that two required
conditions are satisfied.
• size(S1′ ) + size(S2 ) ≤ k.
size(s1 ) ≥ 1 by definition. Then size(S1′ ) + size(S2 ) ≤
k.
• ∀x ∈ OVar(S1′ ) ∪ OVar(S2 ) : σ1 (x) = σ2 (x).
By definition of TVaro (S)/Impo (S), TVaro (S1′ ) =
TVaro (S1 ), and Impo (S1′ ) = Impo (S1 ) Hence, ∀x ∈
OVar(S1′ ) ∪ OVar(S2 ) : σ1 (x) = σ2 (x).
Therefore, S1′ and S2 produce the same output sequence
when started in state m1 (σ1 ) and m2 (σ2 ) respectively,
(S1′ , m1 ) ≡O (S2 , m2 ) by the hypothesis IH.
When the execution of S1′ terminates, then the output sequence is not changed in the execution of s1 by Lemma 5.23.
The theorem holds.

5.4.3 Supporting lemmas for the soundness proof of
behavioral equivalence
We listed the lemmas and corollaries used in the proof of Theorem 5 below. The supporting lemmas are of two parts. One part is
various properties related to the out-deciding variables. The other
part is the proof that two loop statements produce the same output
sequence.
Lemma 5.17. For any statement sequence S, the I/O sequence
variable is in imported variable in S relative to output, idIO ∈
Impo (S).
Proof. By structure induction on abstract syntax of S.
Lemma 5.18. For any statement sequence S, the imported variables in S relative to output are a subset of the imported variables in S relative to the I/O sequence variable, Impo (S) ⊆
Imp(S, {idIO }).
Proof. By induction on abstract syntax of S. In every case, there
are subcases based on if there is output statement in the statement
sequence S or not if necessary.
Lemma 5.19. If two statement sequences S1 and S2 satisfy the
proof rule of behavioral equivalence, then S1 and S2 have the
same set of imported variables relative to output, (S1 ≡S
O S2 ) ⇒
(Impo (S1 ) = Impo (S2 )).
Proof. By induction on size(S1 ) + size(S2 ).
Lemma 5.20. For any statement sequence S and any variable x,
the termination deciding variables in S relative to output is a subset
of the termination deciding variables in S, TVaro (S) ⊆ TVar(S).
Proof. By induction on abstract syntax of S. In every case, there
are subcases based on if there is output statement in the statement
sequence S or not if necessary.
Lemma 5.21. If two statement sequences S1 and S2 satisfy the
proof rule of behavioral equivalence, then S1 and S2 have the same
set of termination deciding variables relative to output, (S1 ≡S
O
S2 ) ⇒ (TVaro (S1 ) = TVaro (S2 )).
Proof. By induction on size(S1 ) + size(S2 ).
Corollary 5.4. If two statement sequences S1 and S2 satisfy the
proof rule of behavioral equivalence, then S1 and S2 have the
same set of out-deciding variables, (S1 ≡S
O S2 ) ⇒ OVar(S1 ) =
OVar(S2 ).
Proof. By Lemma 5.19, Impo (S1 ) = Impo (S2 ). By Lemma 5.21,
TVaro (S1 ) = TVaro (S2 ).
Lemma 5.22. In one step execution (S, m(σ)) → (S ′ , m′ (σ ′ )), if
there is no output statement in S, then the output sequence is same
in value store σ and σ ′ , Out(σ ′ ) = Out(σ).
Proof. By induction on abstract syntax of S and crash flag f in state
m.
Lemma 5.23. If there is no output statement in S, then, after the
∗
execution (S, m(σ)) → (S ′ , m′ (σ ′ )), the output sequence is same
in value store σ and σ ′ , Out(σ ′ ) = Out(σ).

40

2015/9/14

the configuration (S; s, mi (f, loopic , σi )) reachable from (s, m) in
which the loop counter is i, loopic (n) = i, and the crash flag is not
set, f = 0. By the assumption of unique loop labels, s ∈
/ S. Then
the loop counter of s is not redefined in the execution of S started
in state mi (f, loopic , σi ). Because there is a configuration in which
the loop counter of s is i + 1, then the execution of S when started
∗
in the state mi (f, loopic , σi ) terminates, (S, mi (f, loopic , σi )) →
i+1
i+1
(skip, mi+1 (f, loopc , σi+1 )) where f = 0 and loopc (n) = i.
∗
, σi+1 )).
By Corollary E.1, (S; s, mi (f, loopic , σi )) → (s, mi+1 (f, loopi+1
c
By similar argument in base case, the evaluation of the predicate
expression w.r.t the value store σi+1 produce nonzero integer value.
The execution of s proceeds as follows:

Proof. By induction on number k of execution steps in the execuk
tion (S, m(σ)) → (S ′ , m′ (σ ′ )). The proof also relies on the fact
that if s ∈
/ S, then s ∈
/ S′.
Lemma 5.24. One while statement s = “whilehni (e){S}” starts
in a state m(f, loopc ) in which the loop counter of s is zero,
loopc (n) = 0 and the crash flag is not set, f = 0. For any positive
integer i, if there is a state m′ (m′c ) reachable from m in which
the loop counter is i, loop′c (n) = i, then there is a configuration
(S; s, m′′ (f′′ , loop′′c )) reachable from the configuration (s, m) in
which loop counter of s is i, loop′′c (n) = i and the crash flag is not
set, f′′ = 0:
∗
∀i > 0 : (((s, m(f, mc )) → (S ′ , m′ (f′ , loop′c ))) ∧ (loopc (n) =
0) ∧ (f = 0) ∧ (loop′c (n) = i)) ⇒
∗
(s, m(f, loopc )) → (S; s, m′′ (f, loop′′c )) where f = 0 and
′′
loopc (n) = i.

(s, mi+1 (f, loopi+1
, σi+1 ))
c
= (whilehni (e) {S}, mi+1 (f, loopi+1
, σi+1 ))
c
→(whilehni (E JeKσi+1 ) {S}, mi+1 (f, loopi+1
, σi+1 ))
c
by the EEval rule
→(S; whilehni (e) {S}, mi+1 (f, loopi+1
[(i + 1)/n], σi+1 ))
c
by the Wh-T rule.

Proof. The proof is by induction on i.
Base case i = 1.
We show that the evaluation of the loop predicate of s w.r.t the
value store σ in the state m(loopc , σ) produces an nonzero integer
value. By our semantic rule, if the evaluation of the predicate
expression of s raises an exception, the execution of s proceeds
as follows:

The lemma holds.
Lemma 5.25. Let s1 = “whilehn1 i (e) {S1 }” and s2 = “whilehn2 i (e)
{S2 }” be two while statements and all of the followings hold:

• There are output statements in s1 and s2 , ∃e1 e2 : (“output e1 ” ∈
(s, m(f, loopc , σ))
s1 ) ∧ (“output e2 ” ∈ s2 );
= (whilehni (e) {S}, m(loopc , σ))
•
s1 and s2 have the same set of termination deciding vari→(whilehni (error) {S}, m(loopc , σ)) by the EEval rule
ables relative to output, and the same set of imported variables
→(whilehni (0) {S}, m(1/f, loopc , σ)) by the ECrash rule
relative to output, (TVaro (s1 ) = TVaro (s2 ) = TVar(s)) ∧
k
→(whilehni (0) {S}, m(1/f, loopc )) for any k > 0, by the Crash rule.
(Impo (s1 ) = Impo (s2 ) = Imp(io));
• Loop bodies S1 and S2 satisfy the proof rule of equivalent
Hence, we have a contradiction that there is no configuration in
computation of the out-deciding variables of s1 and s2 , ∀x ∈
which the loop counter of s is 1.
OVar(s) = TVar(s) ∪ Imp(io) : S1 ≡S
x S2 ;
When the evaluation of the loop predicate expression of s pro•
Loop
bodies
S
and
S
satisfy
the
proof
rule of termination in
1
2
duce zero, the execution of s proceeds as follows:
the same way, S1 ≡S
H S2 ;
(s, m(f, loopc , σ))
• Loop bodies S1 and S2 produce the same output sequence
= (whilehni (e) {S}, m(loopc , σ))
when started in states with crash flags not set and whose value
→(whilehni (0) {S}, m(loopc , σ)) by the EEval rule
stores agree on values of variables in OVar(S1 ) ∪ OVar(S2 ),
→(skip, m(loopc [0/n1 ])) by the Wh-F rule.
∀mS1 (f1 , σS1 ) mS2 (f2 , σS2 ) :
((f1 = f2 = 0) ∧ (∀x ∈ OVar(S1 ) ∪ OVar(S2 ) : σS1 (x) =
Hence, we have a contradiction that there is no configuration in
σS2 (x))) ⇒
which the loop counter of s is 1. The evaluation of the predicate
((S1 , mS1 (f1 , σS1 )) ≡O (S2 , mS2 (f2 , σS2 ))).
expression of s w.r.t value store σ produce nonzero value. The
If s1 and s2 start in states m1 (f1 , loop1c , σ1 ), m2 (f2 , loop2c , σ2 )
execution of s proceeds as follows:
respectively with crash flags not set f1 = f2 = 0 and in which s1
(s, m(f, loopc , σ))
and s2 have not started execution (loop1c (n1 ) = loop2c (n2 ) = 0),
= (whilehni (e) {S}, m(f, loopc , σ))
value stores σ1 and σ2 agree on values of variables in OVar(s),
→(whilehni (E JeKσ) {S}, m(f, loopc , σ)) by the EEval rule
∀x ∈ OVar(s) : σ1 (x) = σ2 (x), then one of the followings holds:
→(S; whilehni (e) {S}, m(f, loopc [1/n1 ], σ)) by the Wh-T rule.
1. s1 and s2 both terminate and produce the same output sequence:
The lemma holds.
∗
∗
(s1 , m1 ) → (skip, m′1 (σ1′ )), (s2 , m2 ) → (skip, m′2 (σ2′ ))
Induction step.
′
′
′
i
where σ1 (idIO ) = σ2 (idIO ).
The hypothesis IH is that, if there is a configuration (S , mi (loopc ))
k
reachable from (s, m) in which the loop counter of s is i, loopic (n) =
2. s1 and s2 both do not terminate, ∀k > 0, (s1 , m1 ) →
k
i > 0, then there is a reachable configuration (S; s, mi (f, loopic ))
(S1k , m1k ), (s2 , m2 ) → (S2k , m2k ) where S1k 6= skip,
from (s, m) where the loop counter of s is i and the crash flag is
S2k 6= skip and one of the followings holds:
not set.
(a) For any positive integer i, there are two configurations
Then we show that, if there is a configuration (S ′ , mi+1 (loopi+1
))
c
(s1 , m1i ) and (s2 , m2i ) reachable from (s1 , m1 ) and
reachable from (s, m) in which the loop counter of s is i + 1, then
(s2 , m2 ), respectively, in which both crash flags are not
there is a reachable configuration (S; s, mi+1 (f, loopi+1
))
from
c
set, the loop counters of s1 and s2 are equal to i and
(s, m) where the loop counter of s is i + 1 and the crash flag f is
value stores agree on values of variables in OVar(s), and
not set.
∗
for every state in execution, (s1 , m1 ) → (s1 , m1i ) or
By Lemma E.8, the loop counter of s is increasing by one in
∗
one step. Hence, there must be one configuration reachable from
(s2 , m2 ) → (s2 , m2i ), loop counters for s1 and s2 are
(s, m) in which the loop counter of s is i. By hypothesis, there is
less than or equal to i respectively:

41

2015/9/14

∗

∀i > 0 ∃(s1 , m1i ) (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 ,
∗
loop1ci , σ1i )) ∧ (s2 , m2 ) → (s2 , m2i (f2 , loop2ci , σ2i ))
where
• f1 = f2 = 0; and
• loop1c i (n1 ) = loop2c i (n2 ) = i; and
• ∀x ∈ OVar(s) : σ1i (x) = σ2i (x).
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1i (loop1c i ,
′
σ1i )), loop1c (n1 ) ≤ i; and
′
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2i (loop2c i ,
′
σ2i )), loop2c (n2 ) ≤ i;
(b) The loop counters for s1 and s2 are less than a smallest
positive integer i and all of the followings hold:
′

∗

• ∃i > 0 ∀m′1 , m′2 : (s1 , m1 ) → (S1′ , m′1 (loop1c )),
′

∗

′

(s2 , m2 ) → (S2′ , m′2 (loop2c )) where loop1c (n1 ) < i,
′
loop2c (n2 ) < i;
• ∀0 < j < i, there are two configurations (s1 , m1j )
and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ),
respectively, in which both crash flags are not set, loop
counters of s1 and s2 are equal to j and value stores
agree on values of variables in OVar(s):
1
∗
∃(s1 , m1j ), (s2 , m2j ) : (s1 , m1 ) → (s1 , m1j (f1 , loopcj ,
2
∗
σ1j )) ∧ (s2 , m2 ) → (s2 , m2j (f2 , loopcj , σ2j )) where
f1 = f2 = 0; and
2
1
loopcj (n1 ) = loopcj (n2 ) = j; and
∀x ∈ OVar(s) : σ1j (x) = σ2j (x).
• If i = 1, then the I/O sequence is not redefined in any
states reachable from (s1 , m1 ) and (s2 , m2 ).
∗

∀m′′1 : (s1 , m1 (loop1c , σ1 )) → (S1′′ , m′′1 (σ1′′ ))
where σ1′′ (idIO ) = σ1 (idIO ).
∗
∀m′′2 : (s2 , m2 (loop2c , σ2 )) → (S2′′ , m′′2 (σ2′′ ))
′′
where σ2 (idIO ) = σ2 (idIO ).

∗

∀m′′1 : (s1 , m1i−1 (loopci−1 , σ1i−1 )) → (S1′′ , m′′1 (σ1′′ ))
where σ1′′ (idIO ) = σ1i−1 (idIO ).
∗

∀m′′2 : (s2 , m2i−1 (loopci−1 , σ2i−1 )) → (S2′′ , m′′2 (σ2′′ ))
where σ2′′ (idIO ) = σ2i−1 (idIO ).
(c) The loop counters for s1 and s2 are less than or equal to a
smallest positive integer i and all of the followings hold:
′

∗

• ∃i > 0 ∀m′1 , m′2 : (s1 , m1 ) → (S1′ , m′1 (loop1c )), (s2 ,
∗

′

• Loop bodies S1 and S2 satisfy the proof rule of termination in

the same way;
By assumption.
• Loop bodies S1 and S2 satisfy the proof rule of equivalent
computation of those in the termination deciding variables of
s1 and s2 , ∀x ∈ TVar(s1 ) ∪ TVar(s2 ) : S1 ≡S
x S2 ;
By the definition of OVar(s), TVaro (s1 ) ⊆ OVar(s1 ) and
TVaro (s2 ) ⊆ OVar(s2 ). By the definition of TVaro , TVaro (s1 ) =
TVar(s1 ) and TVaro (s2 ) = TVar(s2 ).

• Crash flags are not set, f1 = f2 = 0;
• Loop counters of s1 and s2 are initially zero, loop1c (n1 ) =

states reachable from (s1 , m1i−1 ) and (s2 , m2i−1 ).

2

Proof. We show that s1 and s2 terminate in the same way when
started in states m1 (f1 , loop1c , σ1 ) and m2 (f2 , loop2c , σ2 ) respectively, (s1 , m1 ) ≡H (s2 , m2 ). In addition, we show that s1 and s2
produce the same output sequence in every possibilities of termination in the same way, (s1 , m1 ) ≡O (s2 , m2 ).
By definition, s1 and s2 satisfy the proof rule of termination in
the same way because

By Lemma 5.16, we show s1 and s2 terminate in the same way
when started in states m1 (f1 , loop1c , σ1 ) and m2 (f2 , loop2c , σ2 ). We
need to show that all the required conditions are satisfied.

• If i > 1, then the I/O sequence is not redefined in any
1

1

∗

∃(s1 , m1j ), (s2 , m2j ) : (s1 , m1 ) → (s1 , m1j (f1 , loopcj ,
2
∗
σ1j )) ∧ (s2 , m2 ) → (s2 , m2j (f2 , loopcj , σ2j )) where
f1 = f2 = 0; and
2
1
loopcj (n1 ) = loopcj (n2 ) = j; and
∀x ∈ OVar(s) : σ1j (x) = σ2j (x).
• If i = 1, then executions from (s1 , m1 ) and (s2 , m2 )
produce the same output sequence:
(s1 , m1 (loop1c , σ1 )) ≡O (s2 , m2 (loop2c , σ2 )).
• If i > 1, then executions from (s1 , m1i−1 ) and (s2 , m2i−1 )
produce the same output sequence:
2
1
(s1 , m1i−1 (loopci−1 , σ1i−1 )) ≡O (s2 , m2i−1 (loopci−1 ,
σ2i−1 )).

′

m2 ) → (S2′ , m′2 (loop2c )) where loop1c (n1 ) ≤ i,
′
loop2c (n2 ) ≤ i;
• There are no configurations (s1 , m1i ) and (s2 , m2i )
reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in
which crash flags are not set, the loop counters of s1
and s2 are equal to i, and value stores agree on values
of variables in OVar(s):
∗
∄(s1 , m1i ), (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 , loop1ci ,
∗
σ1i )) ∧ (s2 , m2 ) → (s2 , m2i (f2 , loop2ci , σ2i )) where
f1 = f2 = 0; and
loop1ci (n1 ) = loop2ci (n2 ) = i; and
∀x ∈ OVar(s) : σ1i (x) = σ2i (x).
• ∀0 < j < i, there are two configurations (s1 , m1j )
and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ),
respectively, in which crash flags are not set, the loop
counters of s1 and s2 are equal to j and value stores
agree on values of variables in OVar(s):

loop2c (n2 ) = 0;

• s1 and s2 have same set of termination deciding variables,

TVar(s1 ) = TVar(s2 ) = TVar(s);
• Value stores σ1 and σ2 agree on values of variables in TVar(s1 ) =

TVar(s2 ), ∀x ∈ TVar(s) : σ1 (x) = σ2 (x);
The above four conditions are from assumption.
• Loop bodies S1 and S2 terminate in the same way when started
in states with crash flags not set and whose value stores agree
on values of variables in TVar(S1 ) ∪ TVar(S2 );
By Theorem 4.
Therefore, by Lemma 5.16, we have one of the followings holds:
1. s1 and s2 both terminate and the loop counters of s1 and s2 are
less than a positive integer i such that the loop counters of s1
and s2 are less than or equal to i − 1:
∗
∗
(s1 , m1 ) → (skip, m′1 ), (s2 , m2 ) → (skip, m′2 ).
We show that, when s1 and s2 terminate, value stores of s1
and s2 agree on the value of the I/O sequence variable by
Lemma 5.2. We need to show all the required conditions hold.
• ∀x ∈ Imp(io) : σ1 (x) = σ2 (x);
• loop1c (n1 ) = loop2c (n2 ) = 0;
The above two conditions are from assumption.
• idIO ∈ Def(s1 ) ∩ Def(s2 );
Because there are output statements in s1 and s2 . By the
definition of Def(·), the I/O sequence variable is defined in
s1 and s2 .

42

2015/9/14

• Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io);

loop counters of s1 and s2 are equal to j and value stores
agree on the values of variables in TVar(s):
1
∗
∃(s1 , m1j ), (s2 , m2j ) : (s1 , m1 ) → (s1 , m1j (f1 , loopcj ,
2j
∗
σ1j )) ∧ (s2 , m2 ) → (s2 , m2j (f2 , loopc , σ2j )) where
f1 = f2 = 0; and
2
1
loopcj (n1 ) = loopcj (n2 ) = j; and
∀x ∈ TVar(s) : σ1j (x) = σ2j (x).

By the definition of Impo (·), Impo (s1 ) = Imp(s1 , {idIO }),
Impo (s2 ) = Imp(s2 , {idIO }).
• ∀y ∈ Imp(io), ∀mS1 (σS1 ) mS2 (σS2 ) :
((∀z ∈ Imp(S1 , Imp(io)) ∪ Imp(S2 , Imp(io)), σS1 (z) =
σS2 (z)) ⇒ (S1 , mS1 (σS1 )) ≡y (S2 , mS2 (σS2 ))).
By Theorem 2.
In addition, by the semantic rules, the I/O sequence is appended
at most by one value in one step. Hence, s1 and s2 produce
the same output sequence when started in states m1 and m2
respectively.
k

2. s1 and s2 both do not terminate, ∀k > 0, (s1 , m1 ) →
k
(S1k , m1k ), (s2 , m2 ) → (S2k , m2k ) where S1k 6= skip,
S2k 6= skip and one of the followings holds:
(a) ∀i > 0, there are two configurations (s1 , m1i ) and (s2 , m2i )
reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in
which both crash flags are not set, the loop counters of
s1 and s2 are equal to i and value stores agree on the values
of variables in TVar(s):
∗
∀i > 0 ∃(s1 , m1i ) (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 ,
∗
1i
loopc , σ1i )) ∧ (s2 , m2 ) → (s2 , m2i (f2 , loop2ci , σ2i ))
where
• f1 = f2 = 0; and
• loop1c i (n1 ) = loop2c i (n2 ) = i; and
• ∀x ∈ TVar(s) : σ1i (x) = σ2i (x).
′
∗
∗
• ∀m′1 : (s1 , m1 ) → (S1′ , m′1 (loop1c )) → (s1 , m1i (loop1c i ,
′
1
σ1i )), loopc (n1 ) ≤ i; and
′
∗
∗
• ∀m′2 : (s2 , m2 ) → (S2′ , m′2 (loop2c )) → (s2 , m2i (loop2c i ,
2′
σ2i )), loopc (n2 ) ≤ i;
We show that, for any positive integer i, value stores σ1i and
σ2i agree on values of variables in Imp(io) by the proof of
Lemma 5.1. We need to show that all the required conditions
are satisfied.
• ∀x ∈ Imp(io) : σ1 (x) = σ2 (x);
• loop1c (n1 ) = loop2c (n2 ) = 0;
The above two conditions are by assumption.
• idIO ∈ Def(s1 ) ∩ Def(s2 );
• Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io);
The above two conditions are obtained by similar argument in the case that s1 and s2 both terminate.
• ∀y ∈ Imp(io), ∀mS1 (σS1 ) mS2 (σS2 ) :
((∀z ∈ Imp(S1 , Imp(io))∪Imp(S2 , Imp(io)), σS1 (z) =
σS2 (z)) ⇒
(S1 , mS1 (σS1 )) ≡y (S2 , mS2 (σS2 ))).
By Theorem 2.
We cannot apply Lemma 5.1 directly because s1 and s2 do
not terminate. But we can still have the proof closely similar
to that of Lemma 5.1 by using the fact that there exists a
configuration of arbitrarily large loop counters of s1 and s2
and in which crash flags are not set.
Then, ∀i > 0, ∀x ∈ Imp(io) : σ1i (x) = σ2i (x). In addition, by the semantic rules, the I/O sequence is appended at
most by one value in one step. The lemma holds.
(b) The loop counters for s1 and s2 are less than a smallest
positive integer i and all of the followings hold:
′

∗

• ∃i > 0 ∀m′1 , m′2 : (s1 , m1 ) → (S1′ , m′1 (loop1c )), (s2 ,
∗

′

′

m2 ) → (S2′ , m′2 (loop2c )) where loop1c (n1 ) < i,
′
loop2c (n2 ) < i;
• ∀0 < j < i, there are two configurations (s1 , m1j )
and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ),
respectively, in which both crash flags are not set, the

43

This case corresponds to the situation that the ith evaluations of the predicate expression of s1 and s2 raise an exception. There are two possibilities regarding the value of
i.
i. i = 1.
s1 and s2 raise an exception in the 1st evaluation of
their predicate expression because loop counters of s1
and s2 are less than 1. In the proof of Lemma 5.16,
value stores σ1 and σ2 in states m1 and m2 respectively
are not modified in the 1st evaluation of the predicate
expression of s1 and s2 . In addition, value stores σ1 and
σ2 are not modified after s1 and s2 both crash according
to the rule Crash. We have the corresponding initial state
in which value stores σ1 and σ2 agree on values of
variables in OVar(s). Thus, σ1 (idIO ) = σ2 (idIO ). The
lemma holds.
ii. i > 1.
We show that, for any positive integer 0 < j < i,
value stores σ1j and σ2j agree on values of variables
in Imp(s) by the proof of Lemma 5.1. We need to show
that all the required conditions are satisfied.
• ∀x ∈ Imp(io) : σ1 (x) = σ2 (x);
• loop1c (n1 ) = loop2c (n2 ) = 0;
The above two conditions are from assumption.
• idIO ∈ Def(s1 ) ∩ Def(s2 );
• Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io);
The above two conditions are obtained by the same
argument in the case that s1 and s2 terminate.
• ∀y ∈ Imp(io), ∀mS1 (σS1 ) mS2 (σS2 ) :
((∀z ∈ Imp(S1 , Imp(io))∪Imp(S2 , Imp(io)), σS1 (z) =
σS2 (z)) ⇒
(S1 , mS1 (σS1 )) ≡y (S2 , mS2 (σS2 ))).
By Theorem 2.
We cannot apply Lemma 5.1 directly because s1 and
s2 do not terminate. But we can still have the proof
closely similar to that of Lemma 5.1 by using the fact
that there are reachable configurations (s1 , m1i−1 ) and
(s2 , m2i−1 ) with the loop counters of s1 and s2 of value
i − 1 and crash flags not set.
By assumption, there is configuration (s1 , m1i−1 (f1 ,
loop1ci−1 , σ1i−1 )) reachable from (s1 , m1 ) in which the
loop counter of s1 is i − 1 and the crash flag is not set;
there is also a configuration (s2 , m2i−1 (f2 , loop2ci−1 , σ2i−1 ))
of s2 reachable from (s2 , m2 ) in which the loop counter
is i − 1 and the crash flag is not set. In addition, value
stores σ1i−1 and σ2i−1 agree on values of variables in
Imp(io). In the proof of Lemma 5.15, the ith evaluations
of the predicate expression of s1 and s2 must raise an
exception because loop counters of s1 and s2 are less
than i. Then the I/O sequence is not redefined in any
state reachable from (s1 , m1i−1 (f1 , loop1ci−1 , σ1i−1 ))
and (s2 , m2i−1 (f2 , loop2ci−1 , σ2i−1 )) respectively. In
addition, by the semantic rules, the I/O sequence is appended at most by one value in one step. The lemma
holds.

2015/9/14

(c) The loop counters for s1 and s2 are less than or equal to a
smallest positive integer i and all of the followings hold:
′

∗

∗

• ∃i > 0 ∀m′1 , m′2 : (s1 , m1 ) → (S1′ , m′1 (loop1c )), (s2 , m2 ) →
′

(S2′ , m′2 (loop2c ))
′
loop2c (n2 ) ≤ i;

where

′

loop1c

(n1 ) ≤ i,

• There are no configurations (s1 , m1i ) and (s2 , m2i )

reachable from (s1 , m1 ) and (s2 , m2 ), respectively, in
which crash flags are not set, the loop counters of s1 and
s2 are equal to i, and value stores agree on values of
variables in TVar(s):
∗
∄(s1 , m1i ), (s2 , m2i ) : (s1 , m1 ) → (s1 , m1i (f1 , loop1ci , σ1i ))∧
∗
2i
(s2 , m2 ) → (s2 , m2i (f2 , loopc , σ2i )) where
f1 = f2 = 0; and
loop1ci (n1 ) = loop2ci (n2 ) = i; and
∀x ∈ TVar(s) : σ1i (x) = σ2i (x).
• ∀0 < j < i, there are two configurations (s1 , m1j )
and (s2 , m2j ) reachable from (s1 , m1 ) and (s2 , m2 ),
respectively, in which both crash flags are not set, the
loop counters of s1 and s2 are equal to j and value stores
agree on values of variables in TVar(s):
1
∗
∃(s1 , m1j ), (s2 , m2j ) : (s1 , m1 ) → (s1 , m1j (f1 , loopcj , σ1j ))∧
2j
∗
(s2 , m2 ) → (s2 , m2j (f2 , loopc , σ2j )) where
f1 = f2 = 0; and
2
1
loopcj (n1 ) = loopcj (n2 ) = j; and
∀x ∈ TVar(s) : σ1j (x) = σ2j (x).

This case corresponds to the situation that, the ith evaluation
of the predicate expression of s1 and s2 produce same
nonzero integer value and loop bodies S1 and S2 do not
terminate after the ith evaluation of the predicate expression
of s1 and s2 . There are two possibilities regarding the value
of i.
i. i = 1.
By assumption, we have the initial value stores σ1 and
σ2 agree on values of variables in OVar(s). In the proof
of Lemma 5.15, the execution of s1 proceeds as follows:
(s1 , m1 (loop1c , σ1 ))
= (whilehn1 i (e) {S1 }, m1 (loop1c , σ1 ))
→(whilehn1 i (v) {S1 }, m1 (loop1c , σ1 )) by the EEval rule
→(S1 ; whilehn1 i (e) {S1 }, m1 (loop1c [1/n1 ], σ1 ))
by the Wh-T rule.

We show that, for any positive integer 0 < j < i,
value stores σ1j and σ2j agree on values of variables
in Imp(io) by the proof of Lemma 5.1. We need to show
that all the required conditions are satisfied.
• ∀x ∈ Imp(io) : σ1 (x) = σ2 (x);
• loop1c (n1 ) = loop2c (n2 ) = 0;
The above two conditions are from assumption.
• idIO ∈ Def(s1 ) ∩ Def(s2 );
• Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io);
The above two conditions are obtained by the same
argument in the case that s1 and s2 terminate.
• ∀y ∈ Imp(io), ∀mS1 (σS1 ) mS2 (σS2 ) :
((∀z ∈ Imp(S1 , Imp(io))∪Imp(S2 , Imp(io)), σS1 (z) =
σS2 (z)) ⇒
(S1 , mS1 (σS1 )) ≡y (S2 , mS2 (σS2 ))).
By Theorem 2.
We cannot apply Lemma 5.1 directly because s1 and s2
do not terminate. But we can still have the proof closely
similar to that of Lemma 5.1. The reason is that there are
reachable configurations (S1 ; s1 , m′1 ) and (S2 ; s2 , m′2 )
with loop counters of s1 and s2 of value i and crash
flags not set. This is by Lemma 5.24 because there are
configurations reachable from (s1 , m1 ) and (s2 , m2 )
respectively with loop counters of s1 and s2 of i.
There are configurations (s1 , m1i−1 ) reachable from
(s1 , m1 ) and (s2 , m2i−1 ) reachable from (s2 , m2 ) in
which loop counters of s1 and s2 are i−1 and crash flags
are not set and value stores agree on values of variables
in Imp(io). Because loop counters of s1 and s2 are less
than or equal to i. Then the execution of s1 proceeds as
follows:
(s1 , m1i−1 (loop1ci−1 , σ1i−1 ))
= (whilehn1 i (e) {S1 }, m1i−1 (loop1ci−1 , σ1i−1 ))
→(whilehn1 i (v) {S1 }, m1i−1 (loop1ci−1 , σ1i−1 ))
by the EEval rule
→(S1 ; whilehn1 i (e) {S1 }, m1i−1 (loop1ci−1 [i/n1 ],
σ1i−1 )) by the Wh-T rule.
The execution of s2 proceeds to (S2 ; whilehn2 i (e) {S2 },
m2i−1 (loop2ci−1 [i/n2 ], σ2i−1 )). By similar argument in
the case i = 1, S2 and S1 produce the same output sequence when started in states m1i−1 (loop1ci−1 [i/n1 ], σ1i−1 )
and m2i−1 (loop2ci−1 [i/n2 ], σ2i−1 ) respectively. In addition, by the semantic rules, the I/O sequence is appended at most by one value in one step. The lemma
holds.

The execution of s2 proceeds to (S2 ; whilehn2 i (e) {S2 },
m2 (loop2c [1/n2 ], σ2 )). Then the execution of S1 and S2
do not terminate when started in states m1 (loop1c [1/n1 ], σ1 )
and m2 (loop2c [1/n2 ], σ2 ). By assumption, value stores
σ1 and σ2 agree on values of the out-deciding variables of s1 and s2 , ∀x ∈ OVar(s1 ) ∪ OVar(s2 ) :
σ1 (x) = σ2 (x). By definition, Imp(S1 , {idIO }) ⊆
Corollary 5.5. Let s1 = “whilehn1 i (e) {S1 }” and s2 =
Imp(s1 , {idIO }), CVar(S1 ) ⊆ CVar(s1 ) and LVar(S1 ) ⊆
“whilehn2 i (e) {S2 }” be two while statements such that all of the
LVar(s1 ). Thus, TVar(S1 ) ⊆ TVar(s1 ). By Lemma 5.20,
followings hold
TVaro (S1 ) ⊆ TVar(S1 ). By Lemma 5.18, Impo (S1 ) ⊆
• There are output statements in s1 and s2 , ∃e1 e2 : (“output e1 ” ∈
Imp(S1 , idIO ). In conclusion, OVar(S1 ) ⊆ OVar(s1 ).
s1 ) ∧ (“output e2 ” ∈ s2 );
Similarly, OVar(S2 ) ⊆ OVar(s2 ). Thus, ∀x ∈ OVar(S1 )∪
• s1 and s2 have same set of termination deciding variables
OVar(S2 ) : σ1 (x) = σ2 (x). Then executions of S1 and
and same set of imported variables relative to the I/O seS2 when started from states
quence variable, (TVar(s1 ) = TVar(s2 ) = TVar(s)) ∧
m1 (loop1c [1/n1 ], σ1 ) and m2 (loop2c [1/n2 ], σ2 ) pro(Imp(s1 , {idIO }) = Imp(s2 , {idIO }) = Imp(io));
duce the same output sequence:
(S1 , m1 (loop1c [1/n1 ], σ1 )) ≡O (S2 , m2 (loop2c [1/n2 ], σ2 )). • Loop bodies S1 and S2 satisfy the proof rule of equivalent
computation of those in out-deciding variables of s1 and s2 ,
In addition, by the semantic rules, the I/O sequence is
∀x ∈ OVar(s) = TVar(s) ∪ Imp(io) : S1 ≡S
appended at most by one value in one step. The lemma
x S2 ;
• Loop bodies S1 and S2 satisfy the proof rule of termination in
holds.
the same way, S1 ≡S
ii. i > 1.
H S2 ;
44

2015/9/14

1:
2:
3:
4: output a + 2

• Loop bodies S1 and S2 produce the same output sequence when

started in states with crash flags not set and agreeing on values
of variables in OVar(S1 ) ∪ OVar(S2 ), ∀mS1 (f1 , σS1 ) mS2 (f2 ,
σS 2 ) :
((f1 = f2 = 0) ∧ (∀x ∈ OVar(S1 ) ∪ OVar(S2 ) : σS1 (x) =
σS2 (x))) ⇒ ((S1 , mS1 (f1 , σS1 )) ≡O (S2 , mS2 (f2 , σS2 ))).

old

If s1 and s2 start in states m1 (f1 , loop1c , σ1 ), m2 (f2 , loop2c , σ2 )
respectively with crash flags not set f1 = f2 = 0 and in which s1
and s2 have not started execution (loop1c (n1 ) = loop2c (n2 ) = 0),
value stores σ1 and σ2 agree on values of variables in OVar(s),
∀x ∈ OVar(s) : σ1 (x) = σ2 (x), then s1 and s2 produce the same
output sequence: (s1 , m1 ) ≡O (s2 , m2 ).

1’: If (b) then
2’:
output a ∗ 2
3’: else
4’:
output a + 2
new

Figure 15: Specializing new configuration variables

Definition 25. (Specializing new configuration variables) A
statement sequence S2 includes updates of specializing new configuration variables compared with S1 w.r.t a mapping ρ of new configuration variables in S2 , ρ : {id} 7→ {0, 1}, denoted S2 ≈S
ρ S1 ,
iff one of the following holds:

This is from lemma 5.25.
5.5 Backward compatible DSU based on program
equivalence

1. S2 = “If(id) then{S2t } else{S2f }” where one of the following
holds:
(a) (ρ(id) = 0) ∧ (S2f ≈S
ρ S1 );
(b) (ρ(id) = 1) ∧ (S2t ≈S
ρ S1 );
2. S1 and S2 produce the same output sequence, S1 ≈S
O S2 ;
3. S1 = “If(e) then{S1t } else{S1f }”, S2 = “If(e) then{S2t } else{S2f }”
f
t
S f
where (S2t ≈S
ρ S1 ) ∧ (S2 ≈ρ S1 );
′
4. S1 = “whilehn1 i (e) {S1 }”, S2 = “whilehn2 i (e) {S2′ }” where
′
S2′ ≈S
ρ S1 ;
S
′
′
′
5. S1 = S1 ; s1 and S2 = S2′ ; s2 where (S2′ ≈S
ρ S1 ) ∧ (S2 ≈H
S1′ ) ∧ ∀x ∈ Imp(s1 , idIO ) ∪ Imp(s1 , idIO ) : (S2′ ≈S
x
S1′ ) ∧ (s2 ≈S
ρ s1 ).

Based on the equivalence result above, we show that there exists backward compatible DSU. We need to show there exists a
mapping of old program configurations and new program configurations and the hybrid execution obtained from the configuration
mapping is backward compatible. We do not provide a practical algorithm to calculate the state mapping. Instead we only show that
there exists new program configurations corresponding to some old
program configurations via a simulation. The treatment in this section is informal.
The idea is to map a configuration just before an output is produced to a corresponding configuration. Based on the proof rule
of same output sequences, not every statement of the old program
can correspond to a statement of the new program, but every output
statemet of the old program should correspond to an output statement of the new program. Consider configuration C1 of the old
program where the leftmost statement (next statement to execute)
is an output statement. We can define a corresponding statement of
the new program by simulating the execution of the new program
on the input consumed so far in C1 . There are two cases. When the
leftmost statement in C1 is not included in a loop statement, then
it is easy to know when to stop simulation. Otherwise, we have
the bijection of loop statements including output statements based
on the condition of same output sequences. Therefore, it is easy to
know how many iterations of the loop statements including the output statement shall be carried out based on the loop counters in the
old program configuration C1 . Based on Theorem 5, there must be
a configuration C2 corresponding to C1 . Moreover, the executions
starting from configurations C1 and C2 produce the same output
sequence based on Theorem 5. In conclusion, we obtain a backward compatible hybrid execution where the state mapping is from
C1 to C2 .

Then we show that executions of two statement sequences produce the same I/O sequence if there are updates of specializing new
configuration variables between the two.
Lemma 6.1. Let S1 and S2 be two different statement sequences
where there are updates of “specializing new configuration variables” in S2 compared with S1 w.r.t a mapping of new configuration variables ρ, S2 ≈S
ρ S1 . If executions of S2 and S1 start in
states m2 (f2 , σ2 ) and m1 (f1 , σ1 ) respectively where all of the following hold:
• Crash flags f2 , f1 are not set, f2 = f1 = 0;
• Value stores σ1 and σ2 agree on output deciding variables in

both S1 and S2 including the input and I/O sequence variable,
∀id ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪ {idI , idIO } : σ1 (id) =
σ2 (id);
• Values of new configuration variables in the value store σ2 are
matching those in ρ, ∀id ∈ Dom(ρ) : ρ(id) = σ2 (id);
• Values of new configuration variables are not defined in the
statement sequence S2 , Dom(ρ) ∩ Def(S2 ) = ∅;

6. Real world backward compatible update
classes: proof rules

then S2 and S1 satisfy all of the following:
• (S1 , m1 ) ≡H (S2 , m2 );
• (S1 , m1 ) ≡O (S2 , m2 );
• ∀x ∈ {idI , idIO } : (S1 , m1 ) ≡x (S2 , m2 );

We propose our formal treatment for real world update classes. For
each update class, we show how the old program and new program
produce the same I/O sequence which guarantees backward compatible DSU.

Proof. The proof of Lemma 6.1 is by induction on the sum of program sizes of S1 and S2 and is a case analysis based on Definition 25.
Base case.
S1 is a simple statement s, S2 = “If(id) then{st2 } else{sf2 }”
where st2 , sf2 are simple statement and one of the following holds:

6.1 Proof rule for specializing new configuration variables
New configuration variables can be introduced to generalize functionality. Figure 15 shows an example of how a new configuration
variable introduces new code. The two statement sequences in Figure 15 are equivalent when the new variable b is specialized to 0.
Our generalized formal definition of “specializing new configuration variables” is defined as follows.

1. (ρ(id) = 0) ∧ (sf2 = s);
2. (ρ(id) = 1) ∧ (st2 = s);
45

2015/9/14

• Value stores σ1 and σ2 agree on values of used variables

W.l.o.g., we assume that ρ(id) = 0. By assumption, σ2 (id) =
ρ(id) = 0. Then the execution of S2 proceeds as follows:

in S1f and S2f as well as the input, I/O sequence variable.
By definition, Use(S1f ) ⊆ Use(S1 ). So are the cases to
(If(id) then{st2 } else{sf2 }, m2 (σ2 ))
S2f and S2 . In addition, value stores σ1 and σ2 are not
→(If(0) then{st2 } else{sf2 }, m2 (σ2 ))
changed in the evaluation of the predicate expression e.
by the rule Var
The condition holds.
• Values of new configuration variables are consistent
→(sf2 , m2 (σ2 )) by the If-F rule.
in the value store σ2 and the specialization ρ, ∀id ∈
Dom(ρ) : σ2 (id) = ρ(id).
By Theorem 5 and Theorem 4, this lemma holds.
By assumption.
Induction step.
The induction hypothesis (IH) is that Lemma 6.1 holds when
By the hypothesis IH, the lemma holds.
the sum of the program size of S1 and S2 is at least 4, size(S1 ) +
(c) The evaluation of e reduces to the same nonzero integer
size(S2 ) = k ≥ 4.
value, E ′ JeKσ1 = E ′ JeKσ2 = (v, vof ) where v 6= 0.
Then we show that the lemma holds when size(S1 )+size(S2 ) =
By arguments similar to the second subcase above.
k + 1. There are cases to consider.
3. S1 and S2 are both “while” statements:
S1 = “whilehni (e) {S1′ }”, S2 = “whilehni (e) {S2′ }” where
1. S1 and S2 satisfy the condition of same output sequence,
′
S2′ ≈S
ρ S1 ;
S1 ≡ S
O S2 .
By Lemma 6.3, we show this lemma holds. We need to show
By Theorem 5, the lemma 6.1 holds.
that all required conditions are satisfied for the application of
2. S1 and S2 are both “If” statement:
Lemma 6.3.
S1 = “If(e) then{S1t } else{S1f }”, S2 = “If(e) then{S2t } else{S2f }”
• S1 and S2 have same set of output deciding variables,
where both of the following hold
OVar(S1 ) = OVar(S2 ) = OVar(S);
t
• S2t ≈S
ρ S1 ;
By Lemma 6.2 and Corollary 5.1.
f
• S2f ≈S
• When started in states m′1 (σ1′ ), m′2 (σ1′ ) where value stores
ρ S1 ;
σ1′ and σ2′ agree on values of output deciding variables in
By the definition of Use(S1 ), variables used in the predicate exboth S1 and S2 as well as the input sequence variable and
pression e are a subset of used variables in S1 and S2 , Use(e) ⊆
the I/O sequence variable, then S1′ and S2′ terminate in the
Use(S1 ) ∩ Use(S2 ). By assumption, corresponding variables
same way, produce the same output sequence, and have
used in e are of same value in value stores σ1 and σ2 . By
equivalent computation of defined variables in both S1 and
Lemma D.1, the expression evaluates to the same value w.r.t
S2 .
value stores σ1 and σ2 . There are three possibilities.
By the induction hypothesis IH. This is because the sum of
(a) The evaluation of e crashes, E ′ JeKσ1 = E ′ JeKσ2 =
the program size of S1′ and S2′ is less than k. By definition,
(error, vof ).
size(S1 ) = 1 + size(S1′ ).
The execution of S1 continues as follows:
f
t
By Lemma 6.3, this lemma holds.
(If(e) then{S1 } else{S1 }, m1 (σ1 ))
4. S2 = “If(id) then {S2t } else {S2f }” where one of the following
→(If((error, vof )) then{S1t } else{S1f }, m1 (σ1 ))
holds:
by the rule EEval’
(a) (ρ(id) = 0) ∧ (S2f ≈S
→(If(0) then{S1t } else{S1f }, m1 (1/f))
ρ S1 );
by the ECrash rule
(b) (ρ(id) = 1) ∧ (S2t ≈S
ρ S1 );
i
→(If(0) then{S1t } else{S1f }, m1 (1/f)) for any i > 0
W.l.o.g, we assume (ρ(id) = 0) ∧ (S2f ≈S
ρ S1 );
by the Crash rule.
Then the execution of S2 proceeds as follows:
Similarly, the execution of S2 started from the state m2 (σ2 )
crashes. The lemma holds.
(If(id) then{S2t } else{S2f }, m2 (σ2 ))
(b) The evaluation of e reduces to zero, E ′ JeKσ1 = E ′ JeKσ2 =
= (If(0) then{S2t } else{S2f }, m2 (σ2 ))
(0, vof ).
by the Var rule
The execution of S1 continues as follows.
→(S2f , m2 (σ2 ))
(If(e) then{S1t } else{S1f }, m1 (σ1 ))
by the If-F rule
= (If((0, vof )) then{S1t } else{S1f }, m1 (σ1 ))
by the rule EEval’
By the induction hypothesis, we show that the lemma holds.
We need to show the required conditions are satisfied for the
→(If(0) then{S1t } else{S1f }, m1 (σ1 ))
application of the hypothesis.
by the E-Oflow1 or E-Oflow2 rule
• S2f ≈S
→(S1f , m1 (σ1 )) by the If-F rule.
ρ S1
By assumption.
Similarly, the execution of S2 gets to the configuration
• The sum of the program size of S1f and S2f is less than k,
(S2f , m2 (σ2 )).
By the hypothesis IH, we show the lemma holds. We need
size(S1f ) + size(S2f ) < k.
to show that all conditions are satisfied for the application
By definition, size(S2 ) = 1 + size(S2t ) + size(S2f ). Then,
f
t
of the hypothesis IH.
size(S
2 ) + size(S1 ) < k + 1 − 1 − size(S2 ) < k.
f
• (S2f ≈S
ρ S1 )
• Value stores σ1 and σ2 agree on values of used variables in
By assumption.
S2f and S1 as well as the input, I/O sequence variable.
• The sum of the program size of S1f and S2f is less than
By definition, Use(S2f ) ⊆ Use(S2 ). In addition, the value
k, size(S1f ) + size(S2f ) < k.
store σ2 is not changed in the evaluation of the predicate
By definition, size(S1 ) = 1+size(S1t )+size(S1f ). Then,
expression e. The condition holds.
size(S1f ) + size(S2f ) < k + 1 − 2 = k − 1.
By the hypothesis IH, the lemma holds.
46

2015/9/14

σ1 (id) = σ2 (id) = σ2′ (id). Otherwise, the variable id
is defined in the execution of S1′ and S2′ , by assumption,
σ1′ (id) = σ2′ (id). The condition holds.
• Values of new configuration variables are consistent
in the value store σ2′ and the specialization ρ, ∀id ∈
Dom(ρ) : σ2′ (id) = ρ(id).
By assumption, Dom(ρ) ∩ Def(S2 ). By Corollary E.2,
values of new configuration variables are not changed
in the execution of S2′ , ∀id ∈ Dom(ρ) : σ2′ (id) =
σ2 (id) = ρ(id).
By the hypothesis IH, the lemma holds.

5. S1 and S2 are same, S1 = S2 ;
By definition, used variables in S1 and S2 are same; defined
variables in S1 and S2 are same. By semantic rules, S1 and S2
terminate in the same way, produce the same output sequence
and have equivalent computation of defined variables in S1 and
S2 . This lemma holds.
6. S1 = S1′ ; s1 and S2 = S2′ ; s2 where both of the following hold:
′
• S2′ ≈S
ρ S1 ;
S
• s2 ≈ρ s1 ;
By Theorem 4 and the hypothesis IH, we show S2′ and S1′ terminate in the same way and produce the same output sequence
and when S2′ and S1′ both terminate, S2′ and S1′ have equivalent
terminating computation of variables used or defined in S2′ and
S1′ .
We show all the required conditions are satisfied for the application of the hypothesis IH.
′
• S2′ ≈S
ρ S1 .
By assumption.
• The sum of the program size of S1′ and S2′ is less than k,
size(S1′ ) + size(S2′ ) < k.
By definition, size(S2 ) = size(s2 ) + size(S2′ ) where
size(s2 ) < 1. Then, size(S2′ ) + size(S1′ ) < k + 1 −
size(s2 ) − size(s1 ) < k.
• Value stores σ1 and σ2 agree on values of output deciding
variables in S2′ and S1′ including the input, I/O sequence
variable.
By definition of TVaro and Impo , OVar(S2′ ) ⊆ OVar(S2 ).
The condition holds.
• Values of new configuration variables are consistent in the
value store σ2 and the specialization ρ, ∀id ∈ Dom(ρ) :
σ2 (id) = ρ(id).
By assumption.
By the hypothesis IH, one of the following holds:
(a) S1′ and S2′ both do not terminate.
By Lemma E.2, executions of S1 = S1′ ; s1 and S2 =
S2′ ; s2 both do not terminate and produce the same output
sequence.
(b) S1′ and S2′ both terminate.
∗
By assumption, (S2′ , m2 (σ2 )) → (skip, m′2 (σ2′ )),
∗
(S1′ , m1 (σ1 )) → (skip, m′1 (σ1′ )).
∗
By Corollary E.1, (S2′ ; s2 , m2 (σ2 )) → (s2 , m′2 (σ2′ )),
∗
′
′
′
(S1 ; s1 , m1 (σ1 )) → (s1 , m1 (σ1 )).
By the hypothesis IH, we show that s2 and s1 terminate
in the same way, produce the same output sequence and
when s2 and s1 both terminate, s2 and s1 have equivalent
computation of variables used or defined in s1 and s2 and
the input, and I/O sequence variables.
We need to show that all conditions are satisfied for the
application of the hypothesis IH.
• There are updates of “new configuration variables” between s2 and s1 ;
By assumption, s2 ≈S
ρ s1 .
• The sum of the program size s2 and s1 is less than or
equals to k;
By definition, size(S2′ ) ≥ 1, size(S1′ ) ≥ 1. Therefore,
size(s2 ) + size(s1 ) < k + 1 − size(S2′ ) − size(S1′ ) ≤ k.
• Value stores σ1′ and σ2′ agree on values of output deciding variables in s2 and s1 as well as the input, I/O
sequence variable.
By induction hypothesis IH, OVar(s1 ) ⊆ OVar(s2 ),
then Use(s2 ) ∩ Use(s1 ) = Use(s1 ). For any variable
id in OVar(s1 ), if id is in OVar(S1′ ), then the value of
id is same after the execution of S1′ and S2′ , σ1′ (id) =

We list properties of the update of new configuration variables
and the proof of backward compatibility for the case of loop statement as follows. We present one auxiliary lemma used in the proof
of Lemma 6.1.
Lemma 6.2. Let S2 be a statement sequence and S1 where there
are updates of “specializing new configuration variables” w.r.t
a mapping of new configuration variables ρ, S2 ≈S
ρ S1 . Then the
output deciding variables in S1 are a subset of the union of those
in S2 , OVar(S1 ) ⊆ OVar(S2 ).
Proof. By induction on the sum of the program size of S1 and
S2 .
Lemma 6.3. Let S1 = whilehn1 i (e) {S1′ } and S2 = whilehn2 i (e)
{S2′ } be two loop statements where all of the following hold:

• S2′ includes updates of “specializing new configuration vari-

′
′
ables” compared to S1′ , S2′ ≈S
ρ S1 where Dom(ρ) ∩ Def(S2 ) =
∅.
• the output deciding variables in S1 are a subset of those in S2 ,
OVar(S1 ) ⊆ OVar(S2 );
• When started in states agreeing on values of output deciding
variables in S1 and S2 including the input sequence variable
and the I/O sequence variable, ∀x ∈ OVar(S1 ) ∪ OVar(S2 ) ∪
{idI , idIO } ∀m′1 (σ1′ ) m′2 (σ2′ ) : (σ1′ (x) = σ2′ (x)), S1′ and S2′
terminate in the same way, produce the same output sequence,
and have equivalent computation of defined variables in S1′
and S2′ as well as the input sequence variable and the I/O
sequence variable ((S1′ , m1 ) ≡H (S2′ , m2 )) ∧ ((S1′ , m1 ) ≡O
(S2′ , m2 )) ∧ (∀x ∈ OVar(S1 ) ∪ OVar(S2 ) ∪ {idI , idIO } :
(S1′ , m1 ) ≡x (S2′ , m2 ));

If S1 and S2 start in states m1 (loop1c , σ1 ), m2 (loop2c , σ2 ) respectively, with loop counters of S1 and S2 not initialized (S1 , S2
have not executed yet), value stores agree on values of output deciding variables in S1 and S2 , then, for any positive integer i, one
of the following holds:

1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
∗
′′
′
1′
1′
2
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′′
′
2′
2′
(S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the
same way, produce the same output sequence, and have equivalent computation of output deciding variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or equal
to i, and there are no reachable configurations (S1 , m1 (loop1ci ,
σ1i )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 ,
m2 (σ2 )) where all of the following hold:

47

2015/9/14

• The loop counters of S1 and S2 are of value i, loop1c i (n1 )

i

→(whilehn1 i (0) {S1′ }, m1 (1/f)) for any i > 0
by the Crash rule.

= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of output deciding
variables in both S1 and S2 as well as the input sequence
variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x).
3. There are reachable configurations (S1 , m1 (loop1ci , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of output deciding
variables in both S1 and S2 including the input sequence
variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x).

Similarly, the execution of S2 started from the state m2 (σ2 )
crashes. Therefore S1 and S2 terminate in the same way when
started from m1 and m2 respectively. Because σ1 (idIO ) =
σ2 (idIO ), the lemma holds.
2. The evaluation of e reduces to zero, E ′ JeKσ1 = E ′ JeKσ2 =
(0, vof ).
The execution of S1 continues as follows.
(whilehn1 i (e) {S1′ }, m1 (σ1 ))
= (whilehn1 i ((0, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (0) {S1′ }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(skip, m1 (σ1 )) by the Wh-F rule.

Proof. By induction on i.
Base case.
We show that, when i = 1, one of the following holds:

Similarly, the execution of S2 gets to the configuration (skip, m2 (σ2 )).
Loop counters of S1 and S2 are less than 1 and value stores
agree on values of used/defined variables in both S1 and S2
as well as the input sequence variable and the I/O sequence
variable.
3. The evaluation of e reduces to the same nonzero integer value,
E ′ JeKσ1 = E ′ JeKσ2 = (0, vof ).
Then the execution of S1 proceeds as follows:

1. Loop counters for S1 and S2 are always less than 1 if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i, (S2 , m2 (loop2c , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in
the same way, produce the same output sequence, and have
equivalent computation of used/defined variables in both S1
and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. Loop counters of S1 and S2 are of value less than or equal to 1
but there are no reachable configurations (S1 , m1 (loop1c1 , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2c1 , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value 1, loop1c 1 (n1 )
= loop2c1 (n2 ) = 1.
• Value stores σ11 and σ21 agree on values of used variables
in both S1 and S2 as well as the input sequence variable and
the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪
{idI , idIO } : σ11 (x) = σ21 (x).
3. There are reachable configuration (S1 , m1 (loop1c1 , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2c1 , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value 1, loop1c 1 (n1 )
= loop2c1 (n2 ) = 1.
• Value stores σ11 and σ21 agree on values of used variables
in both S1 and S2 as well as the input sequence variable and
the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪
{idI , idIO } : σ11 (x) = σ21 (x).

(whilehn1 i (e) {S1′ }, m1 (σ1 ))
= (whilehn1 i ((v, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (v) {S1′ }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(S1′ ; whilehn1 i (e) {S1′ }, m1 (
loop1c ∪ {(n1 ) 7→ 1}, σ1 )) by the Wh-T rule.
Similarly, the execution of S2 proceeds to the configuration
(S2′ ; whilehn2 i (e) {S2′ }, m2 (loop2c ∪ {n2 7→ 1}, σ2 )).
By the hypothesis IH, we show that S1′ and S2′ terminate in
the same way and produce the same output sequence when
started in the state m1 (loop1c1 , σ1 ) and m2 (loop2c1 , σ2 ), and
S1′ and S2′ have equivalent computation of variables used or
defined in both statement sequences if both terminate. We need
to show that all conditions are satisfied for the application of the
hypothesis IH.
• variables in the domain of ρ are not redefined in the execution of S2′ .
The above three conditions are by assumption.
By definition, size(S1 ) = 1 + size(S1′ ). Then, size(S1′ ) +
size(S2′ ) = k + 1 − 2 = k − 1.
• Value stores σ1 and σ2 agree on values of used variables in
S1′ and S2′ as well as the input, I/O sequence variable.
By definition, OVar(S1′ ) ⊆ OVar(S1 ). So are the cases
to S2′ and S2 . In addition, value stores σ1 and σ2 are not
changed in the evaluation of the predicate expression e. The
condition holds.
• Values of new configuration variables are consistent in the
value store σ2 and the specialization ρ, ∀id ∈ Dom(ρ) :
σ2 (id) = ρ(id).
By assumption.
By assumption, S1′ and S2′ terminate in the same way and
produce the same output sequence when started in states
m1 (loop′c , σ1 ) and m2 (loop′c , σ2 ). In addition, S1′ and S2′ have
equivalent computation of variables used or defined in S1′ and
S2′ when started in states m1 (loop′c , σ1 ) and m2 (loop′c , σ2 ).
Then there are two cases.

By definition, variables used in the predicate expression e of S1
and S2 are used in S1 and S2 , Use(e) ⊆ OVar(S1 ) ∩ OVar(S2 ). By
assumption, value stores σ1 and σ2 agree on values of variables in
Use(e), the predicate expression e evaluates to the same value w.r.t
value stores σ1 and σ2 . There are three possibilities.
1. The evaluation of e crashes,
E ′ JeKσ1 = E ′ JeKσ2 = (error, vof ).
The execution of S1 continues as follows:
(whilehn1 i (e) {S1′ }, m1 (σ1 ))
→(whilehn1 i ((error, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (0) {S1′ }, m1 (1/f))
by the ECrash rule

48

2015/9/14

(a) S1′ and S2′ both do not terminate and produce the same
output sequence.
By Lemma E.2, S1′ ; S1 and S2′ ; S2 both do not terminate
and produce the same output sequence.
(b) S1′ and S2′ both terminate and have equivalent computation
of variables used or defined in S1′ and S2′ .
∗
By assumption, (S1′ , m1 (loop′c , σ1 )) → (skip, m′1 (loop′′c , σ1′ ));
∗
′
′
′
(S2 , m2 (loopc , σ2 )) → (skip, m2 (loop′′c , σ2′ )) where ∀x ∈
(OVar(S1′ ) ∩ OVar(S2′ )) ∪ {idI , idIO }, σ1′ (x) = σ2′ (x).
Because S1 and S2 have the same predicate expression,
variables used in the predicate expression of S1 and S2
are not in the domain of ρ. By assumption, OVar(S1′ ) ⊆
OVar(S2′ ) ⊆ OVar(S2′ ) ∪ Dom(ρ) and OVar(S1′ ) ⊆
OVar(S2′ ). Then variables used in the predicate expression
of S1 and S2 are either in variables used or defined in both
S1′ and S2′ or not. Therefore value stores σ2′ and σ1′ agree
on values of variables used in the expression e and even
variables used or defined in S1 and S2 .
Induction step on iterations
The induction hypothesis (IH) is that, when i ≥ 1, one of the
following holds:
1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i, (S2 , m2 (loop2c , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in
the same way, produce the same output sequence, and have
equivalent computation of used/defined variables in both S1
and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables
in both S1 and S2 as well as the input sequence variable and
the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).
3. There are reachable configurations (S1 , m1 (loop1ci , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables
in both S1 and S2 as well as the input sequence variable and
the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).

(S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or
equal to i + 1, and there are no reachable configurations
(S1 , m1 (loop1ci+1 , σ1i+1 )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 , σ2i+1 ))
from (S2 , m2 (σ2 )) where all of the following hold:
• The loop counters of S1 and S2 are of value i + 1,
loop1ci+1 (n1 ) = loop2ci+1 (n2 ) = i + 1.
• Value stores σ1i+1 and σ2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩
OVar(S2 )) ∪ {idI , idIO } : σ1i+1 (x) = σ2i+1 (x).
3. There are reachable configurations (S1 , m1 (loop1ci+1 , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i + 1.
• Value stores σ1i+1 and σ2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩
OVar(S2 )) ∪ {idI , idIO } : σ1i+1 (x) = σ2i+1 (x).
By hypothesis IH, there is no configuration where loop counters
of S1 and S2 are of value i + 1 when any of the following holds:
1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
′′
′
1
1
2
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′′
′
2′
2′
(S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in
the same way, produce the same output sequence, and have
equivalent computation of used/defined variables in both S1
and S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables in
both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).
When there are reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )

= loop2ci (n2 ) = i.
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables in
both S1 and S2 as well as the input sequence variable and
the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).

Then we show that, when i + 1, one of the following holds: The
induction hypothesis (IH) is that, when i ≥ 1, one of the following
holds:
1. Loop counters for S1 and S2 are always less than i + 1 if any
′
′
∗
is present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
′′
′
1
1
2
(S1 , m1 (loopc )), loopc (n1 ) < i+1, (S2 , m2 (loopc , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i + 1, S1 and S2 terminate
in the same way, produce the same output sequence, and have
equivalent computation of used/defined variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable,

By similar argument in base case, we have one of the following
holds:
1. Loop counters for S1 and S2 are always less than i + 1 if any
′
′
∗
is present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
49

2015/9/14

1: enum id {o1 }
2: a : enum id
3: If (a == o1 ) then
4:
output 2 + c
5:
6:

1’:
2’:
3’:
4’:
5’:
6’:

old

enum id {o1 , o2 }
a : enum id
If (a == o1 ) then
output 2 + c
If (a == o2 ) then
output 3 + c

2. EN1 , EN2 include more than one enumeration type definitions
EN1 = “enum id {el1 }, EN′1 ”, EN2 = “enum id {el2 }, EN′2 ”
where one of the following holds:
(a) (EN′1 ⊂ EN′2 ) and (el1 = el2 ) ∨ (el2 = el1 , el);
(b) (EN′1 ⊂ EN′2 ) ∨ (EN′1 = EN′2 ) and “enum id {el1 }” ⊂
“enum id {el2 }”.

new

Figure 16: Enumeration type extension
′

′

∗

(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i+1, (S2 , m2 (loop2c , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i + 1, S1 and S2 terminate
in the same way, produce the same output sequence, and have
equivalent computation of used/defined variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable,
(S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∩ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or
equal to i + 1, and there are no reachable configurations
(S1 , m1 (loop1ci+1 , σ1i+1 )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 ,
σ2i+1 )) from (S2 , m2 (σ2 )) where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i.
• Value stores σ1i+1 and σ2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩
OVar(S2 )) ∪ {idI+1 , idIO } : σ1i+1 (x) = σ2i+1 (x).
3. There are reachable configurations (S1 , m1 (loop1ci+1 , σ1i+1 ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 , σ2i+1 )) from (S2 ,
m2 (σ2 )) where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i + 1.
• Value stores σ1i+1 and σ2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩
OVar(S2 )) ∪ {idI+1 , idIO } : σ1i+1 (x) = σ2i+1 (x).

6.2 Proof rule for enumeration type extension
Enumeration types allow developers to list similar items. New code
is usually accompanied with the introduction of new enumeration
labels. Figure 16 shows an example of the update. The new enum
label o2 gives a new option for matching the value of the variable a,
which introduce the new code b := 3 + c. To show updates “enumeration type extension” to be backward compatible, we assume
that values of enum variables, used in the If-predicate introducing
the new code, are only from inputs that cannot be translated to new
enum labels.
In order to have a general definition of the update class, we show
a relation between two sequences of enumeration type definitions,
called proper subset.

Definition 27. (Enumeration type extension) Let P1 , P2 be two
programs where enumeration type definitions EN1 in P1 are a
subset of EN2 in P2 , EN1 ⊂ EN2 and E are new enum labels
in P2 . A statement sequence S2 in a program P2 includes updates
of enumeration type extension compared with a statement sequence
S1 in P1 , written S2 ≈S
E S1 , iff one of the following holds:

1. S2 = “If(id==l) then{S2t } else{S2f }” and all of the following
hold:
• l ∈ E;
• The variable id is not lvalue in an assignment statement,
“id := e” ∈
/ P2 ;
• S2f ≈S
E S1 ;
2. S1 = “If(e) then{S1t } else{S1f }”, S2 = “If(e) then{S2t } else{S2f }”
f
f
t
S
where (S2t ≈S
E S1 ) ∧ (S2 ≈E S1 );
′
3. S1 = “whilehn1 i (e) {S1 }”, S2 = “whilehn2 i (e) {S2′ }” where
′
S2′ ≈S
E S1 ;
S
4. S1 ≈O S2 ;
′
′
S
5. S1 = S1′ ; s1 and S2 = S2′ ; s2 where (S2′ ≈S
E S1 ) ∧ (S2 ≈H
′
′
S1 ) ∧ ∀x ∈ Imp(s1 , idIO ) ∪ Imp(s1 , idIO ) : (S2 ≈S
x
S1′ ) ∧ (s2 ≈S
E s1 ).

We show that two programs terminate in the same way, produce
the same output sequence, and have equivalent computation of
variables defined in both of them in executions if there are updates
of enumeration type extension between them.
Lemma 6.4. Let S1 and S2 be two statement sequences in programs P1 and P2 respectively where there are updates of enumeration type extensions in S2 of P2 compared with S1 of P1 , S2 ≈S
E S1 .
If S1 and S2 start in states m1 (σ1 ) and m2 (σ2 ) such that both of
the following hold:
• Value stores σ1 and σ2 agree on values of output deciding vari-

ables in both S1 and S2 including the input sequence variable
and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪
{idI , idIO } : σ1 (x) = σ2 (x);
• No variables used in S2 are of initial value of enum labels in
E, ∀x ∈ Use(S2 ) : (σ2 (x) ∈
/ E);
• No inputs are translated to any label in E during the execution
of S2 ;
then S1 and S2 terminate in the same way, produce the same output
sequence, and when S1 and S2 both terminate, they have equivalent
computation of used variables and defined variables,
• (S1 , m1 ) ≡H (S2 , m2 );
• (S1 , m1 ) ≡O (S2 , m2 );
• ∀x ∈ OVar(S1 ) ∪ OVar(S2 ) : (S1 , m1 ) ≡x (S2 , m2 );

Proof. By induction on the sum of the program size of S1 and S2 ,
size(S1 ) + size(S1 ).
Base case. S1 is a simple statement s, and S2 = “If(id==l) then{st2 }
else{sf2 }” where all of the following hold:

Definition 26. (Extension relation of enumeration types) Let
EN1 , EN2 be two different sequences of enumeration type definitions. EN1 is a subset of EN2 , written EN1 ⊂ EN2 , iff one of the
following holds:

• l ∈ E;
• st2 , sf2 are two simple statements;
• sf2 = s;

1. EN1 = “enum id {el1 }”, EN2 = “enum id {el2 }” where labels in type “enum id” in EN1 are a subset of those in EN2 ,
el2 = el1 , el and el 6= ∅;
50

2015/9/14

We informally argue that the value of the variable id in the
predicate expression of S2 only coming from an input value or
the initial value. There are three ways a scalar variable is defined:
the execution of an assignment statement, the execution of an
input statement or the initial value. Because id is not lvalue in
an assignment statement, then the value of id is only from the
execution of an input statement or the initial value.
In addition, by assumption, any output deciding variable is not
of the initial value of enum label in E; no input values are translated
into an enum label in E. Then the execution of S2 proceeds as
follows:

By the hypothesis IH, we show the lemma holds. We need
to show that all conditions are satisfied for the application
of the hypothesis IH.
f
• S2f ≈S
E S1
By assumption.
• The sum of the program size of S1f and S2f is less than
k, size(S1f ) + size(S2f ) < k.
By definition, size(S1 ) = 1+size(S1t )+size(S1f ). Then,
size(S1f ) + size(S2f ) < k + 1 − 2 = k − 1.
• Value stores σ1 and σ2 agree on values of output deciding variables in S1f and S2f including the input, I/O
(If(id==l) then{st2 } else{sf2 }, m2 (σ2 ))
sequence variable.
→(If(0) then{st2 } else{sf2 }, m2 (σ2 ))
By definition, OVar(S1f ) ⊆ OVar(S1 ). So are the cases
by the rule Eq-F
to S2f and S2 . In addition, value stores σ1 and σ2 are not
→(sf2 , m2 (σ2 )) by the If-F rule.
changed in the evaluation of the predicate expression e.
The condition holds.
The value store σ2 is not updated in the execution of S2 so far.
• There are no inputs translated to enum labels in E in
By assumption, value stores σ1 and σ2 agree on values of output
S2f ’s execution.
deciding variables in both S1 and S2 .
By assumption.
By Theorem 2 and 4, S1 and S2 terminate in the same way,
By the hypothesis IH, the lemma holds.
produce the same I/O sequence. The lemma holds.
(c) The evaluation of e reduces to the same nonzero integer
Induction step.
value, E ′ JeKσ1 = E ′ JeKσ2 = (0, vof ).
The hypothesis is that this lemma holds when the sum k of the
By
similar to the second subcase above.
program size of S1 and S2 are great than or equal to 4, k ≥ 4.
2. S1 and S2 are both “while” statements:
We then show that this lemma holds when the sum of the
S1 = “whilehn1 i (e) {S1′ }”, S2 = “whilehn2 i (e) {S2′ }” where
program size of S1 and S2 is k + 1. There are cases regarding
S
′
S2 ≈E S1 .
S2′ ≈S
E S1 ;
By Lemma 6.6, we show the lemma holds. We need to show all
1. S1 and S2 are both “If” statement:
the required conditions for the application of Lemma 6.6 holds
f
f
t
t
S1 = “If(e) then{S1 } else{S1 }”, S2 = “If(e) then{S2 } else{S2 }”
(a) No variables are of initial values as new enum labels in E;
where both of the following hold
(b) Value stores σ1 and σ2 agree on values of variables used in
t
• S2t ≈S
E S1 ;
both S1 and S2 ;
f S f
• S2 ≈ E S1 ;
(c) Enumeration types in P1 are a subset of those in P2 ;
By the definition of Impo (S1 ), variables used in the predicate
The above three conditions are by assumption.
expression e are a subset of output deciding variables in S1
(d) The output deciding variables in S1′ are a subset of those in
and S2 , Use(e) ⊆ OVar(S1 ) ∩ OVar(S2 ). By assumption,
S2′ ;
corresponding variables used in e are of same value in value
The above condition is by Lemma 6.5.
stores σ1 and σ2 . By Lemma D.1, the expression evaluates to
(e) S1′ and S2′ produce the same output sequence, terminate in
the same value w.r.t value stores σ1 and σ2 . There are three
the same way and have equivalent computation of defined
possibilities.
variables in both S1′ and S2′ when started in states agreeing
(a) The evaluation of e crashes, E ′ JeKσ1 = E ′ JeKσ2 =
on values of variables used in both S1′ and S2′ ;
(error, vof ).
Because size(S1 ) = size(S1′ ) + 1, then the condition holds
The execution of S1 continues as follows:
by
the induction hypothesis.
(If(e) then{S1t } else{S1f }, m1 (σ1 ))
By
Lemma
6.6, the lemma holds.
→(If((error, vof )) then{S1t } else{S1f }, m1 (σ1 ))
3. S2 = “If(id==l) then {S2t } else {S2f }” such that both of the
by the rule EEval’
following hold:
→(If(0) then{S1t } else{S1f }, m1 (1/f))
• The label l is in E, l ∈ E;
by the ECrash rule
• The variable id is not lvalue in an assignment statement,
i
→(If(0) then{S1t } else{S1f }, m1 (1/f)) for any i > 0
∄“id := e” in S2 ;
by the Crash rule.
• There are updates of enumeration type extension from S2f
Similarly, the execution of S2 started from the state m2 (σ2 )
to S1 , S2f ≈S
E S1 ;
crashes. The lemma holds.
By
Lemma
6.6,
we show this lemma holds. We need to show all
(b) The evaluation of e reduces to zero, E ′ JeKσ1 = E ′ JeKσ2 =
the conditions are satisfied for the application of Lemma 6.6.
(0, vof ).
• S1′ and S2′ have same set of output deciding variables,
The execution of S1 continues as follows.
OVar(S1′ ) = OVar(S2′ ) = OVar(S);
(If(e) then{S1t } else{S1f }, m1 (σ1 ))
• The output deciding variables in S1′ are a subset of those in
= (If((0, vof )) then{S1t } else{S1f }, m1 (σ1 ))
S2′ , OVar(S1′ ) ⊆ OVar(S2′ );
by the rule EEval’
By Lemma 6.5.
→(If(0) then{S1t } else{S1f }, m1 (σ1 ))
• There are no inputs translated to enum labels in the set E.
by the E-Oflow1 or E-Oflow2 rule
By assumption.
→(S1f , m1 (σ1 )) by the If-F rule.
• When started in states m′1 (σ1′ ), m′2 (σ1′ ) where value stores
σ1′ and σ2′ agree on values of output deciding variables in
Similarly, the execution of S2 gets to the configuration
both S1′ and S2′ as well as the input sequence variable and
(S2f , m2 (σ2 )).
51

2015/9/14

• There are no inputs translated to enum labels in E in S2′ ’s

the I/O sequence variable, and there are no inputs translated
to enum labels in E, then S1′ and S2′ produce the same
output sequence.
By the induction hypothesis IH. This is because the sum of
the program size of S1′ and S2′ is less than k. By definition,
size(S1 ) = 1 + size(S1′ ).
4. S2 = “If(id==l) then {S2t } else {S2f }” such that both of the
following hold:
• The label l is in E, l ∈ E;
• The variable id is not lvalue in an assignment statement,
“id := e” ∈
/ S2 ;
• There are updates of enumeration type extension from S2f
to S1 , S2f ≈S
E S1 ;
We informally argue that the value of the variable id in the predicate expression of S2 only coming from an input value or the
initial value. There are several ways a scalar variable is defined:
the execution of an assignment statement, the execution of an
input statement or the initial value. Because id is not lvalue in
an assignment statement, then the value of id is only from the
execution of an input statement or initial value. In addition, by
assumption, any used variable is not of initial value of enum
label in E; no input values are translated into an enum label in
E.
Then the expression id==l evaluates to 0. The execution of S2
proceeds as follows.

execution.
• Initial values of used variables in S2′ are not enum labels in

E.
The above three conditions are by assumption.
• The sum of the program size of S1′ and S2′ is less than k,
size(S1′ ) + size(S2′ ) < k.
By definition, size(S1 ) = size(S1′ ) + size(s1 ). Then,
size(S1′ ) + size(S2′ ) < k + 1 − size(s2 ) − size(s1 ) < k.
• Value stores σ1 and σ2 agree on values of used variables in
both S1′ and S2′ as well as the input, output, I/O sequence
variable.
By definition, OVar(S2′ ) ⊆ OVar(S2 ), OVar(S1′ ) ⊆ OVar(S1 ).
In addition, value stores σ1 and σ2 are not changed in
the evaluation of the predicate expression e. The condition
holds.
By the hypothesis IH, one of the following holds:
(a) S1′ and S2′ both do not terminate.
By Lemma E.2, executions of S1 = S1′ ; s1 and S2 =
S2′ ; s2 both do not terminate and produce the same output
sequence.
(b) S1′ and S2′ both terminate.
∗
∗
By assumption, (S2′ , m2 (σ2 )) → (skip, m′2 (σ2′ )), (S1′ , m1 (σ1 )) →
′
′
(skip, m1 (σ1 )).
∗
By Corollary E.1, (S2′ ; s2 , m2 (σ2 )) → (s2 , m′2 (σ2′ )),
∗
′
′
′
(S1 ; s1 , m1 (σ1 )) → (s1 , m1 (σ1 )).
By the hypothesis IH, we show that s2 and s1 terminate
in the same way, produce the same output sequence and
when s2 and s1 both terminate, s2 and s1 have equivalent
computation of variables used or defined in s1 and s2 and
the input, output, and I/O sequence variables.
We need to show that all conditions are satisfied for the
application of the hypothesis IH.
• There are updates of “enumeration type extension” between s2 and s1 ;
• There are no input values translated into enum labels in
E in the execution of s2 ;
The above two conditions are by assumption.
• The sum of the program size s2 and s1 is less than or
equals to k;
By definition, size(S2′ ) ≥ 1, size(S1′ ) ≥ 1. Therefore,
size(s2 ) + size(s1 ) < k + 1 − size(S2′ ) − size(S1′ ) ≤ k.
• Value stores σ1′ and σ2′ agree on values of used variables
in s2 and s1 as well as the input, output, I/O sequence
variable.
By Lemma 6.5, OVar(s1 ) ⊆ OVar(s2 ), then OVar(s2 )
∩ OVar(s1 ) = OVar(s1 ). Similarly, by Lemma 6.5,
OVar(S1′ ) ⊆ OVar(S2′ ). For any variable id in OVar(s1 ),
if id is not in OVar(S1′ ), then the value of id is not
changed in the execution of S1′ and S2′ , σ1′ (id) =
σ1 (id) = σ2 (id) = σ2′ (id). Otherwise, the variable id
is defined in the execution of S1′ and S2′ , by assumption,
σ1′ (id) = σ2′ (id). The condition holds.
• Values of used variables in s2 are not of value as enum
labels in E, ∀id ∈ OVar(s2 ) : σ2′ (id) ∈ E.
By assumption, initial values of used variables in s2
are not of values as enum labels in E. S2′ and S1′ have
equivalent computation of defined variables in S2′ and
S1′ . Because enum labels are not defined in P1 , defined
variables in the execution of S2′ and S1′ are not of values
as enum labels in E.
By the hypothesis IH, the lemma holds.

(If(id==l) then{S2t } else{S2f }, m2 (σ2 ))
→(If(v==l) then{S2t } else{S2f }, m2 (σ2 )) where v 6= l
by the rule Var
→(If(0) then{S2t } else{S2f }, m1 (σ2 ))
by the Eq-F rule
→(S2f , m2 (σ2 )) by the If-F rule.
By the hypothesis IH, we show the lemma holds. We need
to show the conditions are satisfied for the application of the
hypothesis IH.
• S2f ≈S
E S1
• There are no inputs translated to enum labels in E in S2f ’s
execution.
• Initial values of used variables in S2 are not enum labels in
E.
The above three conditions are by assumption.
• The sum of the program size of S1 and S2f is less than k,
size(S1 ) + size(S2f ) < k.
By definition, size(S1 ) = 1 + size(S1t ) + size(S1f ). Then,
size(S1 ) + size(S2f ) < k + 1 − 1 − size(S2t ) < k.
• Value stores σ1 and σ2 agree on values of used variables in
both S1 and S2f as well as the input, I/O sequence variable.
By definition, OVar(S2f ) ⊆ OVar(S2 ). In addition, value
stores σ1 and σ2 are not changed in the evaluation of the
predicate expression e. The condition holds.
By the hypothesis IH, this lemma holds.
5. S1 = S1′ ; s1 and S2 = S2′ ; s2 such that both of the following
hold:
′
• S2′ ≈S
E S1 ;
S
• s2 ≈E s1 ;

By the hypothesis IH, we show S2′ and S1′ terminate in the same
way, produce the same output sequence, and have equivalent
computation of defined variables in S1 and S2 . We need to
show that all the conditions are satisfied for the application of
the hypothesis IH.
′
• S2′ ≈S
E S1 ;
52

2015/9/14

• Value stores σ1i and σ2i agree on values of output deciding

We show a auxiliary lemma telling that the two programs with
updates of enumeration type extension have same set of used variables and the same set of defined variables.

variables in both S1 and S2 as well as the input sequence
variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x).

Lemma 6.5. If there are updates of enumeration type extension
in a statement sequence S2 against a statement sequence S1 ,
S2 ≈S
E S1 , then the output deciding variables in S1 are a subset
of those in S2 , OVar(S1 ) ⊆ OVar(S2 ).

Proof. By induction on i.
Base case.
We show that, when i = 1, one of the following holds:

Proof. By induction on the sum of the program size of S1 and
S2 .
Lemma 6.6. Let S1 = whilehn1 i (e) {S1′ } and S2 = whilehn2 i (e)
{S2′ } be two loop statements in programs P1 and P2 respectively
where all of the following hold:
• Enumeration types EN 1 in P1 are a proper subset of EN 2 in

P2 , EN 1 ⊂ EN 2 , such that there are a set of enum labels E
only defined in P2 ;
• When started in states agreeing on values of output deciding
variables in both S1′ and S2′ as well as the input sequence
variable and the I/O sequence variable, initial values of used
variables in S2′ are not enum labels in E, and there are no
inputs in S2 ’s execution translated into any label in E, ∀x ∈
OVar(S1′ ) ∪ {idI , idIO } ∀m1 (σ1 ) m2 (σ2 ) : σ1 (x) = σ2 (x),
and S1′ and S2′ terminate in the same way, produce the same
output sequence, and have equivalent computation of defined
variables in S1′ and S2′ as well as the input sequence variable
and the I/O sequence variable ((S1′ , m1 ) ≡H (S2′ , m2 )) ∧
((S1′ , m1 ) ≡O (S2′ , m2 )) ∧ (∀x ∈ OVar(S1 ) ∪ OVar(S2 ) ∪
{idI , idIO } :
(S1′ , m1 ) ≡x (S2′ , m2 ));

If S1 and S2 start in states m1 (loop1c , σ1 ), m2 (loop2c , σ2 ), with
loop counters of S1 and S2 not initialized (S1 , S2 have not executed
yet), value stores agree on values of output deciding variables in
S1 and S2 as well as the input sequence variable, the I/O sequence
variable, initial values of used variables in S2 are not of values as
enum labels in E, no inputs are translated into enum labels in E,
then, for any positive integer i, one of the following holds:

1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
∗
′′
′
1′
1′
2
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in the
same way, produce the same output sequence, and have equivalent computation of output deciding variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of output deciding
variables in both S1 and S2 as well as the input sequence
variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∩
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x).
3. There are reachable configurations (S1 , m1 (loop1ci , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
53

1. Loop counters for S1 and S2 are always less than 1 if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i, (S2 , m2 (loop2c , σ2 )) →
′′
′
2′
2′
(S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in
the same way, produce the same output sequence, and have
equivalent computation of defined variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable,
(S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and ∀x ∈
(Def(S1 ) ∩ Def(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x (S2 , m2 );
2. Loop counters of S1 and S2 are of value less than or equal to 1
but there are no reachable configurations (S1 , m1 (loop1c1 , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2c1 , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value 1, loop1c 1 (n1 )
= loop2c1 (n2 ) = 1.
• Value stores σ11 and σ21 agree on values of used variables
in both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪
{idI , idIO } : σ11 (x) = σ21 (x).
3. There are reachable configuration (S1 , m1 (loop1c1 , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2c1 , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value 1, loop1c 1 (n1 )
= loop2c1 (n2 ) = 1.
• Value stores σ11 and σ21 agree on values of used variables
in both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪
{idI , idIO } : σ11 (x) = σ21 (x).
By definition, variables used in the predicate expression e of S1
and S2 are used in S1 and S2 , Use(e) ⊆ Use(S1 ) ∩ Use(S2 ). By
assumption, value stores σ1 and σ2 agree on values of variables in
Use(e), the predicate expression e evaluates to the same value w.r.t
value stores σ1 and σ2 by Lemma D.2. There are three possibilities.
1. The evaluation of e crashes,
E ′ JeKσ1 = E ′ JeKσ2 = (error, vof ).
The execution of S1 continues as follows:
(whilehn1 i (e) {S1′ }, m1 (σ1 ))
→(whilehn1 i ((error, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (0) {S1′ }, m1 (1/f))
by the ECrash rule
i
→(whilehn1 i (0) {S1′ }, m1 (1/f)) for any i > 0
by the Crash rule.
Similarly, the execution of S2 started from the state m2 (σ2 )
crashes. Therefore S1 and S2 terminate in the same way when
started from m1 and m2 respectively. Because σ1 (idIO ) =
σ2 (idIO ), the lemma holds.
2. The evaluation of e reduces to zero, E ′ JeKσ1 = E ′ JeKσ2 =
(0, vof ).
The execution of S1 continues as follows.

2015/9/14

(whilehn1 i (e) {S1′ }, m1 (σ1 ))
= (whilehn1 i ((0, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (0) {S1′ }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(skip, m1 (σ1 )) by the Wh-F rule.

of S1 and S2 are either in variables used or defined in both
S1′ and S2′ or not. Therefore value stores σ2′ and σ1′ agree
on values of variables used in the expression e and even
variables used or defined in S1 and S2 .
Induction step on iterations
The induction hypothesis (IH) is that, when i ≥ 1, one of the
following holds:

Similarly, the execution of S2 gets to the configuration (skip,
m2 (σ2 )). Loop counters of S1 and S2 are less than 1 and value
stores agree on values of used/defined variables in both S1 and
S2 as well as the input sequence variable, and the I/O sequence
variable.
3. The evaluation of e reduces to the same nonzero integer value,
E ′ JeKσ1 = E ′ JeKσ2 = (0, vof ).
Then the execution of S1 proceeds as follows:

1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i, (S2 , m2 (loop2c , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in the
same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable,
(S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and ∀x ∈
(Def(S1 ) ∩ Def(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x (S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables in
both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).
3. There are reachable configurations (S1 , m1 (loop1ci , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables in
both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).

(whilehn1 i (e) {S1′ }, m1 (σ1 ))
= (whilehn1 i ((v, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (v) {S1′ }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(S1′ ; whilehn1 i (e) {S1′ }, m1 (
loop1c [1/n1 ], σ1 )) by the Wh-T rule.

Similarly, the execution of S2 proceeds to the configuration
(S2′ ; whilehn2 i (e) {S2′ }, m2 (loop2c [1/n1 ], σ2 )).
By the assumption, we show that S1′ and S2′ terminate in the
same way and produce the same output sequence when started
in the state m1 (loop1c1 , σ1 ) and m2 (loop2c1 , σ2 ) respectively,
and S1′ and S2′ have equivalent computation of variables defined
in both statement sequences if both terminate. We need to
show that all conditions are satisfied for the application of the
assumption.
• There are no inputs translated into enum labels in E in the
execution of S2′ .
The above condition is by assumption.
• Initial values of used variables in S2′ are not enum labels in
E.
By the definition of used variables, Use(S2′ ) ⊆ Use(S2 ).
By assumption, initial values of used variables in S2 are not
enum labels in E. The condition holds.
Then we show that, when i + 1, one of the following holds: The
• Value stores σ1 and σ2 agree on values of used variables
induction hypothesis (IH) is that, when i ≥ 1, one of the following
in S1′ and S2′ as well as the input, output, I/O sequence
holds:
variable.
By definition, Use(S1′ ) ⊆ Use(S1 ). So are the cases to
1. Loop counters for S1 and S2 are always less than i + 1 if any
′
′
∗
S2′ and S2 . In addition, value stores σ1 and σ2 are not
is present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
changed in the evaluation of the predicate expression e. The
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i+1, (S2 , m2 (loop2c , σ2 )) →
condition holds.
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i + 1, S1 and S2 terminate
By assumption, S1′ and S2′ terminate in the same way and
in
the same way, produce the same output sequence, and have
produce the same output sequence when started in states
equivalent computation of used/defined variables in both S1 and
m1 (loop′c , σ1 ) and m2 (loop′c , σ2 ). In addition, S1′ and S2′ have
S2 and the input sequence variable, the I/O sequence variable,
equivalent computation of variables used or defined in S1′ and
(S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and ∀x ∈
S2′ when started in states m1 (loop′c , σ1 ) and m2 (loop′c , σ2 ).
(Def(S1 ) ∩ Def(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x (S2 , m2 );
Then there are two cases.
2. The loop counter of S1 and S2 are of value less than or
(a) S1′ and S2′ both do not terminate and produce the same
equal to i + 1, and there are no reachable configurations
output sequence.
(S1 , m1 (loop1ci+1 , σ1i+1 )) from (S1 , m1 (σ1 )),
By Lemma E.2, S1′ ; S1 and S2′ ; S2 both do not terminate
(S2 , m2 (loop2ci+1 , σ2i+1 )) from (S2 , m2 (σ2 )) where all of the
and produce the same output sequence.
′
′
following hold:
(b) S1 and S2 both terminate and have equivalent computation
• The loop counters of S1 and S2 are of value i + 1,
of variables defined in S1′ and S2′ .
∗
loop1ci+1 (n1 ) = loop2ci+1 (n2 ) = i + 1.
By assumption, (S1′ , m1 (loop′c , σ1 )) → (skip, m′1 (loop′′c , σ1′ ));
∗
• Value stores σ1i+1 and σ2i+1 agree on values of used vari(S2′ , m2 (loop′c , σ2 )) → (skip, m′2 (loop′′c , σ2′ )) where ∀x ∈
ables in both S1 and S2 as well as the input sequence vari(Def(S1′ ) ∩ Def(S2′ )) ∪ {idI , idIO }, σ1′ (x) = σ2′ (x).
able, and the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩
By assumption,Use(S1′ ) ⊆ Use(S2′ ) and Def(S1′ ) =
Use(S2 )) ∪ {idI , idIO } : σ1i+1 (x) = σ2i+1 (x).
Def(S2′ ). Then variables used in the predicate expression
54

2015/9/14

3. There are reachable configurations (S1 , m1 (loopc1i+1 , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value i, loopc1i+1 (n1 )
= loop2ci+1 (n2 ) = i + 1.
• Value stores σ1i+1 and σ2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩
Use(S2 )) ∪ {idI , idIO } : σ1i+1 (x) = σ2i+1 (x).

• Value stores σ1i+1 and σ2i+1 agree on values of used vari-

ables in both S1 and S2 as well as the input sequence variable, and the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩
Use(S2 )) ∪ {idI , idIO } : σ1i+1 (x) = σ2i+1 (x).
3. There are reachable configurations (S1 , m1 (loop1ci+1 , σ1i+1 ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 , σ2i+1 )) from (S2 ,
m2 (σ2 )) where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i.
• The loop counter of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i.
• Value stores σ1i+1 and σ2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable and the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩
Use(S2 )) ∪ {idI+1 , idIO } : σ1i+1 (x) = σ2i+1 (x).

By hypothesis IH, there is no configuration where loop counters
of S1 and S2 are of value i + 1 when any of the following holds:
1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i, (S2 , m2 (loop2c , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in the
same way, produce the same output sequence, and have equivalent computation of used/defined variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable,
(S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and ∀x ∈
(Def(S1 ) ∩ Def(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x (S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables in
both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).

6.3 Proof rule for variable type weakening
In programs, variable types are changed either to allow for larger
ranges (weakening). For example, an integer variable might be
changed to become a long variable to avoid integer overflow.
Adding a new enumeration value can is also type weakening. Increasing array size is another example of weakening. Allowing for
type weakening is essentially an assumption about the intent behind the update. The kinds of weakening that should be allowed
are application dependent and would need to be defined by the user
in general. The type weakening considered are either changes of
type Int to Long or increase of array size. These updates fix integer overflow or array index out of bound. In order to prove the
update of variable type weakening to be backward compatible, we
assume that there are no integer overflow and array index out of
bound in execution of the old program and the updated program.
In conclusion, the old program and the new program produce the
same output sequence because the integer overflow and index out
of bound errors fixed by the new program do not occur.
We formalize the update of variable type weakening, then we
show that the updated program produce the same output sequence
as the old program in executions if there are no integer overflow
or index out of bound exceptions related to variables with type
changes. First, we define a relation between variable definitions
showing the type weakening.

When there are reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )

= loop2ci (n2 ) = i.

• Value stores σ1i and σ2i agree on values of used variables in

both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).

Definition 28. (Cases of type weakening) We say there is type
weakening from a sequence of variable definitions V1 to V2 , written
V1 րτ V2 , iff one of the following holds:

By similar argument in base case, we have one of the following
holds:
1. Loop counters for S1 and S2 are always less than i + 1 if any
′
′
∗
is present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
∗
′′
′
1′
1′
2
(S1 , m1 (loopc )), loopc (n1 ) < i+1, (S2 , m2 (loopc , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in
the same way, produce the same output sequence, and have
equivalent computation of used/defined variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable,
(S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and ∀x ∈
(Def(S1 ) ∩ Def(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x (S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or
equal to i + 1, and there are no reachable configurations
(S1 , m1 (loop1ci , σ1i )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i ))
from (S2 , m2 (σ2 )) where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i + 1.
55

1. V1 = “Int id”, V2 = “Long id”;
2. V1 = “τ id[n2 ]”, V2 = “τ id[n1 ]” where n2 > n1 ;
3. V1 = V1′ , “τ1 id1 ”, V2 = V2′ , “τ2 id2 ” where (V1′ րτ V2′ ) ∧
(“τ1 id1 ” րτ “τ2 id2 ”);
4. V1 = V1′ , “τ1 id1 [n1 ]”, V2 = V2′ , “τ2 id2 [n2 ]” where (V1′ րτ
V2′ ) ∧ (“τ1 id1 [n1 ]” րτ “τ2 id2 [n2 ]”);
The following is the generalized definition of variable type
weakening.
Definition 29. (Variable type weakening) We say that there
are updates of variable type weakening in the program P2 =
P mpt; EN ; V2 ; Sentry compared with the program P1 = P mpt;
EN ; V1 ; Sentry , written P2 ≈S
τ P1 , iff V1 րτ V2 .
We show that two programs terminate in the same way, produce
the same output sequence, and have equivalent computation of
defined variables in both programs in valid executions if there are
updates of variable type weakening between them.

2015/9/14

1’: If (1/(a − 5)) then
2’:
skip
3’: output a

1:
2:
3: output a

Lemma 6.7. Let P1 = EN ; V1 ; Sentry and P2 = EN ; V2 ; Sentry
be two programs where there are updates of variable type weakening, P2 ≈S
τ P1 . If the programs P1 and P2 start in states m1 (σ1 )
and m2 (σ2 ) such that both of the following hold:

old

new

• Value stores σ1 and σ2 agree on values of variables used in

Sentry as well as the input sequence variable, the I/O sequence
variable, ∀x ∈ Use(Sentry ) ∪ {idI , idIO } : σ1 (x) = σ2 (x);
• There is no integer overflow or index out of bound exceptions
related to variables of type change;

Figure 17: Exit-on-error
6.4 Proof rule for exit on errors

then Sentry in the program P1 and P2 terminate in the same
way, produce the same output sequence, and when Sentry both
terminate, they have equivalent computation of defined variables
in Sentry in both programs as well as the input sequence variable,
the I/O sequence variable,

Another bugfix is called “exit-on-error”, which causes the program to exit in observation of application-semantic-dependent errors. Figure 17 shows an example of exit-on-error update. In the
example, the fixed bugs refer to the program semantic error that
a = 5. Instead of using an “exit” statement, we rely on the crash
from expression evaluations to formalize the update class. In order
to prove the update of exit-on-error to be backward compatible, we
assume that there are no application related error in executions of
the old program. Therefore, the two programs produce the same
output sequence because the extra check does not cause the new
program’s execution to crash.
The following is the generalized definition of the update class
“exit-on-error”.

• (Sentry , m1 ) ≡H (Sentry , m2 );
• (Sentry , m1 ) ≡O (Sentry , m2 );
• ∀x ∈ Def(S) ∪ {idI , idIO } :

(Sentry , m1 ) ≡x (Sentry , m2 );

Because Sentry are the exactly same in both programs P1 and
P2 , we omit the straightforward proof. Instead, we show that,
if there is no array index out of bound and integer overflow in
executions of the old program, then there is no array index out of
bound or integer overflow in executions of updated program due to
the increase of array index and change of type Int to Long.

Definition 30. (Exit on error) We say a statement sequence S2 includes updates of exit-on-err from a statement sequence S1 , written
S2 ≈ S
Exit S1 , iff one of the following holds:
1. S2 = “If(e) then{skip} else{skip}”; S1 ;
2. S1 = “If(e) then{S1t } else{S1f }”, S2 = “If(e) then{S2t } else{S2f }”
where both of the following hold
t
• S2t ≈S
Exit S1 ;
f
• S2f ≈S
S
Exit 1 ;
3. S1 = “while hn1 i (e) {S1′ }”, S2 = “whilehn2 i (e) {S2′ }” where
′
S2′ ≈S
Exit S1 ;
4. S1 ≈S
S
O 2;
5. S1 = S1′ ; s1 and S2 = S2′ ; s2 such that both of the following hold:
′
• S2′ ≈S
Exit S1 ;
′;
• S2′ ≈S
S
H 1
′
• ∀x ∈ Imp(s1 , idIO ) ∪ Imp(s1 , idIO ) : S2′ ≈S
x S1 ;
• s 2 ≈S
s
;
1
Exit

Proof. The proof is straightforward because the statement sequence
S is same in programs P1 and P2 . The only point is that if there is
array index out of bound or integer overflow in execution of S in
P1 , then there is no array index out of bound or integer overflow in
execution of S in P2 . To show the point, we present the argument
for the array index out of bound and integer overflow separately.
1. We show that, as to one expression id1 [id2 ], there is no array
index out of bound in P2 if there is no array index out of bound
in P1 when P1 and P2 are in states agreeing on values of used
variables in P1 and P2 ;
(id1 [id2 ], m1 (σ1 ))
→(id1 [v], m1 (σ1 )) by the rule Var

Though the bugfix in Definition 30 is not in rare execution in
the first case, the definition shows the basic form of bugfix clearly.
We show that two programs terminate in the same way, produce
the same output sequence, and have equivalent computation of
defined variables in both programs in valid executions if there are
updates of exit-on-error between them.

Similarly, (id1 [id2 ], m2 (σ2 )) → (id1 [v], m2 (σ2 )). By Definition 28, the array bound of id1 in P2 is no less than that in P1 ,
then there is no array out of bound exception in evaluation of
id1 [id2 ] in P2 if there is no array out of bound exception in
evaluation of id1 [id2 ] in P1 .
2. We show that, as to one expression e, there is no integer overflow in evaluation of e in P2 if there is no integer overflow in
evaluation of e in P1 ;

Lemma 6.8. Let S1 and S2 be two statement sequences respectively where there are updates of exit-on-error in S2 against S1 ,
S2 ≈ S
Exit S1 . If S1 and S2 start in states m1 (σ1 ) and m2 (σ2 ) such
that both of the following hold:
• Value stores σ1 and σ2 agree on values of variables used in both

(e, m1 (σ1 ))
→((ve , vof ), m1 (σ1 )) by the rule EEval’

S1 and S2 as well as the input sequence variable and the I/O
sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI , idIO } :
σ1 (x) = σ2 (x);
• There are no program semantic errors related to the extra check
in the update of exit-on-error in the execution of S1 ;

When every used variable in the expression e is of same type
in P1 and P2 , then the evaluation of the expression e in P2 is
of the same result (ve , vof ) in P1 . When every used variable in
the expression e is of type Int in P1 and of type Long P2 , then
there is no integer overflow in the evaluation of the expression
e in P2 if there is no integer overflow in the evaluation of the
expression e in P1 . This is because the values of type Long are
a superset of those of type Int.

then S1 and S2 terminate in the same way, produce the same output
sequence, and when S1 and S2 both terminate, they have equivalent
computation of defined variables in both S1 and S2 as well as the
input sequence variable and the I/O sequence variable,
• (S1 , m1 ) ≡H (S2 , m2 );
• (S1 , m1 ) ≡O (S2 , m2 );
56

2015/9/14

→(If(0) then{S1t } else{S1f }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(S1f , m1 (σ1 )) by the If-F rule.
Proof. By induction on the sum of the program size of S1 and S2 ,
Similarly, the execution of S2 gets to the configuration
size(S1 ) + size(S2 ).
(S2f , m2 (σ2 )).
Base case. S1 = s and S2 = “If(e) then{skip} else{skip}”; s;
By the hypothesis IH, we show the lemma holds. We need
By assumption, there is no program semantic error related to
to show that all conditions are satisfied for the application
the update of exit-on-error. Then the evaluation of the predicate
of the hypothesis IH.
expression e in the first statement of S2 does not crash. W.l.o.g., the
f
• (S2f ≈S
Exit S1 )
expression e evaluates to zero. Then the execution of S2 proceeds
By assumption.
as follows.
• The sum of the program size of S1f and S2f is less than
k, size(S1f ) + size(S2f ) < k.
(If(e) then{skip} else{skip}; s, m2 (σ2 ))
→(If((0, vof )) then{skip} else{skip}; s, m2 (σ2 ))
By definition, size(S1 ) = 1+size(S1t )+size(S1f ). Then,
by the rule EEval’
size(S1f ) + size(S2f ) < k + 1 − 2 = k − 1.
→(If(0) then{skip} else{skip}; s, m2 (σ2 ))
• Value stores σ1 and σ2 agree on values of used variables
by the rule E-Oflow1 or E-Oflow2.
in S1f and S2f as well as the input, I/O sequence variable.
→(skip; s, m2 (σ2 )) by the rule If-F
By definition, Use(S1f ) ⊆ Use(S1 ). So are the cases to
→(s, m2 (σ2 )) by the rule Seq.
S2f and S2 . In addition, value stores σ1 and σ2 are not
∗
changed in the evaluation of the predicate expression e.
Value stores σ2 are not changed in the execution of (S2 , m2 (σ2 )) →
The condition holds.
(s, m2 (σ2 )). By assumption, σ1 and σ2 agree on values of used
• There are no program semantic error related to the extra
variables as well as the input sequence variable, and the I/O secheck in the update of exit-on-error in the execution of
quence variable, ∀x ∈ Use(S2 ) ∩ Use(S1 ) ∪ {idI , idIO } :
S2 .
σ1 (id) = σ2 (id). By semantics, S1 and S2 terminate in the same
By assumption.
way, produce the same output sequence, and have equivalent comBy the hypothesis IH, the lemma holds.
putation of defined variables in both S1 and S2 as well as the input
(c) The evaluation of e reduces to the same nonzero integer
sequence variable, and the I/O sequence variable. Then this lemma
value, E ′ JeKσ1 = E ′ JeKσ2 = (v, vof ) where v 6= 0.
holds.
By
similar to the second subcase above.
Induction step.
2. S1 and S2 are both “while” statements:
The hypothesis is that this lemma holds when the sum k of the
S1 = “whilehni (e) {S1′ }”, S2 = “whilehni (e) {S2′ }” where
program size of S1 and S2 are great than or equal to 4, k ≥ 4.
′
We then show that this lemma holds when the sum of the
(S2′ ≈S
exit S1 );
program size of S1 and S2 is k + 1. There are cases to consider.
By Lemma 6.10, we show this lemma holds. We need to show
that all required conditions are satisfied for the application of
1. S1 and S2 are both “If” statement:
Lemma 6.10.
S1 = “If(e) then{S1t } else{S1f }”, S2 = “If(e) then{S2t } else{S2f }”
• The output deciding variables in S1′ are a subset of those in
where both of the following hold
S2′ , OVar(S1′ ) = OVar(S2′ );
t
• (S2t ≈S
S
);
By Lemma 6.9.
Exit 1
f
• (S2f ≈S
• When started in states m′1 (σ1′ ), m′2 (σ1′ ) where value stores
Exit S1 );
σ1′ and σ2′ agree on values of used variables in both S1′
By the definition of Use(S1 ), variables used in the predicate exand S2′ as well as the input sequence variable, and the I/O
pression e are a subset of used variables in S1 and S2 , Use(e) ⊆
sequence variable, then S1′ and S2′ terminate in the same
Use(S1 ) ∩ Use(S2 ). By assumption, corresponding variables
way, produce the same output sequence, and have equivaused in e are of same value in value stores σ1 and σ2 . By
lent computation of defined variables in both S1 and S2 as
Lemma D.1, the expression evaluates to the same value w.r.t
well as the input sequence variable, and the I/O sequence
value stores σ1 and σ2 . There are three possibilities.
variable.
(a) The evaluation of e crashes, E ′ JeKσ1 = E ′ JeKσ2 =
By the induction hypothesis IH. This is because the sum of
(error, vof ).
the program size of S1′ and S2′ is less than k. By definition,
The execution of S1 continues as follows:
′
f
t
size(S
1 ) = 1 + size(S1 ).
(If(e) then{S1 } else{S1 }, m1 (σ1 ))
By Lemma 6.10, this lemma holds.
→(If((error, vof )) then{S1t } else{S1f }, m1 (σ1 ))
3. S1 = S1′ ; s1 and S2 = S2′ ; s2 where both of the following hold:
by the rule EEval’
→(If(0) then{S1t } else{S1f }, m1 (1/f))
′
• (S2′ ≈S
Exit S1 );
by the ECrash rule
S
•
(s
≈
s
i
2
Exit 1 );
→(If(0) then{S1t } else{S1f }, m1 (1/f)) for any i > 0
by the Crash rule.
By the hypothesis IH, we show S2′ and S1′ terminate in the
Similarly, the execution of S2 started from the state m2 (σ2 )
same way and produce the same output sequence and when S2′
crashes. The lemma holds.
and S1′ both terminate, S2′ and S1′ have equivalent terminating
(b) The evaluation of e reduces to zero, E ′ JeKσ1 = E ′ JeKσ2 =
computation of variables used or defined in S2′ and S1′ as well
(0, vof ).
as the input sequence variable, and the I/O sequence variable.
The execution of S1 continues as follows.
We show all the required conditions are satisfied for the application of the hypothesis IH.
(If(e) then{S1t } else{S1f }, m1 (σ1 ))
′
• (S2′ ≈S
= (If((0, vof )) then{S1t } else{S1f }, m1 (σ1 ))
Exit S1 ).
By assumption.
by the rule EEval’
• ∀x ∈ (Def(S1 ) ∩ Def(S2 )) ∪ {idI , idIO } :

(S1 , m1 ) ≡x (S2 , m2 );

57

2015/9/14

• The sum of the program size of S1′ and S2′ is less than k,

Lemma 6.10. Let S1 = whilehn1 i (e) {S1′ } and S2 = whilehn2 i (e)
size(S1′ ) + size(S2′ ) < k.
{S2′ } be two loop statements where all of the following hold:
By definition, size(S2 ) = size(s2 ) + size(S2′ ) where
• the output deciding variables in S1′ are a subset of those in S2′ ,
size(s2 ) < 1. Then, size(S2′ ) + size(S1′ ) < k + 1 −
OVar(S1′ ) ⊆ OVar(S2′ ) = OVar(S);
size(s2 ) − size(s1 ) < k.
• When started in states m′1 (σ1′ ), m′2 (σ2′ ) where
• Value stores σ1 and σ2 agree on values of used variables in
Value stores agree on values of output deciding variables
both S2′ and S1′ as well as the input, I/O sequence variable.
in both S1′ and S2′ as well as the input sequence variBy definition, Use(S2′ ) ⊆ Use(S2 ), Use(S1′ ) ⊆ Use(S1 ).
able, and the I/O sequence variable, ∀x ∈ OVar(S2′ ) ∪
The condition holds.
′
′
′
′
′
′
{id
I , idIO } ∀m1 (σ1 ) m2 (σ2 ) : σ1 (x) = σ2 (x);
By the hypothesis IH, one of the following holds:
There are no program semantic errors related to the extra
(a) S1′ and S2′ both do not terminate.
check in the update of exit-on-error in executions of S1′ and
′
By Lemma E.2, executions of S1 = S1 ; s1 and S2 =
S2′ ;
′
S2 ; s2 both do not terminate and produce the same output
then S1′ and S2′ terminate in the same way, produce the same
sequence.
output sequence, and have equivalent computation of defined
′
′
(b) S1 and S2 both terminate.
variables in S1′ and S2′ as well as the input sequence variable,
∗
∗
′
′
′
′
By assumption, (S2 , m2 (σ2 )) → (skip, m2 (σ2 )), (S1 , m1 (σ1 )) →
and the I/O sequence variable ((S1′ , m1 ) ≡H (S2′ , m2 )) ∧
(skip, m′1 (σ1′ )).
((S1′ , m1 ) ≡O (S2′ , m2 )) ∧ (∀x ∈ OVar(S) ∪ {idI , idIO } :
∗
By Corollary E.1, (S2′ ; s2 , m2 (σ2 )) → (s2 , m′2 (σ2′ )),
(S1′ , m1 ) ≡x (S2′ , m2 ));
∗
(S1′ ; s1 , m1 (σ1 )) → (s1 , m′1 (σ1′ )).
If S1 and S2 start in states m1 (loop1c , σ1 ), m2 (loop2c , σ2 ) reBy the hypothesis IH, we show that s2 and s1 terminate
spectively, with loop counters of S1 and S2 not initialized (S1 , S2
in the same way, produce the same output sequence and
have not executed yet), value stores agree on values of used variwhen s2 and s1 both terminate, s2 and s1 have equivalent
ables in S1 and S2 , and there are no program semantic errors recomputation of variables defined in both s1 and s2 and the
lated to the extra check in the update of exit-on-error, then, for any
input, and I/O sequence variables.
positive integer i, one of the following holds:
We need to show that all conditions are satisfied for the
application of the hypothesis IH.
1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
• There are updates of “exit-on-error” between s2 and s1 ,
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
s2 ≈S
s
;
2
1
′′
′
1
1
Exit
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
By assumption, s2 ≈S
′′
′
2′
2′
Exit s1 .
(S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in
• The sum of the program size s2 and s1 is less than or
the same way, produce the same output sequence, and have
equals to k;
equivalent computation of output deciding variables in S1 and
By definition, size(S2′ ) ≥ 1, size(S1′ ) ≥ 1. Therefore,
S2 and the input sequence variable, the I/O sequence vari′
′
size(s2 ) + size(s1 ) < k + 1 − size(S2 ) − size(S1 ) ≤ k.
able, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
• Value stores σ1′ and σ2′ agree on values of output de∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪ {idI , idIO } :
ciding variables in s2 and s1 as well as the input, I/O
(S1 , m1 ) ≡x (S2 , m2 );
sequence variable.
2. The loop counter of S1 and S2 are of value less than or equal
By Lemma 6.9, OVar(s1 ) ⊆ OVar(s2 ), then OVar(s2 )
to i, and there are no reachable configurations (S1 , m1 (loop1ci ,
∩OVar(s1 ) = OVar(s1 ). For any variable id in Use(s1 ),
σ1i )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 ,
if id is not in OVar(S1′ ), then the value of id is not
m
2 (σ2 )) where all of the following hold:
changed in the execution of S1′ and S2′ , σ1′ (id) =
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
′
σ1 (id) = σ2 (id) = σ2 (id). Otherwise, the variable id
= loop2ci (n2 ) = i.
is defined in the execution of S1′ and S2′ , by assumption,
′
′
•
Value stores σ1i and σ2i agree on values of output deciding
σ1 (id) = σ2 (id). The condition holds.
variables in S1 and S2 as well as the input sequence vari• There are no program semantic errors related to the extra
able, and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
check in the update of exit-on-error in the execution of
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x).
S2 .
3. There are reachable configurations (S1 , m1 (loop1ci , σ1i )) from
By assumption.
(S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 )) where
By the hypothesis IH, the lemma holds.
all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of output deciding
We list the auxiliary lemmas below. One lemma shows that,
variables in S1 and S2 including the input sequence variif there are updates of exit-on-error between two statement seable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
quences, then there are same set of defined variables in the two
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x).
statement sequences, and the used variables in the update program
are the superset of those in the old program.
Proof. By induction on i.
Lemma 6.9. Let S2 be a statement sequence and S1 where there
Base case.
are updates of exit-on-error, S2 ≈S
Exit S1 . Then output deciding variWe show that, when i = 1, one of the following holds:
ables in S1 are a subset of those in S2 , OVar(S1 ) ⊆ OVar(S2 ).
1. Loop counters for S1 and S2 are always less than 1 if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
Proof. By induction on the sum of the program size of S1 and
′
′
∗
1
′
′′
1
2
S2 .
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′′
′
2′
2′
(S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the
58

2015/9/14

3. The evaluation of e reduces to the same nonzero integer value,
E ′ JeKσ1 = E ′ JeKσ2 = (0, vof ).
Then the execution of S1 proceeds as follows:

same way, produce the same output sequence, and have equivalent computation of output deciding variables in S1 and S2
including the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. Loop counters of S1 and S2 are of values less than or equal to 1
but there are no reachable configurations (S1 , m1 (loop1c1 , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2c1 , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value 1, loop1c 1 (n1 )
= loop2c1 (n2 ) = 1.
• Value stores σ11 and σ21 agree on values of output deciding
variables in S1 and S2 including the input sequence variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI , idIO } : σ11 (x) = σ21 (x).
3. There are reachable configuration (S1 , m1 (loop1c1 , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2c1 , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value 1, loop1c 1 (n1 )
= loop2c1 (n2 ) = 1.
• Value stores σ11 and σ21 agree on values of output deciding
variables in S1 and S2 including the input sequence variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI , idIO } : σ11 (x) = σ21 (x).

(whilehn1 i (e) {S1′ }, m1 (σ1 ))
= (whilehn1 i ((v, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (v) {S1′ }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(S1′ ; whilehn1 i (e) {S1′ }, m1 (
loop1c ∪ {(n1 ) 7→ 1}, σ1 )) by the Wh-T rule.
Similarly, the execution of S2 proceeds to the configuration
(S2′ ; whilehn2 i (e) {S2′ }, m2 (loop2c ∪ {(n2 ) 7→ 1}, σ2 )).
By the assumption, we show that S1′ and S2′ terminate in the
same way and produce the same output sequence when started
in the state m1 (loop1c1 , σ1 ) and m2 (loop2c1 , σ2 ) respectively,
and S1′ and S2′ have equivalent computation of variables defined
in both statement sequences if both terminate. We need to
show that all conditions are satisfied for the application of the
assumption.
• There are no program semantic errors related to the extra
check in the update of exit-on-error in executions of S2′ and
S1′ .
The above two conditions are by assumption.
• Value stores σ1 and σ2 agree on values of output deciding
variables in S1′ and S2′ including the input, I/O sequence
variable.
By definition, OVar(S1′ ) ⊆ OVar(S1 ). So are the cases
to S2′ and S2 . In addition, value stores σ1 and σ2 are not
changed in the evaluation of the predicate expression e. The
condition holds.
By assumption, S1′ and S2′ terminate in the same way and
produce the same output sequence when started in states
m1 (loop′c , σ1 ) and m2 (loop′c , σ2 ). In addition, S1′ and S2′ have
equivalent computation of output deciding variables in S1′ and
S2′ when started in states m1 (loop′c , σ1 ) and m2 (loop′c , σ2 ).
Then there are two cases.
(a) S1′ and S2′ both do not terminate and produce the same
output sequence.
By Lemma E.2, S1′ ; S1 and S2′ ; S2 both do not terminate
and produce the same output sequence.
(b) S1′ and S2′ both terminate and have equivalent computation
of output deciding variables in S1′ and S2′ .
∗
By assumption, (S1′ , m1 (loop′c , σ1 )) → (skip, m′1 (loop′′c , σ1′ ));
∗
′
′
′
(S2 , m2 (loopc , σ2 )) → (skip, m2 (loop′′c , σ2′ )) where ∀x ∈
(OVar(S1′ ) ∪ OVar(S2′ )) ∪ {idI , idIO }, σ1′ (x) = σ2′ (x).
By Lemma 6.9, OVar(S1′ ) ⊆ OVar(S2′ ). Then variables
used in the predicate expression of S1 and S2 are either in
output deciding variables in both S1′ and S2′ or not. Therefore value stores σ2′ and σ1′ agree on values of variables used
in the expression e and even output deciding variables in S1
and S2 .

By definition, variables used in the predicate expression e of S1
and S2 are in output deciding variables in S1 and S2 , Use(e) ⊆
OVar(S1 ) ∪ OVar(S2 ). By assumption, value stores σ1 and σ2
agree on values of variables in Use(e), the predicate expression
e evaluates to the same value w.r.t value stores σ1 and σ2 by
Lemma D.2. There are three possibilities.
1. The evaluation of e crashes,
E ′ JeKσ1 = E ′ JeKσ2 = (error, vof ).
The execution of S1 continues as follows:
(whilehn1 i (e) {S1′ }, m1 (σ1 ))
→(whilehn1 i ((error, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (0) {S1′ }, m1 (1/f))
by the ECrash rule
i
→(whilehn1 i (0) {S1′ }, m1 (1/f)) for any i > 0
by the Crash rule.
Similarly, the execution of S2 started from the state m2 (σ2 )
crashes. Therefore S1 and S2 terminate in the same way when
started from m1 and m2 respectively. Because σ1 (idIO ) =
σ2 (idIO ), the lemma holds.
2. The evaluation of e reduces to zero, E ′ JeKσ1 = E ′ JeKσ2 =
(0, vof ).
The execution of S1 continues as follows.
(whilehn1 i (e) {S1′ }, m1 (σ1 ))
= (whilehn1 i ((0, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (0) {S1′ }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(skip, m1 (σ1 )) by the Wh-F rule.

Induction step on iterations
The induction hypothesis (IH) is that, when i ≥ 1, one of the
following holds:

Similarly, the execution of S2 gets to the configuration (skip, m2 (σ2 )).
Loop counters of S1 and S2 are less than 1 and value stores
agree on values of output deciding variables in S1 and S2 including the input sequence variable and the I/O sequence variable.

59

1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
∗
′′
′
1′
1′
2
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′′
′
2′
2′
(S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the
same way, produce the same output sequence, and have equivalent computation of output deciding variables in both S1 and S2

2015/9/14

as well as the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the followings hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of output deciding
variables in S1 and S2 including the input sequence variable, and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x).
3. There are reachable configurations (S1 , m1 (loop1ci , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of output deciding
variables in S1 and S2 including the input sequence variable, and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x)).

same way, produce the same output sequence, and have equivalent computation of output deciding variables in S1 and S2
including the input sequence variable and the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of output deciding
variables in both S1 and S2 as well as the input sequence
variable, and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI , idIO } : σ1i (x) = σ2i (x).
When there are reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )

Then we show that, when i + 1, one of the following holds:
1. Loop counters for S1 and S2 are always less than i + 1 if any
′
′
∗
is present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i+1, (S2 , m2 (loop2c , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i + 1, S1 and S2 terminate in
the same way, produce the same output sequence, and have
equivalent computation of output deciding variables in S1
and S2 including the input sequence variable and the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O
(S2 , m2 ) and ∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪ {idI , idIO } :
(S1 , m1 ) ≡x (S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or
equal to i + 1, and there are no reachable configurations
(S1 , m1 (loop1ci+1 , σ1i+1 )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 ,
σ2i+1 )) from (S2 , m2 (σ2 )) where all of the following hold:
• The loop counters of S1 and S2 are of value i + 1,
loop1ci+1 (n1 ) = loop2ci+1 (n2 ) = i + 1.
• Value stores σ1i+1 and σ2i+1 agree on values of output deciding variables in S1 and S2 including the input sequence
variable, and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI , idIO } : σ1i+1 (x) = σ2i+1 (x).
3. There are reachable configurations (S1 , m1 (loop1ci+1 , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i + 1.
• Value stores σ1i+1 and σ2i+1 agree on values of output deciding variables in S1 and S2 including the input sequence
variable, and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI , idIO } : σ1i+1 (x) = σ2i+1 (x).
By hypothesis IH and theorem 4 and 5, there is no configuration
where loop counters of S1 and S2 are of value i + 1 when any of
the following holds:
1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
∗
1′
′
′′
1′
2
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in the
60

= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of output deciding
variables in S1 and S2 including the input sequence variable
and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪
{idI , idIO } : σ1i (x) = σ2i (x).

By similar argument in base case, we have one of the following
holds:
1. Loop counters for S1 and S2 are always less than i + 1 if any
′
′
∗
is present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i+1, (S2 , m2 (loop2c , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in the
same way, produce the same output sequence, and have equivalent computation of output deciding variables in S1 and S2
including the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (OVar(S1 ) ∪ OVar(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x
(S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or
equal to i + 1, and there are no reachable configurations
(S1 , m1 (loop1ci , σ1i )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i ))
from (S2 , m2 (σ2 )) where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i + 1.
• Value stores σ1i+1 and σ2i+1 agree on values of output deciding variables in S1 and S2 including the input sequence
variable and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI , idIO } : σ1i+1 (x) = σ2i+1 (x).
3. There are reachable configurations (S1 , m1 (loop1ci+1 , σ1i+1 ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 , σ2i+1 )) from (S2 ,
m2 (σ2 )) where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i.
• Value stores σ1i+1 and σ2i+1 agree on values of output deciding variables in S1 and S2 including the input sequence
variable, and the I/O sequence variable, ∀x ∈ (OVar(S1 ) ∪
OVar(S2 )) ∪ {idI+1 , idIO } : σ1i+1 (x) = σ2i+1 (x).

2015/9/14

programs P1 and P2 have the same entry statement sequence and
we have the assumption that different prompt outputs due to the
difference of the prompt type are equivalent.

6.5 Proof rule for improved prompt message
If the only difference between two programs are the constant messages that the user receives, we consider that the two programs to be
equivalent. We realize that in general it is possible to introduce new
semantics even by changing constant strings. An old version might
have incorrectly labeled output: “median value = 5” instead of “average value = 5, for example. We rule out such possibilities because
all non-constant values are guaranteed to be exactly same. In practice, outputs could be classified into prompt outputs and actual outputs. Prompt outputs are those asking clients for inputs, which are
constants hardcoded in the output statement. Actual outputs are dynamic messages produced by evaluation of non-constant expression
in execution. The changes of prompt outputs are equivalent only for
interactions with human clients. In order to prove the update of improved prompt messages to be backward compatible, we assume
that the different prompt outputs produced in executions of the old
program and the updated program, due to the different constants in
output statements, are equivalent. Because the old program and the
new program are exactly same except some output statements with
different constants as expression e, we could show two programs
produce the “equivalent” output sequence under the assumption of
equivalent prompt outputs.
We formalize the generalized update of improved prompt messages, then we show that the updated program produce the same
I/O sequence as the old program in executions without program semantic errors. The following is the definition of the update class of
improved prompt messages.

Proof. By induction on the sum of the program size of S1 and S2 ,
size(S1 ) + size(S2 ).
Base case. S1 = “output v1 ” and S2 = “output v2 ”;
Then the execution of S2 proceeds as follows.
(output v2 , m2 (σ2 ))
→(skip, m2 (σ2 [“σ2 (idIO ) · v¯2 ”/idIO ]))
by the rule Out-1 or Out-2
∗

Similarly, (output v1 , m1 (σ1 )) → (skip, m1 (σ1 [“σ1 (idIO )·v¯1 ”/idIO ])).
By assumption, σ2 (idIO ) ≡ σ1 (idIO ). In addition, by assumption, v¯2 ≡ v¯1 . Therefore, S1 and S2 terminate in the same way,
produce the same output sequence and have equivalent computation of defined variables in S1 and S2 . This lemma holds.
Induction step.
The hypothesis is that this lemma holds when the sum k of the
program size of S1 and S2 are great than or equal to 2, k ≥ 2.
We then show that this lemma holds when the sum of the
program size of S1 and S2 is k + 1. There are cases to consider.
1. S1 and S2 are both “If” statement:
S1 = “If(e) then{S1t } else{S1f }”, S2 = “If(e) then{S2t } else{S2f }”
where both of the following hold
t
• S2t ≈S
Out S1 ;
f
• S2f ≈S
Out S1 ;
By the definition of Use(S1 ), variables used in the predicate expression e are a subset of used variables in S1 and S2 , Use(e) ⊆
Use(S1 ) ∩ Use(S2 ). By assumption, corresponding variables
used in e are of same value in value stores σ1 and σ2 . By
Lemma D.1, the expression evaluates to the same value w.r.t
value stores (σ1 and σ2 . There are three possibilities.
(a) The evaluation of e crashes, E ′ JeKσ1 = E ′ JeKσ2 =
(error, vof ).
The execution of S1 continues as follows:
(If(e) then{S1t } else{S1f }, m1 (σ1 ))
→(If((error, vof )) then{S1t } else{S1f }, m1 (σ1 ))
by the rule EEval’
→(If(0) then{S1t } else{S1f }, m1 (1/f))
by the ECrash rule
i
→(If(0) then{S1t } else{S1f }, m1 (1/f)) for any i > 0
by the Crash rule.
Similarly, the execution of S2 started from the state m2 (σ2 )
crashes. The lemma holds.
(b) The evaluation of e reduces to zero, E ′ JeKσ1 = E ′ JeKσ2 =
(0, vof ).
The execution of S1 continues as follows.
(If(e) then{S1t } else{S1f }, m1 (σ1 ))
= (If((0, vof )) then{S1t } else{S1f }, m1 (σ1 ))
by the rule EEval’
→(If(0) then{S1t } else{S1f }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(S1f , m1 (σ1 )) by the If-F rule.
Similarly, the execution of S2 gets to the configuration
(S2f , m2 (σ2 )).
By the hypothesis IH, we show the lemma holds. We need
to show that all conditions are satisfied for the application
of the hypothesis IH.
f
• S2f ≈S
Out S1
By assumption.

Definition 31. (Improved user messages) A program P2 =
P mpt2 ; EN ; V ; Sentry includes updates of improved prompt messages compared with a program P1 = P mpt1 ; EN ; V ; Sentry ,
written P2 ≈S
Out P1 , iff P mpt2 6= P mpt1 .
We give the lemma that two programs terminate in the same
way, produce the equivalent output sequence, and have equivalent
computation of defined variables in both programs in valid executions if there are updates of improved prompt messages between
them.
Lemma 6.11. Let P1 = P mpt1 ; EN ; V ; Sentry and P2 =
P mpt2 ; EN ; V ; Sentry be two programs where there are updates
of improved prompt messages in P2 compared with P1 . If S1 and
S2 start in states m1 (σ1 ) and m2 (σ2 ) such that both of the following hold:
• Value stores σ1 and σ2 agree on values of variables used in

Sentry in both programs as well as the input sequence variable,
∀x ∈ Use(Sentry ) ∪ {idI } : σ1 (x) = σ2 (x);
• Value stores σ1 and σ2 have “equivalent” I/O sequence,
σ1 (idIO ) ≡ σ2 (idIO );
• The different prompt outputs in the update of improved prompt
messages are equivalent;
then S1 and S2 terminate in the same way, produce the equivalent
output sequence, and when S1 and S2 both terminate, they have
equivalent computation of defined variables in Sentry in both programs as well as the input sequence variable, Sentry in the two
programs produce the equivalent I/O sequence variable,
• (Sentry , m1 ) ≡H (Sentry , m2 );
• ∀x ∈ (Def(S1 ) ∩ Def(S2 )) ∪ {idI } : (Sentry , m1 ) ≡x

(Sentry , m2 );

• The produced output sequences in executions of Sentry in both

programs are “equivalent”, σ1 (idIO ) ≡ σ2 (idIO ).
The difference between prompt types in P1 and P2 can be either addition/removal of labels as well as the change of the mapping of labels with constants. The proof is straightforward because

61

2015/9/14

By definition, Use(S2′ ) ⊆ Use(S2 ), Use(S1′ ) ⊆ Use(S1 ).
The condition holds.
By the hypothesis IH, one of the following holds:
(a) S1′ and S2′ both do not terminate.
By Lemma E.2, executions of S1 = S1′ ; s1 and S2 =
S2′ ; s2 both do not terminate and produce the same output
sequence.
(b) S1′ and S2′ both terminate.
∗
∗
By assumption, (S2′ , m2 (σ2 )) → (skip, m′2 (σ2′ )), (S1′ , m1 (σ1 )) →
′
′
(skip, m1 (σ1 )).
∗
By Corollary E.1, (S2′ ; s2 , m2 (σ2 )) → (s2 , m′2 (σ2′ )),
∗
′
′
′
(S1 ; s1 , m1 (σ1 )) → (s1 , m1 (σ1 )).
By the hypothesis IH, we show that s2 and s1 terminate in
the same way, produce the “equivalent” output sequence and
when s2 and s1 both terminate, s2 and s1 have equivalent
computation of variables defined in both s1 and s2 and the
input sequence variable; s2 and s1 produce “equivalent”
output sequence.
We need to show that all conditions are satisfied for the
application of the hypothesis IH.
• There are updates of “improved prompt messages” in s2
compared with s1 , s2 ≈S
Out s1 ;
By assumption, s2 ≈S
Out s1 .
• The sum of the program size s2 and s1 is less than or
equals to k;
By definition, size(S2′ ) ≥ 1, size(S1′ ) ≥ 1. Therefore,
size(s2 ) + size(s1 ) < k + 1 − size(S2′ ) − size(S1′ ) ≤ k.
• Value stores σ1′ and σ2′ agree on values of used variables
in s2 and s1 as well as the input sequence variable;
By Lemma 6.9, Use(s1 ) = Use(s2 ), then Use(s2 )
= Use(s1 ) = Use(s). Similarly, by Lemma 6.9,
Def(S1′ ) = Def(S2′ ). For any variable id in Use(s1 ), if
id is not in Def(S1′ ), then the value of id is not changed
in the execution of S1′ and S2′ , σ1′ (id) = σ1 (id) =
σ2 (id) = σ2′ (id). Otherwise, the variable id is defined in the execution of S1′ and S2′ , by assumption,
σ1′ (id) = σ2′ (id). The condition holds.
• Values of , the I/O sequence variable in value stores σ1′
and σ2′ are equivalent.
By assumption.
By the hypothesis IH, the lemma holds.

• The sum of the program size of S1f and S2f is less than

k, size(S1f ) + size(S2f ) < k.
By definition, size(S1 ) = 1+size(S1t )+size(S1f ). Then,
size(S1f ) + size(S2f ) < k + 1 − 2 = k − 1.
• Value stores σ1 and σ2 agree on values of used variables
in S1f and S2f as well as the input, I/O sequence variable.
By definition, Use(S1f ) ⊆ Use(S1 ). So are the cases to
S2f and S2 . In addition, value stores σ1 and σ2 are not
changed in the evaluation of the predicate expression e.
The condition holds.
• Different constants used in output statements are equivalent as output values.
By assumption.
By the hypothesis IH, the lemma holds.
(c) The evaluation of e reduces to the same nonzero integer
value, E ′ JeKσ1 = E ′ JeKσ2 = (v, vof ) where v 6= 0.
By argument similar to the second subcase above.
2. S1 and S2 are both “while” statements:
S1 = “whilehni (e) {S1′ }”, S2 = “whilehni (e) {S2′ }” where
′
S2′ ≈S
Out S1 ;
By Lemma 6.13, we show this lemma holds. We need to show
that all required conditions are satisfied for the application of
Lemma 6.13.
• S1′ and S2′ have same set of defined variables, Def(S1′ ) =
Def(S2′ ) = Def(S);
• The used variables in S1′ are a subset of those in S2′ ,
Use(S1′ ) = Use(S2′ );
By Lemma 6.12.
• When started in states m′1 (σ1′ ), m′2 (σ1′ ) where value stores
σ1′ and σ2′ agree on values of used variables in both S1′ and
S2′ as well as the input sequence variable, , and the I/O
sequence variable, then S1′ and S2′ terminate in the same
way, produce the same output sequence, and have equivalent computation of defined variables in both S1 and S2 as
well as the input sequence variable and the I/O sequence
variable.
By the induction hypothesis IH. This is because the sum of
the program size of S1′ and S2′ is less than k. By definition,
size(S1 ) = 1 + size(S1′ ).
By Lemma 6.13, this lemma holds.
3. S1 = S1′ ; s1 and S2 = S2′ ; s2 where both of the following hold:
′
• S2′ ≈S
Out S1 ;
• s2 ≈S
Out s1 ;

We list the auxiliary lemmas below. One lemma shows that, if
there are updates of improved prompt messages between two statement sequences, then there are same set of defined variables and
used variables in the two statement sequences. The second lemma
shows that, if there are updates of improved prompt messages between two loop statements, then the two loop statement terminate
in the same way, produce the equivalent output sequence, and have
equivalent computation of defined variables in both the old and updated programs as well as the input sequence variable.

By the hypothesis IH, we show S2′ and S1′ terminate in the same
way and produce the equivalent output sequence and when S2′
and S1′ both terminate, S2′ and S1′ have equivalent terminating
computation of variables defined in S2′ and S1′ as well as the
input sequence variable. By assumption, the different value of
the I/O sequence in executions of S1 and S2 are equivalent.
We show all the required conditions are satisfied for the application of the hypothesis IH.
′
• S2′ ≈S
Out S1 ;
• The I/O sequence variable in executions of S1 and S2 are
equivalent, σ1 (idIO ) ≡ σ2 (idIO );
By assumption.
• The sum of the program size of S1′ and S2′ is less than k,
size(S1′ ) + size(S2′ ) < k.
By definition, size(S2 ) = size(s2 ) + size(S2′ ) where
size(s2 ) < 1. Then, size(S2′ ) + size(S1′ ) < k + 1 −
size(s2 ) − size(s1 ) < k.
• Value stores σ1 and σ2 agree on values of used variables in
both S2′ and S1′ as well as the input sequence variable.

Lemma 6.12. Let S2 be a statement sequence and S1 where there
are updates of “improved prompt messages”, S2 ≈S
Out S1 . Then used
variables in S2 are the same of used variables in S1 , Use(S1 ) =
Use(S2 ), defined variables in S2 are the same as used variables in
S1 , Def(S1 ) = Def(S2 ).
Proof. By induction on the sum of the program size of S1 and
S2 .
Lemma 6.13. Let S1 = whilehn1 i (e) {S1′ } and S2 = whilehn2 i (e)
{S2′ } be two loop statements where all of the following hold:
62

2015/9/14

• There are updates of improved prompt messages in S2′ com-

′
pared with S1′ , S2′ ≈S
Out S1 ;
′
′
• S1 and S2 have same set of defined variables,
Def(S1′ ) = Def(S2′ ) = Def(S);
• S1′ and S2′ have same set of used variables, Use(S1′ ) =
Use(S2′ );
• When started in states m′1 (σ1′ ), m′2 (σ2′ ) where
Value stores agree on values of used variables in both
S1′ and S2′ as well as the input sequence variable, ∀x ∈
Use(S1′ ) ∪ {idI } ∀m′1 (σ1′ ) m′2 (σ2′ ) : σ1′ (x) = σ2′ (x);
Values of the I/O sequence variable in value stores σ1′ , σ2′
are equivalent, σ1′ (idIO ) ≡ σ2′ (idIO ));
then S1′ and S2′ terminate in the same way, produce the “equivalent” output sequence, and have equivalent computation of
defined variables in S1′ and S2′ as well as the input sequence
variable, ((S1′ , m1 ) ≡H (S2′ , m2 )) ∧ (∀x ∈ Def(S) ∪ {idI } :
(S1′ , m1 ) ≡x (S2′ , m2 ));

If S1 and S2 start in states m1 (loop1c , σ1 ), m2 (loop2c , σ2 ) respectively, with loop counters of S1 and S2 not initialized (S1 , S2
have not executed yet), value stores agree on values of used variables in S1 and S2 , and there are no program semantic errors, then,
for any positive integer i, one of the following holds:

1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
∗
′′
′
1′
1′
2
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in the
same way, produce the equivalent output sequence, and have
equivalent computation of defined variables in both S1 and
S2 and the input sequence variable, (S1 , m1 ) ≡H (S2 , m2 )
and ∀x ∈ (Def(S1 ) ∩ Def(S2 )) ∪ {idI } : (S1 , m1 ) ≡x
(S2 , m2 );S1 and S2 produce the “equivalent” I/O sequence;
2. The loop counter of S1 and S2 are of value less than or equal
to i, and there are no reachable configurations (S1 , m1 (loop1ci ,
σ1i )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 ,
m2 (σ2 )) where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables
in both S1 and S2 as well as the input sequence variable,
∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i (x) = σ2i (x).
• Values of the I/O sequence variable in value stores σ1i (idIO ) ≡
σ2i (idIO );
3. There are reachable configurations (S1 , m1 (loop1ci , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables
in both S1 and S2 as well as the input sequence variable,
∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i (x) = σ2i (x).
• Values of the I/O sequence variable in value stores σ1i , σ2i
are equivalent, σ1i (idIO ) ≡ σ2i (idIO );
Proof. By induction on i.
Base case.
We show that, when i = 1, one of the followings holds:
1. Loop counters for S1 and S2 are always less than 1 if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
′′
′
1
1
2
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in
the same way, produce the equivalent I/O sequence, and have

equivalent computation of defined variables in both S1 and
S2 and the input sequence variable, the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and ∀x ∈ Def(S) ∪ {idI } :
(S1 , m1 ) ≡x (S2 , m2 );
2. S1 and S2 produce the equivalent output sequence and the
equivalent I/O sequence;
3. Loop counters of S1 and S2 are of values less than or equal to 1
but there are no reachable configurations (S1 , m1 (loop1c1 , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2c1 , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value 1, loop1c 1 (n1 )
= loop2c1 (n2 ) = 1.
• Value stores σ11 and σ21 agree on values of used variables
in both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪
{idI } : σ11 (x) = σ21 (x).
• Values of the I/O sequence variable in value stores σ11 and
σ21 are equivalent, σ11 (idIO ) ≡ σ21 (idIO );
4. There are reachable configuration (S1 , m1 (loop1c1 , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2c1 , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value 1, loop1c 1 (n1 )
= loop2c1 (n2 ) = 1.
• Value stores σ11 and σ21 agree on values of used variables
in both S1 and S2 as well as the input sequence variable, and
the I/O sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪
{idI } : σ11 (x) = σ21 (x).
• Values of the I/O sequence variable in value stores σ11 and
σ21 are equivalent, σ11 (idIO ) ≡ σ21 (idIO );
By definition, variables used in the predicate expression e of S1
and S2 are used in S1 and S2 , Use(e) ⊆ Use(S1 ) ∩ Use(S2 ). By
assumption, value stores σ1 and σ2 agree on values of variables in
Use(e), the predicate expression e evaluates to the same value w.r.t
value stores σ1 and σ2 by Lemma D.2. There are three possibilities.
1. The evaluation of e crashes,
E ′ JeKσ1 = E ′ JeKσ2 = (error, vof ).
The execution of S1 continues as follows:
(whilehn1 i (e) {S1′ }, m1 (σ1 ))
→(whilehn1 i ((error, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (0) {S1′ }, m1 (1/f))
by the ECrash rule
i
→(whilehn1 i (0) {S1′ }, m1 (1/f)) for any i > 0
by the Crash rule.
Similarly, the execution of S2 started from the state m2 (σ2 )
crashes. Therefore S1 and S2 terminate in the same way when
started from m1 and m2 respectively. Because σ1 (idIO ) ≡
σ2 (idIO ), the lemma holds.
2. The evaluation of e reduces to zero, E ′ JeKσ1 = E ′ JeKσ2 =
(0, vof ).
The execution of S1 continues as follows.
(whilehn1 i (e) {S1′ }, m1 (σ1 ))
= (whilehn1 i ((0, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (0) {S1′ }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(skip, m1 (σ1 )) by the Wh-F rule.
Similarly, the execution of S2 gets to the configuration (skip, m2 (σ2 )).
Loop counters of S1 and S2 are less than 1 and value stores
agree on values of used/defined variables in both S1 and S2

63

2015/9/14

in both S1 and S2 and the input sequence variable, (S1 , m1 )
≡H (S2 , m2 ) and ∀x ∈ Def(S) ∪ {idI } : (S1 , m1 ) ≡x
(S2 , m2 ); S1 and S2 produce the equivalent I/O sequence;
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables
in both S1 and S2 as well as the input sequence variable,
∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i (x) = σ2i (x).
• Values of the I/O sequence variable in value stores σ1i and
σ2i , σ1i (idIO ) ≡ σ2i (idIO );
3. There are reachable configurations (S1 , m1 (loop1ci , σ1i )) from
(S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 )) where
all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables
in both S1 and S2 as well as the input sequence variable,
∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i (x) = σ2i (x).
• Values of the I/O sequence variable in value stores σ1i and
σ2i are equivalent, σ1i (idIO ) ≡ σ2i (idIO );

as well as the input sequence variable and the I/O sequence
variable.
3. The evaluation of e reduces to the same nonzero integer value,
E ′ JeKσ1 = E ′ JeKσ2 = (v, vof ) where v 6= 0.
Then the execution of S1 proceeds as follows:
(whilehn1 i (e) {S1′ }, m1 (σ1 ))
= (whilehn1 i ((v, vof )) {S1′ }, m1 (σ1 ))
by the rule EEval’
→(whilehn1 i (v) {S1′ }, m1 (σ1 ))
by the E-Oflow1 or E-Oflow2 rule
→(S1′ ; whilehn1 i (e) {S1′ }, m1 (loop1c [1/n1 ], σ1 ))
by the Wh-T rule.

Similarly, the execution of S2 proceeds to the configuration
(S2′ ; whilehn2 i (e) {S2′ }, m2 (loop2c [1/n2 ], σ2 )).
By the assumption, we show that S1′ and S2′ terminate in
the same way and produce the equivalent I/O sequence when
started in the state m1 (loop1c1 , σ1 ) and m2 (loop2c1 , σ2 ) respectively, and S1′ and S2′ have equivalent computation of variables
defined in both statement sequences if both terminate. We need
to show that all conditions are satisfied for the application of
the assumption.
• Values of the I/O sequence variable in value stores σ1 and
σ2 are equivalent, σ1 (idIO ) ≡ σ2 (idIO );
The above two conditions are by assumption.
• Value stores σ1 and σ2 agree on values of used variables in
Then we show that, when i + 1, one of the following holds: The
S1′ and S2′ as well as the input sequence variable.
induction hypothesis (IH) is that, when i ≥ 1, one of the following
′
By definition, Use(S1 ) ⊆ Use(S1 ). So are the cases to
holds:
S2′ and S2 . In addition, value stores σ1 and σ2 are not
changed in the evaluation of the predicate expression e. The
1. Loop counters for S1 and S2 are always less than i + 1 if any
condition holds.
′
′
∗
is present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
By assumption, S1 and S2 terminate in the same way and
∗
′′
′
1′
1′
2
(S1 , m1 (loopc )), loopc (n1 ) < i+1, (S2 , m2 (loopc , σ2 )) →
produce the equivalent output sequence when started in states
′′
′
2′
2′
′
′
′
′
(S2 , m2 (loopc )), loopc (n2 ) < i + 1, S1 and S2 terminate in
m1 (loopc , σ1 ) and m2 (loopc , σ2 ). In addition, S1 and S2 have
the same way, produce the equivalent I/O sequence, and have
equivalent computation of variables used or defined in S1′ and
equivalent computation of defined variables in both S1 and
S2′ when started in states m1 (loop′c , σ1 ) and m2 (loop′c , σ2 ).
S2 and the input sequence variable, (S1 , m1 ) ≡H (S2 , m2 )
Then there are two cases.
and (S1 , m1 ) ≡O (S2 , m2 ) and ∀x ∈ (Def(S) ∪ {idI } :
(a) S1′ and S2′ both do not terminate and produce the equivalent
(S1 , m1 ) ≡x (S2 , m2 ); S1 and S2 produce the “equivalent”
I/O sequence.
I/O sequence variable;
By Lemma E.2, S1′ ; S1 and S2′ ; S2 both do not terminate
2. The loop counter of S1 and S2 are of value less than or
and produce the equivalent I/O sequence.
equal to i + 1, and there are no reachable configurations
(b) S1′ and S2′ both terminate and have equivalent computation
(S1 , m1 (loop1ci+1 , σ1i+1 )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 ,
of variables defined in S1′ and S2′ .
∗
′′
′
′
′
′
σ
2i+1 )) from (S2 , m2 (σ2 )) where all of the following hold:
By assumption, (S1 , m1 (loopc , σ1 )) → (skip, m1 (loopc , σ1 ));
∗
′′
′
′
′
′
•
The loop counters of S1 and S2 are of value i + 1,
(S2 , m2 (loopc , σ2 )) → (skip, m2 (loopc , σ2 )) where ∀x ∈
loop1ci+1 (n1 ) = loop2ci+1 (n2 ) = i + 1.
(Def(S1′ ) ∩ Def(S2′ )) ∪ {idI }, σ1′ (x) = σ2′ (x).
′
′
′
•
Value stores σ1i+1 and σ2i+1 agree on values of used variBy assumption,Use(S1 ) = Use(S2 ) and Def(S1 ) =
ables in both S1 and S2 as well as the input sequence variDef(S2′ ). Then variables used in the predicate expression
able, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i+1 (x) =
of S1 and S2 are either in variables used or defined in both
σ2i+1 (x).
S1′ and S2′ or not. Therefore value stores σ2′ and σ1′ agree
• Values of the I/O sequence variable in value stores σ1i+1
on values of variables used in the expression e and even
and σ2i+1 are equivalent, σ1i+1 (idIO ) ≡ σ2i+1 (idIO );
variables used or defined in S1 and S2 .
By assumption, S1 and S2 produce the equivalent output
3. There are reachable configurations (S1 , m1 (loop1ci+1 , σ1i ))
sequence.
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci+1 , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
Induction step on iterations
• The loop counter of S1 and S2 are of value i, loop1c i+1 (n1 )
The induction hypothesis (IH) is that, when i ≥ 1, one of the
= loop2ci+1 (n2 ) = i + 1.
following holds:
• Value stores σ1i+1 and σ2i+1 agree on values of used vari1. Loop counters for S1 and S2 are always less than i if any is
ables in both S1 and S2 as well as the input sequence vari′
′
∗
able, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i+1 (x) =
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
σ2i+1 (x);
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i, (S2 , m2 (loop2c , σ2 )) →
′
′
• Values of the I/O sequence variable in value stores σ1i+1
′′
′
2
2
(S2 , m2 (loopc )), loopc (n2 ) < i, S1 and S2 terminate in the
and σ2i+1 are equivalent, σ1i+1 (idIO ) ≡ σ2i+1 (idIO );
same way, and have equivalent computation of defined variables
64

2015/9/14

1:
2: If (a > 0) then
3:
b := c + 1
4: output b + c

By hypothesis IH, there is no configuration where loop counters
of S1 and S2 are of value i + 1 when any of the following holds:
1. Loop counters for S1 and S2 are always less than i if any is
′
′
∗
present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
∗
′′
′
1′
1′
2
(S1 , m1 (loopc )), loopc (n1 ) < i, (S2 , m2 (loopc , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in
the same way, produce the equivalent I/O sequence, and have
equivalent computation of used/defined variables in both S1
and S2 and the input sequence variable, , the I/O sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and (S1 , m1 ) ≡O (S2 , m2 ) and
∀x ∈ (Def(S1 ) ∩ Def(S2 )) ∪ {idI } : (S1 , m1 ) ≡x (S2 , m2 );
S1 and S2 produce , and the I/O sequence variable;
2. The loop counter of S1 and S2 are of value less than or equal to
i, and there are no reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i (n1 )
= loop2ci (n2 ) = i.
• Value stores σ1i and σ2i agree on values of used variables
in both S1 and S2 as well as the input sequence variable,
∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI , , idIO } : σ1i (x) =
σ2i (x).
• Values of the I/O sequence variable in value stores σ1i and
σ2i are equivalent, σ1i (idIO ) ≡ σ2i (idIO );

old

1’: b := 2
2’: If (a > 0) then
3’:
b := c + 1
4’: output b + c
new

Figure 18: Missing initialization
• The loop counter of S1 and S2 are of value i, loop1c i+1 (n1 )

= loop2ci+1 (n2 ) = i.

• The loop counter of S1 and S2 are of value i, loop1c i+1 (, n1 )

= loop2ci+1 (, n2 ) = i.
• Value stores σ1i+1 and σ2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i+1 (x) =
σ2i+1 (x);
• Values of the I/O sequence variable in value stores σ1i+1
and σ2i+1 are equivalent, σ1i+1 (idIO ) ≡ σ2i+1 (idIO );
6.6 Proof rule for missing variable initializations
A kind of bugfix we call missing-initialization includes variable
initialization for those in the imported variables relative to the I/O
sequence variable in the old program. Figure 18 shows an example of missing-initializations. The initialization b := 2 ensures the
value used in “output b + c” is not to be undefined. In general, new
variable initializations only affect rare buggy executions of the old
program, where there are uses of undefined imported variables relative to the I/O sequence variable in the program. Because DSU
is not starting in error state, we assume that, in the proof of backward compatibility, there are no uses of variables with undefined
variables in executions of the old program.
The following is the definition of the update class “missing
initializations”.

When there are reachable configurations (S1 , m1 (loop1ci , σ1i ))
from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i )) from (S2 , m2 (σ2 ))
where all of the following hold:
• The loop counter of S1 and S2 are of value i, loop1c i (n1 )

= loop2ci (n2 ) = i.

• Value stores σ1i and σ2i agree on values of used variables

in both S1 and S2 as well as the input sequence variable,
∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i (x) = σ2i (x).
• Values of the I/O sequence variable in value stores σ1i and σ2i
are equivalent, σ1i (idIO ) ≡ σ2i (idIO );

By similar argument in base case, we have one of the following
holds:
1. Loop counters for S1 and S2 are always less than i + 1 if any
′
′
∗
is present, ∀m′1 (loop1c ) m′2 (loop2c ) : (S1 , m1 (loop1c , σ1 )) →
′
′
∗
(S1′′ , m′1 (loop1c )), loop1c (n1 ) < i+1, (S2 , m2 (loop2c , σ2 )) →
′
′
(S2′′ , m′2 (loop2c )), loop2c (n2 ) < i, S1 and S2 terminate in
the same way, produce the equivalent I/O sequence, and have
equivalent computation of defined variables in both S1 and S2
and the input sequence variable, (S1 , m1 ) ≡H (S2 , m2 ) and
∀x ∈ (Def(S)) ∪ {idI } : (S1 , m1 ) ≡x (S2 , m2 );
2. The loop counter of S1 and S2 are of value less than or
equal to i + 1, and there are no reachable configurations
(S1 , m1 (loop1ci , σ1i )) from (S1 , m1 (σ1 )), (S2 , m2 (loop2ci , σ2i ))
from (S2 , m2 (σ2 )) where all of the following hold:
• The loop counters of S1 and S2 are of value i, loop1c i+1 (n1 )
= loop2ci+1 (n2 ) = i + 1.
• Value stores σ1i+1 and σ2i+1 agree on values of used variables in both S1 and S2 as well as the input sequence variable, ∀x ∈ (Use(S1 ) ∩ Use(S2 )) ∪ {idI } : σ1i+1 (x) =
σ2i+1 (x).
• Values of the I/O sequence variable in value stores σ1i+1
and σ2i+1 are equivalent, σ1i+1 (idIO ) ≡ σ2i+1 (idIO );
3. There are reachable configurations (S1 , m1 (loopc1i+1 , σ1i+1 ))
from (S1 , m1 (σ1 )), (S2 , m2 (loopc2i+1 , σ2i+1 )) from (S2 ,
m2 (σ2 )) where all of the following hold:

65

Definition 32. (Missing initializations) A statement sequence S2
includes updates of missing initializations compared with a statement sequence S1 , written S2 ≈S
Init S1 , iff S2 = SInit ; S1 where SInit
is a sequence of assignment statements of form “lval := v” and
Def(SInit ) ⊆ Imp(S1 , {idIO });
Though the bugfix in the update of missing initializations are
not in rare execution in the first case in Definition 32, the definition
shows the basic form of bugfix clearly.
We show that two statement sequences terminate in the same
way, produce the same output sequence, and have equivalent computation of defined variables in both programs in valid executions
if there are updates of missing initializations between them.
Lemma 6.14. Let S1 and S2 be two statement sequences respectively where there are updates of “missing initializations” in S2
compared with S1 , S2 ≈S
Init S1 . If S1 and S2 start in states m1 (σ1 )
and m2 (σ2 ) respectively such that both of the following hold:
• Value stores σ1 and σ2 agree on values of variables used in both

S1 and S2 as well as the input sequence variable and the I/O
sequence variable, ∀id ∈ (Use(S1 )∩Use(S2 ))∪{idI , idIO } :
σ1 (id) = σ2 (id);
• defined variables in SInit are of undefined value in value stores
σ1 , σ2 , ∀id ∈ Def(SInit ) : σ1 (id) = σ2 (id) = UdfJτ K where
τ is the type of the variable id;
• There are no use of variables with undefined values in the
execution of S1 ;
• There are no crash in execution of SInit ;

2015/9/14

7. Related Work

then S1 and S2 terminate in the same way, produce the same output
sequence, and when S1 and S2 both terminate, they have equivalent
computation of used variables and defined variables in both S1 and
S2 as well as the input sequence variable and the I/O sequence
variable,

We discuss related work on DSU safety and program equivalence
in order.
Existing studies on DSU safety could be roughly divided into
high level studies and low level ones. There are a few studies on
high level DSU safety. In [19], Kramer and Magee defined the DSU
correctness that the updated system shall “operate as normal instead
of progressing to an error state”. This is covered by our requirement that hybrid executions conform to the old program’s specification and our accommodation for bug fixes. Moreover, our backward compatibility includes I/O behavior, which is more concrete
than the behavior in [19]. In [9], Bloom and Day proposed a DSU
correctness which allows functionality extension that could not produce past behavior. This is probably because Bloom and Day considered updated environment. On the contrary, we assume that the
environment is not updated. In addition, we explicitly present the
error state, which is not mentioned in [9]. Panzica La Manna [28]
presented a high level correctness only considering scenario-based
specifications for controller systems instead of general programs.
There are also studies on low level DSU safety. Hayden et
al. [15] discussed DSU correctness and concluded that there is only
client-oriented correctness. Zhang et al. [32] asked the developers
to ensure DSU correctness. Magill et al. [24] did ad-hoc program
correlation without definitions of any correctness. We consider
that there is general principle of DSU safety. The difference lies
at the abstraction of the program behavior. We model program
behavior by concrete I/O while others [15, 24, 32] consider a
general program behavior.
We next discuss existing work on program equivalence. There is
a rich literature on program equivalence and we compare our work
only with most related work. Our study of program equivalence is
inspired by original work of Horwitz et al. [17] on program dependence graphs, but we take a much more formal approach and we
consider terminating as well as non-terminating programs with recurring I/O. In [13], Godlin and Strichman have a structured study
of program equivalence similar to that of ours. Godlin and Strichman [13] restricted the equivalence to corresponding functions and
therefore weakens the applicability to general transformations affecting loops such as loop fission, loop fusion and loop invariant
code motion. However, our program equivalence allows loop optimizations such as loop fusion and loop fission. Furthermore, our
syntactic conditions imply more program point mapping because
we allow corresponding program point in arbitrary nested statements and in the middle of program that does not include function
call.

• (S1 , m1 ) ≡H (S2 , m2 );
• (S1 , m1 ) ≡O (S2 , m2 );
• ∀x ∈ (Def(S1 ) ∪ Def(S2 )) ∪ {idI , idIO } : (S1 , m1 ) ≡x

(S2 , m2 );

Proof. By induction on the sum of the program size of S1 and S2 ,
size(S1 ) + size(S2 ).
Base case. S1 = s and S2 = SInit ; s where SInit = “lval := v”
and Def(lval) ∈ Use(s);
There are cases regarding lval in SInit .
1. lval = id.
Then the execution of S2 proceeds as follows.
(id := v; s, m2 (σ2 ))
→(skip; s, m2 (σ2 [v/(id)]))
by the rule As-Scl
→(s, m2 (σ2 [v/(id)])) by the rule Seq.
By assumption, id ∈ Use(e). By assumption, the value of id
is undefined in value store σ1 . Then there is no valid execution
of S1 . Then it holds that, in valid executions of S1 , S1 and S2
terminate in the same way, produce the same output sequence,
and have equivalent computation of defined variables in both
S1 and S2 . Then this lemma holds.
2. lval = id[n].
Then the execution of S2 proceeds as follows.
(id[n] := v; s, m2 (σ2 ))
→(skip; s, m2 (σ2 [v/(id, n)]))
by the rule As-Err
→(s, m2 (σ2 [v/(id, n)])) by the rule Seq.
By similar argument above, this lemma holds.
3. lval = id1 [id2 ].
Then the execution of S2 proceeds as follows.
(id1 [id2 ] := v; s, m2 (σ2 ))
→(id1 [v1 ] := v; s, m2 (σ2 [v/(id, n)]))
by the rule Var
→(skip; s, m2 (σ2 [v/(id, v1 )])) by the rule As-Arr.
→(s, m2 (σ2 [v/(id, v1 )])) by the rule Seq.

8. Conclusion
In this paper, we propose a formal and practical general definition
of DSU correction based on I/O sequences, backward compatibility. We devised a formal language and adapt the general definition of DSU correctness for executable programs based on our language. Based on the adapted backward compatibility, we proposed
syntactic conditions that help guarantee correct DSUs for both terminating and nonterminating executions. In addition, we formalize
typical program updates that are provably backward compatible,
covering both new feature and bugfix.
In the future, we plan to identify more backward compatible update patterns by studying more open source programs. Though it is
dubious if open source programs’ evolution history includes typical update patterns, open source programs are the most important
source of widely-used programs for our study of DSU. In addition,
we plan to develop an algorithm for automatic state mapping based
on our syntactic condition of program equivalence and definition of
update classes.

By similar argument above, this lemma holds.
Induction step.
The hypothesis is that this lemma holds when the sum k of the
program size of S1 and S2 are great than or equal to 3, k ≥ 3.
We then show that this lemma holds when the sum of the
program size of S1 and S2 is k + 1.
S2 = SInit ; S1 where SInit is a sequence of assignment statements and Def(SInit ) ∈ Imp(S1 , {idIO });
The proof is similar to that in the base case. By assump∗
tion, the execution of SInit does not crash, (SInit , m2 (σ2 )) →
(skip, m2 (σ2′ )) where σ2′ = σ2 [v1 /x1 ]...[vk /xk ] and ∀1 ≤ i ≤
k : xk ∈ Def(SInit ).
By assumption, there are no use of variables with undefined
values in the execution of S1 by Theorem 5 and Theorem 4, this
lemma holds.

66

2015/9/14

References

[26] K. Makris and R. A. Bazzi. Immediate Multi-Threaded Dynamic
Software Updates Using Stack Reconstruction. In Proceedings of the
USENIX ’09 Annual Technical Conference, June 2009. 3

[1] Software Engineering - Software Life Cycle Processes - Maintenance.
Technical Report ISO/IEC 14764:2006(E). 2.4

[27] I. Neamtiu. Practical Dynamic Software Updating.
University of Maryland, August 2008. 3

[2] Openssh users. http://www.openssh.com/users.html, 2015.
[Online; accessed 15-Jan-2015]. 3

PhD thesis,

[3] Vsftpd wikipage.
http://en.wikipedia.org/wiki/Vsftpd,
2015. [Online; accessed 15-Jan-2015]. 3

[28] V. Panzica La Manna, J. Greenyer, C. Ghezzi, and C. Brenner. Formalizing correctness criteria of dynamic updates derived from specification changes. SEAMS ’13, pages 63–72, 2013. 1, 7

[4] A. V. Aho, R. Sethi, and J. D. Ullman. Compilers: Principles, Techniques, and Tools. Addison-Wesley Longman Publishing Co., Inc.,
Boston, MA, USA, 1986. 5.2.1

[29] D. L. Parnas. Software aging. ICSE ’94, Los Alamitos, CA, USA.
IEEE Computer Society Press. 2.4
[30] B. C. Pierce. Types and programming languages. MIT press, 2002.
4.2

[5] J. Arnold and M. F. Kaashoek. KSplice: Automatic Rebootless Kernel
Updates. In EuroSys 2009, April 2009. 1

[31] S. Verdoolaege, G. Janssens, and M. Bruynooghe. Equivalence checking of static affine programs using widening to handle recurrences.
ACM Trans. Program. Lang. Syst., 34(3):11:1–11:35, Nov. 2012. 1

[6] N. Benton. Simple relational correctness proofs for static analyses and
program transformations. SIGPLAN Not., 39(1):14–25, Jan. 2004. 1
[7] D. Binkley, S. Horwitz, and T. Reps. The multi-procedure equivalence
theorem. Technical report, 1989. 1

[32] M. Zhang, K. Ogata, and K. Futatsugi. Formalization and verification
of behavioral correctness of dynamic software updates. Electronic
Notes in Theoretical Computer Science, 294:12 – 23, 2013. 1, 7

[8] S. Blazy and X. Leroy. Mechanized semantics for the clight subset of
the c language. Journal of Automated Reasoning, 43(3), 2009. 4.2
[9] T. Bloom and M. Day. Reconfiguration and module replacement in
argus: theory and practice. Software Engineering Journal, Mar 1993.
1, 7

A. Type system
Figure 19 shows an almost standard unsound and incomplete type
system. The type system is unsound because of three reasons, (a)
the possible value mismatch due to the subtype rule from hte type
Int to Long, (b) the implicit subtype between enumeration types
and the type Long allowed by our semantics and (c) the possible
array index out of bound. The type system is incomplete due to the
parameterized “other” expressions. The notation Dom(Γ) borrowed
from Cardelli [10] in rules Tvar1, Tvar2, Tlabels an Tfundecl refers
to the domain of the typing environment Γ, which are identifiers
bound to a type in Γ.

[10] L. Cardelli. Type systems. ACM Computing Surveys, 28(1):263–264,
1996. A
[11] R. Cartwright and M. Felleisen. The semantics of program dependence. SIGPLAN Not., 24(7):13–27, 1989. 1
[12] W. Dietz, P. Li, J. Regehr, and V. Adve. Understanding integer
overflow in c/c++. ICSE 2012, pages 760–770, 2012. 2
[13] B. Godlin and O. Strichman. Inference rules for proving the equivalence of recursive procedures. Acta Informatica, 45(6):403–439, 2008.
1, 7
[14] A. D. Gordon. Functional programming and input/output. Number 8.
Cambridge University Press, 1994. 4.1, 4.2

B. Syntactic definitions

[15] C. M. Hayden, S. Magill, M. Hicks, N. Foster, and J. S. Foster.
Specifying and verifying the correctness of dynamic software updates.
VSTTE ’12, pages 278–293, Jan. 2012. 1, 7

The syntax-directed definitions listed below make our argument
independent of existing program analysis partially.
Definition 33. (Idx(lval)) The used variables in index of a left
value lval, written Idx(lval), are listed as follows:

[16] M. Hicks. Dynamic Software Updating. PhD thesis, University of
Pennsylvania, August 2001. 1

1. Idx(id) = ∅;
2. Idx(id[n]) = ∅;
3. Idx(id1 [id2 ]) = {id2 };

[17] S. Horwitz, J. Prins, and T. Reps. On the adequacy of program
dependence graphs for representing programs. POPL ’88, pages 146–
157. ACM, 1988. 1, 7
[18] C. Karfa, K. Banerjee, D. Sarkar, and C. Mandal. Verification
of loop and arithmetic transformations of array-intensive behaviors.
Computer-Aided Design of Integrated Circuits and Systems, IEEE
Transactions on, 32(11):1787–1800, Nov 2013. 1

Definition 34. (Base(lval)) The base of a left value lval, written
Base(lval), is listed as follows:
1. Base(id) = {id};
2. Base(id[n]) = {id};
3. Base(id1 [id2 ]) = {id1 };

[19] J. Kramer and J. Magee. The evolving philosophers problem: dynamic
change management. Software Engineering, IEEE Transactions on,
16, Nov 1990. 1, 7

Definition 35. (Use(e)) The set of used variables in an expression
e, written Use(e), are listed as follows:

[20] S. Kundu, Z. Tatlock, and S. Lerner. Proving optimizations correct
using parameterized program equivalence. SIGPLAN Not., 44(6). 1

1. Use(lval) = Base(lval) ∪ Idx(lval);
2. Use(id == l) = {id};
3. Use(other) = Use(other) where function Use : other → {id}
is parameterized;

[21] D. Lacey, N. D. Jones, E. Van Wyk, and C. C. Frederiksen. Proving
correctness of compiler optimizations by temporal logic. SIGPLAN
Not., 37(1):283–294, Jan. 2002. ISSN 0362-1340. 1
[22] Y.-F. Lee and R.-C. Chang. Hotswapping linux kernel modules.
Journal of Systems and Software, 79(2):163–175, February 2006. 1

Definition 36. (Use(S)) The used variables in a sequence of statements S, written Use(S), are listed as follows:

[23] D. Lucanu and V. Rusu. Program equivalence by circular reasoning.
In Integrated Formal Methods, volume 7940 of Lecture Notes in Computer Science, pages 362–377. Springer Berlin Heidelberg, 2013. 1

1.
2.
3.
4.
5.
6.

[24] S. Magill, M. Hicks, S. Subramanian, and K. S. McKinley. Automating object transformations for dynamic software updating. SIGPLAN
Not., 47(10):265–280, Oct. 2012. 1, 7
[25] K. Makris. Whole-Program Dynamic Software Updating. PhD thesis,
Arizona State University, December 2009. 1, 3

67

Use(skip) = ∅;
Use(lval := e) = Use(e) ∪ Idx(lval);
Use(output e) = Use(e) ∪ {idIO };
Use(input id) = {idI , idIO };
Use(If (e) then {St } else {Sf }) = Use(e)∪Use(St )∪Use(Sf );
Use(whilehni (e){S ′ }) = Use(e) ∪ Use(S ′ );
2015/9/14

Definition 38. (s ∈ S) We say a statement s is in a sequence of
statements S of a program P , written s ∈ S, if one of the following
holds:

Γ⊢⋄

TInit

Γ⊢⋄

Γ → Γ′
(Tvar1)
Γ⊢⋄
V = V ′ , τ id
id ∈
/ Dom(Γ)
Γ, id : τ ⊢ ⋄
(Tprompt)
Γ⊢⋄
P mpt = {l1 : n1 , . . . , lk : nk }

1.
2.
3.
4.

(Tlabels)
Γ⊢⋄
k≥1
id ∈
/ Dom(Γ)
EN = EN ′ , enum id{l1 , ..., lk }
Γ, id : {l1 , ..., lk } ⊢ ⋄

We write s ∈
/ S if s ∈ S does not hold.
We show the definition of program size, which is based of our
induction proof.

pmpt ∈
/ Dom(Γ)

Γ, pmpt : {l1 : n1 , . . . , lk : nk } ⊢ ⋄
(Tvar2)
Γ⊢⋄
id ∈
/ Dom(Γ)
V = V ′ , τ id[n]
n>0

Definition 39. (size(S)) The program size of a statement sequence
S, written size(S), is listed as follows:

Γ, id : array(τ, n) ⊢ ⋄

Γ⊢τ

(Tint)
Γ⊢⋄
Γ ⊢ Int

(Tlong)
Γ⊢⋄
Γ ⊢ Long

1. size(“skip”) = size(“id := e”) = size(“id1 := call id2 (e∗ )”)
= size(“input id”) = size(“output e”) = 1;
2. size(“If(e) then {St } else {Sf }”) = 1 + size(St ) + size(Sf );
3. size(“while(e) {S ′ }”) = 1 + size(S ′ );
k
P
4. For k > 0, size(s1 ; ...; sk =
size(si );

(Tenum)
Γ ⊢ id : {l1 , ..., lk }
Γ ⊢ enum id

i=1

Γ⊢e:τ

(Topnd)

Γ, id : τ ⊢ id : τ
(Tarray1)
Γ ⊢ id : array(τ, n)
Γ ⊢ id′ : Long
Γ ⊢ id[id′ ] : τ
Γ⊢S
(Tassign)
Γ ⊢ lval : τ
Γ⊢e:τ
Γ ⊢ lval := e

(Tequiv)
Γ ⊢ id′ : {l1 , ..., l, ..., lk }
Γ ⊢ id : enum id′
Γ ⊢ (id == l) : Long

C. Properties of imported variables

(TSub)

Lemma C.1. Imp(S1 ; S2 , X) = Imp(S1 , Imp(S2 , X)).

Γ ⊢ e : Int
Γ ⊢ e : Long

Proof. Let statement sequence S2 = s1 ; s2 ; ...; sk for some k > 0.
The proof is by induction on k.

(Tarray2)
Γ ⊢ id : array(τ, n)
1≤k≤n
Γ ⊢ id[k] : τ

(Tinput)
Γ ⊢ id : τ
τ 6= pmpt
Γ ⊢ input id

(Tif)

(Toutput)
Γ⊢e:τ
Γ ⊢ output e

Corollary C.1. ∀i ∈ Z+ , Imp(S i+1 , X) = Imp(S, Imp(S i , X)).
This is by lemma C.1.
Lemma C.2. Imp(S, A ∪ B) = Imp(S, A) ∪ Imp(S, B).

(Tseq)
Γ ⊢ S1
Γ ⊢ S2
Γ ⊢ S1 ; S2

Proof. By structural induction on abstract syntax of statement sequence S.
Lemma C.3. For statement s = “while(e){S}” and a set of finite
number ofSvariables X such that X ∩ Def
S (s) 6= ∅, there is β > 0
such that 0≤i≤(β+1) Imp (S i , X) ⊆ 1≤j≤β Imp(S j , X).

(Twhile)

Γ ⊢ e : Long
Γ ⊢ S1
Γ ⊢ S2
Γ ⊢ If(e) then {S1 } else {S2 }

Γ ⊢ e : Long, Γ ⊢ S
Γ ⊢ while(e){S}

Proof. By contradiction against the fact that is finite number of
variables redefined in statement s.

Γ⊢P
(Tprog)
P mpt = {l1 : n1 , ..., lk : nk }
EN = enum id1 {l1 , ..., lr }, ..., enum idk {l′1 , ..., l′r }
Γ ⊢ enum idi , 1 ≤ i ≤ k
V = τ1′ id′1 , ..., τk′ id′k [n]
Γ ⊢ id′j : τj′ , 1 ≤ j ≤ k′ − 1
Γ ⊢ id′k : array(τk′ , n)
Γ ⊢ Sentry

D. Properties of expression evaluation
We wrap the two properties of expression evaluation, which is
based on the two properties of “other” expression evaluation. In
the following, we use the notation E ′ to expand the domain of the
expression meaning function E ′ : e → σ → (verror , {0, 1}).

Γ ⊢ P mpt; EN ; V ; Sentry

Lemma D.1. If every variable in Use(e) of an expression e has
the same value w.r.t two value stores, the expression e evaluates to
same value against the two value stores, (∀x ∈ Use(e) : σ1 (x) =
σ2 (x)) ⇒ (E ′ JeKσ1 = E ′ JeKσ2 ).

Figure 19: Typing rules

7. For k > 0, Use(s1 ; ...; sk+1 ) = Use(s1 ; ...; sk ) ∪ Use(sk+1 );

Proof. The proof is a case analysis of the expression e.

Definition 37. (Def(S)) The defined variables in a sequence of
statements S, written Def(S), are listed as follows:
1.
2.
3.
4.
5.
6.
7.

S = s;
If S = “If(e) then {St } else {Sf }”, (s ∈ St ) ∨ (s ∈ Sf );
If S = “while(e) {S ′ }”, s ∈ S ′ ;
For k > 0, if S = s1 ; ...; sk ; sk+1 , (s ∈ sk+1 ) ∨ (s ∈
s1 ; ...; sk );

1. e = lval;
There are further cases regarding lval.
(a) lval = id;
By definition, Use(e) = {id}. Besides, there is no integer
overflow in both evaluations. The lemma holds trivially.
(b) lval = id[n];
By definition, Use(e) = {id}. Because the array has fixed
size, by assumption, σ1 (id, n) = σ2 (id, n) or (id, n, ∗) ∈
/
σ1 , (id, n, ∗) ∈
/ σ2 . Besides, there is no integer overflow in
both evaluations. The lemma holds.

Def(skip) = ∅;
Def(id := e) = {id};
Def(input id) = {idI , idIO , id};
Def(output e) = {idIO };
Def(If (e) then {St } else {Sf }) = Def(St ) ∪ Def(Sf );
Def(whilehni (e){S}) = Def(S);
For k > 0, Def(s1 ; ...; sk+1 ) = Def(s1 ; ...; sk ) ∪ Def(sk+1 );

68

2015/9/14

(c) lval = id1 [id2 ];
By definition, Use(e) = {id1 , id2 }. By assumption, σ1 (id2 ) =
σ2 (id2 ) = n By similar argument to the case lval = id[n],
the lemma holds.
2. e = “id == l”;
By definition, Use(e) = {id}. W.l.o.g, id is a global variable.
By assumption, σ1 (id) = σ2 (id) = l′ . If l′ = l, by rule
Eq-T, (l′ == l, m(σ)) → (1, m). If l′ 6= l, by rule EqF, (l′ == l, m(σ)) → (0, m). Besides, there is no integer
overflow in both evaluations. The lemma holds.
3. e = other;
By definition, Use(e) = Use(e). By assumption, ∀x ∈
Use(e) : σ1 (x) = σ2 (x) ∨ σ1 (x) = σ2 (x). The lemma holds
by parameterized expression meaning function for “other” expression.

Lemma D.2. If every variable in Err(e) of an expression e has
same value w.r.t two pairs of (block, value store), ∀x ∈ Err(e) :
σ1 (x) = σ2 (x) then one of the following holds:
1. the expression evaluates to crash against the two value stores,
(E ′ JeKσ1 = (error, vof )) ∧ (E ′ JeKσ2 = (error, vof ));
2. the expression evaluates to no crash against the two pairs of
1
(block, value store) (E ′ JeKσ1 6= (error, vof
)) ∧ (E ′ JeKσ2 6=
2
(error, vof )).
Proof. The proof is a case analysis of the expression e.
1. e = lval;
There are further cases regarding lval.
(a) lval = id;
By definition, Err(e) = Idx(e) = ∅. By our semantic, the
evaluation of id never crash. Besides, there is no integer
overflow in both evaluations. The lemma holds.
(b) lval = id[n];
By definition, Err(e) = Idx(e) = ∅. Because the array id1
has a fixed array size, by assumption, either ((id1 , n, v1 ) ∈
σ1 ) ∧ ((id1 , n, v2 ) ∈ σ2 ) or ((id1 , n, v1 ) ∈
/ σ1 ) ∧
((id1 , n, v2 ) ∈
/ σ2 ). Besides, there is no integer overflow in
both evaluations. The lemma holds.
(c) lval = id1 [id2 ]
By definition, Err(e) = Idx(e) = {id2 }. By assumption,
σ1 (id2 ) = σ2 (id2 ) = n or σ1 (id2 ) = σ2 (id2 ) = n. By
similar argument to the case lval = id[n], the lemma holds.
2. e = “id == l”;
By definition, Err(e) = ∅. W.l.o.g, id is a global variable.
Let σ1 (id) = l1 , σ2 (id) = l2 . W.l.o.g., l1 = l and l2 6= l,
by rule Eq-T, (l1 == l, m(σ)) → (1, m) and, by rule EqF, (l2 == l, m(σ)) → (0, m). Besides, there is no integer
overflow in both evaluations. The lemma holds.
3. e = other;
By definition, Err(e) = Err(e). By assumption, ∀x ∈ Err(e) :
σ1 (x) = σ2 (x). The lemma holds by the property of parameterized expression meaning function for “other” expression.

With respect to Lemma D.1 and Lemma D.2, we extend semantic rule for expression evaluation as follows.

E. Properties of remaining execution
We assume that crash flag f = 0 in given execution state m(f).
Lemma E.1. (S1 , m) → (S1′ , m′ ) ⇒ (S1 ; S2 , m) → (S1′ ; S2 , m′ ).
69

(r, m) → (r ′ , m′ )
E ′ : e → σ → (verror × {0, 1})

EEval’

f=0
(e, m(f, σ)) → (E ′ JeKσ, m)

Figure 20: An extended SOS rule for expressions

Proof. The proof is by structural induction on abstract syntax of
S1 .
Case 1. S1 = “skip”.
By rule Seq, (skip; S2 , m) → (S2 , m) where m = m′ .
Case 2. S1 = “id := e”.
There are two subcases.
∗
Case 2.1. (e, m) → (v, m) for some value v.
By rule Assign,
(id := v, m) → (skip, m(σ[v/x])).
Then, by contextual (semantic) rule,
(id := v; S2 , m) → (skip; S2 , m(σ[v/x])).
∗
Case 2.2. (e, m) → (e′ , m(1/f)) for some expression e′ .
Then, by rule crash,
(id := e′ , m(1/f)) → (id := e′ , m(1/f)).
Then, by contextual rule,
(id := e′ ; S2 , m(1/f)) → (id := e′ ; S2 , m(1/f)).
Case 3. S1 = “output e”
Case 4. S1 = “input id”
By similar argument in Case 2, the lemma holds for case 3 and
4.
Case 5. S1 = “If (e) then {St } else {Sf }”.
Case 5.1. W.l.o.g., expression e in predicate of S1 evaluates to
∗
nonzero in state m, written (e, m) → (0, m).
By rule If-T, (If (0) then {St } else {Sf }, m) → (St , m).
By contextual (semantic) rule,
(If (0) then {St } else {Sf }; S2 , m) → (St ; S2 , m).
Case 5.2. Evaluation of expression e in predicate of S1 crashes,
∗
written (e, m) → (e′ , m(1/f)).
Then, by rule crash,
(If (e′ ) then {St } else {Sf }, m(1/f)) →
(If (e′ ) then {St } else {Sf }, m(1/f)).
Then, by contextual rule,
(If (e′ ) then {St } else {Sf }; S2 , m(1/f)) →
(If (e′ ) then {St } else {Sf }; S2 , m(1/f)).
Case 6. S1 = “whilehni (e) {S}”.
Case 6.1 When expression e in predicate of S1 evaluates to
∗
nonzero value, written (e, m) → (v, m) for some v 6= 0, then, by
rule Wh-T,
(whilehni (e){S}, m) → (S; whilehni (e){S}, m(mc [(k +
1)/n])) for some nonnegative integer k.
Then, by contextual rule,
(whilehni (e) {S}; S2 , m) →
(S; while hni (e) {S}; S2 , m(mc [(k + 1)/n])).
Case 6.2 When expression e in predicate of S1 evaluates to
∗
zero, written (e, m) → (0, m), then, by rule Wh-F,
(whilehni (e){S}, m) → (skip, m(mc [0/n])).
By contextual rule,
(whilehni (e) {S}; S2 , m) → (skip; S2 , m(mc [0/n])).
Case 6.3 Evaluation of expression e in predicate of S1 crashes,
∗
written (e, m) → (e′ , m).
By rule crash,
(whilehni (e′ ){S}, m(1/f)) → (whilehni (e′ ){S}, m(1/f)).
Then, by contextual rule,

2015/9/14

(whilehni (e′ ){S}; S2 , m(1/f)) →
(whilehni (e′ ){S}; S2 , m(1/f)).
∗

(id := e′ , m(1/f, σ)) → (id := e′ , m(1/f, σ)) where m′ =
m(1/f, σ).
Hence, σ ′ (x) = σ(x). Besides, x ∈
/ Def(id := e′ ) by definition.
Case 2. S = “ output e”.
Case 3. S = “ input id”.
By similar argument in case 1.
Case 4. S= “If (e) then {St } else {Sf }”.
Def (S) = Def (Sf ) ∪ Def (St ) by definition. Then x ∈
/
Def (Sf ) ∪ Def (St ).
There are two subcases.
Case 4.1 W.l.o.g., expression e in predicate of S evaluates to
∗
nonzero value, written (e, m) → (v, m) where v 6= 0.
Then by rule If-T, (If (v) then {St } else {Sf }, m(σ)) → (St , m(σ))
where m′ = m.
Therefore, σ ′ (x) = σ(x). By argument above, x ∈
/ Def (St ).
Case 4.2 Evaluation of expression e in predicate of S crashes,
∗
written (e, m) → (e′ , m(1/f)).
Then, by rule crash,
(If (e′ ) then {St } else {Sf }, m(1/f, σ)) →
(If (e′ ) then {St } else {Sf }, m(1/f, σ)) where m′ = m(1/f, σ).
Therefore, σ ′ (x) = σ(x).
Besides, x ∈
/ Def (If (e′ ) then {St } else {Sf }) = Def (Sf ) ∪
Def (St ).
Case 5. S = “whilehni (e) {S ′ }”.
Def (S) = Def (S ′ ) by definition. Then x ∈
/ Def (S ′ ) by
condition x ∈
/ Def (S).
There are subcases.
Case 5.1 Expression e evaluates to nonzero value, written
∗
(e, m) → (v, m) where v 6= 0.
By rule Wh-T, (whilehni (v) {S ′ }, m(σ)) →
(S ′ ; whilehni (e) {S ′ }, m(mc [(k + 1)/n]), σ) for some nonnegative integer k.
Let m′ = m(mc [(k + 1)/n], σ). Then σ ′ (x) = σ(x).
Besides, x ∈
/ Def (S ′ ; whilehni (e) {S ′ }) = Def (S ′ ) ∪
Def (S), because x ∈
/ Def (S ′ ).
Case 5.2 Expression e evaluates to zero in state m, written
∗
(e, m) → (0, m).
By rule Wh-F,
(whilehni (0) {S ′ }, m(σ)) → (skip, m(mc [0/n], σ)) where
′
m = m(mc [0/n], σ).
Therefore, σ ′ (x) = σ(x). Besides, x ∈
/ Def (skip).
∗
Case 5.3 Evaluation of expression e crashes, written (e, m) →
′
(e , m(1/f)).
By rule crash
(whilehni (e′ ) {S ′ }, m(1/f, σ)) →
(whilehni (e′ ) {S ′ }, m(1/f, σ)) where m′ = m(1/f, σ).
Therefore, σ ′ (x) = σ(x). Besides, x ∈
/ Def(whilehni (e′ ) {S ′ })
′
= Def (S ) by definition.
Case 6. S = S1 ; S2 .
By argument in Case 1 to 5, after one step execution ((S1 , m(σ)) →
(S ′ , m′ (σ))), σ ′ (x) = σ(x).
By contextual rule, the lemma holds.

∗

Lemma E.2. (S1 , m) → (S1′ , m′ ) ⇒ (S1 ; S2 , m) → (S1′ ; S2 , m′ ).
k

Proof. By induction on number of steps k in execution (S1 , m) →
(S1′ , m′ ).
Base case. k = 0 and 1.
By definition,
0
0
(S1 , m) → (S1 , m), and (S1 ; S2 , m) → (S1 ; S2 , m).
By lemma E.1,
(S1 , m) → (S1′ , m′ ) ⇒ (S1 ; S2 , m) → (S1′ ; S2 , m′ ).
Induction step.
The induction hypothesis IH is that, for k ≥ 1,
k
k
(S1 , m) → (S1′ , m′ ) ⇒ (S1 ; S2 , m) → (S1′ ; S2 , m′ ).
Then we show that,
k+1
k+1
(S1 , m) → (S1′ , m′ ) ⇒ (S1 ; S2 , m) → (S1′ ; S2 , m′ ).
We decompose the k+1 step execution into
k
(S1 , m) → (S1′′ , m′′ ) → (S1′ , m′ ).
By lemma E.1,
(S1 ; S2 , m) → (S1′′ ; S2 , m′′ ).
Next, by IH,
k
(S1′′ ; S2 , m′′ ) → (S1′ ; S2 , m′ ).
∗

∗

Corollary E.1. (S1 , m) → (skip, m′ ) ⇒ (S1 ; S2 , m) →
(S2 , m′ ).
Proof. By lemma E.2,
∗
∗
(S1 , m) → (skip, m′ ) ⇒ (S1 ; S2 , m) → (skip; S2 , m′ ).
Then, by rule Seq,
(skip; S2 , m′ ) → (S2 , m′ ).
Lemma E.3. If one statement s is not in S, then, after one step
of execution (S, m) → (S ′ , m′ ), s is not in the S ′ , (s ∈
/ S) ∧
((S, m) → (S ′ , m′ )) ⇒ (s ∈
/ S ′ ).
Proof. By induction on abstract syntax of S.
Lemma E.4. If one statement s is not in S, then, after the execution
∗
∗
(S, m) → (S ′ , m′ ), s is not in the S ′ , (s ∈
/ S) ∧ ((S, m) →
′
′
′
(S , m )) ⇒ (s ∈
/ S ).
Proof. By induction on the number k of the steps in the execution
k
(S, m) → (S ′ , m′ ).
Lemma E.5. If a variable x is not defined in a statement sequence
S, then, after one step execution of S, the value of x is not redefined,
(x ∈
/ Def(S)) ∧ ((S, m(σ)) → (S ′ , m′ (σ ′ ))) ⇒ (x ∈
/ Def(S ′ )) ∧
′
(σ (x) = σ(x))
Proof. By structural induction on abstract syntax of statement sequence S, we show the lemma holds.
Case 1. S = “id := e”.
By definition, Def(S) = {id}. Then id 6= x by condition that
x∈
/ Def (S).
Then there are two subcases.
Case 1.1 Expression e evaluates to some value v, written
∗
(e, m) → (v, m).
Then, by rule Assign, (S, m(σ)) → (skip, m(σ[v/id])) where
m′ = m(σ[v/id]).
Hence, σ ′ (x) = σ(x). Besides, x ∈
/ Def (skip) by definition.
∗
Case 1.2 Evaluation of expression e crashes, written (e, m) →
′
(e , m(1/f)).
Then, by rule crash,

Corollary E.2. If a variable x is not defined in a statement sequence S, then, after an execution of S, the value of x is not re∗
defined, (x ∈
/ Def(S) ∧ (S, m(σ)) → (S ′ , m′ (σ ′ )) ⇒ (x ∈
/
′
′
Def(S )) ∧ σ (x) = σ(x)).
k

Proof. Let (S, m) → (S ′ , m′ ). The proof is by induction on k
using lemma E.5.

70

2015/9/14

(If (e′ ) then {St } else {Sf }, m(1/f)) →
(If (e′ ) then {St } else {Sf }, m(1/f)).
By parameterized type rule TExpr, Γ 6⊢ e′ . By type rule Tif,
Γ 6⊢ If (e′ ) then {St } else {Sf }.
Because Γ ⊢ s, then s 6= If (e′ ) then {St } else {Sf }.
Besides, s ∈
/ St , s ∈
/ Sf by condition. Therefore, s ∈
/
If (e′ ) then {St } else {Sf }.
Case 5. S = “whilehni (e) {S ′ }”.
s∈
/ S ′ by definition. There are subcases.
Case 5.1 Expression e evaluates to nonzero value, written
∗
(e, m) → (v, m) where v 6= 0.
By rule Wh-T, (whilehni (v) {S ′ }, m) →
(S ′ ; whilehni (e) {S ′ }, m(mc [(k + 1)/n])) for some nonnegative integer k.
Then s ∈
/ S ′ ; whilehni (e) {S ′ } by definition.
Case 5.2 Expression e evaluates to zero in state m, written
∗
(e, m) → (0, m).
By rule Wh-F,
(whilehni (0) {S ′ }, m) → (skip, m(mc [0/n])).
Therefore, s ∈
/ skip.
∗
Case 5.3 Evaluation of expression e crashes, written (e, m) →
′
(e , m(1/f)).
By rule crash,
(whilehni (e′ ) {S ′ }, m(1/f)) →
(whilehni (e′ ) {S ′ }, m(1/f)).
Then, by type rule Twhile, Γ 6⊢ whilehni (e′ ) {S ′ }. Because
Γ ⊢ s, then s 6= whilehni (e′ ) {S ′ }.
Besides s ∈
/ S ′ , then s ∈
/ whilehni (e′ ) {S ′ } by definition.
Case 6. S = S1 ; S2 .
By argument in Case 1 to 5, after one step execution (S1 , m) →
(S ′ , m′ ), s ∈
/ S′.
By contextual rule, (S1 ; S2 , m) → (S ′ ; S2 , m′ ).
By definition, s ∈
/ S2 .
Then, by definition, s ∈
/ S ′ ; S2

Based on Corollary E.2, we extend the result to array variable
elements.
Corollary E.3. If an element in an array variable x[i] is not defined in a statement sequence S in a program P = EN ; V ; Sentry ,
then, after an execution of S, the value of x[i] is not redefined,
∗
(x ∈
/ Def(S)) ∧ ((x, i, ∗) ∈ σ) ∧ (S, m(σ)) → (S ′ , m′ (σ ′ )) ⇒
′
′
(x ∈
/ Def(S )) ∧ σ (x, i) = σ(x, i)).
Lemma E.6. If all of the following hold:
1. There is no loop of label n in statements S, “whilehni (e){S ′ }” ∈
/
S;
2. The crash flag is not set, f = 0;
3. There is an entry n in loop counter, (n, ∗) ∈ loopc ;
4. There is one step execution, (S, m(f, loopc )) → (S ′ , m′ (loop′c ));

then, loop′c (n) = loopc (n).

Proof. The proof is by induction on abstract syntax of S, similar to
that for lemma E.5.
Corollary E.4. If all of the following hold:
1. There is no loop of label n in statements S, “whilehni (e){S ′ }” ∈
/
S;
2. The crash flag is not set, f = 0;
3. There is an entry n in loop counter, (n, ∗) ∈ loopc ;
4. There is multiple steps execution of stack depth d = 0,
∗
(S, m(f, loopc )) → (S ′ , m′ (loop′c ));

then, loop′c (n) = loopc (n).

Lemma E.7. If all of the following hold:
1. A non-skip statement s is not in S, (s 6= skip) ∧ (s ∈
/ S);
2. There is one step execution of stack depth d = 0, (S, m) →
(S ′ , m′ ),
then, s ∈
/ S′.

Lemma E.8. Let s = “whilehni (e) {S ′′ }”. If both of the following
hold:

Proof. By structural induction on abstract syntax of statement sequence S, we show the lemma holds.
Case 1. S = “id := e”.
Then there are two subcases.
Case 1.1 Expression e evaluates to some value v, written
∗
(e, m) → (v, m).
Then, by rule Assign, (S, m) → (skip, m(σ[v/id])).
Hence, s ∈
/ skip by definition.
∗
Case 1.2 Evaluation of expression e crashes, written (e, m) →
′
(e , m(1/f)).
By parameterized type rule TExpr, Γ 6⊢ e′ . Then, by type rule
TAssign, Γ 6⊢ id := e′ .
Then, by rule crash,
(id := e′ , m(1/f)) → (id := e′ , m(1/f)).
Because Γ ⊢ s, then s 6= id := e′ . Hence, s ∈
/ id := e′ by
definition.
Case 2. S = “ output e”.
Case 3. S = “ input id”.
By similar argument in case 1.
Case 4. S= “If (e) then {St } else {Sf }”.
s∈
/ Sf , s ∈
/ St by definition. There are two subcases.
Case 4.1 W.l.o.g., expression e in predicate of S evaluates to
∗
nonzero value, written (e, m) → (v, m) where v 6= 0.
Then by rule If-T, (If (v) then {St } else {Sf }, m) → (St , m).
Therefore, s ∈
/ St .
Case 4.2 Evaluation of expression e in predicate of S crashes,
∗
written (e, m) → (e′ , m(1/f)).
Then, by rule crash,

• s ∈ S;
• (S, m(loopc )) → (S ′ , m′ (loop′c ));

then one of the following holds:
1. The loop counter of label n is incremented by one, loop′c (n) −
loopc (n) = 1;
2. There is no entry for label n in loop counter, (n, v) ∈
/ loop′c ;
′
3. The loop counter of label n is not changed, loopc (n)−loopc (n)
= 0;
Proof. Let S = s′ ; S ′′ . The proof is by induction on abstract syntax
of s′ .

71

2015/9/14


Byzantine and Multi-writer K-quorums
Amitanand S. Aiyer , Lorenzo Alvisi , and Rida A. Bazzi
Department of Computer Sciences, The University of Texas at Austin anand,lorenzo @cs.utexas.edu Computer Science and Engineering Department, Arizona State University bazzi@asu.edu

Abstract. Single-writer -quorum protocols achieve high availability without incurring the risk of read operations returning arbitrarily stale values: in particular, they guarantee that, even in the presence of an adversarial scheduler, any read operation will return the value written by one of the last writes. In this paper, we expand our understanding of -quorums in two directions: rst, we present a single-writer -quorum protocol that tolerates Byzantine server failures; second, we extend the single-writer -quorum protocol to a multi-writer solution that applies to both the benign and Byzantine cases. For a system with writers, we prove a lower bound of on the staleness of any multi-writer protocol built over a single-writer -quorum system and propose a multi-writer protocol that provides an almost matching staleness bound of .

1 Introduction
Quorum systems have been extensively studied, with applications that include mutual exclusion, coordination, and data replication in distributed systems [1­4]. systems [1­ 4]. A traditional, or strict, quorum system is simply a collection of servers organized in sets called quorums. Quorums are accessed either to write a new value to a write quorum or to read the values stored in a read quorum: in strict quorums, any read quorum intersects with a write quorum. Important quality measures of quorum systems are availability, fault tolerance, load, and quorum size. lower size have measures are conicting in strict quorum systems [5]. For instance, the majority quorum system provides the highest availability of all strict quorum systems when the failure probability of individual nodes is lower than 0.5, but it also suffers from high load and large quorum size--and this tension holds true in general [6]. When the failure probability of individual nodes is higher than 0.5, the quorum system with highest availability is the singleton, in which one node handles all requests in the system. Probabilistic [7] and signed [8] quorum systems have been proposed to achieve high availability while guaranteeing system consistency (non-empty intersection of
This work was supported in part by NSF Cybertrust award 0430510, NSF award CNS 0509338, and a grant from the Texas Advanced Technology Program.

quorums) with high probability. These probabilistic constructions offer much better availability than the majority system at the cost of providing only probabilistic guarantees on quorum intersection. If a probabilistic quorum system is used to implement a distributed register with read and write operations, then, with high probability, a read operation will return the value most recently written. To achieve a high probability of quorum intersection, probabilistic constructions assume, either implicitly (probabilistic quorum systems [7]) or explicitly (signed quorum systems [8]), that the network scheduler is not adversarial. If the scheduler is adversarial, both constructions can return arbitrarily old values, even if servers fail only by crashing. If instead servers can also be subject to Byzantine failures, the situation is a bit more complicated. Signed quorum systems are simply not dened under these circumstances; probabilistic Byzantine quorum systems [7] must instead be congured to prevent read operations from returning values fabricated by Byzantine servers. Note that returning a fabricated value can be much more problematic than returning an arbitrarily old value, especially if readers are required to write back what they read (as it is common to achieve strong consistency guarantees): in this case, the system can become contaminated and quickly loose its consistency guarantees 3. Fortunately, the parameters of probabilistic quorums systems can be chosen to eliminate the possibility of contamination; unfortunately, doing so results in a loss of all the gains made in availability. -quorum systems, which we have recently introduced [9], guarantee that a read operation will always return one of the last written values ­ even if the scheduler is adversarial. If the scheduler is not adversarial and read quorums are chosen randomly, as is the case with probabilistic systems, -quorums can guarantee a high probability of intersection with the quorum used by the latest write. In a sense, -quorums have some of the best features of both strict systems and probabilistic constructions and they can be thought of as a middle ground between them. Like probabilistic constructions, they achieve high availability by performing their writes to small quorums, (called partial-write-quorums), and therefore weaken the intersection property of traditional strict quorum systems; unlike probabilistic constructions, however, -quorums can still provide deterministic intersection guarantees: in particular, they require the set of servers contacted during consecutive writes--the union of the corresponding partial write quorums--to form a traditional strict write quorum. Using this combination, -quorum systems can bound the staleness of the value returned by a read, even in the presence of an adversarial scheduler: a read operations that contacts a random read quorum of servers is guaranteed to return one of the values written by the last preceding writes; furthermore, during periods of synchrony the returned value will, with high probability, be the one written by the last preceding write. In the absence of an adversarial scheduler, probabilistic systems can have higher availability than -quorum systems. -quorums make a tradeoff between safety and liveness. By allowing for lower availability than probabilistic systems, they guaran3

This is not a problem if the returned values are simply old values because in that case timestamps can be used to prevent old values from overwriting newer values. Timestamps cannot be used with fabricated values because the timestamps of the fabricated values can themselves be fabricated.

tee a bound on the staleness of returned values even in the presence of an adversarial scheduler. In the absence of an adversarial scheduler, -quorum systems have higher availability than strict quorum systems when the frequency of write operations is not high (in a sense well dened in [9]). In the same paper, we also propose -consistency semantics and provide a single-writer implementation of -atomic registers over servers subject to crash failures. Our previous paper left several important questions unanswered--in particular, it did not discuss how to handle Byzantine failures, nor how to provide a multi-writer/multireader construction with -atomic semantics. The rst question is particularly important in light of the contamination problem that can affect probabilistic Byzantine quorum systems. Answering these questions is harder than in strict quorum systems because the basic guarantees provided by -quorum systems are relatively weak and hard to leverage. For example, in the presence of multiple writers it is hard for any single writer to guarantee that consecutive writes (possibly performed by other writers) will constitute a quorum: because of the weaker consistency semantics, a writer cannot accurately determine the set of servers to which the other writers are writing. In this paper, we answer both questions. We begin by showing a protocol that implements single-writer -atomic semantics and tolerates Byzantine servers and any number of crash-and-recover failures as long as read and write quorums intersect in at servers. Like its crash-only counterpart, the protocol can provide better least availability than strict quorum systems when writes are infrequent, and unlike probabilistic solutions, can bound the staleness of the values returned by read operations. Byzantine faults add another dimension to the comparison with probabilistic solutions: the cost, in terms of loss of availability, of preventing reads from returning a value that has never been written by a client, but has instead been generated by Byzantine servers out of thin air. We show that, for equally sized quorums, this cost is considerably higher for probabilistic constructions than for -quorum systems. We then investigate the question of -atomic semantics in a multi-writer/multireader setting by asking whether it is possible to obtain a multi-writer solution by using a single writer solution as a building block--that is, by restricting read and write operations in the multi-writer case to use the read and write partial quorums of the single writer solution. This approach appears attractive, because, if successful, would result in a multi-writer system with availability very close to that of a single writer system. We rst show a lower bound on the price that any such system must pay in terms of consistency: we prove that no -writer protocol based on a solution that achieves atomic semantics in the single writer case can provide better than atomic semantics. We then present an -writer protocol that provides -atomic semantics, using a construction that, through a clever use of vector timestamps, allows readers and writers to disregard excessively old values.

2 System Model
We consider a system of servers. Each server (or node) can crash and recover. We assume that servers have access to a stable storage mechanism that is persistent across crashes. We place no bound on the number of non-Byzantine failures and, when considering Byzantine faults, we assume that there are no more than Byzantine servers--all remaining servers can crash and recover.

Network model We consider an asynchronous network model that may indenitely delay, or drop, messages. We require that the protocols provide staleness guarantees irrespective of network behavior. For purposes of availability, we assume there will be periods of synchrony, during which, if enough servers are available, operations execute in a timely manner. Access Model A read or write operation needs to access a read or a (partial) write quorum in order to terminate successfully. If no quorum is available the operation has two options: it can either abort or remain pending until enough servers become available (not necessarily all at the same time). The operation can abort unless it has already taken actions that can potentially become visible to other clients. Clients operations may have timeliness constraints. This does not contradict the asynchrony assumption we make about the network but simply reects the expectation that operations should execute in a timely manner if the system is to be considered available. A client considers any operation that does not complete in time to have failed, independent of whether these operations abort or eventually complete. Note that an operation may be aborted and fail before being actually executed if the operation remains locally queued for too long after being issued. We assume for simplicity that clients do not crash in between operations, although our protocols can be extended to tolerate client crash and recovery by incorporating a logging protocol. Finally, we assume that writes are blocking. In other words, a writer will not start the next write until the current write has nished. While this assumption is not overly restrictive, we need to make it for a technical reason, as our protocols require a write operation to know exactly where the previously written values have been written to. Availability Informally, a system is available at time if operations started at execute in a timely manner. Consider an execution in a given time interval (possibly innite) in which a number of operations are started. The system's availability for execution is the ratio of the number of operations that complete in a timely manner in to the total number of operations in . If the number of operations is innite, then the system's availability is the limit of the ratio, if it exists. The read and write access patterns are mappings from the natural numbers to the set of positive real numbers (denoting the duration between the requests). The failure pattern of a given node is a mapping from the positive real numbers (denoting global time) to ; the system's failure pattern is a set of failure patterns, one for each node. Given probability distributions on the access patterns (read or write) and failure patterns, the system's availability is the expected availability for all pairs of access patterns and failure patterns. For the purposes of estimating availability, we assume that nodes crash and recover independently, with mean time to recover (MTTR) and mean time between failures (MTBF) . We also assume the periods between two consecutive reads or writes to be random variables with means MTBR and MTBW respectively and that MTBW is large compared to MTBF; in other words, writes are infrequent. We dene the system's availability in periods in which the network is responsive; i.e. in periods in which the roundtrip delay is negligible compared to MTBF and MTTR. In other words, the

availability we are interested in depends on whether nodes are up or down, and not on how slow is the network: indeed, in the presence of an adversarial network scheduler measuring availability becomes meaningless, since the scheduler could always cause it to be equal to zero. We assume that the time allowed for successful completion of an operation is negligible compared to MTBF and MTTR. Relaxed consistency semantics The semantics of shared objects that are implemented with quorum systems can be classied as safe, regular or atomic [10]. For applications that can tolerate some staleness, these notions of consistency are too strong and one can use dene relaxed consistency semantics as follows [9]: -safe: A read that does not overlap with a write returns the result of one of the latest completed writes. The result of a read overlapping a write is unspecied. 2. -regular: A read that does not overlap with a write returns the result of one of the latest completed writes. A read that overlaps with a write returns either the result of one of the latest completed writes or the eventual result of one of the overlapping writes. 3. -atomic: A read operation returns one of the values written by the last preceding writes in an order consistent with real time (assuming there are initial writes with the same initial value). 1.

3 K-quorums for Byzantine Faults
We dene a -quorum construction that tolerates Byzantine servers, while providing -atomic semantics, as a triple , , where is the set of write quorums, is the set of read quorums, and is a staleness parameter such that, for any , and , and . Server side protocol Figure 1 shows the server-side protocol. Each server maintains in the structure current data information about the last write the server knows of, as well writes that preceded it. READ REQUEST messages are handled using as the a "listeners" pattern [11]. The sender is added to 's Reading set, which contains the identities of the clients with active read operations at . A read operation is active at from when receives 's READ REQUEST to when it receives the corresponding STOP READ. On receipt of a WRITE message, acknowledges the writer. Then, if the received information is more recent than the one stored in current data, updates current data and forwards the update to all the clients in Reading; otherwise, it does nothing. Writer's protocol Figure 2 shows the client-side write protocol. Each write operation affects only a small set of servers, called a partial write quorum, chosen by the writer so that the set of its last partial write quorums forms a complete write quorum. The information sent to the servers contains not just a new value and timestamp, but also additional data that will help readers distinguish legitimate updates from values fabricated by Byzantine servers. Specically, the writer sends to each server in the partial write quorum, tuples--one for each of its last writes. The tuple for the -th of these writes includes: i) the value ; ii) the corresponding timestamp ts ; iii) the set of servers that were not written to in the last writes preceding ; and iv) a hash of the tuples writes preceding . The write ends once the set of servers from which the of the

writer has received an acknowledgment during the last writes forms a complete write quorum 4. Thus, the value, timestamp, , and hash information for write are not only written to 's partial write quorum, but will also be written to the partial write quorums used for the next writes. By the end of these writes this information will be written to a complete write quorum which is guaranteed to intersect any read quorum in at least servers. Reader's protocol The reader contacts a read quorum of servers and collects from each of them the tuples they are storing. The goal of the read operation is twofold: rst, to identify a tuple representing one of the last writes, call it , and return to the reader the corresponding value ; second, to write back to an appropriate partial write quorum tuples representing the writes (one comprised of servers not in ) both and the that preceded --this second step is necessary to achieve -atomicity. The read protocol computes three sets based on the received tuples. The Valid set contains, of the most recent tuples returned by each server in the read quorum, only those that are also returned by at least other servers. The tuples in this set are legitimate: they cannot have been fabricated by Byzantine servers. The Consistent set also contains a subset of the most recent tuples returned by each server in the read quorum. For each tuple in this set, the reader has veried that the hash of the preceding tuples returned by is equal to the value of stored in . The Fresh set contains the most recent tuples that come from distinct servers. correct Since a complete write quorum intersects a read quorum in at least servers, legitimate tuples in this set can only correspond to recent (i.e. not older than latest) writes. The intersection of these three sets includes only legitimate and recent tuples that can be safely written back, together with the tuples that precede them, to any appropriate partial write quorum. The reader can choose any of the tuples in this intersection: to minimize staleness, it is convenient to choose the one with the highest timestamp. 3.1 Protocol Correctness We rst prove the read protocol for single-writer Byzantine -quorums, shown in Figure 3, only returns values that are : ­ actually written by the writer (as opposed to an arbitrary value generated by a Byzantine server), and ­ are not more than writes old. Lemma 1. If the algorithm, in Figure 3 returns a value, , then the writer must have written . Proof: The algorithm returns a value, Tuple[ ], only if it belongs to ] to be present in Valid, the latest of the Valid Consistent. For Tuple[
4

Byzantine servers may never respond. The writer can address this problem by simply contacting extra nodes for each write while still only waiting for a partial quorum of replies. For simplicity, we abstract from these details in giving the protocol's pseudocode.

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19

static Reading = static c u r r e n t d a t a [ 1 . . k ] ; while ( tr u e ) ( msg , s e n d e r ) = r e c i e v e M e s s a g e ( ) ; i f ( msg i n s t a n c e o f READ REQUEST) Reading ; send c u r r e n t d a t a to sender . e l s e i f ( msg i n s t a n c e o f STOP READ ) Reading = Reading ; e l s e i f ( msg i n s t a n c e o f WRITE ) / / s a y msg i s WRITE if ( current data [1]. ts ) current data [1.. k ] = ; s e n d ACK( ) to sender ; f o r w a r d c u r r e n t d a t a t o a l l i n Reading . else s e n d ACK( ) to sender ;

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23

static := 0; static T u p l e [ ] ; void Write ( v a l u e v ) begin := ; = hash ( Tuple [ ] ); / / E i s t h e s e t o f s e r v e r s NOT u s e d f o r t h e previous writes

Tuple [ ] = d e le t e Tuple [ Find a s e t

; ] to save space , such t h a t :

s e n d WRITE se rve rs in

to a l l .

/ / wait f o r acknowledgements do recv until ( return end from s e r v )

Fig. 1. K-quorum protocol for non-Byzantine servers.

Fig. 2. K-quorum write protocol tolerating up to Byzantine servers.

values ­ Tuple[ts] ­ has to be reported by at least different servers. Since at least one of these servers is correct, it follows that Tuple[ts] was written by the writer. Moreover, since Tuple[ ] also belongs to Consistent, the the hash ]). Therefore the history in Tuple[ts] has to matches hash( Tuple[ of the previous writes ­ Tuple[ ]­ is also correct and should have been written by the writer. Lemma 2. The set Fresh never contains a value that is more than writes old. Proof: The intersection between a read and a write quorum consists of at least servers. Hence, among the servers responding there are at least servers who have "seen" one of the latest writes. At least of these are correct and have a timestamp greater than or equal to the -th latest write that occurred before the read has begun. Since the timestamp at a correct server monotonically increases, the correct servers in the intersection will never return a value that is more than writes old. correct servers who never report a value more than Since there are at least writes old. The latest values received from different servers, Fresh, will never contain a value that is more than writes old. Theorem 1. The single-writer Byzantine -quorum read protocol in Figure 3 never returns a value that is has not been written by the writer. Proof: Follows from Lemma 1 Theorem 2. The single-writer Byzantine -quorum read protocol in Figure 3 never returns a value that is more than -writes old Proof: The read in Figure 3 only returns a value that belongs to . From lemma 2, we know that the set Fresh can never contain a value that is

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50

/ / protocol for a reader r e c e i v e d [ ] / / s t o r e s t h e r e s p o n s e s from s e r v e r s CandidateValues / / holds the s e t of c a n d i d a t e values Read ( ) begin c h o o s e a r e a d quorum R . s e n d READ REQUEST t o s e r v e r s i n R . received [ i ] = null , CandidateValues = / / r e c e i v e v a l u e s from a l l t h e s e r v e r s i n R while ( ); begin r e c e i v e Tuple [ ] from s e r v e r s ; r e c e i v e d [ s ] = Tuple [ ]; i f ( i s V a l i d ( Tuple [ ] ) ) add T u p l e [ ] to the s et CandidateValues end / / t r y to choose a value / / i f u n s u c c e s s f u l , w a i t f o r more r e s p o n s e s . = LargestTimestamp ( r e c e i v e d ) ; tryChoosing ( ) ; while ( value chosen == n u ll ) begin r e c e i v e Tuple [ if ( ) r e c e i v e d [ s ] = Tuple [ tryChoosing ( ) ; end s e n d STOP READ t o s e r v e r s i n R . / / w r i t e back t h e c h o s e n v a l u e t o a p a r t i a l w r i t e quorum F i n d a p a r t i a l w r i t e quorum , PW, s u i t a b l e f o r v a l u e c h o s e n . s e n d WRITE t o PW w a i t f o r a c k s from PW return end value chosen

] from s e r v e r s ; ];

void tryChoosing ( ) begin ( 1 ) Fresh = Tuple [ e nt r ie s in ( 2 ) Valid = Tuple [ servers (3) Consistent = Tuple [ hash ( Tuple [ ( 4 ) if ( value chosen = end

] i s one o f t h e 2 f + 1 l a r g e s t time stamped r e c e i v e d from d i f f e r e n t s e r v e r s ] Tuple [ ] occurs in the responses of a t l e a s t ] ] ) ) , with the l a r g e s t timestamp . t h e hash , h , i n T u p l e [ ] matches

Fig. 3. K-quorum read protocol tolerating up to

Byzantine servers.

more than writes old. Hence, a read will never return a value that is more than writes old. In an asynchronous environment where there is no bound on the number of nodes failing no protocol can provide liveness guarantees always. If the network is behaving asynchronously, or if the required number of servers are not available then our protocols will just stall until the systems comes to a good conguration. We will now argue that if the required number of servers are accessible, and the network behaves synchronously then our protocols will eventually terminate. Theorem 3. If the network behaves synchronously and all non-Byzantine nodes recover and stay accessible, then the Byzantine -quorum protocol for the writer in Figure 2 eventually terminates Proof: If network is synchronous, and the non-Byzantine nodes recover, then the writer will be able to get nd an accessible partial-write-quorum. On receiving the acknowledgements from all the servers in the partial-write-quorum, the writer terminates.

Theorem 4. If the network behaves synchronously and all non-Byzantine nodes recover and stay accessible, then the Byzantine -quorum protocol for the reader in Figure 3 eventually terminates Proof: New values from a server are allowed to overwrite old values only as long as the . Therefore values cannot get overwritten time stamp of the new value is indenitely. : say Consider the situation, after the writer completes the latest write before 5 . When this happens all correct servers in the intersection of the read and write quosuch that . The rum will have a timestamp correct servers will forward the values and, these values will not be overwritten by any other value 6 . Since the intersection between a read and a write quorum contains at least correct servers, eventually the reader will receive at least values that have their timestamp in the range . Consider the -th largest timestamped value, , received from the correct servers. is reported by a correct server, so its hashes match and will be present in Consistent. Since there are no more than faulty servers, who may report higher timestamps, will be present in . Also, since all the highest timestamped , it follows that values from correct servers lie in the range the -th value from a correct server will be contained in the history of the rst highest timestamped values from correct servers. Hence is also present in . Therefore tryChoosing will set to a non-null value and the algorithm will terminate. K-Atomic Semantics To prove that the protocols achieve -atomic semantics, we show a linearized schedule of reads and writes such that every read returns one of the previously written values. We dene Definition 1. Written-time: Let written-time denote the global time instance, when a value that is being written reaches a partial-write-quorum. We will order the reads and writes in a manner similar to [9]. ­ All writes are ordered as if they instantaneously take place at their written-time. , which was written at time-stamp , can ­ A read which returns a value be scheduled any time between 1. The written-time, of the value returned, . write, . i.e. before 2. and, before the written-time of the next . It is easy to see that, such an ordering satises the requirements of k-atomic semantics. We need to show that such a ordering can be done in a manner consistent with local history.
5

6

If the writer does not write a value with a timestamp , then would be the can be taken as . timestamp of the last write written. Otherwise if then writer has not written any value with a time stamp , so , then the values do not these values never get overwritten. Otherwise, if . get overwritten because we discard values with timestamps

The scheduling of writes is trivial, because written-time of a write occurs between the time a write has begun and before the write ends. We now show, by contradiction, that reads can also be scheduled. Assume, if possible, that the read interval does not overlap with the interval . There are two cases: 1. Read nishes before : This scenario is not possible, because a read has to writeback the value. Therefore a read can end only after the written-time of the value it returns. 2. Read begins after : From Lemma 2, any read that starts after cannot return a value as old as , which is a contradiction. 3.2 Comparison to Probabilistic Quorum Systems In the Byzantine version of probabilistic quorum systems-- -masking quorum systems [7]--write operations remain virtually unchanged: values are simply written to a write quorum chosen according to a given access strategy. Read operations contact a read quorum, also chosen according to the access strategy, and return the highest timestamped value that is reported by more than servers, where is a safety parameter7 . Choosing any value of lower than can be hazardous as, under these circumstances, read operations may return a value that was never written by a client, but instead fabricated by Byzantine nodes. While the probability of an individual read operation returning a fabricated value can be low, if enough reads occur in the system, the probability that one of them will do so becomes signicant, even in the absence of an adversarial scheduler. Byzantine -quorums are immune from such dangers: read operations may return slightly stale values, but never fabricated values. This property allows for the safe use of write backs to achieve stronger consistency guarantees. Availability Although it is possible to tune probabilistic Byzantine quorum systems so that they never return fabricated values, such a choice of by choosing cannot guarantee that the read availability always increases with : if , then read availability actually tends to as increases, because even a reader able to contact a read-quorum is highly unlikely to receive at least identical responses [7]. To ensure identical responses in a read quorum, that, with high probability, there are at least probabilistic Byzantine quorum systems would have to choose large quorum sets-- requiring the size of the quorum to be signicantly larger than . Thus, if the number of Byzantine failures is large, then the quorum size for probabilistic quorum systems needs to be large in order to avoid fabricated values. In summary, if probabilistic Byzantine systems are to have high availability when the scheduler is not adversarial, they run the risk of returning fabricated values, and if a value that is dependent on a fabricated value is written to the system, the system becomes contaminated. Also, if they are designed for high availability and the scheduler happens to be adversarial, probabilistic Byzantine systems can always be forced to return fabricated values.
7

The original paper [7] uses to denote this safety parameter. We use to avoid confusion with the staleness parameter of -quorum systems. We also use to denote the threshold on Byzantine faults instead of the original .

Our system provides high availability for both reads and writes while guaranteeing that we always return one of the latest values written to the system. There are two main reasons for the higher availability of -quorums. First, each of their write operations writes, causing a write to become visible at also writes tuples for the preceding more locations than in a probabilistic quorum system with similar quorum sizes and load. Second, -quorums reads are content to return one of the last writes, not just the latest one. Read operations will therefore be likely to yield Valid, Consistent, and Fresh sets with a non-empty intersection. In -masking quorums a read can return a legitimate value only if the read quorum intersects with a single write-quorum in more than nodes. This is a much rarer case and the availability of probabilistic quorum systems is consequently lower. Probability of returning the latest value The denition of -atomicity only bounds the worst-case staleness of a read. However, since the choice of read quorums is not dependent on any other quorums chosen earlier, -quorums can also use a random access strategy to choose read quorums, as in [7]. A random access strategy guarantees that, when the network is not adversarial, a read which does not overlap with a write returns, with high probability, the latest written value. We now try to bound the probability that during times when the network is not adversarial, a read returns the latest value. For these calculations, we assume that the write operations do not overlap with any other operations. From our optimized protocol, it is clear that if the read quorum intersects with the partial-write-quorum used for the latest write in at least correct nodes, then the read will return the latest write. We now use Chernoff bounds to bound the probability that the read does not return denote the size of the read quorum and the size of partialthe latest value. Let and write-quorums used. Theorem 5. If the read quorum is chosen uniformly at random, the probability that a read does not return the latest written value is

Proof: If the reader receives the latest written value from at least different servers, then the read will return that value. Hence the probability that the read returns the latest value is no less than the probability that the read quorum intersects with the partialcorrect servers. write-quorum used for the latest write in at least The number of correct servers in the read quorum is at least . If these servers are chosen at random, then the number of servers in the intersection of the partial write and these servers follows a hypergeometric distribution with quorum of size a mean of

[12] shows that the tail bounds for hypergeometric distribution is no more than the tail bounds for a sum of independent Bernoulli variables with the same mean. Hence, we can use Chernoff bounds to provide an upper bound on the probability that the number of servers in the intersection is less than or equal to .

Therefore

4 Multi Writer -quorums
We now study the problem of building a multi-writer -quorum system using singlewriter -quorum systems. This problem is interesting because the resulting multi-writer system will have almost the same availability as the underlying single-writer systems. A single-writer multi-reader -quorum system implements two operations. 1. sw-kread( wtr ): returns one of the latest written values, by the writer . ): writes the value to the k-quorum system. It can only be 2. sw-kwrite( wtr, invoked by the writer We assume that the read and write availability of the single-writer -quorum system is and respectively. 4.1 A Lower Bound We show that using -atomic single-writer systems as primitives for a multi-writer syswriters, one cannot achieve more than -atomic tem with guarantees. We assume that the the multi-writer solution uses the single writer solution through the sw-kread and sw-kwrite functions. We use these functions as black boxes, and we assume that an invocation of sw-kread on a given register will return any one of the last writes to that register. Since we are interested in a multi-writer solution that has the same availability as the underlying single writer system, we should rule out solutions that require a write in the multi-writer system to invoke multiple write operations of the single writer system. In other words, a write operation in the multi-writer system should be able to successfully terminate if a read quorum and a partial write quorum of the single writer system are available. We require that a read quorum be available because otherwise writers would be forced to write independently of each other with no possibility for one writer to see other writes. We do not require that a read and a write quorum be available at the same time. So, without loss of generality, we assume that the implementation uses only single-writer registers, one for each writer. The implementation of a write operation of a the multi-writer register can issue a write operation to the issuing writer's register but not to the other writers' registers; it can also issue read operations to any of the registers. The read operations on the multi-writer register can only issue read operations on the single-writer registers. In our lower bound proof, we assume that writers execute a full-information protocol in which every write includes all the history of the writer, including all the values it ever wrote and all the values it read from other writers. If the lower bound applies to a full-information protocol, then it will denitely apply to any other protocol, because a full-information protocol can simulate any other protocol by ignoring portions of the data read. Also, we assume that a reader and a writer read all single-reader registers in

every operation, possibly multiple times; a protocol that does not read some registers can simply ignore the results of such read operations. For a writer , we denote with the 'th value written by . If a client reads , then it will also read , . We denote with a vector timestamp that captures the writer's knowledge of values written to the system. is the largest for which has read a value . In what follows, we will simply denote values with their indices. So, we will say that a writer writes a vector timestamp instead of writing values whose indices are less than or equal to the indices in the vector timestamp. We now describe a scenario where a reader would return a value that happens to be writes old. Consider a multi-writer read operation, where the timestamps for all the values that the reader receives are similar--specically, the timestamps

. . .

where the timestamp for the value received from the -th writer contains information up to the -th write by that writer, but only contains information about the -th write for all remaining writers. timestamp values are similar, the reader would have no reason to Since all the choose one value over the other. Let us assume, without loss of generality, that the reader who reads such a set of timestamp returns the value with the timestamp

written by the rst writer. We now show a set of writes to the system wherein the value returned would be writes old. The writes to the system occur in 4 phases. In phase 0, each of the writers performs a write operation such that the writer's entry in the corresponding timestamp reads 0. For the sake of this discussion, the nonpositive values stored in the other entries of the timestamp are irrelevant. We refer to this write as the -th write. In phase 1, writer 1 ­ whose value is being returned by the read ­ performs writes. During each of these writes, the reads of the -atomic register of other writers returns their -th write. The timestamp vector associated with each of these writes is shown in Figure 4. In phase 2, each of the remaining writers perform writes. Since the underlying single-writer system only provides -atomic semantics, also during this phase all reads to the underlying single-writer system returns the -th write for that writer. Hence the timestamp vector associated with these writes would be as shown in Figure 4. writes. The total number of At the end of phase 2, each writer has performed . writes performed in this phase is Finally, in phase 3, each writer performs another writes. There are a total of writes in this phase. The exact timestamps associated with these writes are not important.

Writer 1 Phase 0 Phase 1 < 0,?, ?, . . . , ? > < 1, 0, 0, . . . , 0 > < 2, 0, 0, . . . , 0 > < 3, 0, 0, . . . , 0 > < k!1, 0, 0, . . . , 0 >
...

Writer 2 < ?, 0, ?, . . . , ? >

Writer m < ?,?, ?, . . . , 0 >

< 0, 1, 0, . . . , 0 > < 0, 2, 0, . . . , 0 > < 0, 3, 0, . . . , 0 > Phase 2
TIME

< 0, k!1, 0, . . . , 0 >
...

...

< 0, 0, 0, . . . , 1 > < 0, 0, 0, . . . , 2 > < 0, 0, 0, . . . , 3 > < 0, 0, 0, . . . , k!1 > Phase 3 k!1 more writes k!1 more writes k!1 more writes k!1 more writes
...

Read Occurs Now

Fig. 4. Write ordering in the multi-writer

quorum system

At the end of phase 3, the multi-writer read takes place. Since the underlying singlewriter system only provides -atomic semantics, all the reads to the underlying singlewriter system during the read are only guaranteed to return a value which is not any older than the -th write. Thus could be the set of values received by the reader where the reader chooses

which is

writes old.

4.2 Multiple writer construction We present a construction for a -writer, multi-reader register with relaxed atomic semantics using single-writer, multi-reader registers with relaxed atomic semantics. Using -atomic registers, our construction provides -atomic semantics, which is almost optimal. The single-writer registers can be constructed using the -quorum protocols from [9], if servers are subject to crash and recover failures, or using the construction from Section 3 if servers are subject to Byzantine failures. In particular, using the single-writer -atomic register implementation for Byzantine failures described in Section 3, we obtain an -writer -atomic register for Byzantine failures. The Construction The multi-write construction uses instances of the single-writer -atomic registers, one for each writer . It uses approximate vector timestamps to compare writes from different writers. , maintains a local virtual clock , which is incremented Each writer , by for each write so that its value equals the number of writes performed by writer .

1 2 3 4 5 6 7 8 9 10 11 12

static = 0; void mw-write ( begin for j = 1 to m

,

)

14 15 16 17 ) 18 19 20 21 22 23 24 25 26

mw-read ( ) begin for j = 1 to m = sw r e a d ( Reject = for i = 1 to m for j = 1 to m if ( Reject = return any end

)

= sw r e a d ( / / E s t i m a t e t h e a p p r o x time stamp [ j ] = max p [ i ] = ++ sw w r i t e ( end , )

)

Fig. 5. Multi-writer K-quorum protocols

At a given time, let

be dened by

where the equality holds at the time of interest. The vector represents the global vector timestamp and it may not be known to any of the clients or servers in the system. The read and write protocols are shown in Figure 5. Write Operation To perform a write operation, the writer rst performs a read to obtain the timestamp information about all the writers (lines 4-5). Since the registers used are -atomic, each of the received timestamp information is guaranteed to be no more than writes old for any writer. A writer executing a write would calculate (lines 8-9) an approximate vector timestamp , whose -th entry is equal to and whose remaining entries can be at most older than the local time stamps of the entries at the time the write operation was started. Let and denote the global timestamps at the start and end of the write. Then,

The writer then writes the value, writer -atomic system for the writer.

, along with the timestamp

to the single-

Read operation To perform a multi-writer read operation, a reader reads from all the single-writer -quorum systems. Because of the -atomicity of the underlying singlewriter implementation, each of these responses is guaranteed to be one of the latest values written by each writer. However, if some writer has not written for a long time, then the value could be very old when considering all the writes in the system. Finding the latest value among these values is difcult because the approximate timestamps are not totally ordered. The reader uses elimination rules (lines 19-23) to reject values that can be inferred to be older than other values. This elimination is guaranteed to reject any value that is writes old. Finally, after rejecting old values, the more than reader returns any value that has not been rejected.

Protocol Correctness We now analyze the protocol in Figure 5 to give a bound on the staleness. Lemma 3. If a writer performs a write, beginning at the (global) time , with a (approximate) timestamp , then ending at and and

Proof: -quorum implementation of the single-writer system for writer , guarantees that any sw-read for writer will return one of the latest values written by the writer . Thus, during the initial read phase, the writer will read one of the last timestamp for all . values used by writer . Hence Moreover, the writer always sets the coordinate of the computed vector times(line 9). Therefore . tamp to his local virtual timestamp Lemma 4. Let be one of the values read in lines 16-17. If a writer, say , has performed writes after has been written (and before the read starts) will be rejected in lines 19-23. then Proof: Let , and , denote the global timestamp at the beand . Also, let be the we have

ginning and end of the writes for timestamp when the read is started. Since writer has performed at least

writes after writing

Also, from the -atomic properties of the single writer system, we know that

Hence

will be added to Reject in line 23.

Theorem 6. The multi-writer read protocol never returns a value that is more than writes old. Proof: Let be the value returned by the read protocol. The writer cannot have written more than writes after (and before the read begins). From Lemma 4 it follows that each of the remaining writers writes after the write for (and before could have written no more than the read begins). Hence, can be at most writes old. Lemma 5. At least one of the received values remains un-rejected.

Proof: There are two rules that we apply for rejecting a value 1. rule (i): 2. rule (ii): To show that at least one value remains un-rejected by both, we rst show a value that is not rejected by rule (ii). Then we argue that for any value that survives rule (ii), but gets rejected by rule (i) we have another value that survives rule (ii). Thus we have at least one value that remains un-rejected, because just applying rule (i) cannot reject all values. Among all the values received, consider the value whose write started last. Let the value be . Consider the write for any other value . Since this write has started before , it follows that

Since, when writer performs a read to estimate no older than writes,

it is guaranteed to receive a value

Thus will not be rejected by rule (ii). is a value that is not rejected by rule (ii) but is rejected because If then cannot be rejected by rule (ii). Hence at least one value remains un-rejected. Theorem 7. The multi-writer protocol described in Figure 5 provides -atomic semantics. Proof: To prove that the multi-writer protocols achieve -atomic semantics, we show a serialized schedule of reads and writes where each read returns writes. one of the values written by the last Since the underlying single-writer -quorum system provides -atomic semantics, all reads and writes to any such underlying system can be serialized such that all reads return one of the last values written to the system. For proving -atomicity for the multi-writer system, we schedule the writes to take place at the same instance as it is scheduled to take place in the single-writer system. Let denote the time instance when the write is scheduled to occur. We schedule the reads as follows: Any read that returns a value , written during the write to the system, would be scheduled to occur some time between and . It is easy to see that, such an ordering satises the requirements of -atomic semantics. We need to show that such a ordering can be done in a manner consistent with local history.

The scheduling of writes is trivial, because from the -atomicity property of the underlying single-writer system, it follows that the time instance when the write is scheduled to occur lies between the time when the sw-write(line 11) begins and ends. We now show, by contradiction, that reads can also be scheduled. Assume if possible that the read interval does not overlap with the interval . There are two cases: 1. Read nishes before : Since the mw-read only returns a value that has been read from sw-read in line 5, if mw-read were to nish before that would contradict the assumption that the underlying single-writer implementation satises -atomicity. 2. Read begins after : From Lemma ?? any read that starts after cannot return a value which is more than writes old. Hence the read could not possibly have returned from the this is a contradiction. write;

Availability of a Multi-writer System We now estimate the availability of the multiwriter system, assuming that the underlying single-writer -quorum system has a read and respectively. and write availability of Each multi-writer write operation involves reading from all the single-writer quorum systems and writing to one single-writer system. Hence the write availability , is at least . This is a conservative estimate of the multi-writer system, because we are assuming that, when the network is synchronous, we treat nding a read quorum and nding a partial-write-quorum as independent events. In practice, however, the fact that a particular number of servers (size of read quorum) are up and accessible only increases the probability of being able to nd an accessible partial-write-quorum. underlying single-writer -quorum systems are implemented Moreover, If the over the same strict quorum system, then the potential read quorums that can be used for all the systems will be the same.8 Thus, we can use the same read quorum to perform all the read operations. In this case, either all reads are available with probability or all reads fail with probability . Hence the probability of the multi-writer write succeeding is at least .

To perform a multi-writer read, our read protocol performs reads from the single writer -quorum implementations. Thus, along similar lines, we can argue that the availability is at least . Using the same underlying strict quorum system for all the single-writer systems, we can achieve an availability of

8

The partial-write-quorums could still be different, if the writers have chosen different partialwrite-quorums in the past.

Probabilistic freshness guarantees We now estimate the probability that our multiwriter implementation of -quorums provides the latest value, when all the writes that occur are non-overlapping. denote the probability that a sw-read does not return the latest value written Let to the single-writer system. Let denote the probability that the multi-writer system does not return the latest value written to the system. Theorem 8. The probability that the multiple-writer system does not return the latest value is at most Proof: Consider the latest write . Without loss of generality, assume it was written by writer-i. The reader may not return the latest values if either (i) the reader does not read the latest written value or (ii) the reader reads the value, but chooses a value from some other writer whose timestamp is concurrent with the latest value. . The probability that the reader does not read the latest written value is at most For any other writer, writer-j the probability that while writing , writer-i did not read the latest write written by writer-j is at most . Hence the probability that there . exists a write, whose timestamp is concurrent with 's timestamp is at most Hence the result.

5 Conclusion and Future Work
In this paper we expand our understanding of -quorum systems in three key directions [9]. First, we present a single-writer -quorum construction that tolerates Byzantine failures. Second, we prove a lower bound of on the staleness for a writer solution built over a single-writer -quorum solution. Finally, we demonstrate a technique to build multiple-writer multiple-reader quorum protocols using a single-writer multiple-reader protocol to achieve -atomic semantics. One limitation of our approach is that it improves availability only when writes are infrequent. Also, we have restricted our study of multi-writer solutions to those that built over a single-writer -quorum system; it may be possible that a direct implementation can achieve a better staleness guarantee.

References
1. Raynal, M., Beeson, D.: Algorithms for mutual exclusion. MIT Press, Cambridge, MA, USA (1986) 2. Castro, M., Liskov, B.: Practical byzantine fault tolerance. In: Proc. of the Third Symposium on Operating Systems Design and Implementation, USENIX Association, Co-sponsored by IEEE TCOS and ACM SIGOPS (1999) 3. Susan Davidson, H.G.M., Skeen, D.: Consistency in partioned network. Computing Survey 17(3) (1985) 4. Herlihy, M.: Replication methods for abstract data types. Technical Report TR-319, MIT/LCS (1984) 5. Naor, M., Wool, A.: The load, capacity, and availability of quorum systems. SIAM Journal on Computing 27(2) (1998) 423­447

6. Peleg, D., Wool, A.: The availability of quorum systems. Inf. Comput. 123(2) (1995) 210­ 223 7. Malkhi, D., Reiter, M.K., Wool, A., Wright, R.N.: Probabilistic quorum systems. Inf. Comput. 170(2) (2001) 184­206 8. Yu, H.: Signed quorum systems. In: Proc. 23rd PODC, ACM Press (2004) 246­255 9. Aiyer, A., Alvisi, L., Bazzi, R.A.: On the availability of non-strict quorum systems. In: DISC '05, London, UK, Springer-Verlag (2005) 48­62 10. Lamport, L.: On interprocess communication. part i: Basic formalism. Distributed Computing 1(2) (1986) 77­101 11. Martin, J.P., Alvisi, L., Dahlin, M.: Minimal byzantine storage. In: DISC '02, London, UK, Springer-Verlag (2002) 311­325 12. Hoeffding, W.: Probability inequalities for sums of bounded random variables. Journal of the American Statistical Association 58(301) (1963) 13­30


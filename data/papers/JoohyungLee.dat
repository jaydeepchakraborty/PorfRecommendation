On Loop Formulas with Variables
Joohyung Lee and Yunsong Meng
Computer Science and Engineering
School of Computing and Informatics
Arizona State University, Tempe, USA
{joolee, Yunsong.Meng}@asu.edu

Abstract
Recently Ferraris, Lee and Lifschitz proposed a new definition of stable models that does not refer to grounding, which
applies to the syntax of arbitrary first-order sentences. We
show its relation to the idea of loop formulas with variables
by Chen, Lin, Wang and Zhang, and generalize their loop
formulas to disjunctive programs and to arbitrary first-order
sentences. We also extend the syntax of logic programs to allow explicit quantifiers, and define its semantics as a subclass
of the new language of stable models by Ferraris et al. Such
programs inherit from the general language the ability to handle nonmonotonic reasoning under the stable model semantics even in the absence of the unique name and the domain
closure assumptions, while yielding more succinct loop formulas than the general language due to the restricted syntax.
We also show certain syntactic conditions under which query
answering for an extended program can be reduced to entailment checking in first-order logic, providing a way to apply
first-order theorem provers to reasoning about non-Herbrand
stable models.

Introduction
The theorem on loop formulas showed that the stable models
(answer sets) are the models of the logic program that satisfy
all its loop formulas. This idea has turned out to be widely
applicable in relating the stable model semantics (Gelfond
and Lifschitz 1988) to propositional logic, which in turn allowed to use SAT solvers for computing answer sets. Since
the original invention of loop formulas for nondisjunctive
logic programs (Lin and Zhao 2004), the theorem has been
extended to more general classes of logic programs, such
as disjunctive programs (Lee and Lifschitz 2003), programs
with classical negation and infinite programs (Lee 2005),
arbitrary propositional formulas under the stable model semantics (Ferraris et al. 2006), and programs with aggregates (Liu and Truszczyński 2005). The theorem has also
been applied to other nonmonotonic formalisms, such as
nonmonotonic causal theories (Lee 2004) and McCarthy’s
circumscription (Lee and Lin 2006). The notion of a loop
has been further refined by “elementary sets” (Gebser et al.
2006).
c 2008, American Association for Artificial IntelliCopyright 
gence (www.aaai.org). All rights reserved.

However, most work has been restricted to the propositional case. Variables contained in a program are first eliminated by grounding—the process which replaces every variable with every object constant—and then loop formulas are
computed from the ground program. As a result, loop formulas were defined as formulas in propositional logic.
Chen et al.’s definition of loop formulas [2006] is different in that loop formulas are obtained from the original
program without converting to the ground program, so that
variables remain. However, since the underlying semantics
of logic programs refers to grounding, such a loop formula
was understood as a schema for the set of propositional loop
formulas.
Recently there emerged a generalization of the stable
model semantics that does not refer to grounding (Ferraris
et al. 2007). The semantics turns a first-order sentence
into a second-order sentence using the “stable model operator” SM, similar to the use of the “circumscription operator”
CIRC (McCarthy 1980). Logic programs are understood as
a special class of first-order sentences under the stable model
semantics. Unlike the traditional stable model semantics,
the new language has quantifiers with genuine object variables and the notion of first-order models instead of Herbrand models. Consequently, as in classical logic, it has no
built-in unique name and domain closure assumptions.
In this paper, we study the relationship between first-order
loop formulas from (Chen et al. 2006) and the new definition of stable models from (Ferraris et al. 2007). We also extend the definition of first-order loop formulas from (Chen et
al. 2006) to disjunctive programs and to arbitrary first-order
sentences, and present certain conditions under which the
new second-order definition of stable models can be turned
into formulas in first-order logic in the form of loop formulas.
The studied relationship helps extend the syntax of logic
programs by allowing explicit quantifiers, which will be useful in overcoming the difficulties of traditional answer set
programs in reasoning about the existence (or absence) of
unnamed objects. We define the semantics of extended programs as a subclass of the new language of stable models
from (Ferraris et al. 2007). Such programs inherit from the
general language the ability to handle nonmonotonic reasoning under the stable model semantics even in the absence of
the unique name and the domain closure assumptions. On

the other hand, extended programs yield succinct loop formulas due to the restricted syntax so that it is feasible to
apply first-order theorem provers as computational engines.
Imagine an insurance policy considering “a person is eligible for a discount plan if he or she has a spouse and has no
record of accident.” This can be represented by the following program Π1 that contains explicit existential quantifiers.
GotMarried(x, y) ← Spouse(x, y)
Spouse(x, y) ← GotMarried(x, y), not Divorced(x, y)
∃w Discount(x, w) ← Spouse(x, y), not ∃z Accident(x, z)
We will say that a program Π entails a query F (under the
stable model semantics) if every stable model of Π satisfies F . For example,
• Π1 entails each of ¬∃xy Spouse(x, y) and
¬∃xy Discount(x, y).
• Π1 conjoined with Π2 = {∃y GotMarried(marge, y)},
no more entails ¬∃xw Discount(x, w),
but
entails
each
of
∃xw
Discount(x, w)
and
∀x(Discount(x, plan1) → x = marge).
• Π1 conjoined with
Π3 = {Spouse(homer, marge), ∃z Accident(homer, z)}
entails ¬∃w Discount(homer, w).
For the reasoning of this kind, we need the notion of nonHerbrand models since the names of discount plans, spouses
and accident records may be unknown. However, answer
sets are defined as a special class of Herbrand models. Instead, we will show how reasoning about non-Herbrand stable models can be represented by extended programs and
can be computed using loop formulas with variables. This
provides a way to apply first-order theorem provers to reasoning about non-Herbrand stable models.
The paper is organized as follows. In the next section
we review the new definition of stable models from (Ferraris et al. 2007). Then we review first-order loop formulas
from (Chen et al. 2006) and extend the result to disjunctive programs and to arbitrary sentences. We compare the
new definition of stable models with first-order loop formulas and show certain conditions under which the former can
be reduced to the latter. Given these results we give the notion of extended programs with explicit quantifiers and show
how query answering for extended programs can be reduced
to entailment checking in first-order logic.

Review of the New Stable Model Semantics
Let p be a list of distinct predicate constants p1 , . . . , pn , and
let u be a list of distinct predicate variables u1 , . . . , un of the
same length as p. By u = p we denote the conjunction of
the formulas ∀x(ui (x) ↔ pi (x)), where x is a list of distinct
object variables of the same arity as the length of pi , for all
i = 1, . . . n. By u ≤ p we denote the conjunction of the
formulas ∀x(ui (x) → pi (x)) for all i = 1, . . . n, and u < p
stands for (u ≤ p) ∧ ¬(u = p).
For any first-order sentence F , SM[F ] stands for the
second-order sentence
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),

where p is the list p1 , . . . , pn of all predicate constants occurring in F , u is a list u1 , . . . , un of distinct predicate variables of the same length as p, and F ∗ (u) is defined recursively:
• pi (t1 , . . . , tm )∗ = ui (t1 , . . . , tm );
• (t1 = t2 )∗ = (t1 = t2 );
• ⊥∗ = ⊥;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;
• (∃xF )∗ = ∃xF ∗ .
(There is no clause for negation here, because we treat ¬F
as shorthand for F → ⊥.) According to (Ferraris et al.
2007), an interpretation of the signature σ(F ) consisting of
the object, function and predicate constants occurring in F
is a stable model of F if it satisfies SM[F ].
The terms “stable model” and “answer set” are often used
in the literature interchangeably. In the context of the new
language of stable models, it is convenient to distinguish between them as follows: By an answer set of a first-order
sentence F that contains at least one object constant we will
understand an Herbrand1 interpretation of σ(F ) that satisfies SM[F ].
Logic programs are viewed as alternative notation for
first-order sentences of special kinds (called the FOLrepresentation) by
• replacing every comma by ∧, every semi-colon by ∨, and
every not by ¬ ;
• turning every rule Head ← Body into a formula by rewriting it as the implication Body → Head, and
• forming the conjunction of the universal closures of these
formulas.
Example 1 For program Π that contains three rules
p(a)
q(b)
r(x) ← p(x), not q(x)
the FOL-representation F of Π is
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))

(1)

and SM[F ] is
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x(((u(x) ∧ (¬v(x) ∧ ¬q(x))) → w(x))
∧((p(x) ∧ ¬q(x)) → r(x)))),
which is equivalent to first-order sentence
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b)
∧∀x(r(x) ↔ (p(x) ∧ ¬q(x)))
1

(2)

Recall that an Herbrand interpretation of a signature σ (containing at least one object constant) is an interpretation of σ such
that its universe is the set of all ground terms of σ, and every ground
term represents itself. An Herbrand interpretation can be identified
with the set of ground atoms to which it assigns the value true.

(see (Ferraris et al. 2007), Example 3). The stable models of F are any first-order models of (1) whose signature
is σ(F ). On the other hand F has only one answer set:
{p(a), q(b), r(a)}.
We call a formula negative if every occurrence of every
predicate constant in it belongs to the antecedent of an implication. For instance, any formula of the form ¬F is negative, because this expression is shorthand for F → ⊥.

• (p(t)θ, q(t0 )θ) is in E if p(t) depends on q(t0 ) in Π and
θ is a substitution that maps variables in t and t0 to object
constants and variables occurring in V .
A nonempty finite subset L of V is called a (first-order)
loop of Π if the subgraph of the first-order dependency graph
of Π induced by L is strongly connected.
Example 2 Let Π be the following program:
p(x) ← q(x)
q(y) ← p(y)
p(x) ← not r(x).

First-Order Loop Formulas
Review of Loop Formulas from (Chen et al. 2006)
We reformulate the definition of a first-order loop formula
for a nondisjunctive program from (Chen et al. 2006).
Let Π be a nondisjunctive program that has no function
constants of positive arity, consisting of a finite number of
rules of the form
A ← B, N
(3)
where A is an atom, and B is a set of atoms, and N is a
negative formula.
We will say that Π is in normal form if, for all rules (3)
in Π, no object constants occur in A. It is clear that every program can be turned into normal form using equality.
Let’s assume that Π is in normal form.
Let σ(Π) be the signature consisting of object and predicate constants occurring in Π. Given a finite set Y of nonequality atoms of σ(Π), we first rename variables in Π so
that no variables occur in Y . The (first-order) external support formula of Y for Π, denoted by FESΠ (Y ), is the disjunction of


_
^
0
∃z Bθ ∧ N θ ∧
(t 6= t )
(4)
θ:Aθ∈Y

p(t)∈Bθ
p(t0 )∈Y

for all rules (3) in Π where θ is a substitution that maps
variables in A to terms occurring in Y , and z is the list of
all variables that occur in
Aθ ← Bθ, N θ
2

but not in Y .
The (first-order) loop formula of Y , denoted by
FLFΠ (Y ), is the universal closure of
^
Y → FESΠ (Y ).
(5)

If Π is a propositional program, for any nonempty finite
set Y of propositional atoms, FLF Π (Y ) is equivalent to conjunctive loop formulas defined in (Ferraris et al. 2006),
which we will denote by LF Π (Y ).
The definition of a (first-order) loop is as follows. We say
that p(t) depends on q(t0 ) in Π if Π has a rule (3) such that
p(t) is A and q(t0 ) is in B. The (first-order) dependency
graph of Π is an infinite directed graph (V, E) such that
• V is a set of non-equality atoms formed from σ(Π), along
with an infinite supply of variables;
2
For any lists of terms t = (t1 , . . . , tn ) and t0 = (t01 , . . . , t0n )
of the same length, t = t0 stands for t1 = t01 ∧ · · · ∧ tn = t0n .

(6)

The following sets are first-order loops: Y1 = {p(z)},
Y2 = {q(z)}, Y3 = {r(z)}, Y4 = {p(z), q(z)}. Their loop
formulas are
FLFΠ (Y1 )
FLFΠ (Y2 )
FLFΠ (Y3 )
FLFΠ (Y4 )

=
=
=
=

∀z(p(z) → (q(z) ∨ ¬r(z)));
∀z(q(z) → p(z));
∀z(r(z) → ⊥);
∀z(p(z) ∧ q(z) →
(q(z) ∧ z 6= z) ∨ (p(z) ∧ z 6= z) ∨ ¬r(z)).

Example 3 Let Π be the one-rule program
p(x) ← p(y).

(7)

Its first-order loops are Yk = {p(x1 ), . . . , p(xk )} where
k > 0. Formula FLFΠ (Yk ) is
∀x1 . . . xk (p(x1 ) ∧ . . . ∧ p(xk )
→ ∃y(p(y) ∧ (y 6= x1 ) ∧ . . . ∧ (y 6= xk ))).

(8)

Definition 1 (Grounding a program) For any nondisjunctive program Π we denote by Ground(Π) the ground instance of Π, that is the program obtained from Π by replacing every occurrence of object variables with every object
constant occurring in Π, and then replacing equality a = b
with > or ⊥ depending on whether a is the same symbol as
b.
Given a program Π, let (σ(Π))g be a propositional signature consisting of all the ground atoms of σ(Π). An Herbrand model of σ(Π) can be identified with a corresponding
propositional model of (σ(Π))g .
The following is a reformulation of Theorem 1
from (Chen et al. 2006).
Proposition 1 Let Π be a nondisjunctive program in normal
form, and let I be an Herbrand model of Π whose signature
is σ(Π). The following conditions are equivalent to each
other:
(a) I is an answer set of Π;
(b) I is an Herbrand model of
{FLFΠ (Y ) : Y is a nonempty finite set of atoms of σ(Π)};
(c) I is an Herbrand model of
{FLFΠ (Y ) : Y is a first-order loop of Π};
(d) I is a (propositional) model of {LFGround(Π) (Y ) :
Y is a nonempty (finite) set of ground atoms of (σ(Π))g };
(e) I is a (propositional) model of {LFGround(Π) (Y ) :
Y is a loop of Ground(Π)} ∪ {¬p : p is an atom in
(σ(Π))g not occurring in Ground(Π)}.

The sets of first-order loop formulas considered in conditions (b), (c) above have obvious redundancy. For instance,
the loop formula of {p(x)} is equivalent to the loop formula
of {p(y)}; the loop formula of {p(x), p(y)} entails the loop
formula of {p(z)}. Following (Chen et al. 2006), given two
sets of atoms Y1 , Y2 not containing equality, we say that Y1
subsumes Y2 if there is a substitution θ that maps variables
in Y1 to terms so that Y1 θ = Y2 . We say that Y1 and Y2 are
equivalent if they subsume each other.
Proposition 2 (Chen et al. 2006, Proposition 7) Given two
loops Y1 and Y2 , if Y1 subsumes Y2 , then FLFΠ (Y1 ) entails
FLFΠ (Y2 ).
Therefore in condition (c) from Proposition 1, it is sufficient to consider a set Γ of loops such that for every loop
L of Π, there is a loop L0 in Γ that subsumes L. Chen et
al. [2006] called this set of loops complete. In Example 2,
set {Y1 , Y2 , Y3 , Y4 } is a finite complete set of loops of program (6). Program (7) in Example 3 has no finite complete
set of loops.
In condition (c) of Proposition 1, instead of the first-order
loops of the given program, one may consider the first-order
loops of any strongly equivalent program, including a program that is not in normal form. This sometimes yields a
smaller number of loop formulas to consider. For example,
the ground loops of program
p(a) ← p(b)
p(b) ← p(c)

(9)

are {p(a)}, {p(b)}, {p(c)}, all of which are subsumed by
{p(x)}. Thus it is sufficient to consider the loop formula of
{p(x)}:
∀x(p(x) → ((x = a) ∧ p(b) ∧ (x 6= b))
∨((x = b) ∧ p(c) ∧ (x 6= c))).

(10)

On the other hand, the ground loops of its normal form
p(x) ← x = a, p(b)
p(x) ← x = b, p(c)
contain {p(b), p(c)} in addition to the singleton ground
loops.

Extension to Disjunctive Programs
A disjunctive program consists of a finite number of rules of
the form
A ← B, N
(11)
where A, B are sets of atoms, and N is a negative formula.
As in the nondisjunctive case we assume that there are no
function constants of positive arity. Similar to above, a program is in normal form if, for all rules (11) in Π, no object
constants occur in A. We assume that Π is in normal form.
Given a finite set Y of non-equality atoms of σ(Π), we
first rename variables in Π so that no variables occur in Y .
The (first-order) external support formula of Y for Π, denoted by FESΠ (Y ), is the disjunction of

_
V
∃z Bθ ∧ N θ ∧ p(t)∈Bθ (t 6= t0 )
p(t0 )∈Y

θ:Aθ∩Y 6=∅

∧¬

W

p(t)∈Aθ

p(t) ∧

V

p(t0 )∈Y

t 6= t0


(12)

for all rules (11) in Π where θ is a substitution that maps
variables in A to terms occurring in Y or to themselves, and
z is the list of all variables that occur in
Aθ ← Bθ, N θ
but not in Y . The (first-order) loop formula of Y for Π, denoted by FLFΠ (Y ), is the universal closure of (5). Clearly,
(12) is equivalent to (4) when Π is nondisjunctive.
Similar to the nondisjunctive case, we say that p(t) depends on q(t0 ) in Π if there is a rule (11) in Π such that
p(t) is in A and q(t0 ) is in B. The notions of grounding, a
dependency graph and a first-order loop are extended to disjunctive programs in a straightforward way. Propositions 1
and 2 can be extended to disjunctive programs with these
extended notions.
Example 4 Let
Π
be the following program
p(x, y) ∨ p(y, z) ← q(x) and let Y = {p(u, v)}. Formula FLF Π (Y ) is the universal closure of
p(u, v) → ∃z(q(u) ∧ ¬(p(v, z) ∧ ((v, z) 6= (u, v))))
∨ ∃x(q(x) ∧ ¬(p(x, u) ∧ ((x, u) 6= (u, v)))).

Extension to Arbitrary Sentences
First-order loop formulas can even be extended to arbitrary
sentences under the stable model semantics (Ferraris et al.
2007).
As in (Ferraris et al. 2006), it will be easier to discuss the
result with a formula whose negation is similar to FES. We
define formula NFESF (Y ) (“Negation” of FES) as follows,
where F is a first-order formula and Y is a finite set of atoms
not containing equality. The reader familiar with (Ferraris et
al. 2006) will notice that this is a generalization of the notion
NES from that paper to first-order formulas.
We assume that no variables in Y occur in F by renaming
bound variables in F .
V
• NFESpi (t) (Y ) = pi (t) ∧ pi (t0 )∈Y t 6= t0 ;

•
•
•
•
•
•
•

NFESt1 =t2 (Y ) = (t1 = t2 );
NFES⊥ (Y ) = ⊥;
NFESF ∧G (Y ) = NFESF (Y ) ∧ NFESG (Y );
NFESF ∨G (Y ) = NFESF (Y ) ∨ NFESG (Y );
NFESF →G (Y ) = (NFESF (Y ) → NFESG (Y ))∧(F→G);
NFES∀xG (Y ) = ∀xNFESG (Y );
NFES∃xG (Y ) = ∃xNFESG (Y ).
The (first-order) loop formula of Y for sentence F , denoted by FLFF (Y ), is the universal closure of
^
Y → ¬NFESF (Y ).
(13)

It is not difficult to check that for any propositional formula F and any nonempty finite set Y of propositional
atoms, FLF F (Y ) is equivalent to LFF (Y ), where LF denotes loop formula for a propositional formula as defined
in (Ferraris et al. 2006).
This notion of a loop formula is a generalization of a loop
formula for a disjunctive program in view of the following
lemma.

Lemma 1 Let Π be a disjunctive program in normal form,
F the FOL-representation of Π, and Y a finite set of atoms
not containing equality. Formula NFESF (Y ) is equivalent
to ¬FESΠ (Y ) under the assumption Π.
To define a first-order dependency graph of F , we need
a few notions. Recall that an occurrence of a formula G in
a formula F is positive if the number of implications in F
containing that occurrence in the antecedent is even; it is
strictly positive if that number is 0. We will call a formula in
rectified form if it has no variables that are both bound and
free, and the quantifiers are followed by pairwise distinct
variables. Any formula can be turned into rectified form by
renaming bound variables.
Let F be a formula in rectified form. We say that an
atom p(t) weakly depends on an atom q(t0 ) in an implication
G → H if
• p(t) has a strictly positive occurrence in H, and
• q(t0 ) has a positive occurrence in G that does not belong
to any occurrence of a negative formula in G.
We say that p(t) depends on q(t0 ) in F if p(t) weakly
depends on q(t0 ) in an implication that has a strictly positive
occurrence in F .
The definition of a first-order dependency graph for a
nondisjunctive program is extended to F in a straightforward way using this extended notion of dependency between
two atoms. A loop is also defined similarly.
Definition 2 (Grounding a sentence) For any sentence F
that has no function constants of positive arity, Ground(F )
is defined recursively. If F is an atom p(t) then Ground(F )
is F . If F is an equality a = b then Ground(F ) is > or ⊥ depending on whether a is the same symbol as b. The function
Ground commutes with all propositional connectives; quantifiers turn into finite conjunctions and disjunctions over all
object constants occurring in F .
Proposition 1 remains correct even after replacing “a
nondisjunctive program in normal form” in the statement
with “a sentence in rectified form that contains no function
constants of positive arity,” and using the extended notions
accordingly. Proposition 2 can be extended to arbitrary sentences as well.

Loop Formulas in Second-Order Logic
SM and Loop Formulas
Let F be a first-order formula, let p1 , . . . , pn be the list of all
predicate constants occurring in F , and let u and v be lists
of predicate variables corresponding to p1 , . . . , pn .
We define NESF (u) recursively as follows, which is similar to NFES above but contains second-order variables as its
argument.
• NESpi (t) (u) = pi (t) ∧ ¬ui (t);
• NESt1 =t2 (u) = (t1 = t2 );
• NES⊥ (u) = ⊥;
• NESF ∧G (u) = NESF (u) ∧ NESG (u);
• NESF ∨G (u) = NESF (u) ∨ NESG (u);

• NESF →G (u) = (NESF (u) → NESG (u)) ∧ (F→ G);
• NES∀xF (u) = ∀xNESF (u);
• NES∃xF (u) = ∃xNESF (u).
By Nonempty(u) we denote the formula
∃x1 u1 (x1 ) ∨ · · · ∨ ∃xn un (xn ).
SM[F ] can be written in the style of “loop formulas” in
the following way.
Proposition 3 For any sentence F , SM[F ] is equivalent to
F ∧ ∀u((u ≤ p) ∧ Nonempty(u) → ¬NESF (u)).

(14)

Second-Order Characterization of Loops
The notion of a loop can be incorporated into the secondorder definition of stable models as follows.
Given a sentence F in rectified form, by EF (v, u) we
denote
_
∃z(vi (t) ∧ uj (t0 ) ∧ ¬vj (t0 ))
(pi (t),pj (t0 )) :
pi (t) depends on pj (t0 ) in F

where z is the list of all object variables in t and t0 . By
SCF (u) we denote the second-order sentence
Nonempty(u) ∧ ∀v((v < u) ∧ Nonempty(v) → EF (v, u)).
(15)
Formula (15) represents the concept of a loop without referring to the notion of a dependency graph explicitly, based on
the following observation. Consider a finite propositional
program Π. A set U of atoms is a loop of Π iff for every
nonempty proper subset V of U , there is an edge from an
atom in V to an atom in U \ V in the dependency graph of
Π (Gebser et al. 2006). To see the relation in the first-order
case, we first define a dependency graph and a loop that are
relative to a given interpretation. Let F be a sentence in rectified form and let I be an interpretation of F . The dependency graph of F w.r.t. I is an infinite directed graph (V, E)
where
• V is the set of all atoms of the form pi (ξ~∗ ) where ξ~∗ is a
list of object names, 3 and
• (pi (ξ~∗ ), pj (η~∗ )) is in E if there are pi (t), pj (t0 ) such
that pi (t) depends on pj (t0 ) in F and there is a mapping θ from variables in t and t0 to object names such
~ and (t0 θ)I = ~η.
that (tθ)I = ξ,
We call a nonempty subset L of V a loop of F w.r.t. I
if the subgraph of the dependency graph of F w.r.t. I that
is induced by L is strongly connected.4 The following
lemma describes the relation between formula (15) and a
loop w.r.t. I.
3

Each element ξ of the universe |I| has a corresponding object name, which is an object constant not from the given signature
See (Lifschitz et al. 2008) for details.
4
Note that unlike first-order loops defined earlier we don’t restrict L to be finite. There the assumption was required to be able
to write a loop formula.

Lemma 2 Let F be a first-order sentence in rectified form,
I an interpretation of F and q a list of predicate names 5
corresponding to p. I |= SCF (q) iff
~ TRUE where ξ~ is a list of object names}
Y = {pi (ξ~∗ ) : q I (ξ)=

Lemma 3 Let F be a first-order sentence in rectified form,
I an interpretation, and q a list of predicate names corresponding to p.

is a loop of F w.r.t. I.
One may expect that, similar to the equivalence between
conditions (b) and (c) from Proposition 1, formula (14) is
equivalent to the following formula:
F ∧ ∀u((u ≤ p) ∧ SCF (u) → ¬NESF (u)).
(16)
However, this is not the case as shown in the following example.
Example 5 Let F be the FOL-representation of program Π :
p(x, y) ← q(x, z)
q(x, z) ← p(y, z).
Consider interpretation I whose universe is the set of all
nonnegative integers such that

TRUE
if m = n,
pI (m, n) =
FALSE
otherwise;

TRUE
if n = m + 1,
I
q (m, n) =
FALSE
otherwise;

iff

i

One can check that I is not a stable model of F , but satisfies (16).
This mismatch is similar to the observation from (Lee
2005) that the external support of all loops does not ensure
the stability of the model if the program is allowed to be
infinite. Consider the following infinite program:
pi ← pi+1
(i > 0).
(17)
The only loops are singletons, and their loop formulas are
satisfied by the model {p1 , p2 , . . .} of (17), which is not stable. To check the stability, not only we need to check every loop is externally supported, but also need to check that
{p1 , p2 , . . .} is “externally supported.” Example 5 shows
that the mismatch can occur even if the program is finite once it is allowed to contain variables. What distinguishes {p1 , p2 , . . .} from loops is that, for every loop in
{p1 , p2 , . . .}, there is an outgoing edge in the dependency
graph. Taking this into account, we define LoopF (u) as
SCF (u) ∨ (Nonempty(u)
∧ ∀v((v ≤ u) ∧ SCF (v) → EF (v, u))).
(18)
Given a dependency graph of F w.r.t. I, we say that a
nonempty set Y of vertices is unbounded w.r.t. I if, for every
subset Z of Y that induces a strongly connected subgraph,
there is an edge from a vertex in Z to a vertex in Y \ Z. For
instance, for the interpretation I in Example 5,
{p(0∗ , 0∗ ), q(0∗ , 1∗ ), p(1∗ , 1∗ ), q(1∗ , 2∗ ), . . . , }
is an unbounded set w.r.t. I.
The following lemma describes the relation between the
second disjunctive term of (18) with unbounded sets.
5

Like object names, for every n > 0, each subset of |I|n has
a name, which is an n-ary predicate constant not from the given
signature.

I |= Nonempty(q) ∧ ∀v((v ≤ q) ∧ SCF (v) → EF (v, q))
~ TRUE where ξ~ is a list of object names}
Y = {pi (ξ~∗ ) : qiI (ξ)=
is an unbounded set of F w.r.t. I.
An extended loop of F w.r.t. I is a loop or an unbounded
set of F w.r.t. I. Clearly I |= (18) iff
~ TRUE where ξ~ is a list of object names}
Y = {pi (ξ~∗ ) : qiI (ξ)=
is an extended loop of F w.r.t. I.
The following proposition shows that the formula obtained from (16) by replacing SCF (u) with LoopF (u) is
equivalent to SM[F ].
Proposition 30 For any sentence F in rectified form, the following second-order sentences are equivalent to each other:
(a) SM[F ];
(b) F ∧ ∀u((u ≤ p) ∧ Nonempty(u) → ¬NESF (u));
(c) F ∧ ∀u((u ≤ p) ∧ LoopF (u) → ¬NESF (u)).
(See appendix A for an example.)
Proposition 30 is essentially a generalization of the main
theorem from (Ferraris et al. 2006) to first-order sentences.
If F is a propositional formula, then for any subset Y of p,
−
→
by Y we denote the tuple (Y1 , . . . , Yn ), where

>, if pi ∈ Y ;
Yi =
⊥, otherwise.
Corollary 1 (Ferraris et al. 2006, Theorem 2) For any
propositional formula F , the following conditions are equivalent to each other under the assumption F .
(a) SM[F ];
V
−
→
(b) The conjunction of Y → ¬NESF ( Y ) for all nonempty
sets Y of atoms occurring in F ;
V
−
→
(c) The conjunction of Y → ¬NESF ( Y ) for all loops Y
of F .
Several other propositions in this paper are derived from
Proposition 30 .

Between SM and First-Order Loop Formulas
In general, SM[F ] is not reducible to any first-order sentence, even in the absence of function constants of positive
arity. As in circumscription, transitive closure can be represented using SM, while it cannot be done by any set of
first-order formulas, even if that set is allowed to be infinite.6
However, if the universe consists of finite elements, then the
following holds. We will say that F is in normal form if
no object constants occur in a strictly positive occurrence of
atoms in F .
6

Vladimir Lifschitz, personal communication.

Proposition 4 For any sentence F and any model I of F
whose universe is finite, the following conditions are equivalent:
(a) I satisfies SM[F ];
(b) for every nonempty finite set Y of atoms formed from
predicate constants in σ(F ) and an infinite supply of variables, I satisfies FLF F (Y ).
If F is in rectified and normal form that has no function
constants of positive arity, the following condition is also
equivalent to each of (a) and (b):
(c) for every first-order loop Y of F , I satisfies FLFF (Y ).
Unlike Proposition 1 in which loops can be found from
any strongly equivalent program, condition (c) requires that
loops be found from a normal form. This is related to the fact
that Proposition 4 considers non-Herbrand stable models as
well, which may not satisfy the unique name assumption.
For instance, recall that program (9) has singleton loops
only, which are subsumed by {p(x)}. Consider an interpretation I such that |I| = {1, 2} and aI = cI = 1, bI = 2,
pI (m) = TRUE for m = 1, 2. I is a non-Herbrand model
which is not stable, but it satisfies (10), the loop formula of
{p(x)}.
The proof of the equivalence between (a) and (c) uses the
following lemma.
Lemma 4 Let F be a sentence in rectified and normal form
that contains no function constants of positive arity, and let
I be an interpretation. If there is no infinite extended loop
of F w.r.t. I, then I |= SM[F ] iff, for every first-order loop
Y of F , I |= FLF F (Y ).
Without the finite universe assumption, Proposition 4
would be incorrect, as shown in Example 5. For another
example, consider program (7) with an interpretation I with
an infinite universe such that p is identically true. I does not
satisfy SM[F ], but satisfies F and FLFF (Y ) for any finite
set Y of atoms.
In view of Proposition 2, if the size of the universe |I|
is known, as with the answer sets (whose universe is the
Herbrand universe of σ(F )), it is sufficient to consider at
most 2|p| − 1 loop formulas where p is set of all predicate
constants occurring in the sentence. Each loop formula is for
set Yq corresponding to a nonempty subset q of p, defined
as Yq = {p(x1 ), . . . , p(x|I|n ) : p ∈ q} where n is the arity
of p. For instance, for program (7), if the size of the universe
is known to be 3, it is sufficient to consider only one loop
formula (8) where k = 3.
In the next section we consider certain classes of sentences for which SM[F ] is equivalent to a first-order sentence without the finite universe assumption.

Reducibility to first-order formulas
Finite complete set of first-order loops
Proposition 8 from (Ferraris et al. 2007) shows that SM[F ]
can be reduced to a first-order sentence if F is “tight”, i.e.,
F has no “nontrivial” predicate loops. (Predicate loops are
defined similar to first-order loops, but from a “predicate dependency graph” (Ferraris et al. 2007), which does not take

into account “pointwise dependency.”) We further generalize this result using the notion of finite complete set of loops.
Let F be a sentence in rectified form that contains no
function constants of positive arity. Theorem 2 from (Chen
et al. 2006) provides a syntactic condition under which a
nondisjunctive program has a finite complete set of loops,
which can be extended to disjunctive programs and arbitrary
sentences in a straightforward way.
The following proposition tells that if F has a finite complete set of loops, then SM[F ] can be equivalently rewritten
as a first-order sentence.
Proposition 5 Let F be a sentence in rectified and normal
form that contains no function constants of positive arity.
If F has a finite complete set Γ of first-order loops, then
SM[F ] is equivalent to the conjunction of F with the set of
loop formulas for all loops in Γ.
This proposition generalizes Proposition 8 from (Ferraris
et al. 2007). Clearly, every tight sentence has a finite complete set of first-order loops.
The proof of Proposition 5 follows from Lemma 4 and the
following lemma.
Lemma 5 Let F be a sentence in rectified and normal form
that contains no function constants of positive arity. If F
has a finite complete set of loops, then there is no infinite
extended loop of F w.r.t any interpretation.
Proposition 5 would go wrong if we replace “a finite complete set of loops” in the statement with “a finite number of
predicate loops.” Obviously any sentence F contains a finite number of predicate constants, so that this condition is
trivial. In view of intranslatability of SM to first-order sentences, this fact tells that the more refined notion of firstorder loops is essential for this proposition to hold.
For nondisjunctive program Π, Proposition 9 from (Chen
et al. 2006) shows that if every variable in the head occurs in
the body, then Π has a finite complete set of loops. However,
this does not hold once Π is allowed to be disjunctive. For
instance,
p(x, y) ← q(x), r(y)
q(x) ∨ r(y) ← p(x, y)
has no finite complete set of loops.

Safe formulas
A disjunctive program Π is called safe if, for each rule (11)
of Π, every variable occurring in the rule occurs in B as
well. (Lee et al. 2008) generalized this notion to sentences,
showing that for any safe sentence, its Herbrand stable models are not affected by “irrelevant” object constants that do
not occur in the program. We will show that this notion is
also related to reducing SM[F ] to a first-order sentence.
We review the notion of safety from (Lee et al. 2008).7
We assume that there are no function constants of positive
arity. As a preliminary step, we assign to every formula F
in rectified form a set RV(F ) of its restricted variables, as
follows:
7

The definition here is slightly weaker and applies to arbitrary
sentences, unlike the one in (Lee et al. 2008) that refers to prenex
form.

• For an atom F ,

• RV(F ∧ G) = RV(F ) ∪ RV(G);

where F is a conjunction of the universal closure of implications that correspond to the rules (FOL-representation). An
example of an extended program is given in the introduction.
Let Π be an extended program. Given a nonempty finite set Y of non-equality atoms of σ(Π), we first rename
variables in Π so that no variables occur in Y . Formula
EFESΠ (Y ) (“Extended FES”) is defined as the disjunction
of

• RV(F ∨ G) = RV(F ) ∩ RV(G);

∃z(NFESG (Y ) ∧ ¬NFESH (Y ))

– if F is an equality between two variables then
RV(F ) = ∅;
– otherwise, RV(F ) is the set of all variables occurring
in F ;
• RV(⊥) = ∅;

• RV(F → G) = ∅;
• RV(QvF ) = RV(F ) \ {v} where Q ∈ {∀, ∃}.
We say that a variable x is unsafe in F if there is an occurrence of x in F that is not in any of
• ∀x, ∃x, and
• any subformula G → H of F such that x ∈ RV(G).
By UF we denote the formula

^ 
^ _
∀x p(x) →
x=c
p∈p

(20)

for all rules (19) where H contains a strictly positive occurrence of a predicate constant that belongs to Y , and z is the
list of all free variables in the rule that do not occur in Y .
The loop formula of Y for Π is the universal closure of
^
Y → EFESΠ (Y ).
(21)
The following proposition tells that (21) is a generalization of the definition of a loop formula for a disjunctive program and is equivalent to the definition of a loop formula
(13) for an arbitrary sentence.

x∈x c∈C

where C is the set of all object constants occurring in F ,
and x is a list of distinct object variables whose length is the
same as the arity of p.
The following proposition tells that for a safe sentence F ,
formula SM[F ] can be equivalently rewritten as a first-order
sentence.

Proposition 7 Let Π be an extended program, F the FOLrepresentation of Π, and Y a finite set of atoms not containing equality. Under the assumption Π, formula EFESΠ (Y )
is equivalent to ¬NFESF (Y ). If Π is a disjunctive program,
then EFESΠ (Y ) is also equivalent to FESΠ (Y ) under the
assumption Π.

Proposition 6 Let F be a sentence in rectified form that has
no function constants of positive arity. If F has no unsafe
variables, then SM[F ] is equivalent to the conjunction of F ,
UF and a finite number of loop formulas.

While the size of (13) is exponential to the size of F in
the worst case, (21) can be equivalently written in a linear
size due to the following lemma.

We note that the syntactic conditions in Propositions 5 and 6 do not entail each other. For instance,
∀x (q(x) ∧ p(y) → p(x)) has no unsafe variables, but has
no finite complete set of first-order loops, while ∀x p(x) has
a finite complete set of loops {{p(x)}}, but has an unsafe
variable x.
Safety is usually imposed on input programs for answer
set solvers, but it could be somewhat restricted in first-order
reasoning which is not confined to generating Herbrand stable models. For instance, the example program in the introduction (identified as a sentence) has an unsafe variable w
(but has a finite complete set of loops).

Programs with Explicit Quantifiers
In the following we extend the syntax of logic programs by
allowing explicit quantifiers. As in answer set programs,
the syntax uses the intuitive if-then form, but allows explicit
quantifiers. An extended rule is of the form

Lemma 6 For any negative formula F and any finite set Y
of non-equality atoms, NFESF (Y ) is equivalent to F .
For instance, for F = (p(x)→⊥)→⊥ and Y = {p(a)},
formula NFESF (Y ) is
[(((p(x) ∧ x 6= a)→⊥) ∧ (p(x)→⊥))→⊥] ∧ [(p(x)→⊥)→⊥],
which is equivalent to F .
A finite set Γ of sentences entails a sentence F under the
stable model semantics (symbolically, Γ |=SM F ), if every
stable model of Γ satisfies F .
If SM[F ] can be reduced to a first-order sentence, as allowed in Propositions 5 and 6, clearly, the following holds.
Γ |=SM F iff Γ ∪ ∆ |= F

(19)

where ∆ is the set of first-order loop formulas required. This
fact allows us to use first-order theorem provers to reason
about query entailment under the stable model semantics.

where G and H are formulas with no function constants of
positive arity such that every occurrence of an implication
in G and H is in a negative formula. An extended program is
a finite set of extended rules. The semantics of an extended
program is defined by identifying the program with SM[F ]

Example 6 Consider the insurance policy example in
the introduction, which has the following finite complete set of loops: {Divorced(u, v)}, {Accident(u, v)},
{Discount(u, v)}, {GotMarried(u, v)}, {Spouse(u, v)} and
{GotMarried(u, v), Spouse(u, v)}. Their loop formulas for

H←G

Π1 ∪ Π2 are equivalent to the universal closure of
Div(u, v) → ⊥
Acc(u, v) → ⊥

Acknowledgements

Dis(u, v) → ∃xy[Spo(x, y) ∧ ¬∃zAcc(x, z)
∧ ¬(∃w(Dis(x, w) ∧ (x, w) 6= (u, v)))]
M ar(u, v) →
∃xy[Spo(x, y) ∧ ¬(M ar(x, y) ∧ (x, y) 6= (u, v))]
∨ ¬∃y[M ar(marge, y) ∧ (marge, y) 6= (u, v)]
Spo(u, v) →
∃xy[M ar(x, y) ∧ ¬Div(x, y)
∧¬(Spo(x, y) ∧ (x, y) 6= (u, v))]
M ar(u, v) ∧ Spo(u, v) →
∃xy[(Spo(x, y) ∧ (x, y) 6= (u, v))
∧¬(M ar(x, y) ∧ (x, y) 6= (u, v))]
∨ ¬∃y[M ar(marge, y) ∧ (marge, y) 6= (u, v)]
∨ ∃xy[(M ar(x, y) ∧ (x, y) 6= (u, v)) ∧ ¬Div(x, y)
∧¬(Spo(x, y) ∧ (x, y) 6= (u, v))].
These loop formulas, conjoined with the FOL-representation
of Π1 ∪ Π2 , entail under first-order logic each of
∃xw Dis(x, w) and ∀x(Dis(x, plan1) → x = marge). We
verified the answers using a first-order theorem prover Vampire 8 .

Conclusion
Our main contributions are as follows.
• We extended loop formulas with variables from (Chen et
al. 2006) to disjunctive programs and to arbitrary firstorder sentences and showed their relations to the new language of stable models from (Ferraris et al. 2007).
• We presented certain syntactic conditions under which the
language of stable models from (Ferraris et al. 2007) can
be reduced to first-order logic, which allows to use firstorder theorem provers to reason about stable models.
• We defined the notion of an extended program which allows closed-world reasoning under the stable model semantics even in the absence of the unique name and the
domain closure assumptions. We provided a computational method for extended programs by means of loop
formulas.
The use of first-order theorem provers for the stable model
semantics was already investigated in (Sabuncu and Alpaslan 2007), but their results are limited in several ways.
They considered nondisjunctive logic programs with “trivial” loops only, in which case the stable model semantics is
equivalent to the completion semantics (Clark 1978); their
notion of models were limited to Herbrand models.
SAT-based answer set solvers may also benefit from loop
formulas with variables. Instead of finding propositional
loop formulas one by one from the ground program, one
8

may consider a set of formulas in a batch which are obtained
from grounding first-order loop formulas. Whether it leads
to computational efficiency needs empirical evaluation.

http://www.vampire.fm .

We are grateful to Vladimir Lifschitz, Ravi Palla and the
anonymous referees for their useful comments on this paper.

References
Yin Chen, Fangzhen Lin, Yisong Wang, and Mingyi
Zhang. First-order loop formulas for normal logic programs. In Proceedings of International Conference on
Principles of Knowledge Representation and Reasoning
(KR), pages 298–307, 2006.
Keith Clark. Negation as failure. In Herve Gallaire and
Jack Minker, editors, Logic and Data Bases, pages 293–
322. Plenum Press, New York, 1978.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. A
generalization of the Lin-Zhao theorem. Annals of Mathematics and Artificial Intelligence, 47:79–101, 2006.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. A
new perspective on stable models. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pages 372–379, 2007.
Martin Gebser, Joohyung Lee, and Yuliya Lierler. Elementary sets for logic programs. In Proceedings of National
Conference on Artificial Intelligence (AAAI), pages 244–
249, 2006.
Michael Gelfond and Vladimir Lifschitz. The stable model
semantics for logic programming. In Robert Kowalski
and Kenneth Bowen, editors, Proceedings of International
Logic Programming Conference and Symposium, pages
1070–1080. MIT Press, 1988.
Joohyung Lee and Vladimir Lifschitz. Loop formulas for
disjunctive logic programs. In Proceedings of International Conference on Logic Programming (ICLP), pages
451–465, 2003.
Joohyung Lee and Fangzhen Lin. Loop formulas for
circumscription. Artificial Intelligence, 170(2):160–185,
2006.
Joohyung Lee, Vladimir Lifschitz, and Ravi Palla. A reductive semantics for counting and choice in answer set
programming. In Proceedings of AAAI Conference on Artificial Intelligence (AAAI), 2008. To appear.
Joohyung Lee. Nondefinite vs. definite causal theories.
In Proc. 7th Int’l Conference on Logic Programming and
Nonmonotonic Reasoning, pages 141–153, 2004.
Joohyung Lee. A model-theoretic counterpart of loop formulas. In Proceedings of International Joint Conference
on Artificial Intelligence (IJCAI), pages 503–508, 2005.
Vladimir Lifschitz, Leora Morgenstern, and David
Plaisted. Knowledge representation and classical logic. In
Frank van Harmelen, Vladimir Lifschitz, and Bruce Porter,
editors, Handbook of Knowledge Representation. Elsevier,
2008.

Fangzhen Lin and Yuting Zhao. ASSAT: Computing answer sets of a logic program by SAT solvers. Artificial
Intelligence, 157:115–137, 2004.
Lengning Liu and Mirosław Truszczyński. Properties of
programs with monotone and convex constraints. In Proceedings of National Conference on Artificial Intelligence
(AAAI), pages 701–706, 2005.
John McCarthy. Circumscription—a form of non-monotonic reasoning. Artificial Intelligence, 13:27–39,171–172,
1980.
Orkunt Sabuncu and Ferda N. Alpaslan. Computing answer sets using model generation theorem provers. In
Working Notes of Answer Set Programming (ASP) 2007,
2007.

Appendix. Additional Examples
Consider program (6) from Example 2:
p(x) ← q(x)
q(y) ← p(y)
p(x) ← not r(x).
Let F be the FOL-representation of Π:
∀xy((q(x) → p(x)) ∧ (p(y) → q(y)) ∧ (¬r(x) → p(x))).
Below we use the following fact to simplify the formulas.
Lemma 7 For any negative formula F , the formula
NESF (u) ↔ F
is logically valid.
1. SM[F ] is equivalent to
F ∧ ¬∃u1 u2 u3 ((u1 , u2 , u3 ) < (p, q, r))
∧∀xy((u2 (x) → u1 (x))
∧(u1 (y) → u2 (y))
∧(¬r(x) → u1 (x))).
2. Formula in Proposition 30 (b):
F ∧ ∀u(u ≤ p ∧ Nonempty(u) → ¬NESF (u))
is equivalent to
F ∧ ∀u1 u2 u3 ((u1 , u2 , u3 ) ≤ (p, q, r)
∧(∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
→ ¬∀xy([q(x) ∧ ¬u2 (x) → p(x) ∧ ¬u1 (x)]
∧[p(y) ∧ ¬u1 (y) → q(y) ∧ ¬u2 (y)]
∧[¬r(x) → p(x) ∧ ¬u1 (x)])).
(22)
3. Formula in Proposition 30 (c): Similar to (22) except
that
∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x)
in (22) is replaced with LoopF (u), which is
SCF (u) ∨ [(∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
∧ ∀v1 v2 v3 (((v1 , v2 , v3 ) ≤ (u1 , u2 , u3 )) ∧ SCF (v)
→ (∃x(v1 (x) ∧ u2 (x) ∧ ¬v2 (x))
∨∃y(v2 (y) ∧ u1 (y) ∧ ¬v1 (y))))],

where SCF (u) is
(∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
∧ ∀v1 v2 v3 (((∃x v1 (x) ∨ ∃x v2 (x) ∨ ∃x v3 (x))
∧(v1 , v2 , v3 ) < (u1 , u2 , u3 ))
→ (∃x(v1 (x) ∧ u2 (x) ∧ ¬v2 (x))
∨∃y(v2 (y) ∧ u1 (y) ∧ ¬v1 (y)))).
Remark: Proposition 30 tells that each of the formulas in 1,
2, 3 are equivalent to each other.
4. First-Order Loop Formula for Sentence F (Using
NFES) : Let Y1 = {p(z)},Y2 = {q(z)}, Y3 = {r(z)},
Y4 = {p(z), q(z)}. Set {Y1 , Y2 , Y3 , Y4 } is a complete set of
loops.
Under the assumption F ,
• FLFF (Y1 ) is equivalent to the universal closure of
p(z) → ¬∀xy([q(x) → p(x) ∧ x 6= z]
∧[p(y) ∧ y 6= z → q(y)]
∧[¬r(x) → p(x) ∧ x 6= z]).
• FLFF (Y2 ) is equivalent to the universal closure of
q(z) → ¬∀xy([q(x) ∧ x 6= z → p(x)]
∧[p(y) → q(y) ∧ y 6= z]).
• FLFF (Y3 ) is equivalent to the universal closure of
r(z) → ⊥.
• FLFF (Y4 ) is equivalent to the universal closure of
p(z) ∧ q(z) →
¬∀xy([q(x) ∧ x 6= z → p(x) ∧ x 6= z]
∧[p(y) ∧ y 6= z → q(y) ∧ y 6= z]
∧[¬r(x) → p(x) ∧ x 6= z]).
5. First-Order Loop Formula for Nondisjunctive Program (Using FES): See Example 2.
6. First-Order Loop Formula when Π is understood as
an extended program (Using EFES) : Consider the same
Yi as before.
Under the assumption Π,
• FLFΠ (Y1 ) is equivalent to the universal closure of
p(z) → (∃x(q(x) ∧ ¬(p(x) ∧ x 6= z))
∨ ∃x(¬r(x) ∧ ¬(p(x) ∧ x 6= z))).
• FLFΠ (Y2 ) is equivalent to the universal closure of
q(z) → ∃y(p(y) ∧ ¬(q(y) ∧ y 6= z)).
• FLFΠ (Y3 ) is equivalent to the universal closure of
r(z) → ⊥.
• FLFΠ (Y4 ) is equivalent to the universal closure of
(p(z) ∧ q(z)) → (∃x((q(x) ∧ x 6= z) ∧ ¬(p(x) ∧ x 6= z))
∨ ∃y((p(y) ∧ y 6= z) ∧ ¬(q(y) ∧ y 6= z))
∨ ∃x(¬r(x) ∧ ¬(p(x) ∧ x 6= z))).
Remark: Proposition 7 tells that the sets of formulas in each
of 4, 5, 6 are equivalent to each other, under the assumption
F . In view of Proposition 5, each set conjoined with F is
equivalent to each of the formulas in 1, 2, 3.

Ann Math Artif Intell (2006) 47: 79–101
DOI 10.1007/s10472-006-9025-2

A generalization of the Lin–Zhao theorem
Paolo Ferraris · Joohyung Lee · Vladimir Lifschitz

Received: 6 February 2006 / Accepted: 23 June 2006 /
Published online: 20 September 2006
© Springer Science + Business Media B.V. 2006

Abstract The theorem on loop formulas due to Fangzhen Lin and Yuting Zhao
shows how to turn a logic program into a propositional formula that describes the
program’s stable models. In this paper we simplify and generalize the statement of
this theorem. The simplification is achieved by modifying the definition of a loop in
such a way that a program is turned into the corresponding propositional formula by
adding loop formulas directly to the conjunction of its rules, without the intermediate
step of forming the program’s completion. The generalization makes the idea of a
loop formula applicable to stable models in the sense of a very general definition
that covers disjunctive programs, programs with nested expressions, and more.
Mathematics Subject Classifications (2000) 68N17 · 68T27 · 68T30
Keywords logic programming · stable models · answer set programming ·
nonmonotonic reasoning · Clark’s completion · loop formulas

1 Introduction
The theorem on loop formulas due to Lin and Zhao [15] is an important result in the
theory of stable models. It shows how to turn a logic program  into a propositional
formula that describes the stable models of . The reduction of the problem of

P. Ferraris (B) · V. Lifschitz
University of Texas at Austin, Austin, Texas, USA
e-mail: otto@cs.utexas.edu
V. Lifschitz
e-mail: vl@cs.utexas.edu
J. Lee
Arizona State University, Tempe, Arizona, USA
e-mail: joolee@asu.edu

80

Ann Math Artif Intell (2006) 47: 79–101

computing stable models to the satisfiability problem for propositional formulas
given by the Lin–Zhao theorem has led to the development of the answer set
solvers assat1 and cmodels2 . If the program  is tight [2, 3] then the corresponding
propositional formula is simply the completion of  in the sense of [1]; otherwise the
corresponding formula is the conjunction of the completion of  with the additional
formulas that Lin and Zhao called the ‘loop formulas’ of . The number of loop
formulas is exponential in the size of  in the worst case, and there are reasons for
this in complexity theory [12]. But in many cases the Lin–Zhao translation of  into
propositional logic is not much bigger than .
In this paper we show how the statement of the Lin–Zhao theorem can be
simplified and generalized. The simplification is achieved by modifying the definition
of a loop from [15] in such a way that a program is turned into the corresponding
propositional formula by adding loop formulas directly to the conjunction of its rules,
without the intermediate step of forming the program’s completion.
The generalization, on the other hand, makes the idea of a loop formula applicable
to stable models in the sense of the very general definition proposed in [4] and [5],
which is essentially a reformulation of equilibrium logic [20]. That general definition
covers, in particular, disjunctive programs; the possibility of extending the Lin–Zhao
theorem to the disjunctive case has been used to design a version of cmodels that can
handle disjunctive programs [11]. The definition covers even arbitrary programs with
nested expressions in the sense of [13], and more. The discussion of the semantics
of aggregates (in particular, weight constraints with negative weights) in [5] shows
that this high degree of generality is useful in some applications to knowledge
representation.
Our version of the Lin–Zhao theorem is also more general than its original
statement in another sense: it shows that loop formulas can be formed in two ways –
not only ‘disjunctively’ as in [15], but also ‘conjunctively.’
It can be viewed as an enhancement of the encoding of equilibrium logic by
quantified propositional formulas proposed by Pearce et al. [19]. If we eliminate
quantifiers from that encoding, the result will be similar to the conjunction of loop
formulas, but it will be much longer in many cases.
This paper is organized as follows. In Section 2 we discuss our generalization of the
Lin–Zhao theorem for the simple case of ‘traditional’ programs from [6], and show
how to extend it to disjunctive programs. The main theorem in full generality is stated
in Section 3 and proved in Section 4. To make the paper self-contained, we have also
included a review of the necessary background material from [4] (Appendix A) and
from [19] (Appendix B).
Preliminary reports on some of the work presented below are published in [8] and
[9].

1 http://assat.cs.ust.hk/.
2 http://www.cs.utexas.edu/users/tag/cmodels/.

Ann Math Artif Intell (2006) 47: 79–101

81

2 Special cases
2.1 Syntax and semantics of traditional programs
A traditional rule is an expression of the form
a1 ← a2 , . . . , am , not am+1 , . . . , not an

(1)

where n ≥ m ≥ 1 and a1 , . . . , an are propositional atoms. A traditional program is
a finite set of traditional rules. We will identify a traditional rule (1) with the
propositional formula
(a2 ∧ · · · ∧ am ∧ ¬am+1 ∧ · · · ∧ ¬an ) → a1 .

(2)

A traditional program  will be identified with the conjunction of the formulas (2)
corresponding to the rules of . In view of this convention, the definition of a stable
model of a propositional formula from [4] and [5], reproduced here in Appendix A,
is applicable, in particular, to traditional programs; according to [4, Proposition 28], it
is equivalent in this special case to the familiar definition of a stable model proposed
in [6].
For example, the traditional program
p←q
q← p
p ← not r
r ← not p

(3)

can be viewed as alternative notation for the formula
(q → p) ∧ ( p → q) ∧ (¬r → p) ∧ (¬ p → r).

(4)

The stable models of this program are { p, q} and {r} (see Appendix A for the
verification of a part of this claim).
2.2 Main theorem for traditional programs
The (positive) dependency graph of a traditional program  is the directed graph
such that
•
•

its vertices are the atoms occurring in , and
its edges go from a1 to a2 , . . . , am for all rules (1) of .

A nonempty set L of atoms is called a loop of  if, for every pair p, q of atoms in L,
there exists a path (possibly of length 0) from p to q in the dependency graph of 
such that all vertices in this path belong to L. In other words, L is a loop of  iff
the subgraph of the dependency graph of  induced by L is strongly connected. It is
clear that any set consisting of a single atom is a loop.
For example, the dependency graph of program (3) is shown in figure 1. This
program has four loops:
{ p}, {q}, {r}, { p, q}.

(5)

Our definition of a loop is slightly different from the definition given in [15],
because it takes into account paths of length 0. This is what allows us to drop the

82

Ann Math Artif Intell (2006) 47: 79–101

Figure 1 The dependency graph of program (3)

completion step from the statement of the Lin–Zhao theorem; see Section 2.3 for
details.
For any finite set Y of formulas, by Y ∧ and Y ∨ we denote the conjunction and,
respectively, disjunction of the elements of Y. Using this notation, we can write (2)
as
(B∧ ∧ N) → a1

(6)

where B is the set {a2 . . . , am } of ‘positive body atoms,’ and N is the ‘negative part’
¬am+1 ∧ · · · ∧ ¬an .
For any set Y of atoms that occur in , the external support formula of Y, denoted
by ES (Y), is the disjunction of the bodies B∧ ∧ N of all rules (6) of  such that
•
•

a1 ∈ Y and
B ∩ Y = ∅.

The first condition expresses that the atom ‘supported’ by (6) is an element of Y. The
second condition expresses that this support is ‘external’: the atoms B that it relies
on do not belong to Y.
For instance, let  be program (3), and let Y be { p, q}. Elements of Y are
‘supported’ by each of the first three rules of (3), but in the case of the first two rules
the support is not ‘external.’ Accordingly, the external support formula of { p, q} is
the body of the third rule, ¬r.
Main theorem for traditional programs Let  be a traditional program, and let X
be a set of atoms occurring in . If X is a model of  then the following conditions
are equivalent:
(a) X is stable;
(b) For every set Y of atoms occurring in , X satisfies
Y ∨ → ES (Y);

(7)

(c) For every loop Y of , X satisfies (7);
(d) For every nonempty set Y of atoms occurring in , X satisfies
Y ∧ → ES (Y);

(8)

(e) For every loop Y of , X satisfies (8).
We call (7) the disjunctive loop formula of  corresponding to the set Y of atoms,
and (8) its conjunctive loop formula for Y. The two formulas coincide when Y is a
singleton.

Ann Math Artif Intell (2006) 47: 79–101

83

Y
Disjunctive loop formula Conjunctive loop formula
∅
⊥→ ⊥
{ p}
p→ (q ∨ ¬r)
p→ (q ∨ ¬r)
{q}
q→ p
q→ p
{r}
r→ ¬ p
r→ ¬ p
{ p, q}
( p ∨ q)→ ¬r
( p ∧ q)→ ¬r
{ p, r}
( p ∨ r)→ (q ∨ ¬r ∨ ¬ p)
( p ∧ r)→ (q ∨ ¬r ∨ ¬ p)
{q, r}
(q ∨ r)→ ( p ∨ ¬ p)
(q ∧ r)→ ( p ∨ ¬ p)
{ p, q, r} ( p ∨ q ∨ r)→ (¬r ∨ ¬ p)
( p ∧ q ∧ r)→ (¬r ∨ ¬ p)
Figure 2 The loop formulas of program (3)

For example, the loop formulas of program (3) are shown in figure 2. According to
the theorem above, a model of (3) is stable iff it satisfies each of the 8 disjunctive loop
formulas. We can also say that a model of (3) is stable iff it satisfies the disjunctive
loop formulas corresponding to the program’s loops (5):
p→
q→
r→
( p ∨ q) →

(q ∨ ¬r)
p
¬p
¬r.

(9)

Alternatively, the stable models of (3) can be characterized as the models of (3) that
satisfy the seven conjunctive loop formulas shown in figure 2, and, equivalently, as
the models of (3) that satisfy the four conjunctive loop formulas corresponding to the
program’s loops.
Some of the implications between conditions (a)–(e) are obvious: it is easy to see
that (b) implies both (c) and (d), and each of these two conditions implies (e). In
Section 2.3 we show that the equivalence between conditions (a) and (c) is essentially
a reformulation of the Lin–Zhao theorem. The equivalence between (a) and (d) is a
reformulation of another published result; this is discussed in Section 2.5.

2.3 Comparison with the Lin–Zhao theorem
We will now compare the theorem stated above with Theorem 1 from [15]. The
discussion here does not cover constraints (rules with empty heads), which are
allowed by Lin and Zhao but are not allowed in traditional programs.
The completion of a traditional program  is the set consisting of the following
equivalences, for the atoms a1 occurring in :
a1 ↔


(B∧ ∧ N);

(10)

84

Ann Math Artif Intell (2006) 47: 79–101

here the disjunction extends over all rules (6) of  with the head a1 . For instance, the
completion of (3) is
p ↔ (q ∨ ¬r)
q↔ p
r ↔ ¬ p.

(11)

We say that a loop L of a traditional program  is trivial if
•
•

L is a singleton, and
the dependency graph of  does not contain an edge from the element of L to
itself.

For instance, the loops { p}, {q}, {r} of program (3) are trivial; { p, q} is the only
nontrivial loop. If we add the rule r ← r to program (3) then the loop {r} will become
nontrivial. Nontrivial loops in the sense of this definition are loops in the sense of [15].
Lin–Zhao theorem
For any traditional program  and any set X of atoms
occurring in , X is a stable model of  iff X satisfies
(a) The completion of , and
(b) The disjunctive loop formulas for all nontrivial loops of .
For instance, the stable models { p, q} and {r} of (3) can be characterized as the
models of (11) that satisfy the last of the formulas (9).
The part of the theorem from Section 2.2 that asserts the equivalence between
conditions (a) and (c) is similar to the Lin–Zhao theorem. The difference is that the
former does not refer to completion, and the latter does not refer to loop formulas
for trivial loops.
It is not difficult to explain, however, why the set of formulas (a) and (b) above is
equivalent to the union of  with the set of the disjunctive loop formulas of  for all
loops, both trivial and nontrivial. Indeed, (a) can be equivalently rewritten as the set
of implications that consists of
(a ) The right-to-left implications from (10),
(a ) The left-to-right implications from (10) for the atoms a1 such that the loop {a1 }
is trivial, and
(a ) The left-to-right implications from (10) for the atoms a1 such that the loop {a1 }
is nontrivial.
Group (a ) is equivalent to . Each implication

a1 →
(a2 ∧ · · · ∧ am ∧ ¬am+1 ∧ · · · ∧ ¬an )

(12)

in group (a ) is identical to the loop formula
{a1 }∨ → ES ({a1 }),

(13)

because, for every rule (1) of  with the head a1 ,
B ∩ {a1 } = {a2 , . . . , am } ∩ {a1 } = ∅.
Finally, group (a ) can be dropped in the presence of (b), because each implication (12) in group (a ) is entailed by the corresponding loop formula (13): the

Ann Math Artif Intell (2006) 47: 79–101

85

loop formula can be obtained from (12) by dropping the disjunctive terms with
a1 ∈ {a2 , . . . , am }.
2.4 Extension to disjunctive programs
As an intermediate step before discussing the main theorem in full generality, we
will consider the special case of ‘disjunctive’ programs. Disjunctive rules are often
defined as expressions of the form
a1 ; . . . ; ak ← ak+1 , . . . , am , not am+1 , . . . , not an

(14)

(n ≥ m ≥ k ≥ 0), and the definition of a stable model from Appendix A can be
applied to finite sets of such rules if we treat (14) as alternative notation for the
formula
(ak+1 ∧ · · · ∧ am ∧ ¬am+1 ∧ · · · ∧ ¬an ) → (a1 ∨ · · · ∨ ak ).

(15)

The understanding of disjunctive rules in this section will be more general. We
say that a propositional formula is negative if every occurrence of every atom in this
formula is in the scope of a negation or in the antecedent of an implication. For
instance, the conjunction ¬am+1 ∧ · · · ∧ ¬an in (15) is negative; any formula of the
form F → ¬G is negative. The 0-place connectives 
 and ⊥ are negative formulas
also, because they don’t contain atoms. A disjunctive rule is a formula of the form
(B∧ ∧ N) → A∨

(16)

where A and B are finite sets of atoms, and N is a negative formula. For instance,
( p ∧ ¬(q ∧ ¬r)) → s
is a disjunctive rule in the sense of this definition; in the language of lparse,3 it can
be written as
s :- p, {q, not r}1.
A disjunctive program is a conjunction of (0 or more) disjunctive rules.
The definition of the dependency graph (Section 2.2) is extended to disjunctive
programs in a straightforward way: the vertices of the graph are the atoms occurring
in the program, and its edges go from the elements of A to the elements of B for all
rules (16) of the program. For instance, a rule of the form
(b 1 ∧ N) → (a1 ∨ a2 )
contributes two edges to the dependency graph: from a1 to b 1 and from a2 to b 1 .
Constraints (A = ∅) and rules with a negative body (B = ∅) don’t contribute edges
to the dependency graph.
The definition of a loop in terms of the dependency graph remains the same as in
Section 2.2.

3 http://www.tcs.hut.fi/Software/smodels/lparse.ps

.

86

Ann Math Artif Intell (2006) 47: 79–101

For any set Y of atoms that occur in a disjunctive program , the external support
formula of Y, denoted by ES (Y), is the disjunction of the formulas

¬a
(17)
B∧ ∧ N ∧
a∈A\Y

for all rules (16) of  such that
•
•

A ∩ Y  = ∅, and
B ∩ Y = ∅.

When  is a traditional program, this definition reduces to the definition of ES
given in Section 2.2.
The theorem from Section 2.2 remains correct after replacing ‘traditional program’ in its statement with ‘disjunctive program.’ The terms ‘disjunctive loop formula’ and ‘conjunctive loop formula’ will be applied to formulas (7) and (8) when 
is an arbitrary disjunctive program.
For instance, consider the program
p;s ← q
q← p
p ; r ← not s
which is the ‘logic programming representation’ of the formula
(q → ( p ∨ s)) ∧ ( p → q) ∧ (¬s → ( p ∨ r)).

(18)

The loops of this program are
{ p}, {q}, {r}, {s}, { p, q},
and the corresponding disjunctive loop formulas are
p → ((q ∧ ¬s) ∨ (¬s ∧ ¬r))
q→ p
r → (¬s ∧ ¬ p)
s → (q ∧ ¬ p)
( p ∨ q) → (¬s ∧ ¬r).

(19)

The stable models { p, q}, {r} of (18) can be characterized as the models of (18) that
satisfy (19).
2.5 Relation to unfounded sets
For programs consisting of rules of the form (14), the equivalence between conditions
(a) and (d) from the statement of the main theorem has been established earlier, in
a somewhat different form. Saccá and Zaniolo [21] showed that the stable models of
what we call here traditional programs can be characterized in terms of ‘unfounded

Ann Math Artif Intell (2006) 47: 79–101

87

sets’.4 Leone et al. [10] extended the notion of an unfounded set and the theorem by
Saccá and Zaniolo [21] to disjunctive rules of the form (14).
Their definition can be further extended to arbitrary disjunctive programs in the
sense of this section as follows. A set Y of atoms is unfounded by a disjunctive
program  w.r.t. a set X of atoms if, for each rule (16) of  such that A ∩ Y  = ∅,
•
•
•

X  |= B∧ ∧ N, or
B ∩ Y  = ∅, or
X ∩ (A \ Y)  = ∅.

It is easy to see that X |= ES (Y) iff Y is not unfounded by  w.r.t. X.
A set X of atoms is called unfounded-free if it has no nonempty subsets unfounded
w.r.t. X. The equivalence between conditions (a) and (d) can be reformulated as
follows: for any model X of a disjunctive program , X is stable iff X is unfoundedfree. This is a generalization of Corollary 2 from [21], and of Theorem 4.6 from [10].

3 General theory of loop formulas
Our goal now is to extend the definition of a loop and the definition of a loop formula,
stated above for traditional programs (Section 2.2) and for disjunctive programs
(Section 2.4), to the general case of arbitrary propositional formulas, and to state
the main theorem in full generality.
For simplicity, we assume here that the only propositional connectives allowed in
formulas are
⊥, ∧, ∨ and →,
and all other connectives are treated as abbreviations, as in Section B.3. For instance,
(2) is now viewed as an abbreviation for
(a2 ∧ · · · ∧ am ∧ (am+1 → ⊥) ∧ · · · ∧ (an → ⊥)) → a1 .

(20)

Under this simplifying assumption, the definition of a negative formula from
Section 2.4 can be stated as follows: a formula is negative if every occurrence of every
atom in this formula belongs to the antecedent of an implication.
3.1 Loops
An occurrence of a formula G in a formula F is positive if the number of implications
in F containing that occurrence in the antecedent is even; it is strictly positive if that
number is 0.5 In (20), for instance, the occurrences of a1 , am+1 , . . . , an are positive,
but only the first of them is strictly positive. It is clear that a formula F is negative iff
it has no strictly positive occurrences of atoms.

4 Their

theorem refers actually to ‘assumption sets’ rather than unfounded sets. But as the authors
noted, in the context of this theorem the two concepts are equivalent. Unfounded sets were originally
introduced for the purpose of characterizing the negative consequences of a program under the wellfounded semantics [23].

5 The

concept of a strictly positive occurrence plays an important role in intuitionistic logic; see, for
instance, [22, Theorem 4.2.3].

88

Ann Math Artif Intell (2006) 47: 79–101

Note that we apply the term ‘negative’ to formulas, and the terms ‘positive’ and
‘strictly positive’ to occurrences of one formula in another.
We say that an atom a depends on an atom b in an implication G → H if
•
•

a has a strictly positive occurrence in H, and
b has a positive occurrence in G that does not belong to any occurrence of a
negative formula in G.

The dependency graph of a formula F is the directed graph such that
•
•

Its vertices are the atoms that occur in F, and
It has an edge from a vertex a to a vertex b if a depends on b in an implication
that has a strictly positive occurrence in F.

In application to traditional programs, the new definition of the dependency graph
is equivalent to the definition from Section 2.2. Indeed, assume that F is a conjunction
of formulas of the form (20). Implications occurring in F are of two kinds: conjunctive
terms (20) and implications of the form ai → ⊥. The edges contributed to the
dependency graph by (20) go from a1 to a2 , . . . , am . Implications of the form ai → ⊥
do not contribute edges to the dependency graph.
More generally, in application to disjunctive programs the new definition of the
dependency graph is equivalent to the definition from Section 2.4. Indeed, assume
that F is a conjunction of formulas of the form (16). Implications occurring in F are
of two kinds: conjunctive terms (16) and implications that are subformulas of N in
one of these conjunctive terms. The edges contributed to the dependency graph by
the implications (16) go from elements of A to elements of B; these implications do
not contribute any other edges, because N is negative. Implications from N do not
contribute edges to the dependency graph: if an implication G → H has a strictly
positive occurrence in a negative formula N then H is a negative formula also, and
no occurrence of an atom in H can be strictly positive.
Consider now some formulas other than disjunctive programs. Formula
( p → q) ∨ r

(21)

is a disjunction of two traditional rules. Its dependency graph has one edge, from q
to p. The dependency graph of the nested implication
(( p → q) → r) → s
has two edges—from s to r and from s to p. The dependency graph of
(( p → ¬q) → r) → s
has only one edge, from s to r, because the formula p → ¬q is negative.
Given this definition of a dependency graph, loops are defined in the same way
as in Section 2.2: a loop of a formula F is a nonempty set of atoms occurring in F
such that the subgraph of the dependency graph of F induced by that set is strongly
connected.
3.2 Loop formulas
For any set Y of atoms occurring in a formula F, we want to define a formula that
would be similar to the external support formula ES F (Y) in the special case when F

Ann Math Artif Intell (2006) 47: 79–101

89

is a disjunctive program. It is easier to define a formula that essentially captures the
negation of ES F (Y).
Such a formula NES F (Y) is defined recursively, as follows:
•
•
•
•
•

for an atom a, NESa (Y) is ⊥ if a ∈ Y, and a otherwise;
NES⊥ (Y) = ⊥;
NES F∧G (Y) = NES F (Y) ∧ NESG (Y);
NES F∨G (Y) = NES F (Y) ∨ NESG (Y);
NES F→G (Y) = (NES F (Y) → NESG (Y)) ∧ (F → G).

For instance, if F is p → q then
NES F ({q}) = (NES p ({q}) → NESq ({q})) ∧ ( p → q)
= ( p → ⊥) ∧ ( p → q)
↔ ¬ p.
The definitions of ES and NES look very different from each other. But the calculation above shows that in the case of p → q the formula NES F ({q}) is equivalent to
the negation of the external support formula p of {q}. The following proposition
shows that NES (Y) is ‘almost equivalent’ to the negation of ES (Y) for any
disjunctive program :
Theorem 1 If X is a model of a disjunctive program  then, for any set Y of atoms,
X |= NES (Y) iff X |= ¬ES (Y).
This fact suggests that ¬NES F (Y) may be an acceptable counterpart of the
external support formula of Y when F is syntactically different from disjunctive
programs. The main theorem, stated in the next section, shows that this is indeed
the case. Its statement refers to the formulas
Y ∨ → ¬NES F (Y)

(22)

Y ∧ → ¬NES F (Y),

(23)

and

which can be called the (disjunctive and conjunctive) loop formulas of a formula F
corresponding to the set Y of atoms.
3.3 Main theorem
The definition of a stable model for arbitrary propositional formulas is discussed in
Appendix A.
Theorem 2 (Main Theorem) Let F be a propositional formula, and let X be a set of
atoms occurring in F. If X is a model of F then the following conditions are equivalent:
(a) X is stable;
(b) For every set Y of atoms occurring in F, X satisfies (22);
(c) For every loop Y of F, X satisfies (22);

90

Ann Math Artif Intell (2006) 47: 79–101

(d) For every nonempty set Y of atoms occurring in F, X satisfies (23);
(e) For every loop Y of F, X satisfies (23).
Theorem 1 shows that the theorem stated in Section 2.2 and its extension to
disjunctive programs (Section 2.4) can be viewed as special cases of Theorem 2.
As an example, let’s apply Theorem 2 to formula (21). Its loops are the singletons
{ p}, {q}, {r}, and the corresponding loop formulas (22) are
p → ¬(((⊥ → q) ∧ ( p → q)) ∨ r),
q → ¬((( p → ⊥) ∧ ( p → q)) ∨ r),
r → ¬((( p → q) ∧ ( p → q)) ∨ ⊥).
The conjunction of these formulas is equivalent to
¬q ∧ ¬r.

(24)

According to the main theorem, the stable models of (21) can be characterized as the
sets that satisfy both (21) and (24). The conjunction of (21) with (24) is equivalent to
¬ p ∧ ¬q ∧ ¬r, so that the only stable model of (21) is ∅.

4 Proofs
4.1 Proof of theorem 1
Lemma 1 For any formula F and any set Y of atoms,
(a) NES F (Y) entails F;
(b) If F has no strictly positive occurrences of atoms from Y then NES F (Y) is
equivalent to F.

Proof (a) By induction on F. (b) By induction on F; consider the case when F
is G → H. By (a), NESG (Y) entails G; by the induction hypothesis, NES H (Y) is
equivalent to H. Consequently,

NES F (Y) = (NESG (Y) → NES H (Y)) ∧ (G → H)
↔ (NESG (Y) → H) ∧ (G → H)
↔ ((NESG (Y) ∨ G) → H)
↔ (G → H)
= F.



Ann Math Artif Intell (2006) 47: 79–101

91

Theorem 1 If X is a model of a disjunctive program  then, for any set Y of atoms,
X |= NES (Y) iff X |= ¬ES (Y).
Proof Since NES (Y) is the conjunction of the formulas NES R (Y) for all rules R
of , and ES (Y) is the disjunction of the formulas ES R (Y), it is sufficient to consider
the case when  is a single rule (16). In this case, ¬ES (Y) is equivalent to
(B∧ ∧ N) → (A \ Y)∨

(25)

if A ∩ Y  = ∅ and B ∩ Y = ∅, and is 
 otherwise. We need to show, assuming (16), that this formula is equivalent to NES (Y). In the presence of (16), using
Lemma 1(a),
NES (Y) = (NES B∧ ∧N (Y) → NES A∨ (Y)) ∧ ((B∧ ∧ N) → A∨ )
↔ NES B∧ ∧N (Y) → NES A∨ (Y)
↔ (NES B∧ (Y) ∧ NES N (Y)) → NES A∨ (Y)
↔ (NES B∧ (Y) ∧ N) → NES A∨ (Y)
↔ (NES B∧ (Y) ∧ N) → (A \ Y)∨ .
If B ∩ Y  = ∅ then the last formula contains the conjunctive term ⊥ in the antecedent,
and consequently is equivalent to 
. Otherwise, it can be rewritten as (25). It
remains to note that if A ∩ Y = ∅ then (25) is identical to the assumption (16) and
consequently can be rewritten as 
.


4.2 Proof of theorem 2: equivalence of (a), (b), (d)
In the following lemma, F is a propositional formula, and a is a list of distinct atoms
−
→
a1 , . . . , an containing all atoms occurring in F. For the definitions of F ∗ (v) and Y ,
see Section B.3.
−−−→
Lemma 2 For any sets X, Y of atoms, X |= NES F (Y) iff X |= F ∗ ( X \ Y).
Proof By induction on F. Consider the case when F is an atom. If F ∈ Y then each of
−−−→
−−−→
the formulas NES F (Y), F ∗ ( X \ Y) is ⊥. Otherwise NES F (Y) is F, while F ∗ ( X \ Y)
is 
 or ⊥ depending on whether F ∈ X. The other cases are straightforward.

Proof of the equivalence of conditions (a), (b), (d) in the statement of Theorem 2 Let a
be the list of atoms occurring in F, and let a subset X of a be a model of F. By
the Pearce–Tompits–Woltran theorem, and in view of the fact that PTW[F] can be
written in the form (32), condition (a) (‘X is stable’) is equivalent to
 −
→
−
→
X |=
( Y < a → ¬F ∗ ( Y ))
Y⊆a

92

Ann Math Artif Intell (2006) 47: 79–101

and consequently to
X |=



−
→
¬F ∗ ( Y ).

Y⊂X

Using Lemma 2, we can show that this condition is equivalent to condition (b):


−
→
−−−−→
¬F ∗ ( Y ) iff X |=
¬F ∗ ( X \ Z )
X |=
Z ⊆a: Z ∩X=∅

Y⊂X



iff X |=

¬NES F (Z )

Z ⊆a: Z ∩X=∅

iff X |=



(Z ∨ → ¬NES F (Z ))

Z ⊆a

iff X |= Z ∨ → ¬NES F (Z )
for all subsets Z of a.
It is also equivalent to (d):

−
→
X |=
¬F ∗ ( Y ) iff X |=



−−−−→
¬F ∗ ( X \ Z )

Z ⊆a: Z ⊆X, Z =∅

Y⊂X

iff X |=



¬NES F (Z )

Z ⊆a: Z ⊆X, Z =∅

iff X |=



(Z ∧ → ¬NES F (Z ))

Z ⊆a: Z =∅

iff X |= Z ∧ → ¬NES F (Z )
for all nonempty subsets Z of a.


4.3 Proof of theorem 2: equivalence of (c), (e) to the other conditions
Lemma 3 For any formula F, set Y of atoms, and subset Z of Y,
(a) If every positive occurrence of every atom from Y \ Z in F belongs to a
negative formula then NES F (Z ) entails NES F (Y);
(b) If every nonpositive occurrence of every atom from Y \ Z in F belongs to a
negative formula then NES F (Y) entails NES F (Z ).

Proof Both parts are proved simultaneously by induction on F. Assume that F is an
atom. (a) Since every positive occurrence of every atom from Y \ Z in F belongs to
a negative formula, F  ∈ Y \ Z , so that NES F (Z ) is the same formula as NES F (Y).
(b) Since Z is a subset of Y, NES F (Y) is equal to NES F (Z ) or to ⊥. The cases when F
is ⊥, a conjunction or a disjunction are straightforward. Assume that F is G → H.
If F is negative then, by Lemma 1(b), each of the formulas NES F (Y), NES F (Z ) is
equivalent to F. Assume that F is not negative. (a) Every nonpositive occurrence

Ann Math Artif Intell (2006) 47: 79–101

93

of every atom from Y \ Z in G belongs to a negative formula, and so does every
positive occurrence of every atom from Y \ Z in H. We need to show that
(NESG (Z ) → NES H (Z )) ∧ (G → H)
entails
(NESG (Y) → NES H (Y)) ∧ (G → H),
This is clear from the fact that, by the induction hypothesis, NESG (Y) entails
NESG (Z ) and NES H (Z ) entails NES H (Y). (b) Similar.


Lemma 4 For any formula F and any nonempty set Y of atoms, there exists a subset
Z of Y such that
(a) Z is a loop of F, and
(b) The dependency graph of F has no edges from atoms in Z to atoms in Y \ Z .
Proof Consider the strongly connected components of the subgraph of the dependency graph of F induced by Y. They form a finite acyclic graph. Any terminal vertex
of that graph satisfies conditions (a) and (b).


Lemma 5 Let X be a model of a formula F, Y a set of atoms, and Z a nonempty
subset of Y such that the dependency graph of F has no edges from atoms in Z to
atoms in Y \ Z . If X |= NES F (Y) then X |= NES F (Z ).
Proof By induction on F.
Case 1: F is an atom or ⊥. Then the NES F (Y) is equal to NES F (Z ) or to ⊥.
Case 2: F is G ∧ H. All edges in the dependency graphs of G and H belong to the
dependency graph of F, so that the inductive hypothesis can be applied both to G
and to H.
Case 3: F is G ∨ H. Similar to Case 2.
Case 4: F is G → H. Assume that the dependency graph of F has no edges from
Z to Y \ Z , and that X satisfies NES F (Y):
X |= (NESG (Y) → NES H (Y)) ∧ (G → H)

(26)

but doesn’t satisfy NES F (Z ):
X  |= (NESG (Z ) → NES H (Z )) ∧ (G → H).

(27)

Since X is a model of G → H, X doesn’t satisfy the first conjunctive term of (27), so
that
X |= NESG (Z )

(28)

X  |= NES H (Z ).

(29)

and

By Lemma 1(a), (28) implies X |= G. Since X is a model of G → H, it follows that
X |= H. In combination with (29) and Lemma 1(b), this fact shows that H contains
a strictly positive occurrence of an atom from Z . Since there are no edges from Z
to Y \ Z in the dependency graph of F, it follows that every positive occurrence of

94

Ann Math Artif Intell (2006) 47: 79–101

every atom from Y \ Z in G belongs to a negative formula. By Lemma 3(a), we can
conclude that NESG (Z ) entails NESG (Y). Then, in view of (28), X |= NESG (Y). By
(26), it follows that X |= NES H (Y). Since every edge in the dependency graph of H
belongs to the dependency graph of F, the inductive hypothesis is applicable to H,
and we can further conclude that X |= NES H (Z ), which contradicts (29).


Proof of the equivalence of conditions (d) and (e) in the statement of Theorem 2 Let X
be a model of F. It is clear that (d) implies (e). Assume that (d) does not hold, and
let Y be a nonempty set of atoms such that X does not satisfy loop formula (23), so
that
X |= Y ∧

(30)

X |= NES F (Y).

(31)

and

By Lemma 4, there exists a subset Z of Y such that Z is a loop of F, and the
dependency graph of F has no edges from Z to Y \ Z . From (30) we conclude that
X |= Z ∧ . By Lemma 5, (31) implies that X |= NES F (Z ). Consequently (e) does not
hold either.


Proof of the equivalence of condition (c) to the other conditions in the statement of
Theorem 2 Clearly (b) implies (c), and (c) implies (e). On the other hand, we have
already established that (b) is equivalent to (e).



5 Conclusion
We modified the definition of a loop due to Lin and Zhao so that the reference to
the program’s completion in the statement of their theorem became unnecessary,
and generalized the theorem, first to disjunctive programs, and then to arbitrary
propositional formulas.
In the most general framework, the definition of the dependency graph is guided
by three ideas. First, rules of a given program can be viewed as implications that
occur in it strictly positively. Second, head atoms of a rule can be viewed as atoms
that occur in its head strictly positively. Third, positive body atoms of a rule can be
viewed as atoms that occur in the body positively and do not belong to any negative
formula.
The most general definition of a loop formula, on the other hand, is motivated
by a relationship between external support formulas and a syntactic transformation
introduced by Pearce, Tompits and Woltran.
In this paper we did not discuss logic programs with two negations [7], which are
important in many applications to knowledge representation. Instead of treating the
second negation as an additional syntactic construct, we can think of it in terms of
distinguishing between atoms of two kinds, coming in ‘complementary pairs,’ and in
terms of ‘coherent’ stable models [4][Section 3.9].

Ann Math Artif Intell (2006) 47: 79–101

95

Acknowledgements We are grateful to the anonymous referees for useful suggestions. This research was partially supported by the National Science Foundation under Grant IIS-0412907.

Appendix A: Definition of a stable model
Atoms and formulas are understood here as in propositional logic. As usual, we
identify truth assignments with sets of atoms; for instance, the truth assignment that
makes the atom p true and all other atoms false is identified with { p}. A model of a
formula F is a set of atoms that satisfies F.
According to [4, Section 2.1], the reduct F X of a formula F relative to a set X of
atoms is the formula obtained from F by replacing each maximal subformula that is
not satisfied by X with ⊥ (‘false’). We say that X is a stable model (or an answer set)
of F if X is minimal among the sets satisfying F X . The minimality of X is understood
here in the sense of set inclusion.
Clearly, every set that is a stable model of F according to this definition is a model
of F. Indeed, if X does not satisfy F then F X is ⊥.
Thus we can verify that X is a stable model of F as follows:
(a) Mark in F the maximal subformulas that are not satisfied by X;
(b) Replace each of these subformulas with ⊥ (after that, equivalent transformations of classical propositional logic can be used to simplify the result);
(c) Check that the resulting formula is satisfied by X;
(d) Check that it is not satisfied by any proper subset of X.
For instance, to check that {r} is a stable model of (4), we do the following:
(a) Mark the maximal subformulas of (4) that are not satisfied by {r}:
(q → p) ∧ ( p → q) ∧ (¬r → p) ∧ (¬ p → r);
(b) Replace these subformulas with ⊥:
(⊥ → ⊥) ∧ (⊥ → ⊥) ∧ (⊥ → ⊥) ∧ (¬⊥ → r);
simplify:
r;
(c) Check that the last formula is satisfied by {r};
(d) Check that it is not satisfied by ∅.
As another example, the model {r} of formula (21) is not stable:
(a) Mark the maximal subformulas of (21) that are not satisfied by {r}:
( p → q) ∨ r;
(b) Replace these subformulas with ⊥:
(⊥ → ⊥) ∨ r;
simplify:

.

96

Ann Math Artif Intell (2006) 47: 79–101

The last formula is satisfied by {r}, but it is also satisfied by the proper subset ∅ of {r}.
In fact, the only stable model of (21) is ∅.

Appendix B: Propositional circumscription
and the Pearce–Tompits–Woltran theorem
The Pearce–Tompits–Woltran theorem is about a syntactic transformation that is
similar to circumscription [14, 16, 17]. For this reason, our review includes a brief
discussion of that concept.
B.1 Second-order propositional formulas
Second-order propositional formulas (also known as quantified Boolean formulas)
are formed from propositional atoms (in this paper, p, q, . . . ) and an infinite supply
of propositional variables (x, y, . . . ) using propositional connectives and the quantifiers ∀, ∃. The usual recursive definition of satisfaction for propositional formulas is
extended to second-order propositional formulas without free variables as follows:
a truth assignment (or a set of atoms) satisfies ∀v F(v) if it satisfies both F(⊥) and
F(
); it satisfies ∃v F(v) if it satisfies at least one of these two formulas. A secondorder propositional formula is logically valid if its universal closure is satisfied by all
truth assignments.
Quantifiers can be eliminated from any second-order propositional formula by
repeatedly replacing parts of the form ∀v F(v) with F(⊥) ∧ F(
), and parts of the
form ∃v F(v) with F(⊥) ∨ F(
). This transformation turns logically valid formulas
without free variables into tautologies. For example,
∀x∃y(y ↔ p ∧ x) ↔ ∃y(y ↔ p ∧ 
) ∧ ∃y(y ↔ p ∧ ⊥)
↔ ∃y(y ↔ p) ∧ ∃y¬y
↔ ((
 ↔ p) ∨ (⊥ ↔ p)) ∧ (¬
 ∨ ¬⊥)
↔ 
.
B.2 Propositional circumscription
The review of circumscription in this section is limited to the propositional case of
parallel circumscription with no varied constants.
Let a be a tuple of distinct atoms a1 , . . . , an , and F(a) a propositional formula
(possibly containing other atoms as well). The circumscription of a in F(a), denoted
by CIRC[F(a); a], is the second-order propositional formula
F(a) ∧ ¬∃v(v < a ∧ F(v)),
where v is a tuple of n distinct propositional variables v1 , . . . , vn , and v < a stands for
(v1 → a1 ) ∧ · · · ∧ (vn → an ) ∧ ¬((a1 → v1 ) ∧ · · · ∧ (an → vn )).

Ann Math Artif Intell (2006) 47: 79–101

97

For instance,

CIRC [ p ∨ q; p] = ( p ∨ q) ∧ ¬∃x(x < p ∧ (x ∨ q))
↔ ( p ∨ q) ∧ ¬((⊥ < p ∧ (⊥ ∨ q)) ∨ (
 < p ∧ (
 ∨ q)))
↔ ( p ∨ q) ∧ ¬(( p ∧ q) ∨ (⊥ ∧ 
))
↔ ( p ∨ q) ∧ ¬( p ∧ q).
B.3 Pearce–Tompits–Woltran theorem
In this section we assume that the connectives used in propositional formulas are
⊥, ∧, ∨ and →;

 stands for ⊥ → ⊥, ¬F for F → ⊥, and F ↔ G for (F → G) ∧ (G → F).
Let a1 , . . . , an be all atoms occurring in a propositional formula F. By PTW[F] we
denote the second-order propositional formula
F ∧ ¬∃v(v < a ∧ F ∗ (v)),
where a stands for a1 , . . . , an , v is a tuple of n distinct propositional variables
v1 , . . . , vn , and F ∗ (v) is defined recursively, as follows:
•
•
•
•
•

(ai )∗ = vi ;
⊥∗ = ⊥;
(F ∧ G)∗ = F ∗ ∧ G∗ ;
(F ∨ G)∗ = F ∗ ∨ G∗ ;
(F → G)∗ = (F ∗ → G∗ ) ∧ (F → G).

For instance, let F be the formula p ∧ ( p → (q ∨ r)), corresponding to the disjunctive program
p
q ; r ← p.
Then
F ∗ = p∗ ∧ ( p → (q ∨ r))∗
= p∗ ∧ ( p∗ → (q ∨ r)∗ ) ∧ ( p → (q ∨ r))
= p∗ ∧ ( p∗ → (q∗ ∨ r∗ )) ∧ ( p → (q ∨ r))
= x ∧ (x → (y ∨ z)) ∧ ( p → (q ∨ r))
↔ x ∧ (y ∨ z) ∧ ( p → (q ∨ r))

98

Ann Math Artif Intell (2006) 47: 79–101

and
PTW[F] ↔ p ∧ ( p → (q ∨ r))
∧ ¬∃xyz((x, y, z) < ( p, q, r)
∧ x ∧ (y ∨ z) ∧ ( p → (q ∨ r)))
↔ p ∧ (q ∨ r)
∧¬∃xyz((x, y, z) < ( p, q, r) ∧ x ∧ (y ∨ z))
↔ p ∧ (q ∨ r) ∧ ¬∃yz((
, y, z) < ( p, q, r) ∧ (y ∨ z))
↔ p ∧ (q ∨ r) ∧ ¬∃yz((y, z) < (q, r) ∧ p ∧ (y ∨ z))
↔ p ∧ (q ∨ r) ∧ ¬∃yz((y, z) < (q, r) ∧ (y ∨ z))
↔ p ∧ (q ∨ r) ∧ ¬∃yz((¬y ∧ z ∧ q ∧ r)
∨ (y ∧ ¬z ∧ q ∧ r))
↔ p ∧ (q ∨ r) ∧ ¬((q ∧ r) ∧ ∃yz((¬y ∧ z) ∨ (y ∧ ¬z))
↔ p ∧ (q ∨ r) ∧ ¬((q ∧ r) ∧ 
)
↔ p ∧ (q ∨ r) ∧ ¬(q ∧ r).
The sets satisfying PTW[F] are { p, q} and { p, r}, which are the two stable models
of F. This is an instance of a general theorem:
Pearce–Tompits–Woltran Theorem ([19], Theorem 1)
in F is a stable model of F iff X satisfies PTW[F].

A set X of atoms occurring

To be precise, the statement of this result in [19] refers to equilibrium models, and
its reformulation above refers to stable models in the sense of Appendix A; these
two concepts are equivalent to each other by Theorem 1 from [5]. A direct proof of
our version of the theorem, not referring to this equivalence, is given in Section B.4
below.
Recall that the operation F  → F ∗ (v) replaces the atoms from a with the corresponding variables from v, and that it commutes with all connectives except
implication. If we drop the second conjunctive term from the clause for implication
in the definition of F ∗ then F ∗ will turn into the result of substituting v for a in F, and
PTW[F] will turn into CIRC [F; a].
In one way, however, the operation F  → F ∗ (v) is essentially different from the
substitution of v for a: for two equivalent formulas F and G, F ∗ (v) is not necessarily
equivalent to G∗ (v). Here is an example:
( p → q)∗ = (x → y) ∧ ( p → q),
(¬ p ∨ q)∗ = ( p → ⊥)∗ ∨ q∗
= (( p∗ → ⊥∗ ) ∧ ( p → ⊥)) ∨ y
= (¬x ∧ ¬ p) ∨ y
↔ (x → y) ∧ ( p → y).
Applying the circumscription operator to each of two equivalent formulas gives two
equivalent results; the Pearce–Tompits–Woltran transformation does not have this
property.

Ann Math Artif Intell (2006) 47: 79–101

99

The result of eliminating quantifiers from PTW[F] (see Section B.1) can be
−
→
represented using the following notation. For any subset Y of a, by Y we denote
the tuple (Y1 , . . . , Yn ), where


, if ai ∈ Y;
Yi =
⊥, otherwise.
Then PTW[F] can be written as
F ∧¬

 −
→
−
→
(( Y < a ∧ F ∗ ( Y ))
Y⊆a

or, equivalently, as
F∧

 −
→
−
→
( Y < a → ¬F ∗ ( Y )).

(32)

Y⊆a

B.4 Proof
In the following lemma, F is a propositional formula, and a is a list of distinct atoms
a1 , . . . , an containing all atoms occurring in F.
Lemma For any subset X of a and any Y ⊆ X,
−
→
Y |= F X iff X |= F ∗ ( Y ).

Proof by induction on F.
−
→
Case 1: F is an atom ai , so that F ∗ (a) is vi . If ai ∈ X then F X is ai ; F ∗ ( Y ) is 
or ⊥ depending on whether or not ai ∈ Y, that is, depending on whether or not Y
−
→
satisfies F X . Otherwise F X is ⊥; since Y ⊆ X, ai  ∈ Y, so that F ∗ ( Y ) is ⊥ too.
−
→
Case 2: F is ⊥. Each of the formulas F X , F ∗ ( Y ) is ⊥.
−
→
−
→
−
→
Case 3: F is G ∧ H, so that F ∗ ( Y ) is G∗ ( Y ) ∧ H ∗ ( Y ). If X satisfies G ∧ H
then F X is G X ∧ H X , and we use the induction hypothesis. Otherwise F X is ⊥,
and X doesn’t satisfy at least one of the formulas G, H. Assume, for instance, that
−
→
X  |= G. Then G X is ⊥, and, by the induction hypothesis, X  |= G∗ ( Y ). It follows that
−
→
X  |= F ∗ ( Y ).
−
→
−
→
−
→
Case 4: F is G ∨ H, so that F ∗ ( Y ) is G∗ ( Y ) ∨ H ∗ ( Y ). If X satisfies G ∨ H
then F X is G X ∨ H X , and we use the induction hypothesis. Otherwise F X is ⊥,
and X satisfies neither G nor H. Then each of the formulas G X , H X is ⊥, and,
−
→
−
→
by the induction hypothesis, X satisfies neither G∗ ( Y ) nor H ∗ ( Y ). It follows that
−
→
X  |= F ∗ ( Y ).
−
→
Case 5: F is G → H, so that F ∗ ( Y ) is
−
→
−
→
(G∗ ( Y ) → H ∗ ( Y )) ∧ (G → H).

(33)

If X satisfies the second term G → H of (33) then F X is G X → H X ; from the
induction hypothesis we conclude that X satisfies this formula iff it satisfies the first

100

Ann Math Artif Intell (2006) 47: 79–101

term of (33). Otherwise F X is ⊥; X doesn’t satisfy (33) because it doesn’t satisfy the
second conjunctive term.
−
→
Proof of Pearce–Tompits–Woltran Theorem It is clear that X satisfies Y < a iff Y
is a proper subset of X. Using the representation (32) of PTW[F], we conclude that
X |= PTW[F] iff
(a) X |= F, and
−
→
(b) for every proper subset Y of X, X  |= F ∗ ( Y ).
It is easy to check by induction on F that X |= F X iff X |= F. Using this fact and the
lemma above, we can restate conditions (a) and (b) as follows:
(a ) X |= F X , and
(b ) for every proper subset Y of X, Y  |= F X .
This is equivalent to saying that X is a stable model of F.

References
1. Clark, K.: Negation as failure. In: Gallaire, H., Minker, J. (eds.) Logic and Data Bases, pp. 293–
322. Plenum, New York (1978)
2. Erdem, E., Lifschitz, V.: Tight logic programs. Theory and Pract. Log. Prog. 3, 499–518 (2003)
3. Fages, F.: Consistency of Clark’s completion and existence of stable models. J. Meth. Log.
Comput. Sci. 1, 51–60 (1994)
4. Ferraris, P., Lifschitz, V.: Mathematical foundations of answer set programming. In: We Will
Show Them! Essays in Honour of Dov Gabbay, vol. 1, pp. 615–664. King’s College, London
(2005)
5. Ferraris, P.: Answer sets for propositional theories. In: Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), Cosenza, Italy, 119–131,
(2005)
6. Gelfond, M., Lifschitz, V.: The stable model semantics for logic programming. In: Kowalski, R.,
Bowen, K. (eds.) Proceedings of International Logic Programming Conference and Symposium,
MIT, Cambridge, Massachusetts, 1070–1080 (1988)
7. Gelfond, M., Lifschitz, V.: Logic programs with classical negation. In: Warren D., Szeredi
P. (eds.) Proceedings of International Conference on Logic Programming (ICLP), Jerusalem,
Israel, 579–597, June (1990)
8. Lee, J., Lifschitz, V.: Loop formulas for disjunctive logic programs. In: Proceedings of International Conference on Logic Programming (ICLP), Mumbai, India, 451–465, December (2003)
9. Lee, J.: A model-theoretic counterpart of loop formulas. In: Proceedings of International Joint
Conference on Artificial Intelligence (IJCAI), Edinburgh, Scotland, 503–508 (2005)
10. Leone, N., Rullo, P., Scarcello, F.: Disjunctive stable models: Unfounded sets, fixpoint semantics,
and computation. Inf. Comput. 135(2), 69–112 (1997)
11. Lierler, Y.: Cmodels: SAT-based disjunctive answer set solver. In: Proceedings of International
Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), Diamante, Italy,
447–452 (2005)
12. Lifschitz, V., Razborov, A.: Why are there so many loop formulas? ACM Trans. Comput. Log.
7(2), 261–268 (2006)
13. Lifschitz, V., Tang, L.R., Turner, H.: Nested expressions in logic programs. Ann. Math. Artif.
Intell. 25, 369–389 (1999)
14. Lifschitz, V.: Circumscription. In: Gabbay, D.M., Hogger, C.J., Robinson, J.A., (eds.) The Handbook of Logic in AI and Logic Programming, vol.3 pp. 298–352. Oxford University Press, UK
(1994)
15. Lin, F., Zhao, Y.: ASSAT: Computing answer sets of a logic program by SAT solvers. Artif.
Intell. 157, 115–137 (2004)

Ann Math Artif Intell (2006) 47: 79–101

101

16. McCarthy J.: Circumscription—a form of non-monotonic reasoning. Artif. Intell. 13, 27–39, 171–
172 (1980)
17. McCarthy J. Applications of circumscription to formalizing common sense knowledge. Artif.
Intell. 26(3), 89–116 (1986)
18. McCarthy J.: Formalizing Common Sense: Papers by John McCarthy. Ablex, Norwood, New
Jersey (1990)
19. Pearce, D., Tompits, H., Woltran, S.: Encodings for equilibrium logic and logic programs with
nested expressions. In: Proceedings of Portuguese Conference on Artificial Intelligence (EPIA),
Porto, Portugal, 306–320 (2001)
20. Pearce, D.: A new logical characterization of stable models and answer sets. In: Dix, J., Pereira
L., Przymusinski, T. (eds.) Non-Monotonic Extensions of Logic Programming (Lecture Notes in
Artificial Intelligence 1216), pp. 57–70. Springer, Berlin Heidelberg New York (1997)
21. Saccá, D., Zaniolo, C.: Stable models and non-determinism in logic programs with negation.
In: Proceedings of ACM Symposium on Principles of Database Systems (PODS), Nashville,
Tennesse 205–217 (1990)
22. Troelstra, A.S., Schwichtenberg, H.: Basic Proof Theory. Cambridge University Press, UK (1996)
23. Van Gelder, A., Ross K., Schlipf J.: The well-founded semantics for general logic programs.
J. ACM 38(3), 620–650 (1991)

C Cambridge University Press 2011. This is a work of the
TLP 12 (3): 383–412, 2012. 
U.S. Government and is not subject to copyright protection in the United States.

doi:10.1017/S1471068411000081

383

First published online 25 May 2011

Representing ﬁrst-order causal theories
by logic programs
PAOLO FERRARIS
Google Inc., CA 94043, USA
(e-mail: otto@cs.utexas.edu)

JOOHYUNG LEE
School of Computing, Informatics and Decision Systems Engineering, Arizona State University,
Tempe, AZ 85287-8809, USA
(e-mail: joolee@asu.edu)

YULIYA LIERLER
Computer Science Department, University of Kentucky, Lexington, KY 40506-0046, USA
(e-mail: yuliya@cs.utexas.edu)

VLADIMIR LIFSCHITZ and FANGKAI YANG
Department of Computer Science, University of Texas at Austin, Austin, TX 78712-0233, USA
(e-mail: {vl,fkyang}@cs.utexas.edu)

submitted 16 August 2010; revised 21 February 2011; accepted 16 March 2011

Abstract
Nonmonotonic causal logic, introduced by McCain and Turner (McCain, N. and Turner,
H. 1997. Causal theories of action and change. In Proceedings of National Conference on
Artiﬁcial Intelligence (AAAI), Stanford, CA, 460–465) became the basis for the semantics
of several expressive action languages. McCain’s embedding of deﬁnite propositional causal
theories into logic programming paved the way to the use of answer set solvers for answering
queries about actions described in such languages. In this paper we extend this embedding to
nondeﬁnite theories and to the ﬁrst-order causal logic.
KEYWORDS: reasoning about actions, nonmonotonic causal logic, answer set programming

1 Introduction
Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became the basis for the semantics of several expressive action languages
(Giunchiglia and Lifschitz 1998; Giunchiglia et al . 2004; Lifschitz and Ren 2006;
Lifschitz and Ren 2007; Ren 2009). The Causal Calculator (CCalc)1 is a partial
implementation of this logic that allows us to automate some types of reasoning
and planning in action domains described in such languages. It has been used to
1

http://www.cs.utexas.edu/users/tag/ccalc/

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

384

P. Ferraris et al.

solve several challenging commonsense reasoning problems, including problems of
nontrivial size (Akman et al . 2004), to provide a group of robots with high-level
reasoning (Caldiran et al . 2009), to give executable speciﬁcations of norm-governed
computational societies (Artikis et al . 2009), and to automate the analysis of business
processes under authorization constraints (Armando et al . 2009).
An important theorem due to McCain (1997, Proposition 6.7) shows how to embed
a fragment of propositional causal logic into the language of logic programming
under the answer set semantics (Gelfond and Lifschitz 1991). This result, reviewed
below, paved the way to the development of an attractive alternative to CCalc –
the software system coala (Gebser et al . 2010) that uses answer set programming
(Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2008) for answering queries
about actions described in causal logic.
A causal theory in the sense of McCain and Turner (1997) is a set of “causal
rules” of the form F ⇐ G, where F and G are propositional formulas (the head
and the body of the rule). The rule reads “F is caused if G is true.” Distinguishing
between being true and having a cause turned out to be essential for the study of
commonsense reasoning. The assertion, “if the light is on at time 0 and you toggle
the switch then the light will be oﬀ at time 1,” can be written as an implication:
on 0 ∧ toggle → ¬on 1 .
In causal logic, on the other hand, we can express that under the same assumption
there is a cause for the light to be oﬀ at time 1:
¬on 1 ⇐ on 0 ∧ toggle.
(Performing the toggle action is the cause.) McCain and Turner (1997) showed that
distinctions like this help us solve the frame problem (see Example 5 in Section 5.2)
and overcome other diﬃculties arising in the theory of reasoning about actions.
The semantics of theories of this kind deﬁnes when a propositional interpretation
(truth assignment) is a model of the given theory (is “causally explained” by the
theory, in the terminology of McCain and Turner (1997)). We do not reproduce the
deﬁnition here, because a more general semantics is described in Section 3. But here
is an example: the causal theory
p ⇐ ¬q
¬q ⇐ p

(1)

has one model, according to the semantics from (McCain and Turner 1997). In this
model, p is true and q is false. (Since the bodies of both rules are true in this model,
both rules “ﬁre”; consequently the heads of the rules are “caused”; consequently the
truth values of both atoms are “causally explained.” This will be discussed formally
in Section 3.)
McCain’s translation (1997) is applicable to a propositional causal theory T if the
head of each rule of T is a literal, and the body is a conjunction of literals:
L ⇐ A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ · · · ¬An .

(2)

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

385

The corresponding logic program consists of the logic programming rules
L ← not ¬A1 , . . . , not ¬Am , not Am+1 , . . . , not An

(3)

for all rules (2) of T . This program involves two types of negations: negation as
failure (not), and strong or classical negation (¬). According to Proposition 6.7
from McCain (1997), complete answer sets of this logic program are identical to the
models of T . (A set of literals is complete if it contains exactly one member of each
complementary pair of literals A, ¬A. We identify a complete set of literals with the
corresponding truth assignment.)
For instance, McCain’s translation (1997) turns causal theory (1) into
p ← not q,
¬q ← not ¬p.

(4)

The only answer set of this program is {p, ¬q}. It is complete, and corresponds to
the model of causal theory (1).
In this paper we generalize McCain’s translation (1997) in several ways. First, we
discard the requirement that the bodies of the given causal rules be conjunctions of
literals. Second, instead of requiring that the head of each causal rule be a literal,
we allow the heads to be disjunctions of literals. In this more general setting, the
logic program corresponding to the given causal theory becomes disjunctive as well.
Third, we study causal rules with heads of the form L1 ↔ L2 , where L1 and
L2 are literals. Such a rule says that there is a cause for L1 and L2 to be
equivalent (“synonymous”) under some condition, expressed by the body of the rule.
Synonymity rules play an important role in the theory of commonsense reasoning
in view of the fact that humans often explain the meaning of words by referring to
their synonyms. A synonymity rule
L1 ↔ L2 ⇐ G

(5)

can be translated into logic programming by rewriting it as the pair of rules
L1 ∨ L2 ⇐ G,
L1 ∨ L2 ⇐ G,
where L stands for the literal complementary to L, and then using our extension
of McCain’s translation to rules with disjunctive heads. It turns out, however, that
there is no need to use disjunctive logic programs in the case of synonymity rules.
If, for instance, G in (5) is a literal, then the following group of nondisjunctive rules
will do:
L1 ← L2 , not G,
L2 ← L1 , not G,
L1 ← L2 , not G,
L2 ← L1 , not G.
Finally, we extend the translation from propositional causal rules to ﬁrst-order
causal rules in the sense of Lifschitz (1997). This version of causal logic is useful for
deﬁning the semantics of variables in action descriptions (Lifschitz and Ren 2007).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

386

P. Ferraris et al.

As part of motivation for our approach to transforming causal theories into logic
programs, we start with a few additional comments on McCain’s translation (1997;
Section 2). After reviewing the semantics of causal theories and logic programs in
Sections 3 and 4, we describe four types of causal rules that we are interested in and
show how to turn a theory consisting of such rules into a logic program (Section 5).
This translation is related to answer set programming in Section 6, and its soundness
is proved in Section 7.
Preliminary reports on this work are published in Ferraris (2006), Ferraris (2007),
Lee et al. (2010), and Lifschitz and Yang (2010). Some results appear here for the
ﬁrst time, including the soundness of a representation of a synonymity rule with
variables by a nondisjunctive logic program.

2 McCain’s translation revisited
2.1 Incorporating constraints
In causal logic, a constraint is a rule with the head ⊥ (falsity). McCain’s translation
can be easily extended to constraints with a conjunction of literals in the body-causal
rules of the form
⊥ ⇐ A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ · · · ∧ ¬An .

(6)

In the language of logic programming, (6) can be represented by a rule similar
to (3):
⊥ ← not ¬A1 , . . . , not ¬Am , not Am+1 , . . . , not An .

(7)

Furthermore, each of the combinations not ¬ in (7) can be dropped without
destroying the validity of the translation; that is to say, the rule
⊥ ← A1 , . . . , Am , not Am+1 , . . . , not An

(8)

can be used instead of (7).
2.2 Eliminating strong negation
As observed by Gelfond and Lifschitz (1991), strong negation can be eliminated from
a logic program in favor of additional atoms. Denote the new atom representing a
b Then (3) will become
negative literal ¬A by A.
c1 , . . . , not A
c
A0 ← not A
m , not Am+1 , . . . , not An

(9)

if L is a positive literal A0 , and
c0 ← not A
c1 , . . . , not A
c
A
m , not Am+1 , . . . , not An

(10)

if L is a negative literal ¬A0 . The modiﬁed McCain translation of a causal theory T
consisting of rules of the forms (2) and (6) includes
• rules (8) corresponding to the constraints (6) of T ,
• rules (9) and (10) corresponding to the other rules of T , and

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

387

• the completeness constraints
b
← A, A,
b
← not A, not A

(11)

for all atoms A.
For instance, the modiﬁed McCain translation of (1) is
p ← not q,
b
q ← not b
p,
← p, b
p
← not p, not b
p
← q, b
q
← not q, not b
q.

(12)

q }.
The only answer set (stable model2 ) of this program is {p, b
This modiﬁcation is useful to us in view of the fact that eliminating strong
negation in favor of additional atoms is part of the deﬁnition of a stable model
proposed in Section 8 by Ferraris et al. (2011).
2.3 Rules as formulas
The deﬁnition of a stable model for propositional formulas given by Ferraris (2005)
and the deﬁnition of a stable model for the ﬁrst-order sentences proposed in Ferraris
et al. (2011) become generalizations of the original deﬁnition (Gelfond and Lifschitz
1988) when we rewrite rules as logical formulas. For instance, rules (9) and (10),
rewritten as propositional formulas, become
c
c1 ∧ · · · ∧ ¬A
¬A
m ∧ ¬Am+1 ∧ · · · ∧ ¬An → A0

(13)

c
c
c1 ∧ · · · ∧ ¬A
¬A
m ∧ ¬Am+1 ∧ · · · ∧ ¬An → A0 .

(14)

and
Rule (8) can be identiﬁed with the formula
A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ . . . ∧ ¬An → ⊥

(15)

¬(A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ . . . ∧ ¬An ).

(16)

or, alternatively, with

The completeness constraints for an atom A turn into the formulas
b
¬(A ∧ A)
b
¬(¬A ∧ ¬A).

2

(17)

The term “stable model” was introduced by Gelfond and Lifschitz (1988) to describe the meaning of
logic programs with negation as failure but without strong negation. When the stable model semantics
was extended to programs with strong negation by Gelfond and Lifschitz (1991), the term “answer set”
was proposed as a replacement.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

388

P. Ferraris et al.

Here is program (12) rewritten in the syntax of propositional logic:
¬q → p
¬b
p→b
q
¬(p ∧ b
p)
¬(¬p ∧ ¬b
p)
¬(q ∧ b
q)
¬(¬q ∧ ¬b
q ).

(18)

Note that the process of rewriting a rule as a formula is applicable only when
the rule does not contain strong negation; the symbol ¬ in the resulting formula
corresponds to the negation as failure symbol (not) in the rule.
One of the advantages of writing rules as formulas is that it allows us to relate
properties of stable models to subsystems of classical logic. For instance, we know
that if the equivalence of two sentences can be proved in intuitionistic logic (or even
in the stronger logic of here-and-there) then these sentences have the same stable
models (Ferraris et al . 2011, Theorem 5). This fact will be used here many times.
2.4 Translating arbitrary deﬁnite theories
The requirement in the deﬁnition of McCain’s translation that the bodies of all
causal rules should be conjunctions of literals can be lifted by slightly modifying the
translation process. Take any set T of causal rules of the forms
A ⇐ G,

(19)

¬A ⇐ G,

(20)

⊥ ⇐ G,

(21)

where A is an atom and G is an arbitrary propositional formula (rules of these
forms are called deﬁnite). For each rule (19), take the formula ¬¬G → A; for each
b and for each rule (21), the formula ¬G. Then
rule (20), the formula ¬¬G → A;
add completeness constraints (17) for all atoms A. Answer sets of this collection of
propositional formulas correspond to the models of T .
In application to example (1), this modiﬁcation of McCain’s translation gives
¬¬¬q → p
¬¬p → b
q
¬(p ∧ b
p)
¬(¬p ∧ ¬b
p)
¬(q ∧ b
q)
¬(¬q ∧ ¬b
q ).

(22)

It is not surprising that (22) has the same answer set as (18): The two collections of
formulas are intuitionistically equivalent to each other.3
3

Indeed, ¬¬¬q is intuitionistically equivalent to ¬q; the equivalence between ¬¬p and ¬b
p is
p) and ¬(¬p ∧ ¬b
p), which belong to both (18) and (22).
intuitionistically entailed by the formulas ¬(p ∧ b

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

389

3 Review: ﬁrst-order causal theories
According to Lifschitz (1997), the ﬁrst-order causal theory T is deﬁned by
• a list p of distinct predicate constants,4 called the explainable symbols of T ,5
and
• a ﬁnite set of causal rules of the form F ⇐ G, where F and G are the ﬁrst-order
formulas.
The semantics of the ﬁrst-order causal theories can be described as follows. For
each p ∈ p, choose a new predicate variable υp of the same arity, and let υp stand for
the list of all these variables. By T † (υp) we denote the conjunction of the formulas
p
)
∀x(G → Fυp

(23)

for all rules F ⇐ G of T , where x is the list of all free variables of F and
p
denotes the result of substituting the variables υp for the
G. (The expression Fυp
corresponding constants p in F.)
We view T as shorthand for the sentence
∀υp(T † (υp) ↔ (υp = p)).

(24)

(By υp = p we denote the conjunction of the formulas ∀x(υp(x) ↔ p(x)) for all
p ∈ p, where x is a tuple of distinct object variables.) Accordingly, by a model of T
we understand a model of (24) in the sense of classical logic. The models of T
are characterized, informally speaking, by the fact that the interpretation of the
explainable symbols p in the model is the only interpretation of these symbols that
is “causally explained” by the rules of T .
In the deﬁnite case (see Section 2.4) the second-order formula (24) can be replaced
by an equivalent ﬁrst-order formula using a process similar to Clark’s completion
(1978), called literal completion (Lifschitz 1997, Section 5; McCain and Turner
1997). This process is used in the operation of CCalc.
Example 1
Let T be causal theory (1) with both p and q explainable. Then T † (υp, υq) is
(¬q → υp) ∧ (p → ¬υq),
where υp and υq are propositional variables, so that T is understood as shorthand
for the second-order propositional formula (“QBF”)
∀(υp)(υq)((¬q → υp) ∧ (p → ¬υq) ↔ (υp ↔ p) ∧ (υq ↔ q)).

(25)

This formula is equivalent to p ∧ ¬q.6
4
5
6

We view propositional symbols as predicate constants of arity 0, so that they are allowed in p. Equality,
on the other hand, may not be declared explainable.
To be precise, the deﬁnition given by Lifschitz (1997) is more general: object and function constants
can be treated as explainable as well.
This fact can be veriﬁed by replacing the universal quantiﬁer in (25) with the conjunction of the four
propositional formulas obtained by substituting all possible combinations of values for the variables υp
and υq, and simplifying the result. Alternatively, one can apply literal completion to rule (1) and
simplify the result.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

390

P. Ferraris et al.

Example 2
Let T be the causal theory consisting of two rules:
p(a) ⇐ ,
where  is the logical constant true, and
¬p(x) ⇐ ¬p(x),
with the explainable symbol p. The ﬁrst rule says that there is a cause for a to have
property p. The second rule says that if an object does not have property p, then there
is a cause for that; including this rule in a causal theory has, informally speaking,
the same eﬀect as saying that p is false by default (Lifschitz 1997, Section 3). In this
case, T † (υp) is
υp(a) ∧ ∀x(¬p(x) → ¬υp(x)),
so that T is understood as shorthand for the sentence
∀υp(υp(a) ∧ ∀x(¬p(x) → ¬υp(x)) ↔ ∀x(υp(x) ↔ p(x))).
This sentence is equivalent to the ﬁrst-order formula
∀x(p(x) ↔ x = a),

(26)

as can be veriﬁed by applying literal completion to the rules of T .

4 Review: stable models
Some details of the deﬁnition of a stable model proposed by Ferraris et al. (2011)
depend on the propositional connectives that are treated as primitives, and are
viewed as abbreviations. The convention there is to take the 0-place connective ⊥
and the binary connectives ∧, ∨, → as primitives; ¬F is shorthand for F → ⊥.
In this paper we adopt the view that the ﬁrst-order formulas are formed using a
slightly larger set of propositional connectives:
, ⊥, ¬, ∧, ∨, →
(as well as the quantiﬁers ∀, ∃). On the other hand, stable models are only deﬁned
here for sentences of a special syntactic form. A ﬁrst-order sentence is a rule7 if it
has the form e
∀(F → G) and has no occurrences of → other than the one explicitly
shown.8 If a sentence F does not contain implication, then we will identify it with
the rule  → F. For instance, propositional formulas (13)–(18) are rules. A logic
program is a conjunction of rules. The deﬁnition of a stable model given here is more
limited than the deﬁnition from (Ferraris et al . 2011) because it is only applicable
to programs, and not to arbitrary sentences. For instance, it does not cover the
formulas (p → q) → r and (p → q) ∨ r. On the other hand, it is simpler than the
general deﬁnition and suﬃcient for our present purposes.
7
8

Or program rule, to distinguish it from causal rules in the sense of Section 3.

e
∀F stands for the universal closure of F.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

391

We need the following notation from Lifschitz (1994). If p and q are predicate
constants of the same arity, then p 6 q stands for the formula
∀x(p(x) → q(x)),
where x is a tuple of distinct object variables. If p and q are tuples p1 , . . . , pn and
q1 , . . . , qn of predicate constants, then p 6 q stands for the conjunction
(p1 6 q1 ) ∧ · · · ∧ (pn 6 qn ),
and p < q stands for (p 6 q) ∧ ¬(q 6 p). In the second-order logic, we apply the
same notation to tuples of predicate variables.
Let p be a list of distinct predicate constants; members of p will be called
intensional predicates.9 For each p ∈ p, choose a predicate variable υp of the same
arity, and let υp stands for the list of all these variables. For any logic program F,
by SMp [F] we denote the second-order sentence
F ∧ ¬∃υp((υp < p) ∧ F  (υp)),

(27)

where F  (υp) is the formula obtained from F by replacing, for every p ∈ p, each
occurrence of p that is not in the scope of negation with υp. A model of F is stable
(relative to the set p of intensional predicates) if it satisﬁes SMp [F].10
Example 3
Let F be the propositional formula ¬p → q (the one-rule program q ← not p, in
traditional notation). If both p and q are intensional, then F  (υp, υq) is
¬p → υq,
so that SMpq [F] is
(¬p → q) ∧ ¬∃(υp)(υq)(((υp, υq) < (p, q)) ∧ (¬p → υq)).
This formula is equivalent to ¬p ∧ q.11 Consequently F has one stable model: p is
false and q is true.
Example 4
Let F be the formula
∀x(¬p(x) → (q(x) ∨ ¬q(x))),

9

10

11

(28)

This list usually consists of all predicate symbols occurring in the heads of rules; those are the
predicates that we “intend to characterize” by the rules of the program. The original deﬁnition of a
stable model (Gelfond and Lifschitz 1988) treats all predicates as intensional.
We can make two comments about the relation of this treatment of stable models to earlier work.
First, if we drop from the deﬁnition of SM the words “that is not in the scope of negation,” then it
will turn into the deﬁnition of parallel circumscription (Lifschitz 1985; McCarthy 1986) . It follows
that if a logic program does not contain negation, then the class of its stable models is identical to the
class of its minimal models. The stipulation in the description of F  (υp) that intensional predicates in
the scope of negation are not replaced by variables is a reﬂection of the idea of negation as a failure.
Second, the operator of SM as deﬁned by Ferraris et al. (2011) produces, in application to a logic
program, a second-order formula that is usually more complex than (27) but is equivalent to it.
Methods for simplifying the result of applying the operator SM are discussed by Ferraris et al. (2011).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

392

P. Ferraris et al.

(it can be thought of as a formula representation of the lparse choice rule
{q(X)} :- not p(X)).12 If we take q to be the only intensional predicate, then F  (υq)
is
∀x(¬p(x) → (υq(x) ∨ ¬q(x))).
Consequently, SMq [F] is
∀x(¬p(x) → (q(x) ∨ ¬q(x))) ∧ ¬∃υq((υq < q) ∧ ∀x(¬p(x) → (υq(x) ∨ ¬q(x)))).
The ﬁrst conjunctive term here is logically valid and can be dropped. The second
is equivalent to the ﬁrst-order formula ¬∃x(p(x) ∧ q(x)), which reﬂects the intuitive
meaning of the choice rule above: q is an arbitrary set disjoint from p.
The relationship between the deﬁnition of a stable model given above and the
operation of answer set solvers is discussed in Section 6.
If programs F and G are intuitionistically equivalent, then SMp [F] is equivalent
to SMp [G], that is to say, F and G have the same stable models. Moreover, for
establishing that F and G have the same stable models we only need to derive F ↔ G
intuitionistically from the excluded middle formulas e
∀(H ∨¬H) for some formulas H
that do not contain intensional predicates. This fact follows from Theorem 5 given
by Ferraris et al. (2011).

5 Turning a causal theory into a logic program
5.1 Four types of causal rules
In the rest of the paper, we assume that the bodies of causal rules do not contain
implication. This is not an essential limitation, because in classical logic → can be
expressed in terms of other connectives, and the meaning of a causal rule does not
change if we replace its body (or head) by a classically equivalent formula.
Here are four types of rules that we are going to consider, in the order of
increasing complexity of their heads:
• The head is ⊥, that is, the rule is a constraint. Such causal rules will also be
called C-rules.
• The head is a literal containing an explainable predicate symbol. These are
L-rules.
• The head has the form L1 ↔ L2 , where each Li is a literal containing an
explainable predicate symbol. These are synonymity rules, or S-rules.
• The head has the form L1 ∨· · ·∨Ln (n > 0), where each Li is a literal containing
an explainable predicate symbol. These are D-rules.
All C-rules and L-rules can also be viewed as D-rules, and any S-rule can
be replaced with an equivalent pair of D-rules (see Lemma 11 in Section 7.2).
Nevertheless, here we give special attention to rules of the ﬁrst three types, and the
12

This rule would not be accepted by lparse, however, because it is “nonrestricted.” For a description
of the language of lparse see http://www.tcs.hut.fi/Software/ smodels/lparse.ps

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

393

reason is that our translation handles such rules in special ways. It appears that
causal rules of types C, L, and S will be more important than general D-rules in the
application of this work to the automation of reasoning about actions.
On the other hand, the possibility of reducing rules of types C, L, and S to type D
plays an important role in the proof of the soundness of our translation (Section 7).
This is one of the reasons why we are interested in general D-rules.
The requirement, in the deﬁnitions of rules of types L, S and D, that the literals
in the head of the rule contain explainable predicate symbols is not an essential
limitation. If, for instance, the predicate symbol in the head of L ⇐ G is not
explainable, then this rule can be equivalently replaced by the C-rule ⊥ ⇐ G ∧ L. If
a rule has the form
L1 ↔ L2 ⇐ G
and the predicate symbol in L1 is not explainable, then the rule can be replaced by
L2 ⇐ G ∧ L1 ,
L2 ⇐ G ∧ L1 .
If a rule has the form
L1 ∨ · · · ∨ Ln ⇐ G
and the predicate symbol in L1 is not explainable, then the rule can be replaced by
L2 ∨ · · · ∨ Ln ⇐ G ∧ L1 .

5.2 Translating C-rules and L-rules
The transformation described in this section generalizes McCain’s translation, in the
form described in Section 2.4, to the ﬁrst-order causal theories.
The operator Trc , which transforms any C-rule into a program rule, is deﬁned by
the formula
∀¬G.
Trc [⊥ ⇐ G] = e
The operator Trl , which transforms any L-rule into a program rule, is deﬁned by
the formulas
∀(¬¬G → p(t)),
Trl [p(t) ⇐ G] = e
∀(¬¬G → b
p(t)),
Trl [¬p(t) ⇐ G] = e
where t is a tuple of terms.
If T is a causal theory consisting of C-rules and L-rules, then its translation Tr[T ]
is the logic program obtained by conjoining
• the rules obtained by applying Trc to the C-rules of T ,
• the rules obtained by applying Trl to the L-rules of T , and
• the completeness constraints
∀x¬(p(x) ∧ b
p(x)),
∀x¬(¬p(x) ∧ ¬b
p(x))

(29)

(x is a tuple of distinct object variables) for all explainable predicate symbols p
of T .

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

394

P. Ferraris et al.

Let p be the list of explainable predicate symbols p of T , and let b
p be the list
of the corresponding predicate symbols b
p. Take the union of p and b
p to be the set
of intensional predicates. Then the stable models of the logic program Tr[T ] are
“almost identical” to the models of T ; the diﬀerence is because of the fact that the
language of T does not contain the symbols b
p. Let CC be the conjunction of all
completeness constraints (29). Then the relationship between T and Tr[T ] can be
described as follows:
SMpp [Tr[T ]] is equivalent to T ∧ CC .

(30)

This claim, expressing the soundness of our translation, is extended in Sections 5.3
and 5.4 to causal theories containing S-rules and D-rules, and its proof is given in
Section 7.
As the conjunction of formulas (29) is classically equivalent to
∀x(b
p(x) ↔ ¬p(x)),

(31)

sentence CC can be viewed as the conjunction of explicit deﬁnitions of the
predicates b
p in terms of the predicates p. Consequently, the relationship (30) shows
that SMpp [Tr[T ]] is a deﬁnitional extension of T . The models of Tr[T ] that are
stable relative to pb
p can be characterized as the models of T extended by the
interpretations of the predicates b
p that are provided by deﬁnition (31).
Example 1 (continued )
If T is causal theory (1) with both p and q explainable, then Tr[T ] is the conjunction
of formulas (22). The result of applying the operator SMpqpq to this conjunction is
equivalent to
p ∧ ¬q ∧ ¬b
p∧b
q.
Recall that T is equivalent to the ﬁrst half of this conjunction (Section 3). The
second half tells us that the truth values of b
p and b
q are opposite to the truth values
of p and q. In the only stable model of (22), p and b
q are true, and b
p and q are false;
if we “forget” the truth values of b
p and b
q , then we will arrive at the model of (1).
Example 2 (continued )
Our translation turns the causal theory from Example 2 into the conjunction of the
rules
¬¬ → p(a),
∀x(¬¬¬p(x) → b
p(x)),
∀x¬(p(x) ∧ b
p(x)),
∀x¬(¬p(x) ∧ ¬b
p(x)),
or, after intuitionistically equivalent transformations,
p(a),
∀x(¬p(x) → b
p(x)),
∀x¬(p(x) ∧ b
p(x)),
∀x¬(¬p(x) ∧ ¬b
p(x)).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

395

Representing ﬁrst-order causal theories by logic programs

The result of applying SMpp to the conjunction of these formulas is equivalent to
the conjunction of (26) with the formula ∀x(b
p(x) ↔ ¬p(x)), which says that b
p is the
complement of p.
Example 5
Consider the following causal rules:
on 1 (x)
¬on 1 (x)
on 1 (x)
¬on 1 (x)

⇐ toggle(x) ∧ ¬on 0 (x),
⇐ toggle(x) ∧ on 0 (x),
⇐ on 0 (x) ∧ on 1 (x),
⇐ ¬on 0 (x) ∧ ¬on 1 (x).

(32)

The ﬁrst pair of rules describes the eﬀect of toggling a switch x: this action causes
the ﬂuent on(x) at time 1 to take the value opposite to its value at time 0. The second
pair solves the frame problem (Shanahan 1997) for the ﬂuent on(x) by postulating
that if the value of that ﬂuent at time 1 is equal to its previous value, then there is a
cause for this. (Inertia, in the sense of commonsense reasoning, is the cause.) Let T
be the causal theory with rules (32) and with on 1 as the only explainable symbol.
Using literal completion, we can check that T is equivalent to
∀x(on 1 (x) ↔ ((on 0 (x) ∧ ¬toggle(x)) ∨ (¬on 0 (x) ∧ toggle(x)))).

(33)

Our translation turns T into the conjunction of the rules
∀x(¬¬(toggle(x) ∧ ¬on 0 (x)) → on 1 (x)),
∀x(¬¬(toggle(x) ∧ on 0 (x)) → on 1 (x)),
∀x(¬¬(on 0 (x) ∧ on 1 (x)) → on 1 (x)),
∀x(¬¬(¬on 0 (x) ∧ ¬on 1 (x)) → on 1 (x)),
∀x¬(on 1 (x) ∧ on 1 (x)),
∀x¬(¬on 1 (x) ∧ ¬on 1 (x)),

(34)

∀x(toggle(x) ∧ ¬on 0 (x) → on 1 (x)),
∀x(toggle(x) ∧ on 0 (x) → on 1 (x)),
∀x(on 0 (x) ∧ ¬on 1 (x) → on 1 (x)),
∀x(¬on 0 (x) ∧ ¬on 1 (x) → on 1 (x)),
∀x¬(on 1 (x) ∧ on 1 (x)),
∀x¬(¬on 1 (x) ∧ ¬on 1 (x)).

(35)

b

b

b
b

or, equivalently,13

b
b

b

b
b

The result of applying SMon 1 on
1 to this program is equivalent to the conjunction
of (33) with the formula ∀x(on 1 (x) ↔ ¬on 1 (x)), which says that on 1 is the
complement of on 1 .

b

13

b

Removing the double negations in the ﬁrst two lines of (34) is possible because neither toggle nor
on 0 is intensional (see the comment on equivalent transformations of logic programs at the end
of Section 4). In a similar way, the antecedent of the third impication in (34) can be replaced by
c1 (x) is intuitionistically entailed by the
on 0 (x) ∧ ¬¬on 1 (x); the equivalence between ¬¬on 1 (x) and ¬on
last two lines of (34). The fourth line of (34) is simpliﬁed in a similar way.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

396

P. Ferraris et al.

Example 6
The constraint
⊥ ⇐ toggle(badswitch)
expresses that badswitch is stuck: the action of toggling it is not executable. If we
add this constraint to the causal theory from Example 5, then the rule
¬toggle(badswitch)
will be added to its translation (35).
The bodies of causal rules in Examples 5 and 6 are syntactically simple: They
are conjunctions of literals. The general deﬁnitions of a C-rule and an L-rule do
not impose any restrictions on the form of the body, and in applications of causal
logic to formalizing commonsense knowledge this generality is often essential. For
instance, the statement “each position must have at least one neighbor” in the
landscape structure of the Zoo World14 would be represented in causal logic by a
C-rule with a quantiﬁer in the body.

5.3 Translating S-rules
We will now turn to translating synonymity rules (Section 5.1). The operator Trs ,
transforming any such rule into a logic program, is deﬁned by the formulas
Trs [p1 (t1 ) ↔ p2 (t2 ) ⇐ G] = Trs [¬p1 (t1 ) ↔ ¬p2 (t2 ) ⇐ G]
∀(¬¬G ∧ p2 (t2 ) → p1 (t1 )) ∧
=e
∀(¬¬G ∧ p1 (t1 ) → p2 (t2 )) ∧ e
1
2
e
e
∀(¬¬G ∧ pb1 (t ) → pb2 (t )) ∧ ∀(¬¬G ∧ pb2 (t2 ) → pb1 (t1 )),
Trs [¬p1 (t1 ) ↔ p2 (t2 ) ⇐ G] = Trs [p1 (t1 ) ↔ ¬p2 (t2 ) ⇐ G]
∀(¬¬G ∧ p2 (t2 ) → pb1 (t1 )) ∧
=e
∀(¬¬G ∧ pb1 (t1 ) → p2 (t2 )) ∧ e
1
2
e
p2 (t )) ∧ e
∀(¬¬G ∧ b
p2 (t2 ) → p1 (t1 )),
∀(¬¬G ∧ p1 (t ) → b
where t1 and t2 are tuples of terms. The deﬁnition of program Tr[T ] from Section 5.2
is extended to causal theories that may contain S-rules, besides C-rules and L-rules,
by adding that Tr[T ] also includes
• the rules obtained by applying Trs to the S-rules of T .
Example 7
Extend the theory from Example 5 by the rule
dark ↔ ¬on 1 (myswitch) ⇐ ,

14

(36)

The challenge of formalizing the Zoo World was proposed as part of the Logic Modelling Workshop
(http:/www/ida.liu.se/ext/etai/lmw/). The possibility of addressing this challenge using CCalc
is discussed by Akman et al. (2004, Section 4).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

397

where dark is explainable. The corresponding logic program is obtained from (35)
by adding the rules

b

dark → on 1 (myswitch),
on 1 (myswitch) → dark ,
dark → on 1 (myswitch),
(37)
on 1 (myswitch) → dark ,
¬(dark ∧ dark ),
¬(¬dark ∧ ¬dark ).
We will see that the soundness property (30) holds for arbitary causal theories
consisting of rules of types C, L, and S.

b

b
b

b

b

5.4 Translating D-rules
A D-rule (Section 5.1) has the form


A∨
¬A ⇐ G
A∈Pos

(38)

A∈Neg

for some sets Pos and Neg of atomic formulas.
b
If A is an atomic formula p(t), where p ∈ p and t is a tuple of terms, then by A
we will denote the formula b
p(t). The operator Trd transforms D-rule (38) into the
program rule
⎞
⎛




e
b ∨ ¬A)
b ∧
b⎠ .
(A
(A ∨ ¬A) →
A∨
A
(39)
∀ ⎝ ¬¬G ∧
A∈Pos

A∈Neg

A∈Pos

A∈Neg

Example 8
The result of applying Trd to the D-rule
p ∨ ¬q ∨ ¬r ⇐ s
is
¬¬s ∧ (b
p ∨ ¬b
p) ∧ (q ∨ ¬q) ∧ (r ∨ ¬r) → p ∨ b
q ∨b
r.
The number of “excluded middle formulas” conjoined with ¬¬G in (39) equals
the number of disjunctive terms in the head of D-rule (38). In particular, if (38) is
an L-rule, then the antecedent of (39) contains one such formula. For instance, in
application to the ﬁrst rule of (1) Trd produces the program rule
¬¬¬q ∧ (b
p ∨ ¬b
p) → p,
which is more complex than the ﬁrst rule of (22).
For a ﬁxed collection p of explainable symbols, let C, L, S, and D be ﬁnite sets
of causal rules of types C, L, S, and D, respectively. By Tr[C, L, S, D] we denote the
logic program obtained by conjoining
• the rules obtained by applying Trc to all rules from C,
• the rules obtained by applying Trl to all rules from L,

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

398

P. Ferraris et al.
• the programs obtained by applying Trs to all rules from S,
• the rules obtained by applying Trd to all rules from D,
• the completeness constraints (29) for all explainable symbols p.

Our most general form of the soundness theorem, proved in Section 7, asserts that
SMpp [Tr[C, L, S, D]] is equivalent to T ∧ CC

(40)

for the causal theory T with the set of rules C ∪ L ∪ S ∪ D. In the special case when D
is empty, this theorem turns into the assertion stated at the end of Section 5.3.

6 Using answer set solvers to generate models of a causal theory
The discussion of answer set solvers in this section, as almost any discussion of
software, is somewhat informal. We assume here that the ﬁrst-order language under
consideration does not contain function constants of nonzero arity.
An answer set solver can be viewed as a system for generating stable models in
the sense of Section 4, with three caveats. First, currently available solvers require
that the input program has a syntactic form that is much more restrictive than the
syntax of the ﬁrst-order logic.15 Preprocessing based on intuitionistically equivalent
transformations often helps us alleviate this diﬃculty. There exists a tool called f2lp
(Lee and Palla 2009) that converts ﬁrst-order formulas of a rather general type into
logic programs accepted by lparse. The rules produced by the process described in
the previous section have no existential quantiﬁers in their heads, and all quantiﬁers
in their bodies are in the scope of negation. Consequently, these rules satisfy a
syntactic condition that guarantees the correctness of the translation implemented
in f2lp.
Second, answer set solvers represent stable models by sets of ground atoms.
In order to introduce such a representation, we usually choose a ﬁnite set of
object constants that includes all object constants occurring in the program, and
restrict attention to Herbrand interpretations of the extended language. The #domain
construct of lparse16 can be used to specify the object constants constituting the
domain of the variables in the program.
Third, most existing answer set solvers are unaware of the possibility of nonintensional (or extensional ) predicates. Treating a predicate constant as extensional
can be simulated using a choice rule (Ferraris et al . 2011, Theorem 2). There is also
another approach to overcome this limitation. Take a conjunction E of some ground
atoms containing extensional predicates, and assume that we are interested in the
Herbrand stable models of a program F that interpret the extensional predicates
in accordance with E (every atom from E is true; all other atoms containing
extensional predicates are false). Under some syntactic conditions,17 these stable
15
16
17

Solvers also require that the input satisfy some safety conditions. See, for instance, Chapter 3 of the
dlv manual at http://www.dbai.tuwien.ac.at/proj/dlv/man/
See footnote 12 .
Speciﬁcally, under the assumption that every occurrence of every extensional predicate in F is in the
scope of negation or in the antecedent of an implication.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

399

u(a;b;c;d).
#domain u(X).
{q(X)} :- not p(X).
p(a;b).

Fig. 1. Example 4 with a 4-element universe in the language of lparse.

models are identical to the Herbrand stable models of F ∧ E with all predicate
constants treated as intensional. This can be proved using the splitting theorem
from Ferraris et al. (2009).
Example 4 (continued )
We would like to ﬁnd stable models of (28), with q intensional, that have the universe
{a, b, c, d} and make p true on a, b and false on c, d. This is the same as to look for
the Herbrand stable models of the formula
∀x(¬p(x) → (q(x) ∨ ¬q(x))) ∧ p(a) ∧ p(b),
with c and d viewed as object constants of the language along with a and b, and
with both p and q taken to be intensional.
A representation of this example in the language of lparse is shown in Figure 1.
The auxiliary predicate u describes the universe of the interpretations that we are
interested in. The ﬁrst line is shorthand for
u(a). u(b). u(c). u(d),
and the last line is understood by lparse in a similar way.
Given this input, the answer set solver smodels generates four stable models,
representing the subsets of {a, b, c, d} that are disjoint from {a, b}:
Answer: 1
Stable Model:
Answer: 2
Stable Model:
Answer: 3
Stable Model:
Answer: 4
Stable Model:

p(b) p(a) u(d) u(c) u(b) u(a)
p(b) p(a) q(d) u(d) u(c) u(b) u(a)
p(b) p(a) q(c) u(d) u(c) u(b) u(a)
p(b) p(a) q(d) q(c) u(d) u(c) u(b) u(a)

In application to the logic program obtained from a causal theory T as described
in Section 5, this process often allows us to ﬁnd the models of T with a given
universe and given extents of extensional predicates.
Example 7 (continued )
There are two switches, myswitch and hisswitch. It is dark in my room at time 1
if and only if myswitch is not on at time 1. At time 0, both switches are on; then
hisswitch is toggled, and myswitch is not. Is it dark in my room at time 1? We would
like to answer this question using answer set programming.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

400

P. Ferraris et al.

u(myswitch;hisswitch).
#domain u(X).
on1(X) :- toggle(X), not on0(X).
-on1(X) :- toggle(X), on0(X).
on1(X) :- on0(X), not -on1(X).
-on1(X) :- not on0(X), not on1(X).
:- not on1(X), not -on1(X).
on1(myswitch) :- -dark.
-dark :- on1(myswitch).
-on1(myswitch) :- dark.
dark :- -on1(myswitch).
:- not dark, not -dark.
on0(myswitch;hisswitch).
toggle(hisswitch).

Fig. 2. Example 7 with two switches in the language of lparse.

This example of commonsense reasoning involves inertia (the value of the ﬂuent
on(myswitch) does not change because this ﬂuent is not aﬀected by the action that
is executed) and indirect eﬀects of actions: whether or not it is dark in the room at
time 1 after performing some actions is determined by the eﬀect of these actions on
the ﬂuent on(myswitch).
Mathematically, here we are talking about the causal theory T with rules (32)
and (36), with the object constant hisswitch added to the language, and with the
explainable symbols on 1 and dark . We are interested in the Herbrand models of T
in which the extents of the extensional predicates are described by the atoms
on 0 (myswitch), on 0 (hisswitch), toggle(hisswitch).
As we have seen, the logic program Tr[T ] is equivalent to the conjunction of
rules (35) and (37). The corresponding lparse input ﬁle is shown in Figure 2. In
this ﬁle, the “true negation” symbol - is used in the ASCII representations of the
symbols on 1 and dark ; the lparse counterparts of the rules

b

b

b

∀x¬(on 1 (x) ∧ on 1 (x)),
¬(dark ∧ dark )

b

are dropped because such “coherence” conditions are automatically veriﬁed by the
system.
Given this input, smodels generates the only model of T satisfying the given
conditions:
Answer: 1
Stable Model: -on1(hisswitch) on1(myswitch) -dark toggle(hisswitch)
on0(hisswitch) on0(myswitch) u(hisswitch) u(myswitch)
The presence of -dark in this model tells us that it is not dark in the room at time 1.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

401

The above example is an example of “one-step temporal projection” – predicting
the value of a ﬂuent after performing a single action in a given state. Some other
types of temporal reasoning and planning can be performed by generating models of
simple modiﬁcations of the given causal theory (Giunchiglia et al . 2004, Section 3.3);
this is one of the ideas behind the design of CCalc and coala. McCain’s translation
reviewed in the Introduction and its generalization presented in Section 5 allow us
to automatically solve such problems using an answer set solver.

7 Proof of soundness
In order to prove claim (40), which expresses the soundness of our translation,
we will ﬁrst establish it for the case when C = L = S = ∅ (Section 7.1). In this
“leading special case” all rules of the given causal theory are D-rules, and they
are converted to program rules using the translation Trd . Then we will derive the
soundness theorem in full generality (Section 7.2).
7.1 Leading special case
Let T be a ﬁnite set of causal rules of the form (38). Let Π be the conjunction of the
corresponding program rules (39), and let CC , as before, stand for the conjunction
of the completeness constraints (29) for all explainable symbols p of T . We want to
show that
SMpp [Π ∧ CC ] is equivalent to T ∧ CC .

(41)

The key steps in the proof given below are Lemmas 5 (one half of the equivalence)
and 8 (the other half).
In the statement of the following lemma, ¬p stands for the list of predicate
expressions18 λx¬p(x), where x is a list of distinct object variables, for all p from p.
By υp and υb
p we denote the lists of predicate variables used in the second-order
formula SMpp [Π ∧ CC ] (see Section 4).
Lemma 1
Formula (υp, υb
p) < (p, ¬p) is equivalent to
 




(υp, υb
p) 6 (p, ¬p) ∧ ∃x(¬υp(x) ∧ ¬υb
p(x) ).
p∈p

Proof
First note that
(υp,
υb
p) < (p, ¬p)




⇔ 
(υp, υb
p) 6 (p, ¬p) ∧ ¬ (p, ¬p) 6 (υp, υb
p)

⇔ (υp, υb
p) 6 (p, ¬p) ∧ p∈p ∃x((p(x) ∧ ¬υp(x)) ∨ (¬p(x) ∧ ¬υb
p(x)))




p) 6 (p, ¬p) ∧ ∃x((p(x) ∧ ¬υp(x)) ∨ (¬p(x) ∧ ¬υb
p(x)))).
⇔ p∈p ( (υp, υb
18

See Lifschitz (1994, Section 3.1).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

402

P. Ferraris et al.

The disjunction after ∃x is equivalent to
(p(x) ∨ ¬υb
p(x)) ∧ (¬υp(x) ∨ ¬p(x)) ∧ (¬υp(x) ∨ ¬υb
p(x)).

(42)

Since (υp, υb
p) 6 (p, ¬p) entails
υp(x) → p(x) and υb
p(x) → ¬p(x),
the ﬁrst conjunctive term of (42) can be rewritten as ¬υb
p(x), and the second term
as ¬υp(x), so that (42) will turn into ¬υp(x) ∧ ¬υb
p(x). 	
For any formula F, by FΣ1 we denote the formula
(υp)(υ
p)
F(υp∧p)(¬υp∧¬p)
,

where υp ∧ p is understood as the list of predicate expressions
λx(υp(x) ∧ p(x))
for all p ∈ p, and ¬υp ∧ ¬p is understood in a similar way.19
Lemma 2
Formula




(υp, υb
p) < (p, ¬p)


Σ1

is equivalent to υp = p.
Proof



In view of Lemma 1, (υp, υb
p) < (p, ¬p) Σ1 is equivalent to the disjunction of the
formulas






∧
p(x) → ¬p(x))Σ1
p∈p ∀x(υp(x) → p(x))Σ1
p∈p ∀x(υb
(43)
∧ ∃x(¬υp(x) ∧ ¬υb
p(x))Σ1
for all p ∈ p. It is easy to verify that
(υp(x) → p(x))Σ1
(υb
p(x) → ¬p(x))Σ1
(¬υp(x) ∧ ¬υb
p(x))Σ1

= (υp(x) ∧ p(x) → p(x)) ⇔  ,
= (¬υp(x) ∧ ¬p(x) → ¬p(x)) ⇔ ,
⇔ ((¬υp(x) ∨ ¬p(x)) ∧ ¬(¬υp(x) ∧ ¬p(x)))
⇔ (υp(x) ↔ ¬p(x))
⇔ ¬(υp(x) ↔ p(x)).

Therefore (43) is equivalent to ∃x¬(υp(x) ↔ p(x)) so that the disjunction of all
formulas (43) is equivalent to υp = p. 	
If A is an atomic formula p(t), where p ∈ p and t are tuple of terms, then we will
b for υb
write υA for υp(t), and υ A
p(t). By e
∀obj F we denote the formula ∀xF, where x
is a list of all free object variables of F (“object-level universal closure”).
19

p

For the deﬁnition of Fυp see Section 3.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs
Deﬁne H(υp, υb
p) to be the conjunction of the implications
⎛
⎞


e
b ∨ A) → υA) ∨
b⎠
((υ A
((υA ∨ ¬A) → υ A)
∀obj ⎝G →
A∈Pos

403

(44)

A∈Neg

for all rules (38) in T .
Lemma 3
Formula SMpp [Π ∧ CC ] is equivalent to
Π ∧ CC ∧ ∀(υp)(υb
p)(((υp, υb
p) < (p, ¬p)) → ¬H(υp, υb
p)).

(45)

Proof
Every occurrence of every intensional predicate in CC is in the scope of a negation.
Consequently, SMpp [Π ∧ CC ] is
Π ∧ CC ∧ ¬∃(υp)(υb
p)(((υp, υb
p) < (p,b
p)) ∧ Π (υp, υb
p) ∧ CC ),
which is equivalent to
Π ∧ CC ∧ ∀(υp)(υb
p)(((υp, υb
p) < (p, ¬p)) → ¬Π (υp, υb
p)).
We will conclude the proof by showing that CC entails
Π (υp, υb
p) ↔ H(υp, υb
p).
The left-hand side of this equivalence is the conjunction of the formulas
⎛
⎞




e
b ∨ ¬A)
b ∧
b⎠
(υ A
(υA ∨ ¬A) →
υA ∨
υA
∀obj ⎝¬¬G ∧
A∈Pos

A∈Neg

A∈Pos

A∈Neg

for all rules (38) in T . Under the CC assumption this formula can be rewritten as
⎛
⎞




e
b ∨ A) ∨
b⎠ .
¬(υ A
¬(υA ∨ ¬A) ∨
υA ∨
υA
∀obj ⎝G →
A∈Pos

A∈Neg

A∈Pos

A∈Neg

The last formula is equivalent to
⎛
⎞


e
b ∨ A) ∨ υA) ∨
b ⎠,
(¬(υ A
(¬(υA ∨ ¬A) ∨ υ A)
∀obj ⎝G →
A∈Pos

and consequently to (44).

A∈Neg

	

Lemma 4
T † (υp) is equivalent to H(υp, υb
p)Σ1 .
Proof
Formula T † (υp) is the conjunction of the formulas
⎛
⎞


e
υA ∨
¬υA⎠
∀obj ⎝G →
A∈Pos

(46)

A∈Neg

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

404

P. Ferraris et al.

for all rules (38) in T . On the other hand, H(υp, υb
p)Σ1 is the conjunction of the
formulas
⎛
⎞


e
b ∨ A) → υA)Σ1 ∨
b Σ1 ⎠
(47)
((υ A
((υA ∨ ¬A) → υ A)
∀obj ⎝G →
A∈Pos

A∈Neg

for all rules (38) in T . It remains to observe that
b ∨ A) → υA)Σ1
((υ A

=
⇔
⇔
⇔

(¬υA ∧ ¬A) ∨ A → υA ∧ A
¬υA ∨ A → υA ∧ A
(υA ∧ ¬A) ∨ (υA ∧ A)
υA,

b Σ1 is equivalent to ¬υA.
and similarly ((υA ∨ ¬A) → υ A)

	

Lemma 5
SMpp [Π ∧ CC ] |= T ∧ CC .
Proof
Recall that, according to Lemma 3, SMpp [Π ∧ CC ] is equivalent to (45). The second
conjunctive term of (45) is CC . The ﬁrst conjunctive term is equivalent to T † (p).
From the other two terms we conclude:
p)Σ1 ).
∀υp(((υp, υb
p) < (p,b
p))Σ1 → ¬H(υp, υb
By Lemmas 2 and 4, this formula is equivalent to
∀υp((υp = p) → ¬T † (υp)),
and consequently to
∀υp(T † (υp) → (υp = p)).
The conjunction of the last formula with T † (p) is equivalent to (24).

	

For any formula F, by FΣ2 we denote the formula
υp
F(((υp,υ
p)6(p,¬p))∧¬υp∧¬υ
p)↔¬p

where the subscript
(((υp, υb
p) 6 (p, ¬p)) ∧ ¬υp ∧ ¬υb
p) ↔ ¬p
is understood as the list of predicate expressions
λx((((υp, υb
p) 6 (p, ¬p)) ∧ ¬υp(x) ∧ ¬υb
p(x)) ↔ ¬p(x))
for all p ∈ p.
Lemma 6
Formula
(υp = p)Σ2
is equivalent to (υp, υb
p) < (p, ¬p).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

405

Proof
Formula (υp = p)Σ2 is equivalent to

∃x(υp(x) ↔ ¬p(x))Σ2 ,
p∈p

that is,



∃x((((υp, υb
p) 6 (p, ¬p)) ∧ ¬υp(x) ∧ ¬υb
p(x) ↔ ¬p(x)) ↔ ¬p(x)).

p∈p

This formula can be equivalently rewritten as

(((υp, υb
p) 6 (p, ¬p)) ∧ ∃x(¬υp(x) ∧ ¬υb
p(x))),
p∈p

which is equivalent to (υp, υb
p) < (p, ¬p) by Lemma 1.

	

Lemma 7
The implication
(υp, υb
p) 6 (p, ¬p) → (T † (υp)Σ2 ↔ H(υp, υb
p))
is logically valid.
Proof
Recall that T † (υp) is the conjunction of implications (46) for all rules (38) in T .
Consequently, T † (υp)Σ2 is the conjunction of the formulas
⎛
⎞


e
∀obj ⎝G →
(υA)Σ2 ∨
¬(υA)Σ2 ⎠ ,
A∈Pos

A∈Neg

that is to say,
e
∀obj (G →


b ↔ ¬A) ∨
((((υp, υb
p) 6 (p, ¬p)) ∧ ¬υA ∧ ¬υ A)
A∈Pos
b ↔ ¬A).
p) 6 (p, ¬p)) ∧ ¬υA ∧ ¬υ A)
A∈Neg ¬((((υp, υb

Under the assumption
(υp, υb
p) 6 (p, ¬p),

(48)

the last formula can be equivalently rewritten as
⎛
⎞


e
b ↔ A) ∨
b ↔ ¬A)⎠ .
((υA ∨ υ A)
((υA ∨ υ A)
∀obj ⎝G →
A∈Pos

A∈Neg

It remains to check that, under assumption (48),
b ↔A
(υA ∨ υ A)

(49)

b ∨ A → υA,
υA

(50)

b ↔ ¬A
υA ∨ υ A

(51)

can be equivalently rewritten as

and

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

406

P. Ferraris et al.

can be rewritten as
b
υA ∨ ¬A → υ A.

(52)

b → A) ∧ (A → υA ∨ υ A).
b
(υA → A) ∧ (υ A

(53)

Formula (49) is equivalent to

b → ¬A, formula (53) can be rewritten as
As assumption (48) entails υA → A and υ A
b ∧ (A → υA).
¬υ A

(54)

On the other hand, formula (50) is equivalent to
b → υA) ∧ (A → υA),
(υ A
which, under assumption (48), can also be rewritten as (54). In a similar way, each
of the formulas (51) and (52) can be transformed into
b 	
¬υA ∧ (¬A → υ A).
Lemma 8
T ∧ CC |= SMpp [Π ∧ CC ].
Proof
Recall that T is equivalent to
T † (p) ∧ ∀υp(T † (υp) → (υp = p)).

(55)

As the ﬁrst conjunctive term is equivalent to Π, T ∧ CC entails
Π ∧ CC .

(56)

From the second conjunctive term of (55) we conclude
T † (υp)Σ2 → (υp = p)Σ2
and consequently
∀(υp)(υb
p)((υp = p)Σ2 → ¬T † (υp)Σ2 ).
By Lemma 6, this is equivalent to
∀(υp)(υb
p)(((υp, υb
p) < (p, ¬p)) → ¬T † (υp)Σ2 )
and, by Lemma 7, equivalent to
∀(υp)(υb
p)(((υp, υb
p) < (p, ¬p)) → ¬H(υp, υb
p)).
By Lemma 3, the conjunction of this formula with (56) is equivalent to sentence
SMpp [Π ∧ CC ]. 	
Assertion (41) follows from Lemmas 5 and 8.
7.2 General case
Lemma 9
For any C-rule R, Trc [R] is intuitionistically equivalent to Trd [R].

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs
Proof
∀¬G, and Trd [R] is e
∀(¬¬G → ⊥).
If R is ⊥ ⇐ G, then Trc [R] is e

407

	

Lemma 10
For any L-rule R, the conjunction CC of completeness constraints intuitionistically
entails
Trl [R] ↔ Trd [R].
Proof
If R is p(t) ⇐ G, then Trl [R] is
e
∀(¬¬G → p(t)),
and Trd [R] is
e
∀(¬¬G ∧ (b
p(t) ∨ ¬b
p(t)) → p(t)).
As CC intuitionistically entails
¬(p(t) ↔ b
p(t)),

(57)

it is suﬃcient to check that p(t) can be derived from (57) and
b
p(t) ∨ ¬b
p(t) → p(t)

(58)

by the deductive means of intuitionistic propositional logic. As (58) is equivalent
to p(t) in classical propositional logic, it is easy to see that ¬b
p(t) can be derived
from (57) and (58) in classical propositional logic. By Glivenko’s theorem (1929),20
it follows that it can also be derived intuitionistically. As p(t) is intuitionistically
derivable from (58) and ¬b
p(t), we can conclude that p(t) is intuitionistically derivable
from (57) and (58).
The case when R is ¬p(t) ⇐ G is similar. 	
Lemma 11
If R is an S-rule
L1 ↔ L2 ⇐ G,

(59)

L1 ∨ L2 ⇐ G and L1 ∨ L2 ⇐ G,

(60)

and R1 and R2 are the D-rules

then the conjunction CC of completeness constraints intuitionistically entails
Trs [R] ↔ Trd [R1 ] ∧ Trd [R2 ].

20

This theorem (Mints 2000, Theorem 3.1) asserts that if a formula beginning with negation can be
derived from a set Γ of formulas in classical propositional logic, then it can be derived from Γ in
intuitionistic propositional logic as well.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

408

P. Ferraris et al.

Proof
If each of the literals Li is an atom Ai , then Trs [R] is the conjunction of the formulas
e
∀(¬¬G ∧ A1 → A2 ),
e
∀(¬¬G ∧ A2 → A1 ),
e
c1 → A
c2 ),
∀(¬¬G ∧ A
e
c
c1 ),
∀(¬¬G ∧ A2 → A

(61)

e
c1 ∨ ¬A
c1 ) ∧ (A2 ∨ ¬A2 ) → A1 ∨ A
c2 ),
∀(¬¬G ∧ (A

(62)

e
c2 ∨ ¬A
c2 ) → A
c1 ∨ A2 ).
∀(¬¬G ∧ (A1 ∨ ¬A1 ) ∧ (A

(63)

Trd [R1 ] is
and Trd [R2 ] is

We need to show that CC intuitionistically entails the equivalence between the
conjunction of formulas (61) and formulas (62) and (63). As CC intuitionistically
entails
c1 )
¬(A1 ↔ A

(64)

c2 ),
¬(A2 ↔ A

(65)

and

it is suﬃcient to check that the conjunction of formulas (64) and (65),
A1 ↔ A2

(66)

c1 ↔ A
c2
A

(67)

and

is equivalent in intuitionistic propositional logic to the conjunction of formulas (64)
and (65),
c1 ∨ ¬A
c1 ) ∧ (A2 ∨ ¬A2 ) → A1 ∨ A
c2
(A

(68)

c2 ∨ ¬A
c2 ) → A
c1 ∨ A2 .
(A1 ∨ ¬A1 ) ∧ (A

(69)

and

Left-to-right: Assume (64)–(67) and
c1 ∨ ¬A
c1 ) ∧ (A2 ∨ ¬A2 ),
(A

(70)

c2 . Consider two cases, in accordance
then our goal is to derive intuitionistically A1 ∨ A
with the ﬁrst disjunction in (70).
c2 , and consequently A1 ∨ A
c2 .
c1 . Then, by (67), A
Case 1: A
c1 .
Case 2: ¬A
Consider two cases in accordance with the second disjunction in (70).
c2 .
Case 2.1: A2 . Then, by (66), A1 , and consequently A1 ∨ A
Case 2.2: ¬A2 . Then, by (66), ¬A1 , which contradicts (64).
Thus, we proved that (68) is intuitionistically derivable from (64)–(67). The proof
for (69) is similar.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

409

Right-to-left: Let Γ be the set consisting of formulas (64), (65), (68), (69), and A1 .
We claim that A2 can be derived from Γ in intuitionistic propositional logic. Note
that, classically,
c1 ,
• formula (64) is equivalent to A1 ↔ ¬A
c2 , and
• formula (65) is equivalent to A2 ↔ ¬A
c
• formula (69) is equivalent to A1 ∨ A2 .
c2 is derivable from Γ in classical propositional logic. By Glivenko’s
It follows that ¬A
c2 is derivable from Γ intuitionistically as well.
theorem (1929), it follows that ¬A
Hence, the antecedent of (69) is an intuitionistic consequence of Γ, and so is the
c1 ∨ A2 . In combination with A1 and (64), this gives us A2 .
consequent A
We conclude that A1 → A2 is intuitionsistically derivable from (64), (65), (68),
and (69). The derivability of the implication A2 → A1 from these formulas can be
proved in a similar way. Thus, (66) is an intuitionistic consequence of (64), (65), (68),
and (69).
The derivability of (67) from these formulas in propositional intuitionistic logic is
proved in a similar way.
The cases when the literals Li are negative, or when one of them is positive and
the other is negative, are similar. 	
Proof of the soundness property (40). Let C, L, S, and D be sets of causal rules of
types C, L, S, and D, respectively, and let T be the causal theory with the set of
rules C ∪ L ∪ S ∪ D. Consider the causal theory T  obtained from T by replacing
each rule (59) from S with the corresponding rules (60). According to the result (41)
of Section 7.1,
SMpp [Π ∧ CC ] is equivalent to T  ∧ CC ,
where Π is the conjunction of the program rules Trd [R] for all rules R of T  . It is
clear that Π ∧ CC is Tr[T  ], and that T  is equivalent to T . Consequently,
SMpp [Tr[T  ]] is equivalent to T ∧ CC .

(71)

On the other hand, Lemmas 9, 10, and 11 show that the formulas Tr[T  ] and
Tr[C, L, S, D] are intuitionistically equivalent to each other because each of them
contains CC as a conjunctive term. It follows that
SMpp [Tr[T  ]] is equivalent to SMpp [Tr[C, L, S, D]].

(72)

Assertion (40) follows from (71) and (72).

8 Conclusion
In this paper we generalized McCain’s embedding of deﬁnite causal theories into
logic programming. We expect that this work will provide a theoretical basis for
extending the system coala to more expressive action languages, including the
modular action language MAD (Ren 2009). It is essential, from this perspective,
that our translation is applicable to synonymity rules because such rules are closely
related to the main new feature of MAD, its import construct.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

410

P. Ferraris et al.

Our translation is not applicable to causal rules with quantiﬁers in the head. It
may be possible to extend it to positive occurrences of existential quantiﬁers, as an
existentially quantiﬁed formula can be thought of as an inﬁnite disjunction. But the
translation would be a formula with positive occurrences of existential quantiﬁers
as well, and it is not clear how to turn such a formula into executable code.
In future we would like to extend the translation described above to causal
theories with explainable function symbols, which correspond to non-Boolean ﬂuents
in action languages. As the deﬁnition of a stable model does not allow function
symbols to be intensional, such a generalization would have to involve extending
the language by auxiliary predicate symbols.
Acknowledgements
We are grateful to the anonymous referees for useful comments. Joohyung Lee was
partially supported by the National Science Foundation under grant IIS-0916116
and by the Oﬃce of the Director of National Intelligence (ODNI), Intelligence
Advanced Research Projects Activity (IARPA) through the US Army. Yuliya Lierler
was supported by a 2010 Computing Innovation Fellowship. Vladimir Lifschitz and
Fangkai Yang were supported by the National Science Foundation under grant
IIS-0712113. All statements of fact, opinion, or conclusions contained herein are
those of the authors and should not be construed as representing the oﬃcial views
or policies of IARPA, the ODNI, or the US Government.
References
Akman, V., Erdoğan, S., Lee, J., Lifschitz, V. and Turner, H. 2004. Representing the
Zoo World and the Traﬃc World in the language of the causal calculator. Artiﬁcial
Intelligence 153, 1–2, 105–140.
Armando, A., Giunchiglia, E. and Ponta, S. E. 2009. Formal speciﬁcation and automatic
analysis of business processes under authorization constraints: An action-based approach.
In Proceedings of the 6th International Conference on Trust, Privacy and Security in Digital
Business (TrustBus’09), Linz, Austria.
Artikis, A., Sergot, M. and Pitt, J. 2009. Specifying norm-governed computational societies.
ACM Transactions on Computational Logic 10 , 1.
Caldiran, O., Haspalamutgil, K., Ok, A., Palaz, C., Erdem, E. and Patoglu, V. 2009.
Bridging the gap between high-level reasoning and low-level control. In Proceedings of
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),
242–354.
Clark, K. 1978. Negation as failure. In Logic and Data Bases, H. Gallaire and J. Minker,
Eds. Plenum Press, New York, USA, 293–322.
Ferraris, P. 2005. Answer sets for propositional theories. In Proceedings of International
Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). SpringerVerlag, Berlin, 119–131.
Ferraris, P. 2006. Causal theories as logic programs. In Proceedings of Workshop on Logic
Programming (WLP), Vienna, 35–44.
Ferraris, P. 2007. A logic program characterization of causal theories. In Proceedings of
International Joint Conference on Artiﬁcial Intelligence (IJCAI), 366–371.
Ferraris, P., Lee, J. and Lifschitz, V. 2011. Stable models and circumscription. Artiﬁcial
Intelligence 175, 236–263.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Representing ﬁrst-order causal theories by logic programs

411

Ferraris, P., Lee, J., Lifschitz, V. and Palla, R. 2009. Symmetric splitting in the general
theory of stable models. In Proceedings of International Joint Conference on Artiﬁcial
Intelligence (IJCAI), 797–803.
Gebser, M., Grote, T. and Schaub, T. 2010. Coala: A compiler from action languages to
ASP. In Proceedings of European Conference on Logics in Artiﬁcial Intelligence (JELIA),
169–181.
Gelfond, M. and Lifschitz, V. 1988. The stable model semantics for logic programming. In
Proceedings of International Logic Programming Conference and Symposium, R. Kowalski
and K. Bowen, Eds. MIT Press, Cambridge, MA, USA, 1070–1080.
Gelfond, M. and Lifschitz, V. 1991. Classical negation in logic programs and disjunctive
databases. New Generation Computing 9, 365–385.
Giunchiglia, E., Lee, J., Lifschitz, V., McCain, N. and Turner, H. 2004. Nonmonotonic
causal theories. Artiﬁcial Intelligence 153, 1–2, 49–104.
Giunchiglia, E. and Lifschitz, V. 1998. An action language based on causal explanation:
Preliminary report. In Proceedings of National Conference on Artiﬁcial Intelligence (AAAI).
AAAI Press, California, USA, 623–630.
Glivenko, V. 1929. Sur quelques points de la logique de M. Brouwer. Académie Royale de
Belgique. Bulletins de la Classe des Sciences, se’rie 5 , 15, 183–188.
Lee, J., Lierler, Y., Lifschitz, V. and Yang, F. 2010. Representing synonymity in causal logic
and in logic programming21 . In Proceedings of International Workshop on Nonmonotonic
Reasoning (NMR), Toronto, Canada.
Lee, J. and Palla, R. 2009. System F2LP – computing answer sets of ﬁrst-order formulas. In
Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR), Potsdam, Germany, 515–521.
Lifschitz, V. 1985. Computing circumscription. In Proceedings of International Joint
Conference on Artiﬁcial Intelligence (IJCAI), Los Angeles, CA, USA, 121–127.
Lifschitz, V. 1994. Circumscription. In Handbook of Logic in AI and Logic Programming,
Vol. 3, D. Gabbay, C. Hogger, and J. Robinson, Eds.. Oxford University Press, Oxford, UK,
298–352.
Lifschitz, V. 1997. On the logic of causal explanation. Artiﬁcial Intelligence 96, 451–465.
Lifschitz, V. 2008. What is answer set programming? In Proceedings of the AAAI Conference
on Artiﬁcial Intelligence. MIT Press, Cambridge, MA, 1594–1597.
Lifschitz, V. and Ren, W. 2006. A modular action description language. In Proceedings of
National Conference on Artiﬁcial Intelligence (AAAI), Boston, MA, 853–859.
Lifschitz, V. and Ren, W. 2007. The semantics of variables in action descriptions. In
Proceedings of National Conference on Artiﬁcial Intelligence (AAAI), Vancouver, Canada,
1025–1030.
Lifschitz, V. and Yang, F. 2010. Translating ﬁrst-order causal theories into answer set
programming. In Proceedings of the European Conference on Logics in Artiﬁcial Intelligence
(JELIA), Helsinki, Finland, 247–259.
Marek, V. and Truszczyński, M. 1999. Stable models and an alternative logic programming
paradigm. In The Logic Programming Paradigm: A 25-Year Perspective. Springer Verlag,
Berlin, 375–398.
McCain, N. 1997. Causality in commonsense reasoning about actions,22 PhD thesis, University
of Texas at Austin, Austin, TX.

21
22

http://userweb.cs.utexas.edu/users/vl/papers/syn.pdf
ftp://ftp.cs.utexas.edu/pub/techreports/tr97-25.ps.gz

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

412

P. Ferraris et al.

McCain, N. and Turner, H. 1997. Causal theories of action and change. In Proceedings of
National Conference on Artiﬁcial Intelligence (AAAI), Stanford, CA, 460–465.
McCarthy, J. 1986. Applications of circumscription to formalizing common sense knowledge.
Artiﬁcial Intelligence 26 , 3, 89–116.
Mints, G. 2000. A Short Introduction to Intuitionistic Logic. Kluwer, Dordrecht, Netherlands.
Niemelä, I. 1999. Logic programs with stable model semantics as a constraint programming
paradigm. Annals of Mathematics and Artiﬁcial Intelligence 25, 241–273.
Ren, W. 2009. A modular language for describing actions,23 PhD thesis, University of Texas at
Austin, Austin, TX.
Shanahan, M. 1997. Solving the Frame Problem: A Mathematical Investigation of the Common
Sense Law of Inertia. MIT Press, Cambridge, MA, USA.

23

http://www.cs.utexas.edu/users/rww6/dissertation.pdf

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:01, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000081

Journal of Artificial Intelligence Research 42 (2011) 125-180

Submitted 03/11; published 10/11

First-Order Stable Model Semantics
and First-Order Loop Formulas
Joohyung Lee
Yunsong Meng

joolee@asu.edu
Yunsong.Meng@asu.edu

School of Computing, Informatics,
and Decision Systems Engineering
Arizona State University
Tempe, AZ 85287, USA

Abstract
Lin and Zhao’s theorem on loop formulas states that in the propositional case the stable
model semantics of a logic program can be completely characterized by propositional loop
formulas, but this result does not fully carry over to the first-order case. We investigate
the precise relationship between the first-order stable model semantics and first-order loop
formulas, and study conditions under which the former can be represented by the latter.
In order to facilitate the comparison, we extend the definition of a first-order loop formula
which was limited to a nondisjunctive program, to a disjunctive program and to an arbitrary
first-order theory. Based on the studied relationship we extend the syntax of a logic program
with explicit quantifiers, which allows us to do reasoning involving non-Herbrand stable
models using first-order reasoners. Such programs can be viewed as a special class of firstorder theories under the stable model semantics, which yields more succinct loop formulas
than the general language due to their restricted syntax.

1. Introduction
According to the theorem on loop formulas (Lin & Zhao, 2004), the stable models of a
logic program (Gelfond & Lifschitz, 1988) can be characterized as the models of the logic
program that satisfy all its loop formulas. This idea has turned out to be widely applicable
in relating the stable model semantics to propositional logic, and has resulted in an efficient
method for computing answer sets using SAT solvers. Since the original invention of loop
formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been
extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee,
Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model
semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu &
Truszczynski, 2006; You & Liu, 2008). The theorem has also been applied to other nonmonotonic formalisms, such as nonmonotonic causal theories (Lee, 2004) and McCarthy’s
circumscription (Lee & Lin, 2006). The notion of a loop was further refined as an “elementary loop” (Gebser & Schaub, 2005; Gebser, Lee, & Lierler, 2006, 2011). However,
all this work is restricted to the propositional case. Variables contained in a program are
first eliminated by grounding—the process which replaces every variable with every object
constant—and then loop formulas are obtained from the ground program. As a result, loop
formulas were defined as formulas in propositional logic.
c

2011
AI Access Foundation. All rights reserved.

Lee & Meng

Chen, Lin, Wang, and Zhang’s definition (2006) of a first-order loop formula is different
in that loop formulas are directly obtained from a non-ground program, so that they are
first-order logic formulas which retain variables. However, since the semantics of a logic
program that they refer to is based on grounding, these first-order loop formulas are simply
understood as schemas for ground loop formulas, and only Herbrand models of the loop
formulas were considered in this context.
The stable model semantics that does not involve grounding appeared a year later
(Ferraris, Lee, & Lifschitz, 2007, 2011). The authors define the stable models of a firstorder sentence F as the models of the second-order sentence that is obtained by applying
the “stable model operator” SM to F . The definition of SM is close to the definition of the
circumscription operator CIRC (McCarthy, 1980, 1986). Under the first-order stable model
semantics, logic programs are viewed as a special class of first-order theories. A similar
definition of a stable model was given by Lin and Zhou (2011), via logic of knowledge
and justified assumption (Lin & Shoham, 1992). The first-order stable model semantics is
also closely related to quantified equilibrium logic (Pearce & Valverde, 2005), and indeed,
Ferraris et al. (2011) showed that they are essentially equivalent.
A natural question arising is how first-order loop formulas and the first-order stable
model semantics are related to each other. In general, the first-order stable model semantics
is more expressive than first-order logic, and as such cannot be completely characterized
by first-order loop formulas. Like circumscription, the concept of transitive closure can
be represented in the first-order stable model semantics, but not in any set of first-order
formulas, even if that set is allowed to be infinite.1 However, as we show in this paper,
understanding the precise relationship between them gives us insights into the first-order
stable model semantics and its computational properties.
In order to facilitate the comparison, we extend the definition of a first-order loop
formula which was limited to nondisjunctive programs, to disjunctive programs and to
arbitrary first-order theories. Also we present a reformulation of SM[F ] in the style of loop
formulas, which includes the characterization of a loop by a syntactic formula. From this
formulation, we derive several conditions, under which a first-order theory under the stable
model semantics can be equivalently rewritten as first-order loop formulas.
Based on the relationship between the first-order stable model semantics and first-order
loop formulas, we extend the syntax of logic programs with explicit quantifiers, which may be
useful in overcoming some limitations of traditional answer set programs in reasoning about
non-Herbrand models. We define the semantics of such extended programs by identifying
them as a special class of first-order theories under the stable model semantics. Such
programs inherit from the general language the ability to handle nonmonotonic reasoning
under the stable model semantics even in the absence of the unique name and the domain
closure assumptions that are built into the grounding-based answer set semantics. On
the other hand, the restricted syntax of an extended program leads to more succinct loop
formulas. The following program Π1 is a simple insurance policy example represented in

1. Vladimir Lifschitz, personal communication.

126

First-Order Stable Model Semantics and First-Order Loop Formulas

this syntax.
HasWife(x)
HasWife(x)
Married (x)
∃w Discount(x, w)

←
←
←
←

∃y Spouse(x, y)
Man(x), Married (x)
Man(x), HasWife(x)
Married (x), not ∃z Accident(x, z).

The second and the third rules express that Married (x) and HasWife(x) are synonymous
to each other when x is a Man. The last rule states that x is eligible for some discount
plan (with the name unknown) if x is married and has no record of accident. The quantifier
in the first rule can be dropped without affecting the meaning, but the other quantifiers
cannot. We will say that a program Π entails a query F (under the stable model semantics)
if every stable model of Π satisfies F . For example,
• Π1 conjoined with Π2 = {Man(John)} entails each of ¬∃x Married (x) and
¬∃xy Discount(x, y).
• Π1 ∪ Π2 conjoined with Π3 = {∃y Spouse(John, y)} entails neither ¬∃x Married (x)
nor ¬∃xy Discount(x, y), but entails each of ∃x Married (x), ∃xyDiscount(x, y), and
∀xy(Discount(x, y) → x = John).
• Π1 ∪ Π2 ∪ Π3 conjoined with Π4 = {∃z Accident(John, z)} does not entail
∀xy(Discount(x, y) → x = John), but entails ¬∃w Discount(John, w).
The nonmonotonic reasoning of this kind requires non-Herbrand models since the names
(or identifiers) of discount plans, spouses and accident records may be unknown. However,
the traditional answer set semantics is limited to Herbrand models due to the reference
to grounding. By turning the program into first-order loop formulas we can automate the
example reasoning using a first-order theorem prover.
The paper is organized as follows. The next section reviews the first-order stable model
semantics by Ferraris et al. (2007, 2011). Section 3 reviews the theorem on first-order loop
formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary
first-order sentences, limiting attention to Herbrand stable models. Section 4 extends these
results to allow non-Herbrand stable models as well (possibly allowing functions) under a
certain semantic condition, and compare the first-order stable model semantics with loop
formulas by reformulating the former in terms of the latter. In Section 5, we present a series
of syntactic conditions that imply the semantic condition in Section 4. Section 6 provides an
extension of logic programs that contain explicit quantifiers and shows how query answering
for such extended programs can sometimes be reduced to entailment checking in first-order
logic via loop formulas. In Section 7, the results are further extended to distinguish between
intensional and non-intensional predicates. Related work is described in Section 8, and long
proofs are given in Appendix A.
This article is an extended version of a conference paper by Lee and Meng (2008).

2. Review of the First-Order Stable Model Semantics
This review follows a journal paper by Ferraris et al. (2011) that extends a conference
paper by the same authors (Ferraris et al., 2007) by distinguishing between intensional and
non-intensional predicates.
127

Lee & Meng

A formula is defined the same as in first-order logic. A signature consists of function
constants and predicate constants. Function constants of arity 0 are called object constants.
We assume the following set of primitive propositional connectives and quantifiers:
⊥ (falsity), ∧, ∨, →, ∀, ∃ .
¬F is an abbreviation of F → ⊥, symbol > stands for ⊥ → ⊥, and F ↔ G stands for
(F → G) ∧ (G → F ). We distinguish between atoms and atomic formulas as follows:
an atom of a signature σ is an n-ary predicate constant followed by a list of n terms
that can be formed from function constants in σ (including object constants) and object
variables; atomic formulas of σ are atoms of σ, equalities between terms of σ, and the
0-place connective ⊥.
The stable models of F relative to a list of predicates p = (p1 , . . . , pn ) are defined via
the stable model operator with the intensional predicates p, denoted by SM[F ; p].2 Let u
be a list of distinct predicate variables u1 , . . . , un of the same length as p. By u = p we
denote the conjunction of the formulas ∀x(ui (x) ↔ pi (x)), where x is a list of distinct object
variables of the same length as the arity of pi , for all i = 1, . . . , n. By u ≤ p we denote the
conjunction of the formulas ∀x(ui (x) → pi (x)) for all i = 1, . . . , n, and u < p stands for
(u ≤ p) ∧ ¬(u = p). For any first-order sentence F , the expression SM[F ; p] stands for the
second-order sentence
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
(1)
where F ∗ (u) is defined recursively:
• pi (t)∗ = ui (t) for any list t of terms;
• F ∗ = F for any atomic formula F (including ⊥ and equality) that does not contain
members of p;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;
• (∃xF )∗ = ∃xF ∗ .
(There is no clause for negation here, because we treat ¬F as shorthand for F → ⊥.)
A model of a sentence F (in the sense of first-order logic) is called p-stable if it satisfies
SM[F ; p]. We will often simply write SM[F ] instead of SM[F ; p] when p is the list of all
predicate constants occurring in F , and call a model of SM[F ] simply a stable model of F .
We distinguish between the terms “stable models” and “answer sets” as follows.3 By σ(F )
we denote the signature consisting of the function and predicate constants occurring in F .
2. The intensional predicates p are the predicates that we “intend to characterize” by F .
3. The distinction is useful because in the first-order setting, stable models are no longer Herbrand interpretations and may not be represented by sets of atoms.

128

First-Order Stable Model Semantics and First-Order Loop Formulas

If F contains at least one object constant, an Herbrand interpretation4 of σ(F ) that satisfies
SM[F ] is called an answer set of F . The answer sets of a logic program Π are defined as the
answer sets of the FOL-representation of Π (i.e., the conjunction of the universal closures
of implications corresponding to the rules).
Example 1 For program Π that contains three rules
p(a)
q(b)
r(x) ← p(x), not q(x)
the FOL-representation F of Π is
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))

(2)

and SM[F ] is
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x(((u(x) ∧ (¬v(x) ∧ ¬q(x))) → w(x)) ∧ ((p(x) ∧ ¬q(x)) → r(x)))),
which is equivalent to the first-order sentence
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b) ∧ ∀x(r(x) ↔ (p(x) ∧ ¬q(x)))

(3)

(See Example 3 in the work of Ferraris et al., 2007). The stable models of F are any firstorder models of (3). The only answer set of F is the Herbrand model {p(a), q(b), r(a)}.

3. First-Order Loop Formulas and Herbrand Models
We review the definition of a first-order loop formula for a nondisjunctive program given
by Chen et al. (2006) and extend it to a disjunctive program and to an arbitrary first-order
sentence.
3.1 Review of First-Order Loop Formulas Defined by Chen et al. (2006)
We call a formula negative if every occurrence of every predicate constant in it belongs
to the antecedent of an implication. For instance, any formula of the form ¬F is negative
because this expression is shorthand for F → ⊥. An equality t1 = t2 is also negative because
it contains no predicate constants.
A nondisjunctive program is a finite set of rules of the form
A ← B, N,

(4)

4. Recall that an Herbrand interpretation of a signature σ (containing at least one object constant) is an
interpretation of σ such that its universe is the set of all ground terms of σ, and every ground term
represents itself. An Herbrand interpretation can be identified with the set of ground atoms to which it
assigns the value true.

129

Lee & Meng

where A is an atom, B is a set of atoms, and N is a negative formula. The rules may
contain function constants of positive arity.5
We will say that a nondisjunctive program is in normal form if, for all rules (4) in it, A
is of the form p(x) where x is a list of distinct variables. It is clear that every program can
be turned into normal form using equality in the body. For instance, p(a, b) ← q(a) can be
rewritten as p(x, y) ← x = a, y = b, q(a).
Let Π be a nondisjunctive program and let Norm(Π) be a normal form of Π. By σ(Π) we
denote the signature consisting of function and predicate constants occurring in Π. Given a
finite set Y of atoms, we assume that Norm(Π) does not contain variables in Y , by renaming
the variables in Norm(Π). The (first-order) external support formula of Y for Π, denoted
by ES Π (Y ), is the disjunction of
_


∃z Bθ ∧ N θ ∧

θ:Aθ∈Y

^

0

(t 6= t )


(5)

p(t)∈Bθ
p(t0 )∈Y

for all rules (4) in Norm(Π),6 where θ is a substitution that maps variables in A to terms
occurring in Y , and z is the list of all variables that occur in
Aθ ← Bθ, N θ
but not in Y .
The (first-order) loop formula of Y for Π, denoted by LF Π (Y ), is the universal closure
of
^
Y → ES Π (Y ).
(6)
V
(The expression Y in the antecedent stands for the conjunction of all elements of Y .)
When Π is a propositional program, LF Π (Y ) is equivalent to a conjunctive loop formula as
defined by Ferraris et al. (2006).
The definition of a first-order dependency graph and the definition of a first-order loop
are as follows. We say that an atom p(t) depends on an atom q(t0 ) in a rule (4) if p(t) is
A and q(t0 ) is in B. The (first-order) dependency graph of Π is an infinite directed graph
(V, E) such that
• V is the set of atoms of signature σ(Π);7
• (p(t)θ, q(t0 )θ) is in E if p(t) depends on q(t0 ) in a rule of Π and θ is a substitution
that maps variables in t and t0 to terms (including variables) of σ(Π).
A nonempty subset L of V is called a (first-order) loop of Π if the subgraph of the
first-order dependency graph of Π induced by L is strongly connected.

5. The original definition by Chen et al. (2006) does not allow function constants of positive arity.
6. For any lists of terms t = (t1 , . . . , tn ) and t0 = (t01 , . . . , t0n ) of the same length, t = t0 stands for
(t1 = t01 ) ∧ · · · ∧ (tn = t0n ).
7. Note that V is infinite since infinitely many object variables can be used to form atoms.

130

First-Order Stable Model Semantics and First-Order Loop Formulas

Example 2 Let Π be the following program:
p(x) ← q(x)
q(y) ← p(y)
p(z) ← not r(z).

(7)

The following sets of atoms are first-order loops (among many others): Y1 = {p(u)}, Y2 =
{q(u)}, Y3 = {r(u)}, Y4 = {p(u), q(u)}. Their loop formulas are
LF Π (Y1 )
LF Π (Y2 )
LF Π (Y3 )
LF Π (Y4 )

=
=
=
=

∀u(p(u) → (q(u) ∨ ¬r(u))),
∀u(q(u) → p(u)),
∀u(r(u) → ⊥),
∀u(p(u) ∧ q(u) → (q(u) ∧ u 6= u) ∨ (p(u) ∧ u 6= u) ∨ ¬r(u)).

Example 3 Let Π be the one-rule program
p(x) ← p(y).

(8)

Its finite first-order loops are Yk = {p(x1 ), . . . , p(xk )} where k > 0. Formula LF Π (Yk ) is


(9)
∀x1 . . . xk p(x1 ) ∧ . . . ∧ p(xk ) → ∃y(p(y) ∧ (y 6= x1 ) ∧ . . . ∧ (y 6= xk )) .
The following is a reformulation of Theorem 1 from the work of Chen et al. (2006).
Theorem 1 Let Π be a nondisjunctive program that contains at least one object constant
but no function constants of positive arity, and let I be an Herbrand interpretation of σ(Π)
that satisfies Π.8 The following conditions are equivalent to each other:
(a) I is a stable model of Π;
(b) for every nonempty finite set Y of atoms of σ(Π), I satisfies LF Π (Y );

9

(c) for every finite first-order loop Y of Π, I satisfies LF Π (Y ).
The sets of first-order loop formulas considered in conditions (b) and (c) above have
obvious redundancies. For instance, the loop formula of {p(x)} is equivalent to the loop
formula of {p(y)}; the loop formula of {p(x), p(y)} entails the loop formula of {p(z)}. Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2 , we say
that Y1 subsumes Y2 if there is a substitution θ that maps variables in Y1 to terms so that
Y1 θ = Y2 .
Proposition 1 (Chen et al., 2006, Proposition 7) For any nondisjunctive program Π and
any loops Y1 and Y2 of Π, if Y1 subsumes Y2 , then LF Π (Y1 ) entails LF Π (Y2 ).
Therefore in condition (c) from Theorem 1, it is sufficient to consider a set Γ of loops
such that, for every loop L of Π, there is a loop L0 in Γ that subsumes L. Chen et al. (2006)
called such Γ a complete set of loops. In Example 2, set {Y1 , Y2 , Y3 , Y4 } is a finite complete
set of loops of program (7). Program (8) in Example 3 has no finite complete set of loops.
8. We say that I satisfies Π if I satisfies the FOL-representation of Π.
9. Note that Y may contain variables.

131

Lee & Meng

3.2 Extension to Disjunctive Programs
A disjunctive program is a finite set of rules of the form
A ← B, N,

(10)

where A and B are sets of atoms, and N is a negative formula. Similar to a nondisjunctive
program, we say that a disjunctive program is in normal form if, for all rules (10) in it, all
atoms in A are of the form p(x) where x is a list of distinct variables.
Let Π be a disjunctive program and let Norm(Π) be a normal form of Π. Given a finite
set Y of atoms, we first rename variables in Norm(Π) so that no variables in Norm(Π)
occur in Y . The (first-order) external support formula of Y for Π, denoted by ES Π (Y ), is
the disjunction of

_
^
_
^

∃z Bθ ∧ N θ ∧
(t 6= t0 ) ∧ ¬
p(t) ∧
t 6= t0
(11)
θ:Aθ∩Y 6=∅

p(t)∈Bθ
p(t0 )∈Y

p(t)∈Aθ

p(t0 )∈Y

for all rules (10) in Norm(Π), where θ is a substitution that maps variables in A to terms
occurring in Y or to themselves, and z is the list of all variables that occur in
Aθ ← Bθ, N θ
but not in Y . The (first-order) loop formula of Y for Π, denoted by LF Π (Y ), is the universal
closure of
^
Y → ES Π (Y ).
Clearly, (11) is equivalent to (5) when Π is nondisjunctive. When Π and Y are propositional,
LF Π (Y ) is equivalent to the conjunctive loop formula for a disjunctive program as defined
by Ferraris et al. (2006).
Example 4 Let Π be the program
p(x, y) ; p(y, z) ← q(x)
and let Y = {p(u, v)}. Formula LF Π (Y ) is the universal closure of
p(u, v) → ∃z(q(u) ∧ ¬(p(v, z) ∧ ((v, z) 6= (u, v))))
∨ ∃x(q(x) ∧ ¬(p(x, u) ∧ ((x, u) 6= (u, v)))).
Similar to the nondisjunctive case, we say that p(t) depends on q(t0 ) in Π if there is
a rule (10) in Π such that p(t) is in A and q(t0 ) is in B. The definitions of a first-order
dependency graph and a first-order loop are extended to disjunctive programs in a straightforward way. Using these extended notions, the following theorem extends Theorem 1 to
a disjunctive program. It is also a generalization of the main theorem by Ferraris et al.
(2006) which was restricted to a propositional disjunctive program.
Theorem 1 d Let Π be a disjunctive program that contains at least one object constant but
no function constants of positive arity, and let I be an Herbrand interpretation of σ(Π) that
satisfies Π. The following conditions are equivalent to each other:
132

First-Order Stable Model Semantics and First-Order Loop Formulas

(a) I is a stable model of Π;
(b) for every nonempty finite set Y of atoms of σ(Π), I satisfies LF Π (Y );
(c) for every finite first-order loop Y of Π, I satisfies LF Π (Y ).

3.3 Extension to Arbitrary Sentences
In this section we extend the definition of a first-order loop formula to an arbitrary firstorder sentence.
As with a propositional loop formula defined for an arbitrary propositional theory (Ferraris et al., 2006), it is convenient to introduce a formula whose negation is close to ES . We
define formula NES F (Y ) (“Negation of (First-order) External Support Formula”), where F
is a first-order formula and Y is a finite set of atoms, as follows. As before we assume that
no variables in Y occur in F , by renaming variables.
• NES pi (t) (Y ) = pi (t) ∧

V

pi (t0 )∈Y

t 6= t0 ;

• NES t1 =t2 (Y ) = (t1 = t2 );
• NES ⊥ (Y ) = ⊥;
• NES F ∧G (Y ) = NES F (Y ) ∧ NES G (Y );
• NES F ∨G (Y ) = NES F (Y ) ∨ NES G (Y );
• NES F →G (Y ) = (NES F (Y ) → NES G (Y )) ∧ (F → G);
• NES ∀xG (Y ) = ∀xNES G (Y );
• NES ∃xG (Y ) = ∃xNES G (Y ).
The (first-order) loop formula of Y for F , denoted by LF F (Y ), is the universal closure
of
^

Y → ¬NES F (Y ).

(12)

Note that the definition of NES looks similar to the definition of F ∗ given in Section 2.
When F and Y are propositional, LF F (Y ) is equivalent to a conjunctive loop formula for
a propositional formula that is defined by Ferraris et al. (2006). The following lemma tells
us that the definition of a loop formula in this section generalizes the definition of a loop
formula for a disjunctive program in the previous section.
Lemma 1 Let Π be a disjunctive program in normal form, F an FOL-representation of
Π, and Y a finite set of atoms. Formula NES F (Y ) is equivalent to ¬ES Π (Y ) under the
assumption F .
133

Lee & Meng

In order to extend the first-order dependency graph to an arbitrary formula, we introduce
a few notions. We say that an occurrence of a subformula G in a formula F is positive if
the number of implications in F containing that occurrence in the antecedent is even; it is
strictly positive if that number is 0. A rule of a first-order formula F is an implication that
occurs strictly positively in F . We will say that a formula is rectified if it has no variables
that are both bound and free, and if all quantifiers in the formula refer to different variables.
Any formula can be easily rewritten into a rectified formula by renaming bound variables.
We say that an atom p(t) depends on an atom q(t0 ) in an implication G → H if
• p(t) has a strictly positive occurrence in H, and
• q(t0 ) has a positive occurrence in G that does not belong to any negative subformula
of G.10
The definition of a first-order dependency graph is extended to formulas as follows. The
(first-order) dependency graph of a rectified formula F is the infinite directed graph (V, E)
such that
• V is the set of atoms of signature σ(F );
• (p(t)θ, q(t0 )θ) is in E if p(t) depends on q(t0 ) in a rule of F and θ is a substitution
that maps variables in t and t0 to terms of σ(F ).
Note that the rectified formula assumption is required in order to distinguish between
dependency graphs of formulas such as
∀x(p(x) → q(x))
and
∀x p(x) → ∀x q(x).
Once the definition of a dependency graph is given, a loop of a first-order formula is
defined in the same way as with a disjunctive program. Theorem 1 can be extended to
first-order sentences using these extended notions.

Theorem 1 f Let F be a rectified sentence that contains at least one object constant but
no function constants of positive arity, and let I be an Herbrand interpretation of σ(F ) that
satisfies F . The following conditions are equivalent to each other:
(a) I is a stable model of F (i.e., I satisfies SM[F ]);
(b) for every nonempty finite set Y of atoms of σ(F ), I satisfies LF F (Y );
(c) for every finite first-order loop Y of F , I satisfies LF F (Y ).
Example 2 (continued) Consider the FOL-representation F of the program in Example 2,
for which {Y1 , Y2 , Y3 , Y4 } is a complete set of loops. Under the assumption F ,
10. Recall the definition of a negative formula in Section 3.1.

134

First-Order Stable Model Semantics and First-Order Loop Formulas

• LF F (Y1 ) is equivalent to the universal closure of

p(u) → ¬ ∀x(q(x) → p(x) ∧ x 6= u) ∧ ∀y(p(y) ∧ y 6= u → q(y))

∧ ∀z(¬r(z) → p(z) ∧ z 6= u) ;
• LF F (Y2 ) is equivalent to the universal closure of


q(u) → ¬ ∀x(q(x) ∧ x 6= u → p(x)) ∧ ∀y(p(y) → q(y) ∧ y 6= u) ;
• LF F (Y3 ) is equivalent to the universal closure of
r(u) → ⊥;
• LF F (Y4 ) is equivalent to the universal closure of

p(u) ∧ q(u) → ¬ ∀x(q(x) ∧ x 6= u → p(x) ∧ x 6= u)

∧ ∀y(p(y) ∧ y 6= u → q(y) ∧ y 6= u) ∧ ∀z(¬r(z) → p(z) ∧ z 6= u) .

Proposition 1 can be straightforwardly extended to arbitrary sentences even without
restricting the attention to loops.
Proposition 1 f For any sentence F and any nonempty finite sets of atoms Y1 and Y2
of σ(F ), if Y1 subsumes Y2 , then LF F (Y1 ) entails LF F (Y2 ).
Proof. Note that LF F (Y1 ) is
∀z

^


Y1 → ¬NES F (Y1 ) ,

(13)

where z is the set of all variables in Y1 . If Y1 subsumes Y2 , by definition, there is a
substitution θ from variables in Y1 to terms in Y2 such that Y1 θ = Y2 . It is clear that (13)
entails
^

∀z0
Y1 θ → ¬NES F (Y1 θ) ,
(14)
where z0 is the set of all variables in Y1 θ. (14) is exactly LF F (Y2 ).



Theorem 2 from the work of Ferraris et al. (2006) is a special case of Theorem 1f when
F is restricted to a propositional formula.
Corollary 1 (Ferraris et al., 2006, Thm. 2) For any propositional formula F , the following
formulas are equivalent to each other under the assumption F .
(a) SM[F ];
(b) the conjunction of LF F (Y ) for all nonempty sets Y of atoms occurring in F ;
(c) the conjunction of LF F (Y ) for all (ground) loops Y of F .
135

Lee & Meng

4. Comparing First-Order Stable Model Semantics and First-Order Loop
Formulas
The theorems in the previous section were restricted to Herbrand stable models. This
section extends the results to allow non-Herbrand stable models as well, and compare the
idea of loop formulas with SM by reformulating the latter in the style of loop formulas.
4.1 Loop Formulas Relative to an Interpretation
Recall that Theorem 1 and its extensions do not allow function constants of positive arity
and are limited to Herbrand models of the particular signature obtained from the given
theory. Indeed, the statements become wrong if these conditions are dropped.
Example 5 The following program contains a unary function constant f .
p(a)
p(x) ← p(f (x)).
The loops of this program are all singleton sets of atoms, and their loop formulas are satisfied
by the Herbrand model {p(a), p(f (a)), p(f (f (a))), . . . } of the program, but this model is not
stable.

Example 3 (continued) The mismatch can happen even in the absence of function constants of positive arity. Consider the program in Example 3 and an interpretation I such
that the universe is the set of all integers, and pI contains all integers. Interpretation I
satisfies all first-order loop formulas (9), but it is not a stable model.
These examples suggest that the mismatch between the first-order stable model semantics and the first-order loop formulas is related to the presence of an infinite path in the
dependency graph that visits infinitely many vertices. In the following we will make this
idea more precise, and extend Theorem 1f to allow non-Herbrand interpretations under a
certain condition.
First, we define a dependency graph relative to an interpretation. Let F be a rectified
formula whose signature is σ and let I be an interpretation of σ. For each element ξ of the
universe |I| of I, we introduce a new symbol ξ  , called an object name. By σ I we denote the
signature obtained from σ by adding all object names ξ  as additional object constants. We
will identify an interpretation I of signature σ with its extension to σ I defined by I(ξ  ) = ξ
(For details, see the work of Lifschitz, Morgenstern, & Plaisted, 2008).
The dependency graph of F w.r.t. I is the directed graph (V, E) where
• V is the set of all atoms of the form pi (ξ  ) where pi belongs to σ(F ) and ξ  is a list
of object names for |I|, and
• (pi (ξ  ), pj (η  )) is in E if there are atoms pi (t), pj (t0 ) such that pi (t) depends on pj (t0 )
in a rule of F and there is a substitution θ that maps variables in t and t0 to object
names such that (tθ)I = ξ and (t0 θ)I = η.
136

First-Order Stable Model Semantics and First-Order Loop Formulas

We call a nonempty subset L of V a loop of F w.r.t. I if the subgraph of the dependency
graph of F w.r.t. I that is induced by L is strongly connected. We say that F is bounded
w.r.t. I if every infinite path in the dependency graph of F w.r.t. I whose vertices are
satisfied by I visits only finitely many vertices. If F is bounded w.r.t. I, then, clearly, every
loop L of F w.r.t. I such that I |= L is finite. The definition is extended to a non-rectified
formula by first rewriting it as a rectified formula. It also applies to the program syntax by
referring to its FOL-representation.
Theorem 2 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is
bounded w.r.t. I, then the following conditions are equivalent to each other:
(a) I |= SM[F ];
(b) for every nonempty finite set Y of atoms formed from predicate constants in σ(F ) and
object names for |I|, I satisfies LF F (Y );
(c) for every finite loop Y of F w.r.t. I, I satisfies LF F (Y ).
The condition that F is bounded w.r.t. I is sufficient for ensuring the equivalence among
(a), (b), and (c), but it is not a necessary condition. For instance, consider F to be
∀x p(x) ∧ ∀xy(p(x) → p(y))
and I to be a model of F whose universe is infinite. Formula F is not bounded w.r.t. I, but
I satisfies every loop formula, as well as SM[F ].
When I is an Herbrand model of σ(F ), the dependency graph of F w.r.t. I is isomorphic to the subgraph of the first-order dependency graph of F that is induced by vertices
containing ground atoms. A set of ground atoms of σ(F ) is a loop of F iff it is a loop of F
w.r.t. I. Hence Theorem 2 is essentially a generalization of Theorem 1f .
Note that the programs considered in Examples 3 and 5 are not bounded w.r.t. the
interpretations considered there.
Clearly, if the universe of I is finite, then F is bounded w.r.t. I. This fact leads to the
following corollary.
Corollary 2 For any rectified sentence F and any model I of F whose universe is finite,
conditions (a), (b), and (c) of Theorem 2 are equivalent to each other.
In view of Proposition 1f and Corollary 2, if the size of the universe is known to be a
finite number n, it is sufficient to consider at most 2|p| − 1 loop formulas, where p is the
set of all predicate constants
occurring in the sentence. Each loop formula is to check the
S
external support of p∈K {p(x1 ), . . . , p(xnr )} for each K where
• K is a nonempty subset of p;
• r is the arity of p and each xi is a list of variables of the length r such that all variables
in x1 , . . . , xnr are pairwise distinct.
137

Lee & Meng

For instance, consider program (8). If the size of the universe is known to be 3, it is sufficient
to consider only one loop formula (9) where k = 3.
Theorem 1f essentially follows from Corollary 2 as the Herbrand universe of σ(F ) is
finite when F contains no function constants of positive arity.
Another corollary to Theorem 2 is acquired when F has only “trivial” loops. We say
that a formula F is atomic-tight w.r.t. I if every path in the dependency graph of F w.r.t. I
whose vertices are satisfied by I is finite. Clearly, this is a special case of boundedness
condition, and every loop L of an atomic-tight formula F w.r.t. I such that I |= L is a
singleton. The following is a corollary to Theorem 2, which tells us the condition under
which stable models can be characterized by loop formulas of singleton loops only. By
SLF[F ] (“loop formulas of singletons”) we denote
{LF F ({p(x)}) | p is a predicate constant in σ(F ), and x is a list
of distinct object variables whose length is the same as the arity of p}.

(15)

Corollary 3 Let F be a rectified sentence (possibly containing function constants of positive
arity), and let I be a model of F . If F is atomic-tight w.r.t. I, then I satisfies SM[F ] iff I
satisfies SLF[F ].
SLF[F ] is similar to Clark’s completion. In the propositional case, the relationship
between the loop formulas of singletons and the completion is studied by Lee (2005). Below
we describe their relationship in the first-order case. A sentence F is in Clark normal form
(Ferraris et al., 2011) if it is a conjunction of formulas of the form
∀x(G → p(x)),

(16)

one for each predicate constant p occurring in F , where x is a list of distinct variables, and
G has no free variables other than x. The completion of a sentence F in Clark normal form,
denoted by Comp[F ], is obtained from F by replacing each conjunctive term (16) with
∀x(p(x) ↔ G).
Any nondisjunctive program can be turned into Clark normal form (Ferraris et al., 2011,
Section 6.1).
Corollary 4 Let F be the FOL-representation of a nondisjunctive program Π, and let F 0
be the Clark normal form of F as obtained by the process described in the work of Ferraris
et al. (2011, Section 6.1). If F is atomic-tight w.r.t. an interpretation I, then I |= SM[F ]
iff I |= Comp[F 0 ].
Proof. Since F is atomic-tight w.r.t. I, by Corollary 3, I |= SM[F ] iff I |= F ∧ SLF[F ]. It
is sufficient to show that, for each predicate constant p occurring in F , under the assumption
that F is atomic-tight w.r.t. I,


_
^

I |= ∀x p(x) →
∃z (x = t0 ) ∧ B ∧ N ∧
(t 6= x)
(17)
p(t0 )←B,N ∈Π

p(t)∈B

138

First-Order Stable Model Semantics and First-Order Loop Formulas

iff




∃z (x = t ) ∧ B ∧ N ,

_

I |= ∀x p(x) →

0



(18)

p(t0 )←B,N ∈Π

where z is the list of all free variables in p(x) ← (x = t0 ), B, N that are not in x.
Note that (17) is equivalent to saying that


^
_

0
0
(t 6= t ) .
∃z (x = t ) ∧ B ∧ N ∧
I |= ∀x p(x) →
p(t0 )←B,N ∈Π

(19)

p(t)∈B

From the assumption that F is atomic-tight w.r.t. I, it follows that, for any rule p(t0 ) ←
B, N in Π and any atom of p(t) in B, I |= ∀y(t 6= t0 ), where y is the list of all variables in
t and t0 (otherwise we find a singleton loop with a self-cycle, which contradicts that F is
atomic tight w.r.t. I). Consequently, (19) is equivalent to (18).

For example, let F be the FOL-representation of the program
p(b) ← p(a)
← a 6= b

(20)

SLF[p(a) → p(b)] is ∀x(p(x) → x = b ∧ p(a) ∧ x 6= a), while Comp[∀x(x = b ∧ p(a) → p(x))]
is ∀x(p(x) ↔ x = b ∧ p(a)). The additional conjunctive term x 6= a can be dropped when
we consider any model I of F , for which aI 6= bI .
Corollary 4 is an enhancement of Theorem 11 from the work of Ferraris et al. (2011),
which states the equivalence between SM[F ] and Comp[F ] for any tight sentence F in Clark
normal form. (Tight sentences are defined in a similar way, but in terms of a predicate
dependency graph, whose vertices are predicate constants instead of atoms.) Every tight
sentence is atomic-tight w.r.t. any model of the sentence. On the other hand, program (20)
is atomic-tight w.r.t. any model of the program, but is not tight.
Theorem 2 tells us that one of the limitations of first-order loop formulas is that, even
if infinitely many first-order loop formulas are considered, they cannot ensure the external
support of a certain infinite set that forms an infinite path in the dependency graph of F
w.r.t. I. In the next section, by reformulating SM[F ], we show that the definition of SM[F ]
essentially encompasses loop formulas, ensuring the external support of any sets of atoms,
including those “difficult” infinite sets.
4.2 A Reformulation of SM
As before, let F be a first-order formula of a signature σ, let p = (p1 , . . . , pn ) be the list
of all predicate constants occurring in F , and let u and v be lists of predicate variables of
the same length as p. We define NSES F (u) (“Negation of Second-Order External Support
Formula”) recursively as follows.
• NSES pi (t) (u) = pi (t) ∧ ¬ui (t);
• NSES t1 =t2 (u) = (t1 = t2 );
• NSES ⊥ (u) = ⊥;
139

Lee & Meng

• NSES F ∧G (u) = NSES F (u) ∧ NSES G (u);
• NSES F ∨G (u) = NSES F (u) ∨ NSES G (u);
• NSES F →G (u) = (NSES F (u) → NSES G (u)) ∧ (F→ G);
• NSES ∀xF (u) = ∀xNSES F (u);
• NSES ∃xF (u) = ∃xNSES F (u).
Lemma 2 Let F be a rectified sentence of a signature σ, I an interpretation of σ, p the
list of predicate constants occurring in F , q a list of predicate names 11 of the same length
as p and Y a set of atoms formed from predicate constants from σ(F ) and object names
such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. If Y is finite, then
I |= NSES F (q) iff I |= NES F (Y ).
Proof. By induction on F . We only list the case when F is an atom. The other cases are
straightforward. Let F be an atom pi (ξ  ).
iff
iff
iff
iff
iff

I |= NSES F (q)
I |= pi (ξ  ) ∧ ¬qi (ξ  )
I |= pi (ξ  ) and pi (ξ  ) ∈
/Y
 such that p (η  ) ∈ Y, it holds that ξ  6= η 
I |= pi (ξ  ) and
for
all
η
i
V
I |= pi (ξ  ) ∧ pi (η )∈Y ξ  6= η 
I |= NES F (Y ).


SM[F ] can be written in terms of NSES as follows. By Nonempty(u) we denote the
formula
∃x1 u1 (x1 ) ∨ · · · ∨ ∃xn un (xn ),
where each xi is a list of distinct variables whose length is the same as the arity of pi .
Proposition 2 For any sentence F , SM[F ] is equivalent to
F ∧ ∀u((u ≤ p) ∧ Nonempty(u) → ¬NSES F (u)).

(21)

Now we represent the notion of a loop by a second-order formula. Given a rectified
formula F , by EF (v, u) we denote
_
∃z(vi (t) ∧ uj (t0 ) ∧ ¬vj (t0 )),
(pi (t),pj (t0 )) :
pi (t) depends on pj (t0 ) in a rule of F

11. Like object names, for every n > 0, each subset of |I|n has a name, which is an n-ary predicate constant
not from the underlying signature.

140

First-Order Stable Model Semantics and First-Order Loop Formulas

where z is the list of all object variables in t and t0 . By Loop F (u) we denote the second-order
formula
Nonempty(u) ∧ ∀v((v < u) ∧ Nonempty(v) → EF (v, u)).
(22)
Formula (22) represents the concept of a loop without referring to the notion of a dependency
graph explicitly. This is based on the following observation. Consider a finite propositional
program Π. A nonempty set U of atoms that occur in Π is a loop of Π iff, for every
nonempty proper subset V of U , there is an edge from an atom in V to an atom in U \ V
in the dependency graph of Π (Gebser et al., 2006).
Recall the definition of a dependency graph relative to an interpretation. Let F be
a rectified sentence of a signature σ, and let I be an interpretation of σ. The following
proposition describes the relationship between formula (22) and a loop of F w.r.t. I.
Proposition 3 Let q be a list of predicate names corresponding to p, and let Y be a set of
atoms in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. Then I |= Loop F (q) iff Y is a loop of F w.r.t. I.
One might expect that, similar to the equivalence between conditions (a) and (c) from
Theorem 2, formula SM[F ] is equivalent to the following formula:
F ∧ ∀u((u ≤ p) ∧ Loop F (u) → ¬NSES F (u)).

(23)

However, the equivalence does not hold in general, as the following example illustrates.
Example 6 Consider the FOL-representation F of the following program
p(x, y) ← q(x, z)
q(x, z) ← p(y, z),
and an interpretation I whose universe is the set of all nonnegative integers such that
pI = {(m, m) | m is a nonnegative integer},
q I = {(m, m+1) | m is a nonnegative integer}.
Formula F is not bounded w.r.t. I since the dependency graph of F w.r.t. I contains an
infinite path such as
hp(0 , 0 ), q(0 , 1 ), p(1 , 1 ), q(1 , 2 ), . . .i.

(24)

The interpretation I satisfies every loop formula of every finite loop of F w.r.t. I, but it is
not a stable model.
In the example, what distinguishes the set
{p(0 , 0 ), q(0 , 1 ), p(1 , 1 ), q(1 , 2 ), . . . }

(25)

from a loop is that, for every loop contained in (25), there is an outgoing edge in the dependency graph. This is an instance of what we call “unbounded set.” Given a dependency
graph of F w.r.t. I, we say that a nonempty set Y of vertices is unbounded w.r.t. I if, for
every subset Z of Y that is a loop, there is an edge from a vertex in Z to a vertex in Y \ Z.
The following proposition tells us how an unbounded set can be characterized by a
second-order formula.
141

Lee & Meng

Proposition 4 Let q be a list of predicate names corresponding to p, and let Y be a set of
atoms in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. Then
I |= Nonempty(q) ∧ ∀v((v ≤ q) ∧ Loop F (v) → EF (v, q))
iff Y is an unbounded set of F w.r.t. I.
In order to check the stability of a model, we need to check the external support of every
loop and every unbounded set. An extended loop of F w.r.t. I is a loop or an unbounded
set of F w.r.t. I. We define Ext-Loop F (u) as
Loop F (u) ∨ (Nonempty(u) ∧ ∀v((v ≤ u) ∧ Loop F (v) → EF (v, u))).

(26)

From Propositions 3 and 4, it follows that I |= Ext-Loop F (q) iff Y is an extended loop of
F w.r.t. I.
If we replace Loop F (u) with Ext-Loop F (u) in (23), the formula is equivalent to SM[F ],
as the following theorem states.
Theorem 3 For any rectified sentence F , the following sentences are equivalent to each
other:
(a) SM[F ];
(b) F ∧ ∀u((u ≤ p) ∧ Nonempty(u) → ¬NSES F (u));
(c) F ∧ ∀u((u ≤ p) ∧ Ext-Loop F (u) → ¬NSES F (u)).
In the following example we use the following fact to simplify the formulas.
Proposition 5 For any negative formula F , formula
NSES F (u) ↔ F
is logically valid.
Example 2 (continued) Consider program (7) from Example 2:
p(x) ← q(x)
q(y) ← p(y)
p(z) ← not r(z).
Let F be the FOL-representation of the program:



∀x q(x) → p(x) ∧ ∀y p(y) → q(y) ∧ ∀z ¬r(z) → p(z) .
142

First-Order Stable Model Semantics and First-Order Loop Formulas

1. SM[F ] is equivalent to
F ∧ ¬∃u1 u2 u3 ((u1 , u2 , u3 ) < (p, q, r))∧
∀x(u2 (x) → u1 (x)) ∧ ∀y(u1 (y) → u2 (y)) ∧ ∀z(¬r(z) → u1 (z))).
2. Formula in Theorem 3 (b):
F ∧ ∀u(u ≤ p ∧ Nonempty(u) → ¬NSES F (u))
is equivalent to
F ∧ ∀u1 u2 u3 ((u1 , u2 , u3 ) ≤ (p, q, r) ∧ (∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
→ ¬(∀x[q(x) ∧ ¬u2 (x) → p(x) ∧ ¬u1 (x)]
∧∀y[p(y) ∧ ¬u1 (y) → q(y) ∧ ¬u2 (y)]
∧∀z[¬r(z) → p(z) ∧ ¬u1 (z)])).

(27)

3. Formula in Theorem 3 (c): Similar to (27) except that
∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x)
in (27) is replaced with Ext-Loop F (u), which is
Loop F (u) ∨ [(∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
∧ ∀v1 v2 v3 (((v1 , v2 , v3 ) ≤ (u1 , u2 , u3 )) ∧ Loop F (v)
→ (∃x(v1 (x) ∧ u2 (x) ∧ ¬v2 (x)) ∨ ∃y(v2 (y) ∧ u1 (y) ∧ ¬v1 (y))))],
where Loop F (u) is
(∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
∧ ∀v1 v2 v3 (((∃x v1 (x) ∨ ∃x v2 (x) ∨ ∃x v3 (x)) ∧ (v1 , v2 , v3 ) < (u1 , u2 , u3 ))
→ (∃x(v1 (x) ∧ u2 (x) ∧ ¬v2 (x)) ∨ ∃y(v2 (y) ∧ u1 (y) ∧ ¬v1 (y)))).
The proof of Theorem 2 follows from Theorem 3 using the following lemma.
Lemma 3 Let F be a rectified sentence of a signature σ (possibly containing function constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is bounded
w.r.t. I,
I |= ∃u(u ≤ p ∧ Ext-Loop F (u) ∧ NSES F (u))
iff there is a finite loop Y of F w.r.t. I such that
^

I |=
Y ∧ NES F (Y ) .

5. Representing First-Order Stable Model Semantics by First-Order
Loop Formulas
We noted in the previous section that if a sentence is bounded w.r.t. a model, then loop
formulas can be used to check the stability of the model. In this section, we provide a few
syntactic counterparts of the boundedness condition.
143

Lee & Meng

5.1 Bounded Formulas
We say that a rectified formula F is bounded if every infinite path in the first-order dependency graph of F visits only finitely many vertices. If F is bounded, then, clearly, every loop
of F is finite. Again, the definition is extended to a non-rectified formula by first rewriting
it as a rectified formula. It also applies to a program by referring to its FOL-representation.
One might wonder if the syntactic notion of boundedness ensures the semantic notion of
boundedness: that is, if a formula is bounded, then it is bounded w.r.t. any interpretation.
However, the following example tells us that this is not the case in general.
Example 7 Consider the FOL-representation F of the following program
p(a) ← q(x)
q(x) ← p(b),

(28)

and an interpretation I whose universe |I| is the set of all nonnegative integers, aI = bI = 0,
pI = {0} and q I = |I|. Formula (28) is bounded according to the above definition, but not
bounded w.r.t. I: the dependency graph of F w.r.t. I contains an infinite path such as
hp(0 ), q(1 ), p(0 ), q(2 ), . . . i.
5.1.1 Bounded Formulas and Clark’s Equational Theory
On the other hand, such a relationship holds if the interpretation satisfies Clark’s equational
theory (1978). Clark’s equational theory of a signature σ, denoted by CETσ , is the union
of the universal closures of the following formulas
f (x1 , . . . , xm ) 6= g(y1 , . . . , yn ),

(29)

for all pairs of distinct function constants f , g,
f (x1 , . . . , xn ) = f (y1 , . . . , yn ) → (x1 = y1 ∧ . . . ∧ xn = yn ),

(30)

for all function constants f of arity > 0, and
t 6= x,

(31)

where t is any term which contains the variable x.
Proposition 6 If a rectified formula F of a signature σ is bounded, then F is bounded
w.r.t. any interpretation of σ that satisfies CETσ .
The following lemma relates loops and loop formulas of different notions of dependency
graphs.
Proposition 7 For any rectified sentence F of a signature σ and for any interpretation I
of σ that satisfies CETσ , I is a model of
{LF F (Y ) | Y is a finite first-order loop of F }
iff I is a model of
{LF F (Y ) | Y is a finite loop of F w.r.t. I}.
144

First-Order Stable Model Semantics and First-Order Loop Formulas

The following theorem follows from Theorem 2, Proposition 6 and Proposition 7.
Theorem 4 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F and CETσ .
If F is bounded, then the following conditions are equivalent to each other:
(a) I |= SM[F ];
(b) for every nonempty finite set Y of atoms of σ(F ), I satisfies LF F (Y );
(c) for every finite first-order loop Y of F , I satisfies LF F (Y ).
Proof. By Proposition 6, if F is bounded then F is bounded w.r.t. any interpretation
that satisfies CETσ . Then the equivalence between (a) and (b) follows from the equivalence
between (a) and (b) of Theorem 2. The equivalence between (a) and (c) follows from the
equivalence between (a) and (c) of Theorem 2 and by Proposition 7.

As every Herbrand interpretation of σ satisfies CETσ , Theorem 4 applies to Herbrand
interpretations as a special case.
The theorem also applies to logic programs, since they can be viewed as a special case
of formulas. For example, consider the following program, which is bounded.
p(f (x)) ← q(x)
q(x) ← p(x), r(x)
p(a)
r(a)
r(f (a)).

(32)

The set {p(a), p(f (a)), p(f (f (a))), q(a), q(f (a)), r(a), r(f (a))} is an answer set of (32). In
accordance with Theorem 4, it is also the Herbrand interpretation of the signature obtained
from the program that satisfies the FOL-representation of (32) and the loop formulas, which
are the universal closures of
p(z) → (q(x) ∧ z = f (x)) ∨ z = a
q(z) → p(z) ∧ r(z)
r(z) → z = a ∨ z = f (a).
Consider another example program by Bonatti (2004), where a, . . . , z, nil are object
constants.
letter (a)
...
letter (z)
(33)
atomic([x]) ← letter (x)
atomic([x|y]) ← letter (x), atomic(y).
The expression [x|y] is a list whose head is x and whose tail is y, which stands for a function
cons(x, y). The expression [x] stands for cons(x, nil) where nil is a special symbol for
145

Lee & Meng

the empty list. This program is bounded. The only answer set of the program is the only
Herbrand interpretation of the FOL-representation of (33) and the universal closures of
letter (u) → u = a ∨ . . . ∨ u = z
atomic(u) → ∃v (letter (v) ∧ u = cons(v, nil))
∨ ∃xy (letter (x) ∧ atomic(y) ∧ y 6= u ∧ u = cons(x, y)).
In fact, the definitions of standard list processing predicates, such as member, append, and
reverse (Bonatti, 2004, Figure 1) are bounded, so they can be represented by first-order
formulas on Herbrand interpretations.12
We say that a formula F is atomic-tight if the first-order dependency graph of F has no
infinite paths. Every tight sentence is atomic-tight, but not vice versa. For example, the
FOL-representations of programs (32) and (33) are atomic-tight, but are not tight. Similar
to Proposition 6, if F is atomic-tight, then F is atomic-tight w.r.t. any interpretation that
satisfies CETσ , so that the following statement is derived from Corollary 3.
Corollary 5 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F and CETσ .
If F is atomic-tight, then I satisfies SM[F ] iff I satisfies SLF[F ].
The statement of Corollary 5 is restricted to interpretations that satisfy CETσ . Indeed,
the statement becomes wrong if this restriction is dropped. For example, program (28)
in Example 7 is atomic-tight, but the non-stable model considered there satisfies all loop
formulas, including those of singleton loops.
5.1.2 Bounded Formulas and Normal Form
Normal form is another syntactic condition that can be imposed so that the syntactic notion
of boundedness ensures the semantic notion of boundedness. We say that a formula is in
normal form if every strictly positive occurrence of an atom is of the form p(x), where x is
a list of distinct variables. It is clear that every formula can be turned into normal form
using equality.
Proposition 8 If a rectified formula F in normal form is bounded, then F is bounded w.r.t.
any interpretation.
Proposition 9 If a rectified sentence F in normal form is bounded, then for any interpretation I, I is a model of
{LF F (Y ) | Y is a finite first-order loop of F }
iff I is a model of
{LF F (Y ) | Y is a finite loop of F w.r.t. I}.
The following theorem follows from Theorem 2, Proposition 8 and Proposition 9.
12. They actually satisfy a stronger condition called “finitely recursive” (Bonatti, 2004). See Section 8 for
more details.

146

First-Order Stable Model Semantics and First-Order Loop Formulas

Theorem 5 Let F be a rectified sentence in normal form (possibly containing function
constants of positive arity). If F is bounded, then the following formulas are equivalent to
each other:
(a) SM[F ];
(b) {F } ∪ {LF F (Y ) | Y is a nonempty finite set of atoms of σ(F )};
(c) {F } ∪ {LF F (Y ) | Y is a finite first-order loop of F }.
Proof. By Proposition 8, if F is bounded then F is bounded w.r.t. any interpretation I.
Then the equivalence between (a) and (b) follows from the equivalence between (a) and (b)
of Theorem 2. The equivalence between (a) and (c) follows from the equivalence between
(a) and (c) of Theorem 2 and by Proposition 9.

Consider a program in normal form
p(x) ← x = a, q(a)
q(y) ← p(b)

(34)

and an interpretation I such that |I| = {1}, aI = bI = 1 and pI = q I = {1}. This
interpretation does not satisfy Clark’s equational theory, and is not a stable model. In
accordance with Theorem 5, I does not satisfy the loop formula of the loop {p(b), q(a)},
which is
p(b) ∧ q(a) → (b = a ∧ q(a) ∧ a 6= a) ∨ (p(b) ∧ b 6= b).
On the other hand, consider another program in non-normal form that has the same
stable models as (34):
p(a) ← q(a)
(35)
q(y) ← p(b)
Program (35) has a finite complete set of loops, {{p(z)}, {q(z)}}; their loop formulas are
the universal closures of
p(z) → z = a ∧ q(a)
q(z) → p(b)
and I satisfies all loop formulas. This example illustrates the role of normal form assumption
in Theorem 5 (in place of Clark’s equational theory in Theorem 4).
Note that a normal form conversion may turn a bounded sentence into a non-bounded
sentence. For instance, the normal form of the bounded program (32) is
p(y) ← y = f (x), q(x)
q(x) ← p(x), r(x)
p(x) ← x = a
r(x) ← x = a
r(x) ← x = f (a),

(36)

which is not bounded.
Unlike in Corollary 5, if a program is in normal form, atomic-tightness is not more
general than tightness. It is not difficult to check that a program in normal form is atomictight iff it is tight.
147

Lee & Meng

5.1.3 Decidability of Boundedness and Finite Complete Set of Loops
In general, checking whether F is bounded is not decidable, but it becomes decidable if F
contains no function constants of positive arity. The same is the case for checking whether
F is atomic-tight.
Proposition 10 For any rectified sentence F (allowing function constants of positive arity),
(a) checking whether F is bounded is not decidable;
(b) checking whether F is atomic-tight is not decidable.
If F contains no function constants of positive arity,
(c) checking whether F is bounded is decidable;
(d) checking whether F is atomic-tight is decidable.
The proof of Proposition 10 (c) is based on the following fact and the straightforward
extension of Theorem 2 by Chen et al. (2006) to first-order formulas, which asserts that
checking if F has a finite complete set of loops is decidable.
Proposition 11 For any rectified formula F that contains no function constants of positive
arity, F is bounded iff F has a finite complete set of loops.
Note that Proposition 11 does not hold if F is allowed to contain function constants of
positive arity. For instance,
p(x) ← p(f (x))
is not bounded, but has a finite complete set of loops {{p(x)}}.
The following corollary follows from Theorem 4 and Proposition 11.
Corollary 6 Let F be a rectified sentence of a signature σ that has no function constants
of positive arity, and let I be an interpretation of σ that satisfies F and CETσ . If F has a
finite complete set of loops, then conditions (a), (b), and (c) of Theorem 4 are equivalent
to each other.
The following corollary follows from Theorem 5 and Proposition 11.
Corollary 7 Let F be a rectified sentence in normal form that has no function constants
of positive arity. If F has a finite complete set of loops, formulas in (a), (b), and (c) of
Theorem 5 are equivalent to each other.
148

First-Order Stable Model Semantics and First-Order Loop Formulas

5.2 Semi-Safe Formulas
Semi-safety is another decidable syntactic condition that ensures that SM[F ] can be expressed by first-order sentences.
We assume that there are no function constants of positive arity. According to Lee,
Lifschitz, and Palla (2009), a semi-safe sentence has the “small predicate property”: the
relation represented by any of its predicate constants p can hold for a tuple of arguments
only if each member of the tuple is represented by an object constant occurring in F . We
will show that any semi-safe sentence under the stable model semantics can be turned into
a sentence in first-order logic.
First, we review the notion of semi-safety by Lee et al. (2009).13 As a preliminary step,
we assign to every formula F a set RV(F ) of its restricted variables as follows:
• For an atomic formula F ,
– if F is an equality between two variables, then RV(F ) = ∅;
– otherwise, RV(F ) is the set of all variables occurring in F ;
• RV(G ∧ H) = RV(G) ∪ RV(H);
• RV(G ∨ H) = RV(G) ∩ RV(H);
• RV(G → H) = ∅;
• RV(QvG) = RV(G) \ {v} where Q ∈ {∀, ∃}.
We say that a variable x is restricted in F if x ∈ RV(F ). A rectified formula F is semisafe if every strictly positive occurrence of every variable x belongs to a subformula G → H
where x is restricted in G.
If a sentence has no strictly positive occurrence of a variable, then it is obviously semisafe. The FOL-representation of a disjunctive program is semi-safe if, for each rule (10)
of the program, every variable occurring in the head of the rule occurs in B as well.
Example 8 The FOL-representation of (8) is not semi-safe. Formula
p(a) ∧ q(b) ∧ ∀xy((p(x) ∨ q(y)) → p(y))
is not semi-safe, while
p(a) ∧ q(b) ∧ ∀xy((p(x) ∧ q(y)) → p(y))

(37)

is semi-safe.
For any finite set c of object constants, in c (x) stands for the formula
_
x = c.
c∈c

13. The definition here is slightly more general in that it does not refer to prenex form. Instead we require
a formula to be rectified.

149

Lee & Meng

The small predicate property can be expressed by the conjunction of the sentences


^
∀v1 , . . . , vn p(v1 , . . . , vn ) →
inc (vi )
i=1,...,n

for all predicate constants p occurring in F , where v1 , . . . , vn are distinct variables. We
denote this conjunction of the sentences by SPP c . By c(F ) we denote the set of all object
constants occurring in F .
Proposition 12 (Lee et al., 2009) For any semi-safe sentence F , formula SM[F ] entails
SPP c(F ) .
For example, for the semi-safe sentence (37), SM[(37)] entails


∀x p(x) → (x = a ∨ x = b)) ∧ ∀x(q(x) → (x = a ∨ x = b) .

(38)

The following proposition tells us that for a semi-safe sentence F , formula SM[F ] can
be equivalently rewritten as a first-order sentence.
Theorem 6 Let F be a rectified sentence that has no function constants of positive arity.
If F is semi-safe, then SM[F ] is equivalent to the conjunction of F , SPP c(F ) and a finite
number of first-order loop formulas.
Proof. If F is semi-safe, then SM[F ] entails SPP c(F ) . So it is sufficient to prove that under
the assumption SPP c(F ) , SM[F ] is equivalent to the conjunction of F and a finite number
of first-order loop formulas. It follows from I |= SPP c(F ) that F is bounded w.r.t. I. Since
every finite loop of F w.r.t. I can be represented by a finite set of atoms whose terms are
object variables, it follows from Theorem 2 that I satisfies SM[F ] iff I satisfies the loop
formulas of those sets.

For example, SM[(37)] is equivalent to the conjunction of F , (38) and the universal
closures of
p(z) → z = a ∨ (p(x) ∧ q(z) ∧ z 6= x)
q(z) → z = b
Note that the condition on a finite complete set of loops in Corollaries 6 and 7, and the
condition on semi-safety in Theorem 6 do not entail each other. For instance, formula (37)
is semi-safe, but has no finite complete set of first-order loops, while ∃x p(x) has a finite
complete set of loops {{p(x)}}, but it is not semi-safe. Also program Π1 in Section 1 has a
finite complete set of loops, but it is not semi-safe due to w in the fourth rule.

6. Programs with Explicit Quantifiers
In the following we extend the syntax of a logic program by allowing explicit quantifiers. A
rule with quantifiers is of the form
H ← G,
(39)
where G and H are first-order formulas such that every occurrence of every implication
in G and H belongs to a negative formula. A program with quantifiers is a finite set of rules
150

First-Order Stable Model Semantics and First-Order Loop Formulas

with quantifiers. Program Π1 in Section 1 is an example. The semantics of such a program
is defined by identifying the program with its FOL-representation under the stable model
semantics. By restricting the syntax of a program like the one above, in comparison with
the syntax of an arbitrary formula, we are able to write a more succinct loop formulas, as
we show below.
Let F be a formula and Y a finite set of atoms. By FY we denote the formula obtained
from F by replacing every occurrence
of every atom p(t) in F that does not belong to a
V
negative formula with p(t) ∧ p(t0 )∈Y t 6= t0 . Let Π be a program with quantifiers. Given
a finite set Y of atoms of σ(Π), we first rename variables in Π so that no variables in Π
occur in Y . We define the formula QES Π (Y ) (“External Support Formula for Programs
with Quantifiers”) to be the disjunction of
∃z(GY ∧ ¬HY )

(40)

for every rule (39) such that H contains a strictly positive occurrence of a predicate constant
that occurs in Y , and z is the list of all free variables in the rule that do not occur in Y .
The loop formula of Y for Π is the universal closure of
^
Y → QES Π (Y ).
(41)
The following proposition tells us that (41) is equivalent to (12) when the notions are
applied to a program with explicit quantifiers. It also shows that (41) is a generalization of
the definition of a loop formula for a disjunctive program.
Proposition 13 Let Π be a program with quantifiers, F the FOL-representation of Π,
and Y a finite set of atoms. Under the assumption Π, formula QES Π (Y ) is equivalent to
¬NES F (Y ). If Π is a disjunctive program in normal form, then QES Π (Y ) is also equivalent
to ES Π (Y ) under the assumption Π.
Note that the size of (41) for each Y is polynomial to the size of the given program.
This is not the case when we apply (12) to the FOL-representation of the program, due to
the expansion of NES for nested implications. On the other hand, the syntactic condition
imposed on the rule with quantifiers avoids such an exponential blow up, as the following
lemma tells us.
Lemma 4 Let F be a formula such that every occurrence of an implication in F belongs
to a negative formula and let Y be a set of atoms. NES F (Y ) is equivalent to FY .
Proof. By induction on F .



Example 2 (continued) First-Order Loop Formula when Π is understood as an
extended program (Using QES Π (Y )) : Under the assumption Π,
• LF Π (Y1 ) is equivalent to the universal closure of
p(u) → (∃x(q(x) ∧ ¬(p(x) ∧ x 6= u)) ∨ ∃z(¬r(z) ∧ ¬(p(z) ∧ z 6= u))).
151

Lee & Meng

• LF Π (Y2 ) is equivalent to the universal closure of
q(u) → ∃y(p(y) ∧ ¬(q(y) ∧ y 6= u)).
• LF Π (Y3 ) is equivalent to the universal closure of
r(u) → ⊥.
• LF Π (Y4 ) is equivalent to the universal closure of
(p(u) ∧ q(u)) → (∃x((q(x) ∧ x 6= u) ∧ ¬(p(x) ∧ x 6= u))
∨ ∃y((p(y) ∧ y 6= u) ∧ ¬(q(y) ∧ y 6= u))
∨ ∃z(¬r(z) ∧ ¬(p(z) ∧ z 6= u))).

A finite set Γ of sentences entails a sentence F under the stable model semantics (symbolically, Γ |=SM F ), if every stable model of Γ satisfies F .
If SM[F ] can be reduced to a first-order sentence, as described in Theorem 5 and Theorem 6, then
Γ |=SM F iff Γ ∪ ∆ |= F,
where ∆ is the set of first-order loop formulas required (and possibly including SPP c(F )
when Theorem 6 is applied). This fact allows us to use first-order theorem provers to reason
about query entailment under the stable model semantics.
Example 9 Consider program Π1 in Section 1, which has the following finite complete
set of loops: {Man(u)}, {Spouse(u, v)}, {HasWife(u)}, {Married (u)}, {Accident(u, v)},
{Discount(u, v)}, and {HasWife(u), Married (u)}. Their loop formulas for Π1 ∪ Π2 ∪ Π3 are
equivalent to the universal closure of

Man(u) → ¬ Man(John) ∧ John 6= u ;

Spouse(u, v) → ¬ ∃y Spouse(John, y) ∧ (John, y) 6= (u, v) ;

HasWife(u) → ∃x ∃y Spouse(x, y) ∧ ¬(HasWife(x) ∧ x 6= u)

∨ ∃x Man(x) ∧ Married (x) ∧ ¬(HasWife(x) ∧ x 6= u) ;

Married (u) → ∃x Man(x) ∧ HasWife(x) ∧ ¬(Married (x) ∧ x 6= u) ;
Accident(u, v) → ⊥;
Discount(u, v) →

∃x Married (x) ∧ ¬∃z Accident(x, z) ∧ ¬(∃w(Discount(x, w) ∧ (x, w) 6= (u, v))) ;
Married (u) ∧ HasWife(u) →

∃x ∃y Spouse(x, y) ∧ ¬(HasWife(x) ∧ (x 6= u))

∨ ∃x Man(x) ∧ Married (x) ∧ x 6= u ∧ ¬(HasWife(x) ∧ x 6= u)
∨ ∃x Man(x) ∧ HasWife(x) ∧ x 6= u ∧ ¬(Married (x) ∧ x 6= u) .
152

First-Order Stable Model Semantics and First-Order Loop Formulas

These loop formulas, conjoined with the FOL-representation of Π1 ∪ Π2 ∪ Π3 , entail under
first-order logic each of ∃x Married (x) and ∀xy(Discount(x, y) → x = John). We verified
the answers using a first-order theorem prover Vampire 14 .

7. Extension to Allow Extensional Predicates
The definition of a stable model in the journal paper by Ferraris et al. (2011), reviewed in
Section 2, is more general than the definition in their conference paper (Ferraris et al., 2007)
in that it allows us to distinguish between intensional and non-intensional (a.k.a. extensional) predicates. Similar to Datalog, intensional (output) predicates are characterized in
terms of extensional (input) predicates. For instance, consider Example 9 again, but now assume that Man and Spouse are non-intensional. Π1 ∪ Π2 ∪ Π3 still entails ∃xyDiscount(x, y)
but no longer entails ∀xy(Discount(x, y) → x = John) because there may be a person other
than John who has a spouse.
The results in the earlier sections can be extended to this general semantics in view of
Proposition 14 below, which characterizes SM[F ; p] in terms of SM[F ]. By pr (F ) we denote
the list of all predicate constants occurring in F ; by Choice(p) we denote the conjunction
of “choice formulas” ∀x(p(x) ∨ ¬p(x)) for all predicate constants p in p, where x is a list of
distinct object variables; by False(p) we denote the conjunction of ∀x¬p(x) for all predicate
constants p in p. We sometimes identify a list with the corresponding set when there is no
confusion.
Proposition 14 For any list p of predicate constants, formula SM[F ; p] is equivalent to
SM[F ∧ Choice(pr (F )\p) ∧ False(p\pr (F ))]

(42)

SM[F ¬¬ ∧ Choice(pr (F )\p) ∧ False(p\pr (F ))],

(43)

and to
where F ¬¬ is obtained from F by replacing every atom of the form q(t) in F such that q
does not belong to p by ¬¬q(t).
This proposition allows us to extend the results established for SM[F ] to SM[F ; p]. For
instance, Theorem 3 can be extended to SM[F ; p] by first rewriting it into the form SM[G],
where G is
F ¬¬ ∧ Choice(pr (F )\p) ∧ False(p\pr (F )).
(44)
In the next three corollaries, σ is a signature, F is a rectified sentence of σ (possibly
containing function constants of positive arity), p is any finite list of predicate constants
from σ, and G is (44).
The first corollary follows from Theorem 2 and Proposition 14.
Corollary 8 For any interpretation I of σ that satisfies F , if G is bounded w.r.t. I, then
the following conditions are equivalent to each other:
(a) I |= SM[F ; p];
14. http://www.vampire.fm .

153

Lee & Meng

(b) for every nonempty finite set Y of atoms formed from predicate constants in p and
object names for |I|, I satisfies LF F (Y );
(c) for every finite loop Y of G w.r.t. I whose predicate constants are contained in p, I
satisfies LF F (Y ).
The next corollary follows from Theorem 4 and Proposition 14.
Corollary 9 If G is bounded, then, for any interpretation I of σ that satisfies F and CETσ ,
the following conditions are equivalent to each other:
(a) I |= SM[F ; p];
(b) for every nonempty finite set Y of atoms of σ(G) whose predicate constants are contained in p, I satisfies LF F (Y );
(c) for every finite first-order loop Y of G whose predicate constants are contained in p,
I satisfies LF F (Y ).
The last corollary follows from Theorem 5 and Proposition 14.
Corollary 10 If G is in normal form and is bounded, then the following formulas are
equivalent to each other:
(a) SM[F ; p];
(b) {F } ∪ {LF F (Y ) | Y is a nonempty finite set of atoms of σ(G) whose predicate
constants are contained in p};
(c) {F } ∪ {LF F (Y ) | Y is a finite first-order loop of G whose predicate constants are
contained in p}.
Example 10 Consider Example 9 again, assuming that Man and Spouse are extensional.
Let F be the FOL-presentation of Π1 ∪ Π2 ∪ Π3 and let G be the formula (44). The loops
of G are the same as the loops of F . The loop formulas remain the same as before except
for the following loop formulas of Man(u) and Spouse(u, v):


Man(u) → ¬ Man(John) ∧ John 6= u ∨ ∃x ¬ (Man(x) ∧ x 6= u) ∨ ¬Man(x) ;

Spouse(u, v) → ¬ ∃y Spouse(John, y) ∧ (John, y) 6= (u, v) ∨

∃xy ¬ (Spouse(x, y) ∧ (x, y) 6= (u, v)) ∨ ¬Spouse(x, y) .
These two formulas are tautologies. As a result, the loop formulas of all loops, conjoined
with G, entail ∃xyDiscount(x, y), but no longer entail ∀xy (Discount(x, y) → x = John).
In general, there are no loops of G that contain both intensional and extensional predicates. Also every loop of G that contains an extensional predicate is a singleton, and the
loop formula of such a loop is a tautology.
154

First-Order Stable Model Semantics and First-Order Loop Formulas

Corollary 3 is extended to allow extensional predicates as in the following. By SLF[F ; p],
we denote
{LF F ({p(x)}) | p is a predicate constant in p, and x is a list
of distinct object variables whose length is the same as the arity of p}.
We say that a formula F is p-atomic-tight w.r.t. I if every infinite path in the dependency
graph of F w.r.t. I whose vertices are satisfied by I contains an atom whose predicate
constant is not in p.
Corollary 11 Let F be a rectified sentence (possibly containing function constants of positive arity), and let I be a model of F . If F is p-atomic-tight w.r.t. I, then I satisfies
SM[F ; p] iff I satisfies SLF[F ; p].
The definition of semi-safety is extended to distinguish between intensional and nonintensional predicates as follows. Let F be a formula that has no function constants of
positive arity. To every first-order formula F we assign a set RVp (F ) of restricted variables
relative to p as follows.
• For an atomic formula F (including equality and ⊥),
– if F is an equality between two variables, or is an atom whose predicate constant
is not in p, then RVp (F ) = ∅;
– otherwise, RVp (F ) is the set of all variables occurring in F ;
• RVp (G ∧ H) = RVp (G) ∪ RVp (H);
• RVp (G ∨ H) = RVp (G) ∩ RVp (H);
• RVp (G → H) = ∅.
• RVp (QvG) = RVp (G) \ {v} where Q ∈ {∀, ∃}.
We say that a variable x is p-restricted in F if x ∈ RVp (F ). A rectified formula F is
semi-safe relative to p if every strictly positive occurrence of every variable x belongs to a
subformula G → H, where x is p-restricted in G.
The small predicate property is generalized as follows. Formula SPP pc is the conjunction
of the sentences


^
∀v1 , . . . , vn p(v1 , . . . , vn ) →
inc (vi )
i=1,...,n

for all predicate constants p in p, where v1 , . . . , vn are distinct variables.
Proposition 15 (Lee et al., 2009) For any semi-safe sentence F relative to p, formula
SM[F ; p] entails SPP pc(F ) .
The following proposition tells us that for a semi-safe sentence F , formula SM[F ; p] can
be equivalently rewritten as a first-order sentence.
155

Lee & Meng

Theorem 7 Let F be a rectified sentence that has no function constants of positive arity.
If F is semi-safe relative to p, then SM[F ; p] is equivalent to the conjunction of F , SPP pc(F )
and a finite number of first-order loop formulas.
Proof. Let F be a sentence of the signature σ. If F is semi-safe relative to p, then SM[F ; p]
entails SPP pc(F ) , so it is sufficient to prove that under the assumption SPP pc(F ) , SM[F ; p]
is equivalent to the conjunction of F and a finite number of first-order loop formulas. By
Proposition 14, SM[F ; p] is equivalent to SM[G], where G is (44). Consider any interpretation I of σ that satisfies G and SPP pc(F ) . Note that the dependency graph of G w.r.t. I
contains no outgoing edges from a vertex whose predicate constant does not belong to p.
Together with the fact that I |= SPP pc(F ) , we conclude that each path in the dependency
graph whose vertices are satisfied by I visits only finitely many vertices. Consequently, G
is bounded w.r.t. I. Since every finite loop of G w.r.t. I can be represented by a finite set
of atoms whose terms are object variables, it follows from Theorem 2 that I satisfies SM[G]
iff I satisfies the loop formulas of those sets.


8. Related Work
The notion of a bounded program is related to the notion of a finitely recursive program
studied by Bonatti (2004), where a different definition of a dependency graph was considered. The atom dependency graph of a nondisjunctive ground program defined by Bonatti
is a directed graph such that the vertices are the set of ground atoms, and the edges go
from the atom in the head to atoms in the body of every rule, including those in the negative body. A program is called finitely recursive if, for every atom, there are only finitely
many atoms reachable from it in the atom dependency graph. It is clear that every finitely
recursive program is bounded, but the converse does not hold. For instance, the program
p(x) ← not p(f (x))
is bounded, but is not finitely recursive because there are infinite paths that involve negative
edges. Also the program
p(a) ← q(f (x))
is bounded, but is not finitely recursive because infinitely many atoms q(f (a)), q(f (f (a))), . . .
can be reached from p(a) in the atom dependency graph. Like bounded programs, checking
finitely recursive programs is undecidable in the presence of function constants of positive
arity.
Lin and Wang (2008) extended answer set semantics with functions by extending the
definition of a reduct, and also provided loop formulas for such programs. We can provide
an alternative account of their results by considering the notions there as special cases of
the definitions presented in this paper. For simplicity, we assume non-sorted languages.15
Essentially, they restricted attention to a special case of non-Herbrand interpretations such
that object constants form the universe, and ground terms other than object constants are
mapped to object constants. According to Lin and Wang, an LW-program P consists of
15. Lin and Wang (2008) consider essentially many-sorted languages. The result of this section can be
extended to that case by considering many-sorted SM (Kim, Lee, & Palla, 2009).

156

First-Order Stable Model Semantics and First-Order Loop Formulas

type definitions and a set of rules. Type definitions introduce the domains for a many-sorted
signature consisting of some object constants, and includes the evaluation of each function
symbol of positive arity that maps a list of object constants to an object constant. Since we
assume non-sorted languages, we consider only a single domain (universe). We say that an
interpretation I is a P -interpretation if the universe is the set of object constants specified
by P , object constants are evaluated to itself, and ground terms other than object constants
are evaluated conforming to the type definitions of P .
Proposition 16 Let P be an LW-program and let F be the FOL-representation of the set
of rules in P . The following conditions are equivalent to each other:
(a) I is an answer set of P according to Lin and Wang (2008);
(b) I is a P -interpretation that satisfies SM[F ];
(c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of
F w.r.t. I.
The equivalence between (b) and (c) follows from Proposition 2 since the universe is
finite. The equivalence between (a) and (c) follows from the fact that LW answer sets can
be characterized by loop formulas that are defined by Lin and Wang (2008) and that these
loop formulas are essentially the same as the loop formulas in (c).
Since the proposal of the first-order stable model semantics, there have been some papers
about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program Π that has no function constants of positive arity, its first-order stable
model semantics can be reformulated by a progression based semantics. They also showed
that the programs whose answer sets can be found by a finite progression are exactly those
that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010)
show a game-theoretic characterization for the first-order indefinability of first-order answer
set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order
definability on finite structures by turning programs into modified completion using new
predicates to record levels. Chen, Lin, Zhang, and Zhou (2011) present a condition called
“loop-separable,” which is more refined than finite complete set of loops under which the
finite answer sets of a program can be captured by first-order sentences. However, like the
condition of finite complete set of loops, this condition is disjoint with semi-safety. The
following program is semi-safe but not loop-separable:
p(x) ← p(y), q(x, y).
However, all this work is limited to nondisjunctive programs that contain no function constants of positive arity. Our work is not limited to finite structures, and considers function
constants of positive arity as well. Nonetheless the above papers on first-order definability
are closely related to our work and more insights would be gained from the relationship
between them.
The use of first-order theorem provers for the stable model semantics was already investigated by Sabuncu and Alpaslan (2007), but their results are limited in several ways. They
157

Lee & Meng

considered nondisjunctive logic programs with “trivial” loops only, in which case the stable
model semantics is equivalent to the completion semantics. They also restricted attention
to Herbrand models.

9. Conclusion
This paper puts first-order loop formulas in the context of first-order reasoning and studies
how they are related to first-order stable model semantics. The similarities and mismatches
found in this paper provide useful insights into first-order reasoning with stable models.
Future work is to find further restrictions that make first-order stable model reasoning
decidable and computable in an efficient manner, like the conditions imposed in “finitary”
programs (Bonatti, 2004). Recently, the first-order stable model semantics was shown to
be used as a unifying nonmonotonic logic for integrating rules and ontologies (de Bruijn,
Pearce, Polleres, & Valverde, 2010; Lee & Palla, 2011), in which ontology predicates are
identified with extensional predicates. Based on the studied relationship between first-order
stable model semantics and first-order loop formulas, one may find further restrictions that
are tailored to the hybrid knowledge bases for efficient computation.

Acknowledgments
We are grateful to Joseph Babb, Michael Bartholomew, Piero Bonatti, Vladimir Lifschitz,
and Ravi Palla for useful discussions, and to the anonymous referees for their useful comments. The authors were partially supported by the National Science Foundation under
Grant IIS-0916116 and by the IARPA SCIL program.

Appendix A. Proofs
The proofs are presented in the order of dependencies. Theorem 3 is the main theorem.
The proof of Theorem 2 uses Theorem 3. The proofs of Theorems 4 and 5 follow from
Theorem 2. The proof of Lemma 1 follows from Proposition 13.
In the following, unless otherwise noted, F is a rectified first-order sentence, p is the list
of distinct predicate constants p1 , . . . , pn occurring in F , symbols u, v are lists of distinct
predicate variables of the same length as p, and symbols q, r are lists of distinct predicate
names of the same length as p.
A.1 Proof of Theorem 3
Theorem 3
other:

For any rectified sentence F , the following sentences are equivalent to each

(a) SM[F ];
(b) F ∧ ∀u((u ≤ p) ∧ Nonempty(u) → ¬NSES F (u));
(c) F ∧ ∀u((u ≤ p) ∧ Ext-Loop F (u) → ¬NSES F (u)).
158

First-Order Stable Model Semantics and First-Order Loop Formulas

The notation that we use in the proof involves predicate expressions (Lifschitz, 1994,
Section 3.1) of the form
λxF (x),
(45)
where F (x) is a formula. If e is (45) and G(p) is a formula containing a predicate constant
p of the same arity as the length of x then G(e) stands for the result of replacing each
atomic part of the form p(t) in G(p) with F (t), after renaming the bound variables in G(p)
in the usual way, if necessary. For instance, if G(p) is p(a) ∨ p(b) then G(λy(x = y)) is
x = a ∨ x = b. Substituting a tuple e of predicate expressions for a tuple p of predicate
constants is defined in a similar way.
Lemma 5 Let v be the list of λyi (pi (yi ) ∧ ¬ui (yi )). The following formulas are logically
valid:
• u ≤ p → (F ∗ (u) ↔ NSES F (v));
• u ≤ p → (F ∗ (v) ↔ NSES F (u)).
Proof. By induction.
A.1.1 Proof of Equivalence between (a) and (b) of Theorem 3
It is sufficient to show that
∃u(u < p ∧ F ∗ (u))
is equivalent to
∃v(v ≤ p ∧ Nonempty(v) ∧ NSES F (v)).
From left to right: Take u such that u < p∧F ∗ (u). Let v be the list of λyi (pi (yi ) ∧ ¬ui (yi )).
• Clearly, v ≤ p holds.
• From
u < p, it follows that there are x and i such that pi (x) ∧ ¬ui (x), from which
W
i
i
i ∃x vi (x ) follows, so that Nonempty(v) follows.
• By Lemma 5, NSES F (v) follows from u < p and F ∗ (u).
From right to left: Take v such that v ≤ p ∧ Nonempty(v) ∧ NSES F (v). Let u be the list
of λyi (pi (yi ) ∧ ¬vi (yi )).
• Clearly, u ≤ p holds. Moreover ¬(u = p) holds. Indeed, if u = p, then ∀xi ¬vi (xi )
follows, which contradicts the assumption Nonempty(v). Consequently, u < p follows.
• By Lemma 5, F ∗ (u) follows from v ≤ p and NSES F (v).

159

Lee & Meng

A.1.2 Proof of Proposition 3
Lemma 6 Let I be an interpretation of σ that contains σ(F ), and let q, r be lists of
predicate names corresponding to p. Let Z and Y be sets of atoms in the dependency graph
of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  )
and
pi (ξ  ) ∈ Z iff I |= ri (ξ  ),
where ξ  is a list of object names. Then
I |= r ≤ q ∧ EF (r, q)
iff Z is a subset of Y and there is an edge from an atom in Z to an atom in Y \ Z in the
dependency graph of F w.r.t. I.
Proof. From left to right: Assume I |= r ≤ q ∧ EF (r, q). The fact that Z is a subset of
Y follows from the assumption that I |= r ≤ q and the construction of Z and Y . Since
_
I |=
∃z(ri (t) ∧ qj (t0 ) ∧ ¬rj (t0 )),
(pi (t),pj (t0 )) : pi (t) depends on pj (t0 )
in a rule of F

where z is the list of all object variables in t and t0 , there is a substitution θ that maps
object variables in t and t0 to object names such that
_
I |=
ri (tθ) ∧ qj (t0 θ) ∧ ¬rj (t0 θ).
(pi (t),pj (t0 )) : pi (t) depends on pj (t0 )
in a rule of F

Consequently, there are atoms pi (t), pj (t0 ) such that pi (t) depends on pj (t0 ) in a rule of F
and I |= ri (tθ)∧qj (t0 θ)∧¬rj (t0 θ). From I |= ri (tθ) and the construction of Z, it follows that
pi (((tθ)I ) ) belongs to Z. Also from I |= qj (t0 θ) ∧ ¬rj (t0 θ), it follows that that pj (((t0 θ)I ) )
belongs to Y \ Z. Therefore, there is an edge from an atom in Z to an atom in Y \ Z in the
dependency graph of F w.r.t. I.
From right to left: Assume that Z is a subset of Y and there is an edge from an atom
pi (ξ  ) in Z to an atom pj (η  ) in Y \ Z in the dependency graph of F w.r.t. I. Clearly,
I |= r ≤ q.
From the assumption that pi (ξ  ) ∈ Z, pj (η  ) ∈ Y \ Z and the construction of Y and Z,
it follows that I |= ri (ξ  ) ∧ qj (η  ) ∧ ¬rj (η  ). From the definition of the dependency graph
w.r.t. I, it follows that there are pi (t), pj (t0 ) such that pi (t) depends on pj (t0 ) in a rule of
F with a substitution θ that maps object variables in t and t0 to object names such that
(tθ)I = ξ and (t0 θ)I = η.
Consequently,
_
I |=
ri (tθ) ∧ qj (t0 θ) ∧ ¬rj (t0 θ),
(pi (t),pj (t0 )) : pi (t) depends on pj (t0 )
in a rule of F

160

First-Order Stable Model Semantics and First-Order Loop Formulas

which is equivalent to saying that
_
I |=

∃z(ri (t) ∧ qj (t0 ) ∧ ¬rj (t0 )),

(pi (t),pj (t0 )) : pi (t) depends on pj (t0 )
in a rule of F

where z is the list of all variables in t and t0 .



Lemma 7 A graph (V, E) is strongly connected iff, for any nonempty proper subset U of
V , there is an edge from U to V \ U .
Proof. Follows from the definition of a strongly connected graph.



Proposition 3 Let q be a list of predicate names corresponding to p, and let Y be a set
of atoms in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. Then I |= Loop F (q) iff Y is a loop of F w.r.t. I.
Proof. From left to right: Assume that I |= Loop F (q). From I |= Nonempty(q), it
follows that Y is nonempty.
Take any nonempty proper subset Z of Y . Let r be the list of predicate names such
that
I |= ri (ξ  ) iff pi (ξ  ) ∈ Z.
It is clear that
I |= Nonempty(r) ∧ r < q.
Consequently, from I |= Loop F (q), it follows that I |= E F (r, q). By Lemma 6, there is an
edge from an atom in Z to an atom in Y \ Z. Consequently, by Lemma 7, Y induces a
strongly connected subgraph and thus a loop of F w.r.t. I.
From right to left: Let Y be loop of F w.r.t. I and q a list of predicate names such that
I |= qi (ξ  ) iff pi (ξ  ) ∈ Y.
Since Y is nonempty, I |= Nonempty(q).
Consider any list of predicate names r such that
I |= Nonempty(r) ∧ r < q.
Let Z be a set of vertices in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Z iff I |= ri (ξ  ).
Clearly, Z is a nonempty proper subset of Y . Since Y induces a strongly connected subgraph,
by Lemma 7, there is an edge from an atom in Z to an atom in Y \ Z. Consequently by
Lemma 6, I |= EF (r, q).


161

Lee & Meng

A.1.3 Proof of Proposition 4
Proposition 4 Let q be a list of predicate names corresponding to p, and let Y be a set
of atoms in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. Then
I |= Nonempty(q) ∧ ∀v((v ≤ q) ∧ Loop F (v) → EF (v, q))
iff Y is an unbounded set of F w.r.t. I.
Proof. From left to right: Assume
I |= Nonempty(q) ∧ ∀v(v ≤ q ∧ Loop F (v) → EF (v, q)).

(46)

Since I |= Nonempty(q), it is clear that Y is nonempty.
Take any subset Z of Y that is a loop of F w.r.t. I. Let r be a list of predicate names
such that
I |= ri (ξ  ) iff pi (ξ  ) ∈ Z.
Since Z is a subset of Y , it is clear that I |= r ≤ q. Since Z is a loop of F w.r.t. I, by
Proposition 3, I |= Loop F (r). Consequently, from (46) it follows that I |= E F (r, q). By
Lemma 6, there is an edge from an atom in Z to an atom in Y \ Z. Therefore, Y is an
unbounded set of F w.r.t. I.
From right to left: Let Y be an unbounded set of F w.r.t. I. Since Y is nonempty, it is
clear that I |= Nonempty(q).
Take any list of predicate names r such that I |= r ≤ q ∧ Loop F (r). Let Z be a set of
vertices in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Z iff I |= ri (ξ  ).
By Proposition 3, Z is a loop of F w.r.t. I. It is clear that Z is a subset of Y . Since Y is an
unbounded set of F w.r.t. I, there is an edge from Z to Y \ Z. Consequently by Lemma 6,
I |= EF (r, q).

A.1.4 Proof of Proposition 5
Proposition 5 For any negative formula F , formula
NSES F (u) ↔ F
is logically valid.
Proof. The proof follows immediately from the following two lemmas, which can be proved
by induction.


162

First-Order Stable Model Semantics and First-Order Loop Formulas

Lemma 8 For any formula F ,
NSES F (u) → F
is logically valid.
Lemma 9 Let F be a formula, and let SF be the set of pi (t) that has a strictly positive
occurrence in F . Formula
^
F∧
∀z¬vi (t) → NSES F (v)
(47)
pi (t)∈SF

is logically valid, where z is the tuple of variables in t that are not free in F .
A.1.5 Proof of Equivalence between (b) and (c) of Theorem 3
Lemma 10 Let F be a rectified formula, let SF+ be the set of all atoms pi (t) that have a
positive occurrence in F that does not belong to a negative formula, and let SF− be the set
of all atoms pi (t) that have a negative occurrence in F that does not belong to a negative
formula.16 The following formulas are logically valid, where z is the list of all variables in
t that are not free in F .
V
(a) (v ≤ u) ∧ pi (t)∈S + ∀z(ui (t) → vi (t)) ∧ NSES F (v) → NSES F (u);
F
V
(b) (v ≤ u) ∧ pi (t)∈S − ∀z(ui (t) → vi (t)) ∧ NSES F (u) → NSES F (v).
F

Proof. Both parts are proved simultaneously by induction on F .
Case 1: F is an atom pi (t).
Part (a): NSES F (v) entails NSES F (u) under the assumption
^
∀z(ui (t) → vi (t)).
+
pi (t)∈SF

Part (b): NSES F (u) entails NSES F (v) under the assumption v ≤ u.
Case 2: F is ⊥ or an equality. It is clear since NSES F (v) and NSES F (u) are the same as
F.
Case 3: F is G ∧ H or G ∨ H. Follows from I.H.
Case 4: F is G → H.
Part (a): Assume
(v ≤ u) ∧

^

∀z(ui (t) → vi (t)).

(48)

+
pi (t)∈SF

We need to show that
(NSES G (v) → NSES H (v)) ∧ (G → H)
16. Note that we distinguish between formula being negative and an occurrence being negative. See at the
end of Section 2.

163

Lee & Meng

entails
(NSES G (u) → NSES H (u)) ∧ (G → H).
Note that
^

∀z(ui (t) → vi (t))

−
pi (t)∈SG

and
^

∀z(ui (t) → vi (t))

+
pi (t)∈SH

are entailed by formula (48). By I.H., NSES G (u) entails NSES G (v) and NSES H (v) entails
NSES H (u).
Part (b): Similar to Part (a).
Case 5: F is ∀x G
Part (a): Assume
^

(v ≤ u) ∧

∀z(ui (t) → vi (t)) ∧ ∀xNSES G (v).

+
pi (t)∈SF

From the assumption NSES G (v), G follows by Lemma 8. Also
^
∀z0 (ui (t) → vi (t))
+
pi (t)∈SG

follows, where z0 is the list of all variables in t that are not free in G, so that by I.H. on G,
NSES G (u) holds from the assumption. Since x is not free in the assumption, ∀xNSES G (u)
holds as well.
Part (b): Similar to Part (a).
Case 6: F is ∃x G.
Part (a): Assume
^

(v ≤ u) ∧

∀z(ui (t) → vi (t)) ∧ ∃xNSES G (v).

(49)

∀z(ui (t) → vi (t)) ∧ NSES G (v).

(50)

+
pi (t)∈SF

Take x such that
(v ≤ u) ∧

^
+
pi (t)∈SF

From NSES G (v), by Lemma 8, G follows. Also
^
∀z0 (ui (t) → vi (t))
+
pi (t)∈SG

follows, where z0 is the list of all variables in t that are not free in G. By I.H. on G,
NSES G (u) holds under the assumption (50). Consequently, ∃xNSES G (u) holds from the
164

First-Order Stable Model Semantics and First-Order Loop Formulas

same assumption. Since x is not free in (49), we conclude that ∃xNSES G (u) holds from
the assumption (49).
Part (b): Similar to Part (a).



Lemma 11 For any rectified formula F ,
(v ≤ u) ∧ ¬EF (v, u) ∧ NSES F (u) → NSES F (v)
is logically valid.
Proof. By induction on F .
Case 1: F is an atom pi (t). NSES F (u) entails NSES F (v) under the assumption v ≤ u.
Case 2: F is ⊥ or equality. It is clear since NSES F (v) and NSES F (u) are the same as F .
Case 3: F is G ∧ H or G ∨ H. Follows from I.H.
Case 4: F is G → H. Assume
(v ≤ u) ∧ ¬EF (v, u) ∧ NSES F (u)
and NSES G (v). From NSES F (u), by Lemma 8, we conclude G → H. From NSES G (v),
by Lemma 8, G follows, and consequently H.
Assume ¬NSES H (v) for the sake of contradiction. By Lemma 9, from H and ¬NSES H (v),
it follows that
_
∃xvi (t)
(51)
pi (t) : pi (t) occurs strictly positively in H

, where x is the list of variables in t that are not free in H.
Since F is rectified, the variables in F can be partitioned into three sets: the list of
variables x that are not free in H, the list of variables y that are not free in G, and the
rest. Note that ¬EF (v, u) entails


^
∃xvi (t) → ∀y(uj (t0 ) → vj (t0 )) ,
(52)
(pi (t),pj (t0 )) : pi (t) depends on pj (t0 ) in a rule G→H in F
pi (t) occurs in H,pj (t0 ) occurs in G

where x is the list of all variables in t that are not free in H, and y is the list of all variables
in t0 that are not free in G. From (51) and (52), we conclude
^
∀y(uj (t0 ) → vj (t0 )).
pj (t0 ) : pj (t0 ) occurs positively and not in a negative subformula of G

From this, together with the assumption (v ≤ u) and NSES G (v), by Lemma 10 (a),
NSES G (u) follows. Thus NSES H (u) follows from NSES F (u) and NSES G (u). Since ¬E F (v, u)
entails ¬E H (v, u), by I.H. on H, NSES H (v) follows, which contradicts the assumption.
Case 5: F is ∀xG or ∃xG. Follows from I.H.
165



Lee & Meng

Lemma 12
Nonempty(u) → ∃v(v ≤ u ∧ Ext-Loop F (v) ∧ ¬EF (v, u))
is logically valid.
Proof. Take any list q of predicate names, and any interpretation I that satisfies Nonempty(q).
Let Y be a set of vertices in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ).
Consider the subgraph G of the dependency graph of F w.r.t. I that is induced by Y . If Y
is an unbounded set w.r.t. I, by Proposition 4, I |= Ext-Loop F (q). So
I |= q ≤ q ∧ Ext-Loop F (q) ∧ ¬EF (q, q).
Otherwise, consider the graph G0 that is obtained from G by collapsing strongly connected
components of G, i.e., the vertices of G0 are the strongly connected components of G and
G0 has an edge from V to V 0 if G has an edge from a vertex in V to a vertex in V 0 . Since
we assumed that Y is not an unbounded set w.r.t. I, there exists a vertex Z in G0 that has
no outgoing edges. Consider the list of predicate names r such that
I |= ri (ξ  ) iff pi (ξ  ) ∈ Z.
It is clear that I |= r ≤ q. By Proposition 3, I |= Loop F (r) thus I |= Ext-Loop F (r). Since
there is no edge from Z to Y \ Z, by Lemma 6, I |= ¬EF (r, q). Consequently, the claim
follows.

Proof of Equivalence Between (b) and (c) of Theorem 3
From (b) to (c):
valid.

Clear from that the formula Ext-Loop F (u) → Nonempty(u) is logically

From (c) to (b): Assume
F ∧ ∀v(v ≤ p ∧ Ext-Loop F (v) → ¬NSES F (v)).
Take any u such that u ≤ p ∧ Nonempty(u). By Lemma 12, it follows from Nonempty(u)
that there exists v such that v ≤ u ∧ Ext-Loop F (v) ∧ ¬EF (v, u). It is clear that v ≤ p
follows from v ≤ u and u ≤ p. It follows from the assumption that ¬NSES F (v). Then by
Lemma 11, ¬NSES F (u) follows from v ≤ u and ¬EF (v, u).

A.2 Proof of Theorem 2
Lemma 3 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is
bounded w.r.t. I,
I |= ∃u(u ≤ p ∧ Ext-Loop F (u) ∧ NSES F (u))
166

First-Order Stable Model Semantics and First-Order Loop Formulas

iff there is a finite loop Y of F w.r.t. I such that
^

I |=
Y ∧ NES F (Y ) .
Proof. From left to right: Assume
I |= q ≤ p ∧ Ext-Loop F (q) ∧ NSES F (q)
for some list of predicate names q. Consider Y to be the set of vertices in the dependency
graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ).
Since I |= Ext-Loop F (q), by Proposition 3 and Proposition 4, it follows that Y is an
extended loop of F w.r.t. I. Since I |= qi (ξ  ) for all pi (ξ  ) ∈ Y and I |= q ≤ p, it follows
that I satisfies every atom in Y . Together with the assumption that F is bounded w.r.t. I,
this implies that set Y is finite. Since I |= NSES F (q) and Y is finite, by Lemma 2, it
follows that I |= NES F (Y ).
From right to left: Consider any finite loop Y of F w.r.t. I. Assume
^
I |=
Y ∧ NES F (Y ).
Let q be a list of predicate names such that
I |= qi (ξ  ) iff pi (ξ  ) ∈ Y.
• I |= q ≤ p follows from the construction of q and I |=

V

Y.

• Since Y is a loop of F w.r.t. I, by Proposition 3, I |= Loop F (q), and consequently,
I |= Ext-Loop F (q).
• From I |= NES F (Y ), by Lemma 2, I |= NSES F (q).
Consequently, I |= ∃u(u ≤ p ∧ Ext-Loop F (u) ∧ NSES F (u)).



Theorem 2 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is
bounded w.r.t. I, then the following conditions are equivalent to each other:
(a) I satisfies SM[F ];
(b) for every nonempty finite set Y of atoms formed from predicate constants in σ(F ) and
object names for |I|, I satisfies LF F (Y );
(c) for every finite loop Y of F w.r.t. I, I satisfies LF F (Y ).
Proof. Between (a) and (c): By Theorem 3 and Lemma 3.
Between (b) and (c):
167

Lee & Meng

• From (b) to (c): Clear.
• From (c) to (b): Assume that I satisfies LF F (L) for every finite loop L of F w.r.t I.
Consider any nonempty finite set V
Y of atoms formed from predicate constants in σ(F )
and object names such that I |= Y . Let q be a list of predicate names such that
I |= qi (ξ  ) iff pi (ξ  ) ∈ Y.
Since Y is nonempty, it is clear that Nonempty(q) follows. In view of Lemma 12,
there is a list of predicate names r such that
I |= r ≤ q ∧ Ext-Loop F (r) ∧ ¬EF (r, q).

(53)

Consider Z to be the set of vertices in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Z iff I |= ri (ξ  ).
Since I |= Ext-Loop F (r), by Proposition
3 and PropositionV4, Z is an extended loop
V
of F w.r.t. I. Clearly, I |= Z since Z ⊆ Y and I |= Y . Since F is bounded
w.r.t. I, and Z is satisfied by I, it follows that Z is a finite loop of F w.r.t. I.
Since I |= r ≤ q ∧ ¬EF (r, q), Z is a subset of Y and, by Lemma 6, there is no edge
from Z to Y \ Z in the dependency graph of F w.r.t. I. Since I |= LF F (Z), we
conclude that I |= ¬NES F (Z), and by Lemma 2, I |= ¬NSES F (r). From (53) and
that I |= ¬NSES F (r), by Lemma 11, we have I |= ¬NSES F (q). By Lemma 2 again,
I |= ¬NES F (Y ). Consequently, I |= LF F (Y ).

A.3 Proof of Proposition 6
Proposition 6
If a rectified formula F of a signature σ is bounded, then F is bounded
w.r.t. any interpretation of σ that satisfies CETσ .
Lemma 13 For any terms t1 and t2 of signature σ, any interpretation I that satisfies
CETσ , and any substitution θ from object variables in t1 and t2 to object names such that
(t1 θ)I = (t2 θ)I , Robinson’s unification algorithm (Robinson, 1965), when applied to t1 and
t2 , returns a most general unifier (mgu) γ of t1 and t2 such that
(a) t1 γ = t2 γ, and
(b) for every variable x in t1 or t2 , (xγθ)I = (xθ)I .
Proof. From the assumptions, by Lemma 5.1 from the work of Kunen (1987), t1 and t2
are unifiable, in which case Robinson’s algorithm returns a mgu for t1 and t2 that maps
variables occurring in t1 and t2 into terms. Given this, part (b) can be proven by induction.

The proof of Proposition 6 follows from the following lemma.
168

First-Order Stable Model Semantics and First-Order Loop Formulas

Lemma 14 Let F be a rectified sentence of a signature σ, and let I be an interpretation of
σ that satisfies CETσ . For any path
hp1 (ξ 1 ), p2 (ξ 2 ), . . . , pk (ξ k ), pk+1 (ξ k+1 )i

(54)

in the dependency graph of F w.r.t I, there is a path
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), pk+1 (uk+1 )i
in the first-order dependency graph of F with a substitution θ that maps object variables in
ui to object names such that (ui θ)I = ξ i for all i.
Proof. Each edge (pi (ξ i ), pi+1 (ξ i+1 )) in (54) is obtained from a pair of atoms (pi (ti ), pi+1 (t0i ))
and a substitution θi such that pi (ti ) depends on pi+1 (t0i ) in a rule of F , and
(t1 θ1 )I = ξ 1 , (t0i θi )I = (ti+1 θi+1 )I = ξ i+1 (1 ≤ i < k), (t0k θk )I = ξ k+1 .

(55)

For simplicity we assume that each pair (pi (ti ), pi+1 (t0i )) considered above has no common
variables with another pair by first renaming variables. This allows us to use one substitution θ = θ1 . . . θk in place of individual θi in the rest of the proof.
We will show by induction that, for each j where j ∈ {1 . . . k}, there are substitutions
j
σi (1 ≤ i ≤ j) from variables in ti and t0i to terms such that
(a) hp1 (t1 )σ1j , p2 (t2 )σ2j , . . . , pj (tj )σjj , pj+1 (t0j )σjj i is a path in the first-order dependency
graph of F , and
(b) (ti σij θ)I = ξ i for all 1 ≤ i ≤ j, and (t0j σjj θ)I = ξ j+1 .
When j = 1, we take σij to be an identity substitution. Clearly, conditions (a) and (b)
are satisfied.
Otherwise, by I.H. we assume that, for some j in {1, . . . , k−1}, there are substitutions
σ1j , . . . , σjj such that conditions (a) and (b) are satisfied. We will prove that there are
substitutions σij+1 (1 ≤ i ≤ j +1) from variables in ti and t0i to terms such that
j+1
j+1
(a’) hp1 (t1 )σ1j+1 , p2 (t2 )σ2j+1 , . . . , pj+1 (tj+1 )σj+1
, pj+2 (t0j+1 )σj+1
i is a path in the first-order dependency graph of F , and
j+1 I
(b’) (ti σij+1 θ)I = ξ i for all 1 ≤ i ≤ j +1, and (t0j+1 σj+1
θ) = ξ j+2 .

From I.H., we have (t0j σjj θ)I = ξ j+1 and from (55) we have (tj+1 θ)I = ξ j+1 . By Lemma 13
there is a substitution γ from variables in t0j σjj or tj+1 to terms such that t0j σjj γ = tj+1 γ and
for any variable x in t0j σjj or tj+1 ,
(xγθ)I = (xθ)I .
We define σij+1 as
• σij γ when 1 ≤ i ≤ j and
169

(56)

Lee & Meng

• γ when i = j +1.
It is easy to check that condition (a’) is satisfied. To check that condition (b’) is satisfied,
consider any variable x in the set
{t1 σ1j , t2 σ2j , . . . , tj σjj , t0j σjj , tj+1 , t0j+1 }.

(57)

If x is in t0j σjj or tj+1 , by (56), (xγθ)I = (xθ)I . Otherwise, since γ does not change the
variables that are not in t0j σjj or tj+1 , (xγθ)I = (xθ)I . Consequently, for any variable x in
(57), we get (xγθ)I = (xθ)I . It remains to check the following.
• For 1 ≤ i ≤ j, (ti σij+1 θ)I = (ti σij γθ)I = (ti σij θ)I . The last one is equal to ξ i by I.H.
j+1 I
• (tj+1 σj+1
θ) = (tj+1 γθ)I = (tj+1 θ)I . The last one is equal to ξ j+1 by (55).
j+1 I
• (t0j+1 σj+1
θ) = (t0j+1 γθ)I = (t0j+1 θ)I . The last one is equal to ξ j+2 by (55).


A.4 Proof of Proposition 7
Proposition 7 For any rectified sentence F of a signature σ and for any interpretation
I of σ that satisfies CETσ , I is a model of
{LF F (Y ) | Y is a finite first-order loop of F }
iff I is a model of
{LF F (Y ) | Y is a finite loop of F w.r.t. I}.

The proof follows immediately from the following fact and Lemma 15.
Fact 1 Let F be a rectified sentence of a signature σ, and let I be an interpretation of σ.
For any first-order loop Y of F and any substitution θ that maps variables in Y to object
names, Y 0 = {pi (ξ  ) | pi (t) ∈ Y θ, tI = ξ} is a loop of F w.r.t. I.
Lemma 15 Let F be a rectified sentence of a signature σ, and let I be an interpretation
of σ. If I satisfies CETσ , then, for any finite loop Y 0 of F w.r.t. I, there is a finite
loop Y of F with a substitution θ that maps variables in Y to object names such that
Y 0 = {pi (ξ  ) | pi (t) ∈ Y, (tθ)I = ξ}.
Proof. Without loss of generality, consider a path
hp1 (ξ 1 ), p2 (ξ 2 ), . . . , pk (ξ k ), p1 (ξ 1 )i
(k ≥ 1) in the dependency graph of F w.r.t. I that consists of the vertices in Y 0 . Since
I |= CETσ , by Lemma 14, there is a path
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), p1 (uk+1 )i
170

First-Order Stable Model Semantics and First-Order Loop Formulas

in the first-order dependency graph of F with a substitution θ that maps variables in ui
to object names such that (ui θ)I = ξ i for all 1 ≤ i ≤ k, and (uk+1 θ)I = ξ 1 . Since
(uk+1 θ)I = (u1 θ)I , by Lemma 13, there is a unifier γ for uk+1 and u1 such that, for any
variable x in uk+1 or u1 , (xγθ)I = (xθ)I . Consequently,
{p1 (u1 γ), p2 (u2 γ), . . . , pk (uk γ)}
induces a finite strongly connected subgraph such that (ui γθ)I = (ui θ)I = ξ i .



A.5 Proof of Proposition 8
Proposition 8 If a rectified formula F in normal form is bounded, then F is bounded
w.r.t. any interpretation.
The proof follows from the following lemma.
Lemma 16 Let F be a rectified sentence of a signature σ in normal form, and let I be an
interpretation of σ. For any path
hp1 (ξ 1 ), p2 (ξ 2 ), . . . , pk (ξ k ), pk+1 (ξ k+1 )i
in the dependency graph of F w.r.t I, there exists a path
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), pk+1 (uk+1 )i
in the first-order dependency graph of F with a substitution θ that maps object variables in
ui to object names such that (ui θ)I = ξ i for all i, and u1 is a list of object variables.
Proof. The proof is similar to the proof of Lemma 14 except that we do not require that
I satisfy CETσ . Instead, the existence of a unifier γ for t0j σjj and tj+1 is ensured by the
assumption on normal form that tj+1 is a list of variables and the assumption that t0j σjj
contains none of those variables (due to variable renaming).
A.6 Proof of Proposition 9
Proposition 9 If a rectified sentence F in normal form is bounded, then for any interpretation I, I is a model of
{LF F (Y ) | Y is a finite first-order loop of F }
iff I is a model of
{LF F (Y ) | Y is a finite loop of F w.r.t. I}.

The proof follows from Fact 1 and the following lemma.
Lemma 17 If a rectified sentence F in normal form is bounded, then for any finite loop
Y 0 of F w.r.t. I, there is a finite loop Y of F with a substitution θ that maps variables in
Y to object names such that Y 0 = {pi (ξ  ) | pi (t) ∈ Y, (tθ)I = ξ}.
171

Lee & Meng

Proof. Let Y 0 be a finite loop of F w.r.t. I. Without loss of generality, there is a path
hp1 (ξ 1 ), p2 (ξ 2 ), . . . , pk (ξ k ), p1 (ξ 1 )i
(k ≥ 1) in the dependency graph of F w.r.t. I that consists of the vertices in Y 0 . Since F
is in normal form, by Lemma 16, there are a path
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), p1 (uk+1 )i

(58)

in the first-order dependency graph of F , where u1 consists of object variables only, and
a substitution θ that maps variables in ui to object names such that (ui θ)I = ξ i for all
1 ≤ i ≤ k, and (uk+1 θ)I = ξ 1 . There are two cases to consider.
• Case 1: There is a unifier γ for u1 and uk+1 that maps variables in u1 to terms in uk+1
so that u1 γ = uk+1 . It follows that, for any variable x in uk+1 or u1 , (xγθ)I = (xθ)I .
Consequently,
{p1 (u1 γ), p2 (u2 γ), . . . , pk (uk γ)}
induces a finite strongly connected subgraph such that (ui γθ)I = (ui θ)I = ξ i .
• Case 2: There is no such unifier γ.
Consider another path
hp1 (v1 ), p2 (v2 ), . . . , pk (vk ), p1 (vk+1 )i
that is obtained similar to (58) except that the variables in the path are disjoint from
the variables in (58). Clearly, there is a unifier γ 0 for uk+1 and v1 that maps the
variables v1 to terms, so that
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), p1 (v1 γ 0 ), p2 (v2 γ 0 ), . . . , pk (vk γ 0 )i
is another path in the first-order dependency graph of F . It is clear that using the
same construction repeatedly, we can form an infinite path that visits infinitely many
vertices in the first-order dependency graph. But this contradicts the assumption that
F is bounded.

A.7 Proof of Proposition 11
We will use the following lemma in this section and the next section, which extends Theorem 2 in the work of Chen et al. (2006) that provides a few equivalent conditions for a
program to have a finite complete set of loops to a disjunctive program and a sentence.
Lemma 18 (Chen et al., 2006, Thm. 2) For any formula F that contains no function
constants of positive arity, the following conditions are equivalent:
(a) F has a finite complete set of loops.
172

First-Order Stable Model Semantics and First-Order Loop Formulas

(b) There is a nonnegative integer N such that for every loop L of F , the number of
variables in L is bounded by N .
(c) For any loop L of F and any atom A1 and A2 in L, the variables occurring in A1 are
identical to the variables occurring in A2 .
(d) For any loop L of Ground σ(F )∪{c1 ,c2 } (F ) where c1 , c2 are two new object constants,
there are no two atoms A1 and A2 in L such that A1 mentions c1 but A2 does not or
A1 mentions c2 but A2 does not.
Proposition 11 For any rectified formula F that contains no function constants of positive
arity, F is bounded iff F has a finite complete set of loops.
Proof. From left to right: Assume that F is bounded. Then every loop of F is finite. It
follows that there exists a nonnegative integer N such that the number of variables in any
loop is bounded by N . By Lemma 18 (b), F has a finite complete set of loops.
From right to left: Assume that F has a finite complete set of loops and, for the sake of
contradiction, assume that it is not bounded. Without loss of generality, there is an infinite
path
hp1 (t1 )σ1 , p2 (t2 )σ2 , . . .i
(59)
in the first-order dependency graph of F that visits infinitely many vertices, where pi (ti )
are atoms occurring in F and σi are substitutions.
Since F is a finite string, it contains finitely many atoms. It follows that there is an
atom pi (ti ) occurring in F with arbitrarily many substitutions σ such that atoms pi (ti )σ
are contained in (59). Without loss of generality, consider the path
hpi (ti )σi , pi+1 (ti+1 )σi+1 , . . . , pi (ti )σk i
that is contained in (59), where σk and σi agree on substituting object constants for variables
in ti . Since ti σi and ti σk contain no function constant, there exists a substitution σ0 that
maps variables in ti σk to terms in ti σi so that ti σk σ0 = ti σi . Consequently,
{pi (xi )σi σ0 , pi+1 (xi+1 )σi+1 σ0 , . . . , pi (xi )σk σ0 }
is a loop of F . Since the length of the path is arbitrarily large, there are arbitrarily many
variables occurring in the loop. By Lemma 18 (b), it follows that F has no finite complete
set of loops.

A.8 Proof of Proposition 10
Proposition 10
arity),

For any rectified sentence F (allowing function constants of positive

(a) checking whether F is bounded is not decidable;
(b) checking whether F is atomic-tight is not decidable.
If F contains no function constants of positive arity,
(c) checking whether F is bounded is decidable;
(d) checking whether F is atomic-tight is decidable.
173

Lee & Meng

A.8.1 Proof of Part (a) and (b)
We show the proof of Part (a) first. The proof repeats, with minor modifications, the
argument from the proof of Theorem 26 from the work of Bonatti (2004), which considers
the following program ΠM to simulate deterministic Turing machines M.
t(s, L, v, [V | R], C) ← t(s0 , [v 0 | L], V, R, C +1)
t(s, L, v, [ ], C) ← t(s0 , [v 0 | L], b, [ ], C +1)
t(s, [V | L], v, R, C) ← t(s0 , L, V, [v 0 | R], C +1)
t(s, [ ], v, R, C) ← t(s0 , [ ], b, [v 0 | R], C +1)
t(s, L, v, R, C)

for
for
for
for
for

all
all
all
all
all

instr.hs, v, v 0 , s0 , righti
instr.hs, v, v 0 , s0 , righti
instr.hs, v, v 0 , s0 , lefti
instr.hs, v, v 0 , s0 , lefti
final states s.

The Halting problem can be reduced to the problem of checking bounded formulas. More
precisely, we show that ΠM is bounded iff M terminates from every configuration.
We first establish the following facts:
(i) for every non-terminating computation of M on input x, there is a corresponding
infinite path in the first-order dependency graph of ΠM that visits infinitely many
vertices;
(ii) if there is an infinite path in the first-order dependency graph of ΠM , then there
is an infinite path starting with a legal encoding of an input and corresponds to a
non-terminating computation of M.
Fact (i) is immediate from the definition of ΠM : Note that the step counter (the last
argument of t) ensures that the dependency graph is acyclic. Then, whenever M falls into
a cycle, the dependency graph contains an infinite acyclic path that visits infinitely many
vertices and hence the program is not bounded.
Fact (ii) can be proven as follows. Assume that there is an infinite path in the dependency graph. We observe that the first argument of every vertex in the path must be a legal
state and the third argument of every vertex must be a legal tape value. Otherwise, there
is no outgoing edge from the vertices in the dependency graph of ΠM . So only the second,
fourth and fifth arguments can contain variables or illegal values which were obtained from
substitutions from the variables L, R, V and C. In this case, we can easily find substitutions
from these variables or illegal values to legal values and apply them uniformly along the
path, so that we obtain another infinite path starting from the vertex that correctly encodes
a configuration of M and thus M has a corresponding non-terminating computation.
The claim follows immediately from the two facts: if M does not terminate on some
computation, then by (i), ΠM is unbounded. If ΠM is unbounded, then by (ii), M does
not terminate.
The same proof works for Part (b) as well. This is because the step counter (the last
argument of t) ensures that the dependency graph is acyclic. Consequently, every infinite
path in the dependency graph visits infinitely many vertices, so that ΠM is atomic-tight iff
ΠM is bounded.

A.8.2 Proof of Part (c)
In view of the equivalence between (a) and (d) in Lemma 18, checking whether a formula
F containing no function constants of positive arity has a finite complete set of loops can
174

First-Order Stable Model Semantics and First-Order Loop Formulas

be done by examining a finite number of loops from a finite dependency graph, which is
decidable. By Proposition 11, it follows that checking whether F is bounded is decidable.

A.8.3 Proof of Part (d)
For any sentence F that has no function constants of positive arity and any finite set c of object constants, Ground c (F ) is defined recursively. If F is an atomic formula thenGround c (F )
is F . The function Ground c commutes with all propositional connectives; quantifiers turn
into finite conjunctions and disjunctions over all object constants occurring in c.
Lemma 19 Let c be the set consisting of all object constants occurring in F , and possibly a new object constant if F contains no object constants. F has a non-trivial loop iff
Ground c (F ) has a non-trivial loop.
In order to check whether F is atomic-tight, we first check whether F is bounded,
which is decidable. If F is not bounded, then F is not atomic-tight. Otherwise, in view of
Lemma 19, checking whether F is atomic-tight is the same as checking whether Ground c (F )
is atomic-tight. Since F contains no function constants of positive arity, the dependency
graph of Ground c (F ) is finite. So it is decidable to check whether the dependency graph of
Ground c (F ) has a non-trivial loop.

A.9 Proof of Proposition 13
Lemma 20 Let F be a formula and Y a set of atoms. If no predicate constant occurring
in Y occurs strictly positively in F , then NES F (Y ) is equivalent to F .
Proof. By induction.



Proposition 13 Let Π be a program with quantifiers, F the FOL-representation of Π,
and Y a finite set of atoms. Under the assumption Π, formula QES Π (Y ) is equivalent to
¬NES F (Y ). If Π is a disjunctive program in normal form, then QES Π (Y ) is also equivalent
to ES Π (Y ) under the assumption Π.
Proof. Between QES Π (Y ) and ¬NES F (Y ): ¬NES F (Y ) is
^
¬
∀x[(G → H) ∧ (NES G (Y ) → NES H (Y ))].

(60)

H←G∈Π

Under the assumption F , formula (60) is equivalent to
_
∃x(NES G (Y ) ∧ ¬NES H (Y )).

(61)

H←G∈Π

In view of Lemma 20, if H does not contain any strictly positive occurrence of a predicate
constant that belongs to Y , NES H (Y ) is equivalent to H. Also, it follows from Lemma 2
and Lemma 8 that NES G (Y ) implies G. So NES G (Y )∧¬NES H (Y ) conflicts the assumption
175

Lee & Meng

G → H when H does not contain any strictly positive occurrence of a predicate constant
that belongs to Y . As a result, under the assumption F , formula (61) is equivalent to the
disjunction of
∃x(NES G (Y ) ∧ ¬NES H (Y ))
(62)
for all rules H ← G, where H contains a strictly positive occurrence of a predicate constant
that belongs to Y . Note that G and H are formulas such that every occurrence of an
implication in G and H belongs to a negative formula. By Lemma 4, (62) is equivalent to
QES Π (Y ).
Between QES Π (Y ) and ES Π (Y ): When Π is a disjunctive program, QES Π (Y ) is the disjunction of


^
_
^

∃z B ∧ N ∧
(t 6= t0 ) ∧ ¬
(p(t) ∧
t 6= t0 )
(63)
p(t)∈B
p(t0 )∈Y

p(t0 )∈Y

p(t)∈A

over all rules (10) such that A contains a predicate constant that occurs in Y , where z is a
list of variables in (10) but not in Y . On the other hand, ES Π (Y ) is the disjunction of
0



∃z Bσ ∧ N σ ∧

^

_

0

(t 6= t ) ∧ ¬

p(t)∈Bσ
p(t0 )∈Y

^

(p(t) ∧

0

t 6= t )




(64)

p(t0 )∈Y

p(t)∈Aσ

over all rules (10) such that A contains a predicate constant that occurs in Y and Aσ∩Y 6= ∅,
where z0 is a list of variables in Aσ ← Bσ, N σ but not in Y .
It is clear that (64) implies (63). To prove that (63) implies (64), assume
B∧N ∧

^

_

(t 6= t0 ) ∧ ¬

p(t)∈B
p(t0 )∈Y

^

(p(t) ∧


t 6= t0 )

(65)

p(t0 )∈Y

p(t)∈A

and consider two cases.
V
If p(t0 )∈Y t 6= t0 for all p(t) ∈ A, then (65) is equivalent to
^

B∧N ∧

(t 6= t0 ) ∧ ¬

p(t)∈B
p(t0 )∈Y

_

p(t)

p(t)∈A

which contradicts the assumption Π.
Otherwise, there exists p(t) ∈ A and p(t0 ) ∈ Y such that t = t0 . Since Π is in normal form,
there exists σ that maps t to t0 , so that Aσ ∩ Y 6= ∅. Consequently, (65) is equivalent to
Bσ ∧ N σ ∧

^
p(t)∈Bσ
p(t0 )∈Y

_

(t 6= t0 ) ∧ ¬

p(t)∈Aσ

Thus the claim follows.

(p(t) ∧

^


t 6= t0 ) .

p(t0 )∈Y


176

First-Order Stable Model Semantics and First-Order Loop Formulas

A.10 Proof of Proposition 16
Proposition 16 Let P be an LW-program and let F be the FOL-representation of the set
of rules in P . The following conditions are equivalent to each other:
(a) I is an answer set of P according to Lin and Wang (2008);
(b) I is a P -interpretation that satisfies SM[F ];
(c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of
F w.r.t. I.
Given a program Π, Norm(Π) is a normal form of Π and Ground (Π) is a ground program
obtained from Π as described by Lin and Wang (2008). The proof of Proposition 16 follows
from the following lemma. We refer readers to the work of Lin and Wang for the definition
of ES (·, ·, ·) defined there.
Lemma
21 For any program Π and any set Y of ground atoms, ES Norm(Π) (Y ) is equivalent
W
to p(c)∈Y ES (p(c), Y, Ground (Π)).
Proof. By definition, ES Norm(Π) (Y ) is

_
∃z Bθ ∧ N θ ∧ xθ = tθ ∧

^


(t 6= t ) ,
0

(66)

q(t)∈Bθ
q(t0 )∈Y

p(x)←B,N,x=t is in Norm(Π)
θ:p(x)θ∈Y

where x is a list of distinct object variables, θ is a substitution that maps variables in x
to object constants occurring in Y , and z is the list of all variables that occur in the rule
p(x)θ ← Bθ, N θ, xθ = tθ. (66) is equivalent to


_
^
0
0
∃z B ∧ N ∧ t = c ∧
(t 6= t ) ,
(67)
p(t)←B,N ∈Π
p(c)∈Y

q(t)∈B
q(t0 )∈Y

where z0 is the list of all variables that occur in the rule p(t) ← B, N . In turn, (67) is
equivalent to


_
^
0
0
0
(tg 6= t ) .
(68)
B ∧N ∧d=c∧
p(d)←B 0 ,N 0 ∈Ground(Π)
p(c)∈Y

q(tg )∈B 0
q(t0 )∈Y

Note that when d does not cover c, there exists di ∈ d such that di mentions only constants
and pre-interpreted functions and di can not be evaluated to ci independent of interpretations. In that case, d = c is equivalent to ⊥. Thus (68) is equivalent to


_
_
^
0
0
0
(tg 6= t ) ,
(69)
B ∧N ∧d=c∧
p(c)∈Y

which is essentially

p(d)←B 0 ,N 0 ∈Ground(Π)
p(d) can cover p(c)

W

p(c)∈Y

q(tg )∈B 0
q(t0 )∈Y

ES (p(c), Y, Ground (Π)).

177



Lee & Meng

References
Asuncion, V., Lin, F., Zhang, Y., & Zhou, Y. (2010). Ordered completion for first-order
logic programs on finite structures. In AAAI, pp. 249–254.
Bonatti, P. A. (2004). Reasoning with infinite stable models. Artificial Intelligence, 156 (1),
75–111.
Chen, Y., Lin, F., Wang, Y., & Zhang, M. (2006). First-order loop formulas for normal
logic programs. In Proceedings of International Conference on Principles of Knowledge
Representation and Reasoning (KR), pp. 298–307.
Chen, Y., Lin, F., Zhang, Y., & Zhou, Y. (2011). Loop-separable programs and their firstorder definability. Artificial Intelligence, 175 (3-4), 890–913.
Chen, Y., Zhang, Y., & Zhou, Y. (2010). First-order indefinability of answer set programs
on finite structures. In AAAI, pp. 285–290.
Clark, K. (1978). Negation as failure. In Gallaire, H., & Minker, J. (Eds.), Logic and Data
Bases, pp. 293–322. Plenum Press, New York.
de Bruijn, J., Pearce, D., Polleres, A., & Valverde, A. (2010). A semantical framework for
hybrid knowledge bases. Knowl. Inf. Syst., 25 (1), 81–104.
Ferraris, P., Lee, J., & Lifschitz, V. (2006). A generalization of the Lin-Zhao theorem.
Annals of Mathematics and Artificial Intelligence, 47, 79–101.
Ferraris, P., Lee, J., & Lifschitz, V. (2007). A new perspective on stable models. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 372–379.
Ferraris, P., Lee, J., & Lifschitz, V. (2011). Stable models and circumscription. Artificial
Intelligence, 175, 236–263.
Gebser, M., Lee, J., & Lierler, Y. (2006). Elementary sets for logic programs. In Proceedings
of National Conference on Artificial Intelligence (AAAI), pp. 244–249.
Gebser, M., Lee, J., & Lierler, Y. (2011). On elementary loops of logic programs. Theory
and Practice of Logic Programming, To appear.
Gebser, M., & Schaub, T. (2005). Loops: Relevant or redundant?. In Proceedings of the
Eighth International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR’05), pp. 53–65.
Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming. In
Kowalski, R., & Bowen, K. (Eds.), Proceedings of International Logic Programming
Conference and Symposium, pp. 1070–1080. MIT Press.
Kim, T.-W., Lee, J., & Palla, R. (2009). Circumscriptive event calculus as answer set programming. In Proceedings of International Joint Conference on Artificial Intelligence
(IJCAI), pp. 823–829.
Kunen, K. (1987). Negation in logic programming. The Journal of Logic Programming,
4 (4), 289 – 308.
Lee, J. (2004). Nondefinite vs. definite causal theories. In Proceedings 7th Int’l Conference
on Logic Programming and Nonmonotonic Reasoning, pp. 141–153.
178

First-Order Stable Model Semantics and First-Order Loop Formulas

Lee, J. (2005). A model-theoretic counterpart of loop formulas. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 503–508.
Lee, J., Lierler, Y., Lifschitz, V., & Yang, F. (2010). Representing synonymity in causal logic
and in logic programming. In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR). http://peace.eas.asu.edu/joolee/papers/syn.pdf.
Lee, J., & Lifschitz, V. (2003). Loop formulas for disjunctive logic programs. In Proceedings
of International Conference on Logic Programming (ICLP), pp. 451–465.
Lee, J., Lifschitz, V., & Palla, R. (2009). Safe formulas in the general theory of stable models.
Technical Report. http://peace.eas.asu.edu/joolee/papers/safety.pdf.
Lee, J., & Lin, F. (2006). Loop formulas for circumscription. Artificial Intelligence, 170 (2),
160–185.
Lee, J., & Meng, Y. (2008). On loop formulas with variables. In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), pp. 444–453.
Lee, J., & Palla, R. (2011). Integrating rules and ontologies in the first-order stable model
semantics (preliminary report). In Proceedings of International Conference on Logic
Programming and Nonmonotonic Reasoning (LPNMR), pp. 248–253.
Lifschitz, V. (1994). Circumscription. In Gabbay, D., Hogger, C., & Robinson, J. (Eds.),
Handbook of Logic in AI and Logic Programming, Vol. 3, pp. 298–352. Oxford University Press.
Lifschitz, V., Morgenstern, L., & Plaisted, D. (2008). Knowledge representation and classical
logic. In van Harmelen, F., Lifschitz, V., & Porter, B. (Eds.), Handbook of Knowledge
Representation, pp. 3–88. Elsevier.
Lin, F., & Shoham, Y. (1992). A logic of knowledge and justified assumptions. Artificial
Intelligence, 57, 271–289.
Lin, F., & Wang, Y. (2008). Answer set programming with functions. In Brewka, G., &
Lang, J. (Eds.), Proceedings of International Conference on Principles of Knowledge
Representation and Reasoning (KR), pp. 454–465. AAAI Press.
Lin, F., & Zhao, Y. (2004). ASSAT: Computing answer sets of a logic program by SAT
solvers. Artificial Intelligence, 157, 115–137.
Lin, F., & Zhou, Y. (2011). From answer set logic programming to circumscription via logic
of GK. Artificial Intelligence, 175, 264–277.
Liu, L., & Truszczynski, M. (2006). Properties and applications of programs with monotone
and convex constraints. J. Artif. Intell. Res. (JAIR), 27, 299–334.
McCarthy, J. (1980). Circumscription—a form of non-monotonic reasoning. Artificial Intelligence, 13, 27–39,171–172.
McCarthy, J. (1986). Applications of circumscription to formalizing common sense knowledge. Artificial Intelligence, 26 (3), 89–116.
Pearce, D., & Valverde, A. (2005). A first order nonmonotonic extension of constructive
logic. Studia Logica, 80, 323–348.
179

Lee & Meng

Robinson, J. A. (1965). A machine-oriented logic based on the resolution principle. J. ACM,
12, 23–41.
Sabuncu, O., & Alpaslan, F. N. (2007). Computing answer sets using model generation
theorem provers. Unpublished Draft.
You, J.-H., & Liu, G. (2008). Loop formulas for logic programs with arbitrary constraint
atoms. In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI), pp.
584–589.
Zhang, Y., & Zhou, Y. (2010). On the progression semantics and boundedness of answer
set programs. In Proceedings of International Conference on Principles of Knowledge
Representation and Reasoning (KR), pp. 518–526.

180

Proceedings of the Twenty-Ninth AAAI Conference on Innovative Applications (IAAI-17))

A Logic Based Approach to Answering
Questions about Alternatives in DIY Domains
Yi Wang, Joohyung Lee

Doo Soon Kim

Arizona State University,
Tempe, AZ, USA
{ywang485, joolee}@asu.edu

Bosch Research and Technology Center,
Palo Alto, CA, USA
DooSoon.Kim@us.bosch.com

a question “Can I use a table saw instead of a jigsaw in
step2?”, just answering “yes” or “no” is not helpful. Rather,
the system should deliver the related information, for example, by saying “It is not recommended because step2 requires curve cutting, which is not supported by a table saw”.
This explanation capability is not considered in most factoid
QA systems.
To address these challenges, we present a novel QA system which uses Answer Set Programming (ASP) (Lifschitz
2008) to answer non-factoid questions on DIY projects.1
Our system currently addresses one particular type of nonfactoid questions, questions about alternatives (e.g., “Can
I use an alternative tool/material instead of the suggested
one under a certain circumstance?”) but the general methodology can also be applied to other types of non-factoid
questions. Using ASP, our system encodes various types
of knowledge and constraints (domain knowledge, commonsense knowledge, constraints from users, contexts and
projects) and derives an answer satisfying the question, the
background knowledge and the constraints. ASP is particularly useful for our task because our KB includes many rules
about commonsense knowledge (e.g., “Normally, a power
tool is dangerous to kids”) which can be easily represented
by ASP rules.
To evaluate our system, we performed a user study where
we compared our system against online search, a common
practice for information seeking. Our result shows that online search is unsuitable for answering non-factoid DIY
questions; it takes too much time, and even many participants failed to ﬁnd an answer. However, a majority of participants are satisﬁed with our system because it promptly
presents an answer, and the explanation delivered by our system is informative. ASP has been previously applied to other
QA systems (e.g., (Aditya et al. 2015)) to answer complex
questions but, to our knowledge, our system is the ﬁrst to apply ASP to non-factoid DIY questions in order to derive an
answer under various types of DIY-related knowledge and
constraints.
The paper is organized as follows. After the review of
ASP, we give an overview of the whole framework, and then
introduce the ASP rules and facts that are used to answer the

Abstract
Many question answering systems have primarily focused on
factoid questions. These systems require the answers to be
explicitly stored in a knowledge base (KB) but due to this
requirement, they fail to answer many questions for which
the answers cannot be pre-formulated. This paper presents
a question answering system which aims at answering nonfactoid questions in the DIY domain using logic-based reasoning. Speciﬁcally, the system uses Answer Set Programming to derive an answer by combining various types of
knowledge such as domain and commonsense knowledge.
We showcase the system by answering one speciﬁc type of
questions — questions about alternatives. The evaluation result shows that our logic-based reasoning together with the
KB (constructed from texts using Information Extraction)
signiﬁcantly improves the user experience.

Introduction
Despite the popularity of DIY (Do-It-Yourself), DIY is not
an easy task due to one major problem: DIYers may have
many questions about a project, but in many cases, professionals who can assist the DIYers are unavailable. For example, one might wonder about hypothetical questions such as
“Can I use a table saw instead of a jigsaw in step2” or “Is
it ok to put this DIY product outside?” These questions are
hard, especially for novice DIYers, because answering those
questions requires them to possess extensive domain knowledge and experience. If a question answering (QA) system
can answer those questions and explain the reason, it will
greatly beneﬁt the DIYers.
It is, however, challenging to develop a QA system for
DIYers. First, most recent QA systems have focused on factoid questions, e.g., (Ferrucci et al. 2010; Waltinger et al.
2013). These factoid QA systems ﬁnd an answer by retrieving from their KB an answer closely matching the question,
and thus require all candidate answers to be explicitly stored
in the KB. However, for many DIY questions (such as the
above hypothetical questions), it is infeasible to enumerate
all possible questions in advance.
Another challenge for answering the non-factoid questions is that the system should not only provide an answer
but also explain the reason for the answer. For example, for
c 2017, Association for the Advancement of Artiﬁcial
Copyright 
Intelligence (www.aaai.org). All rights reserved.

1
https://www.bosch-do-it.com/za/en/diy/knowledge/projectguides/index.jsp

4753

Recursive Deﬁnition Another convenient feature of ASP
is being able to represent recursive deﬁnitions, such as transitive closure. For example, the following rules deﬁne the relation descendent step as the transitive closure of the
relation substep.

questions about alternatives. Then, we present our evaluation result. Finally, we discuss how to extend this framework
to offer more advanced reasoning.

Background: Answer Set Programming
Answer Set Programming (ASP) is a declarative programming paradigm that is suitable for the design and implementation of knowledge-intensive applications. It has emerged
from the interaction between two lines of research – nonmonotonic semantics of logic programs and application of
satisﬁability solvers to search problems. The idea is to represent a search problem by a logic program whose intended
models, called “answer sets,” correspond to the solutions of
the problem, and then ﬁnd these models using an answer set
solver, such as CLINGO and DLV.
The language of ASP is logic programs under the stable
model semantics (Gelfond and Lifschitz 1988), which allows for elegant representation of several aspects of knowledge such as causality, defaults, incomplete information,
preference, and recursive deﬁnitions. What distinguishes
ASP from other nonmonotonic formalisms is the availability
of several efﬁcient answer set solvers, which led to practical nonmonotonic reasoning that can be applied to industrial
level applications.
In our framework, we apply answer set programming in
two phases — information extraction to populate knowledge base and inference to derive an answer from the knowledge bases. The following are the brief introduction of some
of the features of ASP that we found useful in our work.
The rules are written in the language of CLINGO v3.0.5.
We refer the reader to the CLINGO manual (http://potassco.
sourceforge.net) for their precise meaning.

descendent_step(ST1,ST2) :- substep(ST1,ST2).
descendent_step(ST1,ST2) :descendent_step(ST1,ST3), descendent_step(ST3,ST2).

System Overview
Figure 1 illustrates the overall QA system, where arrows indicate the information ﬂow. The core part of the system is
an ASP solver, which answers the questions based on the
relevant information from the knowledge base and the user
proﬁle. The knowledge base contains a project knowledge
base and a domain knowledge base. The domain knowledge base provides project-independent information, such
as attributes of tools, accessories, and materials. The project
knowledge base provides project-speciﬁc information, such
as tools and materials needed and steps to be performed on
a certain project. The user proﬁle provides information on
the user who is asking the question, such as his/her DIY
skill level and age. Information on the speciﬁc project that
is being performed, along with the user proﬁle, facilitates
context-aware question answering for the DIY domain. They
are integrated with the domain knowledge by a set of project
constraint generation rules. The domain knowledge base is
constructed by automatically extracting information from
web documents guided by an ontology manually created by
woodworking experts. The question is asked in natural language, and a question interpreter converts the question into
a structured form that can be part of the input to the ASP
solver.

Generate and Test Paradigm In ASP, one can easily
describe a set of “potential solutions” and use a set of
constraints to eliminate all “bad” solutions. For example,
the following program ﬁnds tools X to suggest by ruling out
expensive tools and unsafe tools:

Answering Questions on Alternatives
In this section, we explain how the framework addresses a
speciﬁc type of questions — questions about alternatives.
These questions are about the possibility of using one object
to replace another object in performing a certain project. An
example of this type of questions is
Can I use a table saw instead of a jigsaw in the project
“armchair with stool”?
We call the object to be replaced “target object,” and the
object that replaces the target object “new object.” The answers to this type of questions need to take into account the
following factors:
1. The basic function of target objects and new objects, for
example, “cutting” for saws, “sanding” for sanders.
2. Features that distinguish one type of objects from another
type of objects under the same category. For example,
both jigsaws and table saws are used for cutting, but jigsaws can make curved cuts while table saws generally
cannot.
3. The role that the target object plays in the speciﬁc project.
For example, a jigsaw can be used to cut curves in project
A but can be used to cut straight lines in project B.

3 {suggestedTool(X) : tool(X)} 5.
:- expensive(X), suggestedTool(X).
:- unsafe(X), suggestedTool(X).

The ﬁrst rule is a cardinality constraint to generate answer
sets that contain 3 to 5 suggested tools. The next two rules,
which have the empty head, eliminate the answer sets among
them which contain expensive or unsafe tools.
Aggregates The availability of aggregates, such as
#count, #sum, #min, #max, in ASP allows one for representing combinatorial choices succinctly. For example,
the following rule asserts that “the project PROJ is considered as drilling-intensive if there are at least 5
drilling steps”.
drilling_intensive(PROJ) :5{step(PROJ,ID,"drilling"):step_ID(ID)}, project(PROJ).

The following rule is another example, which estimates
the total time T needed for a project by summing up times
T1 needed by each action ACT in the project:
time_estimation(PROJ,T) :- T = #sum[step(PROJ,ID,ACT):
time_needed(ACT,T1)=T1], project(PROJ).

4754

Figure 1: System Overview
4. Information about the user, such as the user’s age, the
user’s skill level, etc.
5. Additional context information that may or may not be
speciﬁed by the user, such as a time constraint for the
project.
Among these aspects, the ﬁrst and the second are provided by the domain knowledge base. The ﬁrst is speciﬁed by woodworking experts. The second is automatically
constructed from documents in natural language, guided by
attribute schemas that are manually created by woodworking experts. The third is automatically inferred from project
descriptions. The fourth and the ﬁfth are speciﬁed by the
user. All the information mentioned here is converted into
ASP facts. With this information available, an ASP reasoner
infers constraints on the new object, answers the question
by checking whether these constraints are satisﬁed by the
new object, and outputs additional information about this replacement that supports the answer.

Figure 2: Knowledge Base Construction Pipeline

Building the Knowledge Base
As mentioned before, among the ﬁve aspects that we take
into account to answer questions about alternatives, the second one needs to be provided by the domain knowledge
base. The Information Extraction Module (IE Module) is responsible for building this part of domain knowledge base.
In this section, we discuss how we perform the information
extraction. Figure 2 illustrates the whole IE process.
Relevant Sentence Collecting The ﬁrst step is to create
a collection of sentences that potentially contains the information we need. We collected about 2000 documents from
various websites including tool buying guides, woodworking blogs, encyclopedia, etc. A dictionary of entities of interests is deﬁned, including 16 types of saws, 42 types of
wood material, 6 types of sanding tools, 10 types of fastening tools, 5 types of ﬁnishing tools and 5 types of measuring
tools. We use this dictionary to select the sentences where at
least one entity of interest appears from the corpus, and in
this way form the collection of relevant sentences.
Proposition Extraction Extraction from the text is performed mainly via ASP reasoning. We run an ASP solver
on an ASP program which contains rules to extract useful
parts of a sentence to form an atomic proposition. For exam-

Figure 3: Proposition Extraction

ple, from the sentence “Jigsaws are used to cut curves” we
extract the atomic proposition “cut curve(jigsaw).”
Figure 3 illustrates the process. The input is the dependency parsing (De Marneffe et al. 2006) of the sentence,
converted into a set of ASP facts. The ASP program for
proposition extraction contains various sentence patterns
deﬁned as abstract dependency parsing, specifying which
nodes in the dependency parsing tree should be extracted.
For the above example, the sentence pattern (as shown in
the middle box in Figure 3) is “ARG is/are used to ExtV
ExtN ,” where ARG, ExtV and ExtN are to be extracted.
Sometimes the modiﬁers of an extracted token contain

4755

In the above code, “@meansCurveCutting(Desc)”
is an external Lua function call which returns 1 iff there
is any lexicon deﬁned for curve-cutting appearing in the
string Desc.

key information as well and thus need to be extracted. To
do this, we ﬁrst deﬁne what a modiﬁer is:
modifying_relation("nmod").
modifying_relation("nmod:of").
...
modifies(MOD,TOK) :- dep(TOK,MOD,R), modifying_relation(R).

• Constraints from DIYer “Kids-friendly” is deﬁned as
“easy to use and safe”; If the user’s age is less than 18,
require tools to be kids-friendly.

Then we write a rule saying “a modiﬁer of an extracted
token is also extracted.”

hasFeature(X, "Inferred:NotHardToUse") :not attrVal(X, "Difficulty", "Difficult"), entity(X).
hasFeature(X,"Inferred:Kids-Friendly") :attrVal(X,"Safety","Safe"),
hasFeature(X,"Inferred:NotHardToUse"), entity(X).

extracted(MOD) :- extracted(TOK), modifies(MOD, TOK).

Note that this rule deﬁnes the concept “extracted” in terms of
itself. Handling such recursive deﬁnition is a unique feature
of ASP.
Normalization Having a set of keyword lists extracted
from the text, the next step is to decide for each list whether
the list contains any useful fact about the entity, and if
yes, we derive a KB instance from it, or discard it otherwise. We do this by deﬁning an attribute schema for each
type of entities. An attribute schema contains a set of attributes along with their values. For example, we deﬁne that
cutting tools have the attribute “shape-of-cut”, whose
values could be “straight”, “curve”, “miter-cut”,
“bevel-cut”, etc. Note that in our schema, we allow an
attribute to have multiple values or no values.
To extract attribute values from extracted propositions,
we further deﬁne lexicons for each attribute value. For example, the lexicons for the attribute value straight of
shape-of-cut are: “straight”, “rectangular”,
“stiff”, etc. We then simply detect if any of these lexicons
appears in the extracted proposition. If yes, we construct
an ASP fact of the form attr(X, "Shape-of-Cut",
"Straight").
Inferring attribute values via commonsense rules Since
some attribute values are not speciﬁed in the texts, those values were inferred using ASP rules such as ”If a tool is a
power tool, it is difﬁcult to use.”
Attribute values inferred by these rules are used only
when there is no value extracted from the text. This is
implemented utilizing ASP’s feature of default reasoning.
Take the rule about power tool and difﬁculty of use as an
example. We ﬁrst write ASP rules to deﬁne “Easy” and
“Difficult” as mutually exclusive values, and then we
write:

req(P, X, "Inferred:Kids-Friendly") :user_age(AGE), AGE < 18, action(X),

• Constraints from user If the user speciﬁed a time constraint which is smaller than the estimated project ﬁnishing time plus a time buffer, require tools to have high efﬁciency.
req(P,X,"Efficiency:High") :user_time_budget(TH), total_time_needed(P,TM),
query(P,T1,T2), TH * 60 < TM + TB * 60,
time_buffer(TB), action(X).

Answering the Question
Having the domain knowledge base and the requirements on
the new object, we are ready to answer the question about alternatives. We again use ASP rules to deﬁne what the answer
to the question is.
We ﬁrst deﬁne the relations between entities and actions.
The ontology already speciﬁes the corresponding actions of
tools, such as the relation hasAction2 . The ontology also
speciﬁes interchangeable actions, such as nailing and screwing3 . We deﬁne the relation hasDerivedAction in terms
of the relations hasAction and interchangeable.
We say an entity T has derived action Act if T has action
Act, or T has an action Act1 that is interchangeable with
Act
hasDerivedAction(T,Act) :- hasAction(T,Act).
hasDerivedAction(T,Act) :hasAction(T,Act1),
interchangeable(Act, Act1).

% By default, power tools are difficult to use
{attr(X,"Difficulty","Difficult")} :- hasModifier(X, "power").

Then we deﬁne when the replacement is not recommended. The replacement is not recommended in the following two cases:

Inferring the Constraints

• The replacement of T1 by T2 is not recommended if T2
does not support the action that T1 has.

Having the domain knowledge base available, we can now
write ASP rules to infer constraints that the new object needs
to satisfy. Some examples of constraints inference rules are:

not_recommended(P,T1,T2) :- query(P,T1,T2),
hasDerivedAction(T1,Act), not hasDerivedAction(T2,Act).

• The replacement of T1 by T2 is not recommended if T2
supports all actions that the target entity has, but does not
support some features that are required by the project

• Constraints from project if any lexicon for “curve” appears in the description of a step involving cutting, require
the cutting tools used for the project to have the feature
“Shape: Curve”:

2
For
example,
hasAction("Screwdriver",
"Screwing").
3
We consider two actions as interchangeable actions if it is generally possible to replace one by the other. It does not mean it is
always ok to replace one by the other.

step_type(P, ST, "Curve_Cutting") :step(P, ST, Act, Desc), step_type(P, ST, "Cutting"),
@meansCurveCutting(Desc) == 1.
req(P, "Cutting", "Shape:Curve") :step_type(P, ST, "Curve_Cutting"), project(P).

4756

not_recommended(P,T1,T2) :- query(P,T1,T2),
req(P,Act,Req), hasDerivedAction(T2, Act),
not hasFeature(T2, Req),

Otherwise, the replacement is possible.
possible(P,T1,T2) :- not not_recommended(P,T1,T2),
query(P, T1, T2).

Result

Figure 4: Results of the Survey

The ﬁnal system consists of ∼ 800 ASP facts about entity
features (extracted from the text), ∼ 700 ASP facts converted from the ontology, ∼8800 ASP facts converted from
44 project instructions and ∼100 ASP rules.
Table 1 shows four question answering examples to illustrate the system’s ability to perform context-aware question
answering.

also applies to the comparison between two objects. Two
objects might have the same feature to different degrees. It
is desirable if in the comparison we can say things like “A is
way more efﬁcient than B,” “A is slightly less safe than B,”
etc. to describe the situation more precisely. Here we brieﬂy
illustrate how this can be implemented in our framework using ASP.
First, we deﬁne each constraint as a weighted sum of a
set of entity features (seen as 1-0 variables). We take “kidsfriendly” and “high-efﬁciency” for example:

Evaluation
To evaluate our system, we compared our system against online search, a common practice for information seeking, on
41 questions about alternatives.4 To do this, we recruited
about 250 amateur DIYers through Amazon Mechanical
Turk,5 and for each question, we asked three participants to
ﬁnd an answer using online search and report the answer,
the total time taken and the number of the webpages visited.
If the time exceeded three minutes, we considered it to fail.
For our system, we did not measure the total time taken since
the answer was instantaneously found. Instead we asked the
two questions: (1) whether the answer exhibited sufﬁcient
domain knowledge and (2) whether the answer would be
helpful for their potential DIY projects.
Our result shows that our system provides a much better
user experience. First, we ﬁnd that 40% of the participants
failed to ﬁnd an answer within three minutes and that the
average number of the websites visited by the participants
was three. This indicates that answering a non-factoid DIY
question using online search requires quite much time and
efforts. Fig 5 shows the result of our system. The feedback
from the participants is positive. 67% participants responded
that the answer provided by our system showed sufﬁcient
domain knowledge, and 83% participants responded that the
answers would be helpful for their future DIY projects.

contribute("Difficulty:Easy","Kids-Friendly",10).
contribute("Difficulty:Difficult","Kids-Friendly",-10).
contribute("Safety:Safe","Kid-Friendly",20).
contribute("Safety:Unsafe","Kids-Friendly",-50).
contribute("Efficiency:High","High-Efficiency",50).
contribute("Efficiency:Low","High-Efficiency",-50).
constraint_sat(TAM, CONSTR, X) :entity(TAM), constraint(CONSTR),
X = #sum[hasFeature(TAM,F):contribute(F,CONSTR,Y) = Y].

Then we deﬁne the certainty degree of recommendation
as the weighted sum of the degree to which all constraints
are satisﬁed:
all_constraint_sat(TAM,X) :- entity(TAM),
X = #sum[hasConstraint(CONSTR,W):
constraint_sat(TAM,CONSTR,Y) = Y*W].

Finally, we deﬁne the advantage and disadvantage of the
new object relative to the target object, as the difference in
the degrees to which each of the two objects satisﬁes each
constraint
pros(CONSTR,Z) :- query(P,TARGET_TAM,NEW_TAM),
constraint_sat(NEW_TAM,CONSTR,X),
constraint_sat(TARGET_TAM,CONSTR,Y), Z = X - Y, Z > 0.

Extension: Incorporating Quantitative
Uncertainty in Answers

As an example, suppose the user asks whether it is ok to
use jigsaw instead of hand saw in some project:

Our basic reasoning provides deterministic answers to questions about alternatives - an either-or “possible/recommended” answer and a comparison between the new object
and the target object where a list of Boolean-valued features
is shown. In a real-world setting, often it is more reasonable to give an answer with a certainty degree (e.g., “The
replacement is mildly/strongly recommended”, etc.). This

query("some-project", "hand-saw", "jigsaw").

And the two constraints “kids-friendly” and “highefﬁciency” are inferred for the project, with “kids-friendly”
considered much more important than “high-efﬁciency”:
hasConstraint("Kids-Friendly", 10).
hasConstraint("High-Efficiency", 1).

where 10 and 1 represent how important each of the constraints is. In real applications, these numbers can be derived
from the context. For example, the importance of “highefﬁciency” can be negatively correlated to the difference between time budget and estimated project ﬁnishing time; the

4
These questions were collected through a user study before the
development of the system. In the user study, we asked DIYers to
perform a DIY task while speaking aloud any question and then
recorded those questions.
5
http://www.mturk.com

4757

Question

Context

Can I use table saw instead of jigsaw?

Project:
bird house for balcony
and garden1
(where jigsaw is used
cut straight lines)
Project:
armchair with stool2
(where jigsaw is used
cut curves)

Can I use nail gun
instead of screwdriver
in the project armchair
with stool?

User Age: Adult

User Age: Kid
Can I hand sand the
surface instead of using multi-sander in the
project treasure chest3?

Time
hours

constraint:

5

Time constraint: 3 hours

Answer
Possible.
Please be aware of the following differences between the two entities:
jigsaw:
”Shape:Curve” ”Shape:Circle” ”Portability:Portable/Stationary”
table-saw:
”Shape:Ripcut” ”Shape:Bevel-Cut” ”Shape:Miter-Cut” ”Portability:Stationary”
Not Recommended.
table-saw does not support ”Shape:Curve”.
Possible.
Please be aware of the following differences between the two entities:
screwdriver:
”Strength:High” ”Durability:High” ”Cost:High”
nail-gun:
”Safety:Unsafe” ”Strength:Medium” ”Durability:Medium” ”Cost:Medium”
Not Recommended. nail-gun does not support ”Kids-Friendly”.
Possible.
Please be aware of the following differences between the two entities:
multi-sander:
”Quality:Precise” ”Kids-Friendly:No” ”Surface-Size:Large” ”Power-Source:Corded”
”Material:Wood” ”Shape:Straight” ”Quality:Medium” ”Portability:Portable/Stationary”
”Safety:Unsafe” ”Difﬁculty:Difﬁcult” ”Efﬁciency:High”
hand sander:
”Efﬁciency:Low” ”Power-Source:Manual” ”Portability:Portable” ”Quality:Rough
Not Recommended. hand sander does not support ”Efﬁciency:High”.

1

https://www.bosch-do-it.com/za/en/diy/knowledge/project-guides/birdhouse-for-balcony-and-garden-68609.jsp
2
https://www.bosch-do-it.com/za/en/diy/knowledge/project-guides/armchair-with-stool-68485.jsp
3
https://www.bosch-do-it.com/za/en/diy/knowledge/project-guides/treasure-chest-83813.jsp

Table 1: Showcase Examples of Question Answering
questions. We also discussed how more advanced reasoning
can be implemented in the framework. The evaluation result
suggests our approach is promising. The future work is to
extend the framework to account for other types of hypothetical reasoning in DIY domains.

importance of “kids-friendly” can be negatively correlated
to the user’s age.
The domain knowledge base provides:
entity("jigsaw").
hasFeature("jigsaw", "Difficulty:Difficult").
hasFeature("jigsaw", "Safety:Unsafe").
hasFeature("jigsaw", "Efficiency:High").
entity("hand-saw").
hasFeature("hand-saw", "Difficulty:Easy").
hasFeature("hand-saw", "Safety:Moderate").
hasFeature("hand-saw", "Efficiency:Low").

Acknowledgments We are grateful to the anonymous referees for their useful comments on the draft of this paper.
This work was partially supported by the National Science
Foundation under Grants IIS-1319794 and IIS-1526301.

References

Combining all the above, the ASP solver returns

Aditya, S.; Baral, C.; Vo, N. H.; Lee, J.; et al. 2015. Recognizing social constructs from textual conversation. In NAACL
HLT 2015, 1293–1298.
De Marneffe, M.-C.; MacCartney, B.; Manning, C. D.; et al.
2006. Generating typed dependency parses from phrase structure parses. In Proceedings of LREC, volume 6, 449–454.
Ferrucci, D.; Brown, E.; Chu-Carroll, J.; Fan, J.; Gondek, D.;
Kalyanpur, A. A.; Lally, A.; et al. 2010. Building watson: An
overview of the DeepQA project. AI magazine 31(3):59–79.
Gelfond, M., and Lifschitz, V. 1988. The stable model semantics for logic programming. In Proceedings of International
Logic Programming Conference and Symposium, 1070–1080.
MIT Press.
Lifschitz, V. 2008. What is answer set programming? In
Proceedings of the AAAI Conference on Artiﬁcial Intelligence,
1594–1597. MIT Press.
Waltinger, U.; Tecuci, D.; Olteanu, M.; Mocanu, V.; and Sullivan, S. 2013. USI answers: Natural language question answering over (semi-) structured industry data. In IAAI.

constraint_sat("hand-saw","High-Efficiency",-50)
constraint_sat("hand-saw","Kids-Friendly",10)
constraint_sat("jigsaw","High-Efficiency",50)
constraint_sat("jigsaw","Kids-Friendly",-60)
all_constraint_sat("hand-saw",50)
all_constraint_sat("jigsaw",-550)
recommendation_level("jigsaw",-550)
pros("High-Efficiency",100)
cons("Kids-Friendly",70)

which can be interpreted as “It is strongly not recommended
to replace hand saw with jigsaw. Jigsaw is much more efﬁcient than hand saw, but it is less kids-friendly than hand
saw”.

Conclusion
We presented a framework for non-factoid question answering in DIY domains. We took a logic-based approach to such
non-factoid question answering. We showed how a speciﬁc
type of questions — questions about alternatives was handled in this framework, from constructing the knowledge
to the reasoning process involved in answering this type of

4758

TLP 11 (6): 953–988, 2011.

C Cambridge University Press 2011


doi:10.1017/S1471068411000019

953

First published online 24 May 2011

On elementary loops of logic programs
MARTIN GEBSER
Institut für Informatik, Universität Potsdam, Germany
(e-mail: gebser@cs.uni-potsdam.de)

JOOHYUNG LEE
School of Computing, Informatics and Decision Systems Engineering,
Arizona State University, Tempe, AZ, USA
(e-mail: joolee@asu.edu)

YULIYA LIERLER
Department of Computer Science, University of Kentucky, Lexington, KY, USA
(e-mail: yuliya@cs.uky.edu)

submitted 23 May 2010; accepted 18 August 2010

Abstract
Using the notion of an elementary loop, Gebser and Schaub (2005. Proceedings of the Eighth
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’05 ),
53–65) reﬁned the theorem on loop formulas attributable to Lin and Zhao (2004) by
considering loop formulas of elementary loops only. In this paper, we reformulate the
deﬁnition of an elementary loop, extend it to disjunctive programs, and study several
properties of elementary loops, including how maximal elementary loops are related to minimal
unfounded sets. The results provide useful insights into the stable model semantics in terms
of elementary loops. For a nondisjunctive program, using a graph-theoretic characterization
of an elementary loop, we show that the problem of recognizing an elementary loop is
tractable. On the other hand, we also show that the corresponding problem is coNP-complete
for a disjunctive program. Based on the notion of an elementary loop, we present the
class of Head-Elementary-loop-Free (HEF) programs, which strictly generalizes the class of
Head-Cycle-Free (HCF) programs attributable to Ben-Eliyahu and Dechter (1994. Annals of
Mathematics and Artiﬁcial Intelligence 12, 53–87). Like an HCF program, an HEF program
can be turned into an equivalent nondisjunctive program in polynomial time by shifting head
atoms into the body.
KEYWORDS: stable model semantics, loop formulas, unfounded sets

1 Introduction
The theorem on loop formulas attributable to Lin and Zhao (2004) has contributed
to understanding the relationship between the stable model semantics and classical
logic. Unlike other translations that modify the vocabulary of a logic program
(Ben-Eliyahu and Dechter 1994; Lin and Zhao 2003; Janhunen 2006), the original
theorem on loop formulas characterizes the stable models of a nondisjunctive
program in terms of the models of its completion that satisfy the loop formulas

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

954

M. Gebser et al.

of all loops of the program. This allows us to compute stable models using
SAT solvers, which led to the design of answer set solvers assat1 (Lin and
Zhao 2004) and cmodels2 (Giunchiglia et al. 2004). Owing to its importance in
semantic understanding as well as in stable model computation, the theorem on
loop formulas has been extended to more general classes of logic programs, such
as disjunctive programs (Lee and Lifschitz 2003), inﬁnite programs and programs
containing classical negation (Lee 2005), and programs containing aggregates (Liu
and Truszczynski 2006; You and Liu 2008; Lee and Meng 2009). Moreover, it has
been applied to other nonmonotonic logics, such as circumscription (Lee and Lin
2006) and nonmonotonic causal logic (Lee 2004). The stable model semantics for
the ﬁrst-order formulas as given by Ferraris et al. (2007, 2011) is also closely related
to the idea of loop formulas, as described by Lee and Meng (2008).
By slightly modifying the deﬁnition of a loop, Lee (2005) showed that loop
formulas can be viewed as a generalization of completion (Clark 1978). The modeltheoretic account of loop formulas given by Lee (2005) also tells us that the idea
of loop formulas is closely related to assumption sets (Saccá and Zaniolo 1990)
or unfounded sets (Leone et al. 1997). In a sense, the theorem by Lin and Zhao
(2004) is an enhancement of the unfounded set-based characterization of stable
models given by Sacca and Zaniolo (1990) and Leone et al. (1997). The unfounded
set-based characterization takes into account the loop formulas of all sets of atoms,
while the theorem by Lin and Zhao (2004) considers the loop formulas of loops only.
Gebser and Schaub (2005) improved this enhancement even further. They deﬁned
the notion of an elementary loop of a nondisjunctive program and showed that the
theorem by Lin and Zhao (2004) remains correct even if we consider loop formulas
of elementary loops only.
In this paper we reformulate the deﬁnition of an elementary loop of a nondisjunctive program by Gebser and Schaub (2005), extend it to disjunctive programs,
and study several properties of elementary loops, including how maximal elementary
loops are related to minimal unfounded sets. Based on the notion of an elementary
loop, we present the class of Head-Elementary-loop-Free (HEF) program, which
strictly generalizes the class of Head-Cycle-Free (HCF) programs attributable to
Ben-Eliyahu and Dechter (1994). Like an HCF program, an HEF program can be
turned into an equivalent nondisjunctive program in polynomial time by shifting
head atoms into the body—a simple transformation deﬁned by Gelfond et al.
(1991). This tells us that an HEF program is an “easy” disjunctive program, which
is merely a syntactic variant of a nondisjunctive program. We also observe that
several other properties of nondisjunctive and HCF programs can be generalized
to HEF programs. The main results by Lin and Zhao (2003) and You et al.
(2003) characterizing stable models in terms of inherent tightness and weak tightness,
respectively, can be extended to HEF programs, and likewise the operational
characterization of stable models of HCF programs attributable to Leone et al.
(1997) can be extended to HEF programs. The properties of elementary loops
and HEF programs studied here may be useful in improving the computation of
1
2

http://assat.cs.ust.hk/
http://www.cs.utexas.edu/users/tag/cmodels/

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

955

disjunctive answer set solvers, such as claspd3 (Drescher et al. 2008), cmodels
(Lierler 2005), dlv4 (Leone et al. 2006), and gnt5 (Janhunen et al. 2006).
The outline of this paper is as follows. In Section 2 we present our reformulated
deﬁnition of an elementary loop of a nondisjunctive program and provide a
corresponding reﬁnement of the theorem on loop formulas, as well as some properties
of elementary loops. These results are extended to disjunctive programs in Section 3.
In Section 4 we introduce the class of HEF programs and show that their shifted
variants preserve stable models. In Section 5 we generalize the notion of inherent
tightness to HEF programs. An operational characterization of stable models of
HEF programs is presented in Section 6. Finally, Section 7 concludes the paper.
This paper is an extended version of the conference papers of Gebser et al. (2006,
2007).6

2 Nondisjunctive programs
After providing the relevant background on nondisjunctive programs, this section
introduces elementary loops of nondisjunctive programs. We further reﬁne elementary loops to elementarily unfounded sets, yielding a syntactic characterization of
minimal unfounded sets. Moreover, we show that elementary loops of nondisjunctive
programs can be recognized in polynomial time. (The statements of the theorems
and the propositions in this section that apply to nondisjunctive programs will be
generalized to disjunctive or HEF programs in later sections and the proofs will be
given there.) Finally, we compare our reformulation of elementary loops with the
deﬁnition given by Gebser and Schaub (2005).
2.1 Background
A nondisjunctive rule is an expression of the form
a1 ← a2 , . . . , am , not am+1 , . . . , not an

(1)

where n > m > 1 and a1 , . . . , an are propositional atoms. A nondisjunctive program is
a ﬁnite set of nondisjunctive rules.
We will identify a nondisjunctive rule (1) with the propositional formula
a2 ∧ · · · ∧ am ∧ ¬am+1 ∧ · · · ∧ ¬an → a1 ,

(2)

and will often write (1) as
a1 ← B, F ,

(3)

where B is a2 , . . . , am and F is not am+1 , . . . , not an . We will sometimes identify B
with its corresponding set of atoms.
We will identify an interpretation with the set of atoms that are true in it. We say
that a set X of atoms satisﬁes a rule (1) if X satisﬁes (2). Moreover, X satisﬁes a
3
4
5
6

http://potassco.sourceforge.net/
http://www.dbai.tuwien.ac.at/proj/dlv/
http://www.tcs.hut.fi/Software/gnt/
In Gebser et al. (2006, 2007), the term “elementary set” was used in place of “elementary loop.”

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

956

M. Gebser et al.

Fig. 1. The dependency graph of Program Π1 .

nondisjunctive program Π (symbolically, X |= Π) if X satisﬁes every rule (1) of Π.
If X satisﬁes Π, we also call X a model of Π.
The reduct ΠX of a nondisjunctive program Π w.r.t. a set X of atoms is obtained
from Π by deleting each rule (3) such that X |= F, and replacing each remaining
rule (3) with a1 ← B. A set X of atoms is a stable model, also called an answer set,
of Π if X is minimal among the set of atoms that satisfy ΠX .
The (positive) dependency graph of a nondisjunctive program Π is the directed
graph such that its vertices are the atoms occurring in Π, and its edges go from a1
to a2 , . . . , am for all rules (1) of Π. A nonempty set Y of atoms is called a loop of Π
if, for every pair a, b of atoms in Y , there is a path (possibly of length 0) from a
to b in the dependency graph of Π such that all vertices in the path belong to Y .
In other words, a nonempty set Y of atoms that occur in Π is a loop of Π if the
subgraph of the dependency graph of Π induced by Y is strongly connected. It is
clear that every singleton whose atom occurs in Π is a loop of Π.
For illustration, consider the following program Π1 :
p ← not s
p←r
q←r
r ← p, q .
Figure 1 shows the dependency graph of Π1 . Program Π1 has seven loops: {p}, {q},
{r}, {s}, {p, r}, {q, r}, and {p, q, r}.
For any set Y of atoms, the external support formula of Y for a nondisjunctive
program Π, denoted by ES Π (Y ), is the disjunction of conjunctions B ∧ F for all
rules (3) of Π such that a1 ∈ Y and B ∩ Y = ∅. The ﬁrst condition expresses that
the atom “supported” by (3) is an element of Y . The second condition ensures that
this support is “external”: the atoms in B that it relies on do not belong to Y . Thus,
Y is called externally supported by Π w.r.t. a set X of atoms if X |= ES Π (Y ).
For any set Y of atoms, by LF Π (Y ), we denote the following formula:

a → ES Π (Y ) .
(4)
a∈Y

(The expression in the antecedent stands for the conjunction of all elements in Y .)
Formula (4) is called the (conjunctive) loop formula of Y for Π. Note that we still
call (4) a loop formula even when Y is not a loop of Π.
The following reformulation of the Lin–Zhao (2004) theorem, which characterizes
the stability of a model by loop formulas, is a part of the main theorem by Lee
(2005) for the nondisjunctive case.
Theorem 1 (Lee 2005)
For any nondisjunctive program Π and any set X of atoms that occur in Π, if X is
a model of Π, then the following conditions are equivalent:
(a) X is a stable model of Π;

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

957

(b) X satisﬁes LF Π (Y ) for all nonempty sets Y of atoms that occur in Π;
(c) X satisﬁes LF Π (Y ) for all loops Y of Π.
According to the equivalence between conditions (a) and (b) in Theorem 1, a
model of Π1 is stable iﬀ it satisﬁes the loop formulas of all 15 nonempty sets of
atoms formed from the atoms occurring in Π1 . On the other hand, condition (c) tells
us that it is suﬃcient to restrict attention to the following loop formulas of the seven
loops of Π1 :
p → ¬s ∨ r
q→r
r →p∧q
s→⊥
p ∧ r → ¬s
q∧r →⊥
p ∧ q ∧ r → ¬s .

(5)

Program Π1 has six models: {p}, {s}, {p, s}, {q, s}, {p, q, r}, and {p, q, r, s}. Among
them, {p} is the only stable model of Π1 , which is also the only model of Π1 that
satisﬁes all loop formulas in (5).
As noted by Lee (2005), the equivalence between conditions (a) and (c) is a
reformulation of the theorem by Lin and Zhao (2004); the equivalence between
conditions (a) and (b) is a reformulation of Corollary 2 by Sacca and Zaniolo
(1990) and Theorem 4.6 by Leone et al. (1997) (in the nondisjunctive case), which
characterizes the stability of a model in terms of unfounded sets. For any sets X, Y
of atoms, we say that Y is unfounded by Π w.r.t. X if Y is not externally supported
by Π w.r.t. X. Condition (b) can be stated in terms of unfounded sets as follows:
(b ) X contains no nonempty unfounded sets for Π w.r.t. X.

2.2 Elementary loops of nondisjunctive programs
Gebser and Schaub (2005) showed that Y in LF Π (Y ) in Theorem 1 can be restricted
to “elementary” loops only. In this section we present a reformulation of their
deﬁnition of an elementary loop and investigate its properties. In Section 2.5 we
compare our reformulation with the original deﬁnition given by Gebser and Schaub
(2005).
To begin with, the following proposition tells us that a loop can be deﬁned without
mentioning a dependency graph.
Proposition 1
For any nondisjunctive program Π and any nonempty set X of atoms that occur
in Π, X is a loop of Π iﬀ, for every nonempty proper subset Y of X, there is a
rule (3) in Π such that a1 ∈ Y and B ∩ (X \ Y ) = ∅.
For any set X of atoms and any subset Y of X, we say that Y is outbound in X
for a nondisjunctive program Π if there is a rule (3) in Π such that

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

958

M. Gebser et al.
• a1 ∈ Y ,
• B ∩ (X \ Y ) = ∅, and
• B ∩ Y = ∅.

The following proposition describes the relationship between the external support
formula of a set Y of atoms and the external support formula of a subset Z of Y
that is not outbound in Y .
Proposition 2
For any nondisjunctive program Π and any set X, Y , Z of atoms such that
Z ⊆ Y ⊆ X, if Z is not outbound in Y for Π and X |= ES Π (Z), then X |= ES Π (Y ).
Proposition 2 tells us that, in order to verify that a set Y of atoms is externally
supported by Π w.r.t. a superset X of Y , it is suﬃcient to identify some externally
supported subset of Y that is not outbound in Y for Π. Conversely, if Y is
not externally supported by Π w.r.t. X, then every subset of Y that is externally
supported by Π w.r.t. X is outbound in Y for Π.
For any nonempty set X of atoms that occur in Π, we say that X is an elementary
loop of Π if all nonempty proper subsets of X are outbound in X for Π. As with
loops, it is clear from the deﬁnition that every singleton whose atom occurs in Π
is an elementary loop of Π. It is also clear that every elementary loop of Π is a
loop of Π: the condition for being an elementary loop implies the condition for
being a loop as stated in Proposition 1. On the other hand, a loop is not necessarily
an elementary loop. For instance, one can check that {p, q, r} is not an elementary
loop of Π1 since {p, r} (or {q, r}) is not outbound in {p, q, r} for Π1 . All other loops
of Π1 are elementary loops. Note that an elementary loop may be a proper subset
of another elementary loop (both {p} and {p, r} are elementary loops of Π1 ).
The following program replaces the last rule of Π1 with two other rules:
p ← not s
p←r
q←r
r←p
r←q .

(6)

The program has the same dependency graph as Π1 , and hence has the same loops.
However, its elementary loops are diﬀerent from those of Π1 : all its loops are
elementary loops as well, including {p, q, r}.
The deﬁnition of an elementary loop X given above is not aﬀected if we check the
outboundness condition only for all loops or for all elementary loops that belong to
X instead of all nonempty proper subsets of X.
Proposition 3
For any nondisjunctive program Π and any nonempty set X of atoms that occur
in Π, X is an elementary loop of Π iﬀ all proper subsets of X that are elementary
loops of Π are outbound in X for Π.
The following proposition describes an important relationship between loop
formulas of elementary loops and loop formulas of arbitrary sets of atoms.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

959

Proposition 4
For any nondisjunctive program Π and any nonempty set Y of atoms that occur
in Π, there is an elementary loop Z of Π such that Z is a subset of Y and LF Π (Z)
entails LF Π (Y ).
Proposition 4 allows us to limit attention to loop formulas of elementary loops
only. This yields the following theorem, which is a reformulation of Theorem 3
by Gebser and Schaub (2005).
Theorem 1 (d )
The following condition is equivalent to each of conditions (a)–(c) in Theorem 1:
(d) X satisﬁes LF Π (Y ) for all elementary loops Y of Π.
For instance, according to Theorem 1 (d), a model of Π1 is stable iﬀ it satisﬁes the
ﬁrst six loop formulas in (5); the loop formula of the non-elementary loop {p, q, r}
(the last one in (5)) can be disregarded.
2.3 Elementarily unfounded sets for nondisjunctive programs
If we modify condition (c) in Theorem 1 by replacing “loops” in its statement
with “maximal loops,” the condition becomes weaker, and the modiﬁed statement
of Theorem 1 is incorrect. For instance, Π1 has only two maximal loops, {p, q, r}
and {s}, and their loop formulas are satisﬁed by a non-stable model {p, q, r}. In
fact, maximal loop {p, q, r} is not even an elementary loop of Π1 . Similarly, it is
not suﬃcient to consider maximal elementary loops only. If we replace “elementary
loops” in the statement of Theorem 1 (d) with “maximal elementary loops,” then
the modiﬁed statement is incorrect. For instance, the program
p ← q, not p
q ← p, not p
p←
has two models, {p} and {p, q}, among which the latter is not stable. On the other
hand, the only maximal elementary loop of the program is {p, q}, and its loop
formula p ∧ q →  is satisﬁed by both models, so that this loop formula alone is
not suﬃcient to refute the stability of {p, q}. (Model {p, q} does not satisfy the loop
formula of {q}, which is q → p ∧ ¬p.)
However, in the following we show that, if we consider the “relevant” part of a
program w.r.t. a given interpretation, it is suﬃcient to restrict attention to maximal
elementary loops. For any nondisjunctive program Π and any set X of atoms, by
ΠX , we denote the set of all rules (3) of Π such that X |= B, F. The following
proposition states that all nonempty proper subsets of an elementary loop of ΠX
are externally supported by Π w.r.t. X.
Proposition 5
For any nondisjunctive program Π, any set X of atoms, and any elementary loop Y
of ΠX , X satisﬁes ES Π (Z) for all nonempty proper subsets Z of Y .

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

960

M. Gebser et al.

Proposition 5 tells us that any elementary loop Y of ΠX that is unfounded by Π
w.r.t. X is maximal among the elementary loops of ΠX . From this, we obtain the
following result.
Theorem 1 (e)
The following condition is equivalent to each of conditions (a)–(c) in Theorem 1:
(e) X satisﬁes LF Π (Y ) for every set Y of atoms such that Y is
— a maximal elementary loop of ΠX , or
— a singleton whose atom occurs in Π.
Given a nondisjunctive program Π and a set X of atoms, we say that a set Y of
atoms that occur in Π is elementarily unfounded by Π w.r.t. X if Y is
• an elementary loop of ΠX that is unfounded by Π w.r.t. X, or
• a singleton that is unfounded by Π w.r.t. X.7
Proposition 5 tells us that any non-singleton elementarily unfounded set for Π
w.r.t. X is a maximal elementary loop of ΠX .
It is clear from the deﬁnition that every elementarily unfounded set for Π w.r.t. X
is an elementary loop of Π and that it is also unfounded by Π w.r.t. X. However,
the converse does not hold in general. For instance, {p, q} is an elementary loop that
is unfounded by the program
p ← q, not r
q ← p, not r
w.r.t. {p, q, r}, but {p, q} is not an elementarily unfounded set w.r.t. {p, q, r}.
The following corollary, which follows from Proposition 5, states that all nonempty
proper subsets of an elementarily unfounded set are externally supported. It is
essentially a reformulation of Theorem 5 by Gebser and Schaub (2005).
Corollary 1
For any nondisjunctive program Π, any set X of atoms, and any elementarily
unfounded set Y for Π w.r.t. X, X does not satisfy ES Π (Y ), but satisﬁes ES Π (Z)
for all nonempty proper subsets Z of Y .
Corollary 1 tells us that elementarily unfounded sets form an “anti-chain”: one
of them cannot be a proper subset of another. (On the other hand, an elementary
loop may contain another elementary loop as its proper subset.) Also it tells us
that elementarily unfounded sets are minimal among the nonempty unfounded sets
occurring in Π. Interestingly, the converse also holds.
Theorem 2
For any nondisjunctive program Π and any sets X, Y of atoms, Y is an elementarily
unfounded set for Π w.r.t. X iﬀ Y is minimal among the nonempty sets of atoms
occurring in Π that are unfounded by Π w.r.t. X.
7

Elementarily unfounded sets are closely related to “active elementary loops” deﬁned by Gebser and
Schaub (2005). We further investigate this relationship in Section 2.5.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

961

Notably, the correspondence between elementarily unfounded sets and minimal
nonempty unfounded sets has also led to an alternative characterization of UEmodels (Gebser et al. 2008), which characterizes uniform equivalence (Eiter and
Fink 2003) of nondisjunctive as well as disjunctive programs.
Similar to Theorem 1 (b ), Theorem 1 (e) can be stated in terms of elementarily
unfounded sets, thereby restricting attention to minimal nonempty unfounded
sets.
Theorem 1 (e )
The following condition is equivalent to each of conditions (a)–(c) in
Theorem 1:
(e ) X contains no elementarily unfounded sets for Π w.r.t. X.
The notion of an elementarily unfounded set may help improve computation
performed by SAT-based answer set solvers. Since there are exponentially many
“relevant” loops in the worst case (Lifschitz and Razborov 2006), SAT-based answer
set solvers do not add all loop formulas at once. Instead, they check whether
a model returned by a SAT solver is stable. If not, a loop formula that is not
satisﬁed by the model is added, and the SAT solver is invoked again. This process
is repeated until a stable model is found or the search space is exhausted. In view
of Theorem 1 (e ), it is suﬃcient to restrict attention to elementarily unfounded
sets during the computation. This ensures that the considered loop formulas belong
to elementary loops. Since every elementary loop is a loop, but not vice versa,
the computation may involve fewer loop formulas overall than in the case when
arbitrary loops are considered. However, whether this idea will lead to more eﬃcient
computation in practice requires further investigation.

2.4 Recognizing elementary loops of nondisjunctive programs
The deﬁnition of an elementary loop given in Section 2.2 involves considering all its
nonempty proper subsets (or at least all elementary loops that are subsets). This may
seem to imply that deciding whether a given set of atoms is an elementary loop is
a computationally hard problem. However, Gebser and Schaub (2005) showed that
this is not the case for nondisjunctive programs. They also noted that the notion
of a positive dependency graph is not expressive enough to distinguish between
elementary and non-elementary loops (Program Π1 and the program in (6) have
the same dependency graph, but their elementary loops are diﬀerent), and instead
used the rather complicated notion of a body–head dependency graph to identify
elementary loops. In this section we simplify their result by still referring to a
positive dependency graph. We show that removing some unnecessary edges from
a positive dependency graph is just enough to distinguish between elementary and
non-elementary loops.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

962

M. Gebser et al.

Fig. 2. The elementary subgraph of {p, q, r} for Program Π1 .

For any set X of atoms that occur in a nondisjunctive program Π, we deﬁne
EC 0Π (X) = ∅ ,
EC i+1
Π (X) = {(a1 , b) | there is a rule (3) in Π such that a1 ∈ X,
b ∈ B ∩ X, and all atoms in B ∩ X belong to the
same strongly connected component in (X, EC iΠ (X))} ,

EC Π (X) = i>0 EC iΠ (X) .
This is a “bottom-up” construction based on strongly connected components, i.e.,
maximal strongly connected subgraphs of a given graph. Thus EC iΠ (X) is a subset
of EC i+1
Π (X), and the graph (X, EC Π (X)) is a subgraph of the positive dependency
graph of Π. We call the graph (X, EC Π (X)) the elementary subgraph of X for Π.
Figure 2 shows the elementary subgraph of {p, q, r} for Π1 , which is not strongly
connected.
The following theorem is similar to Theorem 10 from (Gebser and Schaub 2005),
but instead of referring to the notion of a body–head dependency graph, it refers to
the notion of an elementary subgraph.
Theorem 3
For any nondisjunctive program Π and any nonempty set X of atoms that occur
in Π, X is an elementary loop of Π iﬀ the elementary subgraph of X for Π is
strongly connected.
Since an elementary subgraph can be constructed in polynomial time, the problem
of deciding whether a given set of atoms is an elementary loop of a nondisjunctive
program is tractable.
2.5 Comparison with Gebser–Schaub deﬁnition
In this section we compare our reformulation of elementary loops with the original
deﬁnition by Gebser and Schaub (2005) for nondisjunctive programs.
Let Π be a nondisjunctive program. A loop of Π is called trivial if it consists of
a single atom such that the dependency graph of Π does not contain an edge from
the atom to itself, and nontrivial otherwise.8 For a nontrivial loop L of Π, let
−
• RΠ
(L) = {(3) ∈ Π | a1 ∈ L, B ∩ L = ∅}, and
+
(L) = {(3) ∈ Π | a1 ∈ L, B ∩ L = ∅}.
• RΠ

Deﬁnition 1 (Gebser and Schaub 2005)
A nontrivial loop L of a nondisjunctive program Π is called a GS-elementary loop
+
− 
(L ) ∩ RΠ
(L) = ∅ for all proper subsets L of L that are nontrivial loops
of Π if RΠ
of Π.
8

In (Lin and Zhao 2004) and (Gebser and Schaub 2005), loops were deﬁned to be nontrivial.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

963

Proposition 6
For any nondisjunctive program Π and any set L of atoms, L is a GS-elementary
loop of Π iﬀ L is a nontrivial elementary loop of Π.
Proof. From left to right: Assume that L is a GS-elementary loop of Π. If L is
a singleton, it is a (nontrivial) elementary loop according to our deﬁnition. If L is
+
− 
(L ) ∩ RΠ
(L) = ∅ for any proper subset L of L that is a
not a singleton, we have RΠ
nontrivial loop of Π. In other words, there is a rule (3) in Π such that
a1 ∈ L ,

(7)

B ∩ L = ∅ ,

(8)

B ∩ (L \ L ) = ∅ .

(9)

and


Thus, we have that L is outbound in L for Π. Furthermore, for any trivial loop {a1 }
of Π contained in L, there must be a rule (3) in Π such that B ∩ (L \ {a1 }) = ∅, as L
cannot be a loop of Π otherwise. Since {a1 } is trivial, B ∩ {a1 } = ∅, so that {a1 } is
outbound in L for Π. By Proposition 3, it follows that L is a (nontrivial) elementary
loop of Π.
From right to left: Assume that L is a nontrivial elementary loop of Π. From the
deﬁnition of an elementary loop, it follows that any proper subset L of L that is a
nontrivial loop of Π is outbound in L for Π. That is, there is a rule (3) in Π such
that (7), (8), and (9) hold, so that L is a GS-elementary loop of Π.

For a nondisjunctive program Π and a set X of atoms, a loop L of ΠX is a
GS-elementary loop of ΠX iﬀ L is a nontrivial elementary loop of ΠX . Thus, an
active elementary loop of Π, according to Gebser and Schaub (2005), is a nontrivial
elementary loop of ΠX that is unfounded by Π w.r.t. X. Hence, any active elementary
loop L of Π is an elementarily unfounded set for Π w.r.t. X, while the converse does
not hold in general if L is a singleton.
In fact, there are a few diﬀerences between Deﬁnition 1 and our deﬁnition of
an elementary loop. First, our deﬁnition of an elementary loop does not a priori
assume that its atoms form a loop. Rather, the fact that an elementary loop is a
loop follows from its deﬁnition in view of Proposition 1. Second, the two deﬁnitions
do not agree on trivial loops: A trivial loop is an elementary loop, but not a
GS-elementary loop. This originates from the diﬀerence between the deﬁnition of a
loop given by Lin and Zhao (2004) and its reformulation given by Lee (2005). As
shown in the main theorem by Lee (2005), identifying a trivial loop as a loop admits
a simpler reformulation of the Lin–Zhao (2004) theorem by allowing us to view
completion formulas (Clark 1978) as a special case of loop formulas. Furthermore,
the reformulated deﬁnition of an elementary loop enables us to identify a close
relationship between maximal elementary loops (elementarily unfounded sets) and
minimal nonempty unfounded sets.
Importantly, trivial loops allow us to extend the notion of an elementary loop
to disjunctive programs without producing counterintuitive results. For instance,

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

964

M. Gebser et al.

consider the following disjunctive program:
p; q←r
p; r←q
q ; r←p.

(10)

The nontrivial loops of this program are {p, q}, {p, r}, {q, r}, and {p, q, r}, but not the
singletons {p}, {q}, and {r}. If we were to extend GS-elementary loops to disjunctive
programs, a natural extension would say that {p, q, r} is a GS-elementary loop since
{p, q}, {p, r}, and {q, r} are “outbound” in {p, q, r}. But note that {p, q, r} is unfounded
w.r.t. {p, q, r}; moreover, every singleton is also unfounded w.r.t {p, q, r}. This is in
contrast with Proposition 5, according to which all nonempty proper subsets of an
elementary loop should be externally supported. The next section shows that such
an anomaly does not arise with our deﬁnition of an elementary loop that is extended
to disjunctive programs.

3 Disjunctive programs
After providing the relevant background on disjunctive programs, this section
generalizes the notions of an elementary loop and an elementarily unfounded set
to disjunctive programs. We also provide the proofs of the generalizations of the
statements given in the previous section; such generalized results also apply to the
class of nondisjunctive programs as a fragment of disjunctive programs. Furthermore,
we show that in contrast to nondisjunctive programs, recognizing an elementary loop
is intractable in the case of arbitrary disjunctive programs, but stays tractable under
a certain syntactic condition.
3.1 Background
A disjunctive rule is an expression of the form
a1 ; . . . ; ak ← ak+1 , . . . , al , not al+1 , . . . , not am , not not am+1 , . . . , not not an ,

(11)

where n > m > l > k > 0 and a1 , . . . , an are propositional atoms. A disjunctive
program is a ﬁnite set of disjunctive rules. Note that any program with nested
expressions can be turned into an equivalent program whose rules have the
form (11) (Lifschitz et al. 1999).
We will identify a disjunctive rule (11) with the propositional formula
ak+1 ∧ · · · ∧ al ∧ ¬al+1 ∧ · · · ∧ ¬am ∧ ¬¬am+1 ∧ · · · ∧ ¬¬an → a1 ∨ · · · ∨ ak
and will often write (11) as
A ← B, F ,

(12)

where A is a1 , . . . , ak , B is ak+1 , . . . , al , and F is
not al+1 , . . . , not am , not not am+1 , . . . , not not an .
We will sometimes identify A and B with their corresponding sets of atoms.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

965

The reduct ΠX of a disjunctive program Π w.r.t. a set X of atoms is obtained
from Π by deleting each rule (12) such that X |= F, and replacing each remaining
rule (12) with A ← B. A set X of atoms is a stable model, also called an answer set,
of Π if X is minimal among the sets of atoms that satisfy ΠX .
The deﬁnition of a (positive) dependency graph is extended to a disjunctive
program Π in the straightforward way: the vertices of the graph are the atoms
occurring in Π, and its edges go from the elements of A to the elements of B for all
rules (12) of Π. With this extended deﬁnition of a dependency graph, the deﬁnition
of a loop for a nondisjunctive program is straightforwardly extended to a disjunctive
program.
For any set Y of atoms, the external support formula of Y for a disjunctive
program Π, denoted by ES Π (Y ), is the disjunction of conjunctions

¬a
B∧F ∧
a∈A\Y

for all rules (12) of Π such that A∩Y = ∅ and B ∩Y = ∅. When Π is a nondisjunctive
program, this deﬁnition reduces to the deﬁnition of ES Π (Y ) for nondisjunctive
programs given earlier. As before, we say that Y is externally supported by Π w.r.t.
a set X of atoms if X |= ES Π (Y ); Y is unfounded Π w.r.t. X if X |= ES Π (Y ).
The notion of LF Π (Y ) and the term (conjunctive) loop formula similarly apply to
formulas (4) when Π is a disjunctive program.
As shown by Lee (2005), Theorem 1 remains correct after replacing “nondisjunctive program” in its statement with “disjunctive program.”
Theoremd 1 (Lee 2005)
For any disjunctive program Π and any set X of atoms that occur in Π, if X is a
model of Π, then the following conditions are equivalent:9
(a)
(b)
(b )
(c)

X
X
X
X

is a stable model of Π;
satisﬁes LF Π (Y ) for all nonempty sets Y of atoms that occur in Π;
contains no nonempty unfounded sets for Π w.r.t. X;
satisﬁes LF Π (Y ) for all loops Y of Π.

For instance, the loop formulas of the seven loops of the program in (10) are:
p → (r ∧ ¬q) ∨ (q ∧ ¬r)
q → (r ∧ ¬p) ∨ (p ∧ ¬r)
r → (q ∧ ¬p) ∨ (p ∧ ¬q)
p∧q →r
p∧r →q
q∧r →p
p∧q∧r →⊥ .

(13)

∅ is the only model of (13) and is the only stable model of (10) in accordance with
the equivalence between (a) and (c) in Theoremd 1.
9

Superscript

d

indicates that the statement is a generalization to disjunctive programs.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

966

M. Gebser et al.
3.2 Elementary loops of disjunctive programs

In this section we generalize the deﬁnition of an elementary loop to disjunctive
programs.
A loop of a disjunctive program can be deﬁned without referring to a dependency
graph, as in Proposition 1.
Propositiond 1
For any disjunctive program Π and any nonempty set X of atoms that occur in Π,
X is a loop of Π iﬀ for every nonempty proper subset Y of X there is a rule (12)
in Π such that A ∩ Y = ∅ and B ∩ (X \ Y ) = ∅.
Proof. From left to right: Assume that X is a loop of Π. If X is a singleton, then
it is clear. If X is not a singleton, then take any nonempty proper subset Y of X.
Since both Y and X \ Y are nonempty, there is a path from some atom in Y to
some atom in X \ Y in the dependency graph of Π such that all vertices in the path
belong to X. This implies that there is an edge from an atom in Y to an atom in
X \ Y , i.e., A ∩ Y = ∅ and B ∩ (X \ Y ) = ∅ for some rule (12) in Π.
From right to left: Assume that X is not a loop of Π. Then the subgraph of the
dependency graph of Π induced by X is not strongly connected. Consequently, there
is a nonempty proper subset Y of X such that no edge connects an atom in Y to
an atom in X \ Y . This implies that there is no rule (12) in Π such that A ∩ Y = ∅
and B ∩ (X \ Y ) = ∅.

For any set X of atoms and any subset Y of X, we say that Y is outbound in X
for a disjunctive program Π if there is a rule (12) in Π such that
•
•
•
•

A ∩ Y = ∅,
B ∩ (X \ Y ) = ∅,
A ∩ (X \ Y ) = ∅, and
B ∩ Y = ∅.

As with nondisjunctive programs, for any nonempty set X of atoms that occur in Π,
we say that X is an elementary loop of Π if all nonempty proper subsets of X
are outbound in X for Π. Clearly, every singleton whose atom occurs in Π is an
elementary loop of Π, and every elementary loop of Π is a loop of Π. The deﬁnition
of an elementary loop of a disjunctive program is stronger than the alternative
characterization of a loop provided in Propositiond 1: It requires that the rule (12)
satisfy two additional conditions, A ∩ (X \ Y ) = ∅ and B ∩ Y = ∅.
In order to illustrate the deﬁnition of an elementary loop of a disjunctive program,
consider the loop {p, q, r} of the program in (10). The loop is not an elementary loop
because, for instance, {p} is not outbound in {p, q, r}: Though the ﬁrst two rules (12)
in (10) are such that A ∩ {p} = ∅, B ∩ {q, r} = ∅, and B ∩ {p} = ∅, we also have that
A ∩ {q, r} = ∅ for each of them. Similarly, {q} and {r} are not outbound in {p, q, r}.
On the other hand, the remaining loops of the program, {p}, {q}, {r}, {p, q}, {p, r},
and {q, r}, are elementary loops.
With the extended deﬁnitions given above, Propositions 2, 3, 4, and Theorem 1 (d)
remain correct after replacing “nondisjunctive program” in their statements with

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

967

“disjunctive program.” In the following, we present the proofs for these
generalizations.
Propositiond 2
For any disjunctive program Π and any sets X, Y , Z of atoms such that Z ⊆ Y ⊆ X,
if Z is not outbound in Y for Π and X |= ES Π (Z), then X |= ES Π (Y ).
Proof. Assume that Z is not outbound in Y for Π and that X |= ES Π (Z). From
the latter, it follows that there is a rule (12) in Π such that
A ∩ Z = ∅ ,

(14)

B∩Z =∅ ,

(15)

X |= B, F ,

(16)

X ∩ (A \ Z) = ∅ .

(17)

A ∩ Y = ∅ .

(18)

X ∩ (A \ Y ) = ∅

(19)

and
From (14), since Z ⊆ Y ,
From (17), since Z ⊆ Y ⊆ X,

and
Y ∩ (A \ Z) = ∅ ,
where the latter is equivalent to
A ∩ (Y \ Z) = ∅ .

(20)

Since Z is not outbound in Y for Π, from (14), (15), and (20), it follows that
B ∩ (Y \ Z) = ∅ ,
which, in combination with (15), gives us that
B∩Y =∅ .
Finally, from (16), (18), (19), and (21), we conclude that X |= ES Π (Y ).

(21)


Propositiond 3
For any disjunctive program Π and any nonempty set X of atoms that occur in Π,
X is an elementary loop of Π iﬀ all proper subsets of X that are elementary loops
of Π are outbound in X for Π.
Proof.

From left to right is clear.

From right to left: Assume that X is not an elementary loop of Π. Then there is
a nonempty proper subset Y of X that is not outbound in X for Π. If Y is an
elementary loop of Π, it is clear. Otherwise, there is a nonempty proper subset Z

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

968

M. Gebser et al.

of Y that is not outbound in Y for Π. For the sake of contradiction, assume that
Z is outbound in X for Π, i.e., there is a rule (12) in Π such that
A ∩ Z = ∅ ,

(22)

B ∩ (X \ Z) = ∅ ,

(23)

A ∩ (X \ Z) = ∅ ,

(24)

B∩Z =∅ .

(25)

and
From (22) and (24), since Z ⊆ Y ⊆ X,
A ∩ Y = ∅ ,

(26)

A ∩ (X \ Y ) = ∅ ,

(27)

A ∩ (Y \ Z) = ∅ .

(28)

and
Since Z is not outbound in Y for Π, from (22), (25), and (28), it follows that
B ∩ (Y \ Z) = ∅ ,
which, in combination with (23) and (25), gives us that
B∩Y =∅

(29)

B ∩ (X \ Y ) = ∅ .

(30)

and
However, (26), (27), (29), and (30) together contradict that Y is not outbound in X
for Π, from which we conclude that Z is not outbound in X for Π. We have thus
shown that every nonempty proper subset of X that is not outbound in X for Π
and not an elementary loop of Π contains in turn a nonempty proper subset that is
not outbound in X for Π. Since X is ﬁnite, there is some (not necessarily unique)
minimal nonempty proper subset of X that is not outbound in X for Π, and such a
subset must be an elementary loop of Π.

Propositiond 4
For any disjunctive program Π and any nonempty set Y of atoms that occur in Π,
there is an elementary loop Z of Π such that Z is a subset of Y and LF Π (Z) entails
LF Π (Y ).
Proof. If Y is an elementary loop of Π, it is clear. Otherwise, by Propositiond 3,
some proper subset Z of Y is an elementary loop of Π that is not outbound in Y

for Π. Take any set X of atoms such that X |= LF Π (Z). If Y ⊆ X, then X |= a∈Y a

and X |= LF Π (Y ). If Y ⊆ X, X |= a∈Z a, and X |= ES Π (Z), and, by Propositiond 2,
we conclude that X |= ES Π (Y ) and X |= LF Π (Y ).


Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

969

Theoremd 1 (d )
The following condition is equivalent to each of conditions (a)–(c) in Theoremd 1:
(d) X satisﬁes LF Π (Y ) for all elementary loops Y of Π.
Proof. We show the equivalence between (b) and (d). From (b) to (d) is clear, and
from (d) to (b) follows immediately from Propositiond 4.

For instance, for the program in (10), the loop formula of non-elementary loop
{p, q, r} (the last one in (13)) can be disregarded in view of Theoremd 1 (d).
3.3 Elementarily unfounded sets for disjunctive programs
Let Π be a disjunctive program. For any sets X, Y of atoms, by ΠX,Y we denote
the set of all rules (12) of Π such that X |= B, F and X ∩ (A \ Y ) = ∅. That is,
the program ΠX,Y contains all rules of Π that can provide supports for Y w.r.t. X.
If Y = X, we also denote ΠX,Y by ΠX . When Π is a nondisjunctive program, this
deﬁnition reduces to the deﬁnition of ΠX for nondisjunctive programs given earlier.
Furthermore, when Π is nondisjunctive and Y is not a singleton, then Y is an
elementary loop of ΠX,Y iﬀ Y is an elementary loop of ΠX .
We extend the deﬁnition of an elementarily unfounded set to disjunctive programs
by replacing “ΠX ” with “ΠX,Y ”: for a disjunctive program Π and a set X of atoms,
we say that a set Y of atoms that occur in Π is elementarily unfounded by Π w.r.t. X
if Y is
• an elementary loop of ΠX,Y that is unfounded by Π w.r.t. X, or
• a singleton that is unfounded by Π w.r.t. X.
It is clear from the deﬁnition that every elementarily unfounded set for Π w.r.t. X
is an elementary loop of Π and that it is also unfounded by Π w.r.t. X.
For instance, let Π be the program (10). The program Π{p,q,r},{p,q} consists of the
ﬁrst rule in (10), so that {p, q} is not an elementary loop of Π{p,q,r},{p,q} . On the other
hand, Π{p,q},{p,q} consists of the last two rules in (10), and {p, q} is an elementary loop
of Π{p,q},{p,q} . Since {p, q} is also unfounded by Π w.r.t. {p, q}, it is an elementarily
unfounded set for Π w.r.t. {p, q}.
Proposition 5, Corollary 1, and Theorem 2 remain correct after replacing “nondisjunctive program” in their statements with “disjunctive program,” and “ΠX ” with
“ΠX,Y .”
Propositiond 5
For any disjunctive program Π, any set X of atoms, and any elementary loop Y of
ΠX,Y , X satisﬁes ES Π (Z) for all nonempty proper subsets Z of Y .
Proof. From the fact that Y is an elementary loop of ΠX,Y , it follows that any
nonempty proper subset Z of Y is outbound in Y for ΠX,Y . If Y is not a singleton,
this implies that Y is a subset of X and that, for each nonempty proper subset Z
of Y , there is a rule (12) in Π such that
A ∩ Z = ∅ ,

(31)

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

970

M. Gebser et al.

A ∩ (Y \ Z) = ∅ ,

(32)

B∩Z =∅ ,

(33)

X |= B, F ,

(34)

X ∩ (A \ Y ) = ∅ .

(35)

and
From (32) and (35), it follows that
X ∩ (A \ Z) = ∅ .
Finally, from (31), (33), (34), and (36), we conclude that X |= ES Π (Z).

(36)


Corollaryd 1
For any disjunctive program Π, any set X of atoms, and any elementarily unfounded
set Y for Π w.r.t. X, X does not satisfy ES Π (Y ), but satisﬁes ES Π (Z) for all
nonempty proper subsets Z of Y .
Proof. From the deﬁnition of an elementarily unfounded set, X |= ES Π (Y ), and,
by Propositiond 5, X |= ES Π (Z) for all nonempty proper subsets Z of Y .


Theoremd 2
For any disjunctive program Π and any sets X, Y of atoms, Y is an elementarily
unfounded set for Π w.r.t. X iﬀ Y is minimal among the nonempty sets of atoms
occurring in Π that are unfounded by Π w.r.t. X.
Proof.

From left to right follows immediately from Corollaryd 1.

From right to left: Assume that Y is minimal among the nonempty unfounded
sets for Π w.r.t. X whose atoms occur in Π. If Y is a singleton, it is elementarily
unfounded by Π w.r.t. X. Otherwise, if Y ⊆ X, there is an atom a ∈ (Y \ X), and
one can check that (Y \ {a}) is also unfounded by Π w.r.t. X, which contradicts that
Y is a minimal nonempty unfounded set for Π w.r.t. X. Hence, from the minimality
assumption on Y , it follows that Y is a subset of X. It also holds that X |= ES Π (Z)
for every nonempty proper subset Z of Y , so that there is a rule (12) in Π such that
A ∩ Z = ∅ ,

(37)

B∩Z =∅ ,

(38)

X |= B, F ,

(39)

X ∩ (A \ Z) = ∅ .

(40)

A ∩ (Y \ Z) = ∅

(41)

and
From (40), since Z ⊆ Y ⊆ X,

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

971

X ∩ (A \ Y ) = ∅ .

(42)

and
Since Y is unfounded by Π w.r.t. X, from (37), (39), and (42), it follows that
B ∩ Y = ∅ ,
which, in combination with (38), gives us that
B ∩ (Y \ Z) = ∅ .

(43)

In view of (39) and (42), we have that the rule (12) is contained in ΠX,Y . From (37),
(38), (41), and (43), we further conclude that Z is outbound in Y for ΠX,Y .
Consequently, Y is an elementary loop of ΠX,Y and elementarily unfounded by Π
w.r.t. X.

Theorem 1 (e) and (e ) can now be extended to disjunctive programs as follows.
Theoremd 1 (e )
The following conditions are equivalent to each of conditions (a)–(c) in Theoremd 1:
(e) X satisﬁes LF Π (Y ) for every set Y of atoms such that Y is
— maximal among all sets Z of atoms that are elementary loops of ΠX,Z , or
— a singleton whose atom occurs in Π;
(e ) X contains no elementarily unfounded sets for Π w.r.t. X.
Proof. We ﬁrst show the equivalence between (b ) and (e ): from (b ) to (e ) is
clear, and from (e ) to (b ) follows immediately from Theoremd 2. Moreover, the
equivalence between (e ) and (e) holds in view of Propositiond 5, which tells us that
an elementarily unfounded set Y for Π w.r.t. X cannot be a proper subset of any
set Z of atoms that is an elementary loop of ΠX,Z .


3.4 Recognizing elementary loops of disjunctive programs
Although deciding whether a given set of atoms is an elementary loop of a
nondisjunctive program can be done eﬃciently, it turns out that the corresponding
problem in the case of arbitrary disjunctive programs is intractable.
Theorem 4
For any disjunctive program Π and any set Y of atoms, deciding whether Y is an
elementary loop of Π is coNP-complete.
Proof. Containment in coNP is clear, since it is easy to check that a given nonempty
proper subset of Y is not outbound in Y for Π.
For coNP-hardness, we reduce the coNP-hard problem of deciding whether a ﬁnite
set X of atoms is “unfounded-free” for a disjunctive program Π (Leone et al. 1997),
i.e., X contains no nonempty unfounded sets for Π w.r.t. X. Using a new atom e
that does not occur in Π or X, we construct a program Π as follows: for every
rule (12) of ΠX , include a rule A ← e, B, F in Π , and, for every a ∈ X ∪ {e}, include
a rule e ← a in Π . Given the rules of the latter type, it is clear that any proper

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

972

M. Gebser et al.

subset Z of Y = X ∪ {e} that is not outbound in Y for Π cannot contain e. For
every rule (12) of Π such that A = {e}, since e ∈ B, we then have that
B ∩ (Y \ Z) = ∅ .
Hence, if a nonempty proper subset Z of Y is not outbound in Y for Π , for every
rule (12) of Π such that A = {e}, at least one of the following conditions holds:
A∩Z =∅ ,

(44)

A ∩ (Y \ Z) = ∅ ,

(45)

B ∩ Z = ∅ .

(46)

A ∩ (X \ Z) = ∅ .

(47)

or
Since e ∈
/ A, (45) implies that
We have thus shown that (44), (46), or (47) holds for every rule (12) of Π such that
A = {e}, and, similarly, for every rule (12) of ΠX . Furthermore, we have that
X |= B, F

(48)

for every rule (12) of Π \ ΠX . Consequently, (44), (46), (47), or (48) holds for every
rule (12) of Π, which shows that Z is unfounded by Π w.r.t. X. Conversely, if a
nonempty subset Z of X is unfounded by Π w.r.t. X, the fact that (44), (46), or (47)
holds for every rule (12) of ΠX implies that every rule (12) of Π satisﬁes (44), (45),
or (46), so that Z is not outbound in Y for Π . Consequently, we conclude that X
is unfounded-free for Π iﬀ Y = X ∪ {e} is an elementary loop of Π .

However, for the class of disjunctive programs called “Head-Cycle-Free (HCF)”
(Ben-Eliyahu and Dechter 1994), deciding whether a set of atoms is an elementary
loop is tractable. We say that a disjunctive program Π is HCF if |A ∩ Y | 6 1 for
every rule (12) of Π and every loop Y of Π.
The deﬁnition of an elementary subgraph for a nondisjunctive program can be
extended to disjunctive programs by modifying the equation for EC i+1
Π as follows:
EC i+1
Π (X) = {(a, b) | there is a rule (12) in Π such that A ∩ X = {a},
b ∈ B ∩ X, and all atoms in B ∩ X belong to the
same strongly connected component in (X, EC iΠ (X))} .
With this extended deﬁnition of an elementary subgraph, Theorem 3 remains correct
after replacing “nondisjunctive program” in its statement with “HCF program.”
In the next section, we introduce “Head-Elementary-loop-Free (HEF)” programs,
and show that Theorem 3 can be further generalized to such programs.
4 Head-elementary-loop-free (HEF) programs
In general, computing stable models of a disjunctive program is harder than
computing stable models of a nondisjunctive program (Eiter and Gottlob 1995).
On the other hand, HCF programs are “easy” disjunctive programs that can be

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

973

turned into equivalent nondisjunctive programs in polynomial time (Ben-Eliyahu
and Dechter 1994). This property plays an important role in the computation of
stable models of disjunctive programs, and is used by answer set solvers claspd,
cmodels, and dlv.
By referring to elementary loops in place of loops in the deﬁnition of an HCF
program, we deﬁne a class of programs that is more general than HCF programs: we
say that a disjunctive program Π is Head-Elementary-loop-Free (HEF) if |A∩Y | 6 1
for every rule (12) of Π and every elementary loop Y of Π. Since every elementary
loop is also a loop, it is clear that every HCF program is an HEF program as
well. However, not all HEF programs are HCF. For example, consider the following
program Π2 :
p←r
q←r
r ← p, q
p; q← .
This program has six loops: {p}, {q}, {r}, {p, r}, {q, r}, and {p, q, r}. Since the head
of the last rule contains two atoms from the loop {p, q, r}, Π2 is not HCF. On the
other hand, Π2 is HEF since {p, q, r} is not an elementary loop of Π2 : its subsets
{p, r} and {q, r} are not outbound in {p, q, r} for Π2 .
Let us write rule (12) in the following form:
a1 ; . . . ; ak ← B, F .

(49)

Gelfond et al. (1991) deﬁned a mapping from a disjunctive program Π to a
nondisjunctive program Πsh , the shifted variant of Π, by replacing each rule (49)
with k > 1 in Π by k new rules:
ai ← B, F, not a1 , . . . , not ai−1 , not ai+1 , . . . , not ak .

(50)

They showed that every stable model of Πsh is also a stable model of Π. Although
the converse does not hold in general, Ben-Eliyahu and Dechter (1994) showed that
the converse holds if Π is HCF. We below extend this result to HEF programs.
The following proposition compares the elementary loops of Π with the elementary
loops of Πsh .
Proposition 7
For any disjunctive program Π, if X is an elementary loop of Π, then X is an
elementary loop of Πsh .
Proof. Assume that X is an elementary loop of Π. Then every nonempty proper
subset Y of X is outbound in X for Π, so that there is a rule (49) in Π such that
{a1 , . . . , ak } ∩ Y = ∅ ,

(51)

B ∩ (X \ Y ) = ∅ ,

(52)

{a1 , . . . , ak } ∩ (X \ Y ) = ∅ ,
and
B∩Y =∅ .

(53)

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

974

M. Gebser et al.

For some ai ∈ {a1 , . . . , ak } ∩ Y , (51) implies that some rule (50) in Πsh satisﬁes
{ai } ∩ Y = ∅
and
{ai } ∩ (X \ Y ) = ∅ .
Together with (52) and (53), this means that Y is outbound in X for Πsh .
Consequently, X is an elementary loop of Πsh .

The converse of Proposition 7 does not hold even if Π is HEF. For example,
consider the following HEF program Π3 :
p; q←r
r←p
r←q .
Set {p, q, r} is not an elementary loop of Π3 since, for instance, {p} is not outbound
in {p, q, r} for Π3 . On the other hand, {p, q, r} is an elementary loop of (Π3 )sh :
p ← r, not q
q ← r, not p
r←p
r←q .

(54)

However, the following proposition shows that there is a certain subset of Πsh
whose elementary loops are also elementary loops of Π.
Proposition 8
For any disjunctive program Π, any set X of atoms, and any subset Y of X, if Y is
an elementary loop of (Πsh )X , then Y is an elementary loop of Π.
Proof. Assume that Y is an elementary loop of (Πsh )X , and not an elementary
loop of Π for the sake of contradiction. Consider any rule (49) in Π, and any proper
subset Z of Y . Since Y is not an elementary loop of Π, at least one of the following
conditions holds:
{a1 , . . . , ak } ∩ Z = ∅ ,
{a1 , . . . , ak } ∩ (Y \ Z) = ∅ ,
(55)
B ∩ Z = ∅ , or
B ∩ (Y \ Z) = ∅ .
We will show that any rule (50) in (Πsh )X obtained from (49) by shifting satisﬁes
at least one of the following conditions:
{ai } ∩ Z = ∅ ,
{ai } ∩ (Y \ Z) = ∅ ,
B ∩ Z = ∅ , or
B ∩ (Y \ Z) = ∅ .
This contradicts the assumption that Y is an elementary loop of (Πsh )X .
Case 1 : The ﬁrst, the third, or the fourth condition of (55) holds. The claim trivially
follows.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

975

Case 2: {a1 , . . . , ak } ∩ (Y \ Z) = ∅. Recall that
X |= B, F, not a1 , . . . , not ai−1 , not ai+1 , not ak ,
by (Πsh )X construction. It follows that |{a1 , . . . , ak } ∩ X| 6 1. From the fact that
Y ⊆ X and Z ⊂ Y we conclude that |{a1 , . . . , ak } ∩ Y | 6 1 and {a1 , . . . , ak } ∩ Z = ∅,
so that {ai } ∩ Z = ∅.

For instance, for X = {p, q, r} and (Π3 )sh , we have that [(Π3 )sh ]X consists of the
last two rules in (54). Only the singletons {p}, {q}, and {r} are elementary loops
of [(Π3 )sh ]X , and clearly they are elementary loops of Π3 as well.
We are now ready to show the equivalence between an HEF program and its
shifted variant.
Theorem 5
For any HEF program Π and any set X of atoms, X is a stable model of Π iﬀ X
is a stable model of Πsh .
Proof. From left to right: Assume that X is a stable model of Π. Then X is a
model of Πsh such that all its atoms occur in Πsh and also in [Πsh ]X . Furthermore,
by Theoremd 1 (d), we have that X satisﬁes LF Π (Y ) for all elementary loops Y
of Π. By Proposition 8, the elementary loops of Π include all elementary loops Y
of [Πsh ]X that are contained in X, and, since Π is HEF, it holds that ES Πsh (Y )
and ES Π (Y ), as well as LF Πsh (Y ) and LF Π (Y ), are equivalent to each other. This
implies that X satisﬁes ES Πsh (Y ) for all elementary loops Y of [Πsh ]X that are
contained in X, so that X contains no elementarily unfounded sets for Πsh w.r.t. X.
By Theoremd 1 (e ), we conclude that X is a stable model of Πsh .
From right to left: Assume that X is a stable model of Πsh . Then X is a model
of Π such that all its atoms occur in Π. Furthermore, by Theoremd 1 (d), we have
that X satisﬁes LF Πsh (Y ) for all elementary loops Y of Πsh . By Proposition 7,
the elementary loops of Πsh include all elementary loops Y of Π, and, since Π
is HEF, it holds that ES Π (Y ) and ES Πsh (Y ), as well as LF Π (Y ) and LF Πsh (Y ),
are equivalent to each other. This implies that X satisﬁes LF Π (Y ) for all elementary loops Y of Π. By Theoremd 1 (d), we conclude that X is a stable model
of Π.

For instance, one can check that both Π2 and (Π2 )sh have {p} and {q} as
their stable models. It follows that HEF programs are not more expressive than
nondisjunctive programs, so that one can regard the use of disjunctive rules in
such programs as a syntactic variant. Furthermore, the problem of deciding whether
a model is stable for an HEF program is tractable, just as the same problem
for a nondisjunctive program. (In the case of arbitrary disjunctive programs, it is
coNP-complete (Eiter and Gottlob 1995).) These properties were known for HCF
programs, and here we extended them to HEF programs.
In Section 3.4, we deﬁned the notion of an elementary subgraph of a set X of
atoms for a disjunctive program Π. Theorem 3 still applies to HEF programs.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

976

M. Gebser et al.

Theoremhef 3
For any HEF program Π and any nonempty set X of atoms that occur in Π, X is an
elementary loop of Π iﬀ the elementary subgraph of X for Π is strongly connected.
Proof. From left to right: Assume that X is an elementary loop of Π, and, for the
sake of contradiction, the elementary subgraph of X for Π is not strongly connected.
Then there is a strongly connected component in (X, EC Π (X)) whose atoms Y are
not reached from any atom in X \ Y . Clearly Y is a nonempty proper subset of X,
and so is X \ Y . Furthermore, for every rule (12) in Π, at least one of the following
conditions holds:
|A ∩ X| > 1 ,

(56)

A ∩ (X \ Y ) = ∅ ,

(57)

B∩Y =∅ ,

(58)

B ∩ (X \ Y ) = ∅ .

(59)

or
However, (56) contradicts the assumption that Π is HEF. Also the fact that at least
one of the conditions (57), (58), and (59) holds contradicts the assumption that
X \ Y is outbound in X for Π.
From right to left: Assume that the elementary subgraph of X for Π is strongly
connected. For every nonempty proper subset Y of X, there is a minimum integer i >
0 such that EC iΠ (X) does not contain any edge from an atom in Y to an atom
in X \ Y , but EC i+1
Π (X) contains such an edge. Thus, some rule (12) in Π satisﬁes
|A ∩ X| = 1 ,

(60)

A ∩ Y = ∅ ,

(61)

B ∩ (X \ Y ) = ∅ ,
and
B∩Y =∅ .
From (60) and (61), since Y ⊆ X,
A ∩ (X \ Y ) = ∅ .
This shows that Y is outbound in X for Π. We conclude that X is an elementary
loop of Π.

Although many properties of HCF programs still apply to HEF programs (e.g.,
equivalence between an HEF program and its shifted variant), the computational
complexities of recognizing them are diﬀerent. While an HCF program can be
recognized in polynomial time (by computing the strongly connected components of
its dependency graph), Fassetti and Palopoli (2010) showed that deciding whether a
disjunctive program is HEF is coNP-complete.10 Theorem 4 established a similar
10

The problem was left open in Gebser et al. (2007), one of our conference papers that this paper
extends.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

977

complexity gap by showing that elementary loops are hard to verify in the case of
arbitrary disjunctive programs, while for loops it remains a question of reachability.
Such elevated complexities may appear daunting, but the semantic similarities
between HEF and HCF programs still exhibit that the syntactic concept of
reachability merely gives a rough approximation of properties rendering disjunctive
programs more diﬃcult than nondisjunctive ones. As noted by Fassetti and Palopoli
(2010), identifying subclasses of (not necessarily HCF) disjunctive programs for
which verifying the HEF property is tractable may be an interesting line of future
research.

5 HEF programs and inherent tightness
When we add more rules to a program, a stable model of the original program
remains to be a stable model of the extended program if it satisﬁes the new rules.
Proposition 9
For any disjunctive program Π and any model X of Π, X is a stable model of Π iﬀ
there is a subset Π of Π such that X is a stable model of Π .
Proof.

From left to right is clear.

From right to left: Assume that X is not a stable model of Π. Then some proper
subset Y of X is a model of ΠX . For each subset Π of Π, we have that (Π )X ⊆ ΠX ,
so that Y is a model of (Π )X and X is not a stable model of Π .

In view of Theoremd 1, Proposition 9 tells us that, provided that X is a model
of Π, in order to verify that X is a stable model of Π, it is suﬃcient to identify a
subset Π of Π such that X is a stable model of Π . Of course, one can trivially take
Π itself as the subset Π , but there are nontrivial subsets that deserve attention. In
fact, if Π is nondisjunctive, it is known that the subset Π can be further restricted
to a “tight” program (Fages 1994; Erdem and Lifschitz 2003)—the result known as
“inherently tight” (Lin and Zhao 2003) or “weakly tight” (You et al. 2003) program.
In the following, we simplify these notions and show that these can be extended to
HEF programs.
Recall that a loop of Π is called trivial if it consists of a single atom such that the
dependency graph of Π does not contain an edge from the atom to itself. In other
words, a loop {a} of Π is trivial if there is no rule (12) in Π such that a ∈ A ∩ B.
Deﬁnition 2 (Lee 2005)
A disjunctive program Π is called tight if every loop of Π is trivial.
As deﬁned previously (Apt et al. 1988; Baral and Gelfond 1994; Inoue and
Sakama 1998; Lee 2005), we call a set X of atoms supported by a disjunctive
program Π if, for every a ∈ X, there is a rule (12) in ΠX such that A ∩ X = {a}. Note
that Deﬁnition 2 and the notion of support also apply to nondisjunctive programs
as a special case.
The property of inherent tightness, introduced by Lin and Zhao (2003) for the case
of nondisjunctive programs, can now be reformulated and generalized as follows.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

978

M. Gebser et al.

Deﬁnition 3
A disjunctive program Π is called inherently tight on a set X of atoms if there is a
subset Π of Π such that Π is tight and X is supported by Π .
In the case of nondisjunctive programs, this reformulation of inherent tightness is similar to “well-supportedness” (Fages 1994). Furthermore, weak tightness,
introduced by You et al. (2003), is closely related to the notion of inherent tightness.
For nondisjunctive programs, it is known that their stable models can be
characterized in terms of inherent tightness.
Proposition 10 (Fages 1994; Lin and Zhao 2003; You et al. 2003)
For any nondisjunctive program Π and any model X of Π, X is a stable model
of Π iﬀ Π is inherently tight on X.
One may wonder whether Proposition 10 can be extended to disjunctive programs
as well, given that Deﬁnition 3 readily applies to them. However, only one direction
of Proposition 10 holds in the case of arbitrary disjunctive programs.
Proposition 11
For any disjunctive program Π and any model X of Π, if Π is inherently tight on X,
then X is a stable model of Π.
Proof. Assume that Π is inherently tight on X. Then there is a subset Π of Π
such that Π is tight and X is supported by Π . By Proposition 2 given by Lee and
Lifschitz (2003), X is a stable model of Π , and, by Proposition 9, X is a stable
model of Π.

To see that the converse of Proposition 11 does not hold, consider Π as follows:
p←q
q←p
p; q← .
Set {p, q} is a stable model of Π. On the other hand, since any tight subset Π
of Π must exclude the ﬁrst or the second rule, it follows that {p, q} is not supported
by Π . But this means that Π is not inherently tight on {p, q}. It is also worthwhile
to note that {p, q} is an elementary loop of Π, so that Π is not HEF (and not HCF).
Indeed, the following theorem tells us that Proposition 10 can be extended to HEF
programs.
Theorem 6
For any HEF program Π and any model X of Π, X is a stable model of Π iﬀ Π is
inherently tight on X.
Proof. From left to right: Assume that X is a stable model of Π. By Propositiond 3
(and the fact that every atom of X occurs in ΠX ), any nonempty subset Y of X
contains some elementary loop Z of ΠX that is not outbound in Y for ΠX .11 That
is, every rule (12) of ΠX satisﬁes at least one of the following conditions:
A∩Z =∅ ,
11

If Y is an elementary loop of ΠX , take Z = Y .

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

979

B ∩ (Y \ Z) = ∅ ,

(62)

A ∩ (Y \ Z) = ∅ ,

(63)

or
B ∩ Z = ∅ .
From (63), since Y ⊆ X,
A ∩ (X \ Z) = ∅ .
On the other hand, since X is a stable model of Π and Z is a nonempty subset of
X, by Theoremd 1 (b), there is a rule (12) in ΠX such that
A ∩ Z = ∅ ,

(64)

A ∩ (X \ Z) = ∅ ,

(65)

B∩Z =∅ ,

(66)

and
so that (62) must hold, which, in combination with (66), gives us that
B∩Y =∅ .

(67)

Furthermore, since ΠX ⊆ Π, we have that Z is an elementary loop of Π. Given that
Π is HEF, from (64) and (65), we conclude that
A ∩ X = {a}

(68)

for some a ∈ Z, where a ∈ Y also holds because Z ⊆ Y . We have thus shown
that, for any nonempty subset Y of X, there is a rule (12) in ΠX such that (67) and
(68) for a ∈ Y hold. Starting from X 0 = ∅ and Π0 = ∅, when, for 1 6 i 6 |X|, we let
• Y = (X \ X i−1 ),
• Πi is obtained from Πi−1 by adding some rule (12) in ΠX such that (67) and
(68) for a ∈ Y hold, and
• X i = X i−1 ∪ {a},
then X is supported by Π = Π|X| . Furthermore, since rule (12) in (Πi \ Πi−1 ) satisﬁes
A ∩ X i−1 = ∅ and B ⊆ X i−1 for every 1 6 i 6 |X|, Π is tight by construction, which
shows that Π is inherently tight on X.
From right to left follows immediately from Proposition 11.



Since every HCF program is HEF, Theorem 6 also applies to HCF programs.
We demonstrated that by turning to the notion of an elementary loop in place
of a loop, we obtain generalizations of results known for loops, such as Theorem 5.
This brings our attention to the following question. As a tight program can be
characterized in terms of loops, can the notion of a tight program be generalized by
referring to elementary loops instead? To answer it, let us ﬁrst modify Deﬁnition 2
in the following way.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

980

M. Gebser et al.

Deﬁnition 4
A disjunctive program Π is called e-tight if every elementary loop of Π is trivial.
Since every elementary loop is a loop, it is clear that a tight program is e-tight
as well. But is the class of e-tight programs more general than the class of tight
programs? One reason why this is an interesting question to consider is because, if
so, it would lead to a generalization of Fages’ (1994) theorem, which would yield a
more general class of programs for which the stable model semantics coincides with
the completion semantics. However, it turns out that e-tight programs are not more
general than tight programs.
Proposition 12
For any disjunctive program Π, Π is e-tight iﬀ Π is tight.
Proof. From left to right: Assume that Π is not tight. Then there is a minimal
nontrivial loop X of Π, and the subgraph of the dependency graph of Π induced
by X yields a simple directed cycle. That is, for any nonempty proper subset Y
of X, there is a rule (12) in Π such that A ∩ X = {a}, B ∩ X = {b} for atoms a ∈ Y ,
b ∈ X \ Y . This shows that Y is outbound in X for Π, so that X is a nontrivial
elementary loop of Π.
From right to left is clear.



This result also tells us that the notion of an inherently tight program does not
become more general by referring to elementary loops, i.e., by replacing the part “Π
is tight” in the statement of Deﬁnition 3 with “Π is e-tight.”

6 HEF programs and stability checking
For a disjunctive program, the problem of deciding whether a given model is
stable is coNP-complete (Eiter and Gottlob 1995). On the other hand, in view of
Theorem 5, the same problem is tractable for HEF programs. In order to check the
stability of a model in polynomial time, Leone et al. (1997) presented an operational
framework, which, for HCF programs, allows for deciding whether a model is
stable. Given a disjunctive program Π and sets X, Y of atoms, they deﬁned a
0
1
ω
(Y ), RΠ,X
(Y ), . . . , which converges to a limit RΠ,X
(Y ), in the following
sequence RΠ,X
way:
0
(Y ) = Y and
• RΠ,X
i+1
i
(Y ) is obtained by removing every atom a from RΠ,X
(Y ) such that some
• RΠ,X
i
(Y ) = ∅.12
rule (12) in ΠX satisﬁes A ∩ (X ∪ {a}) = {a} and B ∩ RΠ,X

The disjunctive rules considered in (Leone et al. 1997) do not admit double
negations in rule bodies, but its (dis)use merely aﬀects conditions like X |= B, F
(or X |= B, F) determining ΠX , while it is inconsequential otherwise. Hence, the
12

If Y is a subset of X, then the condition “A ∩ (X ∪ {a}) = {a}” can be replaced with “A ∩ X = {a}”
ω (Y ).
without altering RΠ,X

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

981

following results remain valid for disjunctive programs whose rules are of the
form (12).
Proposition 13 (Leone et al. 1997, Lemma 6.4)
For any disjunctive program Π and any sets X, Y of atoms that occur in Π, all
ω
(Y ).
subsets of Y that are unfounded by Π w.r.t. X are contained in RΠ,X
Proposition 14 (Leone et al. 1997, Proposition 6.5)
For any disjunctive program Π and any set X of atoms that occur in Π, if
ω
(X) = ∅, then X contains no nonempty unfounded sets for Π w.r.t. X.
RΠ,X
Proposition 15 (Leone et al. 1997, Theorem 6.9)
For any HCF program Π and any set X of atoms that occur in Π, X contains no
ω
(X) = ∅.
nonempty unfounded sets for Π w.r.t. X iﬀ RΠ,X
For a model X of Π, in view of Theoremd 1 (b ), Proposition 14 tells us that X is
ω
(X) = ∅. As stated in Proposition 15, the converse also
a stable model of Π if RΠ,X
holds if Π is HCF. We below extend this result to HEF programs.
Proposition 16
For any HEF program Π, any set X of atoms, and any subset Y of X whose atoms
ω
ω
(Y ) = ∅, then RΠ,X
(Y ) contains an elementary loop Z of Π that
occur in Π, if RΠ,X
is unfounded by Π w.r.t. X.
ω
Proof. Assume that RΠ,X
(Y ) = ∅. Then, for every rule (12) of ΠX , at least one of
the following conditions holds:

|A ∩ X| > 1 ,

(69)

ω
A ∩ RΠ,X
(Y ) = ∅ ,

(70)

ω
(Y ) = ∅ .
B ∩ RΠ,X

(71)

or
ω
(Y ) contains some elementary loop Z of Π that is not
By Propositiond 3, RΠ,X
ω
outbound in RΠ,X (Y ) for Π.13 For the sake of contradiction, assume that Z is not
unfounded by Π w.r.t. X. Then there is a rule (12) in ΠX such that

A ∩ Z = ∅ ,

(72)

A ∩ (X \ Z) = ∅ ,

(73)

B∩Z =∅ .

(74)

and
From (73), since

ω
RΠ,X
(Y

) ⊆ X,
ω
A ∩ (RΠ,X
(Y ) \ Z) = ∅ ,

13

ω (Y ) is an elementary loop of Π, take Z = R ω (Y ).
If RΠ,X
Π,X

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

982

M. Gebser et al.

which, in combination with (72), (74), and the fact that Z is not outbound in
ω
(Y ) for Π, gives us that
RΠ,X
ω
(Y ) \ Z) = ∅ .
B ∩ (RΠ,X

(75)

From (74) and (75) we conclude that (71) does not hold. Furthermore, since
ω
(Y ), (72) implies that (70) does not hold. Hence, (69) must hold, which, in
Z ⊆ RΠ,X
combination with (73), gives us that
|A ∩ Z| > 1 .
But since Z is an elementary loop of Π, this contradicts that Π is HEF.



We are now ready to generalize Proposition 15 to HEF programs.
Theorem 7
For any HEF program Π and any set X of atoms that occur in Π, X contains no
ω
nonempty unfounded sets for Π w.r.t. X iﬀ RΠ,X
(X) = ∅.
Proof.

From left to right follows immediately from Proposition 16.

From right to left follows immediately from Proposition 14.



Regarding the models of HEF programs, we derive the following corollary.
Corollary 2
For any HEF program Π and any set X of atoms that occur in Π, X is a stable
ω
(X) = ∅.
model of Π iﬀ X is a model of Π such that RΠ,X
Proof.
Both directions follow immediately from Theoremd 1 (b ) and
Theorem 7.

For instance, reconsider Π2 from Section 4, which is HEF, but not HCF. Hence,
ω
(X) = X
Corollary 2 applies, but Proposition 15 does not apply. Indeed, since RΠ
2 ,X
for (nonstable) model X = {p, q, r} of Π2 , Corollary 2 allows us to conclude that
X is not a stable model of Π2 . On the other hand, for model {p} of Π2 , we have
ω
({p}) = ∅, which implies that {p} is a stable model of Π2 .
RΠ
2 ,{p}
In Section 3.3, we deﬁned the notion of an elementarily unfounded set and showed
that it coincides with a minimal nonempty unfounded set. Thus stability checking
can be cast into the problem of ensuring the absence of elementarily unfounded sets.
Since every elementarily unfounded set is a loop, it is clearly contained in a maximal
loop, which allows us to modularize the consideration of (elementarily) unfounded
sets. The idea of using maximal loops for partitioning a program and conﬁning
stability checking to subprograms was already exploited by Leone et al. (1997) and
Koch et al. (2003). In fact, for a disjunctive program Π and a set X of atoms, Leone
et al. (1997) showed how stability can be checked separately for maximal loops of Π,
and Koch et al. (2003) developed this idea further by considering maximal loops
ω (X) . We below describe a notion called “bounding
of the smaller program ΠX,RΠ,X
loops,” which go beyond such maximal loops.
For a disjunctive program Π and a set X of atoms, we say that a subset Y of X
is a bounding loop of Π w.r.t. X if Y is maximal among all subsets Z of X such that

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

983

ω
(Z) = Z. Note that there are two crucial diﬀerences
Z is a loop of ΠX,Z and RΠ,X
between bounding loops and elementarily unfounded sets. First, a bounding loop Y
of Π w.r.t. X is not necessarily an elementary loop of ΠX,Y . Next, it does not need
to be unfounded by Π w.r.t. X. To see this, observe that X = {p, q, r} is a bounding
loop of Π2 w.r.t. X that is not (elementarily) unfounded by Π2 w.r.t. X. Furthermore,
one can check that {p, r} and {q, r} are (elementarily) unfounded by Π2 w.r.t. X, and
thus Propositiond 5 tells us that X is not an elementary loop of (Π2 )X,X .
The following two propositions describe properties of bounding loops that are
similar to those of maximal loops, as used in Leone et al. (1997) and Koch et al.
(2003).

Proposition 17
For any disjunctive program Π and any set X of atoms, all bounding loops of Π
w.r.t. X are mutually disjoint.
Proof. Let Y1 , Y2 be subsets of X such that Y1 is a loop of ΠX,Y1 , Y2 is a loop of
ω
ω
(Y1 ) = Y1 , and RΠ,X
(Y2 ) = Y2 . If Y1 ∩Y2 = ∅, the fact that ΠX,Y1 ∪ΠX,Y2 ⊆
ΠX,Y2 , RΠ,X
ω
(Y1 ) = Y1
ΠX,Y1 ∪Y2 implies that Y1 ∪ Y2 is a loop of ΠX,Y1 ∪Y2 . Furthermore, since RΠ,X
ω
and RΠ,X (Y2 ) = Y2 , for any rule (12) of ΠX such that A ∩ (Y1 ∪ Y2 ) = ∅ and
B ∩ (Y1 ∪ Y2 ) = ∅, we have that |A ∩ X| > 1, from which we conclude that
ω
(Y1 ∪ Y2 ) = Y1 ∪ Y2 . Since bounding loops of Π w.r.t. X are maximal among
RΠ,X
ω
(Z) = Z, this shows that
all subsets Z of X such that Z is a loop of ΠX,Z and RΠ,X
they must be mutually disjoint.

Proposition 18
For any disjunctive program Π and any set X of atoms that occur in Π, every
elementarily unfounded set for Π w.r.t. X is a singleton or contained in some
bounding loop of Π w.r.t. X.
Proof. Assume that Y is an elementarily unfounded set for Π w.r.t. X that is not
a singleton. From the deﬁnition of an elementarily unfounded set, it follows that
Y is a loop of ΠX,Y and a subset of X. Since Y is also unfounded by Π w.r.t. X,
ω
(Y ) = Y . This shows that Y is contained in some
by Proposition 13, we have RΠ,X
ω
(Z) = Z.
maximal subset Z of X such that Z is a loop of ΠX,Z and RΠ,X

Propositions 17 and 18 tell us that checking the absence of elementarily unfounded
sets can be accomplished separately for bounding loops.
Proposition 19
For any disjunctive program Π and any model X of Π, X is a stable model of Π iﬀ
• X is supported by Π and
• no bounding loop of Π w.r.t. X contains a nonempty unfounded set for Π
w.r.t X.
Proof. From left to right follows immediately from Theoremd 1 (b ) (and the fact
that every atom of X occurs in Π).
From right to left: Assume that X is not a stable model of Π but supported by Π.
Then, by Theoremd 1 (e ), X contains some elementarily unfounded set Y for Π

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

984

M. Gebser et al.

w.r.t. X. If Y is not a singleton, by Proposition 18, Y is contained in some bounding
loop of Π w.r.t. X. Otherwise, if Y is a singleton, the assumption that X is supported
by Π implies that there is a rule (12) in ΠX,Y such that A ∩ X = Y , so that Y is a
loop of ΠX,Y . Since Y is unfounded by Π w.r.t. X, by Proposition 13, we also have
ω
(Y ) = Y . This shows that Y is contained in some maximal subset Z of X
that RΠ,X
ω
(Z) = Z.
such that Z is a loop of ΠX,Z and RΠ,X

As it is easy to check that X is supported by Π, Proposition 19 tells us that the
investigation of bounding loops constitutes the hard part of stability checking. But
this is not due to the hardness of identifying them. In fact, the following method
can be used to compute all bounding loops Z of Π w.r.t. X in polynomial time:
(1) Let Y = X.
ω
ω
(Y ).
(Note that Z = RΠ,X
(Z).)
(2) Let Z = RΠ,X
(3) If Z is a loop of ΠX,Z , then mark Z as a bounding loop of Π w.r.t. X. Otherwise,
proceed with Step 2 for every maximal loop Y of ΠX,Z that is contained
in Z.
The soundness of this approach is straightforward, given that the operator R is
ω
ω
(Z) ⊆ RΠ,X
(Y ) if Z ⊆ Y (used in Step 2), and likewise that
monotone, i.e., RΠ,X
ΠX,Y ⊆ ΠX,Z if Y ⊆ Z (used in Step 3).
For illustration, consider the following program Π4 :
p←r
q←r
r ← p, q

s←p
s←t
t ← s, u

p; q←u
s; t←q
r ; u←t

u; v←.

For X = {p, q, r, s, t, u}, it holds that (Π4 )X,X = Π4 and also that X is a loop of Π4 .
ω
(X) = {p, q, r, s, t} = X, so that X is not a bounding loop of Π4
However, Y = RΠ
4 ,X
w.r.t. X. On the other hand, Y is not a loop of (Π4 )X,Y , which does not include the
last two rules where u occurs in the head. Rather, Z = {p, q, r} and Z  = {s, t} are
the maximal loops of (Π4 )X,Y that are contained in Y . In view of the rules in the
ω
(Z  ) = ∅, which shows that no subset of Z  is a bounding loop
second column, RΠ
4 ,X
ω
(Z) = Z, and Z is also a loop of
of Π4 w.r.t. X. For Z = {p, q, r}, we obtain RΠ
4 ,X
(Π4 )X,Z (because of the rules in the ﬁrst column). That is, Z is the single bounding
loop of Π4 w.r.t. X.
Let us compare this outcome with the ones of previous methods for modularizing
stability checking. Since the approach by Leone et al. (1997) considers maximal loops
of the original program and X = {p, q, r, s, t, u} is a (maximal) loop of Π4 , it cannot
be used to decompose X, and the only applicable simpliﬁcation is to remove u by
ω
(X) = {p, q, r, s, t}. The approach by Koch et al. (2003)
means of R, that is, Y = RΠ
4 ,X
ω (X) , which, for (Π4 )X,Y , gives Z = {p, q, r} and
considers the maximal loops of ΠX,RΠ,X

Z = {s, t}. As described by Koch et al. (2003), since the subprograms (Π4 )X,Z and
(Π4 )X,Z  are not HCF, these are not simpliﬁed any further and used to separately
check for a nonempty unfounded subset of Z or Z  , respectively. Unlike this, the
notion of a bounding loop allowed us to eliminate all subsets of Z  as potential
nonempty unfounded sets.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

985

Turning back to HEF programs, from Proposition 16, we derive the following
proposition for a subprogram ΠX,Y associated with a bounding loop Y of Π
w.r.t. X.
Proposition 20
For any disjunctive program Π, any set X of atoms, and any bounding loop Y of Π
w.r.t. X, if ΠX,Y is HEF, then Y contains a nonempty unfounded set for Π w.r.t. X.
Proof. Assume that ΠX,Y is HEF. From the deﬁnition of a bounding loop, it follows
ω
ω
(Y ) = R(Π
(Y ) ⊆ X. By
that all atoms of Y occur in ΠX,Y and that Y = RΠ,X
X,Y ),X
ω
Proposition 16 we conclude that R(ΠX,Y ),X (Y ) contains an elementary loop Z of ΠX,Y
that is unfounded by ΠX,Y w.r.t. X. From the deﬁnition of ΠX,Y and since Z is
contained in Y , we conclude that Z is also unfounded by Π w.r.t. X.

Proposition 20 tells us that the existence of a bounding loop Y of Π w.r.t. X
whose associated subprogram ΠX,Y is HEF is already suﬃcient to conclude that X
is not a stable model of Π. Reconsidering the bounding loop Z = {p, q, r} of Π4
w.r.t. X = {p, q, r, s, t, u}, we have that (Π4 )X,Z , consisting of the rules in the ﬁrst
column along with the disjunctive rule containing p and q in the head, is HEF
(neither {p, q} nor {p, q, r} is an elementary loop of (Π4 )X,Z ). Thus, X is not a stable
model of Π4 . Indeed, Z contains two (elementarily) unfounded sets for Π4 w.r.t. X:
{p, r} and {q, r}.
7 Conclusion
The notion of an elementary loop and its properties provide useful insights into
the concept of a loop and the relationship between nondisjunctive programs and
disjunctive programs. By turning to the notion of an elementary loop in place of a
loop, we could strengthen the theorem by Lin and Zhao (2004), its generalization to
disjunctive programs (Lee and Lifschitz 2003), and the main theorem (for programs
in canonical form) by Lee (2005). The semantic (e.g., Theoremd 2) and complexitytheoretic (e.g., Theorem 4) properties of elementary loops indicate their close
relationship to unfounded sets. Compared with loops, elementary loops provide a
deeper understanding of the internal structure of unfounded sets. In fact, we have
shown that loop formulas of non-elementary loops are unnecessary for checking the
stability of a model. It is an interesting open question whether this result can be
used to improve computation performed by answer set solvers that calculate loop
formulas, such as assat, claspd, and cmodels.
A method to identify an elementarily unfounded set for an HEF program was
presented by Gebser et al. (2007).14 An orthogonal approach is implemented in
claspd: it greedily adds atoms a to an unfounded set Y if Y ∪ {a} stays unfounded
and has a shorter loop formula than Y . However, the potential of unfounded
set “optimization” has not been studied in depth so far, and the theoretical
foundations laid here may be useful for future investigations in this direction.
Regarding nondisjunctive programs, elementary loops can be distinct from loops
of programs called “binary” (Janhunen 2006). Moreover, modularity aspects of
14

It is omitted in this paper for brevity.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

986

M. Gebser et al.

disjunctive stable models (Janhunen et al. 2009), which are closely related to loop
formulas (Lemma 5.4 from Janhunen et al. (2009)), can be reﬁned by referring to
elementary loops in place of loops. Lifting elementary loops to ﬁrst-order programs,
as already done for loops (Chen et al. 2006; Lee and Meng 2008), may also be a
direction to explore.
The notion of an HEF program is a strict generalization of the notion of an
HCF program. On the one hand, nice properties of HCF programs still apply
to HEF programs. In particular, their inherent tightness on stable models grants
the soundness of shifting head atoms into the body as well as the possibility
of performing stability checks in polynomial time. This however implies that a
disjunctive program encoding an instance of a ΣP2 -hard problem is unlikely to be
HEF. On the other hand, recognizing elementary loops and verifying the HEF
property are both intractable in the case of arbitrary disjunctive programs, but
tractable for nondisjunctive and HCF programs. This parallels the complexity of
stability checking (Eiter and Gottlob 1995), and it also tells us that the inherent
complexities of computational tasks dealing with elementary loops tightly correlate
to the fragment of disjunctive programs under consideration. As the latter does not
apply to recognizing loops or verifying the HCF property, the notion of an HEF
program more precisely renders what makes arbitrary disjunctive programs more
diﬃcult than nondisjunctive programs. Whether this admits (syntactic) characterizations of yet unknown subclasses of disjunctive programs for which verifying the
HEF property is tractable is an interesting open question.
Acknowledgements
We are grateful to Selim Erdoğan, Tomi Janhunen, Dan Lessin, Vladimir Lifschitz,
Torsten Schaub, Jicheng Zhao, and the anonymous referees of Gebser et al. (2006,
2007) and this paper for their useful comments. Martin Gebser was partially
supported by the German Research Foundation under Grant SCHA 550/8-1.
Joohyung Lee was partially supported by the National Science Foundation under
Grant IIS-0916116 and by the Oﬃce of the Director of National Intelligence (ODNI),
Intelligence Advanced Research Projects Activity (IARPA), through US army. Yuliya
Lierler was partially supported by the National Science Foundation under Grant
IIS-0712113 and by a 2010 Computing Innovation Fellowship.
References
Apt, K., Blair, H. and Walker, A. 1988. Towards a theory of declarative knowledge.
In Foundations of Deductive Databases and Logic Programming, J. Minker, Ed. Morgan
Kaufmann, Massachusetts, USA, 89–148.
Baral, C. and Gelfond, M. 1994. Logic programming and knowledge representation. Journal
of Logic Programming 19, 20, 73–148.
Ben-Eliyahu, R. and Dechter, R. 1994. Propositional semantics for disjunctive logic
programs. Annals of Mathematics and Artiﬁcial Intelligence 12, 53–87.
Chen, Y., Lin, F., Wang, Y. and Zhang, M. 2006. First-order loop formulas for normal logic
programs. In Proceedings of the Tenth International Conference on Principles of Knowledge
Representation and Reasoning (KR’06), P. Doherty, J. Mylopoulos and C. Welty, Eds.
AAAI Press, Menlo Park, CA, USA, 298–307.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

On elementary loops of logic programs

987

Clark, K. 1978. Negation as failure. In Logic and Data Bases, H. Gallaire and J. Minker,
Eds. Plenum Press, New York, 293–322.
Drescher, C., Gebser, M., Grote, T., Kaufmann, B., König, A., Ostrowski, M. and
Schaub, T. 2008. Conﬂict-driven disjunctive answer set solving. In Proceedings of the
Eleventh International Conference on Principles of Knowledge Representation and Reasoning
(KR’08), G. Brewka and J. Lang, Eds. AAAI Press, Menlo Park, CA, USA, 422–432.
Eiter, T. and Fink, M. 2003. Uniform equivalence of logic programs under the stable model
semantics. In Proceedings of the Nineteenth International Conference on Logic Programming
(ICLP’03), C. Palamidessi, Ed. Springer-Verlag, New York, USA, 224–238.
Eiter, T. and Gottlob, G. 1995. On the computational cost of disjunctive logic programming:
Propositional case. Annals of Mathematics and Artiﬁcial Intelligence 15 , 3–4, 289–323.
Erdem, E. and Lifschitz, V. 2003. Tight logic programs. Theory and Practice of Logic
Programming 3, 499–518.
Fages, F. 1994. Consistency of Clark’s completion and existence of stable models. Journal of
Methods of Logic in Computer Science 1, 51–60.
Fassetti, F. and Palopoli, L. 2010. On the complexity of identifying head elementary set free
programs. Theory and Practice of Logic Programming 10, 1, 113–123.
Ferraris, P., Lee, J. and Lifschitz, V. 2007. A new perspective on stable models.
In Proceedings of the Twentieth International Joint Conference on Artiﬁcial Intelligence
(IJCAI’07), AAAI Press, 372–379.
Ferraris, P., Lee, J. and Lifschitz, V. 2011. Stable models and circumscription. Artiﬁcial
Intelligence 175, 236–263.
Gebser, M., Lee, J. and Lierler, Y. 2006. Elementary sets for logic programs. In Proceedings
of the Twenty-ﬁrst AAAI Conference on Artiﬁcial Intelligence (AAAI’06), AAAI Press,
Menlo Park, CA, USA.
Gebser, M., Lee, J. and Lierler, Y. 2007. Head-elementary-set-free logic programs. In
Procedings of the Ninth International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR’07), Springer, 149–161.
Gebser, M. and Schaub, T. 2005. Loops: Relevant or redundant? In Proceedings of the Eighth
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’05),
Springer, 53–65.
Gebser, M., Schaub, T., Tompits, H. and Woltran, S. 2008. Alternative characterizations for
program equivalence under answer-set semantics based on unfounded sets. In Proceedings
of the Fifth International Symposium on Foundations of Information and Knowledge Systems
(FoIKS’08), S. Hartmann and G. Kern-Isberner, Eds. Springer-Verlag, New York, USA,
24–41.
Gelfond, M., Lifschitz, V., Przymusińska, H. and Truszczyński, M. 1991. Disjunctive
defaults. In Proceedings of the Second International Conference on Principles of Knowledge
Representation and Reasoning (KR’91), J. Allen, R. Fikes and E. Sandewall, Eds. Morgan
Kaufmann, 230–237.
Giunchiglia, E., Lierler, Y. and Maratea, M. 2004. SAT-based answer set programming.
In Proceedings of the Nineteenth AAAI Conference on Artiﬁcial Intelligence (AAAI), AAAI
Press/The MIT Press, 61–66.
Inoue, K. and Sakama, C. 1998. Negation as failure in the head. Journal of Logic
Programming 35, 39–78.
Janhunen, T. 2006. Some (in)translatability results for normal logic programs and
propositional theories. Journal of Applied Non-Classical Logics 16 , 1–2, 35–86.
Janhunen, T., Niemelä, I., Seipel, D., Simons, P. and You, J.-H. 2006. Unfolding partiality
and disjunctions in stable model semantics. ACM Transactions on Computational Logic 7 , 1,
1–37.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

988

M. Gebser et al.

Janhunen, T., Oikarinen, E., Tompits, H. and Woltran, S. 2009. Modularity aspects of
disjunctive stable models. Journal of Artiﬁcial Intelligence Research 35, 813–857.
Koch, C., Leone, N. and Pfeifer, G. 2003. Enhancing disjunctive logic programming systems
by SAT checkers. Artiﬁcial Intelligence 151, 177–212.
Lee, J. 2004. Nondeﬁnite vs. deﬁnite causal theories. In Proceedings of the Seventh International
Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04), Springer,
141–153.
Lee, J. 2005. A model-theoretic counterpart of loop formulas. In Proceedings of the
Nineteenth International Joint Conference on Artiﬁcial Intelligence (IJCAI’05). Professional
Book Center, Denver CO, USA, 503–508.
Lee, J. and Lifschitz, V. 2003. Loop formulas for disjunctive logic programs. In Proceedings
of Nineteenth International Conference on Logic Programming (ICLP’03). 451–465.
Lee, J. and Lin, F. 2006. Loop formulas for circumscription. Artiﬁcial Intelligence 170 , 2,
160–185.
Lee, J. and Meng, Y. 2008. On loop formulas with variables. In Proceedings of the Eleventh
International Conference on Knowledge Representation and Reasoning (KR’08), AAAI Press,
444–453.
Lee, J. and Meng, Y. 2009. On reductive semantics of aggregates in answer set
programming. In Procedings of the Tenth International Conference on Logic Programming
and Nonmonotonic Reasoning (LPNMR’09), Springer, 182–195.
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S. and Scarcello, F.
2006. The dlv system for knowledge representation and reasoning. ACM Transactions on
Computational Logic 7 , 3, 499–562.
Leone, N., Rullo, P. and Scarcello, F. 1997. Disjunctive stable models: Unfounded sets,
ﬁxpoint semantics, and computation. Information and Computation 135, 2, 69–112.
Lierler, Y. 2005. cmodels: SAT-based disjunctive answer set solver. In Proceedings of
the Eighth International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR’05), Springer, 447–452.
Lifschitz, V., Tang, L. R. and Turner, H. 1999. Nested expressions in logic programs. Annals
of Mathematics and Artiﬁcial Intelligence 25, 369–389.
Lifschitz, V. and Razborov, A. 2006. Why are there so many loop formulas? ACM
Transactions on Computational Logic 7 , 2, 261–268.
Lin, F. and Zhao, J. 2003. On tight logic programs and yet another translation from normal
logic programs to propositional logic. In Proceedings of the Eighteenth International Joint
Conference on Artiﬁcial Intelligence (IJCAI’03), Morgan Kaufmann, 853–858.
Lin, F. and Zhao, Y. 2004. ASSAT: Computing answer sets of a logic program by SAT
solvers. Artiﬁcial Intelligence 157, 115–137.
Liu, L. and Truszczynski, M. 2006. Properties and applications of programs with monotone
and convex constraints. Journal of Artiﬁcial Intelligence Research 27, 299–334.
Saccá, D. and Zaniolo, C. 1990. Stable models and non-determinism in logic programs with
negation. In Proceedings of the Ninth ACM Symposium on Principles of Database Systems
(PODS), ACM Press, 205–217.
You, J.-H. and Liu, G. 2008. Loop formulas for logic programs with arbitrary constraint
atoms. In Proceedings of the Twenty-Third AAAI Conference on Artiﬁcial Intelligence
(AAAI’08), AAAI Press, 584–589.
You, J.-H., Yuan, L.-Y. and Zhang, M. 2003. On the equivalence between answer sets
and models of completion for nested logic programs. In Proceedings of the Eighteenth
International Joint Conference on Artiﬁcial Intelligence (IJCAI’03), Morgan Kaufmann,
859–866.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:30:38, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068411000019

Representing the Language of the Causal
Calculator in Answer Set Programming
Michael Casolary and Joohyung Lee
School of Computing, Informatics and Decision Systems Engineering
Arizona State University, Tempe, AZ, USA
Michael.Casolary@asu.edu, joolee@asu.edu

Abstract
Action language C+, a formalism based on nonmonotonic causal logic, was designed for describing properties of actions. The definite fragment of C+ was implemented in system the Causal
Calculator (CCalc), based on a reduction of nonmonotonic causal logic to propositional logic.
On the other hand, in this paper, we represent the language of CCalc in answer set programming (ASP), by translating nonmonotonic causal logic into formulas under the stable model
semantics. We design a standard library which describes the constructs of the input language
of CCalc in terms of ASP, allowing a simple modular method to represent CCalc input programs in the language of ASP. Using the combination of system f2lp and answer set solvers, our
prototype implementation of this approach, which we call Cplus2ASP, achieves functionality
close to CCalc while taking advantage of answer set solvers to yield efficient computation that
is orders of magnitude faster than CCalc on several benchmark examples.
1998 ACM Subject Classification I.2.4 Knowledge Representation Formalisms and Methods
Keywords and phrases answer set programming, nonmonotonic causal logic, action languages
Digital Object Identifier 10.4230/LIPIcs.ICLP.2011.51

1

Introduction

Action languages are formal models of parts of natural language that are used for describing
properties of actions. Among them, language C+ [9] and its predecessor C [10] are based
on nonmonotonic causal logic. The definite fragment of nonmonotonic causal logic can be
turned into propositional logic by the literal completion method, which resulted in an efficient way to compute C+ using satisfiability (SAT) solvers. The Causal Calculator (CCalc)
is an implementation of this idea. Version 1 of CCalc was created by McCain [16], accepting C as its input language; Version 2 is an enhancement described in [11], which accepts
C+ as its input language. Language C+ is significantly more enhanced than C in several
ways, such as being able to represent multi-valued formulas, defined fluents, additive fluents,
rigid constants and defeasible causal laws. Although CCalc was not aimed at large scale
applications, it has been applied to several challenging commonsense reasoning problems,
including problems of nontrivial size [1], to provide a group of robots with high-level reasoning [4], to give executable specifications of norm-governed computational societies [3], and
to automate the analysis of business processes under authorization constraints [2].
An alternative way to compute C+ is to turn it into answer set programs and to use
existing answer set solvers. This can be achieved by first turning multi-valued causal logic
into Boolean-valued causal logic as described in [11] and then turning the latter into answer
set programs as described in [16, 5, 15]. In fact, a system called Coala (Compiler for action
languages) was implemented based on this idea [8]. The system turns a fragment of language
© Michael Casolary and Joohyung Lee;
licensed under Creative Commons License NC-ND
Technical Communications of the 27th International Conference on Logic Programming (ICLP’11).
Editors: John P. Gallagher, Michael Gelfond; pp. 51–61
Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

52

Representing the Language of the Causal Calculator in ASP

C+ into the input language of Gringo1 , but that fragment lacks several important features
of C+ mentioned above, which are available in CCalc.
In this paper, we provide a way to encode CCalc input language in answer set programming, and present a prototype implementation called Cplus2ASP based on this idea. Our
approach differs from that of Coala in a few ways. First, Cplus2ASP can handle multivalued constants, which Coala does not allow. Second, we turn the language of CCalc
into formulas under the stable model semantics [7], and use system f2lp2 (“f ormulas to
logic programs”) [14] to turn them into the input language of ASP solvers. This allows
users to write the same complex formulas as in the input language of CCalc. Third, we
design a standard library that defines the constructs of the CCalc input language in terms
of the language of Gringo. Using the standard library and reusing the existing software
f2lp and Clingo3 allowed a simple design of Cplus2ASP that achieves functionality close
to CCalc. Also thanks to the efficiency of answer set solvers, our experiments show that
Cplus2ASP is orders of magnitude faster than CCalc in several benchmark examples.
The paper is organized as follows. Section 2 provides preliminaries, and Section 3 shows
how to encode the language of CCalc in ASP, and presents the prototype implementation
Cplus2ASP. We compare the efficiency of Cplus2ASP against that of CCalc in Section 4.

2

Preliminaries

2.1

Nonmonotonic Causal Theories and C+

Due to lack of space, the reviews in this section are rather dense. We refer the reader to [9]
for the details. In C+, formulas are multi-valued. A (multi-valued propositional) signature
is a set σ of symbols called constants, along with a nonempty finite set Dom(c) of symbols
called the domain of c. An atom of a signature σ is an expression of the form c = v (“the value
of c is v”) where c ∈ σ and v ∈ Dom(c). A (multi-valued) formula of σ is a propositional
combination of atoms. A causal rule is an expression of the form
F ⇐G
where F and G are multi-valued propositional formulas. A causal theory is a set of causal
rules.
Language C+ is a high level notation for causal theories that was designed for describing
transition systems—directed graphs whose vertices represent states and edges are labeled
by actions that affect the states. In C+, constants are partitioned into fluent constants
and action constants. Fluent constants are further partitioned into simple and statically
determined fluents. A fluent formula is a formula where all constants occurring in it are
fluent constants. An action formula is a formula that contains at least one action constant
and no fluent constants. A static law is an expression of the form
caused F if G

(1)

where F and G are fluent formulas. An action dynamic law is an expression of the form (1)
in which F is an action formula and G is a formula. A fluent dynamic law is an expression

1
2
3

http://potassco.sourceforge.net
http://reasoning.eas.asu.edu/f2lp
Clingo is a system that combines Gringo and Clasp in a monolithic way, available from the same
link as the one in Footnote 1.

Michael Casolary and Joohyung Lee

53

of the form
caused F if G after H

(2)

where F and G are fluent formulas and H is a formula, provided that F does not contain
statically determined constants. A causal law is a static law, or an action dynamic law, or
a fluent dynamic law. An action description is a set of causal laws.
The semantics of C+ in [9] is described via a translation into causal logic. For any action
description D and any nonnegative integer m, the causal theory Dm is defined as follows.
The signature of Dm consists of the pairs i : c such that
i ∈ {0, . . . , m} and c is a fluent constant of D, or
i ∈ {0, . . . , m − 1} and c is an action constant of D.
The domain of i : c is the same as the domain of c. By i : F we denote the result of inserting
i : in front of every occurrence of every constant in a formula F , and similarly for a set of
formulas. The rules of Dm are
i:F ⇐ i:G

(3)

for every static law (1) in D and every i ∈ {0, . . . , m}, and for every action dynamic law (1)
in D and every i ∈ {0, . . . , m − 1};
i+1 : F ⇐ (i+1 : G) ∧ (i : H)

(4)

for every fluent dynamic law (2) in D and every i ∈ {0, . . . , m − 1};
0:c=v ⇐ 0:c=v

(5)

for every simple fluent constant c and every v ∈ Dom(c).
The causal models of Dm correspond to the paths of length m in the transition system
described by D.

2.2

Language of the Causal Calculator

The language of CCalc provides a convenient way of expressing C+ descriptions. It allows
us to declare sorts, objects, variables and constants, as well as to describe causal laws.
A causal law may contain variables, which are understood in terms of grounding. Such
causal laws are schemas for ground instances, as in answer set programming.
The left column of Figure 1 is a simple C+ description in the language of CCalc. The
symbol >> in the sort declaration between the names of two sorts expresses that the second
is a subsort of the first, so that every object that belongs to the second sort belongs also to
the first. Lines 1–2 declare that s_num is a subsort of num. Lines 11–13 introduce objects
of the two sorts. The integers from 0 to n − 1 belong to sort s_num; the integers from 0 to
n belong to sort num. Line 19 declares that has is an inertial fluent whose domain is num.
CCalc understands this line the same as the declaration
has

:: simpleFluent(num)

followed by the fluent dynamic law
caused has=X if has=X after has=X

where X ranges over all objects of sort num.
Similarly, Line 22 declares that buy is an
exogenous action with Boolean values. Lines 32–35 represent a simple query for finding a
path of length 3 from the initial state where has=2 to the goal state where has=4.

ICLP 2011

54

Representing the Language of the Causal Calculator in ASP

2.3

Stable Model Semantics of First-Order Formulas and System f2lp

We refer the reader to [7, 14] for the details. The stable model semantics from [7] is defined
for first-order formulas, which allow for arbitrary nesting of connectives and quantifiers as
in first-order logic. Strong negation (∼) occurs only in front of an atom. For instance,
¬ ∼p(x) → p(x)

(6)

expresses that x belongs to p by default.
System f2lp can be used to turn any “almost universal sentence” into an answer set
program so that answer set solvers can be used to compute the Herbrand stable models of
the almost universal sentence. As far as this paper is concerned, it is sufficient to know that
any sentence where every quantifier is in the scope of negation is almost universal. (6) can
be encoded in the language of f2lp as
p(X) <- not -p(X).

(In the language of f2lp, the default negation (¬) is expressed as not; the strong negation
(∼) is encoded as -, following the convention in the input language of ASP solvers. In
addition, ? and ! denote the existential and universal quantifiers, respectively; | denotes
disjunction and & denotes conjunction.) The input language of f2lp also allows aggregates
and choice rules as in the language of Gringo.
1
2

:- sorts
num >> s_num.

1
2

3

3

4

4

5

5

6

6

7

7

8

8

9

9

10

10

11
12
13

:- objects
0..n-1
:: s_num;
n
:: num.

14
15
16

19

:- constants
has :: inertialFluent(num);

12
13

16

18
19

22
23

24

25
26

27

27

28

35

29
30

31

34

exogenousAction(buy).
constant_sort(buy,boolean).
h(eql(has,K+1),V_astep+1) <h(eql(buy,true),V_astep) &
h(eql(has,K),V_astep).

28

nonexecutable buy if has=n.

30

33

inertialFluent(has).
constant_sort(has,num).

24

buy causes has=K+1 if has=K.

26

32

#domain s_num(K).

21

buy :: exogenousAction(boolean).

23

29

s_num(0..n-1).
num(n).

15

20

21

25

num(V_s_num).

11

17

20

22

sort(s_num).
#domain s_num(V_s_num).
sort_object(num,V_s_num).

14

:- variables
K
:: s_num.

17
18

sort(num).
#domain num(V_num).
sort_object(num,V_num).

31

:- query
maxstep :: 3;
0: has=2;
maxstep: has=4.

false <h(eql(buy,true),V_astep) &
h(eql(has,n),V_astep).

32
33
34
35

false <- query_label(0) &
not (h(eql(has,2),0) &
h(eql(has,4),maxstep)).

Figure 1 Simple Transition System in the Language of CCalc and in the Language of f2lp

Michael Casolary and Joohyung Lee

3

55

Representing the Language of the Causal Calculator in ASP

3.1

Translating C+ into Answer Set Programs

We consider a finite definite C+ description D of signature σ, where the heads of the rules
are either an atom or ⊥. Without losing generality, we assume that, for any constant c
in σ, Dom(c) has at least two elements. Description D can be turned into a logic program
following these steps: (i) turn D into the corresponding multi-valued causal theory Dm (as
0
explained in Section 2.1); (ii) turn Dm into a Boolean-valued causal theory Dm
; (iii) turn
0
Dm into formulas under the stable model semantics; (iv) turn the result further into a logic
program (using f2lp as explained in Section 2.3). In this section we explain Steps (ii) and
(iii).
Definite Elimination of Multi-Valued Constants
Consider the causal theory Dm
with signature σm consisting of rules of the form (3), (4) and (5). Consider all constants
c
i : c (0 ≤ i ≤ m) in σm , where c is a fluent constant of D. By σm
we denote the signature
obtained from σm by replacing every constant i : c with Boolean constants i : eql(c, v) for
all v ∈ Dom(c).
c
c
The causal theory Dm
with signature σm
is obtained from Dm by replacing each occurrence of an atom i : c = v in Dm with i : eql(c, v) = t, and adding the causal rules
i : eql(c, v 0 ) = f ⇐ i : eql(c, v) = t

(0 ≤ i ≤ m)

(7)

for all v, v 0 ∈ Dom(c) such that v 6= v 0 .
The following proposition is a simplification of Proposition 9 from [11].4
I Proposition 1. There is a 1-1 correspondence between the models of Dm and the models
c
of Dm
.
The elimination of multi-valued action constants is similar.
Turning Boolean-valued Action Descriptions into SM In [6], McCain’s translation
is modified and extended as follows. Take any set T of causal rules of the forms
A ⇐ G,

(8)

¬A ⇐ G,

(9)

⊥ ⇐ G,

(10)

where A is an atom and G is an arbitrary propositional formula. For each rule (8), take
the formula ¬¬G → A; for each rule (9), the formula ¬¬G → ∼A; for each rule (10), the
formula ¬G. Also add the following completeness constraints for all atoms A:
¬A ∧ ¬ ∼A → ⊥ .

(11)

Note that, for T , which is definite, the modified McCain translation yields a first-order
theory that is tight [7].
0
Consider Dm
which is obtained from Dm by eliminating all multi-valued constants in
favor of Boolean constants. h(i : F ) is a formula obtained from i : F by replacing every

4

Proposition 9 from [11] involves adding two kinds of rules. Vladimir Lifschitz pointed out that one
kind of rules can be dropped if the given theory is definite.

ICLP 2011

56

Representing the Language of the Causal Calculator in ASP

occurrence of i : eql(c, v) = t in it with h(eql(c, v), i) and every occurrence of i : eql(c, v) = f
with ∼h(eql(c, v), i). According to the modified McCain translation, the causal rules (3)
that represent a static law (1) are represented by formulas under the stable model semantics
as
h(i : F ) ← ¬¬h(i : G)

(12)

(i ∈ {0, . . . , m}). The translation of causal rules for an action dynamic law is similar except
that i ranges over {0, . . . , m − 1}. In the special case when h(i : F ) and h(i : G) are the
same literal, (12) can be represented using choice rules in ASP:
{h(i : F )}.

(13)

This is because (12) is strongly equivalent to h(i : F ) ∨ ¬h(i : F ), which can be abbreviated
as (13) [12]. In fact, we observe in many cases (13) can be used in place of (12).
Similarly, the modified McCain translation turns the causal rules (4) that correspond to
a fluent dynamic law (2) into


h(i+1 : F ) ← ¬¬ h(i+1 : G) ∧ h(i : H) .
In fact, we can also turn (4) into
h(i+1 : F ) ← ¬¬h(i+1 : G) ∧ h(i : H)

(14)

because the change does not affect the stable models of the resulting theory, which is tight
[7]. Similarly, certain occurrences of ¬¬ in (12) and (14) can be further dropped if removing
them does not cause the resulting theory to become non-tight.
Again in the special case when h(i+1 : F ) and h(i+1 : G) are the same literal, (14) can
be represented using choice rules as follows:
{h(i+1 : F )} ← h(i : H).

3.2

Representing Domain Descriptions in the Language of f2lp

Figure 1 shows a side-by-side comparison of an example CCalc input program and its
representation in the language of f2lp. As shown, the translation is modular. For each
sort name S that is declared in the CCalc input program, the translation introduces a fact
sort(S) and a variable VS that ranges over all objects of sort S by the line #domain S(VS ),
and relates the sort name and the objects by the fact sort_object(S, VS ). (This “meta
predicate,” together with another meta predicate constant_sort that is shown later, is
used in the standard library to associate constants with their domains.) As an example,
Lines 2–8 in the right column of Figure 1 is a representation of sort declarations in the
language of Gringo. In addition, the declaration that S1 is a supersort of S2 is represented
by S1 (VS2 ), as illustrated in Line 10.
The ASP representation of the object and variable declarations are straightforward. The
declaration that O is an object of sort S is encoded as a fact S(O). In order to declare a
user-defined variable V of sort S, we write #domain S(V ). See Lines 12–13, and Line 16
for example.
A constant declaration in the language of CCalc of the form
C :: CompositeSort(V )

Michael Casolary and Joohyung Lee

57

Figure 2 The Hierarchy of Atomic Formulas

is turned into a fact CompositeSort(C), followed by another fact constant_sort(C, V ),
which is used in the standard library. See Lines 19–23 for example.
Encoding causal laws in the language of f2lp follows the method in Section 3.1. Like
the input language of CCalc, the variables in the f2lp rules are understood as schemas for
ground terms. Lines 25–31 are example encodings of causal laws in the language of f2lp.
Since every variable is sorted, these f2lp rules are safe according to the definition of safety
in [13], and its translation into an ASP program also results in a safe logic program.
Note that Figure 1 does not contain the other causal laws (the inertial assumption for
has and the exogeneity assumption for buy). Since such causal laws and rules are frequently
used, they are described in the standard library, which we explain in the next section.

3.3

Standard Library

The standard library5 declares built-in sorts and objects, such as sort boolean and its
objects true and false; sorts step and astep and the integer objects that belong to the
sorts (0, . . . , maxstep for step and 0, . . . , maxstep − 1 for astep). More importantly, it
contains postulates specific to each kind of fluents and actions.

3.3.1

Postulates for Specific Fluents and Actions

First, we assume the presence of certain meta-variables that are used in the postulates.
For instance, V_inertialFluentAF is a meta-variable that ranges over all ground terms
of the form eql(c, v) where c is an inertialFluent and v is an object in the domain
of c as introduced in the domain description. For the domain description in Figure 1,
V_inertialFluentAF ranges over eql(has, 0), eql(has, 1), . . . , eql(has, n). Similarly, we
have other meta-variables V_fluentAF, V_simpleFluentAF, V_sdFluentAF, V_rigidAF,
V_actionAF, V_exogenousActionAF, V_attributeAF that range over ground terms of the
form eql(c, v) where c and v range over corresponding constants and values. We show later
how to prepare a program so that meta-variables range over the atoms as intended.
The inertial assumption for inertialFluents is represented by
{h(V_inertialFluentAF,V_astep+1)} <- h(V_inertialFluentAF,V_astep).

5

See http://reasoning.eas.asu.edu/cplus2asp for the complete file.

ICLP 2011

58

Representing the Language of the Causal Calculator in ASP

The exogeneity assumption (5) for simple fluents at time 0 is represented by
{h(V_simpleFluentAF,0)}.

The exogeneity assumption for exogenousAction is stated as
{h(V_exogenousActionAF,V_astep)}.

The completeness assumption (11) for fluents is represented as follows.
false <- not h(V_fluentAF,V_step) & not -h(V_fluentAF,V_step).

or equivalently as
false <- {h(V_fluentAF,V_step), -h(V_fluentAF,V_step)}0.

The definite elimination rules for multi-valued fluent constants corresponding to (7) can
be represented as
-h(eql(V_fluent,Object1),V_step) <h(eql(V_fluent,Object),V_step) & constant_object(V_fluent,Object)
& constant_object(V_fluent,Object1) & Object != Object1.

Here V_fluent is a meta-variable that ranges over all fluent constants. The predicate
constant_object is defined in terms of sort_object and constant_sort:
constant_object(V_constant,Object) <constant_sort(V_constant,V_sort) & sort_object(V_sort,Object).

(Recall that sort_object is introduced in translating sort declarations from the domain
description and constant_sort is introduced in translating constant declarations from
the domain description.)
The definite elimination rules and the completeness assumptions for action constants are
similar to those for fluent constants.

3.4

Meta-Sorts and Meta-Variables

In order to make grounding replace all meta-variables with the corresponding ground terms
as intended in the previous section, we first introduce meta-level sorts for representing the
constant hierarchy in C+. This is done in the same way as the object-level (user-defined)
sorts are introduced. For instance, the following are sort declarations for simpleFluent and
inertialFluent, and the declaration of their subsort relation.
sort(simpleFluent).
#domain simpleFluent(V_simpleFluent).
sort_object(simpleFluent,V_simpleFluent).
sort(inertialFluent).
#domain inertialFluent(V_inertialFluent).
sort_object(inertialFluent,V_inertialFluent).
simpleFluent(V_inertialFluent).

Recall that in Figure 1, the constant declarations included the fact inertialFluent(has);
the variable V_simpleFluent ranges over all simple fluent constants, including the inertial
fluent has.
Similarly, we introduce meta-level sorts for different kinds of atomic formulas depending
on the different kinds of constants. For instance, the following is a part of the declaration
for simpleFluentAF and inertialFluentAF.

Michael Casolary and Joohyung Lee

59

sort(simpleFluentAF).
#domain simpleFluentAF(V_simpleFluentAF).
sort_object(simpleFluentAF,V_simpleFluentAF).
sort(inertialFluentAF).
#domain inertialFluentAF(V_inertialFluentAF).
sort_object(inertialFluentAF,V_inertialFluentAF).
simpleFluentAF(V_inertialFluentAF).

These declarations are used to define domain predicates ConstantAFs which contain
terms of the form eql(c, v) where c is a constant of meta-level sort Constant and v is a
value in the domain of c. For instance, the following represents that inertialFluentAF
is a domain predicate that contains all ground terms of the form eql(c, v) where c is an
inertialFluent, and v is a value in the domain of c, using the meta-predicate constant_
object.
inertialFluentAF(eql(V_inertialFluent,Object)) <constant_object(V_inertialFluent,Object).

(Recall the definition of constant_object in the previous section.) The grounding process
replaces the meta-variable V_inertialFluentAF by every ground term of the form eql(c, v)
where c is a constant of meta-level sort inertialFluent and v is an element in the domain
of c, as specified by the constant_object relation. So once the user declares that c is an
inertialFluent (or one of its subsorts) in the domain description, the postulates for the
inertial assumption for c are generated by ASP grounders.

4

Implementation and Experiments

We implemented the techniques described in Section 3 in a prototype implementation, which
we call Cplus2ASP. The system achieves functionality close to CCalc by using the standard library and the combination of the existing software f2lp and Clingo. As documented
in Figure 3, the system turns the CCalc domain description into the language of f2lp, calls
f2lp to turn it into the language of Clingo, calls Clingo to find answer sets, and displays
them in CCalc-style solutions (as2transition is a post-processor that takes answer sets
and transforms them into a format of CCalc output.) Cplus2ASP is designed to be compatible with the input language of CCalc. It supports most of the basic features of CCalc,
but does not yet handle features like user-defined macros, where clauses, and shifting. The
system was written in C++, utilizing the tools flex and bison to aid in the creation of a
CCalc language grammar and syntax parser.

Figure 3 The Architecture of Cplus2ASP

ICLP 2011

60

Representing the Language of the Causal Calculator in ASP

Problem
Total
Traffic World:

0.03s

(maxstep=5)

0.17s)
22.74s

22.38s

0.36s

Scenario 2

(17.85s + 3.45s

(maxstep=3)

+ 1.08s)
6.29s

6.05s

0.24s

Scenario 3

(4.48s + 0.99s +

(maxstep=5)

0.58s)

Traffic World:

c

1.52s
(1.06s + 0.29s +

Traffic World:

b

1.55s

Scenario 1

Traffic World:

a

CCalc with zchaff
Preparationa
Solving

608.76s

558.46s

50.30s

Scenario 3-1

(415.06s

(maxstep=11)

85.45s + 57.95s)

Total
0.22s

1.42s

0.52s

59.84s

+

Cplus2ASP with Clingo
Preparationb
Solvingc
0.20s

0.02s

(0.11s + 0.09s)

(0.02s + 0.00s)

1.14s

0.28s

(0.11s + 1.03s)

(0.28s + 0.00s)

0.40s

0.12s

(0.08s + 0.32s)

(0.12s + 0.00s)

34.42s

25.42s

(0.08s + 33.34s)

(17.95s + 7.47s)

(grounding time + completion time + shifting & writing input clause time)
(Cplus2ASP processing time + Clingo grounding time)
(Clingo pre-processing time + solving time)

Figure 4 Experiments with CCalc and Cplus2ASP

We ran both CCalc and Cplus2ASP on a series of benchmark problems designed to
utilize a variety of CCalc syntactic elements and tested the speed of each program with
respect to grounding and solving. These tests included all examples from [9] along with
specific versions of the larger domains described in [1]. Figure 4 shows the performance
comparison of CCalc and Cplus2ASP on the Traffic World domain from [1] using the
same scenarios described there, plus one more that is a scaled-up version of Scenario 3.
All tests were run in a native install of Ubuntu on a machine with a 3.2 GHz Pentium 4
processor and 2 GB of RAM. Overall Cplus2ASP consistently performs significantly faster
than CCalc, producing identical solutions to those of CCalc. The preparation times that
are spent for Cplus2ASP in producing the input to Clingo are negligible, as they do not
involve grounding.

5

Conclusion

Based on the theoretical result that turns nonmonotonic causal logic into the stable model
semantics, we presented a method that represents the language of the Causal Calculator in
answer set programming, and implemented it in a prototype called Cplus2ASP. In comparison with Coala, Cplus2ASP allows the full expressivity of action language C+ using
input language syntax that is almost identical to the language of CCalc. Our ongoing work
involves making Cplus2ASP fully compatible with CCalc by implementing the remaining
features of CCalc missing in Cplus2ASP.

Acknowledgements: We are grateful to Michael Bartholomew, Vladimir Lifschitz, Yunsong Meng, Ravi Palla, and anonymous referees for their useful comments on this paper.
The authors were partially supported by the National Science Foundation under Grant IIS0916116 and by the IARPA SCIL program.

Michael Casolary and Joohyung Lee

61

References
1

2

3
4

5
6
7
8

9
10

11
12

13

14

15

16

6
7

Varol Akman, Selim Erdoğan, Joohyung Lee, Vladimir Lifschitz, and Hudson Turner. Representing the Zoo World and the Traffic World in the language of the Causal Calculator.
Artificial Intelligence, 153(1–2):105–140, 2004.
Alessandro Armando, Enrico Giunchiglia, and Serena Elisa Ponta. Formal specification
and automatic analysis of business processes under authorization constraints: an actionbased approach. In Proceedings of the 6th International Conference on Trust, Privacy and
Security in Digital Business (TrustBus’09), 2009.
Alexander Artikis, Marek Sergot, and Jeremy Pitt. Specifying norm-governed computational societies. ACM Transactions on Computational Logic, 9(1), 2009.
Ozan Caldiran, Kadir Haspalamutgil, Abdullah Ok, Can Palaz, Esra Erdem, and Volkan
Patoglu. Bridging the gap between high-level reasoning and low-level control. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR), 2009.
Paolo Ferraris. A logic program characterization of causal theories. In Proceedings of
International Joint Conference on Artificial Intelligence (IJCAI), pages 366–371, 2007.
Paolo Ferraris, Joohyung Lee, Yuliya Lierler, Paolo Lifschitz, and Fangkai Yang. Representing first-order causal theories by logic programs. TPLP, 2010. To appear.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. Stable models and circumscription.
Artificial Intelligence, 175:236–263, 2011.
Martin Gebser, Torsten Grote, and Torsten Schaub. Coala: A compiler from action languages to asp. In Proceedings of European Conference on Logics in Artificial Intelligence
(JELIA), pages 360–364, 2010.
Enrico Giunchiglia, Joohyung Lee, Vladimir Lifschitz, Norman McCain, and Hudson
Turner. Nonmonotonic causal theories. Artificial Intelligence, 153(1–2):49–104, 2004.
Enrico Giunchiglia and Vladimir Lifschitz. An action language based on causal explanation: Preliminary report. In Proceedings of National Conference on Artificial Intelligence
(AAAI), pages 623–630. AAAI Press, 1998.
Joohyung Lee. Automated Reasoning about Actions6 . PhD thesis, University of Texas at
Austin, 2005.
Joohyung Lee, Vladimir Lifschitz, and Ravi Palla. A reductive semantics for counting and
choice in answer set programming. In Proceedings of the AAAI Conference on Artificial
Intelligence (AAAI), pages 472–479, 2008.
Joohyung Lee, Vladimir Lifschitz, and Ravi Palla. Safe formulas in the general theory of
stable models (preliminary report). In Proceedings of International Conference on Logic
Programming (ICLP), pages 672–676, 2008.
Joohyung Lee and Ravi Palla. System f2lp – computing answer sets of first-order formulas. In Procedings of International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR), pages 515–521, 2009.
Vladimir Lifschitz and Fangkai Yang. Translating first-order causal theories into answer set
programming. In Proceedings of the European Conference on Logics in Artificial Intelligence
(JELIA), 2010.
Norman McCain. Causality in Commonsense Reasoning about Actions7 . PhD thesis, University of Texas at Austin, 1997.

http://peace.eas.asu.edu/joolee/papers/dissertation.pdf
ftp://ftp.cs.utexas.edu/pub/techreports/tr97-25.ps.gz

ICLP 2011

Proceedings of the Fourteenth International Conference on Principles of Knowledge Representation and Reasoning

Stable Models of Multi-Valued Formulas:
Partial versus Total Functions
Michael Bartholomew and Joohyung Lee
School of Computing, Informatics, and Decision Systems Engineering
Arizona State University, Tempe, AZ, USA
{mjbartho,joolee}@asu.edu

Abstract

and Yang 2013). For this paper, multi-valued formulas serve
as a simple but useful special case of first-order formulas to
compare different extensions of the functional stable model
semantics.
The total function based stable model semantics for multivalued formulas is defined in (Bartholomew and Lee 2012).
Here, following (Cabalar 2011; Balduccini 2013), we define
the partial function based stable model semantics, which we
call the CB-stable model semantics. This is essentially a
generalization of the semantics from (Balduccini 2013). We
show that multi-valued formulas under these functional stable model semantics can be viewed in terms of propositional
formulas under the stable model semantics, with a slight difference to each other. This finding reveals the close relationship between the functional stable model semantics and their
relationships to the propositional stable model semantics, and
allows us to easily relate the mathematical results established
for propositional formulas, such as the theorem on strong
equivalence (Lifschitz, Pearce, and Valverde 2001) and the
splitting theorem (Ferraris et al. 2009), to multi-valued formulas. In (Lee, Lifschitz, and Yang 2013), action language
BC is defined by a translation to multi-valued formulas and
by a translation to logic programs. The equivalence between
the two translations follows from our finding.
Given that both versions of the functional stable model
semantics can be reduced to the propositional stable model semantics, one may wonder about the relationship between the
two versions of the functional stable model semantics. Interestingly, we show that the functional stable model semantics
that is based on partial functions can be fully embedded into
the one that is based on total functions.
These results provide a way to implement the functional
stable model semantics using existing ASP solvers. We
present system MVSM based on this idea. The system is essentially a preprocessor to F 2 LP (Lee and Palla 2009), which
in turn is a preprocessor to the ASP grounder GRINGO.

Recent extensions of the stable model semantics that allow
intensional functions—functions that can be specified by logic
programs using other functions and predicates—can be divided into two groups. One group defines a stable model in
terms of minimality on the values of partial functions, and
the other defines it in terms of uniqueness on the values of
total functions. We show that, in the context of multi-valued
formulas, these two different approaches can be reduced to
each other, and further, each of them can be viewed in terms
of propositional formulas under the stable model semantics.
Based on these results, we present a prototype implementation
of different versions of functional stable model semantics by
using existing answer set solvers.

Introduction
The original stable model semantics (Gelfond and Lifschitz
1988) and many extensions have been restricted to Herbrand
models, where the role of functions is quite limited. Recently a few extensions of the stable model semantics were
proposed to allow intensional functions—functions that can
be specified by logic programs using other functions and
predicates. Despite the different forms in which these semantics were defined, they can be essentially divided into
two groups. One group defines a stable model in terms of
“minimality on the values of partial functions” (Cabalar 2011;
Balduccini 2013) and the other defines it in terms of “uniqueness on the values of total functions” (Lifschitz 2012;
Bartholomew and Lee 2012). While it is known that they
coincide on some class of formulas (Bartholomew and Lee
2013), it does not look obvious if they can be reduced to each
other in full generality. Further, it is not obvious how mathematical results in answer set programming that have been
established in the absence of intensional functions would
carry over to these extensions.
In this note, we address such issues in the context of multivalued formulas—a simple extension of standard propositional formulas where atoms can express functions mapping
to finite domains. The convenience of using multi-valued
formulas for knowledge representation is demonstrated in
the context of nonmonotonic causal theories and action languages C+ (Giunchiglia et al. 2004) and BC (Lee, Lifschitz,

Multi-Valued Formulas under the Stable
Model Semantics
Review: Stable Models of Multi-Valued Formulas
A (multi-valued) signature is a finite set σ of symbols called
constants, along with a finite set Dom(c) of symbols that is
disjoint from σ and contains at least two elements, assigned

c 2014, Association for the Advancement of Artificial
Copyright 
Intelligence (www.aaai.org). All rights reserved.

583

to each constant c. We call Dom(c) the domain of c. A
multi-valued atom of σ is ⊥, or an expression of the form
c = v (“the value of c is v”) where c ∈ σ and v ∈ Dom(c). A
(multi-valued) formula of σ is a propositional combination
of multi-valued atoms.
A (multi-valued) interpretation of σ is a function that maps
every element of σ to an element in its domain. A multivalued interpretation I satisfies an atom c = v (symbolically,
I |= c = v) if I(c) = v. The satisfaction relation is extended
from atoms to arbitrary formulas according to the usual truth
tables for the propositional connectives. We often identify an
interpretation with the set of atoms of σ that are satisfied by I.
We say that I is a (multi-valued) model of F if it satisfies F .
We understand an expression of the form c = d, where
both c and d are constants, as an abbreviation for the formula
_
(c = v ∧ d = v).
(1)

Given a multi-valued signature σ, by UCσ (“Uniqueness
Constraint”) we denote the conjunction of
^
¬(c = v ∧ c = w)
(2)
v6=w | v,w∈Dom(c)

for all c ∈ σ, and by ECσ (“Existence Constraint”) we denote
the conjunction of
_
¬¬
c=v,
(3)
v∈Dom(c)

for all c ∈ σ. By UECσ we denote the conjunction of (2) and
(3) for all c ∈ σ. For instance, in Example 1, UECσ is
¬(c = 1 ∧ c = 2) ∧ ¬(c = 2 ∧ c = 3) ∧ ¬(c = 1 ∧ c = 3)
∧ ¬¬(c = 1 ∨ c = 2 ∨ c = 3) .
Theorem 1 Let F be a multi-valued formula of signature σ,
which can be also viewed as a propositional formula of signature σ prop .

v∈Dom(c)∩Dom(d)

Let F be a multi-valued formula of signature σ, and let
I be a multi-valued interpretation of σ. The reduct of F
relative to I (denoted F I ) is the formula obtained from F
by replacing each (maximal) subformula that is not satisfied
by I with ⊥. We call I a multi-valued stable model of F if I
is the only multi-valued interpretation of σ that satisfies F I .
Example 1 Take σ = {c} and Dom(c) = {1, 2, 3}, and
let F1 be c = 1 ∨ ¬(c = 1) and let Ii (i = 1, 2, 3) be the
interpretation that maps c to i. All three interpretations
satisfy F1 , but I1 is the only stable model of F1 : the reduct
I1
F1 is c = 1 ∨ ⊥, and I1 is the only model of the reduct;
the reduct of F1 relative to other interpretations is ⊥ ∨ ¬⊥,
which does not have a unique model.
If we conjoin c = 2 with F1 , we can check that the only
stable model is c = 2, which illustrates the nonmonotonicity
of the semantics.
As shown in Example 1, formulas of the form F ∨ ¬F
under the stable model semantics are useful for representing
the concept of defaults involving functions. We abbreviate
F ∨ ¬F as hF i. For example, F1 above can be written as
hc = 1i.

(a) If an interpretation I of σ is a multi-valued stable model
of F , then I can be viewed as an interpretation of σ prop
that is a propositional stable model of F ∧ UECσ in the
sense of (Ferraris 2005).
(b) If an interpretation I of σ prop is a propositional stable
model of F ∧ UECσ in the sense of (Ferraris 2005), then
I can be viewed as an interpretation of σ that is a multivalued stable model of F .
Note that the presence of ¬¬ in (3) is essential for Theorem 1 to be valid. For instance, consider the signature
containing only one constant d whose domain is {1, 2}
and F to be >. F has no multi-valued stable models,
but F ∧ ¬(d = 1 ∧ d = 2) ∧ (d = 1 ∨ d = 2) has two propositional stable models: {d = 1} and {d = 2}.

Multi-Valued Formulas under the CB-Stable
Model Semantics
CB-Stable Models of Multi-Valued Formulas
In this section we introduce a variant of the stable model
semantics in the previous section, which we call the CBstable model semantics. Unlike the previous section, this
section allows interpretations to be partially defined. That
is, some constants might not be mapped to any values. By
complete interpretations, we mean a special case of partial
interpretations where all constants are defined, which can be
identified with “total” interpretations in the previous section.
We consider the same syntax of a multi-valued formula as
in the previous section. As with total interpretations, a partial
interpretation I satisfies an atom c = v if I(c) is defined and
is mapped to v. This implies that an interpretation that is
undefined on c does not satisfy any atom of the form c = w
for any w ∈ Dom(c). As before, it is convenient to identify
a partial interpretation I with the set of atoms of σ that are
satisfied by this interpretation. For instance, an interpretation
of σ = {c} which is undefined on c is identified with the
empty set. Again, the satisfaction relation is extended from
atoms to arbitrary formulas according to the usual truth tables

Reducing Multi-Valued SM to Propositional SM
In this section we show that the multi-valued stable model
semantics can be viewed as a special case of the propositional
stable model semantics. Let σ be a multi-valued signature,
and let σ prop be the propositional signature consisting of all
propositional atoms c = v where c ∈ σ and v ∈ Dom(c).
For example, for σ in Example 1, σ prop is the set {c = 1, c =
2, c = 3}, where each element is understood as a propositional
atom. We identify a multi-valued interpretation of σ with
the corresponding set of propositional atoms from σ prop . It
is clear that a multi-valued interpretation I of signature σ
satisfies a multi-valued formula F iff I satisfies F when F is
viewed as a propositional formula of signature σ prop . Also,
it is not difficult to show that multi-valued formulas can be
turned into standard propositional formulas having the same
models. Less obvious is whether such a translation exists
while keeping same stable models. Theorem 1 below shows
such a translation.

584

for the propositional connectives. We call I a model of F if
it satisfies F .
The reduct F I is defined to be the same as before. We say
that a partial interpretation I is a CB-stable model of F if I
satisfies F and no proper subset J of I satisfies F I .

value. This is essentially equivalent to the way we understand
c = d as shorthand for formula (1).2
Since I satisfies c = c iff I is defined on c, the assertion
in Corollary 1 remains
valid when

 we replace ECσ in the
V
statement with ¬¬
c∈σ c = c .

Example 1 Continued Under the CB-stable model semantics, hc = 1i does not mean that c is mapped to 1 by default.
Instead, it means that c can be mapped to 1 or undefined. As
I1
before, the reduct F1 relative to I1 = {c = 1} is c = 1 ∨ ⊥,
and I1 is the minimal model of the reduct.1 Further, for I0
I0
that leaves c undefined, the reduct F1 is ⊥ ∨ ¬⊥, and I0 is
the minimal model of the reduct.

Reducing CB-Stable Models to Multi-Valued SM
Any multi-valued stable model of a formula is a CB-stable
model, but not vice versa because an incomplete partial interpretation has no direct counterpart as a total interpretation.
It may not look obvious how the CB-stable model semantics
(based on partial functions) can be reduced to the multivalued stable model semantics (based on total functions).
Nevertheless, we show that it is possible.
Let σ be a multi-valued signature, and let σ none be the
signature that is the same as σ except that the domain of each
constant has an additional new value NONE. Given a partial
interpretation I of σ, by I none we denote an interpretation of
σ none that agrees with I on all defined constants, and maps
undefined constants to NONE. Recall that expression hF i
stands for the formula F ∨ ¬F .

This difference in understanding hF i tells us that multivalued stable models are more convenient for representing
the commonsense law of inertia. For instance,
Loc0 = Kitchen → hLoc1 = Kitcheni
represents under the multi-valued stable model semantics that
the location does not change by default, but under the CBstable model semantics, the location may become unknown
as well.

Theorem 3 Let F be a multi-valued formula of signature σ.

Reducing CB-Stable Models to Propositional SM

(a) If an interpretation I of σ is a CB-stable
model of F , then
V
I none is a stable model of F ∧ c∈σ hc = NONEi.
none
is a stable model of F ∧
(b) If
V an interpretation J of σ
none
hc
=
NONE
i
then
J
=
I
for some CB-stable
c∈σ
model I of F .

Similar to Theorem 1, the following theorem tells us that the
CB-stable models of a multi-valued formula can be identified
with the stable models of a propositional formula. The only
difference is that we impose UCσ in place of UECσ .
Theorem 2 Let F be a multi-valued formula of signature σ,
which can be also viewed as a propositional formula of signature σ prop .
(a) If a partial interpretation I of σ is a CB-stable model of F ,
then I can be viewed as an interpretation of σ prop that
is a propositional stable model of F ∧ UCσ (in the sense
of (Ferraris 2005)).
(b) If an interpretation I of σ prop is a propositional stable
model of F ∧ UCσ (in the sense of (Ferraris 2005)), then
I can be viewed as a partial interpretation of σ that is a
CB-stable model of F .

For instance, in Example 1, the CB-stable models of
F1 are in a 1-1 correspondence with the stable models of
F1 ∧ hc = NONEi.

System MVSM
3

System mvsm is a prototype implementation of multivalued formulas under the stable model semantics. In
fact, it is a script that invokes several software, such
as MVPF 2 LP C OMPILER, F 2 LP, GRINGO, CLASP D, and
AS 2 TRANSITION . MVPF 2 LP C OMPILER is an implementation of the translations in Theorem 1 and Theorem 2, which
translates multi-valued formulas under the stable model semantics into standard propositional formulas under the stable
model semantics. As the theorems show, the translations
are very similar, and the user can choose which translation to use. F 2 LP then transforms the propositional formula
into an ASP program in the input language of GRINGO v3.
AS 2 TRANSITION takes the output of CLASP D and outputs
propositional atoms in the form of multi-valued atoms. The
composition of these software is depicted in Figure 1.
Shown below is a description of the blocks world domain
in the language of MVSM assuming the multi-valued stable
model semantics. The syntax of declarations follows the one
in the input language of the Causal Calculator v2.4 Compared

Reducing CB Semantics to Multi-Valued SM
Reducing Multi-Valued SM to CB-Stable Models
The following corollary immediately follows from Theorems 1 and 2. It tells us that the multi-valued stable model
semantics can be fully embedded into the CB-stable model
semantics.
Corollary 1 For any multi-valued formula F of signature
σ and any partial interpretation I, we have that I is a
multi-valued stable model of F iff I is a CB-stable model of
F ∧ ECσ .
Unlike the way we treat c = d as an abbreviation of (1),
in (Balduccini 2013), it was called a t-atom, for which the
notion of satisfaction was defined directly: I satisfies c = d
if I is defined on both c and d, and maps them to the same
1

2

In a sense, our treatment is more general because it allows the
domains of c and d to be different.
3
http://sourceforge.net/projects/aspmt/
4
http://www.cs.utexas.edu/∼tag/cc/

Minimality is understood in terms of set inclusion.

585

Figure 1: Architecture of MVSM
Acknowledgements: This work was partially supported by
NSF under Grant IIS-1319794 and by the South Korea IT
R&D program MKE/KIAT 2010-TD-300404-001.

to the usual ASP encoding, explicit declaration of sorts and
type checking help reduce the programmer’s mistakes. The
inertia and exogeneity assumptions in the last three rules
have simple reading, once we understand hF i as representing
defaults ({. . . } was used in place of h. . . i). There is no need
to use strong negation.

References

Balduccini, M. 2013. ASP with non-Herbrand partial functions: a language and system for practical use. TPLP 13(4% File ’bw’: The blocks world
5):547–561.
:- sorts
Bartholomew, M., and Lee, J. 2012. Stable models of forstep; astep; location >> block.
mulas with intensional functions. In Proceedings of International Conference on Principles of Knowledge Representa:- objects
tion and Reasoning (KR), 2–12.
0..maxstep
:: step;
Bartholomew, M., and Lee, J. 2013. On the stable model
0..maxstep-1
:: astep;
semantics for intensional functions. TPLP 13(4-5):863–876.
1..6
:: block;
table
:: location.
Cabalar, P. 2011. Functional answer set programming. TPLP
11(2-3):203–233.
:- variables
Ferraris, P.; Lee, J.; Lifschitz, V.; and Palla, R. 2009. SymST
:: step;
metric splitting in the general theory of stable models. In
T
:: astep;
Proceedings of International Joint Conference on Artificial
Bool
:: boolean;
Intelligence (IJCAI), 797–803. AAAI Press.
B,B1
:: block;
L
:: location.
Ferraris, P. 2005. Answer sets for propositional theories. In
Proceedings of International Conference on Logic Program:- constants
ming and Nonmonotonic Reasoning (LPNMR), 119–131.
loc(block,step)
:: location;
Gelfond, M., and Lifschitz, V. 1988. The stable model semove(block,location,astep)
:: boolean.
mantics for logic programming. In Kowalski, R., and Bowen,
% two blocks can’t be on the same block at the same time K., eds., Proceedings of International Logic Programming
<- loc(B1,ST)=B & loc(B2,ST)=B & B1!=B2.
Conference and Symposium, 1070–1080. MIT Press.
Giunchiglia, E.; Lee, J.; Lifschitz, V.; McCain, N.; and
% effect of moving a block
Turner,
H. 2004. Nonmonotonic causal theories. Artificial
loc(B,T+1)=L <- move(B,L,T).
Intelligence 153(1–2):49–104.
% a block can be moved only when it is clear
Lee, J., and Palla, R. 2009. System F 2 LP – computing
<- move(B,L,T) & loc(B1,T)=B.
answer sets of first-order formulas. In Procedings of International Conference on Logic Programming and Nonmonotonic
% a block can’t be moved onto a block that is being
Reasoning (LPNMR), 515–521.
% moved also
Lee, J.; Lifschitz, V.; and Yang, F. 2013. Action language
<- move(B,B1,T) & move(B1,L,T).
BC: Preliminary report. In Proceedings of International Joint
Conference on Artificial Intelligence (IJCAI).
% initial location is exogenous
{loc(B,0)=L}.
Lifschitz, V.; Pearce, D.; and Valverde, A. 2001. Strongly
equivalent logic programs. ACM Transactions on Computa% actions are exogenous
tional Logic 2:526–541.
{move(B,L,T)=Bool}.
Lifschitz, V. 2012. Logic programs with intensional functions.
% fluents are inertial
In Proceedings of International Conference on Principles of
{loc(B,T+1)=L} <- loc(B,T)=L.
Knowledge Representation and Reasoning (KR), 24–31.

586

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 63, NO. 7, JULY 2016

4255

Contribution-Based Energy-Trading Mechanism
in Microgrids for Future Smart Grid: A Game
Theoretic Approach
Sangdon Park, Student Member, IEEE, Joohyung Lee, Member, IEEE,
Sohee Bae, Student Member, IEEE, Ganguk Hwang, Member, IEEE,
and Jun Kyun Choi, Senior Member, IEEE

Abstract—This paper designs a contribution-based
energy-trading mechanism among microgrids in a competitive market. In each fixed time interval, each microgrid can
be an energy provider or a consumer according to their
energy generation and local demand. Under the trading
mechanism, there is a distributor which gathers the surplus
energy from providers and distributes it to the consumers
based on the consumers’ historical contribution level. To
design the trading mechanism, a novel contribution-based
energy allocation policy (EAP) is proposed. Each consumer
who knows this distribution rule decides the amount of
requesting energy in order to maximize its utility, i.e., the
quantity of energy it will receive. Finally, the economic benefits of such trading mechanism are studied by analyzing
the decision-making procedures of consumers and distributor. The problem is formulated as a noncooperative energy
competition game (ECG) among the consumers. The existence and the uniqueness of Nash equilibrium (NE) are
shown, and the NE solution is given as a closed form.
Also, even though there are foolish consumers which do
not take the given NE solution, a consumer which takes the
NE solution will not lose out on its utility. The proposed
energy-trading mechanism is stable enough to be applied
to a practical microgrid trading market.
Index Terms—Energy competition game (ECG), energy
trading, equilibrium analysis, microgrids.

I. I NTRODUCTION

A

S ENERGY demands and greenhouse gas emissions
increase worldwide, the smart grid, an evolved power
grid that manages electricity demand, has emerged as a promising technology that can improve the efficiency, reliability,
Manuscript received August 12, 2015; revised December 8, 2015;
accepted January 27, 2016. Date of publication February 29, 2016; date
of current version June 9, 2016. This work was supported by the R&D
Program of the Ministry of Science, ICT, and Future Planning, South
Korea, under Grant B0101-15-1365, development of technology for integrated energy management service of building and community and their
energy trading. (Corresponding author: Joohyung Lee.)
S. Park, S. Bae, and J. K. Choi are with the Department of Electrical
Engineering, Korea Advanced Institute of Science and Technology,
Daejeon 305-701, South Korea (e-mail: johnsdpark@kaist.ac.kr;
elasteam@kaist.ac.kr; jkchoi59@kaist.edu).
J. Lee is with Samsung Electronics, Suwon 443-742, South Korea
(e-mail: joohyung08@kaist.ac.kr).
G. Hwang is with the Department of Mathematical Sciences, Korea
Advanced Institute of Science and Technology, Daejeon 305-701, South
Korea (e-mail: guhwang@kaist.edu).
Color versions of one or more of the figures in this paper are available
online at http://ieeexplore.ieee.org.
Digital Object Identifier 10.1109/TIE.2016.2532842

economics, and sustainability of the production and distribution of electricity [1]–[3]. There have been numerous studies
related to smart-grid technology such as research on distributed
generation (DG) [4]–[6], energy storage system (ESS) [7]–[9],
electric vehicles (EVs) [10]–[14], advanced energy electronics [15], [16], and modern communication technologies [17],
[18]. A networked group of distributed energy sources such as
solar panels, wind turbines, or other renewable energy sources
located in a distributed network is referred to as a microgrid;
it can also provide energy to a small geographical area [19].
It also creates various benefits (e.g., flexibility and reliability)
providing reduced electricity cost to customers [1], [20].
In microgrids, the retailers should supply energy to their geographical areas without reliance on the main grid [3], [21]. This
is beneficial for alleviating overload on the main grid and reducing transmission loss. Nevertheless, because the generation of
renewable energy sources used in microgrids is generally highly
variable and intermittent, it is challenging to balance the energy
demand and supply. Thus, whenever some retailers have a
superfluous energy while others require more energy, it would
be advantageous for these retailers to trade energy with one
another instead of requesting it from the main grid. In this
manner, energy trading in microgrids is considered a promising mechanism; the retailers who have extra energy are called
providers or sellers and the retailers who have a need of energy
are called consumers or buyers.
Various forms of energy-trading mechanisms have been studied in the literature by taking into account the characteristics of
competitive market in microgrids. This is different from classical power grids, which are a centralized system. Specifically,
an individual microgrid involved in energy trading has its own
interests to maximize without concern of the interests of other
microgrids. This behavior creates a competitive market for
energy trading in microgrids that can be modeled and analyzed
as noncooperative game [21]. In this respect, the most important
concern is to obtain a Nash equilibrium (NE) where no player
has incentive to deviate from their strategies [3], [22].
Numerous game-theoretic approaches for energy trading in
microgrids have been introduced. Kim et al. proposed a power
scheduling algorithm by solving a noncooperative game among
self-interested customers, where each customer determines its
own load scheduling and energy trading to maximize its profit
[23]. Wang et al. showed to admit at least one NE for a

0278-0046 © 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

4256

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 63, NO. 7, JULY 2016

noncooperative game between storage units such as plug-in
hybrid electric vehicles (PHEV), which are trading their stored
energy, to decide on the maximum amount of energy to sell
[24]. Tushar et al. proposed a single-leader multiple-follower
Stackelberg game between the central power station (CPS) and
consumers, and found an optimal distributed solutions in order
to maximize all the consumers’ utility and to minimize the total
cost of the CPS [25]. Mondal and Misra provided generalized
NE of a multileader multifollower Stackelberg game between
PHEV and energy-trading network topology (ENTRANT) control [26]. In [27], a unique Stackelberg equilibrium of a noncooperative Stackelberg game between residential units (RUs)
and a shared facility controller (SFC) was provided for energy
management with distributed energy resources in smart grid.
Tushar et al. provided cake cutting game to give Pareto optimal solution to decide on the price per unit of energy to
charge a SFC in order to sell surplus energy for energy users
in smart grid [28]. This preliminary work gave a closed form
of NE of Stackelberg game model of a distributed mechanism
for energy trading among microgrids in a competitive market
where heterogeneous energy sources and energy storages were
considered [29].
All the previous works have adopted a pricing mechanism to
sustain the trading mechanism (e.g., buying and selling cost),
since it is difficult to encourage microgrids to contribute their
superfluous energy. If some retailers having superfluous generation cannot be guaranteed any benefit, they might store
their energy for future use. However, implementation of a pricing mechanism requires additional overhead in the microgrid
energy market. For example, a pricing mechanism should concern a tax inspection procedure or a tricky trader in microgrids.
In this light, this paper proposes a contribution-based energytrading mechanism by utilizing the historical contribution level
in order to encourage providers to donate energy. Thus, this
is the first study on nonpricing mechanism-based energy trading in microgrids, and thus the suggested mechanism is simple
and does not require any additional overhead, as required in
conventional works.
The contributions of this paper are summarized as follows.
1) This paper designs a contribution-based energy-trading
mechanism among microgrids in a competitive market. In
each fixed time interval, each microgrid can be an energy
provider or a consumer according to their energy generation and local demand. Under the trading mechanism,
there is a distributor which gathers the surplus energy
from providers and distributes it to the consumers based
on the consumers’ historical contribution level.
2) To design a trading mechanism, a novel contributionbased energy allocation policy (EAP) is proposed. Each
consumer who knows this allocation policy decides the
amount of requesting energy so as to maximize its utility,
i.e., the quantity of energy it will receive.
3) This paper proposes a new parameter, weight factor α,
so the energy distributor can control the importance of
microgrid buildings’ contribution.
4) The economic benefits of this trading mechanism are
studied by analyzing the decision-making procedures of

consumers and a distributor. The problem is formulated as
a noncooperative energy competition game (ECG) among
the consumers. The existence and the uniqueness of NE
are shown, and the NE solution is given as a closed
form.
5) Even though there are foolish consumers who do not take
the given NE solution, any consumer who takes the NE
solution will not lose out on its utility. Thus, the proposed
energy-trading mechanism is stable enough to be applied
to a practical microgrid trading market.
6) Furthermore, implementation procedure and convergence
time are discussed for practical implementation.
This paper is organized as follows. The proposed model is
explained in detail in Section II and the energy allocation algorithm is also proposed in Section III. In Section IV, the problem
is formulated as a noncooperative ECG and NE is discussed.
Some numerical results and practical issues are discussed in
Sections V and VI, respectively. Finally, the conclusion of this
paper is provided in Section VII.

II. S YSTEM M ODEL
This section provides an overview of a contribution-based
energy-trading mechanism where each microgrid can generate
or provide electricity through heterogeneous energy sources.
In the energy-trading microgrid system, it is considered that
there are M microgrids and M = {1, 2, . . . , M } denotes index
set of all the microgrids. In a given time period, each microgrid i ∈ M is able to generate a total energy Gi and each
microgrid is required to service a group of customers having a
demand Di .
If Gi ≥ Di for some i ∈ M, this ith microgrid is called
a provider and J denotes the set of all providers, where
J = {i ∈ M|Gi ≥ Di }. After the provider serves its own customers, its remaining generated energy is defined as Ei,rm ,
i ∈ J , i.e., Ei,rm = (Gi − Di ) ≥ 0 ∀i ∈ J . If Gi < Di , this
microgrid has to procure extra energy from a provider or the
main grid, and hence this microgrid is called a consumer. I
is the index set of all consumers, i.e., I = {i ∈ M|Gi < Di }.
Note that (Di − Gi ) is the required energy for a provider
to support its own customers, denoted by Ei,req > 0. Here,
assume that there are N consumers in this time period, i.e.,
|I| = N . From now on, without loss of generality, we arrange
the index set of all microgrids J satisfying I = {1, 2, . . . , N }
and J = {N + 1, N + 2, . . . , M }. There is an energy distributor D between the set of providers J and the set of consumers
I, which gathers the surplus energy from all the providers.
It is encouraged for D to have its own energy
storage. Thus,

(Gk − Dk ) =
the
distributor
D
has
total
energy
E
=
k∈J

k∈J Ek,rm . Note that this distributor concept is widely
used in microgrid infrastructures to control trading between
providers and consumers, to decide the price of trading energy
in microgrids, and so on [30].
The contribution concept is now introduced in the proposed
scenario. Each microgrid has a historical contribution value,
which indicates how much electricity it has provided to this

PARK et al.: CONTRIBUTION-BASED ENERGY-TRADING MECHANISM

4257

is now easy to consider the following optimization problem to
allocate the energy to consumers:


Ui (Ei )s.t.0 ≤ Ei ≤ si ∀i ∈ I,
Ei ≤ E.
max
E

Fig. 1. System model for a contribution-based control of energy allocation in microgrid infrastructures.

energy-trading microgrid society. Ci denotes the contribution
value of the ith microgrid. In addition, there is a weight factor
α of the contribution that serves as a measure of the importance
of the contribution in this system.
A scenario, in which a set of consumers I requests electricity energy from the distributor D, is illustrated in Fig. 1.
Here, the ith consumer sends a request for energy si to distributor D, including how much energy is required (in unit of
Watt); s denotes the requested energy vector such that s =
(s1 , . . . , sN ). Upon receiving this message, the distributor D
will use an EAP to distribute its electricity energy based on the
value of the request and the requesting consumers’ contribution values Ci . Here, C denotes the contribution vector only
for consumers; C = (C1 , . . . , CN ). Hence, the distributor D
delivers electricity to each competing the consumer i with electricity energy Ei ; E denotes the allocated energy vector for the
consumers, i.e., E = (E1 , . . . , EN ).
Here, the request for energy is the strategy of the consumer,
and thus si is not always equal to the actual required energy
of the ith consumer Ei,req . Considering the variables in this
sharing microgrid system and the EAP by the distributor D,
each consumer decides their strategy si on [0, Ei,req ] to maximize their allocated energy Ei , which will be discussed in
Section IV.

III. E NERGY A LLOCATION P OLICY
In this section, an EAP is provided for the distributor D to
the set of consumers after the requesting strategies of all the
consumers s are fixed. From the point of view of the distributor
D, it wants to maximize the sum of the satisfaction of all the
consumers under the concept of social welfare (SW). From this
the satisfaction of the consumer i
perspective, Ui (Ei ) denotes

from D’s view, and i∈I Ui (Ei ) is the SW of this model. It

i∈I

i∈I

Note that the above two constraints originate from the assumptions that the distributor D will not allocate the energy greater
than the requested energy and the sum of all the allocated
energy cannot exceed the remaining energy from all the
providers.
To this end, Ui (Ei ) is defined as the satisfaction of the
consumer i from D’s view. The following assumptions and
corresponding meanings are proposed for Ui :
1) Ui is a nonnegative real-valued function : satisfaction
cannot be a negative value.
2) Ui is a strictly increasing function of Ei /si : satisfaction
increases by the ratio between the allocated energy and
its requirement. (The law of diminishing marginal utility
[31], [32].)
3) Ui is a concave function of Ei : the increasing rate of
satisfaction decreases as the allocated energy increases.
4) Ui is proportional to Ciα : the distributor D tries to
allocate more energy to a consumer who contributes
more, considering the weight factor of contribution of the
system.
Note that a logarithmic utility function is generally used for
measuring user’s satisfaction with decreasing returns [29], [33],
[34]. Thus, the following utility function of the consumer i can
be considered from D’s view:


Ei
α
∀i ∈ I.
(1)
Ui (Ei ) = Ci log 1 +
si
Therefore, the EAP of the distributor D is proposed by solving
the following constrained optimization problem.
Problem 1: (EAP) Let I = {1, 2, . . . , N } be the index set of
all the consumers, C = {C1 , C2 , . . . , CN } be the contribution
vector, and s = {s1 , . . . , sN } be the requesting vector. Then,
the EAP is given by


 α
Ci log 1 + Esii
max
E

s.t.

i∈I

0
≤ Ei ≤ si
Ei ≤ E

∀i ∈ I

i∈I

where
α is the weight factor (α ≥ 0) for contribution value.
If i∈I si ≤ E, it is easily confirmed that the proposed optimization problem assigns Ei = si for all i. In this case, there
is no competition between consumers. Thus, in order to concentrate on the case
 of competition between consumers, the
nontrivial case of i∈I si > E should be considered.
Now, solving Problem 1 in the nontrivial case, one can obtain
the closed-form solution given by the following theorem.
Theorem 1: (EAP) There is an optimal energy allocation
E∗ = {Ei∗ |i ∈ I} of Problem 1 as follows:
⎧
⎨ hCiα − si , if this is >0 and <si
∗
if the above value is ≥si
(2)
Ei = s i ,
⎩
0,
otherwise

4258

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 63, NO. 7, JULY 2016


where h is a real number satisfying I Ei∗ = E and is called
by the energy level for the strategy s.
Proof: Since the objective function is strictly concave and
all the constraints are linear, the Karush–Kuhn–Tucker (KKT)
conditions guarantee conditions of Problem 1 are given as
follows:
Ciα
+ λi − μi − ν = 0 ∀i ∈ I
+ si

Ei∗

− Ei∗ ≤ 0, Ei∗ − si ≤ 0

Ei∗ − E = 0

(3)

∀i ∈ I
(4)

i∈I

λi ≥ 0, μi ≥ 0

∀i ∈ I

λi Ei∗ = 0, μi (Ei∗ − si ) = 0

∀i ∈ I.

(5)

Clearly, the objective function and inequality constraint functions are differentiable and convex; equality constraint function
is affine. Thus, the KKT condition has an optimal solution [35].
From (5), there are three possible cases for Ei : Ei∗ = 0 or
∗
Ei = si or 0 < Ei∗ < si .
First, consider a case 0 < Ei∗ < si , then it is clear that
λi = 0 and μi = 0. Thus, stationary condition (3) becomes
Ei∗ = hCiα − si where h = 1/ν.
Considering a case Ei∗ = 0, it should be shown that hCiα −
si ≤ 0. Since Ciα > 0 and si ≥ 0, one can get h > 0 from
this assumption. The slackness condition (5) gives μi = 0, and
from the stationary condition (3), one can get hCiα − si =
−λi si h ≤ 0.
Next, considering a case Ei∗ = b, it should be shown that
hCiα − si ≥ si . The slackness condition (5) gives λi = 0, and
from the stationary condition (3), one can get hCiα − 2si =
2μsi h ≥ 0, which yields hCiα − si ≥ si .
From the above three cases and from the third primal feasibility condition (4), the optimal solution is given by (2).

Here, Problem 1 is a slightly different version of the wellknown water-filling problem in [36] and [37]. In this manner, it
can be converted to the following water-filling problem, which
has the same solution as Problem 1.
There are N tanks and any two of them are connected
by a pipe. I = {1, 2, . . . , N } is the index set of all the
α
} is the set of tanks’ widths, and
tanks, {C1α , C2α , . . . , CN
α
α
α
} is the set of tanks’ heights.
{s1 /C1 , s2 /C2 , . . . , sN /CN
Suppose that tank i has to be on the base of height si /Ciα for
all i ∈ I. Now, the set of tanks will be filled by pouring water
of volume E. Then, tank i will filled by the water of volume
Ei , given by the same solution as Problem 1. Fig. 2 shows the
example of the water-filling problem and solution.
An interesting aspect is that the value Ciα of the consumer i
implies the ith tank’s width. Thus, the consumer which has no
contribution cannot achieve any energy allocation because this
consumer’s tank width is zero. Now, focusing on the weight
factor of the contribution of this system α, there is also an
interesting feature. If α is zero, it can be seen that all the
tanks’ widths are the same, which implies that the contributions of consumers are not considered in the energy allocation.
However, by increasing α larger, then the width is more affected
by the contribution value of the consumer. Using this concept,

Fig. 2. Water filling solution for the EAP.

the distributor D can scale this weight factor α based on how
important the contribution value is in the system.
Now, the reader might wonder how the water-filling solution
(2) can be implemented in practice without knowing h first. A
procedure for implementing (2) that determines h uniquely will
be provided. For convenience, assume that the set of the consumers I is arranged by the increasing order of the tank’s width
si /Ciα without loss of generality, i.e.,
s1
s2
sN
< α < ··· < α .
α
C1
C2
CN
The algorithm starts by increasing the energy E1 in the first
tank and checks the energy level (height of the energy) until one
of the following three cases happens:
(a) the energy level meets the base of the second tank and
there is pouring energy remaining;
(b) the energy level meets the ceil of the first tank and there
is pouring energy remaining;
(c) the pouring energy is exhausted.
It is clear that in the case of (c), the algorithm will be finished. In the case of (a), the fist tank and the second tank should
be filled together until one of the similar following three cases
happens: (a ) for the third tank or (b ) for the first tank or (c ).
In the case of (b), because the first tank is full, the second tank
should be filled until one of the following three cases happens:
(a ) for the third tank or (b ) for the second tank or (c ).
Continue this step sequentially to consider a general situation, pouring the (k − j) tanks, from the jth tank to the
(k − 1)th tank together. Similar to the above three cases, the
energy level is increased until one of the following three cases
happens:
(ag ) the energy level meets the base of the kth tank and there
is pouring energy remaining;
(bg ) the energy level meets the ceil of the jth tank and there
is pouring energy remaining;
(cg ) the pouring energy is exhausted.
The next job of each case is given as follows:
(ãg ) pour energy from the jth tank to the kth tank together;

PARK et al.: CONTRIBUTION-BASED ENERGY-TRADING MECHANISM

4259

Algorithm 1. Energy Allocation Policy

A. Noncooperative Continuous Strategic Form Game

Initialization:
(a) Arrange the set of consumers I and its coordinate vectors s
and C by the value of si /Ciα in ascending order
(b) Initialize the filling indexes j = 1, k = 2
(c) Initialize the filling width w = C1α
(d) Initialize the remaining energy Erm = E
(e) Initialize the energy height h = s1 /C1α
(f) Initialize the allocated energy vector of consumers
E = 0; that is, E = {Ei |Ei = 0, ∀i ∈ I}.
(g) Initialize the sN +1 = ∞ and CN +1 = 1 for exception
handling.
Repeat the

 iterationwhile{Erm > 0}
2s
(a) If C αj > Cskα & w Cskα − h < Erm ,
j
k
k

sk
Erm = Erm − w
−h ;
Ckα
α
α
; k =k + 1; 
w = w
+ Ck ; h = s
k /Ck 

sk
2sj
2sj
≤ α & w
− h < Erm ,
(b) else if
Cjα
Ck
Cjα


2sj
Erm = Erm − w
− h ; Ej = s j ;
Cjα

The utility function of each consumer is defined in this
section. The required energy is different for each consumer;
however, each consumer wants to receive as much energy as
possible from the distributor, limited to the required energy of
the consumer. In this respect, the utility function of the consumer i is defined as the energy Ei allocated by the distributor,
i.e., the solution set of EAP given in the previous section. Thus,
the utility functions of all the consumers are the vector-valued
functions u, given by



 α
Ci log 1 + Esii
u(s) = argmax

w = w − Cjα ; h = 2sj /Cjα ; j = j + 1;
(c) else,
Erm
; Erm = 0;
h=h+
w
for i = j : k

si
Ei = Ciα h − α ;
Ci
End iteration
Output: Set of allocated energy of consumers E, after rearranged by the original order

(b̃g ) pour energy from the (j + 1)th tank to the (k − 1)th tank
together;
(c̃g ) finish the pouring energy.
In case (bg ), there is no vacant space to fill the jth tank; i.e.,
jth consumer will be allocated by the maximum energy of si .
Also, in the case of (cg ), the ith tank satisfying j ≤ i ≤ k will
get Ciα (h − si /Ciα ) amount of energy. The remaining tanks,
whose base did not meet the energy level satisfying si /Ciα > h
cannot be allocated any water.
From the above procedure and explanation, one can derive
Algorithm 1 for the EAP to provide a unique solution of
Problem 1 that is summarized in the following proposition.
Proposition 1: Algorithm 1 gives the optimal solution of the
Problem 1.
IV. E NERGY C OMPETITION G AME
In this section, the competition between consumers is formulated as a noncooperative continuous strategic form game,
and then the existence and the uniqueness of NE of the game
are shown [38]. Furthermore, the NE solution is given as a
closed-form expression in this section, in addition to a useful
proposition.

E

i∈I

s.t. 0 ≤ Ei ≤ si

Ei ≤ E

∀i ∈ I

i∈I

where si is the strategy of the ith consumer, requesting
energy. Clearly, the ith consumer’s utility function is given
by ui (s) where ui is the ith component of u; i.e., u(s) =
(u1 (s), . . . , ui (s), . . . , uN (s)).
Now, the proposed competing problem is formulated
as a noncooperative continuous strategic form game G =
(Si , ui )N
i=1 , called an ECG. Here, N is the number of I,
ui is a payoff function given as above, and Si = [0, Ei,req ]
N
for each player i ∈ I with S = i=1 Si . The notations s−i
and S−iare given by s−i = (s1 , . . . , si−1 , si+1 , . . . , sN ) and
S−i = j=i Sj , respectively.
B. Nash Equilibrium of the ECG
In this section, not only the proof of the existence and the
uniqueness of NE but also the closed form of the NE solution
are provided for the proposed ECG. They start from the proof
of NE existence, of which the key aspect is the continuity and
quasi-concavity of the utility function [38].
Lemma 1: For the consumer i, fix the other consumers’ strategy s−i = s̄−i . Now, consider two strategies for the consumer
i, s¯i , and si , satisfying the following conditions:
s¯i < si
0 < ui (s¯i , s̄−i ) < s¯i .
Then, ui (s¯i , s̄−i ) ≥ ui (si , s̄−i ).
In particular, if an additional condition holds as follows:
∃j ∈ I\{i} s.t. 0 < uj (s¯i , s̄−i ) < s¯j

(6)

then it can be concluded that ui (s¯i , s̄−i ) > ui (si , s̄−i ).
Proof: At first, if ui (si , s̄−i ) = 0, then it is trivial; thus,
the nontrivial case, 0 < ui (si , s̄−i ) ≤ si , will be considered.
Now, let h̄ be the energy level for the strategy (s¯i , s̄−i ) and
let h be the energy level for the strategy (si , s̄−i ), given by
Theorem 1. For convenience, for the strategy s¯i , divide the set
of all other consumers I\{i} into the three sets as follows:
ĪL = {j ∈ I\{i}|uj (s¯i , s̄−i ) = 0}
ĪU = {j ∈ I\{i}|uj (s¯i , s̄−i ) = sj }
ĪM = {j ∈ I\{i}|0 < uj (s¯i , s̄−i ) < sj }.

4260

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 63, NO. 7, JULY 2016

si , satisfying si < s¯i < si . To prove the quasi-concavity of the
utility function in si , it is enough to show that

It is clear that ĪM = ∅ if the additional condition (6) holds.
Also for the strategy si , divide I\{i} as follows:

min {ui (si , s̄−i ), ui (si , s̄−i )} ≤ ui (s¯i , s̄−i ).

IL = {j ∈ I\{i}|uj (si , s̄−i ) = 0}
IU = {j ∈ I\{i}|uj (si , s̄−i ) = sj }

IM
= {j ∈ I\{i}|0 < uj (si , s̄−i ) < sj }.

Because s¯i < si , one can get h̄ < h , which yields ĪL ⊃ IL ,

ĪU ⊂ IU , and ĪM ⊂ IM
considering the energy level in Fig. 2.
First, it will be shown that
h −

si
s¯i
≤ h̄ − α .
α
Ci
Ci

(7)
s

To this end, suppose that h̄ − Cs¯iα < h − Ciα . Now, consider
i
i
the total allocated energy to all the consumers for each strategy s¯i and si . Considering the total allocated energy to all the
consumers for the strategy s̄i and si , one can obtain



 

s
s
¯
i
j
E = Ciα h̄ − α +
sj +
Cjα h̄ − α
Ci
Cj
j∈ĪU
j∈ĪM



 

sj
s¯i
α
α
≤ Ci h̄ − α +
sj +
Cj h̄ − α
Ci
Cj


j∈IU
j∈IM



 

si
sj
α

α

< Ci h − α +
sj +
Cj h − α
Ci
Cj


j∈IU

j∈IM

=E
which gives contradiction; thus, the inequality condition (7) is
shown.
2s
2s¯i
Now, if ui (si , s̄−i ) = si , then h > C αi > C
α > h̄, which
s

i

i

yields h̄ − Cs¯iα < h − Ciα , a contradiction to the inequality
i
i
condition (7), thus 0 < ui (si , s̄−i ) < si . By Theorem 1, the
utility of the strategy s¯i is given by
ui (s¯i , s̄−i ) = h̄Ciα − s¯i
ui (si , s̄−i ) = h Ciα − si .
From the inequality condition (7), we have
ui (si , s̄−i ) = h −

si
s¯i
≤ h̄ − α = ui (s̄i , s̄−i ).
α
Ci
Ci

If one of utilities ui (si , s̄−i ) and ui (si , s̄−i ) is zero, then the
proof is done; it remains to consider the nontrivial case when
both of them are nonzero.
1) Case 1: ui (s¯i , s̄−i ) = 0
In this case, it is clear that ui (si , s̄−i ) = 0 and hence the
inequality holds.
2) Case 2: ui (s¯i , s̄−i ) = s¯i
In this case, it can be shown that ui (si , s̄−i ) = si by the
similar way in Lemma 1, thus
min {ui (si , s̄−i ), ui (si , s̄−i )} ≤ si < ui (s¯i , s̄−i ).
3) Case 3: 0 < ui (s¯i , s̄−i ) < s¯i
By Lemma 1, ui (s¯i , s̄−i ) ≥ ui (si , s̄−i ), which completes
the proof.

Now, using Lemma 2 and Theorem 2.2 in [38], the existence
of NE is directly shown in the following theorem, and one of
the NE solutions is given in the next theorem.
Theorem 2: (Existence of a NE) There exists at least one NE
for the ECG.
Theorem 3: (A NE Point) s∗ = {s∗1 , . . . , s∗N } is a NE of the
ECG, which is given by
s∗i = min {η ∗ Ciα , Ei,req }

where η ∗ is a number satisfying i∈I s∗i = E. Furthermore,
Algorithm 2 gives this NE.
Proof: For i ∈ I, it is enough to show
ui (s∗i , s∗−i ) ≥ ui (si , s∗−i ) ∀si ∈ [0, Ei,req ].

Obviously, j∈I s∗i = E gives uj (s∗ ) = s∗j ∀j ∈ I.
First, if si ≤ s∗i , it is easily observe that
ui (si , s∗−i ) ≤ si ≤ s∗i = ui (s∗i , s∗−i ).
Thus, it remains to prove the case when si > s∗i . If s∗i =
Ei,req , then there is no strategy bigger than s∗i , then it remains
the case s∗i = η ∗ Ciα .
To this end, suppose that ui (s∗i , s∗−i ) < ui (si , s∗−i ). Let h∗
be the energy level in EAP for the strategy s∗ , and h∗−i be
the energy level in EAP for the strategy (si , s∗−i ). It is easily
checked that 2η ∗ = h∗ < h∗−i , which yields uj (si , s∗−i ) = s∗j
for all j ∈ I\{i} because uj (s∗ ) = s∗j . Considering the sum of
all the utility for the above two strategies

uj (s∗ )
E=
j∈I

In addition for the additional condition (6), it can be easily checked by the same procedure as given above that h −
si /Ciα < h̄ − s¯i /Ciα , from which ui (s¯i , s̄−i ) > ui (si , s̄−i ). 
Lemma 2: Each utility function ui (s1 , . . . , sN ) is continuous in (s1 , . . . , sN ) and quasi-concave in si .
Proof: Since the objective function is continuous and the
strategic domain is convex, it is clear that the utility function is
continuous in (s1 , . . . , sN ).
Now for the consumer i, fixing the other consumers’ strategies s−i = s̄−i , consider arbitrary three strategies si , s¯i , and



=

uj (s∗ ) + ui (s∗i , s∗−i )

j∈I\{i}



=

s∗j + ui (s∗i , s∗−i )

j∈I\{i}



<

s∗j + ui (si , s∗−i )

j∈I\{i}

=E
which gives contradiction.



PARK et al.: CONTRIBUTION-BASED ENERGY-TRADING MECHANISM

Proposition 2: The proposed EAP allocates the same
amount of requested energy to the consumer i which employs
a strategy of si = s∗i ; i.e., ui (s∗i , s−i ) = s∗i for all s−i ∈
j=i Sj .
Proof: Assume that the other consumers’ strategies are
s−i = s̄−i where s̄−i = {s¯1 , . . . , s¯N }. Let h∗ be the energy
level in EAP for the strategy s∗ , and h̄ be the energy level
in EAP for the strategy (s∗i , s̄−i ). It is easily checked that
h∗i = 2s∗i /Ciα .
If h∗ ≤ h̄, then


ui (s∗i , s̄−i ) = min s∗i , h̄Ciα − s∗i


= min h∗ Ciα − s∗i , h̄Ciα − s∗i
= h∗ Ciα − s∗i
= s∗i .
Now, suppose that h̄ < h∗ . It is easily checked that
ui (s∗i , s̄−i ) < s∗i . For j ∈ I\{i}, if s¯j ≥ s∗j , then the utility of
consumer j is given by


uj (s∗i , s̄−i ) = max 0, h̄Ciα − s̄i < h∗ Ciα − s∗i = s∗j .
If s̄j < s∗j , the utility of consumer j is given by


uj (s∗i , s̄−i ) = min h̄Ciα − s̄i , s¯j ≤ s¯j < s∗j .
Thus, the total sum of utility is given by


∗
∗
j∈I uj (si , s̄−i ) <
j∈I sj = E
which yields that there are remaining energy to allocate, contradictory to the assumption.

Proposition 2 has the significant implication that if there are
foolish consumers which do not take the strategy of the NE
solution, EAP guarantees allocation of the requesting amount
of energy to the consumer which employs the strategy of the NE
solution. Thus, the proposed system is stable and can be implemented to a real trading market. Also from this proposition,
the proposed NE solution gives the optimal strategy to each
consumer; thus, Algorithm 2 can be assumed as the optimal
strategy for consumer (OSC) algorithm.
Finally, the uniqueness of the NE solution will be shown in
the following theorem, which concludes this section.
Theorem 4: (Uniqueness of NE) For the NE solution s∗
given by Theorem 3, suppose that there are at least two consumers of which the utility is less than the amount of their own
strategy; i.e.,
∃i, j ∈ I s.t. ui (s∗ ) < s∗i and uj (s∗ ) < s∗j .
Then, this NE solution is unique in the ECG.
Proof: To this end, suppose that there are another NE, say
s = {s1 , . . . , sN } = s∗ . If there is k ∈ I such that uk (s ) <
s∗k , then it is not a NE because uk (s∗k , s−i ) = s∗k by Proposition
2. If there is k ∈ I such that uk (s ) > s∗k , then it is observed

∗
that there has to exist l ∈ I such
 that∗ ul (s ) < sl because
∗
∗
un (s ) = sn for all n ∈ I and n∈I sn = E; it is not a NE,
either. Thus, it is concluded that uk (s ) = s∗k for all k ∈ I.

4261

Algorithm 2. Optimal Strategy for Consumer
Initialization:
(a) Arrange the set of consumers I and its coordinate vectors C
by the value of Ei,req /Ciα in ascending order
(b) Initialize the filling index j = 0
(c) Initialize the filling width w = i∈I Ciα
(d) Initialize the remaining requesting energy Erm = E
(e) Initialize the energy height η = 0
(f) Initialize the EN +1,req = ∞ and CN +1 = 1 for exception
handling.
Repeat the
while
{Erm >0}

 iteration

Ej,req
− η < Erm
(a) if w
Cjα


Ej,req
Ej,req
Erm = Erm − w
− η ;η =
;
Cjα
Cjα
w = w − Cjα ; sj = Ej,req ;
j = j + 1;
(b) else
Erm
; Erm = 0;
η=η+
w
for k = j : N
sk = ηCkα ;
End iteration
Output: Set of requesting energy vector of consumers s, after
rearranged by the original order



Now, if j∈I sk < j∈I s∗k , then k∈I sk < 
E which is
acontradiction. Thus, it remains the case when j∈I sj ≥
∗

∗
∗
j∈I sj . Since s = s , there is i ∈ I such that si <

∗
si . Let s̄i be a strategy between them, i.e., si < s̄i < si .
Since ui (s∗i , s−i ) = ui (si , s−i ) = s∗j , it is easily observed that
ui (s̄i , s−i ) = s∗j by the quasi-concavity of the utility function.
Also, it is easily checked that 0 < ui (s̄i , s−i ) < s̄i . Now, by
Lemma 1, it can be obtained that ui (s¯i , s̄−i ) > ui (si , s̄−i ),
which is also a contradiction to the assumption that s
is an NE.

Note that the condition for the NE solution holds in most
cases because it holds unless the energy level h is less than only
one consumer’s tank height.
V. N UMERICAL R ESULTS
In this section, six numerical examples are given to verify
the proposed theorems and propositions, and to investigate the
utility of consumers with respect to variation in a consumer’s
strategy and some parameters. First, Fig. 3 investigates SW with
respect to variations in energy allocations to consumers. This
example uses N = 2, E = 7, C = (1, 1.5), α = 1.5, and s =
(3, 5). As the energy allocations
E1 and E2 increase gradually
from 0, the graph plots the SW i∈I Ui (Ei ), where Ui (Ei ) is
given by (1). By Proposition 1, Algorithm 1 gives the optimal
energy allocations to the consumers, which yields E1 = 2.287,
E2 = 4.713 for this example. Remind that the
 SW is defined
by the sum of all the consumers’ utilities, i∈I Ui (Ei ), in
Section III. By maximizing the SW numerically, the optimal

4262

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 63, NO. 7, JULY 2016

Fig. 3. SW with respect to variations in the energy allocation to two
consumers.

Fig. 4. Utility of consumers with respect to variation in the consumer 1’s
strategy when s−1 = s̄−1 .

Fig. 5. Utility of consumers with respect to variation in the consumer 1’s
strategy when s−1 = s∗−1 .

energy allocations are given by E1 = 2.287 and E2 = 4.713,
same as the solution of EAP algorithm. Thus, from this numerical example, the proposed EAP algorithm and Proposition 1 are
verified.
The remaining numerical examples consider more general cases than the case with only two consumers; i.e.,
N = 4, E = 20, Ereq = (10, 7, 3, 12), C = (1, 1.2, 1.4, 1.6),
α = 1.5, and s̄−1 = (4, 7, 9) as a default. Note that using
Algorithm 2, the optimal strategy s∗ of this case is given by
s∗ = (3.919, 5.151, 3.000, 7.931), which will be used in the
numerical analysis.
Figs. 4 and 5 investigate the utility of all the consumers as
consumer 1’s strategy s1 varies from 0 to 10 (= E1,req ) when
s−1 is s̄−1 in Fig. 4 and s∗−1 in Fig. 5, respectively. Investigating
both figures, it is verified that the utility of consumer 1 is
quasi-concave, which is shown in Lemma 2. Also shown in
Theorem 1, u1 (s1 , s̄−1 ) has a linearly increasing region before
the peak value. It then decreases until it vanishes, and it has
a zero value in the rest of the region. In addition, there are

Fig. 6. Three meaningful values of each consumers {Ci /
Ei /E, Ei,req /E}.


i∈I

Ci ,

Fig. 7. Utility of consumers with respect to variation in the total remaining energy.

two important observations in Fig. 5 that verify Theorem 3
and Proposition 2. First, it is observed that the utility of consumer 1 gives the first maximum value at 3.919, which is the
same value of s∗1 using Algorithm 2. This observation verifies that s∗ is the NE solution, i.e., ui (s∗ ) ≥ ui (s1 , s∗−1 ) for
all s1 ∈ S1 . Also, another observation is that the other consumers are allocated the same amount of energy that they
request, s∗−1 = (5.151, 3.000, 7.931), independent of consumer
1’s strategy. This observation shows the other consumers that
take the NE solution are guaranteed to receive the same amount
of energy they request, which is the result of Proposition 2.
Fig.6 investigates three meaningful values of each consumer
{Ci / i∈I Ci , Ei /E, Ei,req /E} when all the consumers
employ the optimal strategy 
s∗ and the distributor allocates
energy by the EAP. Here, Ci / i∈I Ci is the ratio of each consumer’s contribution to the sum of contributions; Ei /E is the
ratio of each consumer’s allocated energy to the total remaining energy; and Ei,req /E is the ratio of the required energy
to the total remaining energy. It is observed that the allocated
energy ratio is bigger if the contribution ratio is bigger, but constrained by the required energy. In addition, because the weight
factor is greater than 1 in this case (α = 1.5), the increasing
rate of the allocated energy ratio is bigger than the increasing rate of the contribution ratio. These observations show the
proposed energy-trading mechanism operates well as expected;
i.e., a higher contributing consumer receives more energy than
a lower one.
Figs. 7 and 8 investigate the utility, i.e., the allocated energy,
of all the consumers with respect to the variation in the total
remaining energy for Fig. 7 and of the weight factor for Fig. 8. It
shows how much the total remaining energy and weight factor

PARK et al.: CONTRIBUTION-BASED ENERGY-TRADING MECHANISM

4263

Fig. 8. Utility of consumers with respect to variation in the weight factor.

Fig. 10. Average number of convergence steps of EAP algorithm versus
the number of retailers.

Fig. 11. Average number of convergence steps of OSC algorithm versus
the number of retailers.
Fig. 9. Sequence diagram for the proposed energy-trading mechanism.

affect the proposed energy-trading mechanism. In Fig. 7, it is
clear that the energy allocation increases as the total remaining
energy increases; however, some energy allocations meet their
constraints Ei,req . If this occurs, the other consumers’ increasing rates become larger. In Fig. 8, when the weight factor is
zero, the allocated energy of all the consumers is completely
fair because the distributor does not consider the contribution. As the weight factor increases, the energy allocation gap
increases until the higher contributor saturates to its maximum.

VI. D ISCUSSION
In this section, some practical issues of the proposed energytrading mechanism are discussed. For practical implementation,
it is worth reminding that the proposed mechanism occurs in
a given time period (e.g., per 6 h; four times in a day). The
distributor in microgrids can decide the time period depending
on their circumstances.
Fig. 9 is the sequence diagram for the proposed mechanism
that shows the actual communication and energy flows for practical implementation procedure in microgrids. Note that dotted
lines and continuous lines mean communication messages and

energy flows, respectively. For the first step of procedure, each
retailer sends a message to the distributor whether he is a
provider or a consumer; if he is a provider, then he also informs
how much he can provide energy to the distributor. Now, the
distributor calculates the total aggregated energy from providers
and informs it to all consumers. Based on this information,
each consumer decides their optimal strategy by using proposed OSC algorithm. Afterward, all consumers send energy
requesting messages to the distributor so that the distributor
decides how the total aggregated energy can be distributed to
each consumer by using proposed EAP algorithm. Finally, the
distributor plays a role to distribute the aggregated energy after
sending energy requesting message to providers.
Next, it will be shown that the proposed algorithms are
fast enough for real-time implementation. Figs. 10 and 11
show the average number of convergence steps of the proposed EAP and OSC algorithm, respectively, as the number of
retailers varies from 1 to 50; the practical number of retailers is less than 50. Note that the results are averaged by
105 times of simulations with the following random variables: Di /30 ∼ ln N (0, 1), Ci ∼ U (1, 2) ∀i ∈ {1, 2, . . . , N },
and α = 1.5. Since it is reasonable that the amount of energy
generation is mostly less than the amount of energy demand, the

4264

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 63, NO. 7, JULY 2016

following four cases are considered for the energy generation:
Gi /6 ∼ ln N (0, 1), Gi /12 ∼ ln N (0, 1), Gi /18 ∼ ln N (0, 1),
Gi /24 ∼ ln N (0, 1) ∀i ∈ {1, 2, . . . , N }. The figures shows
that the average numbers of convergence steps of both algorithms are linear increasing function of the number of retailers.
Here, the highest convergence time of the proposed EAP and
OSC algorithm is 38.638 (ms) and 16.696 (ms) with 3.4-GHz
quad-core Intel Core i5 CPU. In addition, for the extreme case
at 1000 retailers, the convergence time of the proposed EAP and
OSC algorithm is 303.52 (ms) and 142.94 (ms), respectively,
which is fast enough for practical implementation.
In classical large-scale power systems, any energy mismatch
between demand and generation can be solved by a slack
bus. On the other hand, in microgrids, distributed energytrading mechanism for various objectives can be considered as a
promising solution [3]. Accordingly, a consumer can get energy
from providers first. If it is not sufficient for the consumer to
support its local demands, the consumer would make up the
shortfall with the energy from the main grid.
VII. C ONCLUSION
This paper has described the design of a contribution-based
energy-trading mechanism among microgrids in a competitive
market. To this end, a novel contribution-based EAP is proposed. The problem is formulated as a noncooperative ECG
among the consumers. The existence and the uniqueness of
NE are shown rigorously, and the NE solution is given in a
closed form. Also, even though there are foolish consumers
who do not take the given NE solution, a consumer who takes
the NE solution will not lose out on its utility. Numerical results
verify the proposed theorems with propositions and investigate the utility of consumers with respect to variation in some
parameters. Furthermore, the implementation procedure of the
proposed mechanism is provided and the convergence time of
the proposed algorithms is shown to be fast enough for practical
implementation. It is concluded that the proposed mechanisms
are applicable to a real noncooperative microgrid system.
ACKNOWLEDGMENT
The authors would like to thank the anonymous reviewers
for their valuable comments that contributed to the improved
quality of this paper.
R EFERENCES
[1] G. W. Arnold, “Challenges and opportunities in smart grid: A position
article,” Proc. IEEE, vol. 99, no. 6, pp. 922–927, Jun. 2011.
[2] V. C. Gungor et al., “A survey on smart grid potential applications and
communication requirements,” IEEE Trans. Ind. Informat., vol. 9, no. 1,
pp. 28–42, Feb. 2013.
[3] W. Saad, Z. Han, H. V. Poor, and T. Basar, “Game-theoretic methods
for the smart grid: An overview of microgrid systems, demand-side management, and smart grid communications,” IEEE Signal Process. Mag.,
vol. 29, no. 5, pp. 86–105, Sep. 2012.
[4] T. L. Vandoorn, C. M. Ionescu, J. D. Kooning, R. D. Keyser, and
L. Vandevelde, “Theoretical analysis and experimental validation of
single-phase direct versus cascade voltage control in Islanded microgrids,” IEEE Trans. Ind. Electron., vol. 60, no. 2, pp. 789–798, Feb.
2013.

[5] G. M. Guerrero, P. C. Loh, T. Lee, and M. Chandorkar, “Advanced control architectures for intelligent microgrids. Part II: Power quality, energy
storage, and ac/dc microgrids,” IEEE Trans. Ind. Electron., vol. 60, no. 4,
pp. 1263–1270, Apr. 2013.
[6] A. Ovalle, G. Ramos, S. Bacha, A. Hably, and A. Rumeau,
“Decentralized control of voltage source converters in microgrids based
on the application of instantaneous power theory,” IEEE Trans. Ind.
Electron., vol. 62, no. 2, pp. 1152–1162, Feb. 2015.
[7] M. Sechilariu, B. Wang, and F. Locment, “Building integrated photovoltaic system with energy storage and smart grid communication,” IEEE
Trans. Ind. Electron., vol. 60, no. 4, pp. 1607–1618, Apr. 2013.
[8] W. Huang and A. Qahouq, “Energy sharing control scheme for stateof-charge balancing of distributed battery energy storage system,” IEEE
Trans. Ind. Electron., vol. 62, no. 5, pp. 2764–2776, May 2015.
[9] F. Adinolfi, G. M. Burt, P. Crolla, F. D’Agostino, M. Saviozzi, and
F. Silvestro, “Distributed energy resources management in a low-voltage
test facility,” IEEE Trans. Ind. Electron., vol. 62, no. 4, pp. 2593–2603,
Apr. 2015.
[10] C. Ou, H. Liang, and W. Zhuang, “Investigating wireless charging and
mobility of electric vehicles on electricity market,” IEEE Trans. Ind.
Electron., vol. 62, no. 5, pp. 3123–3133, May 2015.
[11] N. Liu et al., “A heuristic operation strategy for commercial building
microgrids containing EVs and PV system,” IEEE Trans. Ind. Electron.,
vol. 62, no. 4, pp. 2560–2570, Apr. 2015.
[12] L. Jian, H. Xue, G. Xu, X. Zhu, D. Zhao, and Z. Shao, “Regulated charging of plug-in hybrid electric vehicles for minimizing load variance in
household smart microgrid,” IEEE Trans. Ind. Electron., vol. 60, no. 8,
pp. 3218–3226, Aug. 2013.
[13] C. Jin, J. Tang, and P. Ghosh, “Optimizing electric vehicle charging with
energy storage in the electricity market,” IEEE Trans. Smart Grid, vol. 4,
no. 1, pp. 311–320, Mar. 2013.
[14] A. T. Al-Awami and E. Sortomme, “Coordinating vehicle-to-grid services
with energy trading,” IEEE Trans. Smart Grid, vol. 3, no. 1, pp. 453–462,
Mar. 2012.
[15] J. M. Carrasco, L. G. Franquelo, J. T. Bialasiewicz, E. Galván,
R. Guisado, and M. Prats, “Power-electronic systems for the grid integration of renewable energy sources: A survey,” IEEE Trans. Ind. Electron.,
vol. 53, no. 4, pp. 1002–1016, Aug. 2006.
[16] B. K. Bose, “Global energy scenario and impact of power electronics in
21st century,” IEEE Trans. Ind. Electron., vol. 60, no. 7, pp. 2638–2651,
Jul. 2013.
[17] T. Sauter and M. Lobashov, “End-to-end communication architecture for
smart grids,” IEEE Trans. Ind. Electron., vol. 58, no. 4, pp. 1218–1228,
Apr. 2011.
[18] V. C. Gungor et al., “Smart grid technologies: Communication technologies and standards,” IEEE Trans. Ind. Informat., vol. 7, no. 4,
pp. 529–539, Nov. 2011.
[19] N. Hatziargyriou, H. Asano, R. Iravani, and C. Marnay, “Microgrids,”
IEEE Power Energy Mag., vol. 5, no. 4, pp. 78–94, Aug. 2007.
[20] I. Koutsopoulos and L. Tassiulas, “Optimal control policies for power
demand scheduling in the smart grid,” IEEE J. Sel. Areas Commun.,
vol. 30, no. 6, pp. 1049–1060, Jul. 2012.
[21] I. S. Bayram, M. Z. Shakir, M. Abdallah, and K. Qaraqe, “A survey on
energy trading in smart grid,” in Proc. IEEE Global Conf. Signal Inf.
Process. (GlobalSIP), Dec. 3–5, 2014, pp. 258–262.
[22] E. V. Damme, Stability and Perfection of Nash Equilibria. Berlin,
Germany: Springer-Verlag, 1991, vol. 339.
[23] B. Kim, S. Ren, M. Schaar, and J. Lee, “Bidirectional energy trading and residential load scheduling with electric vehicles in the smart
grid,” IEEE J. Sel. Areas Commun., vol. 31, no. 7, pp. 1219–1234,
Jul. 2013.
[24] Y. Wang, W. Saad, Z. Han, H. V. Poor, and T. Basar, “A game-theoretic
approach to energy trading in the smart grid,” IEEE Trans. Smart Grid,
vol. 5, no. 3, pp. 1439–1450, May 2014.
[25] W. Tushar, J. Zhang, D. Smith, H. V. Poor, and S. Thiebaux, “Prioritizing
consumers in smart grid: A game theoretic approach,” IEEE Trans. Smart
Grid, vol. 5, no. 3, pp. 1429–1438, May 2014.
[26] A. Mondal and S. Misra, “Game-theoretic energy trading network topology control for electric vehicles in mobile smart grid,” IET Netw., vol. 4,
no. 4, pp. 220–228, Jul. 2015.
[27] W. Tushar et al., “Three-party energy management with distributed
energy resources in smart grid,” IEEE Trans. Ind. Electron., vol. 62, no. 4,
pp. 2487–2498, Apr. 2015.
[28] W. Tushar, C. Yuen, D. Smith, and H. V. Poor, “Price discrimination for
energy trading in smart grid: A game theoretic approach,” IEEE Trans.
Smart Grid, to be published, doi: 10.1109/TSG.2015.2508443.

PARK et al.: CONTRIBUTION-BASED ENERGY-TRADING MECHANISM

[29] J. Lee, J. Guo, J. K. Choi, and M. Zukerman, “Distributed energy trading in microgrids: A game-theoretic model and its equilibrium analysis,”
IEEE Trans. Ind. Electron., vol. 62, no. 6, pp. 3524–3533, Jun. 2015.
[30] L. Jelenkovic and T. Budrovic, “Simple day-ahead bidding algorithm
for a system with microgrids and a distributor,” in Proc. Int. Conv. Inf.
Commun. Technol. Electron. Microelectron., May 25–29, 2015, pp. 1103–
1108.
[31] M. C. Rios, C. R. McConnell, and S. L. Brue, Economics: Principles,
Problems, and Policies. New York, NY, USA: McGraw-Hill, 2013.
[32] O. Lange, “The determinateness of the utility function,” Rev. Econ. Stud.,
vol. 1, no. 3, pp. 218–225, 1934.
[33] T. Alpcan and T. Basar, “A globally stable adaptive congestion control
scheme for internet-style networks with delay,” IEEE/ACM Trans. Netw.,
vol. 13, no. 6, pp. 1261–1274, Dec. 2005.
[34] D. Niyato, E. Hossain, and Z. Han, “Dynamics of multiple-seller and
multiple-buyer spectrum trading in cognitive radio networks: A gametheoretic modeling approach,” IEEE Trans. Mobile Comput., vol. 8, no. 8,
pp. 1009–1022, Aug. 2009.
[35] S. Boyd and L. Vandenberghe, Convex Optimization. Cambridge, U.K.:
Cambridge Univ. Press, 2004.
[36] D. P. Palomar, D. Pérez, and J. R. Fonollosa, “Practical algorithms for
a family of waterfilling solutions,” IEEE Trans. Signal Process., vol. 53,
no. 2, pp. 686–695, Feb. 2005.
[37] P. P. Vaidyanathan, S. M. Phoong, and Y. P. Lin, Signal Processing
and Optimization for Transceiver Systems. Cambridge, U.K.: Cambridge
Univ. Press, 2010.
[38] P. J. Reny, “Non-cooperative games: Equilibrium existence,” in New
Palgrave Dictionary of Economics, 2nd ed., Palgrave Macmillan, 2008,
[Online]. Available: http://www.dictionaryofeconomics.com/dictionary

Sangdon Park (S’16) received the B.S. and
M.S. degrees in mathematical sciences from
Korea Advanced Institute of Science and
Technology (KAIST), Daejeon, South Korea, in
2011 and 2013, respectively, where he is currently working toward the Ph.D. degree in electronic engineering.
His research interests include not only
resource allocation and optimization in smart
grids but also throughput analysis and optimization in wireless networks.
Joohyung Lee (S’09–M’14) received the B.S.,
M.S., and Ph.D. degrees in electrical engineering from Korea Advanced Institute of Science
and Technology (KAIST), Daejeon, South Korea,
in 2008, 2010, and 2014, respectively.
He was a Visiting Researcher in the
Department of Electronic Engineering, City
University of Hong Kong, Kowloon Tong, Hong
Kong, from 2012 to 2013. In 2014, he joined
Samsung Electronics, Suwon, South Korea, as
a Senior Engineer. His research interests include
resource allocation and optimization, with a focus on resource management for 5G networks, green networks, smart grids (future power grids),
and network economics.
Dr. Lee was a member of the GreenTouch Consortium. From
2010 to 2013, he contributed several articles to the International
Telecommunication Union Telecommunication Standardization Sector
Study Group 13 Questions 9 and 22. He was the recipient of the
Best Paper Award at the Integrated Communications, Navigation, and
Surveillance Conference in 2011.

4265

Sohee Bae (S’16) received the B.S. degree in
electrical engineering and the M.S. degree in
mathematical sciences from Korea Advanced
Institute of Science and Technology (KAIST),
Daejeon, South Korea, in 2012 and 2014,
respectively, where she is currently working toward the Ph.D. degree in electronic
engineering.
Her research interests include signal processing and optimization in smart grids.

Ganguk Hwang (M’03) received the B.S., M.S.,
and Ph.D. degrees in mathematics (applied
probability) from Korea Advanced Institute of
Science and Technology (KAIST), Daejeon,
South Korea, in 1991, 1993, and 1997, respectively.
From February 1997 to March 2000, he was
a Senior Researcher with the Electronics and
Telecommunications Research Institute (ETRI),
Daejeon, South Korea. From March 2000 to
February 2002, he was a Visiting Scholar at
the School of Interdisciplinary Computing and Engineering, University
of Missouri–Kansas City, Kansas City, MO, USA. Since March 2002,
he has been with the Department of Mathematical Sciences and
Telecommunication Engineering Program, KAIST, where he is currently
a Professor. From August 2010 to July 2011, he was a Visiting Scholar
in the Department of Electrical Engineering, University of Washington,
Seattle, WA, USA. His research interests include teletraffic theory,
performance analysis of communication networks, quality of service
provisioning for wired/wireless networks, and cross-layer design and
optimization for wireless networks.
Jun Kyun Choi (M’88–SM’00) received the M.S.
(Eng.) and Ph.D. degrees in electronic engineering from Korea Advanced Institute of Science
and Technology (KAIST), Daejeon, South Korea,
in 1985 and 1988, respectively.
He was a Senior Researcher with the
Electronics and Telecommunication Research
Institute (ETRI), Daejeon, South Korea, from
1986 to 1997. In 1998, he joined, as a Professor,
the Information and Communications University
(now known as KAIST). His research interests
include broadband network architecture and technologies, with particular emphasis on performance and protocol problems.
Dr. Choi has been an active member of the International
Telecommunication Union Telecommunication Standardization Sector
Study Group 13 as a Rapporteur/Editor on the ATM, MPLS, and NGN
issues since 1993.

Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence

Handling Uncertainty in Answer Set Programming
Yi Wang and Joohyung Lee
School of Computing, Informatics, and Decision Systems Engineering
Arizona State University, Tempe, USA
{ywang485, joolee}@asu.edu

Abstract

Language LPMLN

We present a probabilistic extension of logic programs under the stable model semantics, inspired by the concept of
Markov Logic Networks. The proposed language takes advantage of both formalisms in a single framework, allowing
us to represent commonsense reasoning problems that require
both logical and probabilistic reasoning in an intuitive and
elaboration tolerant way.

Since a Markov Logic Network is based on the standard
first-order logic semantics, it “has the drawback that it cannot express (non-ground) inductive definitions” (Fierens et
al. 2013). Consider the following domain description (“α”
denotes “hard weight”).
w1 :
w2 :
...
α:
α:

Introduction
Answer Set Programming (ASP) is a successful logic programming paradigm that takes advantage of nonmonotonicity of the underlying semantics, the stable model semantics.
Many useful knowledge representation constructs and efficient solvers allow ASP to handle various commonsense
reasoning problems elegantly and efficiently. However, difficulty still remains when it comes to domains with uncertainty. Imprecise and vague information cannot be handled
well since the stable model semantics is mainly restricted
to Boolean values. Further, probabilistic information cannot
be handled since the stable model semantics does not distinguish which stable models are more likely to be true.
To address the first aspect of the issue, several approaches
to incorporating fuzzy logic into ASP have been proposed,
such as (Lukasiewicz 2006). However, most of the work
is limited to simple rules. In our previous work (Lee and
Wang 2014), we proposed a stable model semantics for
fuzzy propositional formulas, which properly generalizes
both fuzzy logic and the Boolean stable model semantics,
as well as many existing approaches to combining them.
The resulting language combines the many-valued nature of
fuzzy logic and the nonmonotonicity of stable model semantics, and consequently shows competence in commonsense
reasoning involving fuzzy values.
In this work, we focus on the other aspect of the issue, namely handling probabilistic information in commonsense reasoning. We adapt the idea of Markov Logic Networks (MLN) (Richardson and Domingos 2006), a wellknown approach to combining first-order logic and probabilistic graphical models in a single framework, to the context of logic programming. The resulting language LPMLN
combines the attractive features of each of the stable model
semantics and MLN.

Edge(1, 2)
Edge(2, 3)
Path(x, y) ← Edge(x, y).
Path(x, y) ← Path(x, z), Path(z, y).

The above weighted rules are intended to describe probabilistic reachability in a graph, which is induced by the probabilities of the involved edges. The relation Path, describing
the reachability between two vertices, is supposed to be the
transitive closure of the relation Edge. However, under the
MLN semantics, this is not the case.
We propose the language LPMLN , which overcomes such
a limitation. The syntax of an LPMLN program is essentially
the same as that of an MLN instance, except that weighted
formulas are replaced by weighted rules.
Similar to MLN, the weight of each rule can be either
a real number, or the symbol α that marks a rule a “hard
rule.” The weight of each interpretation is obtained from the
weights of the rules that form the maximal subset of the program for which the interpretation is a stable model.
More precisely, we assume a finite first-order signature σ
that contains no function constants of positive arity, so that
any non-ground LPMLN program can be identified with
its ground instance. Without loss of generality, we consider ground (i.e., variable-free) LPMLN programs. For any
ground LPMLN program P of signature σ, consisting of a set
of weighted rules w : R, and any Herbrand interpretation I
of σ, we define PI to be the set of rules in P which are satisfied by I. The weight of I, denoted by WP (I), is defined
as
!
X
WP (I) = exp
w
w:R ∈ P
R∈PI

if I is a stable model of PI ; otherwise WP (I) = 0. The
probability of I under P, denoted P rP [I], is defined as

c 2015, Association for the Advancement of Artificial
Copyright 
Intelligence (www.aaai.org). All rights reserved.

WP (I)
J∈P W WP (J)

P rP [I] = lim P
α→∞

4218

the elaboration has a new minimal plan containing 11 actions only, including two steps in which the wolf does not
eat the sheep when the farmer is not around. We formalized this domain in LPMLN , and, based on the reduction of
LPMLN to MLN, used Alchemy to check that the probability
of the success of this plan is p × p and that of the original 17
step plan is 1.

Figure 1: The transition system with probabilistic effects,
defined by LPMLN semantics (a) and MLN semantics (b)

Discussion
LPMLN is related to many earlier work. Only a few of them
are mentioned here due to lack of space. It is not difficult
to embed ProbLog (Raedt, Kimmig, and Toivonen 2007) in
LPMLN . The language is also closely related to P-log (Baral,
Gelfond, and Rushton 2009). The LPMLN formalization of
probabilistic transition systems is related to PC+ (Eiter and
Lukasiewicz 2003), which extends action language C+ for
probabilistic reasoning about actions.
The work presented here calls for more future work.
One may design a native computation algorithm for LPMLN
which would be feasible to handle certain “non-tight” programs. We expect many results established in ASP may
carry over to MLN, and vice versa, which may provide a
new opportunity for probabilistic answer set programming.
Acknowledgements We are grateful to Chitta Baral,
Michael Bartholomew, Amelia Harrison, Vladimir Lifschitz, Yunsong Meng, and the anonymous referees for their
useful comments. This work was partially supported by the
National Science Foundation under Grant IIS-1319794 and
by the South Korea IT R&D program MKE/KIAT 2010-TD300404-001, and the Brain Pool Korea program.

where P W is the set of all Herbrand interpretations of σ.
Inductive definitions are correctly handled in LPMLN
since it adopts the stable model semantics in place of the
standard first-order logic semantics in MLN. For instance,
the weighted rules given at the beginning of this section
yields the expected result under the LPMLN semantics.
Any logic program under the stable model semantics can
be embedded in LPMLN by assigning the hard weight to each
rule. MLN can also be embedded in LPMLN via choice formulas which exempt atoms from minimization. LPMLN programs can be turned into MLN instances via the concept of
loop formulas (Ferraris, Lee, and Lifschitz 2006). This result
allows us to use an existing implementation of MLN, such as
Alchemy, to effectively compute “tight” LPMLN programs.

Probabilistic Transitions by LPMLN
LPMLN can be used to model transition systems where actions may have probabilistic effects. For example, the transition system shown in Figure 1(a) can be encoded as the
following LPMLN program.
ln(λ)
ln(1 − λ)
α
α
α

:
:
:
:
:

α
Auxi
α
← Auxi
α
← Pi , NPi
← not Pi , not NPα
i
Pi+1 ← Ai , Auxiα

:
:
:
:
:

References

{Pi+1 } ← Pi
{NPi+1 } ← NPi
{Ai }
{P0 }
{NP0 }

Baral, C.; Gelfond, M.; and Rushton, J. N. 2009. Probabilistic
reasoning with answer sets. TPLP 9(1):57–144.
Eiter, T., and Lukasiewicz, T. 2003. Probabilistic reasoning
about actions in nonmonotonic causal theories. In Proceedings
Nineteenth Conference on Uncertainty in Artificial Intelligence
(UAI-2003), 192–199. Morgan Kaufmann Publishers.
Ferraris, P.; Lee, J.; and Lifschitz, V. 2006. A generalization
of the Lin-Zhao theorem. Annals of Mathematics and Artificial
Intelligence 47:79–101.
Fierens, D.; Van den Broeck, G.; Renkens, J.; Shterionov, D.;
Gutmann, B.; Thon, I.; Janssens, G.; and De Raedt, L. 2014.
Inference and learning in probabilistic logic programs using
weighted boolean formulas. TPLP, 44 pages.
Lee, J., and Wang, Y. 2014. Stable models of fuzzy propositional formulas. In Proceedings of European Conference on
Logics in Artificial Intelligence (JELIA), 326–339.
Lukasiewicz, T. 2006. Fuzzy description logic programs under
the answer set semantics for the semantic web. In Eiter, T.;
Franconi, E.; Hodgson, R.; and Stephens, S., eds., RuleML, 89–
96. IEEE Computer Society.
Raedt, L. D.; Kimmig, A.; and Toivonen, H. 2007. ProbLog:
A probabilistic Prolog and its application in link discovery. In
IJCAI, 2462–2467.
Richardson, M., and Domingos, P. 2006. Markov logic networks. Machine Learning 62(1-2):107–136.

Here i is a schematic variable ranging over
{0, . . . , maxstep − 1}. The atom Auxi represents the
probabilistic choice for the success of action Ai . The 3rd
and 4th rules say that Pi and NPi are complementary.
The 5th rule defines the probabilistic effect of Ai . The
6th and 7th rules represent the commonsense law of
inertia, where we use {H} ← Body to denote the rule
H ← Body, not not H. The last three rules specify that the
execution of A at each step and the initial value of P are
arbitrary.
Under the MLN semantics, the same program specifies a
different probabilistic transition system (Figure 1(b)), which
is not aligned with the commonsense understanding of the
description. In this transition system, fluents can change arbitrarily even when no relevant actions are executed.
As an application of the idea of using LPMLN to define
probabilistic transition systems, a probabilistic variant of the
Wolf, Sheep and Cabbage puzzle can be encoded in LPMLN .
We consider an elaboration in which with some probability p, eating does not happen even when the farmer is not
present. While the minimal length plan for the original puzzle involves 17 actions of loading, moving and unloading,

4219

24-1
Hybrid Driver IC for Real-Time TFT Non-uniformity Compensation
of Ultra High-Definition AMOLED Display
Jun-Suk Bang‫ڌ‬, Hyun-Sik Kim2, Sang-Hui Park‫ڌ‬, Ki-Duk Kim‫ڌ‬, Sung-Won Choi1,
Oh-Jo Kwon2, Choong-Sun Shin2, Joo‫ۃ‬yung Lee2, Gyu-Hyeong Cho1
1

Department of Electrical Engineering, KAIST, Daejeon, Korea, 2Samsung Display, Yong-in, Korea
Pixel
Timing Controller Source Driver
Abstract
VDD,EL
VDD,EL
VDD,EL
(Digital TFT Compensation) (Analog Driving&Sensing)
SCAN
SCAN
An UHD AMOLED display driver IC, enabling real-time TFT
SCAN
V
+˭V
non-uniformity compensation, is presented with a hybrid driving scheme.
Ȗ-LUT
VDAC
ITFT
The proposed hybrid driving scheme drives a mobile UHD (3840x1920)
˭V
IDATA
AMOLED panel, whose scan time is 7.7ȝs at a scan frequency of 60Hz,
SENSE
SENSE
SENSE
CDAC
V
V
through the load of 30kohm resistance and 30pF capacitance. A
˭V
TFT
CMP
Memory
Driving
Sensing Emission
Comp.
proposed accurate current sensor embedded in the column driver and a
(SCAN=L)
(SENSE=L)
back-end compensation scheme reduce maximum current error between
SCAN[n]
emulated TFTs within 0.94 LSB (37nA) of 8-bit gray scales. Since the
SENSE[n]
SCAN[n+1]
CMP = 1 Ȣ ˭Vĸ˭V - ˭V
TFT variation is externally compensated, a simple 3T1C pixel circuit is
SENSE[n+1]
CMP = 0 Ȣ ˭Vĸ˭V + ˭V
V
employed in each pixel.
V
1-H
Introduction
Driving & Sensing
Emission
Although the active matrix organic light emitting diode (AMOLED) Fig. 3 Functional diagram of hybrid driving system
CDAC
CDAC
CMP
CMP
display is promising because of its fast response, high contrast ratio and
wide viewing angle, a reliability problem still hinders its penetration to
the main display market. Temporal and spatial VTH and mobility
IBIAS
IBIAS
IBIAS
ITFT
ITFT
variation of the TFTs in Fig. 1 is the main cause. Even though an in-pixel
SCAN[n]
VTH compensation method with a voltage driving is widely used, it
requires several TFTs and capacitors which reduce the aperture ratio. A
current driving [1] and a digital driving [2] can program display data
ESENSE[n]
almost regardless of the TFT variation, but its long programming time is
OSENSE[n]
inappropriate to today’s UHD display, whose 1-H time is less than 10ȝs.
The proposed hybrid AMOLED driving scheme satisfies both fast
driving speed as a voltage driving and high current accuracy as a current
driving as in Fig. 2 by performing an external TFT variation Fig. 4 Differential sensing method for panel noise cancelling
compensation in real-time. The proposed column driver circuit the current comparator sensitivity. Also, clock feedthrough error from a
accurately senses the TFT current while driving data under display panel SCAN switch, when turned off before sensing, is reflected to the ITFT.
noise. In addition, the driver can be reorganized as an 8b current-mode
Because the hybrid driving is based on the voltage driving, it is much
SAR ADC to measure the OLED current.
faster than the current driving. In addition, the low output impedance of
൚ ൚ ൚
the driver allows the ITFT to arrive at the current comparator and to be
I
sensed within the sensing time.
൚,
൚,
൚,
Regarding the size of memory, if the ¨V of each pixel is computed for
V
V
V I
V
V
V
I
all
256 gray levels, it requires (741·N) MB (N=# of bits for ¨V) of
I
I
I
I
memory for the ultra HD (3840x2160) resolution. Even though it
V
V V
V
perfectly compensates the mobility variation, this amount of memory
Fig. 1 Threshold voltage (VTH) and mobility (˩) variation of TFT
increases the system cost. Therefore, the same ¨V is applied for every 64
Voltage Driving Current Driving Hybrid Driving
gray levels to reduce the memory by (12·N) MB.
V
V
In Fig. 4, a differential sensing method is presented for high display
I
panel noise immunity. Since the panel noise current (iNOISE) is mainly
I
Display
Display
I
coming from power supply ripple and ground noise coupling via the line
Data
Data
capacitance (CP), the noise currents from two adjacent data lines are
Display Data
highly correlated. If only sense switches of pixels on odd data lines turn
Driving Speed
Fast
Fast
Slow
on when sensing the ITFT, a single current sensor in every two channels
VTH compensation
TFT variation
VTH, ȝ compensation VTH , ȝ compensation
measures the difference between the currents from two adjacent data
Compensation
only
lines so that the two correlated iNOISE are cancelled. Two same bias
Pixel Circuit
Complex (5T2C)
Simple (3T1C)
Simple (3T1C)
currents (IBIAS) are also added to these currents to secure the swing of the
Fig. 2 Comparison among voltage driving, current driving and hybrid driving
iNOISE, and they are cancelled by the differential sensing.
Hybrid AMOLED Driving
Column Driver Circuit Implementation
Fig. 3 shows the functional diagram of the hybrid driving scheme.
Fig. 5 describes a column driver schematic for two hybrid driver
During every 1-H time, the hybrid driver drives the data voltage (VDATA) channels. It consists of two 10b voltage DACs (VDAC) and class-AB
and compares the actual TFT current (ITFT) at the VDATA with the data buffer amplifiers with two current-sensing resistors (RS1, RS2), a 8b
current (IDATA) corresponding to the gray level. The VDATA corresponding current DAC (CDAC) with a reference current(IREF) calibrator (RCC)
to every gray level is initially defined by a predefined gamma-LUT. At for channel-to-channel uniformity[3] and a proposed offset-compensated
the next driving, the programmed VDATA for each pixel increases or integrating comparator (OCIC). During the first half period of the 1-H
decreases by one LSB of the VDAC (¨VLSB) according to the previous time (SENSE=1), SW1~4 are all connected in order to drive the data
comparison result (CMP) between the ITFT and the IDATA. This digital voltage to the pixel. At the next half period (SENSE=0), the SW1 and
back-end compensation is performed by a timing controller until the ITFT SW3 are turned off so that all of the currents coming through the channel
at the VDATA is close to the IDATA within 1 LSB of the current DAC output (ITFT, IBIAS and iNOISE) flow through the RS1O. On the other hand, the
(CDAC), and the correction data (¨V) is stored to the memory.
IDATA from the CDAC goes to the RS1E with the IBIAS and the iNOISE of the
Thus, the VTH and mobility variation of the TFT as well as the offset of even channel. Therefore, the OCIC can compare the ITFT to the IDATA
the buffer amplifier are all compensated in the hybrid driving because the regardless of the iNOISE by integrating the difference between the VRS1O
TFT current at the gray level is only affected by the CDAC linearity and and the VRS1E during integrating period (tint) as in the waveform in Fig. 5.
DATA

D D,EL

DD,EL

LSB

LSB

DD,EL

CP0 CP1

TFT

0

DATA

T0

TFT0

0

T1

D ATA

0

0

CP0 CP1

iNOISE

iNOISE

CP0 CP1

CP0 CP1

1

1

DATA

TFT1

T0

TFT2
TFT0
TFT1

TFT2

DATA

DATA

VDAC

T0

G

DATA

TF T

DATA

CDAC

˭V

978-4-86348-502-0

T1

VDAC

CDAC

+VTH -

C326

iNOISE

iNOISE

SS,EL

DATA

2015 Symposium on VLSI Circuits Digest of Technical Papers

TINT

VDATA_Serial

8b Current
Logic
& SAR

CDATA_Serial
CMP_Serial

SW4

VDATA
<2:0>

SW3

ODD

EVEN
SW1

IDATA

VDDH

RS1O

IBIAS

1-H time =7.7ȝs

SW2

RP

VDD,EL

Tint

EVEN

SCAN

vPO

vPE
OSENSE

INV

VDDL = 1.8V Offset

RS2O
RS2E

ോ2

Gm

Cs
EL

vS
+

Tint

49൚m

Digital Output Code

ോ1

VDDL

102 Channels

ോ‫ڂ ڌ‬ȝോ‫ڎ‬

RS1O
RS1E

ോ2

ോ2
TFT

ോ3
vS

ODD

TOS TINT TSH



Fig. 6 Offset-compensated integrating comparator (OCIC) and its
current offset histogram from 100 samples Monte-Carlo simulation
Source Driver

Pixel
VTEST

Circuit-reused
Current-mode
8b SAR ADC
Reconfigurable
SAR Controller

VDAC

8

CDAC

4൚s

1-H time

w/o Differential Sensing

Rstring
Bias
& Ctrl
Gen.

No Compensation
ǻV for all channels
ǻV for every 128 channels
ǻV for every 64 channels

Gray Level

5mm

VREF

ോ1

Gm

0V

Fig. 11 Current error between two
emulated TFTs with ǻVTH=60mV
Fig. 10 Chip micrograph
before and after hybrid driving
TABLE I. PERFORMANCE SUMMARY OF HYBRID DRIVER IC
Process
0.18ȝm CMOS
Area / Channel
794 x 24.5 ȝm2
63.6ȝW (VDD = 1.8V, 5V)
Power / Channel
(Amp. 10ȝW, OCIC 3.6ȝW, CDAC 50ȝW)
1-H Time
7.7ȝs (UHD (3840x2160), 60Hz)
Panel Loads
30k / 30pF
Full-scale Voltage/Current 3.5V (1.5V – 5V) / 10ȝA
Current ADC DNL/INL
0.56 LSB / 0.75 LSB
TEG

‫ڠڮ کڠڮ‬

ോ2

Max. INL = 0.75LSB

Pre-amp

1-H Time = 7.7ȝs

ODD
EVEN

Max. DNL = 0.56LSB

Fig. 9 DNL/INL of 8b C-ADC

VDDL

ോ3

500mV

500kHz, 10mVPP
GND Noise

1.5mm

ോ1
ോ2

VDDL

ോ3

‫)ۆڋڋڌ ژ ڮ ڭڃ‬

OCIC

VREF
ോ‫ڂ ڌ‬ȝോ‫ڎ‬

Current S/H

ോ‫ڂڂ ڌ‬

VDDH

Integrating
Error

Fig. 8 Measured waveform of the hybrid driving operation

vS

EVEN

vs

vRS1E
vRS1O

w. Differential Sensing

Fig. 5 Schematic and layout of two hybrid driver channels and its
operation of odd-channel TFT current sensing (ODD = H, EVEN = L)
VDDH = 5V

500mV
0V

8b CDAC
+ RCC

vRS1O
vRS1E

ESENSE

1V

‫)ٻڮ ڭ‬
TFT൪

4൚s

vPE
vPO

CP

No Error
‫)ٻڮ ڭ‬
DATA൪

VDD,EL SENSE

RP

vs
vRS1E (=I
vRS1O (=I

Amplifier
+ 3b DAC

1-H time =7.7ȝs

iNOISE

CP

INT

SW1

7b
VDAC
(PTL)

IDATA +IBIAS +iNOISE

SCAN

SENSE,
SW1,SW3

vRS1E

RS1E

IBIAS

INV

ITFT

iNOISE

SCAN

VL

7-bit
VDAC

513൚m

3bit
DAC

SW2

ITFT +IBIAS +iNOISE

VDATA
<9:3>

VH

Gm

3bit
DAC

vRS1O
ODD

RS2E
INV

1V

(S/R,
Latches,
Level
Shifters,
3b Decoder)

794൚m

VH
VL

vS

CS

10b Voltage Logic

TFT Current Error (nA)

EVEN
INT

SW3

VDDH

TINT

0V

DNL (LSB)

VDATA
<2:0>

CDATA<7:0>

8-bit
CDAC

RS2O

SW4

VDATA
<9:3>

7-bit
VDAC

VDDH = 5V

TINT

TINT

0V

10b
Voltage
Logic

INL (LSB)

OCIC
10b Voltage Logic

SMP

8b Current Logic
& SAR Controller

Two Channel Voltage Driver

CMP

IREF

TINT

SCAN

IOLED
IDATA
OCIC

SENSE

Fig. 7 Circuit-reused 8b Current-mode SAR ADC

To prevent the error between two IBIAS currents, they are swapped by the
INV signal at the middle of the Tint. Also, the nonlinearity of the CDAC
due to mismatch is also averaged over Tint by a path-swapping scheme in
[3]. The layout in Fig. 5 shows that only 55% of the conventional voltage
driver area is added for the data current generation and sensing scheme.
The OCIC in Fig. 6 integrates the voltage difference between two
resistors (RS) for better noise immunity and common noise cancelling.
After integration, the integrated voltage (vS) is applied to comparator
input. Its operation is separated by three periods: offset compensation
(TOS), integration (TINT) and sample/hold (TSH). At the TOS, the offset of a
transconductor (Gm) is sampled by an offset current S/H as a form of
current, and the following comparator simultaneously samples the VGS
mismatch of the offset current S/H and the offset of the comparator itself.
Furthermore, the offset current S/H plays the role of CMFB by sampling
common-mode error current. The vS integrated through the TINT is
sampled at the end and compared by the following comparator. The S/H
holds it during the TSH due to slow speed of the comparator. This current
sensing architecture shows offset current under 2nA with the RS of
100k and the IBIAS of 300nA in 100 samples Monte-Carlo simulation.
Circuit-reused 8b Current-mode SAR ADC
As one of the principles for the OLED degradation compensation,
correlation between luminance degradation and electrical degradation of
the OLED has been reported [4]. In order to measure those
characteristics in a short time, each column driver is required to measure
OLED current (IOLED) at a constant test voltage (VTEST) in parallel.

For this measurement, the CDAC, the OCIC and the D flip-flops for
current data latches in the driver can be reused as the components of the
current-mode SAR ADC as shown in Fig. 7. Since the SAR ADC
originally consists of a DAC, a comparator and a logic, the hybrid driver
embodies 8b current-mode SAR ADC with almost no area increase. It
takes 65.5ȝs to convert the OLED currents on a row to the digital output.
Measurement Results
The prototype of the hybrid driver IC in Fig. 10 is fabricated in
0.18ȝm CMOS. Fig. 8 shows the measured waveform of hybrid driving
under emulated panel noise of 10mVpp at 500 kHz. Without the
differential sensing method, the monotonicity of the vs during integrating
small current difference is significantly broken by the noise. In Fig. 9,
measured DNL and INL of circuits-reused 8b current-mode ADC,
determined by the CDAC nonlinearity and the OCIC accuracy,
demonstrates the robustness of the current sensing architecture. Fig. 11
shows a TFT current error curve between two TFTs, modeled by
CMOS, with 60mV VTH difference at every gray level and the curves of
reduced error after hybrid driving with random input data. When four
correction data (¨V) are assigned for every 64 channels, the maximum
error is 37nA (0.94LSB) after compensation.
Acknowledgements
This work was supported by the IC Design Education Center (IDEC).
References
[1]  J. Y. Jeon, Y. J. Jeon, Y. S. Son, K. C. Lee, H. M. Lee, S.C Jung, et al., “A
direct-type fast feedback current driver for medium-to large-size
AMOLED displays,” ISSCC Dig. Tech. Papers, pp. 174-601, Feb. 2008.
[2]  J. H. Jang, M. Kwon, E. Tjandranegara, K. Lee, B. Jung, “A Digital
Driving Technique for an 8b QVGA AMOLED Display Using ǻȈ
Modulation,” ISSCC Dig. Tech. Papers, pp. 270-271, Feb. 2009.
[3]  K. D. Kim, S. W. Lee, G. S. Park, C. B. Park, G. H. Cho, Y. K. Choi, et al.,
“A 10-bit Compact Current DAC Architecture for Large-Size AMOLED
Displays,” SID Symp. Dig. Tech. Papers, vol. 42, pp. 334-337, June 2011.
[4]  G. R. Chaji, C. Ng, A. Nathan, A. Werner, J. Birnstock, O. Schneider, et al.,
“Electrical Compensation of OLED Luminance Degradation,” IEEE
Electron Device Letters, vol. 28. No. 12, pp. 1108-1110, Dec. 2007.

2015 Symposium on VLSI Circuits Digest of Technical Papers

C327

Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence

Reformulating Temporal Action Logics in Answer Set Programming
Joohyung Lee

Ravi Palla

School of Computing, Informatics,
and Decision Systems Engineering
Arizona State University
Tempe, AZ, 85287, USA
joolee@asu.edu

Siemens Corporation
Corporate Research and Technology
Princeton, NJ, 08540, USA
ravi.palla@siemens.com

Abstract

First, the reformulation provides a new method of computing TAL using efficient answer set solvers. Several answer set solvers are actively being developed, including
those that use SAT solvers as search engines. Thus, the improvements in ASP or SAT solvers can be immediately carried over to the computation of TAL, which will benefit the
applications of TAL.
Second, in addition to action language A and many of its
descendants (Gelfond & Lifschitz 1998) that are based on
ASP, TAL can be viewed as another high-level action description language on top of ASP, which is distinct from the
others in terms of a more flexible ontology of time than the
ones adopted in action languages. Moreover, the reformulation enables us to view TAL as a high-level language for
constraint answer set solving (Gebser, Ostrowski, & Schaub
2009) that utilizes constraint variables to represent functional fluents. Typically, functional fluents in ASP are encoded in terms of predicates as in the following rule, which
represents the commonsense inertia:

Temporal Action Logics (TAL) is a class of temporal logics
for reasoning about actions. We present a reformulation of
TAL in Answer Set Programming (ASP), and discuss some
synergies it brings. First, the reformulation provides a means
to compute TAL using efficient answer set solvers. Second,
TAL provides a structured high-level language for ASP (possibly with constraint solving). Third, the reformulation allows us to compute integration of TAL and ontologies using answer set solvers, and we illustrate its usefulness in the
healthcare domain in the context of medical expert systems.

Introduction
Temporal Action Logics (TAL) (Doherty et al. 1998) is a
class of logics for reasoning about action and change that
are based on the Features and Fluents framework of Sandewall (1994). TAL supports rich features, including durative actions, durational fluents (fluents with default values),
ramification constraints, and qualification constraints. Like
several other action formalisms, TAL adopts circumscription (McCarthy 1980; 1986) to solve the frame and the ramification problems. On the other hand, unlike many others,
actions in TAL may have variable durations, and can be inert or highly dynamic during the duration. TAL has been
used in several applications, including Unmanned Aerial Vehicles (Doherty, Kvarnström, & Heintz 2009) and QuestionAnswering (Magnusson & Doherty 2008). Two implementations of TAL are available. VITAL1 supports many features
of TAL, including ramification constraints, qualification
constraints, and durational fluents. TALplanner2 (Kvarnström 2005) is an award-winning forward-chaining planner
based on TAL.
In this paper, based on the relationship between circumscription and the stable model semantics, we show how TAL
can be reformulated in Answer Set Programming (ASP), and
discuss some synergies it brings. 3

WaterLevel(t+1, tank, l) ←
WaterLevel(t, tank, l), not ¬WaterLevel(t+1, tank, l).

Using functions instead, such as WaterLevel(t, tank), does
not work under the ASP semantics for a few reasons. First,
answer sets are Herbrand models: WaterLevel(t+1, tank) =
WaterLevel(t, tank) is always false. Even when we turn to
constraint answer set solving to model functional fluents by
constraint variables, there is still a problem. A naive representation of the above in the language of the constraint ASP
solver CLINGCON4 does not correctly represent the commonsense inertia:
WaterLevel(t+1, tank) =$ l ←
WaterLevel(t, tank) =$ l, not WaterLevel(t+1, tank) 6=$ l.
(1)

The rule can be dropped without affecting the answer sets.
This is due to the fact that nonmonotonicity of the (constraint) ASP semantics is related to the minimality condition
for predicates, but has nothing to do with functions. On the
other hand, our reformulation of TAL provides an encoding
method that correctly represents functional fluents by constraint variables in the language of CLINGCON. We observe
that this method sometimes significantly improves computation time, in comparison with non-constraint encodings.

c 2012, Association for the Advancement of Artificial
Copyright 
Intelligence (www.aaai.org). All rights reserved.
1
http://www.ida.liu.se/∼jonkv/vital
2
http://www.ida.liu.se/divisions/aiics/aiicssite/projects/
talplanner.en.shtml
3
In this paper, TAL refers to the language presented in (Doherty & Kvarnström 2008), which is the latest kernel of this class
of logics.

4

786

http://potassco.sourceforge.net/

Third, our reformulation can be adapted so that answer
set solvers such as DLVHEX5 can be used for computing the
integration of TAL and ontologies, thus enabling us to use
TAL in applications where there is a need to reason about
cause-effect relationships while being able to query ontologies. For example, consider a medical expert system that is
required to assist physicians in diagnosis and treatment of
diseases/disorders. There are several biomedical ontologies,
such as the Foundational Model of Anatomy (FMA) ontology6 (Rosse & Mejino 2003), the human disease ontology7 ,
and the National Drug File (NDF) ontology8 . In order to effectively assist physicians, the expert system needs to have
access to the knowledge in such ontologies. Now, consider
a patient who is suffering from gastritis and complains of
abdominal pain. The job of the system is to determine if
aspirin can be recommended to the patient. Assume that
the biomedical ontology being queried has the knowledge
that aspirin may treat pain (written in RDF for instance) and
gastrointestinal bleeding is a contraindication for administering aspirin. Further, assume that we have the knowledge
that gastritis usually causes gastrointestinal bleeding. Now,
if the system simply considers the current patient symptoms,
it will conclude that aspirin can be prescribed. However,
since gastritis usually causes gastrointestinal bleeding, this
would not be the preferred treatment. On the other hand,
if the system considers the knowledge about the effects of
gastritis, then it will be able to conclude that aspirin is not
recommended. Thus it is clear that the system needs to consider what conditions the current patient condition might
cause and then check whether any of the conditions is a contraindication to prescribing the drug. So, in addition to being
able to query ontologies, the system also needs to be able to
reason about various cause-effect relationships. This is one
of the main motivations for integrating nonmonotonic rules
and ontologies. In contrast with those approaches, that have
to integrate heterogenous semantics, TAL can be straightforwardly extended to include interfaces to ontologies. We
show how the reformulation of TAL in ASP can be used to
turn such hybrid theories into the language of DLVHEX.

substituting the variables u for the constants p. Similarly,
SM[F ; p] is defined as the second-order formula

Review: Circumscription and Stable Models

• no occurrence of a predicate constant from p is in the antecedent of more than one implication in F , and

F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where formula F ∗ (u) is defined recursively as follows:
• pi (t)∗ = ui (t) for any tuple t of terms;
• F ∗ = F for any atomic F that does not contain members
of p;
• (F  G)∗ = (F ∗  G∗ ),  ∈ {∧, ∨};
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (QxF )∗ = QxF ∗ , Q ∈ {∀, ∃}.
A model of F (in the sense of first-order logic) is stable
(relative to the list p of intensional predicates) if it satisfies
SM[F ; p]. It is shown in (Ferraris, Lee, & Lifschitz 2011)
that this definition, applied to the syntax of logic programs
(by viewing them as a special case of first-order formulas)
and restricted to Herbrand models, is equivalent to the traditional definition of answer sets that is based on grounding
and fixpoint construction.
System F 2 LP (“formulas to logic programs”)9 (Lee &
Palla 2009; 2012) is a front-end that allows ASP solvers
to compute Herbrand stable models of “almost universal”
first-order theories (Lee & Palla 2012). The translation implemented in the system first eliminates quantifiers and then
turns the resulting quantifier-free formula into a logic program by flattening the nested subformulas.
Theorem 1 from (Lee & Palla 2012) tells us that for the
class of “canonical formulas,” the stable model semantics
coincides with circumscription. We say that an occurrence
of a predicate constant, or any other subexpression, in a
formula F is strictly positive if it is not contained in the
antecedent of any implication. For example, in formula
∀x(¬p(x) → q(x)), the occurrence of q is strictly positive
(we view ¬p(x) as shorthand for p(x) → ⊥).
We say that a formula F is canonical relative to a list p of
predicate constants if

We follow the definition of a stable model from (Ferraris,
Lee, & Lifschitz 2011). There, stable models are defined using the “stable model operator SM” with “intensional predicates,” similar to circumscription.
Let p be a list of distinct predicate constants p1 , . . . , pn
other than equality.
For any first-order formula F ,
CIRC[F ; p] is defined as the second-order formula

• every occurrence of a predicate constant from p that is in
the scope of a strictly positive occurrence of ∃ or ∨ in F
is strictly positive in F .
For example, formula ∀x(¬p(x) → q(x)) is not canonical
relative to {p, q} since it does not satisfy the first clause of
the definition. On the other hand, the formula is canonical
relative to {q}. Formula p(a, a) ∧ ∃x(p(x, a) → p(b, x)) is
not canonical relative to {p, q} since it does not satisfy the
second clause.
The following theorem states that, for any canonical formula, circumscription coincides with the stable model semantics. In other words, stable models and minimal models
coincide on canonical formulas. This result will be used to
reformulate TAL in ASP.

F ∧ ¬∃u((u < p) ∧ F (u)),
where u is a list of distinct predicate variables of the same
length as p, expression u < p stands for a formula expressing that u is “stronger than” p, as defined in (Lifschitz 1994), and F (u) is the formula obtained from F by
5

http://www.kr.tuwien.ac.at/research/systems/dlvhex/
http://sig.biostr.washington.edu/projects/fm/
7
http://www.obofoundry.org/
8
http://bioportal.bioontology.org/ontologies/40402
6

9

787

http://reasoning.eas.asu.edu/f2lp

Theorem 1 (Lee & Palla 2012, Theorem 1) For any canonical formula F relative to p,

time structure. The language uses the ternary predicates
Holds and Occurs, and the binary predicate Occlude. The
translation from L(ND) to L(FL) is given by the function Trans (Doherty & Kvarnström 2008). For instance,
Trans([t]f =ω)
ˆ
is defined as Holds(t, f, ω) (fluent f has
value ω at time t). Similarly, Trans(R((t, t0 ]f =ω))
ˆ
is defined as

CIRC[F ; p] ↔ SM[F ; p]
is logically valid.

Reformulating TAL in ASP

∀t00 (t < t00 ≤ t0 → Occlude(t00 , f )) ∧ Holds(t0 , f, ω).

Review: Temporal Action Logics
Due to lack of space, we refer the reader to (Doherty et al.
1998; Doherty & Kvarnström 2008) for the details about the
syntax and the semantics of TAL.
In TAL, a scenario (or narrative) can be described in
a compact surface language L(ND), which is a high-level
macro expandable language consisting of action type specifications (acs), dependency constraints (dep), domain constraints (dom), persistence statements (per), observation
statements (obs), and action occurrence statements (occ).
Consider the Russian Airplane Hijack (RAH) scenario (Doherty et al. 1998; Doherty & Kvarnström 2008), in which
some businessmen try to board a plane while carrying certain items in their pockets. This example demonstrates the
capability of TAL in handling the ramification and qualification problems. We only show the action type specifications for the actions Put and Board, and some dependency
constraints. The fluent PossBoard(person, airplane) is durational with default value true, and the rest of the fluents
are persistent (inertial). The direct effects of actions Put and
Board are represented by the following action type specifications:

Occlude(t, f ) represents that a persistent or durational fluent
f is exempt from inertia or default value assumption, respectively, at time t. Trans([t, t0 ]Ψ), where Ψ is an action term,
is defined as Occurs(t, t0 , Ψ), which represents that action Ψ
occurs in the interval [t, t0 ]. Following is a representation of
acs1 in the language L(FL):
Occurs(t1 , t2 , Put(person, pthing, pocket)) →
∃loc (Holds(t1 , Loc(person), loc)∧
Holds(t1 , Loc(pthing), loc)) →
∀t (t1 < t ≤ t2 →
Occlude(t, InPocket(person, pthing)))∧

Holds(t2 , InPocket(person, pthing), true) .

(2)

Consider any narrative N and let Nper , Nobs , Nocc , Nacs ,
Ndomc , and Ndepc denote the sets of persistence statements,
observation statements, action occurrence statements, action type specifications, domain constraints, and dependency
constraints in N respectively. The TAL domain description
(referred to as preferred narrative) ∆N is given by
CIRC[Γocc ; Occurs] ∧ CIRC[Γdepc ∧ Γacs ; Occlude] ∧
∧ Γf nd ∧ Γtime ∧ Γper ∧ Γobs ∧ Γdomc ,

acs1 [t1 , t2 ]Put(person, pthing, pocket)
→ ([t1 ] Loc(person)=Loc(pthing)
ˆ
→ R((t1, t2] InPocket(person, pthing))).
acs2 [t1 , t2 ]Board(person, airplane) →
[t1 ] PossBoard(person, airplane)∧
Loc(person)=Airport
ˆ
→
R([t2 ] Loc(person)=Loc(airplane)∧
ˆ

OnPlane(airplane, person)) .

(3)

where Γper , Γobs , Γocc , Γacs , Γdomc , and Γdepc are the
formulas in L(FL) (first-order logic formulas) obtained by
applying Trans on Nper , Nobs , Nocc , Nacs , Ndomc , and
Ndepc respectively; Γf nd is the set of foundational axioms
in L(FL), containing unique name axioms, unique value axioms, etc., and Γtime is the axiomatization of the particular
temporal structure used in TAL.

Reformulating Temporal Action Logics in Answer
Set Programming

(The R operator is used for reassignment, and ensures that
the formula holds at the final timepoint in the interval.) The
first statement above represents that if a person puts a thing
into his/her pocket in the time interval [t1 , t2 ] and if the location of the person is the same as the location of the thing
at t1 , then InPocket is released from inertia in the interval
(t1 , t2 ] and the thing is in the pocket at timepoint t2 (i.e.,
InPocket(person, pthing) becomes true at t2 ). The second
statement is similar. One of the qualification constraints for
the action Board is as follows:

To reformulate TAL in ASP, we first reformulate TAL in the
first-order stable model semantics and then use F 2 LP to turn
the resulting theory into ASP. The following theorem shows
how TAL can be reformulated in the first-order stable model
semantics. In the following, we use Γncirc to denote the
formula Γf nd ∧ Γtime ∧ Γper ∧ Γobs ∧ Γdomc .
Fact 1 The following facts are easy to check from the syntax
of TAL:
• Γocc is canonical relative to Occurs;
• Γdepc ∧ Γacs is canonical relative to Occlude.

dep1 [t]InPocket(person, gun)
→ I([t] ∀airplane(¬PossBoard(person, airplane))).

(The I operator is used for interval reassignment, and ensures that the formula holds during the entire interval.) This
dependency constraint represents that if a person has a gun
in his/her pocket, then he/she is not able to board any airplane.
Reasoning about a narrative in L(ND) is done by translating it into the base language L(FL), which is an ordersorted classical first-order language using a linear, discrete

The following theorem shows a reformulation of TAL in
the first-order stable model semantics.
Theorem 2 For any TAL domain description (3), the following formulas are equivalent to each other:
(a) CIRC[Γocc ; Occurs] ∧ CIRC[Γdepc ∧ Γacs ; Occlude] ∧
Γncirc

788

(b) SM[Γocc ; Occurs] ∧ SM[Γdepc ∧ Γacs ; Occlude] ∧ Γncirc
(c) SM[Γocc ∧ Γdepc ∧ Γacs ∧ Γncirc ; Occurs, Occlude] .
The equivalence between (a) and (b) follows from Theorem 1 and Fact 1. The equivalence between (b) and (c) follows from the splitting theorem from (Ferraris et al. 2009).
Formula
Γocc ∧ Γdepc ∧ Γacs ∧ Γncirc

For example, consider the persistence statement
per ∀t Per(t, WaterLevel(tank))
which represents that WaterLevel(tank) is an inertial fluent.
This is represented in L(FL) as follows:
¬Occlude(t+1, WaterLevel(tank))
→ ∀v (Holds(t+1, WaterLevel(tank), v) 
↔ Holds(t, WaterLevel(tank), v)) .

(4)

inside SM in (c) can be represented in the language of F 2 LP.
For instance, formula (2) can be represented in the language
of F 2 LP as follows:

In view of Theorem 3, this can be represented as
¬Occlude(t+1, WaterLevel(tank)) →
Val(t+1, WaterLevel(tank)) = Val(t, WaterLevel(tank)).

occurs(T1,T2,put(Pe, Pt, Po)) ->
(?[Lo]:(holds(T1,loc(Pe),Lo) & holds(T1,loc(Pt),Lo))
-> (![T]:(T > T1 & T <= T2 ->
occlude(T,inpocket(Pe,Pt))) &
holds(T2,inpocket(Pe,Pt),true))).

or in the language of CLINGCON as
val(T+1,waterLevel(Tank)) $== val(T,waterLevel(Tank))
:- not occlude(T+1, waterLevel(Tank)).

The translation implemented in F 2 LP turns the formula (4)
into a logic program (in the input language of GRINGO),
whose stable models are identical to the models of the formula in (c) when we disregard new atoms introduced in the
translation. The ability to write complex formulas in the language of F 2 LP greatly facilitates encoding efforts for TAL.
The following command can be used for computing the
answer sets of the (complete) theory encoded in the file
RAH.f2lp ([N] has to be substituted with an appropriate
value representing the maximum timepoint of interest):

In comparison with the rule (1), this example illustrates that
the TAL style encoding allows us to represent the commonsense inertia correctly in the language of CLINGCON. Our
experiments in the next section indicate that it is also computationally advantageous when fluents range over large numeric domains.

Experimental Evaluation
VITAL (“Visualization and Implementation of Temporal Action Logics”) is a tool for reasoning about actions using
TAL. The tool supports rich features in TAL, including ramification constraints, qualification constraints, and durational
fluents. It not only generates the models but also provides a
visualization of the models, which makes it easier to verify
the output and is also useful in developing TAL narratives.
The primary focus in the design of the tool was on supporting a high degree of expressivity in TAL, rather than on raw
performance.13
We compare the performance of VITAL and our ASPbased method on three scenarios. The TAL descriptions of
the Russian Airplane Hijack (RAH) and the Water Tank scenarios are provided with the VITAL distribution; we encoded
a TAL description of the Zoo World, a medium size action
domain proposed by Sandewall (Akman et al. 2004). All experiments were done on a Pentium machine with 3.06 GHz
CPU and 4GB RAM running 64-bit Linux.
Figure 1 shows the comparison of VITAL (v.2.999.910 alpha) with the following tools for the RAH and Water Tank
scenarios in language L(FL):

$ f2lp RAH.f2lp | gringo -c maxstep=[N] | claspD

TAL in Constraint ASP
The translation Trans represents functional fluents using
predicates. That is, it turns formulas of the form [t] f =ω
ˆ
into Holds(t, f, ω). This may cause a grounding bottleneck for non-Boolean domains in our ASP-based computation. Here we present how to avoid this problem by representing functional fluents by constraint variables in the
language of CLINGCON, a system that combines the ASP
solver CLINGO10 and the CP (Constraint Processing) solver
GECODE 11 .
Intuitively, since Holds is non-intensional, we can simply
replace Holds(t1 , f (x1 ), v1 ) in (4) with Val(t1 , f (x1 )) =
v1 , where Val is a new function constant. We make the idea
precise as follows. Consider a TAL narrative N and any
subset S of the set of feature symbols12 in N . If F is formula (4), by FS we denote the formula obtained from F by
replacing every occurrence of Holds(t1 , f (x1 ), v1 ), where
f ∈ S, with Val(t1 , f (x1 )) = v1 .
Theorem 3 Let N be a TAL narrative, let ∆N be the corresponding preferred narrative (3), and let F be the formula (4). Under the assumption
∀t, x, v(Holds(t, f (x), v) ↔ Val(t, f (x)) = v)
for every feature symbol f in a set S of feature symbols, SM[F ; Occurs, Occlude] is equivalent to
SM[FS ; Occurs, Occlude].

•

F 2 LP (v 1.11) with GRINGO (v 3.0.3) + CLASP (v 2.0.2),14

•

F 2 LP (v 1.11) with CLINGCON (v 0.1.2) ( GRINGO v 2.0.2
and CLASP v 1.1.1) , and

•

F 2 LP (v 1.11) with GRINGO (v 3.0.3) +
(v 3.79) running MINISAT16 (v 2.0 beta).
13

CMODELS 15

This information was provided to us by Jonas Kvarnström in a
personal communication.
14
http://potassco.sourceforge.net/
15
http://www.cs.utexas.edu/ tag/cmodels/
16
http://minisat.se/

10

http://potassco.sourceforge.net/
http://www.gecode.org/
12
The feature symbol corresponding to a fluent f (x) is f .
11

789

Problem
(max. step)

VITAL

F 2 LP with
GRINGO + CMODELS

F 2 LP with
GRINGO + CLASP

RAH-proj
(16)
RAH-proj
(50)
RAH-plan-unit
(7)
RAH-plan-unit
(10)
RAH-plan-dur
(6)
RAH-plan-dur
(9)
WaterTank-proj100 (16)
WaterTank-proj200 (25)
WaterTank-proj300 (30)

0.01s

0.23s
(0.08s + 0.15s)
0.99s
(0.32s + 0.67s)
0.13s
(0.03s + 0.1s)
0.45s
(0.1s + 0.35s)
0.3s
(0.07s + 0.23s)
0.66s
(0.13s + 0.53s)
> 30min
[0.06s]
> 30min
[0.14s]
> 30min
[0.22s]

0.13s
(0.08s + 0.05s)
0.53s
(0.32s + 0.21s)
0.08s
(0.03s + 0.05s)
0.29s
(0.1s + 0.19s)
0.11s
(0.07s + 0.04s)
0.26s
(0.13s + 0.13s)
> 30min
[0.05s]
> 30min
[0.13s]
> 30min
[0.21s]

0.05s
10.56s
> 30min
540.59s
> 30min
0.07s
0.03s
0.01s

F 2 LP with
CLINGCON

0.1s
0.35s
0.07s
0.23s
0.1s
0.33s

Problem
(max. step)

VITAL

F 2 LP with
GRINGO + CMODELS

F 2 LP with
GRINGO + CLASP

F 2 LP with
CLINGCON

ZooWorld-proj
(20)
ZooWorld-proj
(50)
ZooWorld-post
(15)
ZooWorld-post
(15)
ZooWorld-post
(20)

0.43s

0.97s
(0.39s + 0.58s)
4.85s
(2.28s + 2.57s)
0.62s
(0.24s + 0.38s)
0.59s
(0.24s + 0.25s)
0.99s
(0.41s + 0.58s)

0.80s
(0.39s + 0.41s)
4.33s
(2.28s + 2.05s)
0.51s
(0.24s + 0.27s)
0.51s
(0.24s + 0.27s)
0.82s
(0.41s + 0.41s)

0.49s

> 30min
61.63s
17.40s
477.4s

2.03s
0.33s
0.33s
0.5s

8.92s

Figure 2:

119.44s

VITAL

vs. F 2 LP + ASP solvers in the Zoo World

591.15s

As we can see from the results, VITAL performed quite
well on (almost all of) the projection problems but is not
very efficient on the planning and postdiction problems we
considered. On the other hand, our ASP-based approach performed equally well on all the problems, except on those involving numeric domains, such as the Water Tank scenario.
The results also clearly show the advantage of turning TAL
into the language of CLINGCON for handling large numeric
domains.
We also compared the performance of our method with
TALplanner. Detailed results are not shown here since the
version of TALplanner we obtained from the developer has
several features disabled. Thus, the performance of this version is not indicative of what the planner is actually capable of. Further, the performance of TALplanner heavily depends on the quality of control rules used, while ASP-based
planning typically does not make use of control rules but
works with reasonable efficiency. Also, the main search
method of TALplanner is depth-first search, which provides
no guarantee of optimality. Having said that, the experiment
showed that TALplanner was considerably faster than our
ASP-based method for planning tasks. On the other hand,
the plans generated by TALplanner were often much longer
than the minimal length plans generated by our ASP-based
method.

Figure 1: Comparison of VITAL with F 2 LP + ASP solvers
The times shown in the parentheses are “(grounding time
+ solving time).” The cut-off time we used for the tools to
terminate and return one model is 30 minutes.
For the RAH scenario, the first two problems are projection problems and the next four are planning problems.
Among the planning problems, the first two consider all actions to be of unit duration, and the next two consider actions
with fixed lower and upper bounds on their durations. For
each planning problem, “max.step” is also the minimal
length of the plan found. While VITAL is in general not as
efficient as TALplanner on planning problems, it allows us
to represent domains, such as the RAH scenario, which involve ramification and qualification constraints, that are not
allowed in TALplanner. For the Water Tank scenario, the
number in the problem name is the maximum value in the
domain of the numbers considered. For instance, the number domain used for “WaterTank-proj-100” is 0..100. The
times reported in square brackets is when we removed the
unique value axioms (“a fluent has exactly one value at each
timepoint”), and instead added axioms that uniquely define
the value of each fluent at every timepoint. Such rewriting
works for this particular scenario, and drastically improves
the performance. For example,

Hybrid Temporal Action Logic Theories
Description logics form a basis of the Web Ontology Language (OWL). We consider how to integrate TAL with description logic based ontologies. Since both of them are
based on classical logic, the integration is straightforward.

% unique value axiom
1{holds(T,waterlev(Tank),Number):num(Number)}1.
% constraint for determining next water level
-(holds(T,waterlev(Tank),Nu1)
& holds(T,inflow(Tank),Nu2)
& ...
& -holds(T+1,waterlev(Tank),Nu4)).

Definition 1 Let ΣΓ and ΣT be signatures which agree on
common constants. A hybrid action theory (Γ, T ), where
Γ is a TAL domain description of signature ΣΓ and T is
a description logic knowledge base of signature ΣT , is the
conjunction Γ∧FO(T ) of signature ΣΓ ∪ΣT , where FO(T )
is the first-order logic representation of T .
Consider the example discussed in the introduction. Following is a partial TAL description of the domain in the surface language. Admin(d) represents the action of drug d being administered. For simplicity, the duration of the action
is assumed to be equal to the time taken for the effects of the
drug to wear off. Fluent Condition(c) is used to represent
if the patient is currently suffering from disease/disorder c,
and fluent SideEffect(d) is used to represent if the drug d
has a side-effect on the patient. The predicates in all capitals
(MAY TREAT, MAY PREVENT, and CONTRAINDICATION) are

can be turned into
(holds(T,waterlev(Tank),Nu1)
& holds(T,inflow(Tank),Nu2)
& ...
-> holds(T+1,waterlev(Tank),Nu4)).

As the results show, this simple modification has a significant impact on the times taken by GRINGO + CLASP and
GRINGO + CMODELS in returning an answer set.
Figure 2 shows the comparison with VITAL for the Zoo
World scenario. The first two are projection problems, and
the remaining are postdiction problems.

790

description logic predicates (properties in the ontologies),
and are time-independent. MAY TREAT(d, c) represents that
drug d may treat c, MAY PREVENT(d, c) represents that drug
d may prevent c, and CONTRAINDICATION(d, c) represents
that c is a contraindication for administering drug d. The
fluents Ab1 and Ab2 are used to represent the abnormalities,
and these are treated as durational fluents with default value
false. The other fluents are persistent.

resented in OWL: the NDF ontology (NDF-RT2 public edition), which contains knowledge about drugs (i.e., what they
may treat, prevent, the contraindications for the drugs, etc.),
and the human disease ontology (alpha version), which contains knowledge about human diseases (such as definitions
of the diseases, synonyms of the diseases, etc.). The NDF
ontology has over 40,000 classes and the human disease ontology has over 8000 classes.
We encode the TAL description in F 2 LP and use
the rdf plugin for DLVHEX to generate the relevant instances of the Description Logic atoms MAY TREAT(d, c),
MAY PREVENT(d, c), and CONTRAINDICATION(d, c). Since
F 2 LP only outputs programs in the language of GRINGO and
LPARSE , we implemented a python program f2lpdlv.py
to turn the output of F 2 LP into the language of DLV17 . Also,
since DLVHEX (v.1.7.2) does not allow functions, we flatten atoms (e.g., holds(T, condition(C), V) is turned into
holds(T, condition, C, V)).
For the above example, we add the following observations
and query:

acs1 [t1 , t2 ] Admin(d) →

[t1 ] Condition(c) ∧ ¬Ab1 (d, c)∧
(MAY TREAT(d, c) ∨ MAY PREVENT(d, c))∧
¬∃c1 , t t1 ≤ t ≤ t2 ∧ [t] Condition(c1 )∧


CONTRAINDICATION(d, c1 ) → I((t1 , t2 ] ¬Condition(c)) .
acs2 [t1 , t2 ] Admin(d) →
∀t t1 ≤ t ≤ t2 ∧
[t]∃c(Condition(c) ∧ CONTRAINDICATION(d, c))
→ I([t, t2 ] SideEffect(d)) .
dep1 ∀t([t] Condition(Gastritis) ∧ ¬Ab2 (Gastritis) →
R([t + 1] Condition(GastrointestinalBleeding))).

%initial state
gastritisId(X) -> holds(0,condition,X,true).
painId(X) -> holds(0,condition,X,true).
giBleedingId(X) -> holds(0,condition,X,false).
drug(D) -> holds(0,sideEffect,D,false).

The first statement represents that if no contraindication
to the drug d holds in the interval [t1 , t2 ], then administering
d, which may treat or may prevent c, usually has a positive effect on the patient who is suffering from c. The second statement represents that if a contraindication to drug
d holds in the interval [t1 , t2 ], then administering d in that
interval causes a side-effect. Finally, the dependency constraint represents that gastritis usually causes gastroinstestinal bleeding. This example shows the usefulness of the durative actions and dependency constraints available in TAL.
Given that Condition(Gastritis) and Condition(Pain)
hold at timepoint 0, and the ontology being queried
entails
the
facts
MAY TREAT(Aspirin, Pain)
and
CONTRAINDICATION(Aspirin, GastrointestinalBleeding),
one can verify the following from the above description:

% query: can aspirin be given to the patient?
aspirinId(X) -> occurs(0,2,admin,X).
painId(C) & aspirinId(X) ->
-(holds(2,condition,C,false) &
-?[T]: (T >=0 & T <=2 &
holds(T,sideEffect,X,true))).

The predicates ending with Id represent the class names
(in the NDF) of the corresponding drug or condition. For instance, the extent of painId contains just one element and
that element is the class name of the class with label Pain.
The first formula following the initial state description represents that Aspirin is administered in the interval [0, 2], and
the second formula is the negation of the query we want to
check. The query here is to check if administering Aspirin
treats the pain such that no side-effect is caused in the interval [0, 2].
Following is a part of an answer set produced when the
maximum timepoint is set to 2 (the existence of an answer
set indicates that the query is not entailed):

• Condition(GastrointestinalBleeding) is true for all timepoints τ ≥ 1;
• if Admin(Aspirin) occurs in the interval [0, 2], then
SideEffect(Aspirin) is true for all timepoints τ ≥ 1.
Thus, the system will conclude that Aspirin is not recommended.
Now, consider an initial state in which only
Condition(Pain) is true and the rest of the fluents are false.
Further, assume that neither
Condition(GastrointestinalBleeding) nor any other contraindication to administering aspirin is caused in some
interval [τ1 , τ2 ]. If Admin(Aspirin) occurs in the interval
[τ1 , τ2 ], then Condition(Pain) is false for all τ > τ1 and
no side-effect will be caused. So, the system will be able
to conclude that Aspirin can be recommended, unless a
contraindication to it may be caused in the interval that it is
to be administered.

{holds(0,condition,"<NDF#N0000001314>",true),
holds(0,condition,"<NDF#N0000002278>",true),
holds(1,condition,"<NDF#N0000001482>",true),
holds(1,condition,"<NDF#N0000001314>",true),
holds(1,condition,"<NDF#N0000002278>",true),
holds(1,sideEffect,"<NDF#N0000145918>",true),
holds(2,condition,"<NDF#N0000001482>",true),
holds(2,condition,"<NDF#N0000001314>",true),
holds(2,condition,"<NDF#N0000002278>",true),
holds(2,sideEffect,"<NDF#N0000145918>",true)}

Using DLVHEX to Compute Hybrid Theories

Here, N0000001314, N0000002278, N0000001482, and
N0000145918 are the class names corresponding to

We use the answer set solver DLVHEX for reasoning about
hybrid theories as it allows for integrating with external ontologies. In our experiments, we use two ontologies rep-

17

791

http://www.dlvsystem.com/

Gastritis, Pain, Gastroinstestinal Bleeding, and Aspirin respectively. Also, NDF is an abbreviation for the namespace
of the ontology. This output indicates that a side-effect is
caused at timepoint 1 and that administering aspirin in the
interval [0, 2] does not relieve pain. Running the same query
with the drug acetaminophen instead of aspirin produces no
answer set, which indicates that acetaminophen can be recommended.
We also tested some other examples, details of which are
available on the F 2 LP webpage.

Ferraris, P.; Lee, J.; and Lifschitz, V. 2011. Stable models
and circumscription. Artificial Intelligence 175:236–263.
Gebser, M.; Ostrowski, M.; and Schaub, T. 2009. Constraint answer set solving. In Proceedings of International
Conference on Logic Programming (ICLP), 235–249.
Gelfond, M., and Lifschitz, V. 1998. Action languages19 .
Electronic Transactions on Artificial Intelligence 3:195–
210.
Kim, T.-W.; Lee, J.; and Palla, R. 2009. Circumscriptive
event calculus as answer set programming. In Proceedings
of International Joint Conference on Artificial Intelligence
(IJCAI), 823–829.
Kvarnström, J. 2005. TALplanner and other extensions to
temporal action logic. PhD thesis, Linköping University,
Linköping Studies in Science and Technology, Dissertation
No. 937.
Lee, J., and Palla, R. 2009. System F 2 LP – computing answer sets of first-order formulas. In Procedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 515–521.
Lee, J., and Palla, R. 2010. Situation calculus as answer set
programming. In Proceedings of the AAAI Conference on
Artificial Intelligence (AAAI), 309–314.
Lee, J., and Palla, R. 2012. Reformulating the situation
calculus and the event calculus in the general theory of stable
models and in answer set programming. Journal of Artificial
Inteligence Research (JAIR) To appear.
Lifschitz, V. 1994. Circumscription. In Gabbay, D.; Hogger, C.; and Robinson, J., eds., Handbook of Logic in AI and
Logic Programming, volume 3. Oxford University Press.
298–352.
Magnusson, M., and Doherty, P. 2008. Temporal action
logic for question answering in an adventure game. In
In Proc. 1st Artificial Game Intelligence (AGI) Conference,
236–247.
McCarthy, J. 1980. Circumscription—a form of non-monotonic reasoning. Artificial Intelligence 13:27–39,171–172.
McCarthy, J. 1986. Applications of circumscription to formalizing common sense knowledge. Artificial Intelligence
26(3):89–116.
Rosse, C., and Mejino, J. L. V. 2003. A reference ontology for biomedical informatics: the foundational model of
anatomy. Journal of Biomedical Informatics 36(6):478–500.
Sandewall, E. 1994. Features and Fluents, volume 1. Oxford University Press.

Conclusion
Our reformulation of TAL in ASP is based on the same idea
as the reformulations of the event calculus and the situation
calculus in ASP (Kim, Lee, & Palla 2009; Lee & Palla 2010;
2012). On the other hand, it is distinct from the earlier
work as it shows that functional fluents in TAL can be represented by constraint variables in constraint answer set solving. Also, it shows that an answer set solver like DLVHEX
can be used for computing the integration of TAL with ontologies, thereby allowing expressive reasoning about dynamic systems while also being able to query ontologies.
We expect that the techniques developed in this paper can
be applied to other action calculi as well.

Acknowledgements
We are grateful to Jonas Kvarnström for his help on using VITAL and TALPlanner, and for answering our related
questions. We are also grateful to the anonymous referees
for their useful comments. This research was partially supported by the National Science Foundation under Grant IIS0916116 and by Siemens Corporate Research. The work
was done when the second author was at Arizona State University.

References
Akman, V.; Erdoğan, S.; Lee, J.; Lifschitz, V.; and Turner,
H. 2004. Representing the Zoo World and the Traffic World
in the language of the Causal Calculator. Artificial Intelligence 153(1–2):105–140.
Doherty, P., and Kvarnström, J. 2008. Temporal action logics. In van Harmelen, F.; Lifschitz, V.; and Porter, B., eds.,
Handbook of Knowledge Representation. Elsevier Science.
709–757.
Doherty, P.; Gustafsson, J.; Karlsson, L.; and Kvarnström, J.
1998. TAL: Temporal action logics language specification
and tutorial18 . Linköping Electronic Articles in Computer
and Information Science ISSN 1401-9841 3(015).
Doherty, P.; Kvarnström, J.; and Heintz, F. 2009. A temporal logic-based planning and execution monitoring framework for unmanned aircraft systems. Autonomous Agents
and Multi-Agent Systems 19(3):332–377.
Ferraris, P.; Lee, J.; Lifschitz, V.; and Palla, R. 2009. Symmetric splitting in the general theory of stable models. In
Proceedings of International Joint Conference on Artificial
Intelligence (IJCAI), 797–803.
18

19

http://www.ep.liu.se/ea/cis/1998/015/

792

http://www.ep.liu.se/ea/cis/1998/016/

1116

IEEE COMMUNICATIONS LETTERS, VOL. 17, NO. 6, JUNE 2013

Energy Efficient Scalable Video Coding Based
Cooperative Multicast Scheme with Selective Layer Forwarding
Joohyung Lee, Byung Chul Yeo, Ji-Su Kim, Min Seok Jang Student Member, IEEE,
and Jun Kyun Choi, Senior, IEEE
Abstract—Scalable Video Coding (SVC) based multicast
schemes have been researched for many years in efforts to
simultaneously achieve high throughput and good fairness, which
have a trade-off relationship in multicast communication. In an
SVC based multicast, all group members in a good channel
condition can receive both base layer and enhancement layer
information and thus can recover high quality video, while other
group members receive the base layer information for guaranteeing basic quality video. However, this causes differentiation
of video quality between group members with varying channel
conditions, and average video quality is consequently degraded.
We propose an Energy Efficient SVC based cooperative multicast
(EE-SVC-CM) scheme with selective layer forwarding as a novel
approach to mitigate this problem. The performance results
reveal that the proposed scheme enhances the overall energy
efficiency (throughput per watt) with reduced unnecessary relay
power consumption.
Index Terms—Scalable video coding, cooperative communications, multicast scheduling, energy consumption.

I. I NTRODUCTION

W

ITH the deployment of wireless broadband connectivity and increasing demand to share entertainment
multimedia over wireless networks around the world, multicast
communication technology that transmits the same content
to multiple users has emerged as a key technology in next
generation cellular networks [1].
To date, most research related to multicast communication have focused on solving the problem of the trade-off
relationship between fairness of group members and overall
throughput. Recently, to improve both fairness and throughput
simultaneously, Scalable Video Coding (SVC) based multicast
schemes have been proposed. In an SVC based multicast, a
multimedia stream is layered hierarchically. Here, the basic
quality of the video stream is achieved by providing the
user with the base layer. Moreover, higher quality can be
achieved by provisioning the base layer and enhancement
layers together. Therefore, SVC based multicast provides a
degree of freedom to exploit different user conditions [2].
In the area of wireless communication, research on SVC
based multicast schemes has been conducted for throughput
adaption with adaptive modulation and allocation of different

Manuscript received January 9, 2013. The associate editor coordinating the
review of this letter and approving it for publication was H. Yomo.
This work was supported by the IT R&D program of MKE/KEIT
(10039160).
J. Lee, B. C. Yeo, M. S. Jang, and J. K. Choi are with the Dept. of Electrical
Engineering, KAIST, Daejeon, 305-701 Rep. of Korea (e-mail: {joohyung08,
yobc401, jkchoi59}@kaist.ac.kr, chaiosjang@gmail.com).
J. S. Kim is with the School of Electrical and Computer Engineering, Ajou
University, Suwon, Republic of Korea (e-mail: soo@ajou.ac.kr).
Digital Object Identifier 10.1109/LCOMM.2013.050313.130062

%QXGTCIGQH
%QXGTCIGQH

Relay (L3)
rU

Relay (L2)

BS

r3
r2

r1

%QXGTCIGQH
.C[GT 
DCUG NC[GT
.C[GT
GPJCPEGOGPVNC[GT
%QXGTCIGQH.C[GT

2TQRQUGF''58%%/5EJGOG

Fig. 1. System model for scalable video coding based cooperative multicast
scheme

sizes of Forward Error Correction (FEC) bits [3], [4]. However, SVC based multicast schemes cause differentiation of
video quality between group members with varying channel
conditions, and the average video quality is consequently
degraded.
Recently, there are a few studies on cooperative communication approaches in the SVC based multicast to mitigate
this problem [5], [6]. Randomized Distributed Space Time
Code (R-DSTC) based cooperative layered video multicast
is proposed in [5]. The authors conducted the performance
study in terms of received video quality on the physical layer.
On the other hand, our work studies medium-access-control
(MAC) layer cooperation in wireless multicast (the MAC layer
cooperation and R-DSTC are complementary to each other).
The work in [6] proposes a scalable video multicast in hybrid
3g and ad-hoc networks. However, this approach requires the
use of a second radio as well as constructing the routing table
for cooperation. Thus it might require the additional signaling
cost and delay for the routing table. Furthermore, even though
relay users should pay for additional relay power consumption
for user cooperation [1], [7], to the best of our knowledge,
all the previous work does not consider the impact of energy
efficiency for relay.
Therefore, this letter addresses the challenges of energy
efficient multicast design by proposing a novel approach. The
key contributions of this letter are:
• We propose a novel energy efficient multicast scheme
with layered video coding. In detail, 1) we design the
SVC based multicast on two-phase cooperative communication and 2) to reduce unnecessary relay power
expenditure, we develop the selective layer forwarding
by considering the nearby user condition.
• Based on a probabilistic approach, we provide detailed
analytical model to estimate the power consumption of
the relay as well as average throughput in the proposed
scenario.
• Numerical results are provided for demonstrating the
effectiveness of the proposed Energy Efficient SVC based

c 2013 IEEE
1089-7798/13$31.00 

LEE et al.: ENERGY EFFICIENT SCALABLE VIDEO CODING BASED COOPERATIVE MULTICAST SCHEME WITH SELECTIVE LAYER FORWARDING

cooperative multicast (EE-SVC-CM) scheme in terms of
energy efficiency and fairness relative to the existing solution with reduced unnecessary relay power consumption.

rU

II. S YSTEM M ODEL AND E NERGY E FFICIENT S CALABLE
V IDEO C ODING BASED C OOPERATIVE M ULTICAST
(EE-SVC-CM) S CHEME
Our scheme follows a two-phase cooperative communication: a transmission burst assigned for multicast transmission
in the same channel is divided into two phases; in phase I, the
BS transmits the data to the users; in phase II, the users who
successfully received the data in phase I forward the received
data to the other users [1], [7]. Therefore, a multicast data
divided into base layer and enhancement layer data is delivered
from the BS to the users in phase I. Here, users closer to the
BS will receive more enhancement layers from the BS. Then,
they can forward those layers to users in Multicast Group
(MGroup) further away from the BS in phase II.
Fig. 1 depicts the overall system model for the EE-SVC-CM
scheme as with three layers of SVC video, denoted by L1, L2,
and L3 (for convenience, they correspond with the terms “base
layer” and “enhancement layer 1 and 2”, respectively. Also,
certain layer i is denoted by Li). In addition, the coverage of
Li is denoted by ri . To maintain the minimum quality for all
users, L1 should cover the entire cell with the coverage r1
[6].
In phase I, users in the coverage r1 receive the L1 from
the BS (Note that users in the coverage ri are not located
in the coverage rj (for ∀j > i)). And, users in the coverage
r2 receive the L1 and L2 from the BS. Similarly, users in
the coverage r3 receive all three layers from the BS. In
phase II, the selective layer forwarding will be conducted.
Detailed procedures are done in two steps: 1) each user finds a
relay user in its transmission boundary to download additional
enhancement layers. For example, users in the coverage r1
should find nearby users in the coverage r2 or r3 to acquire
additional enhancement layers (L2 or L3). 2) helpers merge
relay requests from nearby users and forward enhancement
layers by multicast. So, even though a helper receives multiple
requests for same layer, it only needs single time slot to
forward certain layer. To support the proposed scenario, we
added the beacon frame between phase I and phase II. Hence,
the total time frame is divided into three parts such as the
phase I, the beacon frame, and the phase II. Here, the beacon
frame is divided into two stages. In the first stage, the BS
multicasts the beacon frame to determine which user needs
to acquire additional layers from helpers. In the second stage,
to find nearby helpers and request relay, users who need to
acquire additional layers broadcast the beacon frame including
the required layer information as the response to previous
inquiry. Furthermore, in order to avoid the interference from
transmitting different layers at the same time, we conducted
each layer to be transmitted at a different time period at phase
II based on Time Division Multiple Access (TDMA).
In the proposed scenario for EE-SVC-CM scheme, the users
can share the layers by using beacon frame in a distributed
manner. For providing a simple method with low complexity,
the proposed scheme does not require any coordination for

x

rj

ri

T2

1117

rU

T1

I2

I1
x

A(ri , x, rU )

B (rj , x, rU )


D4GNC[
RTQDCDKNKV[


C(KPFKPI
RTQDCDKNKV[

Fig. 2. The overlapped area analysis for (a) finding probability and (b) relay
probability
TABLE I
S UMMARY OF NOTATIONS
Notations

Explanation

x

distance of the user to the BS

Pf ind,i

probability that a certain user in the coverage rx (rx
> ri ) will find a nearby user in the coverage ry (ry
≤ ri ) to obtain Li

Prelay,i

probability that a certain user in the coverage rx (rx
≤ ri ) will find a nearby user in the coverage ry (ry
> ri ) who did not receive Li in phase I to relay Li

T hM

system throughput of the proposed EE-SVC-CM
scheme for M users

finding optimal relay or reducing the number of relay. So,
if a user received requests of relay from different users (e.g.
requesting a different layer) simultaneously, this user should
serve different users without denying the request. And, if one
user in the coverage r1 is located within the range of two or
more users in the coverage r2 or r3 at the same time (i.e.,
overlapped range), all those users in the coverage r2 or r3
should transmit the data in the proposed scheme.
III. P ERFORMANCE A NALYSIS
We consider a cellular system with a cell radius rc . The total
M active users are uniformly distributed with a probability
density function (pdf) of distance x from the BS, which is
expressed as
fx (x) =

2x
,
rc2

0 < x ≤ rc .

(1)

We assume that the transmitted signals only experience path
loss to simplify the analysis as in [8], where users in MGroup
receive thermal noise (Prxn ) with a constant channel gain G.
Finally, the SNR value z at the receiver is expressed as
z(x) = G ×

1
PBS
×
n
x
Prxn

(2)

where, PBS is the BS transmission power and n is the path
loss component.
In order to get the effective coverage of Li, we can ensure
that a user existing within a radius ri should satisfy the
following condition.
z(ri ) ≥ SN RT H,i

(3)

1118

IEEE COMMUNICATIONS LETTERS, VOL. 17, NO. 6, JUNE 2013

where, SN RT H,i is the target SNR for Li. It could be
calculated by Shannon’s laws according to the data rate (Rli )
which is the data rate of Li.
A. System throughput of MGroup for proposed Energy Efficient SVC-CM scheme
We address the finding probability with the detailed explanation in Table I. Assume that one user is x distance
away from the BS out of the coverage of Li shown in Fig.
2(a). In order to obtain Pf ind,i , we first note the conditional
probability (Pf ind,i|x ) for finding the nearby relay user who
receive Li in phase I. Because the probability that there exists
i ,x,rU )
with
a relay for Li in the transmission boundary is A(rπr
2
c
the detailed calculation procedure in Appendix, there exists at
least one user who has Li with a given user’s transmission
boundary as follows:
A(ri , x, rU ) M−1
)
.
(4)
Pf ind,i|x = 1 − (1 −
πrc2
where, rU is the relay transmission coverage of a user.
Therefore, from (4), Pf ind,i is expressed as
 rc
Pf ind,i =
fx (x) · Pf ind,i|x dx.
(5)
ri

Given three cumulative layered encoding of the video, i.e,
(k)
1 ≤ i ≤ m (m=3), Let Rli and Ti be the Li’s data rate in
phase k and time duration for Li, respectively. Corresponding
to this, let Rcli and ti respectively be the data rate and
time duration of conventional SVC based multicast for Li.
Basically, in the proposed scheme, since BS only transmits the
data in phase I, in order to compensate the reduced time slot of
BS transmission by taking an advantage of relay, the proposed
scheme uses the higher data rate than conventional scheme to
R
(1)
transmit the data, i.e, Rli > Rcli . Then, Ti = ti · Rcll i in
(2)

R

i

phase I, and Ti = ti · (1 − Rcll i ) in phase II should be
i
satisfied. Thus, system throughput for the proposed EE-SVCCM scheme, which is achieved by M users in the cell, is given
by
m

r2
(1)
(2)
M·
( ri2 · Ti · Rli + Pf ind,i · Ti · Rli )
c
i=1
(6)
T hM =
T (1) + T (2)
m

(k)
Ti .
where, T (k) =
i=1

B. Relay power consumption of proposed Energy Efficient
SVC-CM scheme
Next, we show the relay probability with the detailed
explanation in Table I. As similar approach to obtain Pf ind,i
(5)-(6), assume that one user, which is x distance away from
BS, exists in the coverage of Li as shown in Fig. 2(b). We
observe the probability that there exists nearby users who do
not have the Li by using the area B(ri , x, rU ) with the detailed
calculation procedure in Appendix. Thus, Prelay,i is calculated
as follows:


M−1 
ri
B(ri , x, rU )
fx (x) · 1 − 1 −
dx
P relay,i =
πrc2
ri −rU

(7)

TABLE II
S YSTEM PARAMETERS
System Parameters

Value/Assumption

Channel bandwidth and gain

10 MHz and 0.023568

Transmission power of BS

43 dBm

Transmission power of users in MGroup

23 dBm

Pass loss exponent n and noise power

4.375 and -128 dBm/HZ

Data rate for L1

256kbps (QPSK 1/2)

Data rate for L2

(a) 512kbps (16QAM 1/2) (b)
768kbps (16QAM 3/4)

Data rate for L3

(a) 1024kbps (64QAM 2/3) (b)
1152kbps (64QAM 3/4)

* QPSK : Quadrature phase-shift keying
* QAM : Quadrature amplitude modulation
(a) : data rate for the conventional SVC
(b) : data rate for the proposed schemes

Furthermore, relay power consumption PM is expressed as
the following:
PM = M ·

m


(2)

(Prelay,i · Pt · Ti )

(8)

i=1
(2)

where, Pt and Ti are a transmission power of the mobile
terminal and a transmission time to relay Li in phase II,
respectively. Thus, we can determine the total power consumption in the EE-SVC-CM scheme which includes the BS power
consumption (PBS ) with varying multiple layered coding and
PM .
IV. P ERFORMANCE E VALUATION
In this section, we evaluate the performance of the proposed
SVC-CM 1) with or 2) without selective layer forwarding (denoted as 1) EE-SVC-CM 2) SVC-CM) scheme, conventional
SVC based multicast scheme (denoted as SVC-M), and the
scheme specified in 3GPP (denoted as C3GP P ). Specifically,
the proposed SVC-CM without selective layer forwarding does
not have the beacon frame used to determine which user needs
to acquire additional layer from helpers. So, all users who
receive any enhancement layer (e.g., L2 or L3) in phase I
should be helpers and broadcast all enhancement layers without consideration of nearby users. We first analyze numerically
with the parameters shown in Table II [1], [7]. We assume that
the probability of relay failure is almost 0.01 [1]. To further
justify our proposed solution, we conduct an OPNET-based
simulation that includes more realistic interference effects.
With C3GP P , BS serves all users in MGroup with the
same transmission rate which should ensure the successful
transmissions of the worst channel users. On the other hand,
SVC based multicast provides users in MGroup with different
quality of video based on their channel condition by using
multi-layered coding. It utilizes the whole time slot only for
the BS transmission without user cooperation in contrast to
the proposed schemes (EE-SVC-CM and SVC-CM scheme).
Since 20% bandwidth overhead for layered encoding of video
is included when comparing non-layered encoding of video,
for fair comparison between non-layered encoding based
scheme (C3GP P ) and layered encoding based scheme (SVC-M

LEE et al.: ENERGY EFFICIENT SCALABLE VIDEO CODING BASED COOPERATIVE MULTICAST SCHEME WITH SELECTIVE LAYER FORWARDING

1

0.6

0.4

0.2

SVC−M

EE−SVC−CM

60

SVC−CM(sim)
SVC−CM
EE−SVC−CM(sim)
EE−SVC−CM

59

58

57

56

55

54

53
80

90

100

110

120

130

140

150

2500

EE−SVC−CM
EE−SVC−CM(sim)
SVC−CM
SVC−CM(sim)
SVC−M
SVC−M(sim)
C3GPP
C

(sim)

3GPP

2000

1500

1000

500
80

Number of Users In a MGroup

(a)
Fig. 3.

Energy Efficiency (kBps/Watt)

Relay Power Consumption (Watt)

System Fairness

0.8

0

3000

61

Numerical Result
OPNET Simulation

1119

90

100

110

120

130

140

150

Number of Users In a MGroup

(b)

(c)

(a) system fairness (b) relay power consumption and (c) energy efficiency versus the total number of group members

scheme and proposed schemes), we assume that if a receiver
receives and decodes all layers, the quality of the video will be
the same as that of a non-layered video stream [9]. Hence, we
calculate the amounts of received data for layered-encoding
video stream with consideration of bandwidth overhead.
Fig. 3(a) depicts the system fairness under the proposed
EE-SVC-CM and the SVC-M scheme (M =120). We consider
the Jain’s fairness index as the well known fairness metric
presented in Appendix. In this metric, absolute fairness is
achieved when the value of the index is 1. As shown this
figure, the fairness of the proposed EE-SVC-CM scheme
is larger than that of the SVC-M scheme since the user
cooperation with selective layer forwarding can support the
bad channel users and achieve high system fairness. In Fig.
3(b), we observe the relay power consumption of EE-SVC-CM
and SVC-CM scheme. Then, the relay power consumption of
the EE-SVC-CM scheme is smaller than that of the SVC-CM
scheme since the proposed EE-SVC-CM scheme additionally
reduces the unnecessary relay power consumption by selecting
layers to forward with consideration of the nearby users. For
instance, without selective relay, users who receive the L2
or L3 always conduct relay without consideration of nearby
users which makes unnecessary relay power consumption.
Next, we show the energy efficiency (kbps/watt) versus the
total number group members in Fig. 3(c). We compute the
system throughput in the cell (the summation of each users’
throughput in the cell) per total power consumption (PM
+ PBS ) for the energy efficiency. Fig. 3(c) represents that
C3GP P scheme has the worst performance because BS should
ensure the service of the worst channel users in MGroup with
the lowest transmission rate. On the other hand, the SVC-M
scheme outperforms C3GP P scheme by supporting channeldependent service with layered coding. And, as shown here,
the proposed EE-SVC-CM and SVC-CM scheme outperform
the other schemes since relay users play a role in alleviating
power consumption of the BS by supporting bad channel users
as well as high throughput. Furthermore, proposed EE-SVCCM scheme is more energy-efficient than SVC-CM since the
relay power consumption of EE-SVC-CM scheme is less than
that of SVC-CM scheme.
V. C ONCLUSION
In this letter, we have proposed a novel scalable video
coding based cooperative multicast scheme with selective
layer forwarding. Using the proposed scheme, we can achieve

enhanced overall energy efficiency with minimal relay power
expenditure.
A PPENDIX
Based on [8], A(ri , x, rU ) in Fig. 2(a) is calculated by
2
θ2 − xri sin θ1
A(ri , x, rU ) = ri2 θ1 + rU

(9)

r 2 +x2 −r 2

θ1
)
where, θ1 = cos−1 ( i 2ri x U ) and θ2 = sin−1 ( ri sin
rU
And, B(rj , x, rU ) in Fig. 2(b) is calculated by
2
φ2 − rj2 φ1 + xrj sin φ1
B(rj , x, rU ) = rU
r 2 +x2 −r 2

(10)

r sin φ

where, φ1 = cos−1 ( j 2rj x U ) and φ2 = sin−1 ( j rU 1 ).
- Jain’s fairness metric


2
(
user s throughput)2 /(M ·
user s throughput )
user

user

(11)
R EFERENCES
[1] J. Lee, Y. M. Lim, K. Kim, S. G. Choi, and J. K. Choi, “Energy efficient
cooperative multicast scheme based on selective relay,” IEEE Commun.
Lett., vol. 11, no. 3, pp. 386–388, Mar. 2012.
[2] C. Suh and J. Mo, “Resource allocation for multicast services in multicarrier wireless communications,” IEEE Trans. Wireless Commun., vol. 7,
no. 1, pp. 27–31, Jan. 2008.
[3] M. van der Schaar, S. Krishnamachari, S. Choi, and X. Xu, “Adaptive
cross-layer protection strategies for robust scalable video transmission
over 802.11 WLANs,” IEEE J. Sel. Areas Commun., vol. 21, no. 10, pp.
1752–1763, Dec. 2003.
[4] W. T. Tan and A. Zakhor, “Video multicast using layered FEC and
scalable compression,” IEEE Trans. Circuits Syst. Video Technol., vol. 11,
no. 3, pp. 373–386, Mar. 2001.
[5] O. Alay, P. Liu, Z. Guo, L. Wang, Y. Wang, E. Erkip, and S. Panwar,
“Cooperative layered video multicast using randomized distributed space
time codes,” in Proc. 2009 IEEE INFOCOM Workshops, pp. 1–6.
[6] S. Hua, Y. Guo, Y. Liu, H. Liu, and S. S. Panwar, “Scalable video multicast in hybrid 3G/ad-hoc networks,” IEEE Trans. Multimedia, vol. 13,
no. 2, pp. 402–413, Apr. 2011.
[7] F. Hou, L. X. Cai, P. H. Ho, X. Shen, and J. Zhang, “A cooperative
multicast scheduling scheme for multimedia services in IEEE 802.16
networks,” IEEE Trans. Wireless Commun., vol. 8, no. 3, pp. 1508–1519,
Mar. 2009.
[8] J. Y. Song, H. J. Lee, and D. H. Cho, “Power consumption reduction by
multi-hop transmission in cellular networks,” in Proc. 2004 IEEE VTC,
pp. 3120–3124.
[9] T. Kim, “Scalable video streaming over the Internet,” thesis paper,
Georgia Institute of Technology, 2005.

Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence

Answer Set Programming Modulo Theories and
Reasoning about Continuous Changes
Joohyung Lee and Yunsong Meng
School of Computing, Informatics and Decision Systems Engineering
Arizona State University, Tempe, USA
{joolee, Yunsong.Meng}@asu.edu
Abstract

grounding rule (1) yields a large set of ground instances when
Speed ranges over a large integer domain. Moreover, a real
number domain is not supported because grounding cannot
be applied.
In order to alleviate this “grounding problem,” there have
been several recent efforts to integrate ASP with constraint
solving and satisfiability modulo theories (SMT), where functional fluents can be expressed by variables in Constraint Satisfaction Problems or uninterpreted constants in SMT. Balduccini [2009] and Gebser et al. [2009] combine ASP and
constraint solving in a way that is similar to the “lazy approach” of SMT solvers. Niemelä [2008] shows that ASP
programs can be translated into a particular SMT fragment,
namely difference logic. Janhunen et al. [2011] presents
a tight integration of ASP and SMT. All these approaches
aim at addressing the issue (i) above by avoiding grounding
and exploiting efficient constraint solving methods applied to
functions. However, they do not address the issue (ii) because, like the standard ASP, nonmonotonicity of those extensions has to do with predicates only. For instance, a natural counterpart of (1) in the language of CLINGCON [Gebser
et al., 2009],

Answer Set Programming Modulo Theories is a
new framework of tight integration of answer set
programming (ASP) and satisfiability modulo theories (SMT). Similar to the relationship between
first-order logic and SMT, it is based on a recent
proposal of the functional stable model semantics
by fixing interpretations of background theories.
Analogously to a known relationship between ASP
and SAT, “tight” ASPMT programs can be translated into SMT instances. We demonstrate the usefulness of ASPMT by enhancing action language
C+ to handle continuous changes as well as discrete
changes. We reformulate the semantics of C+ in
terms of ASPMT, and show that SMT solvers can
be used to compute the language. We also show
how the language can represent cumulative effects
on continuous resources.

1

Introduction

The success of answer set programming (ASP) [Lifschitz,
2008; Brewka et al., 2011] is in part thanks to efficiency of
ASP solvers that utilize (i) intelligent grounding—the process
that replaces variables with ground terms—and (ii) efficient
search methods that originated from propositional satisfiability solvers (SAT solvers). However, this method is not scalable when we need to represent functional fluents that range
over large numeric domains. Since answer sets (a.k.a. stable
models) are limited to Herbrand models, functional fluents
are represented by predicates, but not by functions, as in the
following example that represents the inertia assumption on
Speed:
Speed1 (x) ← Speed0 (x), not ¬Speed1 (x) .

Speed1 =$ x ← Speed0 =$ x, not Speed1 6=$ x ,
does not correctly represent inertia.
In this paper, we present a framework of combining answer
set programming with satisfiability modulo theories, which
we call Answer Set Programming Modulo Theories (ASPMT).
Just as SMT is a generalization of SAT and, at the same time,
a special case of first-order logic in which certain predicate
and function constants in background theories (such as difference logic and the theory of reals) have fixed interpretations, ASPMT is a generalization of the standard ASP and, at
the same time, a special case of the functional stable model
semantics [Bartholomew and Lee, 2012] that assumes background theories. Like the known relationship between SAT
and ASP that tight ASP programs can be translated into SAT
instances, tight ASPMT programs can be translated into SMT
instances, which allows SMT solvers for computing ASPMT
programs.
These results allow us to enhance action language C+
[Giunchiglia et al., 2004] to handle reasoning about continuous changes. Language C+ is an expressive action description language but its semantics was defined in terms of

(1)

Here the subscripts 0 and 1 are time stamps, and x is a
variable ranging over the value domain of fluent Speed. A
more natural representation using functions which replaces
Speedi (x) with Speedi = x does not work under the ASP semantics because (i) answer sets are Herbrand models (e.g.,
Speed1 = Speed0 is always false under any Herbrand interpretation), and (ii) nonmonotonicity of the stable model semantics has to do with minimizing the extents of predicates
but has nothing to do with functions. On the other hand,

990

This definition of a stable model is a proper generalization
of the one from [Ferraris et al., 2011]: in the absence of intensional function constants, it reduces to the one in [Ferraris
et al., 2011].

propositional causal theories, which limits the language to express discrete changes only. By reformulating C+ in terms
of ASPMT, we naturally extend the language to overcome
the limitation, and use SMT solvers to compute the language.
Our experiments show that this approach outperforms the existing implementations of C+ by several orders of magnitude
for some benchmark problems.
Section 2 reviews the functional stable model semantics
by Bartholomew and Lee [2012], and defines ASPMT as its
special case. Section 3 reformulates language C+ in terms
of ASPMT, and Section 4 shows how the reformulation can
be used to represent continuous changes. The language is
further extended in Section 5 to represent cumulative effects
on continuous resources. Related work and the conclusion
are presented in Section 6.

2
2.1

2.2

Answer Set Programming Modulo Theories

Formally, an SMT instance is a formula in many-sorted firstorder logic, where some designated function and predicate
constants are constrained by some fixed background interpretation. SMT is the problem of determining whether such a
formula has a model that expands the background interpretation [Barrett et al., 2009].
The syntax of ASPMT is the same as that of SMT. Let σ bg
be the (many-sorted) signature of the background theory bg.
An interpretation of σ bg is called a background interpretation if it satisfies the background theory. For instance, in the
theory of reals, we assume that σ bg contains the set R of symbols for all real numbers, the set of arithmetic functions over
real numbers, and the set {<, >, ≤, ≥} of binary predicates
over real numbers. Background interpretations interpret these
symbols in the standard way.
Let σ be a signature that is disjoint from σ bg . We say that
an interpretation I of σ satisfies F w.r.t. the background theory bg, denoted by I |=bg F , if there is a background interpretation J of σ bg that has the same universe as I, and I ∪ J
satisfies F . For any ASPMT sentence F with background
theory σ bg , interpretation I is a stable model of F relative
to c (w.r.t. background theory σ bg ) if I |=bg SM[F ; c].
We will often write G ← F , in a rule form as in logic programs, to denote the universal closure of F → G. A finite set
of formulas is identified with the conjunction of the formulas
in the set.

Functional SM and ASPMT
Review: Functional Stable Model Semantics

We review the semantics from [Bartholomew and Lee, 2012].
Formulas are built the same as in first-order logic. A signature consists of function constants and predicate constants.
Function constants of arity 0 are called object constants, and
predicate constants of arity 0 are called propositional constants.
Similar to circumscription, for predicate symbols (constants or variables) u and c, expression u ≤ c is defined as
shorthand for ∀x(u(x) → c(x)). Expression u = c is defined
as ∀x(u(x) ↔ c(x)) if u and c are predicate symbols, and
∀x(u(x) = c(x)) if they are function symbols. For lists of
symbols u = (u1 , . . . , un ) and c = (c1 , . . . , cn ), expression
u ≤ c is defined as (u1 ≤ c1 )∧· · ·∧(un ≤ cn ), and similarly,
expression u = c is defined as (u1 = c1 ) ∧ · · · ∧ (un = cn ).
Let c be a list of distinct predicate and function constants,
and let b
c be a list of distinct predicate and function variables
corresponding to c. By cpred (cfunc , respectively) we mean
the list of all predicate constants (function constants, respectively) in c, and by b
cpred the list of the corresponding predicate variables in b
c.
For any formula F , expression SM[F ; c] is defined as

Example 1 The following set F of formulas describes the inertia assumption on the speed of a car and the effect of acceleration assuming the theory of reals as the background theory.
Speed1 = x ← ¬¬(Speed1 = x) ∧ Speed0 = x
Speed1 = x ← (x = Speed0 +3× Duration)
∧ Accelerate = TRUE .

∗

F ∧ ¬∃b
c(b
c < c ∧ F (b
c)),

(2)

Here x is a variable of sort R≥0 ; Speed0 , Speed1
and Duration are object constants with value sort
R≥0 and Accelerate is an object constant with
value sort Boolean.
For interpretation I of signature {Speed0 , Speed1 , Duration, Accelerate} such that
AccelerateI = FALSE, SpeedI0 = 1, SpeedI1 = 1,
DurationI = 1.5, we check that I |=bg SM[F ; Speed1 ].
For another interpretation I1 of the same signature that
agrees with I except that AccelerateI1 = TRUE, SpeedI11 =
5.5, we check that I1 |=bg SM[F ; Speed1 ].

where b
c < c is shorthand for (b
cpred ≤ cpred ) ∧ ¬(b
c = c),
∗
and F (b
c) is defined recursively as follows.
• When F is an atomic formula, F ∗ is F 0 ∧ F where F 0
is obtained from F by replacing all intensional (function
and predicate) constants c in it with the corresponding
(function and predicate) variables from b
c;
• (G ∧ H)∗ = G∗ ∧ H ∗ ; (G ∨ H)∗ = G∗ ∨ H ∗ ;
• (G → H)∗ = (G∗ → H ∗ ) ∧ (G → H);
• (∀xG)∗ = ∀xG∗ ; (∃xF )∗ = ∃xF ∗ .
(We understand ¬F as shorthand for F → ⊥; > as ¬⊥; and
F ↔ G as (F → G) ∧ (G → F ).) Members of c are called
intensional constants.
When F is a sentence, the models of SM[F ; c] are called
the stable models of F relative to c. They are the models of F
that are “stable” on c. The definition can be easily extended
to formulas of many-sorted signatures.

2.3

Review: Completion

We review the theorem on completion from [Bartholomew
and Lee, 2013], which turns the functional stable model semantics into first-order logic.
A formula F is said to be in Clark normal form (relative
to the list c of intensional constants) if it is a conjunction of

991

formula is a formula of σ act ∪ σ bg that contains at least one
action constant and no fluent constants.
A static law is an expression of the form

sentences of the form
∀x(G → p(x))

(3)

and

caused F if G

∀xy(G → f (x) = y)
(4)
one for each intensional predicate p and each intensional
function f , where x is a list of distinct object variables, y
is an object variable, and G is an arbitrary formula that has
no free variables other than those in x and y.
The completion of a formula F in Clark normal form (relative to c) is obtained from F by replacing each conjunctive
term (3) with ∀x(p(x) ↔ G) and each conjunctive term (4)
with ∀xy(f (x) = y ↔ G).
An occurrence of a symbol or a subformula in a formula F
is called strictly positive in F if that occurrence is not in the
antecedent of any implication in F . The t-dependency graph
of F (relative to c) is the directed graph that
• has all members of c as its vertices, and
• has an edge from c to d if, for some strictly positive occurrence of G → H in F ,
– c has a strictly positive occurrence in H, and
– d has a strictly positive occurrence in G.
We say that F is tight (on c) if the t-dependency graph of
F (relative to c) is acyclic. For example, formula (1) is tight
on its signature.
Theorem 1 [Bartholomew and Lee, 2013, Theorem 2] For
any sentence F in Clark normal form that is tight on c, an
interpretation I that satisfies ∃xy(x 6= y) is a model of
SM[F ; c] iff I is a model of the completion of F relative to c.

where F and G are fluent formulas. An action dynamic law is
an expression of the form (5) in which F is an action formula
and G is a formula. A fluent dynamic law is an expression of
the form
caused F if G after H
(6)
where F and G are fluent formulas and H is a formula, provided that F does not contain statically determined constants.
A causal law is a static law, or an action dynamic law, or a
fluent dynamic law. A C+ action description is a finite set of
causal laws.
For any function constant f , we say that a first-order formula is f -plain if each atomic formula in it
• does not contain f , or
• is of the form f (t) = t1 where t is a list of terms not
containing f , and t1 is a term not containing f .
For any list c of predicate and function constants, we say that
F is c-plain if F is f -plain for each function constant f in c.
We call an action description definite if the head F of every
causal law (5) and (6) is an atomic formula that is (σ f l ∪σ act )plain. Throughout this paper we consider definite action descriptions only, which covers the fragment of C+ that is implemented in the Causal Calculator (CC ALC)1 .

3.2

Theorem 1 can be applied to formulas in non-Clark normal form if they can be rewritten in Clark normal form. The
following theorem is often useful in splitting conjunctive formulas, and applying completion to subformulas.
Theorem 2 [Bartholomew and Lee, 2012, Theorem 1] For
any first-order formulas F and G, if G has no strictly positive
occurrence of a constant from c, SM[F ∧ G; c] is equivalent
to SM[F ; c] ∧ G.
Theorem 1 is applicable to ASPMT formulas as well. Since
F in Example 1 is tight on Speed1 , according to Theorem 1,
SM[F ; Speed1 ] is equivalent to the following SMT instance
with the same background theory:
Speed1 = x ↔ ¬¬(Speed1 = x) ∧ (Speed0 = x)
∨ ((x = Speed0 +3× Duration) ∧ Accelerate = TRUE) .

3
3.1

(5)

Reformulating C+ in ASPMT
Syntax

We consider a many-sorted first-order signature σ that is partitioned into three signatures: the set σ f l of object constants
called fluent constants, the set σ act of object constants called
action constants, and the background signature σ bg . The signature σ f l is further partitioned into the set σ sim of simple
fluent constants and the set σ sd of statically determined fluent constants.
We assume the same syntax of formulas as in Section 2. A
fluent formula is a formula of signature σ f l ∪ σ bg . An action

Semantics

In [Giunchiglia et al., 2004] the semantics of C+ is defined
in terms of nonmonotonic propositional causal theories, in
which every constant has a finite domain. The semantics of
the enhanced C+ below is similar to the one in [Giunchiglia et
al., 2004] except that it is defined in terms of ASPMT in place
of causal theories. This reformulation is essential for the language to represent continuous changes as it is not limited to
finite domains only.
For a signature σ and a nonnegative integer i, expression
i : σ is the signature consisting of the pairs i : c such that
c ∈ σ, and the value sort of i : c is the same as the value sort
of c. Similarly, if s is an interpretation of σ, expression i : s
is an interpretation of i : σ such that cs = (i : c)i:s .
For any definite action description D of signature
σ f l ∪ σ act ∪ σ bg and any nonnegative integer m, the ASPMT
program Dm is defined as follows. The signature of Dm is
0 : σ f l ∪ · · · ∪ m : σ f l ∪ 0 : σ act ∪ · · · ∪ (m−1) : σ act ∪ σ bg .
By i : F we denote the result of inserting i : in front of every
occurrence of every fluent and action constant in a formula F .
ASPMT program Dm is the conjunction of
¬¬ i : G → i : F
for every static law (5) in D and every i ∈ {0, . . . , m},
and for every action dynamic law (5) in D and every
i ∈ {0, . . . , m−1};
¬¬ (i+1) : G ∧ i : H → (i+1) : F
1

992

http://www.cs.utexas.edu/ tag/ccalc/

Notation: d, v, v 0 , t, t0 are variables of sort R≥0
A, MS are real numbers.

for every fluent dynamic law (6) in D and every i ∈
{0, . . . , m − 1}.
The transition system represented by an action description D consists of states (vertices) and transitions
(edges). A state is an interpretation s of σ f l such that
0 : s |=bg SM[D0 ; 0:σ sd ]. A transition is a triple hs, e, s0 i,
where s and s0 are interpretations of σ f l and e is an interpretation of σ act , such that

Simple fluent constants:
Speed, Distance, Time
Action constants:
Accelerate, Decelerate
Dur

caused Speed = v+A×t after Accelerate ∧ Speed = v ∧ Dur = t
caused Speed = v−A×t after Decelerate ∧ Speed = v ∧ Dur = t
caused Distance = d+0.5×(v+v 0 )×t if Speed = v 0
after Distance = d ∧ Speed = v ∧ Dur = t
constraint Time = t+t0 after Time = t ∧ Dur = t0
constraint Speed ≤ MS

(0 : s) ∪ (0 : e) ∪ (1 : s0 ) |=bg
SM[D1 ; (0 : σ sd ) ∪ (0 : σ act ) ∪ (1 : σ f l )] .
Theorems 3 and 4 below extend Propositions 7 and 8
from [Giunchiglia et al., 2004] to our reformulation of C+.
These theorems justify the soundness of the language.
The definition of the transition system above implicitly relies on the following property of transitions:

inertial Speed
exogenous Time, c

Theorem 3 For every transition hs, e, s0 i, s and s0 are states.

for every action constant c

Figure 1: Car Example in C+

The following theorem states the correspondence between
the stable models of Dm and the paths in the transition system
represented by D:

where (i) c is a simple fluent constant, (ii) c, c0 are lists of fluent constants, (iii) x, x0 are lists of object variables, (iv) G is
a formula, and (v) f (x, x0 , t) is a term constructed from σ bg ,
and variables in x, x0 , and t.
For instance, the fluent dynamic law

Theorem 4
(0 : s0 ) ∪ (0 : e0 ) ∪ (1 : s1 ) ∪ (1 : e1 ) ∪ · · · ∪ (m : sm )
|=bg SM[Dm ; (0 : σ sd ) ∪ (0 : σ act ) ∪ (1 : σ f l ) ∪ (1 : σ act )
∪ · · · ∪ (m−1 : σ act ) ∪ (m : σ f l )]

caused Distance = d+0.5×(v+v 0 )×t if Speed = v 0
after Distance = d ∧ Speed = v ∧ Dur = t
describes how fluent Distance changes according to the function of real time.
Consider the following problem by Lifschitz
(http://www.cs.utexas.edu/vl/tag/continuous problem).
If the accelerator of a car is activated, the car will speed up
with constant acceleration A until the accelerator is released
or the car reaches its maximum speed MS, whichever comes
first. If the brake is activated, the car will slow down with
acceleration −A until the brake is released or the car stops,
whichever comes first. Otherwise, the speed of the car
remains constant. The problem asks to find a plan satisfying
the following condition: at time 0, the car is at rest at one end
of the road; at time K, it should be at rest at the other end.
A C+ description of this example is shown in Figure 1. The

iff each triple hsi , ei , si+1 i (0 ≤ i < m) is a transition.
It is not difficult to check that ASPMT program Dm that is
obtained from action description D is always tight. In view of
Theorem 1, Dm can be represented in the language of SMT
as the next section demonstrates.

4

Domains:
R≥0
Domains:
Boolean
R≥0

Reasoning about Continuous Changes in C+

In order to represent continuous changes in the enhanced C+,
we distinguish between steps and real clock times. We assume the theory of reals as the background theory, and introduce a simple fluent constant Time with value sort R≥0 ,
which denotes the clock time, and an action constant Dur
with value sort R≥0 , which denotes the time elapsed between
the two consecutive states. We postulate the following causal
laws:

Notation: x, d, v, v 0 , t, t0 are variables of sort R≥0 ;
y is a variable of sort Boolean.
Intensional object constants: i : Speed for i > 0

exogenous Time, Dur,
constraint Time = t + t0 after Time = t ∧ Dur = t0 .
(7)

i+1 : Speed = x ← (x = v+A×t)
∧ i : (Accelerate ∧ Speed = v ∧ Dur = t)
i+1 : Speed = x ← (x = v−A×t)
∧ i : (Decelerate ∧ Speed = v ∧ Dur = t)
i+1 : Distance = x ← (x = d+0.5×(v 0 +v)×t)
∧ i+1 : Speed = v 0 ∧ i : (Speed = v ∧ Distance = d ∧ Dur = t)
⊥ ← ¬(i+1 : Time = t+t0 ) ∧ i : (Time = t ∧ Dur = t0 )
⊥ ← ¬(i : Speed ≤ MS)
i+1 : Speed = x ← ¬¬(i+1 : Speed = x) ∧ i : Speed = x
i : Time = t ← ¬¬(i : Time = t)
i : c = y ← ¬¬(i : c = y)
for every action constant c

These causal laws are shorthand for
caused Time = t if Time = t ,
caused Dur = t if Dur = t ,
caused ⊥ if ¬(Time = t + t0 ) after Time = t ∧ Dur = t0
where t, t0 are variables of sort R≥0 . (See Appendix B
in [Giunchiglia et al., 2004] for the abbreviations of causal
laws.)
Continuous changes can be described as a function of duration using fluent dynamic laws of the form

Figure 2: Car Example in ASPMT

caused c = f (x, x0 , t) if c0 = x0 after (c = x) ∧ (Dur = t) ∧ G

993

to be 1, and all components of the position and the velocity
vectors at any time are assumed to be integers, and even the
forces applied have to be integers. Obviously these are too
strong assumptions.
These limitations are not present in our enhanced C+ and
its SMT-based computation. The representation in [Lee and
Lifschitz, 2003] can be straightforwardly extended to handle
continuous motions by distinguishing between steps and real
time as in the previous section. For example, we can describe the effect that firing multiple jets has on the velocity
of a spacecraft by

Figure 3: Solution Found by iSAT
actions Accelerate and Decelerate has direct effects on Speed
and indirect effects on Distance. For an object constant c that
has the Boolean domain, we abbreviate c = TRUE as c and
c = FALSE as ∼c. According to the semantics in Section 3.2,
the description is turned into an ASPMT program with the
theory of reals as the background theory, which can be further
rewritten in Clark normal form. Some occurrences of ¬¬ can
be dropped without affecting stable models, which results in
the program in Figure 2.
The program can be viewed as F ∧ G where F is the
conjunction of the rules that has intensional constants in the
heads, and G is the conjunction of the rest rules. In view of
Theorem 2, the stable models and F ∧ G are the same as the
stable models of F that satisfies G. By Theorem 1, F can
be turned into completion. For example, the completion on
i+1 : Speed yields a formula that is equivalent to
i+1 : Speed = x ↔ x = (i : Speed+A×i : Dur) ∧ i : Accelerate

∨ x = (i : Speed−A×i : Dur) ∧ i: Decelerate
∨ i+1 : Speed = x ∧ i : Speed = x .

Fire(j) increments Vel(ax) by (n/Mass) × t
if Force(j, ax) = n ∧ Dur = t
In general, additive fluent constants are simple fluent constants with numerical values with certain restrictions. First,
the heads of static and fluent dynamic laws are not allowed to
contain additive fluent constants. Second, the effects of concurrent execution of actions on additive fluents are expressed
by increment laws—expressions of the form
a increments c by f (x, t) if (d, Dur) = (x, t) ∧ G (8)
where (i) a is a Boolean action constant; (ii) c is an additive
fluent constant; (iii) d is a list of fluent constants, and x is
a list of corresponding variables; (iv) f (x, t) is an arithmetic
expression over x and the duration t; (v) G is a formula that
contains no Boolean action constants.
Similar to [Lee and Lifschitz, 2003], the semantics of increment laws is described by a translation that replaces increment laws with action dynamic laws (5) and fluent dynamic
laws (6) using additional action constants. This translation
largely repeats the one in [Lee and Lifschitz, 2003] and we
omit the details due to lack of space.
The C+ encoding of the spacecraft example is shown in
Figure 4.



Variable x in the formula can be eliminated by equivalent
transformations using equality:
i : Accelerate → i+1 : Speed = (i : Speed+A×i : Dur)
i : Decelerate → i+1 : Speed = (i : Speed−A×i : Dur)
(i+1 : Speed = (i : Speed+A×i : Dur) ∧ i : Accelerate)
∨(i+1 : Speed = (i : Speed−A×i : Dur) ∧ i : Decelerate)
∨(i : Speed = i+1 : Speed) .

The whole translation can be encoded in the input language of SMT solvers. The shortest plan found by iSAT
(http://isat.gforge.avacs.org) on this input formula when the
road length is 10, A = 3, MS = 4, K = 4 is shown in Figure 3.

5

Notation: j ∈ {J1 , J2 }, ax ∈ {X, Y, Z}
x, y, y 0 are variables of sort R; t, t0 are variables of sort R≥0
Additive fluent constants:
Vel(ax)
Other Simple fluent constants:
Pos(ax)
Time
Action constants:
Fire(j)
Force(j, ax)
Dur

Reasoning about Additive Continuous
Resources in C+

Additive fluents are fluents with numerical values such that
the effect of several concurrently executed actions on it can be
computed by adding the effects of the individual actions. Lee
and Lifschitz [2003] show how to describe additive fluents
in C+ by understanding “increment laws” as shorthand for
some causal laws. However, some additive fluents are realvalued, and cannot be represented in the language described
in [Lee and Lifschitz, 2003] as the language is limited to finite
domains only. This made the discussion of additive fluents
in [Lee and Lifschitz, 2003] limited to integer domains only.
For example, the effect of firing multiple jets on the velocity
of a spacecraft is described by “increment laws”

Domains:
R
Domains:
R
R≥0
Domains:
Boolean
R
R≥0

Fire(j) increments Vel(ax) by (x/Mass) × t
if Force(j, ax) = x ∧ Dur = t
caused Pos(ax) = x+(0.5×(y+y 0 )×t) if Vel(ax) = y 0
after Pos(ax) = x ∧ Vel(ax) = y ∧ Dur = t
always Force(j, ax) = 0 ↔ ∼Fire(j)
constraint Time = t+t0 after Time = t ∧ Dur = t0
exogenous Time
exogenous c
for every action constant c

Fire(j) increments Vel(ax) by n//Mass if Force(j, ax) = n .

Mass stands for an integer constant, and the symbol // stands
for integer division; the duration of firing action is assumed

Figure 4: Spacecraft Example in C+ with Additive Fluents

994

Max Step

1
2
3
4
5
6
10
50
100
200

CC ALC v2.0 using RELSAT v2.2
Run Time
# of atoms / clauses
(grounding+completion+solving)
0.16 (0.12+0.04+0.00)
488 / 1872
0.57 (0.40+0.17+0.00)
3262 / 14238
10.2 (2.62+1.58+6)
32772 / 155058
505.86 (12.94+13.92+479)
204230 / 992838
failed (51.10+115.58+ failed)
897016 / 4410186
time out
–
time out
–
time out
–
time out
–
time out
–

CPLUS 2 ASP

v1.0 using GRINGO v3.0.3+CLASP v2.0.2
Run Time
# of atoms / rules
(grounding+solving)
0.005 (0.005+0)
1864 / 2626
0.033 (0.033+0)
6673 / 12035
0.434 (0.234+0.2)
42778 / 92124
12.546 (3.176+9.37)
228575/ 503141
73.066 (15.846+57.22)
949240/ 2060834
3020.851 (62.381+2958.47)
3179869/ 6790167
time out
–
time out
–
time out
–
time out
–

C+ in iSAT v1.0
Run Time
# of variables / clauses
last/total
(bool + real)
0/0
(42+53) / 182
0/0
(82+98) / 352
0/0
(122+143) / 520
0/0
(162+188) / 688
0/0.03
(202+233) / 856
0/0.03
(242+278) / 1024
0.03/0.09
(402+458) / 1696
0.09/1.39
(2002+2258) / 8416
0.17/5.21
(4002+4508) / 16816
0.33/21.96
(8002+9008) / 33616

Table 1: Experiment results on Spacecraft Example (time out after 2 hours)
we require that G contain no process fluents and no Boolean
action constants. For example,

Table 1 compares the performance of SMT-based computation of C+ and existing implementations of C+: CC ALC 2
and CPLUS 2 ASP. System CPLUS 2 ASP translates C+ into ASP
programs and use GRINGO and CLASP for computation. For
the sake of comparison, we assume that the duration of each
action is exactly 1 unit of time so that the plans found by the
systems are of the same kind. We assume that initially the
spacecraft is rest at coordinate (0, 0, 0). The task is to find
a plan such that at each integer time t, the spacecraft is at
(t2 , t2 , t2 ). The experiment was performed on an Intel Core
2 Duo CPU 3.00 GHz with 4 GB RAM running on Ubuntu
version 11.10. It shows a clear advantage of the SMT-based
computation of C+ for this example.

On(Tap1 ) increments Level by W(Tap1 )×t if Dur = t

specifies that, when the process fluent On(Tap1 ) is true, the
process contributes to increasing the water level by W(Tap1 )
multiplied by duration.
Figure 5 describes the level of a water tank that has two
taps with different flow rates and possible leaking.

6

Notation: x ∈ {Tap1 , Tap2 }; W(x), V, Low, High are real numbers;
t, t0 are variables of sort R≥0 .
TurnOn(x) causes On(x) ∧ Dur = 0
TurnOff (x) causes ∼On(x) ∧ Dur = 0
On(x) increments Level by W(x)×t if Dur = t
Leaking increments Level by −(V×t) if Dur = t
constraint (Low ≤ Level) ∧ (Level ≤ High)
inertial On(x), Leaking
exogenous c
for every action constant c
exogenous Time
constraint Time = t + t0 after Time = t ∧ Dur = t0

Figure 5: Two Taps Water Tank Example C+
The language C+ is flexible enough to represent the startprocess-end model [Reiter, 1996; Fox and Long, 2006],
where instantaneous actions may initiate or terminate processes. Processes run over time and have a continuous effect on numeric fluents. They are initiated and terminated either by the direct action or by events that are triggered. This
model can be encoded in C+ by introducing process fluents,
which are Boolean-valued. Such a process fluent is assumed
to be inertial, and is caused to be true or false by instantaneous events. Once true, the process fluent p determines the
changes of additive fluents c by increment laws

Related Work and Conclusion

Besides the functional stable model semantics we considered
in this paper, there are other approaches to incorporate “intensional” functions in ASP [Cabalar, 2011; Lifschitz, 2012;
Balduccini, 2012].
Action language H [Chintabathina et al., 2005;
Chintabathina and Watson, 2012] is similar to our enhanced C+ in that it can handle reasoning about continuous
changes. One notable difference is there, each state represents an interval of time, rather than a particular timepoint.
Language H does not have action dynamic laws, and
consequently does not allow additive fluents.
The durative action model of PDDL 2.1 [Fox and Long,
2003] is similar to our C+ representation in Section 4. The
start-process-stop model of representing continuous changes
in PDDL+ [Fox and Long, 2006] is similar to the representation in Section 5. Our work is also related to [Shin and Davis,
2005], which used SMT solvers for computing PDDL+, and
a recent work on planning modulo theories [Gregory et al.,
2012].
Continuous changes have also been studied in the situation calculus, the event calculus and temporal action logics.
In [Lee and Palla, 2012b; 2012a], these action formalisms
were reformulated in ASP. We expect that the techniques we
developed in this paper can be applied for more effective
computation of these formalisms using SMT solvers.
Acknowledgements:
We are grateful to Michael
Bartholomew for useful discussions related to this paper. We are also grateful to the anonymous referees for their
useful comments. This work was partially supported by
the National Science Foundation under Grant IIS-0916116
and by the South Korea IT R&D program MKE/KIAT
2010-TD-300404-001.

p increments c by f (x, t) if (d, Dur) = (x, t) ∧ G .
Here, increments laws are defined similar to (8) except that
p is a process fluent, instead of a Boolean action constant;

995

References

[Gebser et al., 2009] M. Gebser, M. Ostrowski, and
T. Schaub. Constraint answer set solving. In Proceedings
of International Conference on Logic Programming
(ICLP), pages 235–249, 2009.
[Giunchiglia et al., 2004] Enrico Giunchiglia, Joohyung
Lee, Vladimir Lifschitz, Norman McCain, and Hudson Turner. Nonmonotonic causal theories. Artificial
Intelligence, 153(1–2):49–104, 2004.
[Gregory et al., 2012] Peter Gregory, Derek Long, Maria
Fox, and J. Christopher Beck. Planning modulo theories: Extending the planning paradigm. In Proceedings
of the Twenty-Second International Conference on Automated Planning and Scheduling (ICAPS), 2012.
[Janhunen et al., 2011] Tomi Janhunen, Guohua Liu, and
Ilkka Niemel. Tight integration of non-ground answer set
programming and satisfiability modulo theories. In Working notes of the 1st Workshop on Grounding and Transformations for Theories with Variables, 2011.
[Lee and Lifschitz, 2003] Joohyung Lee and Vladimir Lifschitz. Describing additive fluents in action language C+.
In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pages 1079–1084, 2003.
[Lee and Palla, 2012a] Joohyung Lee and Ravi Palla. Reformulating temporal action logics in answer set programming. In Proceedings of the AAAI Conference on Artificial
Intelligence (AAAI), pages 786–792, 2012.
[Lee and Palla, 2012b] Joohyung Lee and Ravi Palla. Reformulating the situation calculus and the event calculus
in the general theory of stable models and in answer set
programming. Journal of Artificial Inteligence Research
(JAIR), 43:571–620, 2012.
[Lifschitz, 2008] Vladimir Lifschitz. What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence, pages 1594–1597. MIT Press, 2008.
[Lifschitz, 2012] Vladimir Lifschitz. Logic programs with
intensional functions. In Proceedings of International
Conference on Principles of Knowledge Representation
and Reasoning (KR), pages 24–31, 2012.
[Niemelä, 2008] Ilkka Niemelä. Stable models and difference logic. Ann. Math. Artif. Intell., 53(1-4):313–329,
2008.
[Reiter, 1996] Raymond Reiter. Natural actions, concurrency and continuous time in the situation calculus. In
Proceedings of International Conference on Principles of
Knowledge Representation and Reasoning (KR), pages 2–
13, 1996.
[Shin and Davis, 2005] Ji-Ae Shin and Ernest Davis. Processes and continuous change in a sat-based planner. Artificial Intelligence, 166(1-2):194–253, 2005.

[Balduccini, 2009] Marcello Balduccini. Representing constraint satisfaction problems in answer set programming.
In Working Notes of the Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP),
2009.
[Balduccini, 2012] Marcello Balduccini. A ”conservative”
approach to extending answer set programming with nonherbrand functions. In Correct Reasoning - Essays on
Logic-Based AI in Hon our of Vladimir Lifschitz, pages
24–39, 2012.
[Barrett et al., 2009] Clark W. Barrett, Roberto Sebastiani,
Sanjit A. Seshia, and Cesare Tinelli. Satisfiability modulo
theories. In Armin Biere, Marijn Heule, Hans van Maaren,
and Toby Walsh, editors, Handbook of Satisfiability, volume 185 of Frontiers in Artificial Intelligence and Applications, pages 825–885. IOS Press, 2009.
[Bartholomew and Lee, 2012] Michael Bartholomew and
Joohyung Lee. Stable models of formulas with intensional
functions. In Proceedings of International Conference on
Principles of Knowledge Representation and Reasoning
(KR), pages 2–12, 2012.
[Bartholomew and Lee, 2013] Michael Bartholomew and
Joohyung Lee. Functional stable model semantics and answer set programming modulo theories. In Proceedings
of International Joint Conference on Artificial Intelligence
(IJCAI), 2013. This volume.
[Brewka et al., 2011] Gerhard Brewka, Ilkka Niemelä, and
Miroslaw Truszczynski. Answer set programming at a
glance. Communications of the ACM, 54(12):92–103,
2011.
[Cabalar, 2011] Pedro Cabalar. Functional answer set programming. TPLP, 11(2-3):203–233, 2011.
[Chintabathina and Watson, 2012] Sandeep Chintabathina
and Richard Watson. A new incarnation of action language h. In Esra Erdem, Joohyung Lee, Yuliya Lierler, and
David Pearce, editors, Correct Reasoning, volume 7265
of Lecture Notes in Computer Science, pages 560–575.
Springer, 2012.
[Chintabathina et al., 2005] Sandeep
Chintabathina,
Michael Gelfond, and Richard Watson.
Modeling
hybrid domains using process description language2 . In
Proceedings of Workshop on Answer Set Programming:
Advances in Theory and Implementation (ASP’05), 2005.
[Ferraris et al., 2011] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. Stable models and circumscription.
Artificial Intelligence, 175:236–263, 2011.
[Fox and Long, 2003] Maria Fox and Derek Long.
PDDL2.1: An extension to pddl for expressing temporal planning domains. J. Artif. Intell. Res. (JAIR),
20:61–124, 2003.
[Fox and Long, 2006] Maria Fox and Derek Long. Modelling mixed discrete-continuous domains for planning. J.
Artif. Intell. Res. (JAIR), 27:235–297, 2006.
2

http://ceur-ws.org/vol-142/page303.pdf

996

A Functional View of Strong Negation
in Answer Set Programming
Michael Bartholomew and Joohyung Lee

arXiv:1312.6130v1 [cs.AI] 20 Dec 2013

School of Computing, Informatics, and Decision Systems Engineering
Arizona State University, Tempe, USA

Abstract. The distinction between strong negation and default negation has been
useful in answer set programming. We present an alternative account of strong negation, which lets us view strong negation in terms of the functional stable model
semantics by Bartholomew and Lee. More specifically, we show that, under complete interpretations, minimizing both positive and negative literals in the traditional
answer set semantics is essentially the same as ensuring the uniqueness of Boolean
function values under the functional stable model semantics. The same account lets
us view Lifschitz’s two-valued logic programs as a special case of the functional stable model semantics. In addition, we show how non-Boolean intensional functions
can be eliminated in favor of Boolean intensional functions, and furthermore can be
represented using strong negation, which provides a way to compute the functional
stable model semantics using existing ASP solvers. We also note that similar results
hold with the functional stable model semantics by Cabalar.

1

Introduction

The distinction between default negation and strong negation has been useful in answer
set programming. In particular, it yields an elegant solution to the frame problem. The fact
that block b stays at the same location l by inertia can be described by the rule
ıOn(b, l, t+1) ← ıOn(b, l, t), ınot ∼ıOn(b, l, t+1)

(1)

along with the rule that describes the uniqueness of location values [Lifschitz, 2002],
∼ıOn(b, l1 , t) ← ıOn(b, l, t), l 6= l1 .

(2)

Here ‘∼’ is the symbol for strong negation that represents explicit falsity while ‘ınot’ is
the symbol for default negation (negation as failure). Rule (1) asserts that without explicit
evidence to the contrary, block b remains at location l. If we are given explicit conflicting
information about the location of b at time t+1 then this conclusion will be defeated by
rule (2), which asserts the uniqueness of location values.
An alternative representation of inertia, which uses choice rules instead of strong negation, was recently presented by Bartholomew and Lee [2012]. Instead of rule (1), they use
the choice rule
{ıOn(b, l, t+1)} ← ıOn(b, l, t) ,
(3)
which states that “if b is at l at time t, then decide arbitrarily whether to assert that b is at
l at time t + 1.” Instead of rule (2), they write weaker rules for describing the functional

50

M. Bartholomew and J. Lee

property of ıOn:
← {ıOn(b, l, t) : Location(l)}0
← 2{ıOn(b, l, t) : Location(l)}

(existence of location)
(uniqueness of location),

(4)
(5)

which can be also combined into one rule: ← ınot 1{ıOn(b, l, t) : Location(l)}1 . In
the absence of additional information about the location of block b at time t+1, asserting
ıOn(b, l, t+1) is the only option, in view of the existence of location constraint (4). But if
we are given conflicting information about the location of b at time t+1 then not asserting
ıOn(b, l, t+1) is the only option, in view of the uniqueness of location constraint (5).
Rules (3), (4), and (5) together can be more succinctly represented in the language
of [Bartholomew and Lee, 2012] by means of intensional functions. That is, the three
rules can be replaced by one rule
{ıLoc(b, t+1) = l} ← ıLoc(b, t) = l ,

(6)

where ıLoc is an intensional function constant (the rule reads, “if block b is at location l at
time t, by default, the block is at l at time t+1”). In fact, Corollary 2 of [Bartholomew and
Lee, 2012] tells us how to eliminate intensional functions in favor of intensional predicates,
justifying the equivalence between (6) and the set of rules (3), (4), and (5). The translation
allows us to compute the language of [Bartholomew and Lee, 2012] using existing ASP
solvers, such as SMODELS and GRINGO. However, DLV cannot be used because it does not
accept choice rules. On the other hand, all these solvers accept rules (1) and (2), which
contain strong negation.
The two representations of inertia involving intensional predicate ıOn do not result in
the same answer sets. In the first representation, which uses strong negation, each answer
set contains only one atom of the form ıOn(b, l, t) for each block b and each time t; for
all other locations l0 , negative literals ∼ıOn(b, l0 , t) belong to the answer set. On the other
hand, such negative literals do not occur in the answer sets of a program that follows
the second representation, which yields fewer ground atoms. This difference can be well
explained by the difference between the symmetric and the asymmetric views of predicates
that Lifschitz described in his message to Texas Action Group, titled “Choice Rules and
the Belief-Based View of ASP”: 1
The way I see it, in ASP programs we use predicates of two kinds, let’s call them
“symmetric” and “asymmetric.” The fact that an object a does not have a property p is reflected by the presence of ∼p(a) in the answer set if p is “symmetric,”
and by the absence of p(a) if p is “asymmetric.” In the second case, the strong
negation of p is not used in the program at all.
According to these terminologies, predicate ıOn is symmetric in the first representation, and asymmetric in the second representation.
This paper presents several technical results that help us understand the relationship
between these two views. In this regard, it helps us to understand strong negation as a way
of expressing intensional Boolean functions.
1

http://www.cs.utexas.edu/users/vl/tag/choice discussion

A Functional View of Strong Negation in Answer Set Programming

51

– Our first result provides an alternative account of strong negation in terms of Boolean
intensional functions. For instance, (1) can be identified with
ıOn(b, l, t+1) = TRUE ← ıOn(b, l, t) = TRUE ∧ ¬(ıOn(b, l, t+1) = FALSE) ,
and (2) can be identified with
ıOn(b, l1 , t) = FALSE ← ıOn(b, l, t) = TRUE ∧ l 6= l1 .
Under complete interpretations, we show that minimizing both positive and negative
literals in the traditional answer set semantics is essentially the same as ensuring the
uniqueness of Boolean function values under the functional stable model semantics.
In this sense, strong negation can be viewed as a mere disguise of Boolean functions.2
– We show how non-Boolean intensional functions can be eliminated in favor of Boolean
functions. Combined with the result in the first bullet, this tells us a new way of turning the language of [Bartholomew and Lee, 2012] into traditional answer set programs
with strong negation, so that system DLV, as well as SMODELS and GRINGO, can be
used for computing the language of [Bartholomew and Lee, 2012]. As an example, it
tells us how to turn (6) into the set of rules (1) and (2).
– Lifschitz [2012] recently proposed “two-valued logic programs,” which modifies the
traditional stable model semantics to represent complete information without distinguishing between strong negation and default negation. Using our result that views
strong negation in terms of Boolean functions, we show that two-valued logic programs are in fact a special case of the functional stable model semantics in which
every function is Boolean.
While the main results are stated for the language of [Bartholomew and Lee, 2012],
similar results hold with the language of [Cabalar, 2011] based on the relationship between
the two languages studied in [Bartholomew and Lee, 2013]. Furthermore, we note that the
complete interpretation assumption in the first bullet can be dropped if we instead refer to
the language of [Cabalar, 2011], at the price of introducing partial interpretations.
The paper is organized as follows. In Section 2 we review the two versions of the stable model semantics, one that allows strong negation, but is limited to express intensional
predicates only, and the other that allows both intensional predicates and intensional functions. As a special case of the latter we also present multi-valued propositional formulas
under the stable model semantics. Section 3 shows how strong negation can be viewed in
terms of Boolean functions. Section 4 shows how non-Boolean functions can be eliminated
in favor of Boolean functions. Section 5 shows how Lifschitz’s two-valued logic programs
can be viewed as a special case of the functional stable model semantics. Section 6 shows
how strong negation can be represented in the language of [Cabalar, 2011].

2

Preliminaries

2.1

Review: First-Order Stable Model Semantics and Strong Negation

This review follows [Ferraris et al., 2011]. A signature is defined as in first-order logic,
consisting of function constants and predicate constants. Function constants of arity 0
2

It is also well-known that strong negation can be also viewed in terms of auxiliary predicate
constants [Gelfond and Lifschitz, 1991].

52

M. Bartholomew and J. Lee

are also called object constants. We assume the following set of primitive propositional
connectives and quantifiers: ⊥ (falsity), ∧, ∨, →, ∀, ∃. The syntax of a formula is defined
as in first-order logic. We understand ¬F as an abbreviation of F → ⊥.
The stable models of a sentence F relative to a list of predicates p = (p1 , . . . , pn )
are defined via the stable model operator with the intensional predicates p, denoted by
SM[F ; p]. Let u be a list of distinct predicate variables u1 , . . . , un of the same length as p.
By u = p we denote the conjunction of the formulas ∀x(ui (x) ↔ pi (x)), where x is a
list of distinct object variables of the same length as the arity of pi , for all i = 1, . . . , n. By
u ≤ p we denote the conjunction of the formulas ∀x(ui (x) → pi (x)) for all i = 1, . . . , n,
and u < p stands for (u ≤ p) ∧ ¬(u = p). For any first-order sentence F , expression
SM[F ; p] stands for the second-order sentence
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where F ∗ (u) is defined recursively:
– pi (t)∗ = ui (t) for any list t of terms;
– F ∗ = F for any atomic formula F (including ⊥ and equality) that does not contain
members of p;
– (F ∧ G)∗ = F ∗ ∧ G∗ ; (F ∨ G)∗ = F ∗ ∨ G∗ ;
– (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
– (∀xF )∗ = ∀xF ∗ ; (∃xF )∗ = ∃xF ∗ .
A model of a sentence F (in the sense of first-order logic) is called p-stable if it
satisfies SM[F ; p].
The traditional stable models of a logic program Π are identical to the Herbrand stable
models of the FOL-representation of Π (i.e., the conjunction of the universal closures of
implications corresponding to the rules).
Ferraris et al. [2011] incorporate strong negation into the stable model semantics by
distinguishing between intensional predicates of two kinds, positive and negative. Each
negative intensional predicate has the form ∼p, where p is a positive intensional predicate
and ‘∼’ is a symbol for strong negation. In this sense, syntactically ∼ is not a logical
connective, as it can appear only as a part of a predicate constant. An interpretation of the
underlying signature is coherent if it satisfies the formula ¬∃x(p(x) ∧ ∼p(x)), where x
is a list of distinct object variables, for each negative predicate ∼p. We consider coherent
interpretations only.
Example 1 The following is a representation of the Blocks World in the syntax of logic
programs:
⊥
ıOn(b, l, t + 1)
⊥
⊥
ıOn(b, l, 0)
∼ıOn(b, l, 0)
ıM ove(b, l, t)
∼ıM ove(b, l, t)
ıOn(b, l, t + 1)
∼ıOn(b, l, t)

←
←
←
←
←
←
←
←
←
←

ıOn(b1 , b, t), ıOn(b2 , b, t)
(b1 6= b2 )
ıM ove(b, l, t)
ıM ove(b, l, t), ıOn(b1 , b, t)
ıM ove(b, b1 , t), ıM ove(b1 , l, t)
ınot ∼ıOn(b, l, 0)
ınot ıOn(b, l, 0)
ınot ∼ıM ove(b, l, t)
ınot ıM ove(b, l, t)
ıOn(b, l, t), ınot ∼ıOn(b, l, t + 1)
ıOn(b, l1 , t)
(l =
6 l1 ) .

(7)

A Functional View of Strong Negation in Answer Set Programming

53

Here ıOn and ıM ove are intensional predicate constants, b, b1 , b2 are variables ranging
over the blocks, l, l1 are variables ranging over the locations (blocks and the table), and t
is a variable ranging over the timepoints. The first rule asserts that at most one block can
be on another block. The next three rules describe the effect and preconditions of action
ıM ove. The next four rules describe that fluent ıOn is initially exogenous, and action
ıM ove is exogenous at each time. The next rule describes inertia, and the last rule asserts
that a block can be at most at one location.
2.2

Review: The Functional Stable Model Semantics

The functional stable model semantics is defined by modifying the semantics in the previous section to allow “intensional” functions [Bartholomew and Lee, 2012]. For predicate
symbols (constants or variables) u and c, we define u ≤ c as ∀x(u(x) → c(x)). We define
u = c as ∀x(u(x) ↔ c(x)) if u and c are predicate symbols, and ∀x(u(x) = c(x)) if they
are function symbols.
Let c be a list of distinct predicate and function constants and let b
c be a list of distinct
predicate and function variables corresponding to c. We call members of c intensional
constants. By cpred we mean the list of the predicate constants in c, and by b
cpred the list of
pred
pred
the corresponding predicate variables in b
c. We define b
c < c as (b
c
≤c
)∧¬(b
c = c)
and SM[F ; c] as
F ∧ ¬∃b
c(b
c < c ∧ F ∗ (b
c)),
where F ∗ (b
c) is defined the same as the one in Section 2.1 except for the base case:
– When F is an atomic formula, F ∗ is F 0 ∧F , where F 0 is obtained from F by replacing
all intensional (function and predicate) constants in it with the corresponding (function
and predicate) variables.
If c contains predicate constants only, this definition of a stable model reduces to the
one in [Ferraris et al., 2011], also reviewed in Section 2.1.
According to [Bartholomew and Lee, 2012], a choice formula {F } is an abbreviation
of the formula F ∨ ¬F , which is also strongly equivalent to ¬¬F → F . A formula
{t = t0 }, where t contains an intensional function constant and t0 does not, represents
that t takes the value t0 by default, as the following example demonstrates.
Example 2 Let F1 be {f = 1}, which stands for (f = 1) ∨ ¬(f = 1), and I1 be an
interpretation such that I1 (f ) = 1. Let’s assume that we consider only interpretations
that map numbers to themselves. I1 is an f -stable model of F1 : F1∗ (fb) is equivalent to
((fb= 1)∧(f = 1))∨¬(f = 1),3 which is further equivalent to (fb= 1) under the assumption
I1 . It is not possible to satisfy this formula by assigning fb a different value from I1 (f ).
On the other hand, I2 such that I2 (f ) = 2 is not f -stable since F1∗ (fb) is equivalent to >
under I2 , so that it is possible to satisfy this formula by assigning fb a different value from
I2 (f ). If we let F2 be {f = 1} ∧ (f = 2), then I2 is a f -stable of F2 , but I1 is not: F2∗ (fb)
is equivalent to fb= 2 under I2 , so that fb has to map to 2 as well. This example illustrates
the nonmonotonicity of the semantics.
3

It holds that (¬F )∗ is equivalent to ¬F .

54

M. Bartholomew and J. Lee

Example 3 The Blocks World can be described in this language as follows. For readability, we write in a logic program like syntax:
⊥
ıLoc(b, t+1) = l
⊥
⊥
{ıLoc(b, 0) = l}
{ıM ove(b, l, t)}
{ıLoc(b, t+1) = l}

←
←
←
←

ıLoc(b1 , t) = b ∧ ıLoc(b2 , t) = b ∧ (b1 6= b2 )
ıM ove(b, l, t)
ıM ove(b, l, t) ∧ ıLoc(b1 , t) = b
ıM ove(b, b1 , t) ∧ ıM ove(b1 , l, t)

← ıLoc(b, t) = l .

Here ıLoc is a function constant. The last rule is a default formula that describes the commonsense law of inertia. The stable models of this program are the models of SM[F ; ıLoc, ıM ove],
where F is the FOL-representation of the program.
2.3

Review: Stable Models of Multi-Valued Propositional Formulas

The following is a review of the stable model semantics of multi-valued propositional
formulas from [Bartholomew and Lee, 2012], which can be viewed as a special case of the
functional stable model semantics in the previous section.
The syntax of multi-valued propositional formulas is given in [Ferraris et al., 2011].
A multi-valued propositional signature is a set σ of symbols called constants, along with
a nonempty finite set ıDom(c) of symbols, disjoint from σ, assigned to each constant c. We
call ıDom(c) the domain of c. A Boolean constant is one whose domain is the set {TRUE, FALSE}.
An atom of a signature σ is an expression of the form c = v (“the value of c is v”) where
c ∈ σ and v ∈ ıDom(c). A (multi-valued propositional) formula of σ is a propositional
combination of atoms.
A (multi-valued propositional) interpretation of σ is a function that maps every element
of σ to an element of its domain. An interpretation I satisfies an atom c = v (symbolically,
I |= c = v) if I(c) = v. The satisfaction relation is extended from atoms to arbitrary formulas according to the usual truth tables for the propositional connectives. I is a model of
a formula if it satisfies the formula.
The reduct F I of a multi-valued propositional formula F relative to a multi-valued
propositional interpretation I is the formula obtained from F by replacing each maximal
subformula that is not satisfied by I with ⊥. Interpretation I is a stable model of F if I is
the only interpretation satisfying F I .
Example 4 Similar to Example 2, consider the signature σ = {f } such that ıDom(c) =
{1, 2, 3}. Let I1 be an interpretation such that I1 (c) = 1, and I2 be such that I2 (c) = 2.
Recall that {f = 1} is shorthand for (f = 1) ∨ ¬(f = 1). The reduct of this formula relative
to I1 is (f = 1) ∨ ⊥, and I1 is the only model of the reduct. On the other hand, the reduct
of {f = 1} relative to I2 is (⊥ ∨ ¬⊥) and I2 is not its unique model. Also, the reduct of
{f = 1} ∧ (f = 2) relative to I1 is (⊥ ∨ ¬⊥) ∧ ⊥ and I1 is not a model. The reduct of
{f = 1} ∧ (f = 2) relative to I2 is (⊥ ∨ ¬⊥) ∧ (f = 2), and I2 is the only model of the
reduct.

3
3.1

Relating Strong Negation to Boolean Functions
Representing Strong Negation in Multi-Valued Propositional Formulas

Given a traditional propositional logic program Π of a signature σ [Gelfond and Lifschitz,
1991], we identify σ with the multi-valued propositional signature whose constants are the

A Functional View of Strong Negation in Answer Set Programming

55

same symbols from σ and every constant is Boolean. By Π mv we mean the multi-valued
propositional formula that is obtained from Π by replacing negative literals of the form
∼p with p = FALSE and positive literals of the form p with p = TRUE.
We say that a set X of literals from σ is complete if, for each atom a ∈ σ, either
a or ∼ a is in X. We identify a complete set of literals from σ with the corresponding
multi-valued propositional interpretation.
Theorem 1 A complete set of literals is an answer set of Π in the sense of [Gelfond and
Lifschitz, 1991] iff it is a stable model of Π mv in the sense of [Bartholomew and Lee,
2012].
The theorem tells us that checking the minimality of positive and negative literals under
the traditional stable model semantics is essentially the same as checking the uniqueness
of corresponding function values under the stable model semantics from [Bartholomew
and Lee, 2012].
Example 5 Consider the program that describes a simple transition system consisting of
two states depending on whether fluent p is true or false, and an action that makes p true
(subscripts 0 and 1 represent time stamps).
p0 ← ınot ∼p0
∼p0 ← ınot p0
a ← ınot ∼a
∼a ← ınot a

p1 ← a
p1 ← p0 , ınot ∼p1
∼p1 ← ∼p0 , ınot p1 .

(8)

The program has four answer sets, each of which corresponds to one of the four edges of
the transition system. For instance, {∼p0 , a, p1 } is an answer set. This program can be
encoded in the input languages of GRINGO and DLV. In the input language of DLV, which
allows disjunctions in the head of a rule, the four rules in the first column can be succinctly
replaced by
p0 ∨ ∼p0

a∨ ∼a .

According to Theorem 1, the stable models of this program are the same as the stable
models of the following multi-valued propositional formula (written in a logic program
style syntax; ‘¬’ represents default negation):
p0 = TRUE ← ¬(p0 = FALSE)
p0 = FALSE ← ¬(p0 = TRUE)
a = TRUE ← ¬(a = FALSE)
a = FALSE ← ¬(a = TRUE)

3.2

p1 = TRUE ← a = TRUE
p1 = TRUE ← p0 = TRUE ∧ ¬(p1 = FALSE)
p1 = FALSE ← p0 = FALSE ∧ ¬(p1 = TRUE) .

Relation among Strong Negation, Default Negation, Choice Rules and Boolean
Functions

In certain cases, strong negation can be replaced by default negation, and furthermore
the expression can be rewritten in terms of choice rules, which often yields a succinct
representation.
The following theorem, which extends the Theorem on Double Negation from [Ferraris
et al., 2009] to allow intensional functions, presents a condition under which equivalent
transformations in classical logic preserve stable models.

56

M. Bartholomew and J. Lee

Theorem 2 Let F be a sentence, let c be a list of predicate and function constants, and
let I be a (coherent) interpretation. Let F 0 be the sentence obtained from F by replacing
a subformula ¬H with ¬H 0 such that I |= e
∀(H ↔ H 0 ). Then
I |= SM[F ; c] iff I |= SM[F 0 ; c] .
We say that an interpretation is complete on a predicate p if it satisfies ∀x(p(x)∨ ∼p(x)).
It is clear that, for any complete interpretation I, we have I |= ∼p(t) iff I |= ¬p(t). This
fact allows us to use Theorem 2 to replace strong negation occurring in H with default
negation.
Example 5 continued Each answer set of the first program in Example 5 is complete.
In view of Theorem 2, the first two rules can be rewritten as p0 ← ınot ınot p0 and
∼ p0 ← ınot ınot ∼ p0 , which can be further abbreviated as choice rules {p0 } and
{∼p0 }. Consequently, the whole program can be rewritten using choice rules as
{p0 }
{∼p0 }
{a}
{∼a}

p1 ← a
{p1 } ← p0
{∼p1 } ← ∼p0 .

Similarly, since I |= (p0 = FALSE) iff I |= ¬(p0 = TRUE), in view of Theorem 2, the
first rule of the second program in Example 5 can be rewritten as p0 = TRUE ← ¬¬(p0 = TRUE)
and further as {p0 = TRUE}. This transformation allows us to rewrite the whole program
as
{p0 = B}
{a = B}

p1 = TRUE ← a = TRUE
{p1 = B} ← p0 = B ,

where B ranges over {TRUE, FALSE}. This program represents the transition system more
succinctly than program (8).
3.3

Representing Strong Negation by Boolean Functions in the First-Order Case

Theorem 1 can be extended to the first-order case as follows.
Let f be a function constant. A first-order formula is called f -plain if each atomic
formula
– does not contain f , or
– is of the form f (t) = u where t is a tuple of terms not containing f , and u is a term
not containing f .
For example, f = 1 is f -plain, but each of p(f ), g(f ) = 1, and 1 = f is not f -plain.
For a list c of predicate and function constants, we say that a first-order formula F
is c-plain if F is f -plain for each function constant f in c. Roughly speaking, c-plain
formulas do not allow the functions in c to be nested in another predicate or function, and
at most one function in c is allowed in each atomic formula. For example, f = g is not
(f, g)-plain, and neither is f (g) = 1 → g = 1.
Let F be a formula whose signature contains both positive and negative predicate
(p,∼p)
constants p and ∼p. Formula F b
is obtained from F as follows:

A Functional View of Strong Negation in Answer Set Programming

57

– in the signature of F , replace p and ∼p with a new intensional function constant b of
arity n, where n is the arity of p (or ∼p), and add two non-intensional object constants
TRUE and FALSE ;
– replace every occurrence of ∼p(t), where t is a list of terms, with b(t) = FALSE, and
then replace every occurrence of p(t) with b(t) = TRUE.
By ıBC b (“Boolean Constraint on b”) we denote the conjunction of the following
formulas, which asserts that b is a Boolean function:
TRUE

6= FALSE ,

(9)

¬¬∀x(b(x) = TRUE ∨ b(x) = FALSE) ,
where x is a list of distinct object variables.
Theorem 3 Let c be a set of predicate and function constants, and let F be a c-plain
formula. Formulas
∀x((p(x) ↔ b(x) = TRUE) ∧ (∼p(x) ↔ b(x) = FALSE)),

(10)

and ıBC b entail
SM[F ; p, ∼p, c] ↔ SM[F

(p,∼p)
;
b

b, c] .

If we drop the requirement that F be c-plain, the statement does not hold as in the
following example demonstrates.
(p,∼p)

Example 6 Take c as (f, g) and let F be p(f )∧ ∼ p(g). F b
is b(f ) = TRUE ∧
b(g) = FALSE. Consider the interpretation I whose universe is {1, 2} such that I contains p(1), ∼p(2) and with the mappings bI (1) = TRUE, bI (2) = FALSE, f I = 1, g I = 2.
I certainly satisfies ıBC b and (10). I also satisfies SM[F ; p, ∼p, f, g] but does not satisfy
(p,∼p)
SM[F b
; b, f, g]: we can let I be bbI (1) = FALSE, bbI (2) = TRUE, fbI = 2, gbI = 1 to
(p,∼p) ∗ b b
satisfy both (bb, fb, gb) < (b, f, g) and (F b
) (b, f , gb), which is
b(f ) = TRUE ∧ bb(fb) = TRUE ∧ b(g) = FALSE ∧ bb(b
g ) = FALSE.
Note that any interpretation that satisfies both (10) and ıBC b is complete on p. Theorem 3 tells us that, for any interpretation I that is complete on p, minimizing the extents
of both p and ∼p has the same effect as ensuring that the corresponding Boolean function
b have a unique value.
The following corollary shows that there is a 1–1 correspondence between the stable
(p,∼p)
models of F and the stable models of F b
. For any interpretation I of the signature of
(p,∼p)
(p,∼p)
F that is complete on p, by I b
we denote the interpretation of the signature of F b
I
I
obtained from I by replacing the relation p with function b such that
bI (ξ1 , . . . , ξn ) = TRUEI if pI (ξ1 , . . . , ξn ) = TRUE;
bI (ξ1 , . . . , ξn ) = FALSEI if (∼p)I (ξ1 , . . . , ξn ) = TRUE .
(Notice that we overloaded the symbols TRUE and FALSE: object constants on one hand,
and truth values on the other hand.) Since I is complete on p and coherent, bI is well(p,∼p)
(p,∼p)
defined. We also require that I b
satisfy (9). Consequently, I b
satisfies ıBC b .

58

M. Bartholomew and J. Lee

Corollary 1 Let c be a set of predicate and function constants, and let F be a c-plain
sentence. (I) An interpretation I of the signature of F that is complete on p is a model of
(p,∼p)
(p,∼p)
SM[F ; p, ∼p, c] iff I b
is a model of SM[F b
; b, c]. (II) An interpretation J of
(p,∼p)
(p,∼p)
(p,∼p)
the signature of F b
is a model of SM[F b
∧ ıBC b ; b, c] iff J = I b
for some
model I of SM[F ; p, ∼p, c].
The other direction, eliminating Boolean intensional functions in favor of symmetric
predicates, is similar as we show in the following.
Let F be a (b, c)-plain formula such that every atomic formula containing b has the
form b(t) = TRUE or b(t) = FALSE, where t is any list of terms (not containing members
b
from (b, c)). Formula F(p,∼p)
is obtained from F as follows:
– in the signature of F , replace b with predicate constants p and ∼p, whose arities are
the same as that of b;
– replace every occurrence of b(t) = TRUE, where t is any list of terms, with p(t), and
b(t) = FALSE with ∼p(t).
Theorem 4 Let c be a set of predicate and function constants, let b be a function constant,
and let F be a (b, c)-plain formula such that every atomic formula containing b has the
form b(t) = TRUE or b(t) = FALSE. Formulas (10) and ıBC b entail
b
SM[F ; b, c] ↔ SM[F(p,∼p)
; p, ∼p, c] .

The following corollary shows that there is a 1–1 correspondence between the stable
b
models of F and the stable models of F(p,∼p)
. For any interpretation I of the signature of
b
b
F that satisfies ıBC b , by I(p,∼p) we denote the interpretation of the signature of F(p,∼p)
obtained from I by replacing the function bI with predicate pI such that
pI (ξ1 , . . . , ξn ) = TRUE iff bI (ξ1 , . . . , ξn ) = TRUEI ;
(∼p)I (ξ1 , . . . , ξn ) = TRUE iff bI (ξ1 , . . . , ξn ) = FALSEI .
Corollary 2 Let c be a set of predicate and function constants, let b be a function constant,
and let F be a (b, c)-plain sentence such that every atomic formula containing b has the
form b(t) = TRUE or b(t) = FALSE. (I) An interpretation I of the signature of F is
b
b
a model of SM[F ∧ ıBC b ; b, c] iff I(p,∼p)
is a model of SM[F(p,∼p)
; p, ∼p, c]. (II) An
b
b
interpretation J of the signature of F(p,∼p) is a model of SM[F(p,∼p)
; p, ∼p, c] iff J =
b
I(p,∼p) for some model I of SM[F ∧ ıBC b ; b, c].
An example of this corollary is shown in the next section.

4

Representing Non-Boolean Functions Using Strong Negation

In this section, we show how to eliminate non-Boolean intensional functions in favor of
Boolean intensional functions. Combined with the method in the previous section, it gives
us a systematic method of representing non-Boolean intensional functions using strong
negation.

A Functional View of Strong Negation in Answer Set Programming

4.1

59

Eliminating non-Boolean Functions in Favor of Boolean Functions

Let F be an f -plain formula. Formula Fbf is obtained from F as follows:
– in the signature of F , replace f with a new boolean intensional function b of arity
n + 1 where n is the arity of f ;
– replace each subformula f (t) = c with b(t, c) = TRUE.
By ıU E b , we denote the following formulas that preserve the functional property:
∀xyz(y 6= z ∧ b(x, y) = TRUE → b(x, z) = FALSE),
¬¬∀x∃y(b(x, y) = TRUE),
where x is a n-tuple of variables and all variables in x, y, and z are pairwise distinct.
Theorem 5 For any f -plain formula F ,

∀xy (f (x) = y ↔ b(x, y) = TRUE) ∧ (f (x) 6= y ↔ b(x, y) = FALSE)
and ∃xy(x 6= y) entail
SM[F ; f, c] ↔ SM[Fbf ∧ ıU E b ; b, c] .
By Ibf , we denote the interpretation of the signature of Fbf obtained from I by replacing
the mapping f I with the mapping bI such that
bI (ξ1 , . . . , ξn , ξn+1 ) = TRUEI if f I (ξ1 , . . . , ξn ) = ξn+1
bI (ξ1 , . . . , ξn , ξn+1 ) = FALSEI otherwise.
Corollary 3 Let F be an f -plain sentence. (I) An interpretation I of the signature of
F that satisfies ∃xy(x 6= y) is a model of SM[F ; f, c] iff Ibf is a model of SM[Fbf ∧
ıU E b ; b, c]. (II) An interpretation J of the signature of Fbf that satisfies ∃xy(x 6= y) is a
model of SM[Fbf ∧ ıU E b ; b, c] iff J = Ibf for some model I of SM[F ; f, c].
Example 3 continued In the program in Example 3, we eliminate non-Boolean function
ıLoc in favor of Boolean function ıOn as follows. The last two rules are ıU E On .
⊥
ıOn(b, l, t + 1) = TRUE
⊥
⊥
{ıOn(b, l, 0) = TRUE}
{ıM ove(b, l, t)}
{ıOn(b, l, t + 1) = TRUE}
ıOn(b, l, t) = FALSE
⊥

←
←
←
←

ıOn(b1 , b, t) = TRUE ∧ ıOn(b2 , b, t) = TRUE ∧ b1 6= b2
ıM ove(b, l, t)
ıM ove(b, l, t) ∧ ıOn(b1 , b, t) = TRUE
ıM ove(b, b1 , t) ∧ ıM ove(b1 , l, t)

← ıOn(b, l, t) = TRUE
← ıOn(b, l1 , t) = TRUE ∧ l 6= l1
← ınot ∃l(ıOn(b, l, t) = TRUE) .

For this program, it is not difficult to check that the last rule is redundant. Indeed, since
the second to the last rule is the only rule that has ıOn(b, l, t) = FALSE in the head, one
can check that any model that does not satisfy ∃l(ıOn(b, l, t) = TRUE) is not stable even if
we drop the last rule.

60

M. Bartholomew and J. Lee

Corollary 2 tells us that this program can be represented by an answer set program
containing strong negation (with the redundant rule dropped).
⊥
ıOn(b, l, t + 1)
⊥
⊥
{ıOn(b, l, 0)}
{ıM ove(b, l, t)}
{ıOn(b, l, t + 1)}
∼ıOn(b, l, t)

←
←
←
←

ıOn(b1 , b, t), ıOn(b2 , b, t)
(b1 6= b2 )
ıM ove(b, l, t)
ıM ove(b, l, t), ıOn(b1 , b, t)
ıM ove(b, b1 , t), ıM ove(b1 , l, t)

← ıOn(b, l, t)
← ıOn(b, l1 , t)

(11)

(l 6= l1 ) .

Let us compare this program with program (7). Similar to the explanation in Example 5
(continued), the 5th and the 7th rules of (7) can be represented using choice rules, which
are the same as the 5th and the 6th rules of (11). The 6th and the 8th rules of (7) represent
the closed world assumption. We can check that adding these rules to (11) extends the
answer sets of (7) in a conservative way with the definition of the negative literals. This
tells us that the answer sets of the two programs are in a 1-1 correspondence.
As the example explains, non-Boolean functions can be represented using strong negation by composing the two translations, first eliminating non-Boolean functions in favor
of Boolean functions as in Corollary 3 and then eliminating Boolean functions in favor of
predicates as in Corollary 2. In the following we state this composition.
Let F be an f -plain formula where f is an intensional function constant. Formula Fpf
is obtained from F as follows:
– in the signature of F , replace f with two new intensional predicates p and ∼p of arity
n + 1 where n is the arity of f ;
– replace each subformula f (t) = c with p(t, c).
By ıU E p , we denote the following formulas that preserve the functional property:
∀xyz(y 6= z ∧ p(x, y) → ∼p(x, z)) ,
¬¬∀x∃y p(x, y) ,
where x is an n-tuple of variables and all variables in x, y, z are pairwise distinct.
Theorem 6 For any (f, c)-plain formula F , formulas
∀xy(f (x) = y ↔ p(x, y)), ∀xy(f (x) 6= y ↔ ∼p(x, y)), ∃xy(x 6= y)
entail
SM[F ; f, c] ↔ SM[Fpf ∧ ıU E p ; p, ∼p, c] .
f
f
By I(p,∼p)
, we denote the interpretation of the signature of F(p,∼p)
obtained from I by
replacing the function f I with the relation pI that consists of the tuples hξ1 , . . . , ξn , f I (ξ1 , . . . , ξn )i
for all ξ1 , . . . , ξn from the universe of I. We then also add the set (∼p)I that consists of the
tuples hξ1 , . . . , ξn , ξn+1 i for all ξ1 , . . . , ξn , ξn+1 from the universe of I that do not occur
in the set pI .

A Functional View of Strong Negation in Answer Set Programming

61

Corollary 4 Let F be an (f, c)-plain sentence. (I) An interpretation I of the signature
f
is a model of
of F that satisfies ∃xy(x 6= y) is a model of SM[F ; f, c] iff I(p,∼p)
f
f
SM[Fp ∧ ıU E p ; p, ∼p, c]. (II) An interpretation J of the signature of Fp that satisfies
f
for some model I of
∃xy(x 6= y) is a model of SM[Fpf ∧ ıU E p ; p, ∼p, c] iff J = I(p,∼p)
SM[F ; f, c].
Theorem 6 and Corollary 4 are similar to Theorem 8 and Corollary 2 from [Bartholomew
and Lee, 2012]. The main difference is that the latter statements refer to the constraint
called ıU EC p that is weaker than ıU E p . For instance, the elimination method from [Bartholomew
and Lee, 2012] turns the Blocks World in Example 3 into almost the same program as (11)
except that the last rule is turned into the constraint ıU EC On :
← ıOn(b, l, t) ∧ ıOn(b, l1 , t) ∧ l 6= l1 .

(12)

It is clear that the stable models of Fpf ∧ıU E p are under the symmetric view, and the stable
models of Fpf ∧ ıU EC p are under the asymmetric view. To see how replacing ıU E On by
ıU EC On turns the symmetric view to the asymmetric view, first observe that adding (12)
to program (11) does not affect the stable models of the program. Let’s call this program
Π. It is easy to see that Π is a conservative extension of the program that is obtained from
Π by deleting the rule with ∼ıOn(b, l, t) in the head.

5

Relating to Lifschitz’s Two-Valued Logic Programs

Lifschitz [2012] presented a high level definition of a logic program that does not contain
explicit default negation, but can handle nonmonotonic reasoning in a similar style as
in Reiter’s default logic. In this section we show how his formalism can be viewed as a
special case of multi-valued propositional formulas under the stable model semantics in
which every function is Boolean.
5.1

Review: Two-Valued Logic Programs

Let σ be a signature in propositional logic. A two-valued rule is an expression of the form
L0 ← L1 , . . . , Ln : F

(13)

where L0 , . . . , Ln are propositional literals formed from σ and F is a propositional formula of signature σ.
A two-valued program Π is a set of two-valued rules. An interpretation I is a function
from σ to {TRUE, FALSE}. The reduct of a program Π relative to an interpretation I,
denoted Π I , is the set of rules L0 ← L1 , . . . , Ln corresponding to the rules (13) of Π
for which I |= F . Interpretation I is a stable model of Π if it is a minimal model of Π I .
Example 7
a ←

: a,

¬a ← : ¬a,

b ← a : >

(14)

The reduct of this program relative to {a, b} consists of rules a and b ← a. Interpretation
{a, b} is the minimal model of the reduct, so that it is a stable model of the program.
As described in [Lifschitz, 2012], if F in every rule (13) has the form of conjunctions
of literals, then the two-valued logic program can be turned into a traditional answer set

62

M. Bartholomew and J. Lee

program containing strong negation when we consider complete answer sets only. For
instance, program (14) can be turned into
a ← ınot ∼a,

∼a ← ınot a,

b ← a.

This program has two answer sets, {a, b} and ∼a, and only the complete answer set {a, b}
corresponds to the stable model found in Example 7.
5.2

Translation into SM with Boolean Functions

Given a two-valued logic program Π of a signature σ, we identify σ with the multi-valued
propositional signature whose constants are from σ and the domain of every constant is
Boolean values {TRUE, FALSE}. For any propositional formula G, ıT r(G) is obtained
from G by replacing every negative literal ∼A with A = FALSE and every positive literal A
with A = TRUE. By ıtv2sm(Π) we denote the multi-valued propositional formula which
is defined as the conjunction of
¬¬ıT r(F ) ∧ ıT r(L1 ) ∧ · · · ∧ ıT r(Ln ) → ıT r(L0 )
for each rule (13) in Π.
For any interpretation I of σ, we obtain the multi-valued interpretation I 0 from I as
follows. For each atom A in σ,

TRUE
if I |= A
0
I (A) =
FALSE
if I |= ¬A
Theorem 7 For any two-valued logic program Π, an interpretation I is a stable model of
Π in the sense of [Lifschitz, 2012] iff I 0 is a stable model of ıtv2sm(Π) in the sense of
[Bartholomew and Lee, 2012].
Example 7 continued For the program Π in Example 7, ıtv2sm(Π) is the following
multi-valued propositional formula:



¬¬(a = TRUE) → a = TRUE ∧ ¬¬(a = FALSE) → a = FALSE ∧ a = TRUE → b = TRUE .

According to [Bartholomew and Lee, 2012], this too has only one stable model in which a
and b are both mapped to TRUE, corresponding to the only stable model of Π according
to Lifschitz.
Consider extending the rules (13) to contain variables. It is not difficult to see that
the translation ıtv2sm(Π) can be straightforwardly extended to non-ground programs.
This accounts for providing the semantics of the first-order extension of two-valued logic
programs.

6

Strong Negation and the Cabalar Semantics

There are other stable model semantics of intensional functions. Theorem 5 from [Bartholomew
and Lee, 2013] states that the semantics by Bartholomew and Lee [2013] coincides with
the semantics by Cabalar [2011] on c-plain formulas. Thus several theorems in this note
stated for the Bartholomew-Lee semantics hold also under the Cabalar semantics.
A further result holds with the Cabalar semantics since it allows functions to be partial.
This provides extensions of Theorem 3 and Corollary 1, which do not require the interpretations to be complete. Below we state this result. Due to lack of space, we refer the reader

A Functional View of Strong Negation in Answer Set Programming

63

to [Bartholomew and Lee, 2013] for the definition of CBL, which is the second-order
expression used to define the Cabalar semantics.
Similar to ıBC b in Section 3.3, by ıBC 0b we denote the conjunction of the following
formulas:
TRUE 6= FALSE,
(15)
¬¬∀x(b(x) = TRUE ∨ b(x) = FALSE ∨ b(x) 6= b(x)),
where x is a list of distinct object variables.4
Theorem 8 Let c be a set of predicate constants, and let F be a formula. Formulas
∀x((p(x) ↔ b(x) = TRUE)∧(∼p(x) ↔ b(x) = FALSE)∧(¬p(x)∧¬ ∼p(x) ↔ b(x) 6= b(x)),
and ıBC 0b entail 5
SM[F ; p, ∼p, c] ↔ CBL[F

(p,∼p)
;
b

b, c] .

The following corollary shows that there is a 1–1 correspondence between the stable
(p,∼p) 6
models of F and the stable models of F b
. For any interpretation I of the signature
(p,∼p)
(p,∼p)
of F , by I b
we denote the interpretation of the signature of F b
obtained from I
by replacing the relation pI with function bI such that
bI (ξ) = TRUEI if pI (ξ) = TRUE ;
bI (ξ) = FALSEI if (∼p)I (ξ) = TRUE ;
bI (ξ) = u if pI (ξ) = (∼p)I (ξ) = FALSE .
Since I is coherent, bI is well-defined. We also require that I
(p,∼p)
quently, I b
satisfies ıBC 0b .

(p,∼p)
b

satisfy (15). Conse-

Corollary 5 Let F be a sentence, and let c be a set of predicate constants. (I) An in(p,∼p)
terpretation I of the signature of F is a model of SM[F ; p, ∼p, c] iff I b
is a model
(p,∼p)
(p,∼p)
of CBL[F b
; b, c]. (II) An interpretation J of the signature of F b
is a model of
(p,∼p)
(p,∼p)
for some model I of SM[F ; p, ∼p, c].
CBL[F b
∧ ıBC 0b ; b, c] iff J = I b

7

Conclusion

In this note, we showed that, under complete interpretations, symmetric predicates using
strong negation can be alternatively expressed in terms of Boolean intensional functions
in the language of [Bartholomew and Lee, 2012]. They can also be expressed in terms of
Boolean intensional functions in the language of [Cabalar, 2011], but without requiring
the complete interpretation assumption, at the price of relying on the notion of partial
interpretations.
System CPLUS 2 ASP [Casolary and Lee, 2011; Babb and Lee, 2013] turns action language C+ into answer set programs containing asymmetric predicates. The translation in
4

5
6

Under partial interpretations, b(t) 6= b(t) is true if b(t) is undefined. See [Cabalar, 2011;
Bartholomew and Lee, 2013] for more details.
The entailment is under partial interpretations and satisfaction.
Recall the notation defined in Section 3.3.

64

M. Bartholomew and J. Lee

this paper that eliminates intensional functions in favor of symmetric predicates provides
an alternative method of computing C+ using ASP solvers.
Acknowledgements: We are grateful to Vladimir Lifschitz for bringing attention to this
subject, to Gregory Gelfond for useful discussions related to this paper, and to anonymous referees for useful comments. This work was partially supported by the National
Science Foundation under Grant IIS-0916116 and by the South Korea IT R&D program
MKE/KIAT 2010-TD-300404-001.

References
Babb and Lee, 2013. Joseph Babb and Joohyung Lee. C PLUS 2ASP: Computing action language
C+ in answer set programming. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 2013. To appear.
Bartholomew and Lee, 2012. Michael Bartholomew and Joohyung Lee. Stable models of formulas
with intensional functions. In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR), pages 2–12, 2012.
Bartholomew and Lee, 2013. Michael Bartholomew and Joohyung Lee. On the stable model semantics for intensional functions. TPLP, 2013. To appear.
Cabalar, 2011. Pedro Cabalar. Functional answer set programming. TPLP, 11(2-3):203–233, 2011.
Casolary and Lee, 2011. Michael Casolary and Joohyung Lee. Representing the language of the
causal calculator in answer set programming. In ICLP (Technical Communications), pages 51–61,
2011.
Ferraris et al., 2009. Paolo Ferraris, Joohyung Lee, Vladimir Lifschitz, and Ravi Palla. Symmetric
splitting in the general theory of stable models. In Proceedings of International Joint Conference
on Artificial Intelligence (IJCAI), pages 797–803. AAAI Press, 2009.
Ferraris et al., 2011. Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. Stable models and circumscription. Artificial Intelligence, 175:236–263, 2011.
Gelfond and Lifschitz, 1991. Michael Gelfond and Vladimir Lifschitz. Classical negation in logic
programs and disjunctive databases. New Generation Computing, 9:365–385, 1991.
Lifschitz, 2002. Vladimir Lifschitz. Answer set programming and plan generation. Artificial Intelligence, 138:39–54, 2002.
Lifschitz, 2012. Vladimir Lifschitz. Two-valued logic programs. In ICLP (Technical Communications), pages 259–266, 2012.

Proceedings of the Thirty-First AAAI Conference on Artificial Intelligence (AAAI-17)

LPMLN Weak Constraints, and P-log
Joohyung Lee and Zhun Yang
School of Computing, Informatics and Decision Systems Engineering
Arizona State University, Tempe, USA
{joolee, zyang90}@asu.edu

of the stable model semantics but has turned out to be useful in many practical applications. Weak constraints are part
of the ASP Core 2 language (Calimeri et al. 2013), and are
implemented in standard ASP solvers, such as CLINGO and
DLV .
P-log is a probabilistic extension of answer set programs.
In contrast to weak constraints, it is highly structured and has
quite a sophisticated semantics. One of its distinct features is
probabilistic nonmonotonicity (the ability of the reasoner to
change his probabilistic model as a result of new information) whereas, in most other probabilistic logic languages,
new information can only cause the reasoner to abandon
some of his possible worlds, making the effect of an update
monotonic.
This paper reveals interesting relationships between
LPMLN and these two extensions of answer set programs.
It shows how different weight schemes of LPMLN and weak
constraints are related, and how the probabilistic reasoning
in P-log can be expressed in LPMLN . The result helps us
understand these languages better as well as other related
languages, and also provides new, effective computational
methods based on the translations.
It is shown in (Lee and Wang 2016) that programs with
weak constraints can be easily viewed as a special case of
LPMLN programs. In the ﬁrst part of this paper, we show
that an inverse translation is also possible under certain conditions, i.e., an LPMLN program can be turned into a usual
ASP program with weak constraints so that the most probable stable models of the LPMLN program are exactly the
optimal stable models of the program with weak constraints.
The result allows for using ASP solvers for computing Maximum A Posteriori probability (MAP) estimates of LPMLN
programs. Interestingly, the translation is quite simple so it
can be easily applied in practice. Further, the result implies
that MAP inference in other probabilistic logic languages,
such as Markov Logic, ProbLog, and Pearl’s Causal Models, can be computed by standard ASP solvers because they
are known to be embeddable in LPMLN , thereby allowing us
to apply combinatorial optimization in standard ASP solvers
to MAP inference in these languages.
In the second part of the paper, we show how P-log can be
completely characterized in LPMLN . Unlike the translation
in (Lee and Wang 2016), which was limited to a subset of

Abstract
LPMLN is a recently introduced formalism that extends answer set programs by adopting the log-linear weight scheme
of Markov Logic. This paper investigates the relationships
between LPMLN and two other extensions of answer set programs: weak constraints to express a quantitative preference
among answer sets, and P-log to incorporate probabilistic uncertainty. We present a translation of LPMLN into programs
with weak constraints and a translation of P-log into LPMLN ,
which complement the existing translations in the opposite
directions. The ﬁrst translation allows us to compute the most
probable stable models (i.e., MAP estimates) of LPMLN programs using standard ASP solvers. This result can be extended to other formalisms, such as Markov Logic, ProbLog,
and Pearl’s Causal Models, that are shown to be translatable
into LPMLN . The second translation tells us how probabilistic nonmonotonicity (the ability of the reasoner to change his
probabilistic model as a result of new information) of P-log
can be represented in LPMLN , which yields a way to compute
P-log using standard ASP solvers and MLN solvers.

Introduction
MLN

LP
(Lee and Wang 2016) is a recently introduced probabilistic logic programming language that extends answer
set programs (Gelfond and Lifschitz 1988) with the concept of weighted rules, whose weight scheme is adopted
from that of Markov Logic (Richardson and Domingos
2006). It is shown in (Lee and Wang 2016; Lee, Meng,
and Wang 2015) that LPMLN is expressive enough to embed Markov Logic and several other probabilistic logic languages, such as ProbLog (De Raedt, Kimmig, and Toivonen
2007), Pearls’ Causal Models (Pearl 2000), and a fragment
of P-log (Baral, Gelfond, and Rushton 2009).
Among several extensions of answer set programs to overcome the deterministic nature of the stable model semantics,
LPMLN is one of the few languages that incorporate the concept of weights into the semantics. Another one is weak
constraints (Buccafurri, Leone, and Rullo 2000), which are
to assign a quantitative preference over the stable models of
non-weak constraint rules: weak constraints cannot be used
for deriving stable models. It is relatively a simple extension
c 2017, Association for the Advancement of Artiﬁcial
Copyright 
Intelligence (www.aaai.org). All rights reserved.

1170

and Rullo 2000; Calimeri et al. 2013), where F was restricted to conjunctions of literals.1 We will see the generalization is more convenient for stating our result, but will also
present translations that conform to the restrictions imposed
on the input language of ASP solvers.
Let Π be a program Π1 ∪ Π2 , where Π1 is a set of ground
formulas and Π2 is a set of weak constraints. We call I a
stable model of Π if it is a stable model of Π1 (in the sense of
(Ferraris, Lee, and Lifschitz 2011)). For every stable model
I of Π and any nonnegative integer l, the penalty of I at
level l, denoted by PenaltyΠ (I, l), is deﬁned as

w.

P-log that does not allow dynamic default probability, our
translation applies to full P-log and complements the recent
translation from LPMLN into P-log in (Balai and Gelfond
2016). In conjunction with the embedding of LPMLN in answer set programs with weak constraints, our work shows
how MAP estimates of P-log can be computed by standard
ASP solvers, which provides a highly efﬁcient way to compute P-log.

Preliminaries
Review: LP

MLN

We review the deﬁnition of LPMLN from (Lee and Wang
2016). In fact, we consider a more general syntax of programs than the one from (Lee and Wang 2016), but this is not
an essential extension. We follow the view of (Ferraris, Lee,
and Lifschitz 2011) by identifying logic program rules as a
special case of ﬁrst-order formulas under the stable model
semantics. For example, rule r(x) ← p(x), not q(x) is identiﬁed with formula ∀x(p(x) ∧ ¬q(x) → r(x)). An LPMLN
program is a ﬁnite set of weighted ﬁrst-order formulas w : F
where w is a real number (in which case the weighted formula is called soft) or α for denoting the inﬁnite weight (in
which case it is called hard). An LPMLN program is called
ground if its formulas contain no variables. We assume a ﬁnite Herbrand Universe. Any LPMLN program can be turned
into a ground program by replacing the quantiﬁers with multiple conjunctions and disjunctions over the Herbrand Universe. Each of the ground instances of a formula with free
variables receives the same weight as the original formula.
For any ground LPMLN program Π and any interpretation I, Π denotes the unweighted formula obtained from Π,
and ΠI denotes the set of w : F in Π such that I |= F , and
SM[Π] denotes the set {I | I is a stable model of ΠI } (We
refer the reader to the stable model semantics of ﬁrst-order
formulas in (Ferraris, Lee, and Lifschitz 2011)). The unnormalized weight of an interpretation I under Π is deﬁned
as

⎧ 

⎨
exp
w
if I ∈ SM[Π];
WΠ (I) =
w:F ∈ ΠI
⎩
0

:∼ F [w@l]∈Π2 ,
I|=F

For any two stable models I and I  of Π, we say I is dominated by I  if
• there is some nonnegative integer l such that
PenaltyΠ (I  , l) < PenaltyΠ (I, l) and
• for all integers k > l, PenaltyΠ (I  , k) = PenaltyΠ (I, k).
A stable model of Π is called optimal if it is not dominated
by another stable model of Π.

Turning LPMLN into Programs with Weak
Constraints
General Translation
We deﬁne a translation that turns an LPMLN program into
a program with weak constraints. For any ground LPMLN
program Π, the translation lpmln2wc(Π) is simply deﬁned
as follows. We turn each weighted formula w : F in Π
into {F }ch , where {F }ch is a choice formula, standing for
F ∨ ¬F (Ferraris, Lee, and Lifschitz 2011). Further, we add
if w is α, and

The normalized weight (a.k.a. probability) of an interpretation I under Π is deﬁned as
α→∞

(1)

:∼ F [−w@0]

(2)

otherwise.
Intuitively, choice formula {F }ch allows F to be either
included or not in deriving a stable model.2 When F is included, the stable model gets the (negative) penalty −1 at
level 1 or −w at level 0 depending on the weight of the formula, which corresponds to the (positive) “reward” eα or ew
that it receives under the LPMLN semantics.
The following proposition tells us that choice formulas
can be used for generating the members of SM[Π].

otherwise.

PΠ (I) = lim

:∼ F [−1@1]

W (I)
 Π
.
WΠ (J)

Proposition 1 For any LPMLN program Π, the set SM[Π]
is exactly the set of the stable models of lpmln2wc(Π).
The following theorem follows from Proposition 1. As
the probability of a stable model of an LPMLN program Π
increases, the penalty of the corresponding stable model of
lpmln2wc(Π) decreases, and the distinction between hard
rules and soft rules can be simulated by the different levels
of weak constraints, and vice versa.

J∈SM[Π]

I is called a (probabilistic) stable model of Π if PΠ (I) = 0.

Review: Weak Constraints
A weak constraint has the form
:∼ F [Weight @ Level].
where F is a ground formula, Weight is a real number and
Level is a nonnegative integer. Note that the syntax is more
general than the one from the literature (Buccafurri, Leone,

1

A literal is either an atom p or its negation not p.
This view of choice formulas was used in PrASP (Nickles and
Mileo 2014) in deﬁning spanning programs.
2

1171

Theorem 1 For any LPMLN program Π, the most probable
stable models (i.e., the stable models with the highest probability) of Π are precisely the optimal stable models of the
program with weak constraints lpmln2wc(Π).

the program in Example 2 can be translated into programs
with weak constraints as follows.
Bird(Jo) ← ResidentBird(Jo)
Bird(Jo) ← MigratoryBird(Jo)
⊥ ← ResidentBird(Jo), MigratoryBird(Jo)
{ResidentBird(Jo)}ch
{MigratoryBird(Jo)}ch

Example 1 For program Π:
10 :
1:

5:
−20 :

p→q
p→r

p
¬r → ⊥

(3)

:∼ ResidentBird(Jo)
:∼ MigratoryBird(Jo)

SM[Π] has 5 elements: ∅, {p}, {p, q}, {p, r}, {p, q, r}.
Among them, {p, q} is the most probable stable model,
whose weight is e15 , while {p, q, r} is a probabilistic stable
model whose weight is e−4 . The translation yields
{p → q}ch
{p → r}ch
{p}ch
{¬r → ⊥}ch

:∼
:∼
:∼
:∼

p→q
p→r
p
¬r → ⊥

Also note that while the most probable stable models
of Π and the optimal stable models of lpmln2wc(Π) coincide, their weights and penalties are not proportional to
each other. The former is deﬁned by an exponential function whose exponent is the sum of the weights of the satisﬁed formulas, while the latter simply adds up the penalties of
the satisﬁed formulas. On the other hand, they are monotonically increasing/decreasing as more formulas are satisﬁed.
In view of Theorem 2 from (Lee and Wang 2016), which
tells us how to embed Markov Logic into LPMLN , it follows from Theorem 1 that MAP inference in MLN can also
be reduced to the optimal stable model ﬁnding of programs
with weak constraints. For any Markov Logic Network Π,
let mln2wc(Π) be the union of lpmln2wc(Π) plus choice
rules {A}ch for all atoms A.

[−10 @ 0]
[−1 @ 0]
[−5 @ 0]
[20 @ 0]

whose optimal stable model is {p, q} with the penalty at level
0 being −15, while {p, q, r} is a stable model whose penalty
at level 0 is 4.
The following example illustrates how the translation accounts for the difference between hard rules and soft rules
by assigning different levels.
Example 2 Consider the LPMLN program Π in Example 1
from (Lee and Wang 2016).
α:
α:
α:
2:
1:

Bird(Jo) ← ResidentBird(Jo)
Bird(Jo) ← MigratoryBird(Jo)
⊥ ← ResidentBird(Jo), MigratoryBird(Jo)
ResidentBird(Jo)
MigratoryBird(Jo)

Theorem 2 For any Markov Logic Network Π, the most
probable models of Π are precisely the optimal stable models of the program with weak constraints mln2wc(Π).

(r1)
(r2)
(r3)
(r4)
(r5)

Similarly, MAP inference in ProbLog and Pearl’s Causal
Models can be reduced to ﬁnding an optimal stable model of
a program with weak constraints in view of the reduction of
ProbLog to LPMLN (Theorem 4 from (Lee and Wang 2016))
and the reduction of Causal Models to LPMLN (Theorem 4
from (Lee, Meng, and Wang 2015)) thereby allowing us to
apply combinatorial optimization methods in standard ASP
solvers to these languages.

The translation lpmln2wc(Π) is 3
{Bird(Jo) ← ResidentBird(Jo)}ch
{Bird(Jo) ← MigratoryBird(Jo)}ch
{⊥ ← ResidentBird(Jo), MigratoryBird(Jo)}ch
{ResidentBird(Jo)}ch
{MigratoryBird(Jo)}ch
:∼ Bird(Jo) ← ResidentBird(Jo)
:∼ Bird(Jo) ← MigratoryBird(Jo)
:∼ ⊥ ← ResidentBird(Jo), MigratoryBird(Jo)}
:∼ ResidentBird(Jo)
:∼ MigratoryBird(Jo)

[−2@0]
[−1@0]

Alternative Translations
Instead of aggregating the weights of satisﬁed formulas, we
may aggregate the weights of formulas that are not satisﬁed.
Let lpmln2wcpnt (Π) be a modiﬁcation of lpmln2wc(Π) by
replacing (1) with

[−1@1]
[−1@1]
[−1@1]
[−2@0]
[−1@0]

:∼ ¬F [1@1]

The

three
probabilistic
stable
models
of
Π,
∅,
{Bird(Jo), ResidentBird(Jo)},
and
{Bird(Jo), MigratoryBird(Jo)}, have the same penalty −3
at level 1. Among them, {Bird(Jo), ResidentBird(Jo)} has
the least penalty at level 0, and thus is an optimal stable
model of lpmln2wc(Π).
In some applications, one may not want any hard rules to
be violated assuming that hard rules encode deﬁnite knowledge. For that, lpmln2wc(Π) can be modiﬁed by simply
turning hard rules into the usual ASP rules. Then the stable
models of lpmln2wc(Π) satisfy all hard rules. For example,

and (2) with

:∼ ¬F [w@0].
Intuitively, when F is not satisﬁed, the stable model gets
the penalty 1 at level 1, or w at level 0 depending on whether
F is a hard or soft formula.
Corollary 1 Theorem 1 remains true when lpmln2wc(Π) is
replaced by lpmln2wcpnt (Π).

This alternative view of assigning weights to stable models, in fact, originates from Probabilistic Soft Logic (PSL)
(Bach et al. 2015), where the probability density function of
an interpretation is obtained from the sum over the “penalty”
from the formulas that are “distant” from satisfaction. This

3
Recall that we identify the rules with the corresponding ﬁrstorder formulas.

1172

range s0 (denoted by Range(c)), where each of s0 , . . . , sn
is a sort. A sorted propositional signature is a special case
of propositional signatures constructed from a set of constants and their associated sorts, consisting of all propositional atoms c(u) = v where c : s1 × · · · × sn → s0 , and
u ∈ s1 × · · · × sn , and v ∈ s0 .7 Symbol c(u) is called an
attribute and v is called its value. If the range s0 of c is {f, t}
then c is called Boolean, and c(u) = t can be abbreviated as
c(u) and c(u) = f as ∼c(u).
The signature of a P-log program is the union of two
propositional signatures σ1 and σ2 , where σ1 is a sorted
propositional signature, and σ2 is a usual propositional signature consisting of atoms Do(c(u) = v), Obs(c(u) = v) and
Obs(c(u) = v) for all atoms c(u) = v in σ1 .
A P-log program Π of signature σ1 ∪ σ2 is a tuple

view will lead to a slight advantage when we further turn
the translation into the input language of ASP solvers (See
Footnote 6).
The current ASP solvers do not allow arbitrary formulas
to appear in weak constraints. For computation using the
ASP solvers, let lpmln2wcpnt,rule (Π) be the translation by
turning each weighted formula wi : Fi in Π into
¬Fi
¬unsat(i)

→
→
:∼

unsat(i)
Fi
unsat(i)

[wi @l].

where unsat(i) is a new atom, and l = 1 if wi is α and l = 0
otherwise.
Corollary 2 Let Π be an LPMLN program. There is a 1-1
correspondence φ between the most probable stable models
of Π and the optimal stable models of lpmln2wcpnt,rule (Π),
where φ(I) = I ∪ {unsat(i) | wi : Fi ∈ Π, I |= Fi }.

Π = 
R, S, P, Obs, Act

where the signature of each of R, S, and P is σ1 and the
signature of each of Obs and Act is σ2 such that
• R is a set of normal rules of the form

The corollary allows us to compute the most probable stable models (MAP estimates) of the LPMLN program using
the combination of F 2 LP 4 and CLINGO 5 (assuming that
the weights are approximated to integers). System F 2 LP
turns this program with formulas into the input language of
CLINGO , so CLINGO can be used to compute the theory.
If the unweighted LPMLN program is already in the rule
form Head ← Body that is allowed in the input languages of
CLINGO and DLV , we may avoid the use of F 2 LP by slightly
modifying the translation lpmln2wcpnt,rule by turning each
weighted rule
wi : Headi ← Bodyi

A ← B1 , . . . , Bm , not Bm+1 , . . . , not Bn
where A, B1 , . . . , Bn are atoms (0 ≤ m ≤ n).
• S is a set of random selection rules of the form
[r] random(c(u) : {x : p(x)}) ← Body

← Bodyi , not Headi
← Bodyi , not unsat(i)
:∼ unsat(i) [wi @l]

where l = 1 if wi is α and l = 0 otherwise.
In the case when Headi is ⊥, the translation can be further simpliﬁed: we simply turn wi : ⊥ ← Bodyi into
:∼ Bodyi [wi @l].6
Example 1 continued: For program (3), the simpliﬁed
translation lpmln2wcpnt,rule yields
unsat(1) ← p, not q
unsat(2) ← p, not r
unsat(3) ← not p

q ← p, not unsat(1)
r ← p, not unsat(2)
p ← not unsat(3)

:∼
:∼
:∼
:∼

unsat(1)
unsat(2)
unsat(3)
not r

Turning P-log into LP

(5)

where r is a unique identiﬁer, p is a boolean constant with
a unary argument, and Body is a set of literals. x is a
schematic variable ranging over the argument sort of p.
Rule (5) is called a random selection rule for c(u). Intuitively, rule (5) says that if Body is true, the value of
c(u) is selected at random from the set Range(c) ∩ {x :
p(x)} unless this value is ﬁxed by a deliberate action, i.e.,
Do(c(u) = v) for some value v.
• P is a set of so-called probability atoms (pr-atoms) of the
form
prr (c(u) = v | C) = p
(6)
where r is the identiﬁer of some random selection rule for
c(u) in S; c(u) = v ∈ σ1 ; C is a set of literals; and p is
a real number in [0, 1]. We say pr-atom (6) is associated
with the random selection rule whose identiﬁer is r.
• Obs is a set of atomic facts for representing “observation”: Obs(c(u) = v) and Obs(c(u) = v).
• Act is a set of atomic facts for representing a deliberate
action: Do(c(u) = v).

instead into
unsat(i)
Headi

(4)

[10@0]
[1@0]
[5@0]
[−20@0]

Semantics Let Π be a P-log program (4) of signature σ1 ∪
σ2 . The possible worlds of Π, denoted by ω(Π), are the
stable models of τ (Π), a (standard) ASP program with the
propositional signature

MLN

Review: P-log
Syntax A sort is a set of symbols. A constant c maps an
element in the domain s1 × · · · × sn to an element in the

σ1 ∪ σ2 ∪ {Intervene(c(
u)) | c(
u) is an attribute occurring in S}

that accounts for the logical part of P-log. Due to lack of
space we refer the reader to (Baral, Gelfond, and Rushton
2009) for the deﬁnition of τ (Π).

4

http://reasoning.eas.asu.edu/f2lp/
5
http://potassco.sourceforge.net
6
Alternatively, we may turn it into the “reward” way, i.e., turning it into :∼ not Bodyi [−wi ], but the rule may not be in the input
language of CLINGO.

7
Note that here “=” is just a part of the symbol for propositional
atoms, and is not equality in ﬁrst-order logic.

1173

An atom c(u) = v is called possible in a possible world
W due to a random selection rule (5) if Π contains (5) such
that W |= Body ∧ p(v) ∧ ¬Intervene(c(u)).8 Pr-atom (6)
is applied in W if c(u) = v is possible in W due to r and
W |= C.
As in (Baral, Gelfond, and Rushton 2009), we assume that
all P-log programs Π satisfy the following conditions:
• Condition 1 [Unique random selection rule]: If a P-log
program Π contains two random selection rules for c(u):

For each possible world W ∈ ω(Π), and each atom
c(u) = v possible in W , the probability of c(u) = v to happen
in W is deﬁned as:
P (W,c(
u) = v) =
PossWithAssPr(W, c(
u) = v)
PossWithDefPr(W, c(
u) = v)

The unnormalized probability of a possible world W is
deﬁned as
	
μ̂Π (W ) =
P (W, c(u) = v),

[r1 ] random(c(u) : {x : p1 (x)}) ← Body1 ,
[r2 ] random(c(u) : {x : p2 (x)}) ← Body2 ,

c(
u)=v∈W and
c(
u)=v is possible in W

and, assuming Π has at least one possible world with
nonzero unnormalized probability, the normalized probability of W is deﬁned as
μ̂Π (W )
μΠ (W ) = 
.
Wi ∈ω(Π) μ̂Π (Wi )

then no possible world of Π satisﬁes both Body1 and
Body2 .
• Condition 2 [Unique probability assignment]: If a Plog program Π contains a random selection rule for c(u):
[r] random(c(u) : {x : p(x)}) ← Body

We say Π is consistent if Π has at least one possible world
with a non-zero probability.
Example 3 Consider a variant of the Monty Hall Problem
encoding in P-log from (Baral, Gelfond, and Rushton 2009)
to illustrate the probabilistic nonmonotonicity in the presence of assigned probabilities. There are four doors, behind which are three goats and one car. The guest picks
door 1, and Monty, the show host who always opens one
of the doors with a goat, opens door 2. Further, while the
guest and Monty are unaware, the statistics is that in the
past, with 30% chance the prize was behind door 1, and with
20% chance, the prize was behind door 3. Is it still better to
switch to another door? This example can be formalized in
P-log program Π, using both assigned probability and default probability, as

along with two different pr-atoms:
prr (c(u) = v | C1 ) = p1 ,
prr (c(u) = v | C2 ) = p2 ,
then no possible world of Π satisﬁes Body, C1 , and C2
together.
Given a P-log program Π, a possible world W ∈ ω(Π),
and an atom c(u) = v possible in W , by Condition 1, it
follows that there is exactly one random selection rule (5)
such that W |= Body. Let rW,c(u) denote this random selection rule, and let AVW (c(u)) = {v  | there exists a pr-atom
prrW,c(u) (c(u) = v  | C) = p that is applied in W for some
C and p}. We then deﬁne the following notations:
• If v
∈
AVW (c(u)), there exists a pr-atom
prrW,c(u) (c(u) = v | C) = p in Π for some C and p
such that W |= C. By Condition 2, for any other
prrW,c(u) (c(u) = v | C  ) = p in Π, it follows that
W |= C  . So there is only one pr-atom that is applied in
W for c(u) = v, and we deﬁne

∼CanOpen(d) ← Selected = d. (d ∈ {1, 2, 3, 4}),
∼CanOpen(d) ← Prize = d.
CanOpen(d) ← not ∼CanOpen(d).
random(Prize).
random(Selected).
random(Open : {x : CanOpen(x)}).
pr(Prize = 1) = 0.3. pr(Prize = 3) = 0.2.
Obs(Selected = 1). Obs(Open = 2). Obs(Prize = 2).

The possible worlds of Π are as follows:

PossWithAssPr(W, c(u) = v) = p.

• W1 = {Obs(Selected = 1), Obs(Open = 2), Obs(Prize
2), Selected = 1, Open = 2, Prize = 1, CanOpen(1)
f, CanOpen(2) = t, CanOpen(3) = t, CanOpen(4) = t}
• W2 = {Obs(Selected = 1), Obs(Open = 2), Obs(Prize
2), Selected = 1, Open = 2, Prize = 3, CanOpen(1)
f, CanOpen(2) = t, CanOpen(3) = f, CanOpen(4) = t}
• W3 = {Obs(Selected = 1), Obs(Open = 2), Obs(Prize
2), Selected = 1, Open = 2, Prize = 4, CanOpen(1)
f, CanOpen(2) = t, CanOpen(3) = t, CanOpen(4) = f}.

(“c(u) = v is possible in W with assigned probability p.”)
• If v ∈ AVW (c(u)), we deﬁne
 
PossWithDefPr(W, c(u) = v) = max p, 0 ,
where p is
1−



v  ∈AVW (c(
u))

PossWithAssPr(W, c(
u) = v  )

|{v  | c(
u) = v  is possible in W and v  ∈ AVW (c(
u))}|

if v ∈ AVW (c(
u));
otherwise.

.

(7)

The probability of each atom to happen is

( “c(u) = v is possible in W with the default probability.”)
The max function is used to ensure that the default probability is nonnegative. 9

P (Wi , Selected = 1) = PossWithDefPr(W, Selected = 1) = 1/4
P (W1 , Open = 2) = PossWithDefPr(W1 , Open = 2) = 1/3
P (W2 , Open = 2) = PossWithDefPr(W2 , Open = 2) = 1/2
P (W3 , Open = 2) = PossWithDefPr(W3 , Open = 2) = 1/2

8

Note that this is slightly different from the original deﬁnition
of P-log from (Baral, Gelfond, and Rushton 2009), according to
which, if Intervene(c(
u)) is true, the probability of c(
u) = v is
determined by the default probability, which is a bit unintuitive.
9
In (Baral, Gelfond, and Rushton 2009), a stronger condition of
“unitariness” is imposed to prevent (7) from being negative.

P (W1 , Prize = 1) = PossWithAssPr(W1 , Prize = 1) = 0.3
P (W2 , Prize = 3) = PossWithAssPr(W2 , Prize = 3) = 0.2
P (W3 , Prize = 4) = PossWithDefPr(W3 , Prize = 4) = 0.25

So,

1174

=
=
=
=
=
=

• μ̂Π (W1 ) = 1/4 × 1/3 × 0.3 = 1/40
• μ̂Π (W2 ) = 1/4 × 1/2 × 0.2 = 1/40
• μ̂Π (W3 ) = 1/4 × 1/2 × 0.25 = 1/32.

in W . This value x is the denominator of (7). Then rule (14)
contributes the factor 1/x to the unnormalized probability of
W as a factor.

Thus, in comparison with staying (W1 ), switching to door 3
(W2 ) does not affect the chance, but switching to door 4
(W3 ) increases the chance by 25%.

Numerator for Default Probability:
• Consider each random selection rule [r] random(c(u) :
{x : p(x)}) ← Body for c(u) in S along with all pr-atoms
associated with it in P:
prr (c(u) = v1 | C1 ) = p1
...
prr (c(u) = vn | Cn ) = pn

Turning P-log into LPMLN
We deﬁne translation plog2lpmln(Π) that turns a P-log program Π into an LPMLN program in a modular way. First,
every rule R in τ (Π) (that is used in deﬁning the possible worlds in P-log) is turned into a hard rule α : R
in plog2lpmln(Π). In addition, plog2lpmln(Π) contains
the following rules to associate probability to each possible
world of Π. Below x, y denote schematic variables, and W
is a possible world of Π.

where n ≥ 1, and vi and vj (i = j) may be equal. For
each v ∈ Range(c), plog2lpmln(Π) contains the following rules:10
α : RemPr(c(
u), 1−y) ← Body
c(
u) = v, PossWithDefPr(c(
u) = v),
y = #sum{p1 : PossWithAssPrr,C1 (c(
u) = v1 );
. . . ; pn : PossWithAssPrr,Cn (c(
u) = vn )}.
(15)

Possible Atoms: For each random selection rule (5) for
c(u) in S and for each v ∈ Range(c), plog2lpmln(Π) includes

α : TotalDefPr(c(
u), x) ← RemPr(c(
u), x), x > 0 (16)
ln(x) : ⊥ ← not TotalDefPr(c(
u), x)
(17)
α : ⊥ ← RemPr(c(
u), x), x ≤ 0.
(18)

Possr (c(u) = v) ← Body, p(v), not Intervene(c(u)) (8)
Rule (8) expresses that c(u) = v is possible in W due to r if
W  Body ∧ p(v) ∧ ¬Intervene(c(u)).
Assigned Probability:
For each pr-atom (6) in P,
plog2lpmln(Π) contains the following rules:
α : PossWithAssPrr,C (c(
u) = v) ←
Possr (c(u) = v), C

In rule (15), y is the sum of all assigned probabilities.
Rules (16) and (17) are to account for the numerator of (7)
when n > 0. The variable x stands for the numerator of
(7). Rule (18) is to avoid assigning a non-positive default
probability to a possible world.
Note that most rules in plog2lpmln(Π) are hard rules.
The soft rules (11), (14), (17) cannot be simpliﬁed as atomic
1
facts, e.g., ln( m
) : NumDefPr(c(u), m) in place of (14),
which is in contrast with the use of probabilistic choice
atoms in the distribution semantics based probabilistic logic
programming language, such as ProbLog. This is related
to the fact that the probability of each atom to happen in
a possible word in P-log is derived from assigned and default probabilities, and not from independent probabilistic
choices like the other probabilistic logic programming languages. In conjunction with the embedding of ProbLog in
LPMLN (Lee and Wang 2016), it is interesting to note that
both kinds of probabilities can be captured in LPMLN using
different kinds of rules.

(9)

α : AssPrr,C (c(
u) = v) ←
u) = v)
(10)
c(
u) = v, PossWithAssPrr,C (c(
ln(p) : ⊥ ← not AssPrr,C (c(
u) = v)
(p > 0)
(11)
α : ⊥ ← AssPrr,C (c(
u) = v)
(p = 0 )
α : PossWithAssPr(c(
u) = v) ← PossWithAssPrr,C (c(
u) = v).

Rule (9) expresses the condition under which pr-atom (6) is
applied in a possible world W . Further, if c(u) = v is true
in W as well, rules (10) and (11) contribute the assigned
probability eln(p) = p to the unnormalized probability of W
as a factor when p > 0.
Denominator for Default Probability: For each random
selection rule (5) for c(u) in S and for each v ∈ Range(c),
plog2lpmln(Π) includes
α : PossWithDefPr(c(
u) = v) ←
Possr (c(
u) = v), not PossWithAssPr(c(
u) = v)
α:

NumDefPr(c(
u), x) ←
c(
u) = v, PossWithDefPr(c(
u) = v),
x = #count{y : PossWithDefPr(c(
u) = y)}

1
):
ln( m

⊥ ← not NumDefPr(c(
u), m)
(m = 2, . . . , |Range(c)|)

Example 3 Continued For the program Π in Example 3,
plog2lpmln(Π) consists of the rules α : R for each rule R
in τ (Π) and the following rules.

(12)

Possible Atoms:
α : Poss(Prize = d) ← not Intervene(Prize)
α : Poss(Selected = d) ← not Intervene(Selected)
α : Poss(Open = d) ← CanOpen(d), not Intervene(Open)

(13)
(14)

10
The sum aggregate can be represented by ground ﬁrst-order
formulas under the stable model semantics under the assumption
that the Herbrand Universe is ﬁnite (Ferraris 2011). In the general case, it can be represented by generalized quantiﬁers (Lee and
Meng 2012) or inﬁnitary propositional formulas (Harrison, Lifschitz, and Yang 2014). In the input language of ASP solvers, which
does not allow real number arguments, pi can be approximated to
integers of some ﬁxed interval.

Rule (12) asserts that c(u) = v is possible in W with a default probability if it is possible in W and not possible with
an assigned probability. Rule (13) expresses, intuitively, that
NumDefPr(c(u), x) is true if there are exactly x different
values v such that c(u) = v is possible in W with a default
probability, and there is at least one of them that is also true

1175

Proof. (Sketch) We can check that the following mapping
φ is the 1-1 correspondence.

Assigned Probability:
α : PossWithAssPr(Prize = 1) ← Poss(Prize = 1)
α : AssPr(Prize = 1) ← Prize = 1, PossWithAssPr(Prize = 1)
ln(0.3) : ⊥ ← not AssPr(Prize = 1)

1. φ(W ) |= Possr (c(u) = v) iff c(u) = v is possible in W
due to r.

α : PossWithAssPr(Prize = 3) ← Poss(Prize = 3)
α : AssPr(Prize = 3) ← Prize = 3, PossWithAssPr(Prize = 3)
ln(0.2) : ⊥ ← not AssPr(Prize = 3)

2. For each pr-atom prr (c(u) = v | C) = p in Π,
φ(W ) |= PossWithAssPrr,C (c(u) = v) iff this pr-atom is
applied in W .
3. For each pr-atom prr (c(u) = v | C) = p in Π,
φ(W ) |= AssPrr,C (c(u) = v) iff this pr-atom is applied
in W , and W |= c(u) = v.

(We
simpliﬁed
slightly
not
to
distinguish
PossWithAssPr(·) and PossWithAssPrr,C (·) because
there is only one random selection rule for Prize and both
pr-atoms for Prize has empty conditions. )

4. φ(W ) |= PossWithAssPr(c(u) = v) iff v ∈ AVW (c(u)).

Denominator for Default Probability:

5. φ(W ) |= PossWithDefPr(c(u) = v) iff c(u) = v is possible in W and v ∈ AVW (c(u)).

α : PossWithDefPr(Prize = d) ←
Poss(Prize = d), not PossWithAssPr(Prize = d)
α : PossWithDefPr(Selected = d) ←
Poss(Selected = d), not PossWithAssPr(Selected = d)
α : PossWithDefPr(Open = d) ←
Poss(Open = d), not PossWithAssPr(Open = d)

6. φ(W ) |= NumDefPr(c(u), m) iff there exist exactly m
different values v such that c(u) = v is possible in W ;
v ∈ AVW (c(u)); and, for one of such v, W |= c(u) = v.
7. φ(W ) |= RemPr(c(u), k) iff there exists a value v such
that W |= c(u) = v; c(u) = v is possible in W ; v ∈
AVW (c(u)); and

PossWithAssPr(W, c(u) = v).
k =1−

α : NumDefPr(Prize, x) ←
Prize = d, PossWithDefPr(Prize = d),
x = #count{y : PossWithDefPr(Prize = y)}
α : NumDefPr(Selected, x) ←
Selected = d, PossWithDefPr(Selected = d),
x = #count{y : PossWithDefPr(Selected = y)}
α : NumDefPr(Open, x) ←
Open = d, PossWithDefPr(Open = d),
x = #count{y : PossWithDefPr(Open = y)}
1
ln( m
) :← not NumDefPr(c, m)
(c ∈ {Prize, Selected, Open}, m ∈ {2, 3, 4})

v∈AVW (c(
u))

8. φ(W )
|=
TotalDefPr(c(u), k)
RemPr(c(u, k)) and k > 0.

iff

φ(W )

|=

To check that μΠ (W ) = Pplog2lpmln(Π) (φ(W )), note ﬁrst
that the weight of φ(W ) is computed by multiplying e to
the power of the weights of rules (11), (14), (17) that are
satisﬁed by φ(W ). Let’s call this product T W .
Consider a possible world W with a non-zero probability
of Π and c(u) = v that is satisﬁed by W .
If c(u) = v is possible in W and pr-atom prr (c(u) = v |
C) = p is applied in W (i.e., v ∈ AVW (c(u))), then the
assigned probability is applied: P (W, c(u) = v) = p. On the
other hand, by condition 3, φ(W ) |= AssPrr,C (c(u) = v), so
that from (11), the same p is a factor of T W .
If c(u) = v is possible in W and v ∈ AVW (c(u)), the
default probability is applied: P (W, c(u) = v) = p is computed by (7). By Condition
 8, φ(W ) |= TotalDefPr(c(u), x)
where x = 1 −
PossWithAssPr(W, c(u) = v  ).

Numerator for Default Probability:
α : RemPr(Prize, 1−x) ← Prize = d, PossWithDefPr(Prize = d),
x = #sum{0.3 : PossWithAssPr(Prize = 1);
0.2 : PossWithAssPr(Prize = 3)}
α : TotalDefPr(Prize, x) ← RemPr(Prize, x), x > 0
ln(x) : ⊥ ← not TotalDefPr(Prize, x)
α : ⊥ ← RemDefPr(Prize, x), x ≤ 0

Clearly, the signature of plog2lpmln(Π) is a superset of
the signature of Π. Further, plog2lpmln(Π) is linear-time
constructible. The following theorem tells us that there is a
1-1 correspondence between the set of the possible worlds
with non-zero probabilities of Π and the set of the stable
models of plog2lpmln(Π) such that each stable model is an
extension of the possible world, and the probability of each
possible world of Π coincides with the probability of the
corresponding stable model of plog2lpmln(Π).
Theorem 3 Let Π be a consistent P-log program. There is a
1-1 correspondence φ between the set of the possible worlds
of Π with non-zero probabilities and the set of probabilistic
stable models of plog2lpmln(Π) such that
• For every possible world W of Π that has a non-zero
probability, φ(W ) is a probabilistic stable model of
plog2lpmln(Π), and μΠ (W ) = Pplog2lpmln(Π) (φ(W )).
• For every probabilistic stable model I of plog2lpmln(Π),
the restriction of I onto the signature of τ (Π), denoted
I|σ(τ (Π)) , is a possible world of Π and μΠ (I|σ(τ (Π)) ) >
0.

v  ∈AVW (c(
u))

Since φ(W ) |= (17), it is a factor of T W , which is the
same as the numerator of (7). Furthermore, by Condition 6,
φ(W ) |= NumDefPr(c(u), m), where m is the denominator
1
is a factor of T W .
of (7). Since φ(W ) |= (14), m
Example 3 Continued For the P-log program Π for the
Monty Hall problem, Π = plog2lpmln(Π) has three probabilistic stable models I1 , I2 , and I3 , each of which is an
extension of W1 , W2 , and W3 respectively, and satisﬁes
the following atoms: Poss(Prize = i) for i = 1, 2, 3, 4;
Poss(Selected = i) for i = 1, 2, 3, 4; PossWithAssPr(Prize =
i) for i = 1, 3; PossWithDefPr(Prize = i) for i =
2, 4; PossWithDefPr(Selected = i) for i = 1, 2, 3, 4;
NumDefPr(Selected, 4). In addition,

1176

• I1 |= {AssPr(Prize = 1), Poss(Open = 2),
Poss(Open = 3), Poss(Open = 4),
PossWithDefPr(Open = 2), PossWithDefPr(Open = 3),
PossWithDefPr(Open = 4), NumDefPr(Open, 3)}
• I2 |= {AssPr(Prize = 3), Poss(Open = 2),
Poss(Open = 4), PossWithDefPr(Open = 2),
PossWithDefPr(Open = 4), NumDefPr(Open, 2)}
• I3 |= {Poss(Open = 2), Poss(Open = 3),
PossWithDefPr(Open = 2), PossWithDefPr(Open = 3),
NumDefPr(Open, 2), NumDefPr(Prize, 2),
RemPr(Prize, 0.5), TotalDefPr(Prize, 0.5)}.
The unnormalized weight WΠ (Ii ) of each probabilistic stable model Ii is shown below. w(AssPrr,C (c(u) =
v)) denotes the exponentiated weight of rule (11);
w(NumDefPr(c(u), m)) denotes the exponentiated weight
of rule (14); w(TotalDefPr(c(u), x)) denotes the exponentiated weight of rule (17).
=
w(NumDefPr(Selected, 4)) ×
• WΠ (I1 )
w(AssPr(Prize = 1)) × w(NumDefPr(Open, 3)) =
1
3
1
1
4 × 10 × 3 = 40 .
• WΠ (I2 )
=
w(NumDefPr(Selected, 4)) ×
w(AssPr(Prize = 3)) × w(NumDefPr(Open, 2)) =
1
2
1
1
4 × 10 × 2 = 40 ;
• WΠ (I3 )
=
w(NumDefPr(Selected, 4)) ×
×w(NumDefPr(Open, 2)) × ×w(NumDefPr(Prize, 2) ×
5
1
w(TotalDefPr(Prize, 0.5) = 14 × 12 × 12 × 10
= 32
.

Buccafurri, F.; Leone, N.; and Rullo, P. 2000. Enhancing
disjunctive datalog by constraints. Knowledge and Data Engineering, IEEE Transactions on 12(5):845–860.
Calimeri, F.; Faber, W.; Gebser, M.; Ianni, G.; Kaminski,
R.; Krennwallner, T.; Leone, N.; Ricca, F.; and Schaub, T.
2013. ASP-Core-2 input language format.
De Raedt, L.; Kimmig, A.; and Toivonen, H. 2007.
ProbLog: A probabilistic prolog and its application in link
discovery. In IJCAI, volume 7, 2462–2467.
Ferraris, P.; Lee, J.; and Lifschitz, V. 2011. Stable models
and circumscription. Artiﬁcial Intelligence 175:236–263.
Ferraris, P. 2011. Logic programs with propositional connectives and aggregates. ACM Transactions on Computational Logic (TOCL) 12(4):25.
Gelfond, M., and Lifschitz, V. 1988. The stable model
semantics for logic programming. In Kowalski, R., and
Bowen, K., eds., Proceedings of International Logic Programming Conference and Symposium, 1070–1080. MIT
Press.
Harrison, A. J.; Lifschitz, V.; and Yang, F. 2014. The
semantics of gringo and inﬁnitary propositional formulas.
In Principles of Knowledge Representation and Reasoning:
Proceedings of the Fourteenth International Conference, KR
2014.
Lee, J., and Meng, Y. 2012. Stable models of formulas
with generalized quantiﬁers (preliminary report). In Technical Communications of the 28th International Conference
on Logic Programming, 61–71.
Lee, J., and Wang, Y. 2016. Weighted rules under the stable
model semantics. In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR), 145–154.
Lee, J.; Meng, Y.; and Wang, Y. 2015. Markov logic style
weighted rules under the stable model semantics. In Technical Communications of the 31st International Conference
on Logic Programming.
Nickles, M., and Mileo, A. 2014. Probabilistic inductive
logic programming based on answer set programming. In
15th International Workshop on Non-Monotonic Reasoning
(NMR 2014).
Pearl, J. 2000. Causality: models, reasoning and inference,
volume 29. Cambridge Univ Press.
Richardson, M., and Domingos, P. 2006. Markov logic
networks. Machine Learning 62(1-2):107–136.

Combining the translations plog2lpmln and lpmln2wc,
one can compute P-log MAP inference using standard ASP
solvers.

Conclusion
In this paper, we show how LPMLN is related to weak constraints and P-log. Weak constraints are a relatively simple extension to ASP programs, while P-log is highly structured but a more complex extension. LPMLN is shown to
be a good middle ground language that clariﬁes the relationships. We expect the relationships will help us to apply the
mathematical and computational results developed for one
language to another language.
Acknowledgments We are grateful to Evgenii Balai, Yi
Wang and anonymous referees for their useful comments on
the draft of this paper. This work was partially supported by
the National Science Foundation under Grants IIS-1319794
and IIS-1526301.

References
Bach, S. H.; Broecheler, M.; Huang, B.; and Getoor, L.
2015. Hinge-loss markov random ﬁelds and probabilistic
soft logic. arXiv:1505.04406 [cs.LG].
Balai, E., and Gelfond, M. 2016. On the relationship between P-log and LPMLN . In Proceedings of International
Joint Conference on Artiﬁcial Intelligence (IJCAI).
Baral, C.; Gelfond, M.; and Rushton, J. N. 2009. Probabilistic reasoning with answer sets. TPLP 9(1):57–144.

1177

Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence

First-Order Extension of the FLP Stable Model
Semantics via Modiﬁed Circumscription
Michael Bartholomew, Joohyung Lee and Yunsong Meng
School of Computing, Informatics and Decision Systems Engineering
Arizona State University, Tempe, USA
{mjbartho, joolee, Yunsong.Meng}@asu.edu
relative to a set X of atoms is obtained from Π by simply removing all rules whose bodies are not satisﬁed by X. After
then the same minimality condition as in the original deﬁnition of an answer set applies. For example, consider the
following program Π1 :

Abstract
We provide reformulations and generalizations of
both the semantics of logic programs by Faber,
Leone and Pfeifer and its extension to arbitrary
propositional formulas by Truszczyński. Unlike the
previous deﬁnitions, our generalizations refer neither to grounding nor to ﬁxpoints, and apply to ﬁrstorder formulas containing aggregate expressions.
In the same spirit as the ﬁrst-order stable model
semantics proposed by Ferraris, Lee and Lifschitz,
the semantics proposed here are based on syntactic
transformations that are similar to circumscription.
The reformulations provide useful insights into the
FLP semantics and its relationship to circumscription and the ﬁrst-order stable model semantics.

1

p ← not q
q ← not p

r←p
r←q.

(1)

The FLP-reduct of Π1 relative to X = {p, r} is
p ← not q

r ← p,

(2)

and X is minimal among the sets of atoms that satisfy (2), and
hence is an answer set of Π1 . Theorem 3.6 from [Faber et al.,
2011] asserts that this deﬁnition of an answer set is equivalent
to the traditional deﬁnition when it is applied to the syntax
of usual disjunctive programs. Indeed, the GL-reduct of Π1
relative to X [Gelfond and Lifschitz, 1988] is
p←

Introduction

The stable model semantics is the mathematical basis of answer set programming, and is one of the most well-studied
knowledge representation formalisms. Lifschitz [2010] surveys thirteen different deﬁnitions of a stable model presented
in the literature. These deﬁnitions are equivalent to each other
when they are applied to normal logic programs, but are not
necessarily so for more general classes of programs. However, each of them deserves its own attention, as it provides
useful insights into the stable model semantics and answer set
programming.
The semantics deﬁned by Faber, Leone and Pfeifer [2004;
2011] (called the FLP semantics) deserves special attention
as it provides a simple satisfactory solution to the semantics of aggregates, and is implemented in the system DLV
(http://www.dlvsystem.com). It is also a basis of
HEX programs, which are an extension of answer set programs towards integration of external sources of information that have possibly heterogeneous semantics [Eiter et al.,
2005]. Also, Dao-Tran et al. [2009] remark that the FLP semantics provides a more natural basis for their Modular Logic
Programs (MLP) than the traditional Gelfond-Lifschitz semantics [Gelfond and Lifschitz, 1988].
The idea of the FLP semantics is based on an interesting
modiﬁcation to the traditional deﬁnition of a reduct by Gelfond and Lifschitz [1988]. The FLP-reduct of a program Π

r←p
r←q

(3)

and, again, {p, r} is minimal among the sets of atoms that
satisfy (3).
The FLP semantics was recently extended to arbitrary
propositional formulas by Truszczyński [2010], based on the
deﬁnition of a reduct that is similar to the one proposed
by Ferraris [2005]. However, his extension is still limited as
it allows neither variables nor aggregates.
In this paper, we extend the FLP semantics and its extension by Truszczyński, both syntactically and semantically. We consider the syntax of arbitrary ﬁrst-order formulas allowing aggregates. Instead of referring to grounding and ﬁxpoints, our generalized semantics are given in
terms of modiﬁcations to circumscription [McCarthy, 1980],
in the same spirit as the ﬁrst-order stable model semantics by Ferraris, Lee and Lifschitz [Ferraris et al., 2007;
2011]. Such uniform characterizations in the form of modiﬁed circumscription tell us how the FLP semantics and its
extension by Truszczyński are related to circumscription and
to the ﬁrst-order stable model semantics.
In Section 2 we review the original FLP semantics, and
present our generalization. Likewise, in Section 3 we review and generalize the extension of the FLP semantics by
Truszczyński. In Section 4 we compare these generalizations
with the ﬁrst-order stable model semantics.

724

2
2.1

Let Π be a ﬁnite program whose rules have the form (5).
The FOL-representation ΠFOL of Π is the conjunction of the
universal closures of B → H for all rules (5) in Π. By
FLP[Π; p] we denote the second-order formula

FLP Semantics
Review: Original FLP Semantics

A disjunctive rule is an expression of the form
A1 ; . . . ; Al ← Al+1 , . . . , Am , not Am+1 , . . . , not An (4)

ΠFOL ∧ ¬∃u(u < p ∧ Π (u))

(n ≥ m ≥ l ≥ 0) where each Ai is an atomic formula (possibly containing equality and 0-place connectives  and ⊥).
A disjunctive program is a set of disjunctive rules. The FLP
semantics for a disjunctive program in [Faber et al., 2011] is
given in terms of grounding and ﬁxpoints. By σ(Π) we denote the signature consisting of the object, function and predicate constants occurring in Π. We denote by Ground(Π) the
ground instance of Π, that is, the program obtained from Π
by replacing every occurrence of object variables with every
ground term that can be constructed from σ(Π), and then replacing equality t = t with  or ⊥ depending on whether
term t is the same symbol as term t . Given a set X of ground
atoms of σ(Π), the reduct of Π relative to X, denoted by ΠX ,
is obtained from Ground(Π) by removing every rule whose
body is not satisﬁed by X. Set X is called an FLP-answer set
of Π if X is minimal among the sets of atoms that satisfy ΠX
(viewed as a formula in propositional logic). For example,
X
for Π1 and X = {p, r} in the introduction, Π1 is (2) and X
is an FLP-answer set of Π1 .

2.2

where Π (u) is deﬁned as the conjunction of
∀x(B ∧ B(u) → H(u))

(7)

for all rules (5) in Π, where x is the list of all (free) variables
in (5).
We will often simply write FLP[Π] instead of FLP[Π; p]
when p is the list of all predicate constants occurring in Π,
and call a model of FLP[Π] an FLP-stable model of Π.
Example 1 Consider the program Π1 in the introduction. Its
is
FOL-representation ΠFOL
1
(¬q → p) ∧ (¬p → q) ∧ (p → r) ∧ (q → r)
and

Π
1 (u, v, w)

is

(¬q∧¬v → u)∧(¬p∧¬u → v)∧(p∧u → w)∧(q∧v → w).
Formula
ΠFOL
∧ ¬∃uvw((u, v, w) < (p, q, r) ∧ Π
1
1 (u, v, w))
can be equivalently rewritten without second-order variables
as ¬(p ↔ q) ∧ (r ↔ p ∨ q).
Though rule arrows (←) are treated like usual implications
in the FOL-representation of Π, they are distinguished in the
deﬁnition of Π (u) because of the presence of ’B∧’ in (7).
If we modify Π (u) by dropping ’B∧’ from (7), then (6)
becomes exactly CIRC[ΠFOL ; p] [McCarthy, 1980]. Interestingly, this small change accounts for the differences in the
two semantics, one leading to stable models and the other
leading to minimal models. For instance, classically equivalent transformations preserve minimal models, but not FLPstable models. Each of the one-rule programs {p ← ¬q},
{q ← ¬p}, and {p ∨ q ← } are classically equivalent to each other (when we identify them with their FOLrepresentations), but their FLP-stable models are different.
Formula FLP[p ← ¬q; p, q] is equivalent to p ∧ ¬q; formula FLP[q ← ¬p; p, q] is equivalent to q ∧ ¬p; formula
FLP[p ∨ q ← ; p, q] is equivalent to (p ∨ q) ∨ ¬(p ∧ q),
which is also equivalent to CIRC[p ∨ q; p, q].
The following theorem states that our semantics is a proper
generalization of the semantics from [Faber et al., 2011].
Theorem 1 Let Π be a ﬁnite disjunctive program (consisting
of rules of the form (4)) containing at least one object constant. The FLP-answer sets of Π are precisely the Herbrand
models of FLP[Π] whose signature is σ(Π).
It is known that the FLP semantics from [Faber et al., 2011]
has the anti-chain property: no FLP-answer set is a proper
subset of another FLP-answer set. This property is still preserved in our generalized semantics.
Proposition 1 For any ﬁnite general program Π, if I is an
Herbrand interpretation of σ(Π) that satisﬁes FLP[Π], then I
is a subset-minimal model of Π.1

Extension: First-Order FLP Semantics

We present a reformulation of the FLP semantics in the ﬁrstorder case. First, we consider a program that does not contain
aggregates, but allows rules of a more general form than (4).
We assume the following set of primitive propositional connectives and quantiﬁers in forming formulas:
⊥, ∧, ∨, →, ∀, ∃ .
¬F is an abbreviation for F → ⊥, symbol  stands for
⊥ → ⊥, and F ↔ G stands for (F → G) ∧ (G → F ).
A (general) rule is of the form
H←B

(6)



(5)

where H and B are arbitrary formulas in ﬁrst-order logic.
Rule (4) is a special case of rule (5) when we identify not
with ¬, the head H with the disjunction of atomic formulas
and the body B with the conjunction of atomic formulas, possibly preceded by negation. A (general) program is a set of
(general) rules.
Let p be a list of distinct predicate constants p1 , . . . , pn ,
and let u be a list of distinct predicate variables u1 , . . . , un .
By u ≤ p we denote the conjunction of the formulas
∀x(ui (x) → pi (x)) for all i = 1, . . . , n where x is a list of
distinct object variables of the same length as the arity of pi ,
and by u < p we denote (u ≤ p) ∧ ¬(p ≤ u). For instance,
if p and q are unary predicate constants then (u, v) < (p, q)
is
∀x(u(x) → p(x)) ∧ ∀x(v(x) → q(x))
∧¬(∀x(p(x) → u(x)) ∧ ∀x(q(x) → v(x))).
For any formula G and any list p of predicate constants,
formula G(u) is obtained from G by replacing all occurrences of predicates from p with the corresponding predicate
variables from u.

1
We identify an Herbrand interpretation I with the set of ground
atoms that are satisﬁed by I.

725

QvG. Otherwise it is free. We say that v is free in H if H
contains a free occurrence of v. An aggregate sentence is an
aggregate formula with no free variables.
The deﬁnition of an interpretation is the same as in ﬁrstorder logic. We consider only the interpretations such that
each number and each comparison operator is interpreted as
itself. Consider an interpretation I of a ﬁrst-order signature σ
that may contain any function constants of positive arity. By
σ |I| we mean the signature obtained from σ by adding distinct
new object constants ξ ∗ , called names, for all ξ in the universe
of I. We identify an interpretation I of σ with its extension
to σ |I| deﬁned by I(ξ ∗ ) = ξ.
The deﬁnition of satisfaction in ﬁrst-order logic is extended
to aggregate sentences as follows. Let I be an interpretation
of signature σ. Consider any aggregate expression (8) that
has no free variables. Let SI be the multiset consisting of all
ξ ∗ [1] (i.e. the ﬁrst element of ξ∗ ), in the universe of I where

Clearly, circumscription can be viewed as a special case of
the FLP semantics as in the following.
Proposition 2 For any ﬁrst-order sentence F and any
list p of predicate constants, CIRC[F ; p] is equivalent to
FLP[F ← ; p].
The FLP semantics can be represented by circumscription
in the following way.
Proposition 3 For any ﬁnite general program Π, formula
FLP[Π; p] is equivalent to ∃u(CIRC[Π (u); u] ∧ (u = p)).

2.3

Extension: First-Order FLP Semantics for
Programs with Aggregates

The semantics presented in the previous section can be extended to allow aggregates by simply extending the notion of
satisfaction to cover aggregate expressions. Below we adopt
the deﬁnitions of an aggregate formula and satisfaction as
given in [Lee and Meng, 2009; Ferraris and Lifschitz, 2010].
Following [Ferraris and Lifschitz, 2010], by a number we
understand an element of some ﬁxed set Num. For example, Num is Z ∪ {+∞, −∞}, where Z is the set of integers.
An aggregate function is a partial function from the class of
multisets to Num. The domain of an aggregate function is deﬁned as usual. For instance, COUNT is deﬁned for any multisets; SUM, TIMES, MIN and MAX are deﬁned for multisets of
numbers; SUM is undeﬁned for multisets containing inﬁnitely
many positive integers and inﬁnitely many negative integers.
We assume that the signature σ contains symbols for all
numbers, and some collection of comparison operators that
stands for binary relations over numbers, such as ≤, ≥, <, >,
= and =. We assume that symbols for aggregate functions
are not part of the signature.
An aggregate expression of signature σ is of the form 2
OP x

: F (x)  b

• ξ ∗ is a list of object names of σ |I| whose length is the
same as the length of x, and
• I satisﬁes F (ξ∗ ).
An interpretation I satisﬁes the aggregate expression if SI
is in the domain of OP, and OP(SI )  bI . With this extension, the recursive deﬁnition of satisfaction for an aggregate
sentence is given in the same way as in ﬁrst-order logic. We
say that an aggregate sentence F is logically valid if every
interpretation satisﬁes it. For instance, an Herbrand interpretation {p(a)} satisﬁes COUNTx : p(x) > 0 but does not
satisfy SUMx : p(x) > 0 because multiset {{a}} is not in the
domain of SUM. Consider the aggregate expression
SUM x

: p(x) ≥ 0

and an Herbrand interpretation I = {p(−1), p(1)}. SI
is {{−1, 1}} and SUM(SI ) = 0 ≥ 0, so I satisﬁes
SUM x : p(x) ≥ 0.
Once we extend the deﬁnition of satisfaction to aggregate
sentences, we can simply extend the FLP semantics in Section 2.2 to a general program with aggregates, whose rules
have the form
H←B
(9)
where H and B are aggregate formulas.
The AFrepresentation (“Aggregate Formula representation”) of a ﬁnite general program Π with aggregates is the conjunction of
the universal closures of the aggregate formulas B → H for
all rules (9) in Π. Formula FLP[Π; p] is deﬁned the same as
(6) except that Π is now understood as a general program with
aggregates.

(8)

where
• OP is an aggregate function;
• x is a nonempty list of distinct object variables;
• F (x) is a ﬁrst-order formula;
•  is a comparison operator;
• b is a term (as in ﬁrst-order logic).
We deﬁne an aggregate formula as an extension of a ﬁrstorder formula by including aggregate expressions as a base
case like (standard) atomic formulas (including equality and
⊥). In other words, aggregate formulas are constructed from
atomic formulas and aggregate expressions using connectives
and quantiﬁers as in ﬁrst-order logic. For instance,

Example 2 Consider the following general program Π with
aggregates:

(SUMx : p(x) ≥ 1 ∨ ∃y q(y)) → r(x)

p(2) ← ¬ SUMx : p(x) < 2
p(−1) ← SUMx : p(x) ≥ 0
p(1) ← p(−1) .

is an aggregate formula.
We say that an occurrence of a variable v in an aggregate
formula H is bound if the occurrence is in a part of H of the
form x : F (x) where v is in x, or in a part of H of the form

(10)

The AF-representation of Π, denoted by ΠAF , is the following:
(¬(SUMx : p(x) < 2) → p(2))
∧ (SUMx : p(x) ≥ 0 → p(−1))
(11)
∧ (p(−1) → p(1)) .

2

The syntax of an aggregate expression considered in Ferraris
and Lifschitz [2010] is more general. The results in this paper can
be extended to the general syntax, which we omit for simplicity.

726

The FLP-stable models of (10) are the models of
ΠAF ∧ ¬∃u(u < p ∧ Π (u))

X

• (G → H)

(12)

where Π (u) is

3.2

(14)

F ∧ ¬∃u(u < p ∧ F  (u))

(l ≥ 0; n ≥ m ≥ 0), where each Ai is an atomic formula and
each Ei is an atomic formula or an aggregate expression.
As before, the original FLP semantics is deﬁned in terms
of grounding and ﬁxpoints. Let us assume that b in every
aggregate expression (8) is a constant. We extend the notion
Ground(Π) to a disjunctive program Π with aggregates by replacing every free occurrence of a variable with every ground
term that can be constructed from σ(Π) in all possible ways.
For any disjunctive program Π with aggregates and any
Herbrand interpretation X whose signature is σ(Π), the FLPreduct of Π relative to X is obtained from Ground(Π) by
removing every rule whose body is not satisﬁed by X. Set X
is an FLP-answer set of Π if it is minimal among the sets of
atoms that satisfy the FLP-reduct of Π relative to X [Faber
et al., 2011]. For example, in program (10) above, the FLPreduct of (10) relative to {p(−1), p(1)} contains the last two
rules only. Set {p(−1), p(1)} is minimal among the sets of
atoms that satisfy the reduct, and thus is an FLP-answer set
of (10). In fact, this is the only FLP-answer set. Also one can
check that {p(−1), p(1)} is the only Herbrand model of σ(Π)
that satisﬁes (12) in Example 2.

• pi (t) = ui (t) for any tuple t of terms;
• F  = F for any atomic formula F that does not contain
members of p;
• (G  H) = G  H  , where  ∈ {∧, ∨};
• (G → H) = (G ∧ G(u) → H  ) ∧ (G → H);
• (QxG) = QxG , where Q ∈ {∀, ∃};
• (OPx : G)  t) =
(OPx : G  t) ∧ (OPx : G(u)  t).
Similar to FLP[Π], we will often simply write FLPT[F ]
instead of FLPT[F ; p] when p is the list of all predicate constants occurring in F , and call a model of FLPT[F ] an FLPTstable model of F .
The following theorem states that our semantics is a proper
extension of the Truszczyński semantics to ﬁrst-order formulas with aggregates. For any formula F , by σ(F ) we denote
the signature consisting of object, function and predicate constants occurring in F .
Theorem 3 For any propositional formula F , the FLPTanswer sets of F are precisely the interpretations of σ(F )
that satisfy FLPT[F ].
Also the semantics above coincides with our extension of
the FLP semantics in Section 2.3 when it is applied to disjunctive programs with aggregates (having rules of the form (14)).

Truszczyński Semantics
Review: Original Truszczyński Semantics

Proposition 4 For any ﬁnite disjunctive program Π with aggregates and the AF-representation F of Π, FLP[Π; p] is
equivalent to FLPT[F ; p].

Truszczyński [2010] deﬁned an extension of the FLP semantics to arbitrary propositional formulas, similar to the extension of the stable model semantics to arbitrary propositional
formulas by Ferraris [2005], whose idea is also related to
[Pearce, 1997; Osorio et al., 2004].
For any propositional formula F , the FLPT-reduct F X relative to a set X of atoms is deﬁned recursively:

A if X |= A,
X
• A =
⊥ otherwise;
X

• ⊥

= ⊥;

• (GH)

X


=

GX H X
⊥

(15)

where F  (u) is deﬁned recursively, as follows:

Theorem 2 Let Π be a ﬁnite disjunctive program with aggregates that contains at least one object constant. The
FLP-answer sets of Π are precisely the Herbrand models of
FLP[Π] whose signature is σ(Π).

3.1

Extension: FLPT Semantics for First-Order
Formulas with Aggregates

We extend the FLPT semantics to arbitrary ﬁrst-order formulas that allow aggregates.
For any ﬁrst-order formula F with aggregates and any ﬁnite list of predicate constants p = (p1 , . . . , pn ), formula
FLPT[F ; p] is deﬁned as

Below we show how this semantics is related to the original semantics by Faber et al. [2011]. Their semantics is
deﬁned for a special class called disjunctive programs with
aggregates, whose rules have the form

3

if X |= G, and X |= H,
if X |= G,
otherwise.

Set X is an FLPT-answer set of F if X is minimal among the
sets of atoms that satisfy F X .

(¬(SUMx : p(x) < 2) ∧ ¬(SUMx : u(x) < 2) → u(2))
∧ (SUMx : p(x) ≥ 0 ∧ SUMx : u(x) ≥ 0 → u(−1))
∧ (p(−1) ∧ u(−1) → u(1)) .
(13)

A1 ; . . . ; Al ← E1 , . . . , Em , not Em+1 , . . . , not En

⎧
X
⎨G → H
= 
⎩
⊥

However, the statement of the proposition does not apply
to general programs.
Example 3 For general program Π = {p ∨ ¬p ← } and its
FOL-representation F , formula FLP[Π] has only one model,
∅, and FLPT[F ] has two models, ∅ and {p}.

In comparison with Proposition 1, this example illustrates
that, unlike the FLP semantics, the FLPT semantics does not
keep the anti-chain property. This has to do with the fact
if X |= GH ( ∈ {∧, ∨}), the FLP semantics distinguishes between rule arrows and the
other implications, while the FLPT semantics does not. The
otherwise;

727

ﬁrst-order stable model semantics from [Ferraris et al., 2011]
also lacks the anti-chain property. In fact, the FLPT semantics has similar properties with that semantics. For instance,
the following theorem is similar to Theorem 2 from [Ferraris
et al., 2011]. By Choice(p) where p is a list of predicate
constants, we denote the conjunction of “choice formulas”
∀x(p(x) ∨ ¬p(x)) for all predicate constants p in p where x
is a list of distinct object variables whose length is the same
as the arity of p.
Theorem 4 For any ﬁrst-order formula F with aggregates
and any disjoint lists p, q of distinct predicate constants, the
following formulas are logically valid:

As a special case, Theorem 6 can be applied to checking
strong equivalence under the FLP semantics between the programs whose rules have the form (14).

4

Comparing FLP, FLPT and the First-Order
Stable Model Semantics

In [Ferraris et al., 2011] the stable models are deﬁned in
terms of the SM operator with intensional predicates: for any
ﬁrst-order sentence F and any list of intensional predicates
p = (p1 , . . . , pn ), formula SM[F ; p] is deﬁned as
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),

FLPT[F ; pq] → FLPT[F ; p],
FLPT[F ∧ Choice(q); pq] ↔ FLPT[F ; p].

where F ∗ (u) is deﬁned recursively:
• pi (t)∗ = ui (t) for any list t of terms;

For example, FLPT[∀x(q(x) → p(x) ∨ ¬p(x)); p] is equivalent to

• F ∗ = F for any atomic formula F that does not contain
members of p;

FLPT[∀x(q(x) → p(x) ∨ ¬p(x)) ∧ ∀x(q(x) ∨ ¬q(x)); p, q].

• (G  H)∗ = G∗  H ∗ , where  ∈ {∧, ∨};

The following theorem is similar to Theorem 3 from [Ferraris et al., 2011].
Theorem 5 For any ﬁrst-order formulas F and G
with aggregates and any list of predicate constants p,
FLPT[F ∧ ¬G; p] is equivalent to FLPT[F ; p] ∧ ¬G.
It follows that the FLPT-stable models of F ∧ ¬G can be
characterized as the FLPT-stable models of F that satisfy ¬G.
The notion of strong equivalence has turned out to be important in the theory of stable models. Similar to the characterization of strong equivalence in terms of HT-models [Lifschitz et al., 2001; Ferraris et al., 2011], Truszczyński [2010]
deﬁned “FLP-models,” a counterpart of HT-models in the
FLPT semantics, and used them to characterize strong equivalence between propositional formulas under the FLPT semantics. In the following, we extend the result to arbitrary
ﬁrst-order formulas with aggregates.3
Following the deﬁnition of strong equivalence in the ﬁrstorder stable model semantics in [Ferraris et al., 2011], about
ﬁrst-order formulas with aggregates F and G, we say that F
is FLPT-strongly equivalent to G if, for any formula H
with aggregates, any occurrence of F in H, and any list p
of distinct predicate constants, FLPT[H; p] is equivalent to
FLPT[H  ; p], where H  is obtained from H by replacing the
occurrence of F by G. The following theorem, which is similar to Theorem 9 from [Ferraris et al., 2011], is a proper extension of Theorem 7 from [Truszczyński, 2010].
Theorem 6 Let F and G be ﬁrst-order formulas with aggregates, let pF G be the list of all predicate constants occurring
in F or G and let u be a list of distinct predicate variables.
The following conditions are equivalent to each other.
• F and G are FLPT-strongly equivalent to each other;
• Formula

• (G → H)∗ = (G∗ → H ∗ ) ∧ (G → H);
• (QxG)∗ = QxG∗ , where Q ∈ {∀, ∃};
• (OPx : G  b)∗ =
(OPx : G∗   b) ∧ (OPx : G)  b).
We often simply write SM[F ] in place of SM[F ; p] when
p is the list of all predicate constants occurring in F , and call
a model of SM[F ] simply a stable model of F .
Disregarding aggregate expressions, the main difference
among the FLP, the FLPT, and the ﬁrst-order stable model
semantics has to do with the treatment of an implication. It is
known that they coincide for programs whose rules have the
form (4) [Faber et al., 2011, Theorem 3.6], [Truszczyński,
2010, Theorem 3]. However, this is not the case for more
general classes of programs (having rules of the form (5)), or
for arbitrary formulas. In fact, no one is stronger than another,
as the following example shows.
Example 4 For propositional signature {p} and program Π1 = {p ← p ∨ ¬p}, whose FOL-representation is
F1 = p ∨ ¬p → p, each of FLP[Π1 ] and FLPT[F1 ] has {p}
as the only model, and SM[F1 ] has no models.
Formula F1 is strongly equivalent (in the sense of [Ferraris et al., 2011]), but not FLPT-strongly equivalent to
F2 = (p → p) ∧ (¬p → p). Again, SM[F2 ] has no models.
Neither does FLP[Π2 ] nor FLPT[F2 ], where Π2 is the program corresponding to F2 .
For program Π3 = {p ∨ ¬p ← }, whose FOLrepresentation is F3 =  → p ∨ ¬p, both SM[F3 ] and
FLPT[F3 ] have two models, ∅ and {p}, while FLP[Π3 ] has
only one model, ∅.
Formula F3 is strongly equivalent, but not FLPT-strongly
equivalent to F4 = ¬¬p → p. Both FLP[Π4 ] (Π4 is the
program corresponding to F4 ) and FLPT[F4 ] have only one
model, ∅, while SM[F4 ] has the same two models as SM[F3 ].
For program Π5 = {¬¬p ← , p ∨ ¬p ← ¬¬p}, and its
FOL-representation F5 , both FLP[Π5 ] and SM[F5 ] have only
one model {p}, while FLPT[F5 ] has no models.

u ≤ pF G → (F  (u) ↔ G (u))
is logically valid.
3
Due to lack of space, we do not present the extension of FLP
models, but instead present an alternative characterization in terms
of F  .

728

• F is semi-positive relative to p;
• for every occurrence of every predicate constant p
from p in F , we have that k + m ≤ 1;
• if a predicate constant p from p occurs in the scope of
a strictly positive occurrence of ∃ or ∨ in F , then the
occurrence of p is strictly positive in F .
For any canonical aggregate formula, the following result
holds.
Proposition 5 For any aggregate formula F , if F is canonical relative to p, then formula

We note that FLPT-strong equivalence involves some unintuitive cases. Formulas F ∧G and F ∧ (F → G) are strongly
equivalent under the ﬁrst-order stable model semantics, but
this is not the case under the FLPT semantics. The two formulas may not even have the same FLPT-stable models.
Example 5 Similar to program Π5 in the previous example, for propositional signature {p} and F = ¬¬p and
G = p ∨ ¬p, formulas SM[F ∧ G] and FLPT[F ∧ G] are
equivalent to each other, having only one model, {p}. Formula SM[F ∧ (F → G)] has the same model as SM[F ∧ G],
but FLPT[F ∧ (F → G)] has no models.
We now show the relationships among the three semantics. Roughly speaking, the FLPT semantics is in between the
two others in the sense that it treats a “non-strictly positive”
occurrence of a subformula same as in the FLP semantics,
and treats a “strictly positive” occurrence of a subformula the
same way as in the ﬁrst-order stable model semantics. The
deﬁnition of a strictly positive occurrence is given below.
First we present a class of programs for which the FLP
semantics and the FLPT semantics coincide. Following [Ferraris and Lifschitz, 2010], we say that an aggregate function
OP is monotone w.r.t.  if for any multisets α, β such that
α ⊆ β,
• if OP(α) is deﬁned then so is OP(β), and
• for any n ∈ Num, if OP(α)  n then OP(β)  n.
For an occurrence of a predicate constant or any other
subexpression in a formula F with aggregates, we consider
two numbers, k and m.
• k: the number of implications in F that contain that occurrence in the antecedent;
• m: the number of aggregate expressions (8) containing
that occurrence such that OP is not monotone w.r.t. .
We call an occurrence of a subexpression in F strictly positive if k + m for that occurrence in F is 0. For example, in
formula (p → q) → p, the second occurrence of p is strictly
positive. In ¬(SUMx : p(x) < 2), the occurrence of p is not
strictly positive (for that occurrence, k = m = 1).
The following theorem presents a class of programs for
which the FLP semantics and the FLPT semantics coincide.
Theorem 7 Let Π be a ﬁnite general program with aggregates, and let F be the AF-representation of Π. For every
rule (9) in Π, if every occurrence of p from p in H is strictly
positive in H, then FLP[Π; p] is equivalent to FLPT[F ; p].
The theorem is a generalization of Proposition 4. For example, the FLP and the FLPT semantics coincide on the programs whose heads have the form of a disjunction of atoms,
regardless of the form of the formulas in the body. In Example 4, programs Π1 , Π2 and Π4 satisfy the condition of
Theorem 7, and so does program (10).
Next we show the class of programs for which the FLP semantics and the stable model semantics coincide. We ﬁrst deﬁne two notions. We call an aggregate formula semi-positive
relative to p if, for every aggregate expression OPx : G  b
in it, every occurrence of every predicate p from p is strictly
positive in G. We say that an aggregate formula F is canonical relative to a list p of predicate constants if

(u ≤ p) ∧ F → (F ∗ (u) ↔ F (u))
is logically valid.
From Proposition 5, when F is a ﬁrst-order formula, it
is easy to see that CIRC[F ; p] and SM[F ; p] are equivalent to each other. This fact is used in [Kim et al., 2009;
Lee and Palla, 2010] to compute circumscriptive action formalisms using ASP solvers. Here we generalize the result to
formulas containing aggregates and use it to relate the FLP
and the FLPT operators to the SM operator.
Theorem 8 Let Π be a ﬁnite general program with aggregates and let F be the AF-representation of Π. For every
rule (9) in Π, if B is canonical relative to p and every occurrence of p from p in H is strictly positive in H, then
FLP[Π; p] is equivalent to SM[F ; p].
Among the programs in Example 4, only Π2 satisﬁes the
condition of Theorem 8. Program (10) does not satisfy the
condition because ¬(SUMx : p(x) < 2) is not canonical relative to {p}. In fact, {p(−1), p(1), p(2)} is an Herbrand interpretation that satisﬁes SM[(11)], but does not satisfy FLP[(10)].
Next we show the class of formulas F for which
FLPT[F ; p] coincides with SM[F ; p].
Theorem 9 Let F be a semi-positive aggregate formula relative to p such that every subformula that has a non-strictly
positive occurrence in F is canonical relative to p. Then
FLPT[F ; p] is equivalent to SM[F ; p].
In Example 4, relative to {p}, formulas F2 and F3 satisfy
the condition of Theorem 9. In Example 5, relative to {p},
formula F ∧ G satisfy the condition, but F ∧ (F → G) does
not. Also formula (11) does not satisfy the condition. Again,
{p(−1), p(1), p(2)} is an Herbrand interpretation that satisﬁes SM[(11)], but it does not satisfy FLPT[(11)].

5

Conclusion

Our work lifts up the mathematical foundations of the FLP
and the FLPT semantics to the ﬁrst-order level; our semantics are applicable to non-Herbrand models allowing arithmetic and arbitrary functions. The fact that these semantics
are uniformly characterized in terms of modiﬁcations to circumscription provides us useful insights into the relationships
among the FLP semantics, the FLPT semantics, circumscription and the ﬁrst-order stable model semantics. We present
the classes of formulas under which the semantics are interchangeable, which would have interesting ramiﬁcations. For

729

[Gelfond and Lifschitz, 1988] Michael
Gelfond
and
Vladimir Lifschitz. The stable model semantics for
logic programming. In Proceedings of International
Logic Programming Conference and Symposium, pages
1070–1080. MIT Press, 1988.
[Kim et al., 2009] Tae-Won Kim, Joohyung Lee, and Ravi
Palla. Circumscriptive event calculus as answer set programming. In Proceedings of International Joint Conference on Artiﬁcial Intelligence (IJCAI), pages 823–829,
2009.
[Lee and Meng, 2009] Joohyung Lee and Yunsong Meng.
On reductive semantics of aggregates in answer set programming. In Procedings of International Conference on
Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 182–195, 2009.
[Lee and Palla, 2009] Joohyung Lee and Ravi Palla. System F 2 LP – computing answer sets of ﬁrst-order formulas.
In Procedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages
515–521, 2009.
[Lee and Palla, 2010] Joohyung Lee and Ravi Palla. Situation calculus as answer set programming. In Proceedings
of the AAAI Conference on Artiﬁcial Intelligence (AAAI),
pages 309–314, 2010.
[Lifschitz et al., 2001] Vladimir Lifschitz, David Pearce,
and Agustin Valverde. Strongly equivalent logic programs.
ACM Transactions on Computational Logic, 2:526–541,
2001.
[Lifschitz, 2010] Vladimir Lifschitz. Thirteen deﬁnitions of
a stable model. Fields of Logic and Computation, volume
6300 of Lecture Notes in Computer Science, pages 488–
503. Springer, 2010.
[McCarthy, 1980] John McCarthy. Circumscription—a form
of non-monotonic reasoning.
Artiﬁcial Intelligence,
13:27–39,171–172, 1980.
[Osorio et al., 2004] Mauricio Osorio, Juan A. Navarro, and
José Arrazola. Applications of intuitionistic logic in answer set programming. TPLP, 4(3):325–354, 2004.
[Pearce, 1997] David Pearce. A new logical characterization
of stable models and answer sets. Non-Monotonic Extensions of Logic Programming (Lecture Notes in Artiﬁcial
Intelligence 1216), pages 57–70. Springer, 1997.
[Truszczyński, 2010] Miroslaw Truszczyński. Reducts of
propositional theories, satisﬁability relations, and generalizations of semantics of logic programs. Artiﬁcial Intelligence, 174(16-17):1285–1306, 2010.

instance, the FLP semantics is simpler than the ﬁrst-order stable model semantics, but involves unintuitive cases if arbitrary formulas are used in the head and in the body. Such
cases do not arise if the FLP semantics is applied to the class
of programs that satisfy the condition of Theorem 8. For the
same class of programs, system F 2 LP [Lee and Palla, 2009],
an implementation of the ﬁrst-order stable model semantics,
can be viewed also as an implementation of the general FLP
semantics.

Acknowledgements
We are grateful to anonymous referees for their useful comments on this paper. The authors were partially supported by
the National Science Foundation under Grant IIS-0916116
and by the Ofﬁce of the Director of National Intelligence
(ODNI), Intelligence Advanced Research Projects Activity
(IARPA), through the US Army Research Lab.

References
[Dao-Tran et al., 2009] Minh Dao-Tran, Thomas Eiter,
Michael Fink, and Thomas Krennwallner.
Modular
nonmonotonic logic programming revisited. In Proceedings of International Conference on Logic Programming
(ICLP), pages 145–159, 2009.
[Eiter et al., 2005] Thomas Eiter, Giovambattista Ianni, Roman Schindlauer, and Hans Tompits. A uniform integration of higher-order reasoning and external evaluations in
answer-set programming. In Proceedings of International
Joint Conference on Artiﬁcial Intelligence (IJCAI), pages
90–96, 2005.
[Faber et al., 2004] Wolfgang Faber, Nicola Leone, and Gerald Pfeifer. Recursive aggregates in disjunctive logic programs: Semantics and complexity. In Proceedings of
European Conference on Logics in Artiﬁcial Intelligence
(JELIA), 2004.
[Faber et al., 2011] Wolfgang Faber, Gerald Pfeifer, and
Nicola Leone. Semantics and complexity of recursive
aggregates in answer set programming. Artiﬁcial Intelligence, 175(1):278–298, 2011.
[Ferraris and Lifschitz, 2010] Paolo Ferraris and Vladimir
Lifschitz. On the stable model semantics of ﬁrsr-oder formulas with aggregates. In Proceedings of International
Workshop on Nonmonotonic Reasoning (NMR), 2010.
[Ferraris et al., 2007] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. A new perspective on stable models.
In Proceedings of International Joint Conference on Artiﬁcial Intelligence (IJCAI), pages 372–379, 2007.
[Ferraris et al., 2011] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. Stable models and circumscription.
Artiﬁcial Intelligence, 175:236–263, 2011.
[Ferraris, 2005] Paolo Ferraris. Answer sets for propositional theories. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 119–131, 2005.

730

A

THERMAL
MICROSCOPY SYSTEM WITH A TEMPERATURE
DITHERING,
SERVO-CONTROLLED
INTERFACECIRCUIT

SCANNING

Joohyung Lee' and Yogesh B. Gianchandani',2
'ECE Department, University of Wisconsin, Madison, WI 53706, USA
'EECS Department, University of Michigan, Ann Arbor, MI 48109, USA
ABSTRACT
This paper describes a thermal imaging system which includes
a customized micromachined thermal probe and circuit interface for
a scanning microscopy instrument. The probe shank is made from
polyimide for mechanical compliance and high thermal isolation,
and has a thin-film metal tip of =50 nm in diameter. The circuit
provides closed-loop control of the tip temperature and also permits
it to be dithered, facilitating scanning microcalorimetry applications.
This paper explains system design and optimization including both
electrical and thermal analyses. Sample scans of patterned
photoresist demonstrate noise-limited resolution of 29 pW/K in
thermal conductance. Applications of the thermal imager extend
from ULSI lithography research to biological diagnostics.

can be controlled to operate the scan at a fixed temperature. The
interface also provides electronic dithering of the tip temperature.
Its design includes consideration of thermal and electrical
interactions between the probe and circuit components based on
NIatLab'M modeling of the overall system. The functionality of the
system is demonstrated with both microcalorimetric and imaging
applications of patterned photoresist and calibration materials. To
further evaluate the operation of the circuit, nodal measurements
taken during a practical scan (not in a test mode), and are presented
along with the scanned image obtained.
Electronic
vcc
vcc

I. INTRODUCTION
In the past decade, scanning microscopy using thermallysensitive probes has been applied to a variety of applications,
ranging from ULSI lithography research to cellular diagnostics in
biochemistry [Oc96, LiO2j. Thermal probes have also been
employed for data storage and other applications [VeOO, LeOO,
Ma991. These are generally made from dielectric thin films on a
silicon substrate, and use a metal or semiconductor film bolometer
for sensing the tip temperature. Other approaches that use more
involved micromachining methods have also been reported [Gi97].
A commercially available probe uses a narrow gauge wire bent into
a V-shape to form a self-supporting resistor. However, for many
applications, thermal probes must have very low mechanical spring
constants to prevent damage to soft samples. In addition, for many
applications they must have very high thermal isolation to minimize
the thermal load presented to the sample. Both of these needs can
be met by the use of a polymer for the probe shank. Furthermore,
thermal and mechanical design challenges must be considered in
conjunction with the interface circuit for best performance of the
overall system.
In a frequently used microscopy technique, the scanning tip is
mechanically dithered so that the sample spacing is modulated at a
known frequency. This is akin to chopping the signal, which
permits the detection to b e phase locked to the dither, improving the
overall signal-to-noise ratio. In the context of thermal microscopy,
this also permits thermal capacitance measurement. However, with
ultracompliant probes, the mechanical spring constant is far too low
to permit physical dithering. The alternative is to dither the bias
current in the bolometer, thereby placing the burden on the interface
circuit. Furthermore, the very high thermal resistance of the probe
shank, designed to minimize thermal loading of the sample, has the
impact of reducing the thermal bandwidth of the probe below 1
KHz. This increases the susceptibility of the pick-off to flicker
noise and further raises the burden on the circuit.
This paper describes a thermal imaging system (Fig. 1) which
uses a customized micromachined bolometer probe and circuit
interface to a commercial scanning microscopy instrument
(TopoMetrix'M SPMLab v.3.06). The bias current in the bolometer

0-7803-7761-3/03/$17.00 02003 IEEE

Rp : Probe
resistance
Rc : control
resistance
",ntsg : integrator

,,v,

output
: demod.
output

1'he overall system configuration of the custom probe and
circuit which interface with a commercial instrument.
11. SYSTEM DESCRIPTION
A. Sensor Element
The scanning thermal probe is fabricated on a Si substrate
using a 7 mask process similar to those described in [LiOO, LiOl]. A
metal thin film bolometer is sandwiched between two layers of
polyimide that form a cantilever (Fig. 2 ) . At one end of the
cantilever the Ni thin film protrudes through an opening in lower
polyimide layer, where i t is molded into a pyramidal tip by a notch
that was anisotropically wet-etched into the substrate. A tip
diameter of =50 nm is achieved by sharpening the notch by
anisotropic thermal oxidation. The tip and a portion of the probe
shank are then released from the substrate by etching an underlying
sacrificial layer. The released length is then folded over to extend
past the die edge for clearance, and held in place by a thermocompression bond across a thin film of Au which is deposited as the
final layer on top of the polyimide. This film also serves as a mirror
to permit use of the probe for AFM. The entire fabrication process
is performed below 350°C, and is compatible with post-CMOS
processing to accommodate the possible integration of an interface
circuit. Typical dimensions of the probes after assembly are 250 I m

IV-812

length, 50 p m width, and 3 pm thickness, which result in a
mechanical spring constant of 0.08 N/m, which is upto lOOx below
commercial probes. The bolometer, which has Cr/Ni at the tip and
Cr/Au leads, is =45 R.

Integrated Flipped-over
attachment probe

.

Probe

stank

Fig.:Schematic and optical micrograph of a fabricated probe.

B. Interface Circuit
The bolometer readout is through a Wheatstone bridge, which
is commonly used for piezoresistive pressure sensors, strain gauges,
etc. It is well suited for microfabrication and allows a differential
measurement that offers a higher common-mode noise rejection than
a single-element measurement. Historically, the conversion of
bridgetesistance to current or voltage for readout has suffered from
non-linearity and restricted dynamic range [YoOO]. Additionally, in
DC mode the signal is subject not only to thermal noise from the
resistor bridge, but also I/f flicker noise from the electronics. T o
overcome these challenges, many efforts have been made to convert
resistance variation to frcquency [Mo95, Hu87, Gi761, to duty
cycle/time [Ci90. (30931, and to both of them [Fe97]. Some require
components such as a pulsed bridge supply current, or an input
amplifier with very low offset and drift [Gi76]. Furthermore, these
approaches are constrained by switching delays causing nonlinearity hetween frequency (or pulse width) and resistance change,
are expensive to implement, and most importantly cannot be applied
directly to operating the microbolometer or anemometer in a
constant tetnpcrature mode.
The system used in this effort (Fig. 1 ) utilizes two separate
feedback loops: electrical and optomechanical. As the probe (Fig. 2)
scans the sample surface, topography is mapped by detecting the
laser signal reflected off a mirror located near the tip and using this
i n a mechanical feedback loop to maintain constant contact force.
Since variations in heat loss through the probe tip cause variations in
the probe rcsistance, this quantity maps the temperature or thermal
conductance of the sample.
When both a DC and an AC signal (at wJ are applied to the
bridge (Fig. I ) , the bolometer is modulated by the square of
V,,+V,,cos(o,,t+B), and its resistance changes proportional to:
AR,, = V,,'+2V,,VA,cos(w,,t+B)

+ VA;cos2(w,,t+8)

(1)

Therefore, bolometer resistance is approximately represented as:

R,, = R,,, + R,,,,cos(o,,t+B) if VAC'<< 2.VDc.VAc
(2)
making w,, the dominant resistance-modulation frequency. T h e
output o f the bridge voltage difference amplifier is:

AV ,lu,=0.5.1,cR,Ac~~~(2w~,t+B)+
I,&,Accos(w,,t+B)

(3)

If the 2 w,, term (second harmonic) of the voltage-modulation
frequency is selected, the impact of l/f flicker noise can be reduced.
In addition, better signal-to-noise ratio is expected as I,, becomes
high to a certain extent, In the selected implementation, V,, was 5
V and VACwas 0.8 V.
T h e interface circuit includes a PI controller (which is
comprised of an integrator and an inverting amplifier), and a simple
homodyne demodulator (Fig. I ) . in which the input signal is
multiplied by in-phase local oscillator and then low pass filtered
(Fig, 3). The PI controller has integral gain of IO4 and proportional
gain of I , showing settling time <I0 msec. This demodulation
technique (Method A) is applicable when phase change in the input
signal is negligibly small compared to change in its magnitude. The
Method A is simple to implement and does not have mismatch
problems which are faced in quadrature homodyne demodulation
(Method B). In Method B, in-phase (I signal) and quadrature ( Q
signal) signals are generated, low pass filtered, and root mean
squared. Problems are caused by mismatches between the
amplitude of I and Q signals and errors in the nominally 90" phase
shift. Method A is consequently preferred. According to our
previous investigations [LiOl], the -3 d B frequency of thermal
response of the probe is about 0.5 kHz with an open-loop interface
circuit. It is somewhat higher with a closed loop interface circuit
because external power is used to increase effective thermal
conductance of the probe [Sa93]. Consequently. for this project a 1
kHz dither is selected, and scan speeds are set to provide a measured
data bandwidth 4 0 Hz. The bridge output voltage is band pass
filtered at the second harmonic 2 kHz, and multiplied by thc
frequency doubled output of the dither oscillator (Fig. 3). The phasc
of the local oscillator is synchronized with that of input carrier
signal to avoid signal distortion. The final output is obtained by low
pass filtering. The Q factor of band pass filter and -3 dB frequency
of low pass filter are based on the dither frequency and data
bandwidth, but adjusted for low frequency noise near the band edge
of scan data. Bi-quad band pass filters and bi-quad low pass filters
are used because of their excellent tuning fcatures and good
stability. The gain, quality factor, and salient frequencies of the
filters can be independently controlled.
111. SYSTEM MODELING AND SIMULATION

The simulation of the whole sensing subsystem provides an
understanding of the interaction between thermal behavior of the
probe and electrical behavior of the interface circuit. I t is
accomplished using electrical parameters of the Simulink tool within
MatLab.IM. Figure 4 shows the state diagram for the combined
subsystem. Using this. i t is demonstrated how the demodulator
achieves noise reduction compared to a non-dithered D C closed loop
interface circuit.
A challenge in modeling the subsystem is how to transform a
thermal probe into electrical parameters. The dotted block in bottom
left of Fig. 4 represents the thermal probe model. The three inputs
shown are used to mimic the time variation of thermal conductance
encountered during a scan of photoresist lines on a Si substrate.
Thermal conductance changes smoothly in a real scan, but the
variation should have a non-zero and finite bandwidth to test the
circuit for signal distortion. The sum of these inputs is multiplied by
the temperature bias of the tip to calculate the power variation in the
probe. This variation, which would otherwise modulate the
bolometer, is instantly compensated by the interface circuit which
keeps the probe temperature constant.
An important optimization parameter for simulations is the
ratio of VDc to V A c in eqn. ( I ) . As VAc increases, modulation of

IV-813

probe resistance by the second harmonic of applied power cannot be
ignored. Additionally, simulations show that the PI controller loses
its feedback control, even though the signal-to-noise at the output of
demodulator becomes better in a certain range of VAc. The probe
temperature is supposed to be almost constant despite small AC
temperature variations introduced for dither operation b y the PI
controller. However, as V A C increases, power supplied by the AC
component becomes comparable to DC power, causing the tip
temperature to fluctuate significantly. Now the PI controller
receives a significant AC signal in addition to the DC signal that is
the differential output from the resistor bridge. The output of PI
controller thus contains not only DC compensation power but also a
significant amount of unnecessary AC power, which derails the PI
feedback control. A low pass filter can be placed between bridge
circuit and PI controller to avoid this problem. However, it is only
useful when the dither frequency is much higher than bandwidth of
the scan signal from the bridge. In the simulated system the
mimicked signal at the input of the system contains frequency
components at higher frequencies than the dithering signal.
Figure 4(a) represents a noiseless input to the system. When
low frequency noise exists at 100 Hz, with a 20% variation in
bolometer resistance the bridge output is deteriorated in the absence
of electrical dithering (Fig. 4(b)). In contrast, the output of
demodulator (Fig. 4(c)), which is used with electrical dithering,
shows a much better signal-to-noise ratio. However, the output of
demodulator can be distorted because high-frequency components of
the input signal can be inadvertently screened by band pass filters
with high quality factor. This motivates the use of the highest dither
frequency (and thus a fast thermal response) to secure the maximum
signal bandwidth.

IV. MEASUREMENT
Insets in Fig. 3 show frequency spectra at various circuit nodes
taken while scanning a photoresist sample at a tip temperature of
45°C. Figure 3(a) shows that at the output of the bridge circuit,
where the second harmonic contains the pursued power-modulated
thermal signal, the amplitude ratio of the first harmonic to the
second is 24.6, which is very close to the theoretical value of 25
obtained from eqn. (3). This demonstrates that the bandwidth of the
thermal probe.can be wider than 2 kHz and the 2 kHz-dithered
signal is not distorted by thermal delay. Figure 3(b) shows that the
band pass filtered signal has a dominant second harmonic. Filters
with higher Q-factor can be used to suppress other harmonics, but
could cause signal distortion due to reduced bandwidth. Figure 3(c)
shows the output of the frequency doubling circuit, which serves as
the local oscillator in demodulation. The dominant 2 kHz harmonic
is obtained using a high Q-factor band pass filter. Figure 3(d) shows
the multiplier output, where the D C component contains
demodulated thermal signal. The output of the low pass filter shows
that other harmonics can be effectively removed (Fig. 3(e)).
Figure 5 is a comparison of the thermal image with the
topographic image obtained using closed loop interface circuit
during measurements shown in Fig. 3. The sample was 350 nm
thick, developed Shipley UV6TMphotoresist, with a 1 pm pitch. The
similarity between the two images is self-evident. The somewhat
flatter top seen for the ridges in the thermal image is as expected
because of the thermal diffusivity of the sample. According to a line
scan across the photoresist patterns of Fig.5, the noise-limited
minimum detectable thermal conductance change is =29 pW/K.

V. CONCLUSION
A scanning thermal imager with micromachined bolometer
type probes and a custom interface circuit was described. Unified
sirnulation of the transducer and circuit permits the components to
be optimized together. The probe temperature can be precisely
controlled by a PI controller while electrical dithering provides
relative immunity to thermal bridge noise even for sub-FV lowfrequency signals. Scanning thermal images obtained showed a
high signal-to-noise ratio of 6 for 350nm UV photoresist in which
the minimum detectable thermal conductance change was =29
pW/K.

ACKNOWLEDGEMENTS
This work was funded in part by the Semiconductor Research
Corporation contract ## 98-LP-452,005. Valuable discussions with
Profs. F. Cerrina and P. Nealey, and Drs. M.-H. Li and R. Tate, all
of UW-Madison, and Dr. L. Ocola of Argonne National Laboratory
are gratefully acknowledged.

RE FE RE NCES
[Ci90] A.Cichocki, R.Unbehauen, “Application of switched-capacitor selfoscillating circuits to the conversion of RLC parameters into a frequency or
digital signal,’’ Sensors und Actuutors A , vol. 24, pp. 129-137, 1990
[Fe971 V.Ferrari. C.Ghidini, D.Marioli. A.Taroni, “Conditioning circuit for
resistive sensors combining frequency and duty-cycle modulation on the
same output signal,” Measurenient Science & Techno/., 8(7). pp. 827-9, ‘97
[Gi’76] B.Gilbert, “A versatile monolithic voltage-to-frequency converter,”
IEEE J. Solid-Stute Circuits, SC-I l(6). pp. 852-64, 1976
[Gi97] Y. Gianchandani, K. Najafi, “Scanning Thermal Profilers with
Integrated Sensing and Actuation,” Trunsuctions on Electron Devices, 44
( I 111, Nov. 1997, pp. 1857-68
[Go931 F.M.L. van der Goes, P.C.De Jong, G.C.M.Meijer, “Concepts for
acciirate A/D converters for transducers,” Solid-Stute Sensors nnd Actuutor.y
(Trunsducers ’93),Yokohama, Japan, 1993, pp. 33 1-4
[Hu87] J.H.Huijsing, G.A.Van Rossum. M.van der Lee. “Two-wire bridgeto-frequency converter,” J. Solid-Stute Circuits. SC-22(3),pp. 343-9. I987
[LeOO] J . Lerchner, D.Caspary, G.Wolf. “Calorimetric detection of volatile
organic compounds,”Sensors und Actuutors E , 70, pp. 57-66, 2000
[LiOO] M.-H.Li, Y.B.Gianchandani, “Microcalorimetry applications of a
surface micromachined bolometer-type thermal probe,” J. Vuc. Sc!. Techriol

B, 18(6), pp. 3600-3,2000
[LiOI] M.-H.Li, J.J.Wu, Y.B.Gianchandani, “Surface micromachined
poly imide scanning thermocouple probes,” J . Microelectrrjniech. Sy.r., IO( I),
pp. 3-9,2001
[LiO2] M.-H.Li, J.-H.Lee, F.Cerrina, A.K.Menon, Y.B.Cianchandani,
“Chemical and biological diagnostics using fully insulated ultracompliant
thermal probes,” Proceedings on Solid-Stute Sensor, Actuutor. und
Microsystems Conference, Hilton Head Island, SC, 2002, pp. 235-8
[Ma991 A.Majumdar, “Scanning thermal microscopy,” Annu. Rev. Muter.
SC;.,29, pp. 505-85, 1999
[Mo95] K.Mochizuki, K.Watanabe, “A linear resistance-to-frequency
converter,” Proc., Instrunientution und Meusurenient Technology Conf:
(IMTC),Waltham, MA, 1995, pp. 339-43.
[Oc96] L.E.Ocola, D.Fryer, P.Nealey, J.dePablo, F.Cerrina, S. Kirnmer,
“Latent image formation: Nanoscale topography and calorimetric
measurements in chemically amplified resists,” J. Vuc. Sci. Techno/. B,
14(6),pp. 3974-9, 1996
[Sa931 G.R.Sarma, “Analysis of a constant voltage anemometer circuit,”
P r o c . , Instrunientution und Meusurement Technology Conf: ( I M T C ) .
Waltham, MA, 1993, pp. 731-6.

[VeOO] P.Vettiger. et al., “The “Millipede”-More than one thousand tips for
future AFM data storage,’’IEM J . Res. Develop., 44(3), pp. 323-40. 2000
[YoOO] D.J.Yonce, P.P.Bey Jr., T.L.J.Fare, “A DC autonulling bridge for
real-time resistance measurement,” Trans. Circuits & Sy.steni.7, 47(3), pp.
273-’7,2000

IV-814

I DEMODULATOR

0
-20

(q

0
-201

Flg.3:Demodulator section of the interface circuit in Fig. 1, Embedded frequency spectra were obtained while scanning a real sample, not in
a test mode. The scan results are present in Fig. 5 .

3'(2'pi^O.2e3)*2

LPF 1

s2 +2*pi*0.2e3~.7~+(2*pi'0.2e3)*2

LPF 2

-I
State diagram for the scanning thermal microscopy system including thermal response of the probe and the electrical behavior ot the
circuit The MatLablM Simulink tool is used to optimize the circuit and evaluate overall performance, including noise immunity

Topographic (lett)
and thermal (right)
$ images of
; developed 350nm
thick UV6TM
photoresist scanned
.3 at 4 5 tip~
temperature
D

163 v
073 v

nm

nm

W

1

h

IV-815

2015 IEEE Wireless Communications and Networking Conference (WCNC): - Track 3: Mobile and Wireless Networks

Energy Efficient Pricing Scheme for Multi-homing
in Heterogeneous Wireless Access Networks: A
Game Theoretic Model and Its Analysis
Seonghwa Yun, Joohyung Lee, S.H. Shah Newaz and Jun Kyun Choi
Department of Electrical Engineering
Korea Advanced Institute of Science and Technology (KAIST)
Daejeon, Republic of Korea
Email: {seonghwa.yun, joohyung08, newaz}@kaist.ac.kr, jkchoi59@kaist.edu

Abstract—For improving Quality of Service in wireless networks, multi-homing techniques have been considered as a
promising solution. To date, most of the conventional research
efforts have been focusing on user side interests (e.g. improving
throughput, minimizing packet loss). However, a service provider
could have different interests (e.g. profit, energy efficiency).
Nevertheless, to the best of our knowledge, there is no research
concern that takes into account the interests of user and service
provider side at the same time. In this paper, we first model
utility functions of both sides considering the aforementioned
issues. Then, based on these utility functions we address the
joint pricing and load distribution problem of multi-homing in
heterogeneous wireless networks. Here, the problem is formulated
into a Stackelberg game. Then, we propose schemes to obtain an
optimal solution; so that, both sides (i.e. service providers and
users) are satisfied. Finally, we provide rigorous analysis varying
different parameters (e.g. cost, rate allocation, energy efficiency)
which can potentially affect to the game. In addition to that, we
show the proposed schemes are well converged to equilibrium
point.
Index Terms—multi-homing, energy efficiency, Stackelberg
game, pricing, resource allocation, heterogeneous wireless networks

I. I NTRODUCTION
With the popularity of internet-based data services in wireless networks seeing astronomical growth, multi-interfaced
devices are being rapidly deployed. Therefore, Internet service providers (ISPs) are expected to offer services through
several wireless technologies. Thus, in overlapped heterogeneous wireless access networks, mobile devices with multiple
interfaces will be able to maintain simultaneous connections
with different networks and increase their data communication rates by aggregating the bandwidth available at these
networks which called multi-homing techniques. The multihoming techniques have been researched for many years and
considered a promising solution as it can improve quality of
service (QoS) by taking advantage of multi-homing.
In relation to multi-homing techniques, numerous studies
have been conducted to solve the problems of re-sequencing
delay and fault tolerance as well as to increase the resequencing buffer size when the multi-homing technique is
executed [1]–[6]. Most rate allocation in multi-homing is
aimed at maximizing throughput or guaranteeing QoS [4]–
[6]. However, to the best of our knowledge, previous work

978-1-4799-8406-0/15/$31.00 ©2015 IEEE

has focused only on user side, and thus insufficient attention
has been directed at service provider side, which inspired our
work.
In the sense of service provider, utility of service provider
can be described as profit as well as energy efficiency.
Especially, concerns on energy efficiency of wireless access
networks have been increasing due to increasing the demand
for wireless data traffic dramatically. Due to the depletion of
non-renewable energy resources, increasing energy cost which
is a huge portion of their operational expenditure (OPEX) has
been predicted [7]. It means that energy efficiency should
be an important criterion not option anymore for wireless
network operators [8]. Thus, a service provider intends to
maximize their profit and energy efficiency both. Especially,
in heterogeneous access networks, wireless access networks
have different energy efficiency gain due to different power
consumption patterns related with characteristics of content
(e.g., loaded traffic, overall capacity). Here, in the sense of
users, users try to maximize their utility including QoS and
cost to pay. And, a service provider needs to set the cost of
each access networks to promote maximum utility over user
reaction.
The contributions of this paper are summarized as follows:
• We design the service provider’s utility function by compromising between profit and energy efficiency both. The
users utility function is designed by considering following
aspects: 1) user’s throughput satisfaction, 2) packet loss
probability, and 3) cost to pay.
• Based on proposed utility functions, we address the
joint pricing and load distribution problem considering
both users and service provider in heterogeneous wireless access networks with multi-homing. The problem
is formulated as a Stackelberg (leader-follower) game.
We solve the both single-follower and multi-follower
Stackelberg game.
• We adopt a Lagrangian algorithm to solve the convex
optimization of user side. On service provider side, we
propose greedy pricing algorithm by an iterative search.
In numerical results, with varying parameters, we analyze
the relationship between users and service provider in
terms of best response. Finally, we show that the proposed
schemes are well converged to equilibrium points.

1672

2015 IEEE Wireless Communications and Networking Conference (WCNC): - Track 3: Mobile and Wireless Networks
2

The remainder of this paper is organized as follows. We
explain the detail system model and utility function of service
provider and users in Section II. In Section III, we formulate a
Stackelberg game and discuss about Stackelberg Equilibrium
(SE). In Section IV and V, detailed analysis of a Stackelberg
game is conducted. Section VI shows numerical results, and
we conclude our work in Section VII.
II. S YSTEM M ODEL
We consider a set of access networks I = {1, 2, . . . , I},
which is the same as a multiple interfaces set (i.e. the number
of interfaces a user has is equal to the number of available
access networks). Each access network i is characterized by
its available bit rate, Ci . Let N = {1, 2, . . . , N } denotes
the set of users. Here, r = {ri,n }I×N , and ri,n means user
n’s rate allocation on interface i. P
And, the total allocated rate
over interface i is ri where, ri = n∈N ri,n . Therefore,
total
P
aggregated rate over all access networks (rtot ) is i∈I ri .
Fig. 1. illustrates the network architecture for providing
single data service to a multi-homed device. A data flow of a
particular service should be partitioned using a rate allocation
algorithm over the heterogeneous access networks.
A. The utility function of service providers
We newly introduce a general utility function of service
providers by considering energy efficiency. Here, Base Station
(BS) consists of two types of power consumptions: fixed
power consumption and adaptive power consumption that is
proportional to BS’s utilization [7]. Therefore, total power
consumption of BS is given as follows:
PBS,i (x) = (1 − qi ) · x/Ci · Pmax,i + qi · Pmax,i ,

(1)

where Pmax,i is the maximum operational power of BS i,
qi is the portion of fixed power consumption to Pmax,i , x
is allocated rate to BS.
From (1), we use the energy efficiency metric, which is
the ratio of total throughput to total power consumption, as
defined in [13]. The energy efficiency of BS can be expressed
as
EBS,i (x) = x/PBS,i (x).

(2)

The utility function of a service provider needs to be
modelled considering energy efficiency as well as total revenue
from subscribers. Therefore, this utility function is presented
as below
X
X
User =
pi · ri + ω
EBS,i (ri ),
(3)
i∈I

i∈I

where pi is normalized cost per bandwidth at interface i, ω is
weight factor for energy efficiency decided by service provider.
B. The utility function of users
Using multi-homing technique, a user can enjoy a bandwidth hungry application with better QoS. It is because,
multi-homing technique can ensure not only higher bandwidth
but also can reduce latency by utilizing multiple interfaces
simultaneously. Arguably, users’ main objective would be
maximizing data service quality in a wireless network.

AP 1

Rate Allocation

Objective includes:
ȡ Energy Efficiency
ȡ Total Revenue

r1

r2

p1

p2

AP 2
Objective includes:
ȡ Energy Efficiency
ȡ Total Revenue

Price
Objective includes:
ȡ Satisfaction from aggregated rate
ȡ Packet loss
ȡ Cost minimization

User
Fig. 1. Network Architecture for a Stackelberg game for pricing and load
distribution in multi-homing.

In distortion model, we consider a delay constraint tightly
connected with the packet loss as the special case of a multimedia streaming service. The packet loss rate reflects the late
arrival of streaming packets. In a bandwidth-limited network,
this loss rate can be modelled based on the M/M/1 queuing
model [14]. The packet loss rate depends on exponential delay
distributions with the average packet size L for each interface
and the deadline constraint t0 . Then, the probability of packet
loss due to late arrival of streaming packets can be expressed
as
P rob{Delay > t0 } = e−t0 (Ci −ri )/L .

(4)

Therefore, the average packet loss rate of user n is the
weighted sum of packet losses over all interfaces as follows:
X
Ploss,n =
ri,n e−γ(Ci −ri ) ,
(5)
i∈I

where γ = t0 /L. In the sense of a user, a utility function
needs to be modelled with QoS and cost of service. Therefore,
proposed utility function of a user is presented as below
X
X
Uuser,n = log(1 +
ri,n ) − κn Ploss,n − δ
pi ri,n (6)
i∈I

i∈I

where κn is weight factor of packet loss rate for user n, and δ
is weight factor for cost. We use a linear combination of user
satisfaction, defined in [15], from total aggregated rate over all
access networks and packet loss rate for modeling QoS part.
III. A GAME - THEORETIC APPROACH : S TACKELBERG GAME
In this section, we introduce a game-theoretic approach
to analyze our system model. Especially, we describe basic
knowledge about Stackelberg game to formulate the joint
pricing and load distribution problem.
A. Stackelberg Game Formulation
In Stackelberg game, there is a leader (or leaders) who
holds stronger position, and it can impose its own strategy.
Then, there are other players, called followers, who react to
the leader’s strategy. In our system model, service provider
takes a role of the leader, while users take role of followers.
The service provider makes a pricing strategy p to impose
cost on the users. The users decide the rate-allocation for each

1673

2015 IEEE Wireless Communications and Networking Conference (WCNC): - Track 3: Mobile and Wireless Networks
3

interface based on provider’s strategy to maximize their utility.
Therefore, for a given pricing strategy p, we define the bestresponse function Bf ol of follower as given by
r∗ = Bf ol (p) = arg max Uf ol ,

(7)

r∈R

where R denotes a set of possible rate-allocation strategies.
The leader also wants to maximize its utility by choosing
proper strategy. Therefore, the optimal pricing strategy p∗
could be expressed as
p∗ = arg max Ulead (p, r∗ (p)).

(8)

p

It means that the leader needs to consider the follower’s
best-response for imposed pricing strategy to decide optimal
strategy. The goal of this game is to find the Stackelberg
Equilibrium (SE) point. At SE point(s), both the leader and
followers have no reason for deviating.

A. Concavity of user’s utility function
The objective function at (10) is composed of three
P terms;
user satisfaction from aggregated rate
(log(1
+
i∈I ri )),
P
packet loss (−κPloss ), and cost (−δ i∈I pi · ri ). Obviously,
the sum of concave functions is concave function. Thus, we
can prove that the objective function is a concave function by
showing the concavity of each term.
Proposition 1. The user satisfaction term in objective function
is a concave function.
Proof. The user satisfaction function is denoted as
X
T (r) = log(1 +
ri ),

(11)

i∈I

and then, for any 1 ≤ j, k ≤ I,
∂2T
1
=−
2 .
P
∂rj ∂rk
1 + i∈I ri

(12)

B. Stackelberg Equilibrium

Since (12) has same negative value for any r ∈ R, and all
feasible j, k pairs, the user satisfaction function T is a concave
function.

For the formulated stackelberg game, a pair of leader’s and
follower’s strategy (pSE , rSE ) is called SE if

Proposition 2. The packet loss term in objective function is
a concave function.

pSE = arg max Ulead (p, Bf ol (p)),

Proof. According to (10), the packet loss term has the following form:
X
−κPloss (r) = −κ
ri e−γ(Ci −ri ) .
(13)

p

(9)

and rSE = Bf ol (pSE ). To find the SE, at first, we need to
solve the best-response function (7); so that, we can get the
relationship between leader’s strategy and follower’s strategy.
Based on that relationship, we can get optimal pricing strategy
p∗ by solving (8) and find the SE point(s).
In the following sections, we consider the two cases:
single-follower case and multi-follower case. The differences
between two cases are follower’s strategy set R and utility
function Uf ol .
IV. S INGLE - FOLLOWER S TAKELBERG GAME
At first, we consider the single-follower Stakelberg game
as one of simple case. Thus, we assume that there is only
one user. Therefore, we omit the user index n from the utility
function presented in (6). From (6) and (7), the best-response
of follower could be rewritten as
!
X
X
r = arg max log(1 +
ri ) − κPloss − δ
pi ri
(10)
r∈R

i∈I

i∈I

where p is the given pricing strategy of service provider and
R is an open set
I

R = {r ∈ R |ri > 0, ri < Ci , ∀i ∈ I}.
To find the best-response rate-allocation for given cost, we
will transform (10) into a convex optimization problem. In
this case, the concavity of objective function at (10) makes
the transformation possible. So, we first prove the concavity
of objective function.

i∈I

Since a certain convex function f can be transformed into a
certain concave function −f , the packet loss function should
be a concave function if the Ploss (r) is a convex function. For
any 1 ≤ j, k ≤ I,
(
∂ 2 Ploss (r)
e−γ(Ci −ri ) (2γ + γ 2 ri ) if j = k
=
,
∂rj ∂rk
0
if j 6= k
and this value is always greater than zero for any feasible
j, k, r which implies the convexity of Ploss (r). As we explained above, the convexity of Ploss leads the concavity of
packet loss term. Therefore, we prove the concavity of packet
loss term in objective function.
Proposition 3. The utility function of user is a concave
function.
Proof. It is easy to prove the concavity of cost term in
objective function. According to Prop 1 and 2, a user’s utility
function is expressed as a sum of concave functions. The sum
of concave functions is concave, so finally we can prove the
concavity of the utility function (6).
B. Optimization problem at follower-level
Since user’s utility function Uuser is a concave function,
solving best-response function of user in (10) could be considered as convex optimization problem as follows:

1674

max Uuser (r, p)

(14)

r

s.t.

ri > 0,
ri < Ci ,

for ∀i ∈ I,
for ∀i ∈ I,

2015 IEEE Wireless Communications and Networking Conference (WCNC): - Track 3: Mobile and Wireless Networks
4

If the objective and inequality constraint functions are
convex and the equality constraint functions are linear, then
the problem is a convex optimization problem [16]. The basic
idea in Lagrange duality is to relax the original problem (14)
by transferring the constraints to the objective in the form of
a weighted sum. The Lagrangian associated with the problem
(14) is given by
X
X
L(r, λ, σ) = Uuser (r, p) −
λi ri +
σi (ri − Ci ) (15)
i∈I

i∈I

where λi , σi are Lagrange multipliers.
As above, let ri∗ and (λ∗ , σ ∗ ) be any primal and dual optimal
points with a zero duality gap. Since ri∗ minimizes L(r, λ∗ ,
σ ∗ ) over ri , it follows that its gradient must vanish at ri∗ .
The necessary and sufficient conditions for optimality are then
given by the Karush-Kuhn-Tucker (KKT) conditions:
0
Uuser
(r∗) − λ∗i + σi∗ = 0,
−λ∗i ri∗ = 0,
σi∗ (ri∗ − Ci ) = 0,
λ∗i , σi∗ ≥ 0.

for ∀i ∈ I,
for ∀i ∈ I,
for ∀i ∈ I,

(16)
(17)
(18)
(19)

0
is derivation of Uuser with respect to ri :
where Uuser
0
Uuser
=

(1 +

1
X

ri )

− κe−γ(Ci −ri ) (1 + γri ) − δpi . (20)

i∈I

Therefore, we use one of the distributed algorithms to
solve (14), which is a Lagrangian algorithm based on a dual
decomposition [17], [18]. The Lagrangian algorithm for this
problem is given by
(j+1)
ri
(j+1)
λi

=

(j+1)

=

σi

=

(j)
(j)
0(j)
ri − α{Uuser
−λ
h
i i
(j)
(j)
λi + β · ri
+,
h
i

(j)
(j)
σi − θ ri −Ci
+,

+

(j)
σi }

(21)
(22)

And, reconstructing pricing strategy set Pi for all i ∈ I based
on p∗ . We can assume that the optimal point would be included
in that re-formed strategy set. Next, the grid size is reduced
to search optimal point more accurately from reconstructed
pricing strategy set. The above procedure continues as long as
the difference of previous maximum utility Umax and current
∗
optimal User
becomes smaller than threshold value. Finally,
proposed algorithm determines the optimal pricing vector.
The computational time to find the optimal pricing vector
depends on the number of interfaces (with the increment of
interfaces, the time complexity increases exponentially). In
practice, however, a user has only a few number of interfaces
(e.g. maximum 3 or 4). Therefore, the proposed algorithm
would be able to find optimal solution in reasonable time.
V. M ULTI - FOLLOWER S TAKELBERG GAME
In this section, we consider the multi-follower case, the
extended version of single-follower case. Assume that, at
follower-level, all users cooperate with each other to maximize
their social welfare. Let N = {1, 2, ..., N } denotes the set of
users in follower-level. The social welfare function of follower
level could be defined as a sum of utility functions for all users:
X
Usw (r) =
Uuser,n (r),
(24)
n∈N

where r = {ri,n }I×N .
Similar with single-follower case, we can specify the bestresponse of followers for given provider’s pricing strategy to
maximize the social welfare,
r = Bsw (p) = arg max0 Usw (r),
r∈R

(25)

where R0 denotes the set of possible rate-allocation matrices
of N users defined as:
X
R0 = {r = [an,i ]N ×I |an,i = ri,n ,
ri,n < Ci , rin > 0}.
n∈N

(23)

where [·]+ =max{0, ·}, j is the time index and α, β, θ are
step size.
The update equation for dual variables is a projected gradient algorithm for maximizing the Lagrangian with respect
to its dual variable argument. The reason for the projection is
that the KKT multiplier vector is required to be nonnegative
in order to satisfy the KKT condition [18].
C. Pricing strategy at leader-level
At leader-level, provider will decide its pricing strategy
on reference to user’s rate-allocation strategy to maximize
his utility defined at (3). Due to the discontinuity and nonmonotonic nature of the Lagrangian algorithm of user side,
optimization problem at leader-level can be obtained by an
iterative search algorithm. Thus, we propose the greedy pricing
algorithm for finding optimal pricing strategy.
Our algorithm is started with selecting grid points of pricing
strategy set with arbitrary grid size. With the selected grid
points, it calculates User , which is the utility of service
provider, from the (3) and (21)-(23). Then, we can find the
pricing strategy p∗ for maximizing User with given grid size.

The best-response function (25) also can be transformed
into convex optimization problem if the objective function Usw
is a concave function over R0 . If we prove the concavity of
the function Uuser,n , then the social welfare function (24),
which is the sum of Uuser,n for all users, becomes a concave
function.
A. Concavity of social welfare
Same with single-follower case, the P
function Uuser,n (r) has
three terms: user satisfaction (log(1
+
i∈I ri,n )), packet loss
P
(−κn Ploss,n ), and cost (−δn i∈I pi · ri,n ). For a specific
user n, we can prove the concavity of user satisfaction and
cost as same as single-follower case. The packet loss term is
slightly different, but we can prove it with a similar process.
As we did, instead of proving the concavity of packet loss
term of (24), we prove the convexity of Ploss,n . For all 1 ≤
j, k ≤ I,
X
∂ 2 Ploss,n
=κ
γ 2 ri,n e−γ(Ci −ri ) + 2κγe−γ(Ci −ri ) ≥ 0,
∂rj,n ∂rk,n
i∈I

and this implies that Ploss,n is a convex function. Therefore,
Uuser,n is a concave function, and Usw which is the sum of
Uuser,n for all n ∈ N is also concave.

1675

2015 IEEE Wireless Communications and Networking Conference (WCNC): - Track 3: Mobile and Wireless Networks
5

B. Optimization problem of social welfare
With the concavity of social welfare, we can transform (25)
into convex optimization problem as follows:

r2 (Mbps)

(26)

r

10

4

r1 (Mbps)

max Usw (r, p)

5

3
2

δ=0.6
δ=0.37
δ=0.184
Max. Cap.

1

ri,n > 0,
∀i ∈ I, ∀n ∈ N
X
ri,n < Ci , ∀i ∈ I.

0
0

0.2

n∈N

Similar with previous approach, a dual decomposition is
appropriate. In this part, we omit expression of the specific
Lagrangian form. Then, the Lagrangian algorithm for this
problem is given by

(j+1)

σi

(j)

(j)

n∈N

(27)
(28)

(1 +

1
X

ri,n )

0.4

0.6

0.8

5

1
0.8
0.6

p1

+,

In our analysis, we assume that there exists two different
WLAN Access Points (APs), called AP1 and AP2, which are
operated on different channel bandwidth and have maximum
capacity of 5.1 and 11 Mbps, respectively. Based on the linear
relationship between transmission and operational power consumption, we consider that the maximum operational power
for the APs, i.e., 38W and 50W, for AP1 and AP2, respectively
[7]. In addition, the portion of fixed power consumption to
Pmax,i (qi ) is 40% and 50% for AP1 and AP2, respectively.
The average packet size L for each interface is also assumed
as 2048 bytes.
A. Rate allocation at each interface
In Fig. 2. (a) and (b), we analyze the rate allocation at each
interface. Basically, the allocated rates decrease as the interface
cost increases. It is because, interface cost directly affects
the proposed utility function of users, which is presented in
(6). This figure shows that over the less expensive interface
cost region user allocates rates as much as possible to both
interfaces as long as packet loss does not occur. In other words,
due to the packet loss depending on deadline constraint in
(5), user cannot accommodate maximum data rate at certain

0.8

1

0.2
0

(a) interface 1

15
10
5
0
1

1
0.8

0.8
0.6

0.6
0.4

0.4
0.2
0

VI. N UMERICAL R ESULTS

0.6

(b) interface 2

0.4

(29)

C. Pricing strategy at leader-level
At this point, we need to find optimal pricing vector in
multi-follower case. For doing so, we need to follow almost
the same procedures applied in the algorithm used for singlefollower case presented in IV-C. The only change in this
algorithm is the Lagrangian for user optimization (i.e. in this
case we are using (27)-(29) instead of (21)-(23)).

0.4

(a) interface 1

0.6

i∈I

0.2

p (= p1 = p2)

0.8

− κe−γ(Ci −ri ) (1 + γri,n ) − δpi .

0
0

1

p (= p1 = p2)

0
1

where ∇i Uuser,n denotes the derivation of Uuser,n with respect to ri,n such that
∇i Uuser,n =

4
2

r2 (Mbps)

(j+1)

λi,n

(j)

(j)
= ri,n − α{∇i Uuser,n
− λi,n + σi }
h
i
(j)
(j)
= λi,n + β · ri,n
+,
"
!#
X
(j)
(j)
= σi − θ
Ci − ri,n

6

Fig. 2. Rate allocation at each interface versus cost (p1 = p2).

r1 (Mbps)

(j+1)

ri,n

δ=0.6
δ=0.37
δ=0.184
Max. Cap.

8

p2

p1

0.4
0.2

0.2
0

p2

0

(b) interface 2

Fig. 3. Rate allocation at each interface versus cost (p1 6= p2).

interface. Therefore, even though the cost is almost zero, user
allocates almost 4.6 Mbps and 10.2 Mbps at each interface,
respectively, rather than allocating maximum data rate of AP1
and AP2 as shown in Fig. 2.
Similarly, Fig. 3. (a) and (b) present the rate allocation at
each interface versus varying cost pairs (p1, p2). It explains
that a user prefers allocating more rate to interface which has
relatively less cost than others.
B. Utility of user and service provider
Fig. 4. (a) and (b) show the utility value of service provider
User and user Uuser with varying cost pairs (p1, p2). Here,
we set the parameters (i.e., weight factors) as κ=0.05, δ=0.184
and ω=20. As shown in Fig. 4. (a), SE is reached at (0.48,
0.38). In this case, if service provider increases cost too
much for achieving more profit per bandwidth, users tend to
decrease the rate allocation. Based on this relationship, there
exist adequate SE points. Vertical black line shows that our
proposed algorithm converged to the almost optimal SE.
Fig. 5. (a) and (b) present relationship between costs and
utility of service provider when there are 20 users in followerlevel. First, we assume that all users in follower-level are
homogeneous. It means that they have same weight factor
for utility function (κ=2, δ=0.75 and ω=40). In multi-follower
case, as total maximum capacity of each interface is shared
with multiple users, the rate allocation to certain user are
limited compared to single-follower case.
C. SE with respect to the number of followers
According to Fig. 6. (a) and (b), we analyze the tendency
of cost and social welfare on follower-level at SE point
according to varying number of followers. In Fig. 6. (a), the
optimal cost vectors (p1, p2) increased as the number of
followers increased. Same as above reasons, as the maximum

1676

2015 IEEE Wireless Communications and Networking Conference (WCNC): - Track 3: Mobile and Wireless Networks
6

service provider strategy. Finally, we show the proposed
scheme is well converged to equilibrium point.

12
10
3

Uuser

User

8
6
4
2

2

1
0.8

0.8

0
1

0.6

0.6
0.5

p1

0

0.6

0.4

0.2

0

1

0.8

ACKNOWLEDGMENT
This research was funded by the MSIP (Ministry of
Science, ICT & Future Planning), Korea in the ICT R&D
Program 2014 [1391104001, Research on Communication
Technology using Bio-inspired Algorithm].

1
0
1

Optimal Point
from Algorithm

p1

0.4

0.4
0

(a) service provider, single-follower

p2

0.2

0.2

p2

0

(b) user, single-follower

Fig. 4. Utility of service provider and user versus varying cost profile.

R EFERENCES
25

User

20
10

Usw

15

10
1

Optimal Point
from Algorithm

5
0
1

1
0.8

0.5

p1

0

0

0.2

0.4

0.6

0.8

0.8
0.6

1

p1

p2

0.6
0.4

0.4
0.2

0.2
0

(a) service provider, multi-follower

p2

0

(b) user, multi-follower

Fig. 5. Utility of service provider and user versus varying cost profile.
1

4.5
AP1
AP2
4

0.6

Usw

Normalized Cost

0.8

0.4

3.5
0.2
0
5

10
15
20
Number of Followers

(a)

25

3
5

10
15
20
Number of Followers

25

(b)

Fig. 6. (a) cost and (b) social welfare at SE versus varying number of
followers in case of multi-follower.

capacity of each interfaces is shared with the large number
of users, the strategy of users is limited within the smaller
range. Therefore, service provider can dominate strategy of
users and increase cost easily. Therefore, as shown in Fig. 6.
(b), the social welfare of user side is decreased as the number
of followers increased. In addition, in the low rate allocation
region, users cannot change their strategy by reducing the
rate allocation.
VII. C ONCLUSION
We have analyzed the joint pricing and load distribution
problem of multi-homing in heterogeneous wireless access
networks. To do this, we firstly modelled the utility function
of user and service provider. Here, in the sense of user, a
utility function considers QoS and cost to pay. In addition,
from service provider’s point of view, a utility function
considers profit and energy efficiency. Considering both
point of view (users and service provider), the problem is
formulated as a Stackelberg game. From numerical results,
we present the relationship between price and allocated rate
as well as energy efficiency, which affects the game and

[1] H. Y. Hsieh and R. Sivakumar, “A Transport Layer Approach for Achieving Aggregate Bandwidth on Multi-Homed Mobile Hosts”, Wireless
Networks, vol. 11, pp. 99-114, Feb. 2005.
[2] A. Argyriou and V. Madisetti, “Bandwidth Aggregation with SCTP”,
Globecom 2003, Dec. 2003.
[3] N. Thompson, G. He and H. Luo, “Flow Scheduling for End-host
Multihoming, Infocom 2006, April 2006.
[4] K. Chebrolu and R. R. Rao, “Bandwidth Aggregation for Real-Time
Applications in Heterogeneous Wireless Networks”, IEEE Transactions
on Mobile Computing, vol. 5, no. 4, pp. 388-403, April 2006.
[5] J.C. Fernandez, T. Teleb, M. Guizani, and N. Kato, “Bandwidth
Aggregation-Aware Dynamic QoS Negotiation for Real-Time Video
Streaming in Next-Generation Wireless Networks”, IEEE Transaction on
Multimedia, vol. 11, no.6, pp. 1082-1093, October 2009.
[6] X. Zhu, P. Agrawal, J.P. Singh, T. Alpcan, and B. Girod, “Distributed Rate
Allocation Policies for Multihomed Video Streaming Over Heterogeneous
Access Networks”, IEEE Transactions on Multimedia, vol. 11, pp. 752764, June 2009.
[7] K. Son, H. Kim, Y. Yung and B. Krishnamachari, “Base Station Operation
and User Association Mechanisms for Energy-Delay Trade-offs in Green
Cellular Networks”, IEEE Journal on Selected Areas in Communications,
vol. 29, pp. 1525-1536, Sep. 2011.
[8] J. Lee, Y. M. Lim, K. Kim, S. G. Choi, and J. K. Choi, “Energy
Efficient Cooperative Multicast Scheme Based on Selective Relay”, IEEE
communications letters, vol.16, no. 3, pp.386-388, March 2012.
[9] M. Shreedhar and G. Varghese, Efficient Fair Queuing Using Deficit
Round Robin, IEEE/ACM Trans. Networking, vol. 4, no. 3, pp. 375-385,
June 1996.
[10] S. Prabhavat, H. Nishiyama, N. Ansari, and N. Kato, “Effective DelayControlled Load Distribution over Multipath Networks”, IEEE Transaction on Parallel and distributed systems 2011, vol. 22, no. 10, pp. 17301741, Oct 2011.
[11] J.H. Lee, Y.M. Lim, J.H. Kim, J.K. Choi and S.G. Choi, “EnergyEfficient Rate Allocation for Multi-homed Streaming Service Over Heterogeneous Access Networks”, IEEE GLOBECOM 2011, Dec 2011.
[12] S. Shakkottai, E. Altman, and A. Kumar, “Multihoming of Users to
Access Points in WLANs:A Population Game Perspective”, IEEE Journal
on Selected Areas in Communications, vol. 25, no. 6, pp. 1207-1215, Aug
2007.
[13] F. Meshkati, H. Vincent Poor, Stuart C. Schwartz, and Narayan B. Mandayam, “An Energy-Efficient Approach to Power Control and Receiver
Design in Wireless Data Networks”, IEEE Transaction on Communications, vol 53, no. 11, Nov 2005.
[14] X. Zhu, E. Setton, and B. Girod, “Congestion-distortion optimized video
transmission over ad hoc networks,EURASIP J. SignalProcess.: Image
Commun.s, vol. 20, no. 8, pp. 773783, Sep. 2005.
[15] C. E. Luna, L. P. Kondi, A. K. Katasaggelos, ”Maximizing User
Utility in Video Streaming Applications, IEEE Transaction on circuit
and systems for video technology, vol. 13, no. 2, pp. 141-148, Feb. 2003.
[16] D. P. Palomar and M. Chiang, “A Tutorial on Decomposition Methods
for Network Utility Maximization,IEEE Journal on Selected Areas in
Communications, vol. 24, pp. 1439-1451, August 2006.
[17] S. Boyd and L. Vandengerghe, Convex Optimization. Cambridge,U.K.:
Cambridge Univ. Press, 2004.
[18] Edwin K. P. Chong and Stanislaw H. ZAK, An Introduction to Optimization,Jon Wiley and Sons Press, 2008.

1677

Multimed Tools Appl (2013) 64:439–453
DOI 10.1007/s11042-012-0998-z

Practical service level agreement negotiation scheme
for multicast service in WiMAX
Joohyung Lee · Jong Min Lee · Seong Gon Choi ·
Jun Kyun Choi

Published online: 16 February 2012
© Springer Science+Business Media, LLC 2012

Abstract For multicast service in WiMAX, there are trade-offs between overall
channel efficiency and the number of users under the commitment of service level
agreements (SLAs). So, it is important to compromise between accommodating
many users under the commitment of SLA and channel efficiency. In order to give an
insight of multicast efficiency, we suggest a novel metric which is named as channel
efficiency (MCE) factor. In addition, we proposed the practical SLA negotiation
scheme based on proposed novel metric. Numerical results show that the proposed
practical scheme significantly outperforms the conventional multicast transmission
scheme.
Keywords Multicast service · OFDMA · WiMAX · SLA negotiation
1 Introduction
As the number of users who enjoy multimedia streaming increases, it is important
to allocate channel bandwidth efficiently in wireless networks. Multicast service is

J. Lee (B) · J. K. Choi
Department of Electrical Engineering, Korea Advanced Institute of
Science and Technology (KAIST), Deajeon, Korea
e-mail: joohyung08@kaist.ac.kr
J. K. Choi
e-mail: jkchoi59@kaist.edu
J. M. Lee
Data Transmission Technology Development Team, SK Telecom, Jung-gu, Seoul, Korea
e-mail: jminlee@sk.com
S. G. Choi
Department of Electrical Engineering, Chungbuk National
University (CBNU), Chungbuk, Korea
e-mail: sgchoi@chungbuk.ac.kr

440

Multimed Tools Appl (2013) 64:439–453

used as an efficient method to reduce bandwidth consumption by delivering the
same contents to multiple mobile nodes [12, 17]. However, the existing sub-channel
allocation scheme of the World Interoperability for Microwave Access (WiMAX)
is not efficient to support multicast service because multicast throughput becomes
saturated as users increase. For example, since the existing sub-channel allocation
scheme for multicast is based on the worst channels user to accommodate all users
in a certain channel, it makes resource consumption inefficient [1]. If there is one
bad channel user in a cell, the service provider has to allocate many sub-channels
to cover this user; thus, there are trade-offs between overall channel efficiency and
guaranteeing all users under the commitment of service level agreements (SLAs).
With efforts to solve the inefficient use of radio spectrums based on worst case
user, many researchers have proposed schemes especially in terms of throughput.
Gopala and Gamal suggest the policy based scheduling for multicast [9]. Although
these schemes can enhance the system throughput by selecting maximal MCS level,
it has low cell edge performance and causes high blocking probability. To solve the
fairness problem, Koh and Kim suggest the Proportional Fair (PF) scheduling for
multicast service [7]. Although, PF scheduling should enhance fairness than before,
it also couldnt handle to cell edge users who are in deep fading and it will be
a fatal problem if multicast is not provided to some static users. Ning et al. [15]
concentrate on guaranteeing service of users in cell edge by handling PF parameter.
Recently, to compromise between fairness and channel efficiency, one approach
to the problem is to use multiple layered coding such as Scalable Video Coding
[14]. By using SVC, Suh and Mo [16] proposed optimum resource allocation for
multicast services in multicarrier wireless communications. Although, it proposed the
optimum and heuristic algorithm with solving nonlinear integer programming, there
is lack of practical view for allocating resource based on base station condition. In
another method using SVC in cooperative communication, Kwon and Lee proposed
that copies of coded and modulated data can achieve cell edge user performance
by same MCS and synchronized transmission [10]. But, this scheme requires to
synchronization transmission. Finally, in order to maximize multicast efficiency,
opportunistic scheduling scheme for mixed multicast and unicast traffic in cellular
system has been proposed in case of time-based scheduling [1]. However, there is
high computational overhead for comparing multicast throughput with threshold
value in each time-slot.
In this paper, we consider the channel condition of users in a cell to measure
channel efficiency since the channel condition of users directly affects multicast
channel efficiency (MCE). In the general WiMAX orthogonal frequency-division
multiple access (OFDMA) system, channel condition of users is mapped according to
modulation and coding scheme (MCS) levels [6]. In addition, the number of users in a
multicast channel is an important factor of MCE. To give insight of multicast channel
efficiency, we proposed the novel metric as MCE factor with channel feedback.
Furthermore, we propose a Weighted Sub-channel Allocation Scheme (WSAS)
to maximize MCE as one of our practical SLA negotiation scheme. In addition,
by considering base station congestion condition, we proposed the opportunistic
scheduling algorithm in a practical manner. Our numerical results demonstrate that
the proposed schemes have significant advantages in terms of channel blocking
probability and throughput compared to the existing WiMAX scheme. Not only out-

Multimed Tools Appl (2013) 64:439–453

441

standing performance but also low complexity has advantage for easily establishing
real wireless communication system.
The remainder of this paper is organized as follows: we discuss our proposed
WSAS in Section 2. In addition, We provide another oportunistic scheudling scheme
in Section 3. In Section 4, we analysis proposed scheme numerically and evaluate
the performance of the proposed scheme in Section 5. Finally, we discuss our future
works and conclude the work in Sections 6 and 7, respectively.

2 System architecture
The overall system architecture for multicast service in WiMAX network is shown
in Fig. 1. The architecture consists of a multimedia server, a Base Station (BS), and
users. We assume that the BS delivers content in channel 1 from a server to three
cases of multicast groups with different user distributions. In Case 1, users reside in
the center of the cell. The BS can allocate just 2 sub-channels to serve every user by
using high modulation and a high coding rate. In Case 2, users reside in the middle of
the cell. Four sub-channels are required to deliver the same content. In Case 3, users
reside at the edges of the cell. Every user may suffer from errors and losses because
the channel condition is very poor due to path loss. When the BS delivers the same
content to every user, the BS should allocate 8 sub-channels by using low modulation
and a low coding rate.
In wireless communication service, there are operational rules for SLA commitment by a service provider. SLA commitment is determined by whether the BS
accommodates every users channel condition in multicast group k or not. In other

Fig. 1 System architecture for multicast service in WiMAX network

442

Multimed Tools Appl (2013) 64:439–453

Fig. 2 Relationship between multicast group, MCS level and sub-channel

words, SLA guaranteeing for every user means that the MCS level in multicast group
k is set by the worst channel user in multicast group k. If the service provider has to
guarantee SLA commitment, sub-channel allocation is executed by the worst channel
user in multicast group k. If the service provider does not have to guarantee SLA
commitment (i.e., no SLA guaranteeing), an efficient sub-channel allocation scheme
to enhance MCE is required. Therefore, we focus on a new sub-channel allocation
scheme considering no SLA guaranteeing for multicast service.

3 Weighted sub-channel allocation scheme using multicast channel efficiency factor
3.1 Basic terminologies for multicast service (Fig. 2)
Definition 1 Multicast group: it is served by same contents and same MCS level
Definition 2 MCS level: level for combination between modulation and coding rates
for OFDMA.
Definition 3 Sub-channel: basic unit of resource allocation in the IEEE 802.16
OFDMA system, which consists of a finite number of subcarriers.
According to WiMAX specification [6], nsub [·] can be easily calculated by following Table 1, which shows the general maximum data rates for MCS levels in
the WiMAX OFDMA system. If multicast group request sub-channel for 300kbps
contents in case of the MCS level 2, the number of sub-channels should be 8
(300 kbps/41.20 kbps = 7.28).
3.2 Multicast channel efficiency factor (gk )
We have developed a novel measurement factor for MCE. The MCE factor (gk )
defines the number of users who are guaranteed by SLA per sub-channel. Therefore,
gk is defined as
gk =

Mk
nsub [MCSk ] ,

(1)

Multimed Tools Appl (2013) 64:439–453
Table 1 System paramters in
OFDMA environment (to
support 300 kpbs input
channel)

443

MCS level Modulation Coding Maximum data nsub [·]
rates
rate (Mbps)
1
2
3
4
5
6
7
8
9
10

QPSK
QPSK
QPSK
QPSK
QPSK
16QAM
16QAM
64QAM
64QAM
64QAM

1/2, 6×
4×
2×
1×
3/4
1/2
3/4
2/3
3/4
5/6

0.75
1.13
2.26
4.51
6.77
9.02
13.54
18.05
20.30
22.56

11
8
4
2
2
1
1
1
1
1

Where k is multicast group index.
–
–
–

MCSk shows an MCS level in multicast group k.
Function nsub [MCS level] calculates the number of sub-channels in a certain MCS
level by using Table 1.
Mk is the number of users who are committed by SLA in multicast group k. If
we assume that there are one hundred users who have MCS level 3 in a certain
multicast group, gk should be 100/4 = 25.

3.3 Boundary condition of gk
For given Mk and N as a finite integer number, sample space of gk is equivalent to
gk ∈ {1/N, ...., Mk },
s.t.

nsub [·] ≤ c, c ∈ {1, 2, ...., N},

(2)
(3)

The lower bound (1/N) of gk expresses unicast transmission, and the upper bound
(Mk ) of gk expresses that one sub-channel covers Mk users.
3.4 Weighted sub-channel allocation scheme (WSAS)
To determine the MCS level of a multicast group using the MCE factor, we can
calculate the optimal MCS level as follows:
–
–

Find MCSk
In order to maximize (1) or (2)

where MCSk ∈ users MCS level in multicast group k In this procedure, we can extract
the group MCS level to maximize the MCE of a certain multicast group. Thus, our
proposed scheme aims to maximize MCE by weighting the sum of the number of
users and the number of sub-channels.

444

Multimed Tools Appl (2013) 64:439–453

4 Opportunistic scheduling scheme
In this section, we address the proposed opportunistic scheduling scheme. The
proposed transmission scheme is involved with two cases: sparse phase and dense
phase. The sparse phase means that the system has enough bandwidth to support
the worst channel users in multicast groups. On the other hands, the dense phase,
the system has not enough bandwidth to support the worst channel users because
many groups are located in a cell. Another approach for opportunistic scheduling
scheme is policy based scheduling by pre-determining threshold which is set by
service providers.
Select a transmission scheme
–
–

Dense mode is executed
Proposed sub-channel allocation scheme (WSAS) is executed.
Else if

–
–

Sparse mode is executed
MCSk = min{user’s MCS level in multicast group k}

Figure 3 expresses the flow chart for proposed opportunistic scheduling scheme
based on WSAS. If multicast-channel is requested for allocating sub-channel, base
station determined whether it is on congestion or not. In congestion condition,
service provider should allocate sub-channel more efficiently to enhance MCE based
on WSAS in case that service provider doesnt have to guarantee SLA commitment.
This approach is more practical than previous approach to give service providers the
guideline of efficient multicast operation.

Fig. 3 Flow chart for proposed scheme

Multimed Tools Appl (2013) 64:439–453

445

5 Numerical analysis
To evaluate the proposed scheme in terms of channel blocking probability and
throughput, we can model our proposal with Mx /M/C/C for the OFDM sub-channel
allocation system [2, 4, 18]. Our model basically assumes the following. With no SLA
guaranteeing, when a multicast channel request arrives, the BS can use available
channels as much as possible instead of rejecting the request. Figure 4 expresses the
state-transition-rate diagram of the model. Transition express session flow arrival
rates for multicast session. And this transition converged to state C. In other words,
requested sub-channel is bigger than available sub-channels, it is converged to state
C. So, it can be dealt with bandwidth degradation condition. The equilibrium (steadystate) equations written below are run to obtain the steady-state probabilities of the
model. Reforming (4), (5) and (6) yields
P(1) = P(0)λ/μ
(mμ +
P(m + 1) =

n

k=1

λk )P(m) −

(4)

min(m,n)


λk P(m − k)

k=1

(5)

(m + 1)μ

Where, 1 ≤ m ≤ C-n
Through detailed calculation of the equilibrium equation and steady-state probabilities, the channel blocking probability with no SLA guaranteeing is obtained by


n−1
n

1
λk
(6)
P(C − i)
Pno_SLA_guar =
λ i=0
k=i+1

,

where, C is the system capacity, λ is the multicast channel arrival rate, P(m) is the
state probability of m, and λk is the multicast channel arrival rate to request for k
sub-channels. Here, Pno_SLA_guar means the probability that the following two events
occur:
(1) No available sub-channels in BS: out of service
(2) Lack of sub-channels in BS: users in service experience bandwidth degradation.

Fig. 4 State transition rates diagram for proposed algorithm

446

Multimed Tools Appl (2013) 64:439–453

For the case without SLA guaranteeing for users, as there is no strict contract
between service provider and user, our proposed scheme can adaptively allocate subchannels in order to maximize channel efficiency.
Furthermore, if we decide to MCE level to maximize MCE, it should sacrifice
bad channel user who has lower channel condition than determined MCS level. In
proposed opportunistic scheduling scheme can reduce the rate of sacrificed user in
multicast group by control MCS level based on residual bandwidth at base station.

6 Performance evaluation
For the performance evaluation, we can calculate the required sub-channels and gk
of the WiMAX standard scheme and the proposed scheme as shown in Table 2.
This table demonstrates how the proposed scheme affects sub-channel allocation.
We consider three groups according to the distribution of users. In Groups 1
and 3, although the proposed scheme requests 1 sub-channel, the WiMAX standard
scheme requests more than 1 sub-channel to support the same multicast service. In
Group 2, the proposed scheme requests the same number of sub-channels as the
WiMAX standard scheme. The number of sub-channels requested directly affects
gk . Therefore, the obtained results clearly demonstrate that the proposed scheme
has higher or same gk and lower or same number of requested sub-channels than
the WiMAX standard scheme for all user distributions. For a detailed analysis,
we assume some parameters with specific values. The BS can serve 64 concurrent
sub-channels for multicast, and the service provider provides only the same length
contents to users as user created content (UCC) streaming with the duration of 180 s
[18]. Therefore, every user joins multicast streaming which is 300 kbps. Based on this
environment, the service rate is 0.0055 (1/180), and the arrival rate varies from 0.02/s
to 0.1/s.
In Fig. 5a, firstly, we present results for the channel blocking probability with
no SLA guaranteeing versus the traffic intensity. When the traffic intensity is 0.3,
the channel blocking probability of the proposed scheme is around 10−3 while the
channel blocking probability of the WiMAX standard scheme is higher than 10−1 .
Since the high channel blocking probability with no SLA guaranteeing means that
a high ratio of the multicast group cannot be served by the requested number of
sub-channels, we see that inefficient usage of sub-channels in the WiMAX standard
schemeresults in higher probability compared to the proposed scheme, particularly

Table 2 An example of required sub-channel and gk for WiMAX standard scheme and proposed
scheme
User
distribution

nsub [·]
of WiMAX

nsub [·] of
proposed
standard

gk in WiMAX
standard
scheme

gk in
proposed
scheme

Group 1
Group 2
Group 3

11
2
4

1
2
1

9.09
50
25

50
50
50

Where, Group 1: uniform distribution among 100 people
Group 2: one peak distribution of MCS level 5 among 100 people
Group 3: two peak distribution of MCS level 3 and MCS level 8 among 100 people

447

100
10

1
0.9

–1

0.8

10–2
Normalized Throughput

Channel blocking probability with no SLA guaranteeing

Multimed Tools Appl (2013) 64:439–453

10–3
10–4
10–5
10–6
10

–7

10

–8

0.1

0.7
0.6
0.5

Proposed scheme using qk
WiMAX standard

0.4
0.3

Proposed scheme using qk
WiMAX Standard

0.2

0.3

0.4 0.5 0.6 0.7
traffic intensity

0.8

0.9

0.2
0.1
0.1

0.2

0.3

0.4

0.5 0.6 0.7
traffic intensity

0.8

0.9

Fig. 5 Results with performance comparison for a channel blocking probability and b normalized
throughput with no SLA guaranteeing

at the lower traffic intensity. As users increase, channel blocking probabilities of
both sub-channel allocation schemes are saturated at around 1 due to the increasing
number of users at the edges of the cell.
In Fig. 5b, with the same parameters, we shows normalized throughput versus
traffic intensity. The throughput of the proposed scheme very significantly increases
according traffic intensity while the throughput of the WiMAX standard scheme
very slowly increases. When the traffic intensity is very high (=1), the normalized
throughput of the proposed scheme is around 1 (i.e., 22.56 Mbps). On the other hand,
the normalized throughput of the WiMAX standard scheme is 0.28 (i.e., 4.51 Mbps).
The proposed scheme supports multicast service at MCS level 10 on average, and
the WiMAX standard scheme supports multicast service at MCS level 3 on average
because 4.51 Mbps is the theoretically maximum throughput of WiMAX at MCS
level 3 (i.e., QPSK, 1/2 coding rates), and 22.56 Mbps is the theoretically maximum
throughput of WiMAX at MCS level 10 (i.e., 64QAM, 5/6 coding rates) [18]. In
addition, as the throughput of the WiMAX standard scheme is saturated at low traffic
intensity (i.e.,over 0.3), the WiMAX standard scheme cant accommodate additional
groups (multicast users) from this point. This result demonstrates that our proposed
scheme accommodates more groups than WiMAX standard scheme according to the
increase of traffic intensity.
Figure 6 depicts the channel blocking probability of WSAS based on MCE factor,
respectively in case that there is the requested SLA contraction. We applied our
WSAS to find the best sub-channel allocation that minimizes channel blocking probability as we assumed that there is 60, 80 and 100% SLA commitment contraction.
This result shows that high portion of SLA commitment contraction should makes
high channel blocking probability as it restrict to allocate sub-channel efficiently to
maximize MCE. In other words, if there is contraction between service provider
and subscriber, we cant freely allocate sub-channel based on maximizing channel
efficiency.
Figure 7 shows the performance comparison among the WSAS with or without
opportunistic scheduling algorithm and conventional scheme in terms of user blocking probability as arrival rate increase from 0.02 to 0.1 [18]. Here, user blocking

448

Multimed Tools Appl (2013) 64:439–453

Fig. 6 comparison of channel
blocking probability of
proposed MCE in case that
requested SLA commitment is
60, 80 and 100%

0

Channel blocking probability

10

10

10

10

1

2

3

100% SLA commitment
10

0.1

0.2

0.3

0.4

0.5
0.6
0.7
traffic intensity

0.8

0.9

probability (block ) means the probability that should contain following three events
(events from (1) to (2) are same as Pno_SLA_guar ):
(1) No avaliable sub-channels in BS: out of service
(2) Lack of sub-channels in BS:users in service experience bandwidth degradation.
(3) Sacrificing users due to pre-determined MCS level based on WSAS: user in
service experience bandwidth degradation since pre-determined MCS level
should request better condition than they experienced.

0

10

10
User Blocking probability

Fig. 7 comparison of user
blocking probability with
different scheme (with or
without opportunistic
scheduling and conventional
scheme)

10

10

10

10

1

2

3

4

WSAS with opportunistic scheduling scheme
conventional
WSAS without opportunistic scheduling scheme
0.03

0.04

0.05
0.06
0.07
arrival rate (second)

0.08

0.09

0.1

Multimed Tools Appl (2013) 64:439–453

449

In WSAS, although arrival rate is small, it can make blocking situation, because
determined MCS level cant guarantee lower channel condition user than determined
value. As arrival rate increase, WSAS algorithm is better than conventional scheme
because conventional scheme makes inefficient use of radio resource due to choose
worst channel user. In opportunistic scheduling scheme, when arrival rate is low
(unused sub-channels are enough to support requested sub-channel), it doesnt use
WSAS. After arrival rate is high, it adaptively uses WSAS algorithm to enhance
multicast sub-channel efficiently. Finally, overall user blocking probability patterns
show that opportunistic scheduling enhances user blocking rates by adaptively
choosing algorithm. It also affects cell edge performance since most of blocking user
might be cell edge user in large scale fading environment.
Next, we introduce the service providers reward/penalty cost model to expect
service providers revenue in case that we choose the opportunistic scheduling
scheme. We assumed that when the base station successfully serves the multicast
service without blocking, the service provider receives a reward value of R. On the
other hand, if a user is rejected, we assume that the service provider loses a value
of L immediately [3]. In prior art under the resource allocation policy, for example,
if the system on average services N client per unit time and reject M client per unit
time, then the system revenue is


N · R−
M·L
(7)
Finally, we define the total system revenue as follow:
revenue =

C


mμP(m) × R−λblock × L

(8)

m=1

In this case, we consider that wireless service provider provide IPTV service. Figure 8
shows the result obtained by service providers reward/penalty cost model. We
assumed that is the base station successfully serves the multicast service without

1300
Revenue of wireless service provider(dollors)

Fig. 8 comparison of revenue
with different scheme (with or
without opportunistic
scheduling and conventional
scheme)

1200
1100
1000
900
800
700
WSAS with opportunistic schedulingscheme
conventional
WSAS without opportunistic scheme

600
500
0.2

0.3

0.4

0.5
0.6
0.7
arrival rate (second)

0.8

0.9

1

450

Multimed Tools Appl (2013) 64:439–453

blocking, the system receives a reward value of R(=$10). On the other hand, if
a user is rejected, we assume that the service provider loses a value of L(=$5)
immediately. Figure 8 shows that as the arrival rate increase, the revenue of each
algorithm is slightly decreasing because of its blocking probability of services. In this
case, our proposed algorithm can offer higher revenue than others. And WSAS can’t
compensate within most of our observe point since WSAS contains static blocking
probability.

7 Future works
For future work, we will analyze several performance factors considering SLA
contracting and traffic priority. We will also perform a detailed analysis considering
a trade-off between the ratio of sacrificing users (i.e., users under the degradation of
QoS) in multicast groups and channel blocking for the proposed scheme.
Moverover, we will extend our proposed algorithm by considering energy
efficiency because the limited amount of energy in mobile terminal has been an
important issue [5, 8, 11, 13]. Especially, to date, because most multicast scheudling
algorithms have been focused on channel efficieny, there is need to research this
topic in terms of energy efficiency.

8 Conclusion
In this paper, we presented a novel metric to give an insight for Multicast Channel
Efficiency (MCE), which are named as MCE factor. In addition, by maximizing
proposed metric, we proposed a Weighted Sub-channel Allocation Scheme (WSAS).
Although it efficiently allocates resources (sub-channels) for multicast service to
enhance MCE, it sometimes requires sacrificing the bad channel condition users.
Therefore, in a practical manner, we proposed the opportunistic scheduling scheme
which adaptively uses WSAS with considering residual bandwidth at base station.
Thus, the service provider accommodates more multicast groups and users at the
same time than WiMAX standard scheme. Our numerical results have demonstrated
that the proposed scheme improves performance in terms of throughput and channel
blocking probability with or without SLA guaranteeing compared to the existing
scheme as well as user blocking probability and revenue for service provider.
Acknowledgements This work was supported by the IT R&D program of MKE/KEIT. [KI001822,
Research on Ubiquitous Mobility Management Methods for Higher Service Availability] and
[10039160, Research on Core Technologies for Self-Management of Energy Consumption in Wired
and Wireless Networks].

References
1. Baek SY, Hong Y-J (2009) Adaptive transmission scheme for mixed multicast and unicast traffic
in cellular systems. IEEE Trans Veh Technol 58(6):2899–2908
2. Chen J-C, Chen W-SE (2006) Call blocking probability and bandwidth utilization of OFDM
subcarrier allocation in next-generation wireless networks. IEEE Commun Lett 10(2):82–84

Multimed Tools Appl (2013) 64:439–453

451

3. Chen IR, His T-H (1998) Performance analysis of admission control algorithms based on reward
optimization for real-time multimedia servers. Perform Evaluation 33(2):89–112
4. Cooper R (1981) Introduction to queueing theory. North-Holland, New York
5. Huang C, Cheng R-H, Chen S-R, Li C-I (2010) Enhancing network availability by tolerance
control in multi-sink wireless sensor networks. Journal of Convergence (JoC), 1(1):15–22
6. IEEE 802.16e (2006) IEEE standard for local and metropolitan area network, part 16: air
interface for fixed broadband wireless access system.
7. Koh CH, Kim YY (2006) A proportional fair scheduling for multicast services in wireless cellular
networks. IEEE vehicular technology conference, pp 1–5
8. Kumar D, Aseri TC, Patel RB (2010) Multi-hop communication routing (MCR) protocol for
heterogeneous wireless sensor networks. International Journal of Information Technology,
Communications and Covergence (IJITCC) 1(2):130–145
9. Kumar Gopala P, EI Gamal H (2005) On the throughput-delay tradeoff in cellular multicast.
IEEE Wireless Networks, Communications and Mobile Computing (IWCMC) 2:4101–1406
10. Kwon H, Lee B (2009) Cooperative power allocation for broadcast/multicast services in cellular
OFDM systems. IEEE Trans Commun 57(10):3092–3102
11. Lee J, Lim YM, Kim JH, Choi JK, Choi SG (2011) Energy-efficient rate allocation for multihomed streaming service over heterogeneious access networks. IEEE GLOBECOM 2011
12. Lee JM, Park H-J, Choi SG, Choi JK (2009) Adaptive hybrid transmission mechanism for ondemand mobile IPTV over WiMAX. IEEE Trans Broadcast 55(2):468–477
13. Liang W-Y, Lai P-T, Chiou CW (2010) An energy conservation DVFS algorithm for the android
operating system. Journal of Convergence (JoC) 1(1):93–100
14. McCanne S, Vetterli M, Jacobsen V (1997) Low-complexity video coding for receiver-driven
layered multicast. IEEE J Sel Areas Commun 15(6):983–1001
15. Ning X, Guilaume V, Wen Z, Yongquan Q (2008) A dynamic PF scheduler to improve the cell
edge performance. IEEE vehicular technology conference, pp 1–5
16. Suh C, Mo J (2008) Resource allocation for multicast services in multicarrier wireless communications. IEEE Trans Wirel Commun 7(1):27–31
17. Zahid Halim A, Baig R, Mujtaba H (2010) Measuring entertainment and automatic generation
of entertaining games. International Journal of Information Technology, Communications and
Covergence (IJITCC), 1(2):130–145
18. Zhang Y, Xiao Y, Chen H-H (2008) Queueing analysis for OFDM subcarrier allocation in
broadband wireless multiservice networks. IEEE Trans Wirel Commun 7(10):3951–3961

Joohyung Lee received M.S. from Korea Advanced Institute of Science and Technology (KAIST)
in 2010 and currently, he is a Doctoral program student in KAIST. Since 2010, he has contributed
some articles into ITU-T SG13 Q9 and Q22. His main research interests include heterogeneous
wireless access network, mobility management, multiple streaming, Quality of Experience (QoE)
and multiconnection as well as resource allocation for green-network.

452

Multimed Tools Appl (2013) 64:439–453

Jong Min Lee received M.S. and Ph.D from Korea Advanced Institute of Science and Technology
(KAIST) in 2010. Since 2007, he has been working as an editor of ITU-T SG13 Q3, Q9 and Q22. In
2010, he joined the SK Telecom. His main research interests include wireless mobile communications,
multicast, mobility issues, next generation network and infrastructure deployment as well as network
management.

Seong Gon Choi received M.S. and Ph.D. from Korea Advanced Institute of Science and Technology
(KAIST) in 2004. In August 2004 he joined the Chungbuk National University (CBNU), Chungbuk,
Korea as a professor. Since 2002, he has been working in ITU-T SG13. His main research interests
include broadcast networks, mobility issues, next generation network and infrastructure deployment
as well as network management problems.

Multimed Tools Appl (2013) 64:439–453

453

Jun Kyun Choi received M.S. (Eng.) and Ph.D. degrees in 1985 and 1988, respectively, in electronics
engineering from Korea Advanced Institute of Science and Technology (KAIST). From June 1986
to December 1997, he was with the Electronics and Telecommunication Research Institute (ETRI).
In January 1998 he joined the Information and Communications University (presently, KAIST),
Korea as a professor. His research interests are concerned with broadband network architecture
and technologies with particular emphasis on performance and protocol problems. He was an active
member of ITU-T Study Group 13 as a Rapporteur or Editor from January 1993 on the ATM, MPLS,
and NGN issues. He has also submitted more than 30 drafts in the IETF in the last few years.

Under consideration for publication in Theory and Practice of Logic Programming

1

arXiv:1210.5222v1 [cs.AI] 18 Oct 2012

Module Theorem for
The General Theory of Stable Models
Joseph Babb and Joohyung Lee
School of Computing, Informatics, and Decision Systems Engineering
Arizona State University, Tempe, AZ, USA
(e-mail: {Joseph.Babb, joolee}@asu.edu)
submitted ; revised ; accepted

Note: To appear in Theory and Practice of Logic Programming (TPLP)
Abstract
The module theorem by Janhunen et al. demonstrates how to provide a modular structure
in answer set programming, where each module has a well-defined input/output interface
which can be used to establish the compositionality of answer sets. The theorem is useful
in the analysis of answer set programs, and is a basis of incremental grounding and reactive answer set programming. We extend the module theorem to the general theory of
stable models by Ferraris et al. The generalization applies to non-ground logic programs
allowing useful constructs in answer set programming, such as choice rules, the count aggregate, and nested expressions. Our extension is based on relating the module theorem
to the symmetric splitting theorem by Ferraris et al. Based on this result, we reformulate
and extend the theory of incremental answer set computation to a more general class of
programs.
KEYWORDS: answer set programming, module theorem, splitting theorem

1 Introduction
The module theorem (Oikarinen and Janhunen 2008; Janhunen et al. 2009) demonstrates how to provide a modular structure for logic programs under the stable
model semantics, where each module has a well-defined input/output interface
which can be used to establish the compositionality of answer sets of different
modules. The theorem was shown to be useful in the analysis of answer set programs and was used as a basis of incremental grounding (Gebser et al. 2008) and
reactive answer set programming (Gebser et al. 2011), resulting in systems iclingo
and oclingo.
The module theorem was stated for normal logic programs and smodels programs in (Oikarinen and Janhunen 2008) and for disjunctive logic programs in (Janhunen et al. 2009),
but both papers considered ground programs only. In this paper we extend the
module theorem to non-ground programs, or more generally, to first-order formulas under the stable model semantics proposed by Ferraris et al. (2011). We derive

2

Joseph Babb and Joohyung Lee

the generalization by relating the module theorem to the symmetric splitting theorem by Ferraris et al. (2009). This is expected in some sense as the symmetric
splitting theorem looks close to the module theorem and is already applicable to
first-order formulas under the stable model semantics (Ferraris et al. 2011). Since
non-ground logic programs can be understood as a special class of first-order formulas under the stable model semantics, the theorem can be applied to split these
programs. In addition, as the semantics of choice rules and the count aggregate in
answer set programming is understood as shorthand for some first-order formulas
(Lee et al. 2008), the splitting theorem can also be applied to non-ground programs
containing such constructs.
The precise relationship between the module theorem and the splitting theorem
has not been established, partly because there is some technical gap that needs
to be closed. While the splitting theorem is applicable to more general classes of
programs in most cases, there are some cases where the module theorem allows us
to split, but the splitting theorem does not.
In order to handle this issue, we first extend the splitting theorem to allow this
kind of generality. We then add modular structures to the splitting theorem, and
provide a mechanism of composing partial interpretations for each module. This
new theorem serves as the module theorem for the general theory of stable models.
The paper is organized as follows. In the next section, we review the stable
model semantics from (Ferraris et al. 2011), the splitting theorem, and the module
theorem. In Section 3 we provide a generalization of the splitting theorem, which
closes the gap between the module theorem and the splitting theorem. In Section 4
we present the module theorem for the general theory of stable models, which
extends both the previous splitting theorem and the previous module theorem.
We give an example of the generalized module theorem in Section 5 and show
how it serves as a foundation for extending the theory of incremental answer set
computation in Section 6.

2 Preliminaries
2.1 Review: General Theory of Stable Models
This review follows the definition by Ferraris et al. (2011). There, stable models
are defined in terms of the SM operator, which is similar to the circumscription
operator CIRC (Lifschitz 1994).
Let p be a list of distinct predicate constants p1 , . . . , pn , and let u be a list of
distinct predicate variables u1 , . . . , un . By u ≤ p we denote the conjunction of the
formulas ∀x(ui (x) → pi (x)) for all i = 1, . . . , n, where x is a list of distinct object
variables whose length is the same as the arity of pi . Expression u < p stands for
(u ≤ p) ∧ ¬(p ≤ u). For instance, if p and q are unary predicate constants then
(u, v) < (p, q) is


∀x(u(x) → p(x)) ∧ ∀x(v(x) → q(x)) ∧ ¬ ∀x(p(x) → u(x)) ∧ ∀x(q(x) → v(x)) .

Module Theorem for the General Theory of Stable Models

3

For any first-order formula F , SM[F ; p] is defined as
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where F ∗ (u) is defined recursively as follows:

1

• pi (t)∗ = ui (t) for any list t of terms;
• F ∗ = F for any atomic formula F (including ⊥ and equality) that does not
contain members of p;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;
• (∃xF )∗ = ∃xF ∗ .
When F is a sentence, the models of SM[F ; p] are called the p-stable models
of F . Intuitively, they are the models of F that are “stable” on p. We will often
simply write SM[F ] in place of SM[F ; p] when p is the list of all predicate constants occurring in F , and often identify p with the corresponding set if there is no
confusion.
By an answer set of F that contains at least one object constant we understand an
Herbrand interpretation of σ(F ) that satisfies SM[F ], where σ(F ) is the signature
consisting of the object, function and predicate constants occurring in F .
The answer sets of a logic program Π are defined as the answer sets of the FOLrepresentation of Π (i.e., the conjunction of the universal closures of implications
corresponding to the rules). For example, the FOL-representation F of the program
p(a)
q(b)
r(x) ← p(x), ınot q(x)
is
p(a) ∧ q(b) ∧ ∀x(p(x) ∧ ¬q(x) → r(x))

(1)

and SM[F ] is
p(a) ∧ q(b) ∧ ∀x(p(x) ∧ ¬q(x) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x((u(x) ∧ (¬v(x) ∧ ¬q(x)) → w(x)) ∧ (p(x) ∧ ¬q(x) → r(x)))),
which is equivalent to the first-order sentence
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b) ∧ ∀x(r(x) ↔ (p(x) ∧ ¬q(x)))

(2)

(Ferraris et al. 2007, Example 3). The stable models of F are any first-order models
of (2). The only answer set of F is the Herbrand model {p(a), q(b), r(a)}.
Ferraris et al. (2011) show that this definition of an answer set, when applied to
the syntax of logic programs, is equivalent to the traditional definition of an answer
set that is based on grounding and fixpoints (Gelfond and Lifschitz 1988).
1

We understand ¬F as shorthand for F → ⊥.

4

Joseph Babb and Joohyung Lee
2.2 Review: Symmetric Splitting Theorem

We say that an occurrence of a predicate constant, or any other subexpression, in
a formula F is positive if the number of implications containing that occurrence in
the antecedent is even (recall that we treat ¬G as shorthand for G → ⊥). We say
that the occurrence is strictly positive if the number of implications in F containing
that occurrence in the antecedent is 0. For example, in (1), both occurrences of q
are positive, but only the first one is strictly positive. A rule of F is an implication
that occurs strictly positively in F .
A formula F is called negative on a list p of predicate constants if members of p
have no strictly positive occurrences in F . For example, formula (1) is negative on
{s}, but is not negative on {p, q}. A formula of the form ¬F (shorthand for F → ⊥)
is negative on any list of predicate constants.
The following definition of a dependency graph is from (Lee and Palla 2012),
which is similar to the one from (Ferraris et al. 2009), but may contain less edges.
Definition 1 (Predicate Dependency Graph)
The predicate dependency graph of a first-order formula F relative to p, denoted
by DG[F ; p], is the directed graph that
• has all members of p as its vertices, and
• has an edge from p to q if, for some rule G → H of F ,
— p has a strictly positive occurrence in H, and
— q has a positive occurrence in G that does not belong to any subformula
of G that is negative on p.
For example, DG[(1); p, q, r] has the vertices p, q, and r, and a single edge from r
to p.
Theorem 1 (Splitting Theorem, (Ferraris et al. 2009))
Let F , G be first-order sentences, and let p, q be finite disjoint lists of distinct
predicate constants. If
(a) each strongly connected component of the predicate dependency graph of
F ∧ G relative to p, q is a subset of p or a subset of q,
(b) F is negative on q, and
(c) G is negative on p
then
SM[F ∧ G; pq] ↔ SM[F ; p] ∧ SM[G; q]
is logically valid.
Theorem 1 is slightly more generally applicable than the version of the splitting theorem from (Ferraris et al. 2009) as it refers to the refined definition of a
dependency graph above instead of the one considered in (Ferraris et al. 2009).
Example 1
Theorem 1 tells us that SM[(1)] is equivalent to
SM[p(a) ∧ q(b); p, q] ∧ SM[∀x(p(x) ∧ ¬q(x) → r(x)); r].

Module Theorem for the General Theory of Stable Models

5

2.3 Review: DLP-Modules and Module Theorem
Janhunen et al. (2009) considered rules of the form
a1 ; . . . ; an ← b1 , . . . , bm , ınot c1 , . . . , ınot ck

(3)

where n, m, k ≥ 0 and a1 , . . . , an , b1 , . . . bm , c1 , . . . , ck are propositional atoms. They
define a DLP-module as a quadruple (Π, I, Ø, H), where Π is a finite propositional
disjunctive logic program consisting of rules of the form (3), and I, Ø, and H are
finite sets of propositional atoms denoting the input, output, and hidden atoms,
respectively, such that (i) the sets of input, output, and hidden atoms are disjoint;
(ii) every atom occurring in Π is either an input, output, or hidden atom; (iii)
every rule in Π with a nonempty head contains at least one output or hidden atom.
A module’s hidden atoms can be viewed as a special case of its output atoms
which occur in no other modules. For simplicity, we consider only DLP-modules
with no hidden atoms (H = ∅), which we denote by a triple (Π, I, Ø).
Definition 2 (Module Answer Set, (Janhunen et al. 2009))
We say that a set X of atoms is a (module) answer set of a DLP-module (Π, I, Ø)
if X is an answer set of Π ∪ {p | p ∈ (I ∩ X)}.
The role of input atoms can be simulated using choice rules. A choice rule {p} ←
ıBody is understood as shorthand for p; ınot p ← ıBody (Lee et al. 2008). The
following lemma shows how module answer sets can be alternatively characterized
in terms of choice rules.
Lemma 1
X is a module answer set of (Π, I, Ø) iff X is an answer set of Π ∪ {{p} ← | p ∈ I}.
Definition 3 (Dependency Graph of a DLP-Module)
The dependency graph of a DLP-module Π = (Π, I, Ø), denoted by DG[Π; Ø], is
the directed graph that
• has all members of Ø as its vertices, and
• has edges from each ai (1 ≤ i ≤ n) to each bj (1 ≤ j ≤ m) for each rule (3)
in Π.
It is clear that this definition is a special case of Definition 1.
Definition 4 (Joinability of DLP-modules)
Two DLP-modules Π1 = (Π1 , I1 , Ø1 ) and Π2 = (Π2 , I2 , Ø2 ) are called joinable if
• Ø1 ∩ Ø2 = ∅,
• each strongly connected component of DG[Π1 ∪ Π2 ; Ø1 Ø2 ] is either a subset
of Ø1 or a subset of Ø2 ,
• each rule in Π1 (Π2 , respectively) whose head is not disjoint with Ø2 (Ø1 ,
respectively) occurs in Π2 (Π1 , respectively).

6

Joseph Babb and Joohyung Lee

Definition 5 (Join of DLP-modules)
For any modules Π1 = (Π1 , I1 , Ø1 ) and Π2 = (Π2 , I2 , Ø2 ) that are joinable, the
join of Π1 and Π2 , denoted by Π1 ⊔ Π2 , is defined to be the DLP-module
(Π1 ∪ Π2 , (I1 ∪ I2 ) \ (Ø1 ∪ Ø2 ), Ø1 ∪ Ø2 ) .
Informally, the join of two DLP-modules corresponds to the union of their programs, and defines all atoms that are defined by either module.
Given sets of atoms X1 , X2 , and A, we say that X1 and X2 are A-compatible
if X1 ∩ A = X2 ∩ A. As demonstrated by Janhunen et al. (2009), given a program
composed of a series of joinable DLP-modules, it is possible to consider each DLPmodule contained in a program separately, evaluate them, and compose the resulting compatible answer sets in order to obtain the answer sets of the complete
program. This notion is presented in Theorem 2, which is a reformulation of the
main theorem (Theorem 5.7) from (Janhunen et al. 2009).
Theorem 2 (Module Theorem for DLPs)
Let Π1 = (Π1 , I1 , Ø1 ) and Π2 = (Π2 , I2 , Ø2 ) be DLP-modules that are joinable,
and let X1 and X2 be ((I1 ∪ Ø1 ) ∩ (I2 ∪ Ø2 ))-compatible sets of atoms. The set
X1 ∪ X2 is a module answer set of Π1 ⊔ Π2 iff X1 is a module answer set of Π1
and X2 is a module answer set of Π2 .

3 A Generalization of the Splitting Theorem by Ferraris et al.
The module theorem (Theorem 2) and the splitting theorem (Theorem 1) resemble
each other. When we restrict attention to propositional logic program F , the intensional predicates p in SM[F ; p] correspond to output atoms in the corresponding
module. Though not explicit in the notation SM[F ; p], the predicates that are not
in p behave like input atoms in the corresponding module. Also, the joinability
condition in Definition 4 appears similar to the splitting condition in Theorem 1,
but with one exception: the last clause in the definition of joinability (Definition 4)
does not have a counterpart in the splitting theorem. The module theorem allows
us to join two DLP-modules Π1 = (Π1 , I1 , Ø1 ) and Π2 = (Π2 , I2 , Ø2 ) even when
Π1 has a rule whose head contains an output atom in Ø2 as long as that rule is also
in Π2 .
Indeed, this difference yields the splitting theorem less generally applicable than
the module theorem in some cases. For example, the module theorem (Theorem 2)
allows us to join
Π1 = ({p ∨ q ← r.

s ← .}, {q, r}, {p, s}) and

Π2 = ({p ∨ q ← r.

t ← .}, {p, r}, {q, t})

(4)

into
Π = ({p ∨ q ← r. s ← . t ← .}, {r}, {p, q, s, t}).
On the other hand, the splitting theorem (Theorem 1), as presented in Section 2.2,

Module Theorem for the General Theory of Stable Models

7

is not as general in this regard. It does not allow us to justify that
SM[(r → p ∨ q) ∧ s; p, s] ∧ SM[(r → p ∨ q) ∧ t; q, t]

(5)

SM[(r → p ∨ q) ∧ s ∧ t; p, q, s, t] .

(6)

is equivalent to
because, for instance, r → p ∨ q in the first conjunctive term of (5) is not negative
on {q, t}.
In order to close the gap, we next extend the splitting theorem to allow a partial
split, which allows an overlapping sentence, such as r → p ∨ q in the above example,
in both component formulas.
Theorem 3 (Extension of the Splitting Theorem)
Let F , G, H be first-order sentences, and let p, q be finite lists of distinct predicate
constants. If
(a) each strongly connected component of DG[F ∧ G ∧ H; pq] is a subset of p or
a subset of q,
(b) F is negative on q, and
(c) G is negative on p
then
SM[F ∧ G ∧ H; pq] ↔ SM[F ∧ H; p] ∧ SM[G ∧ H; q]
is logically valid.
It is clear that Theorem 1 is a special case of Theorem 3 (take H to be ⊤). Unlike
in (Ferraris et al. 2009) we do not require p and q to be disjoint from each other.
Getting back to the example above, according to the extended splitting theorem,
(6) is equivalent to (5) (Take H to be r → p ∨ q).
4 Module Theorem for General Theory of Stable Models
4.1 Statement of the Theorem
In this section, we present a new formulation of the module theorem that is applicable to first-order formulas under the stable model semantics.
As a step towards this end, we first define the notion of a partial interpretation.
Given a signature σ and its subset c, by a c-partial interpretation of σ, we mean an
interpretation of σ restricted to c. Clearly, a σ-partial interpretation of σ is simply
an interpretation of σ. By an Herbrand c-partial interpretation of σ, we mean an
Herbrand interpretation of σ restricted to c.
We say that a c1 -partial interpretation I1 and a c2 -partial interpretation I2 of
the same signature σ are compatible if their universes are the same, and cI1 = cI2
for every common constant c in c1 ∩ c2 . For such compatible partial interpretations
I1 and I2 , we define the union of I1 and I2 , denoted by I1 ∪ I2 , to be the (c1 ∪ c2 )partial interpretation of σ such that (i) |I1 ∪ I2 | = |I1 | = |I2 | 2 , (ii) cI1 ∪I2 = cI1 for
every constant c in c1 , and (iii) cI1 ∪I2 = cI2 for every constant c in c2 .
2

|I| denotes the universe of the interpretation I.

8

Joseph Babb and Joohyung Lee

Next we introduce a first-order analog to DLP-modules, which we refer to as
first-order modules, and define a method of composing multiple such constructs
similar to the join operation for DLP-modules. By ıpr(F ) we denote the set of all
predicate constants occurring in F . A (first-order) module F of a signature σ is a
triple (F, I, Ø), where F is a first-order sentence of σ, and I and Ø are disjoint lists
of distinct predicate constants of σ such that ıpr(F ) ⊆ (I ∪ Ø). Intuitively, I and
Ø denote, respectively, the sets of non-intensional (input) and intensional (output)
predicates considered by F .
Definition 6 (Module Stable Model )
We say that an interpretation I is a (module) stable model of a module F = (F, I, Ø)
if I |= SM[F ; Ø]. We understand SM[F] as shorthand for SM[F ; Ø].
Definition 7 (Joinability of First-Order Modules)
Two first-order modules F1 = (F1 ∧ H, I1 , Ø1 ) and F2 = (F2 ∧ H, I2 , Ø2 ) are
called joinable if
• Ø1 ∩ Ø2 = ∅,
• each strongly connected component of DG[F1 ∧ F2 ∧ H; Ø1 ∪ Ø2 ] is either a
subset of Ø1 or a subset of Ø2 ,
• F1 is negative on Ø2 , and
• F2 is negative on Ø1 .
Definition 8 (Join of First-Order modules)
For any modules F1 = (F1 ∧ H, I1 , Ø1 ) and F2 = (F2 ∧ H, I2 , Ø2 ) that are
joinable, the join of F1 and F2 , denoted by F1 ⊔ F2 , is defined to be the first-order
module
(F1 ∧ F2 ∧ H, (I1 ∪ I2 ) \ (Ø1 ∪ Ø2 ), Ø1 ∪ Ø2 ) .
It is not difficult to check that this definition is a proper generalization of Definition 4.
As with DLP-modules, the join operation for first-order modules is both commutative and associative.
Proposition 1 (Commutativity and Associativity of Join)
For any first-order modules F1 , F2 , and F3 , the following properties hold:
•
•
•
•

F1 ⊔ F2 is defined iff F2 ⊔ F1 is defined.
SM[F1 ⊔ F2 ] is equivalent to SM[F2 ⊔ F1 ].
(F1 ⊔ F2 ) ⊔ F3 is defined iff F1 ⊔ (F2 ⊔ F3 ) is defined.
SM[(F1 ⊔ F2 ) ⊔ F3 ] is equivalent to SM[F1 ⊔ (F2 ⊔ F3 )].

The following theorem is an extension of Theorem 2 to the general theory of
stable models. Given a first-order formula F , by c(F ) we denote the set of all
object, function and predicate constants occurring in F .

Module Theorem for the General Theory of Stable Models



a❄

?c
❄❄
⑧⑧
❄❄
⑧
❄ 	 ⑧⑧⑧
b



9

5e
⑧ _❄❄❄
❄❄
⑧⑧
⑧
❄
⑧
⑧
/f
dj

Fig. 1. A Simple Graph

Theorem 4 (Module Theorem for General Theory of Stable Models)
Let F1 = (F1 , I1 , Ø1 ) and F2 = (F2 , I2 , Ø2 ) be first-order modules of a signature σ
that are joinable, and, for i = 1, 2, let ci be a subset of σ that contains c(Fi ) ∪ Øi ,
and let Ii be a ci -partial interpretation of σ. If I1 and I2 are compatible with each
other, then
I1 ∪ I2 |= SM[F1 ⊔ F2 ]

iff

I1 |= SM[F1 ] and I2 |= SM[F2 ] .

It is clear that when σ = c1 = c2 , Theorem 4 reduces to Theorem 3.
Also, it is not difficult to check that Theorem 4 reduces to Theorem 2 when F1
and F2 represent DLP-modules, c1 is I1 ∪ Ø1 , and c2 is I2 ∪ Ø2 .

5 Example: Analyzing RASPL-1 Programs Using Module Theorem
As an example of Theorem 4, consider the problem of locating non-singleton cliques
within a graph, such as the one shown in Figure 1, that are reachable from a prespecified node. This problem can be divided into three essential parts: (i) fixing the
graph, (ii) determining the reachable subgraph, and (iii) locating cliques within
that subgraph.
We can describe the graph shown in Figure 1 in the language of RASPL-1
(Lee et al. 2008), which is essentially a fragment of the general theory of stable
models in logic programming syntax. We assume that σ is an underling signature.
The program below lists the vertices and the edges using predicates vertex and
edge, and assigns the starting vertex using at predicate.
vertex(a). vertex(b). vertex(c). vertex(d). vertex(e). vertex(f ).
edge(a, a). edge(a, b). edge(b, c). edge(c, b). edge(c, c). edge(d, e).
edge(d, f ). edge(e, d). edge(e, f ). edge(f, d). edge(f, e). at(a).
(7)
The first-order module FG is (FG , ∅, {vertex, edge, at}), where FG is the FOLrepresentation of program (7), which is the conjunction of all the atoms. Let IG be
the following Herbrand c(FG )-partial interpretation of σ that satisfies SM[FG ].

10

Joseph Babb and Joohyung Lee

vertexIG = {a, b, c, d, e, f},
edgeIG = {(a, a), (a, b), (b, c), (c, b),
(c, c), (d, e), (d, f), (e, d), (e, f), (f, d), (f, e)}, and
IG

at

= {a}.

The following program describes the reachable vertices by the predicate reachable,
which is defined using edge and at.
reachable(X) ← at(X).
reachable(Y ) ← reachable(X), edge(X, Y ).

(8)

The first-order module FR is (FR , {edge, at}, {reachable}), where FR is the
FOL-representation of program (8). Let IR be the following Herbrand c(FR )-partial
interpretation of σ that satisfies SM[FG ], which is compatible with IG .
edgeIR = {(a, a), (a, b), (b, c), (c, b),
(c, c), (d, e), (d, f), (e, d), (e, f), (f, d), (f, e)},
at

IR

= {a}, and

IR

= {a, b, c}.

reachable

Finally, the following program describes non-singleton cliques reachable from
vertex a by in clique, which is defined using edge and reachable:
{in clique(X)} ← reachable(X)
← in clique(X), in clique(Y ), ınot edge(X, Y ), X 6= Y
← ınot 2{X : in clique(X)}.

(9)

In RASPL-1, expression b{x : F (x)}, where b is a positive integer, x is a list
of object variables, and F (x) is a conjunction of literals, stands for the first-order
formula


^
^
F (xi ) ∧
¬(xi = xj ) ,
∃x1 . . . xb 
1≤i≤b

1

1≤i<j≤b

b

where x , . . . , x are lists of new object variables of the same length as x. For any
lists of variables x = (x1 , . . . , xn ) and y = (y1 , . . . , yn ) of the same length, x = y
stands for x1 = y1 ∧ · · · ∧ xn = yn .
The first-order module FC is (FC , {reachable, edge}, {in clique}), where FC
is the following FOL-representation of RASPL-1 program (9):
∀X(reachable(X) → (in clique(X) ∨ ¬in clique(X)))
∧ ∀XY (in clique(X) ∧ in clique(Y ) ∧ ¬edge(X, Y ) ∧ X 6= Y → ⊥)
∧ (¬∃XY (in clique(X) ∧ in clique(Y ) ∧ X 6= Y ) → ⊥) .
Let IC be the following Herbrand c(FC )-partial interpretation of σ that satisfies

Module Theorem for the General Theory of Stable Models

11

SM[FC ], which is compatible with IG and IR .
edgeIC = {(a, a), (a, b), (b, c), (c, b),
(c, c), (d, e), (d, f), (e, d), (e, f), (f, d), (f, e)},
IC

= {a, b, c}, and

IC

= {b, c}.

reachable
in clique

Clearly, FG , FR , and FC are joinable. In accordance with Theorem 4, the union
of the partial interpretations IG ∪IR ∪IC is a partial interpretation of σ that satisfies
SM[FG ⊔ FR ⊔ FC ].
6 Modules That Can Be Incrementally Assembled
6.1 Review: Incremental Modularity by Gebser et al.
In this section, we present a reformulation of the theory behind the system iclingo,
which was developed to allow for incremental grounding and solving of answer set
programs. We follow the enhancement given in (Gebser et al. 2011) with a slight
deviation. Most notably, we do not restrict attention to nondisjunctive logic programs, but limit attention to offline programs for simplicity.
Given a disjunctive program Π of a signature σ, by Groundσ (Π) we denote the
ground program obtained from Π by replacing object variables with ground terms
in the Herbrand Universe of σ. If Π is ground, then the projection of Π onto a set
X of ground atoms, denoted by Π|X , is defined to be the program obtained from
Π by removing all rules (3) in Π that contain some bi not in X, and then removing
all occurrences of ınot cj such that cj is not in X from the remaining rules. By
ıhead(Π) we denote the set of all atoms that occur in the head of a rule in Π.
Definition 9 (DLP-Module Instantiation)
Given a disjunctive program Π, and a set of ground atoms I, Gebser et al. (2011)
define the DLP-module instantiation of Π w.r.t. I, denoted by ıDM (Π, I), to be the

DLP-module (Groundσ (Π)|I∪O , I, O), where O is ıhead Groundσ (Π)|I∪head(Groundσ (Π)) .
For example, Figure 2 shows a simple program and its DLP-module instantiation
w.r.t. {l, t}.
An incrementally parameterized program Π[t] is a program which may contain
atoms of the form af (t) (x), called incrementally parameterized atoms, where t is an
incremental step counter, and f (t) is some arithmetic function involving t. Given
such a program Π[t], its incremental instantiation at some nonnegative integer i,
which we denote by Π[i], is defined to be the program obtained by replacing all
occurrences of atoms af (t) (x) with an atom av (x), where v is the result of evaluating

n←t



p ← q, t
q ← r, ınot s 


r←m

7→
I={l,t}




n←t
, {l, t}, {n, p, q}
p ← q, t

Fig. 2. DLP-module instantiation of a simple program

12

Joseph Babb and Joohyung Lee

f (i). For example, let Π = {pt+1 (x) ← pt (x), ınot q(x)}. The program Π[2] is then
{p3 (x) ← p2 (x), ınot q(x)}.
Gebser et al. (2011) define an incremental logic program to be a triple hB, P [t], Q[t]i,
where B is a disjunctive logic program, and P [t], Q[t] are incrementally parameterized disjunctive logic programs. Informally, B is the base program component,
which describes static knowledge; P [t] is the cumulative program component, which
contains information regarding every step t that should be accumulated during execution; Q[t] is the volatile query program component, containing constraints or
information regarding the final step.
We assume a partial order ≺ on
{Groundσ (B),Groundσ (P [1]), Groundσ (P [2]), . . . ,
Groundσ (Q[1]), Groundσ (Q[2]), . . . }

(10)

such that
• Groundσ (B) ≺ Groundσ (P [1]) ≺ Groundσ (P [2]) ≺ . . . ;
• Groundσ (P [i]) ≺ Groundσ (Q[i]) for i ≥ 1.
Given a DLP-module P = (Π, I, Ø), by ıOut(P) we denote Ø.
Definition 10 (Modular and Acyclic Logic Programs)
An incremental logic program hB, P [t], Q[t]i is modular if the following DLP-modules
are defined for every k ≥ 0:
P0 = ıDM (B, ∅),
Pi = Pi−1 ⊔ ıDM (P [i], ıOut(Pi−1 )),

(1 ≤ i ≤ k)

Rk = Pk ⊔ ıDM (Q[k], ıOut(Pk )),
and is acyclic if, for each pair of programs Π, Π′ in (10) such that Π ≺ Π′ , we have
that Π contains no head atoms of Π′ . 3
Gebser et al. (2011) demonstrated that given a modular and acyclic incremental
logic program hB, P [t], Q[t]i and some nonnegative integer k, we are able to evaluate
each component DLP-module individually, and compose the results in order to
obtain the answer sets of the complete module Rk . They define the k-expansion Rk
of the incremental logic program as
B ∪ P [1] ∪ · · · ∪ P [k] ∪ Q[k] .
Proposition 2
(Gebser et al. 2011, Proposition 2) Let hB, P [t], Q[t]i be an incremental logic program of a signature σ that is modular and acyclic, let k be a nonnegative integer,
and let X be a subset of the output atoms of Rk . Set X is an answer set of the
k-expansion Rk of hB, P [t], Q[t]i if and only if X is a (module) answer set of Rk .
3

The acyclicity condition corresponds to the special case of the “mutually revisable” condition
in (Gebser et al. 2011) when there is no online component.

Module Theorem for the General Theory of Stable Models

13

Proposition 2 tells us that the results of incrementally grounding and evaluating
an incremental logic program are identical to the results of evaluating the entire
k-expansion in the usual non-incremental fashion.
6.2 Incrementally Assembled First-Order Modules
In this section, we consider an extension of the theory supporting system iclingo
which allows for the consideration of first-order sentences by utilizing Theorem 4.
This extension may be useful in analyzing non-ground RASPL-1 programs that
describe dynamic domains.
Given a first-order sentence F , we define the projection of F onto a set p of
predicates, denoted by F |p , to be the first-order sentence obtained by replacing all
occurrences of atoms of the form q(t1 , . . . , tn ) in F such that q ∈ ıpr(F ) \ p with ⊥
and performing the following syntactic transformations recursively until no further
transformations are possible:
¬⊥ 7→ ⊤
⊥ ∧ F 7→ ⊥
⊥ ∨ F 7→ F
⊥ → F 7→ ⊤
∃x⊤ 7→ ⊤

¬⊤ 7→ ⊥
F ∧ ⊥ 7→ ⊥
F ∨ ⊥ 7→ F
F → ⊤ 7→ ⊤
∃x⊥ 7→ ⊥

⊤ ∧ F 7→ F
⊤ ∨ F 7→ ⊤
⊤ → F 7→ F
∀x⊤ 7→ ⊤

F ∧ ⊤ 7→ F
F ∨ ⊤ 7→ ⊤
∀x⊥ 7→ ⊥

For example, consider the first-order sentence
∀x(p(x) → q(x)) ∧ (q(a) ∧ ¬p(a) → r) ∧ ∀x(¬q(x) ∧ t(x) → s(x)) .

(11)

The projection of (11) onto {q, r, s, t, m} is
(q(a) → r) ∧ ∀x(¬q(x) ∧ t(x) → s(x)) .
When we restrict attention to the case of propositional logic programs such that
p contains at least the predicates occurring strictly positively in F , this notion
coincides with the corresponding one in the previous section.
Similar to incrementally parameterized programs, we define an incrementally parameterized formula F [t] to be a first-order formula which may contain incrementally parameterized atoms. For any nonnegative integer i, we define the incremental
instantiation of F at i, denoted by F [i], to be the result of replacing all occurrences
of incrementally parameterized atoms af (t) (x) in F [t] with an atom av (x), where v
is the result of evaluating f (i).
Definition 11 (First-Order Module Instantiation)
For any first-order sentence F and any set of (input) predicates I, formula F 0 is
defined as F , and F i+1 is defined as F i |I ∪ head(F i ) , where ıhead(F i ) denotes the set
of all predicates occurring strictly positively in F i . We define the first-order module
instantiation of F w.r.t. I, denoted by ıF M (F, I), to be the first-order module
(F ω , I, ıpr(F )\I),
where F ω is the least fixpoint of the sequence F 0 , F 1 , . . . .

14

Joseph Babb and Joohyung Lee

The idea of the simplification process is related to the fact that all predicates
other than the ones in I ∪ ıhead(F i ) have empty extents under the stable model
semantics, which are equivalent to ⊥ (Ferraris et al. 2011, Theorem 4). The process
is guaranteed to lead to a fixpoint in a finite number of steps since F is finite and
F i |I∪head(F i ) is shorter than F i in all cases except for the terminating case. It is
not difficult to check that if F is the FOL-representation of a ground disjunctive
program Π, the first component Groundσ (Π)|I∪O in the definition of a DLP-module
instantiation corresponds to F 2 .
Example 2
Consider the propositional formula
F = (p → q) ∧ (q → r) ∧ (t ∧ ¬r → s) .
and I = {t, m}. The process of instantiation results in the following transformations
on F :
(p → q) ∧ (q → r) ∧ (t ∧ ¬r → s).

F 0 (= F )

⇒ (q → r) ∧ (t ∧ ¬r → s).

F1

⇒ t ∧ ¬r → s.

F2

⇒ t → s.

F3

⇒ t → s.

F4

The resulting first-order module is then
ıF M (F, {t, m}) = (t → s, {t, m}, {p, q, r, s}).
This definition of an instantiation is different from the one by Gebser et al. (2011)
even when we restrict attention to a finite propositional disjunctive program. First,
we maximize the simplification done on the initial formula F by repeatedly projecting it onto its head and input predicates, whereas Gebser et al. perform only
the first two projections (i.e., F 2 ). Second, the list of output atoms are different.
In our case all atoms occurring in F that are not input atoms are assumed to be
output atoms. The following example illustrates these differences.
Example 3
Recall the DLP-module instantiation in Figure 2. The first-order instantiation of
(the FOL-representation of) the program w.r.t {l, t} is (t → n, {l, t}, {m, n, p, q, r, s}).
While the two notions of instantiation are syntactically different, it can be shown
that, given a propositional logic program Π and sets of propositional atoms I and
X, X is a module answer set of ıDM (Π, I) if and only if X is a module answer set
of ıF M (Π, I).
An incremental first-order theory is a triple hB, P [t], Q[t]i where B is a first-order
sentence, and P [t] and Q[t] are incrementally parameterized sentences.
The k-expansion of hB, P [t], Q[t]i is defined as
Rk = B ∧ P [1] ∧ · · · ∧ P [k] ∧ Q[k].

Module Theorem for the General Theory of Stable Models

15

It is clear that this coincides with the notion of k-expansion for incremental logic
programs when we restrict attention to the common syntax.
We assume a partial order ≺ on
{B, P [1], P [2], . . . , Q[1], Q[2], . . . }

(12)

as follows:
• B ≺ P [1] ≺ P [2] ≺ . . . ;
• P [i] ≺ Q[i] for i ≥ 1.
Definition 12 (Acyclic Incremental First-Order Theory)
We say that an incremental first-order theory hB, P [t], Q[t]i is acyclic if, for every
pair of formulas F, G in (12) such that F ≺ G, we have that G is negative on ıpr(F ).
This definition of acyclicity mirrors that of Gebser et al.’s (2011) in that it prevents predicates from occurring strictly positively in multiple sentences which are
instantiated from the incremental theory. However, as shown in Proposition 3, it is
unnecessary to check a condition similar to modularity for incremental first-order
theories, as it is ensured by acyclicity.
Given a first-order module F = (F, I, Ø), by ıOut(F) we denote Ø.
Proposition 3 (Modularity of Incremental Theory)
If an incremental first-order theory hB, P [t], Q[t]i is acyclic, then the following modules are defined for all k ≥ 0.
P0 = ıF M (B, ∅),
Pi = Pi−1 ⊔ ıF M (P [i], ıOut(Pi−1 )),

(1 ≤ i ≤ k)

Rk = Pk ⊔ ıF M (Q[k], ıOut(Pk )) .
By applying Theorem 4, we can evaluate each component module independently
and compose their results in order to obtain the stable models of Rk .
Proposition 4 (Compositionality for Incremental First-Order Theories)
Let hB, P [t], Q[t]i be an incremental first-order theory and let Rk be the module
as defined in the statement of Proposition 3. For any nonnegative integer k,
IB ∪ IP [1] ∪ · · · ∪ IP [k] ∪ IQ[k] |= SM[Rk ]
iff

IB |= SM[ıF M (B, ∅)]
and IP [1] |= SM[ıF M (P [1], ıOut(P0 ))]
and . . .

(13)

and IP [k] |= SM[ıF M (P [k], ıOut(Pk−1 ))]
and IQ[k] |= SM[ıF M (Q[k], ıOut(Pk ))] .
where IB (IP [1] , . . . , IP [k] , IQ[k] , respectively) is a c(B)-partial interpretation (c(P [1]),
. . . , c(P [k]), c(Q[k])-partial interpretation, respectively) such that IB , IP [1] , . . . , IP [k] , IQ[k]
are pairwise compatible.
Given an acyclic incremental theory and a nonnegative integer k, the following proposition states that evaluating the individual modules and composing their
results is equivalent to evaluating the k-expansion of the incremental theory.

16

Joseph Babb and Joohyung Lee

Proposition 5 (Correctness of Incremental Assembly)
Let hB, P [t], Q[t]i be an acyclic incremental theory, let k be a nonnegative integer,
let Rk be the k-expansion of the incremental theory, and let Rk be the module as
defined in Proposition 3. For any c-partial interpretation I such that c ⊇ c(Rk ),
we have that
I |= SM[Rk ] iff I |= SM[Rk ].
7 Conclusion
Our extension of the module theorem to the general theory of stable models applies to non-ground logic programs containing choice rules, the count aggregate,
and nested expressions. The extension is based on the new findings about the relationship between the module theorem and the splitting theorem. The proof of our
module theorem4 uses the splitting theorem as a building block so that a further
generalization of the splitting theorem can be applied to generalize the module
theorem as well. Indeed, the module theorem presented here can be extended to
logic programs with arbitrary (recursive) aggregates, based on the extension of
the splitting theorem to formulas with generalized quantifiers, recently presented
in (Lee and Meng 2012). Based on the generalized module theorem, we reformulated and extended the theory of incremental answer set computation to the general theory of stable models, which can be useful in analyzing non-ground RASPL-1
programs that describe dynamic domains.
Acknowledgements
We are grateful to Martin Gebser and Tomi Janhunen for useful discussions related to this paper. We are also grateful to the anonymous referees for their useful
comments. This work was partially supported by the National Science Foundation
under Grant IIS-0916116.
References
Ferraris, P., Lee, J., and Lifschitz, V. 2007. A new perspective on stable models. In
Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). AAAI
Press, 372–379.
Ferraris, P., Lee, J., and Lifschitz, V. 2011. Stable models and circumscription.
Artificial Intelligence 175, 236–263.
Ferraris, P., Lee, J., Lifschitz, V., and Palla, R. 2009. Symmetric splitting in the
general theory of stable models. In Proceedings of International Joint Conference on
Artificial Intelligence (IJCAI). AAAI Press, 797–803.
Gebser, M., Grote, T., Kaminski, R., and Schaub, T. 2011. Reactive answer set
programming. In Proceedings of International Conference on Logic Programming and
Nonmonotonic Reasoning (LPNMR). Springer, 54–66.
4

Available in the online appendix.

Module Theorem for the General Theory of Stable Models

17

Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T., and Thiele,
S. 2008. Engineering an incremental ASP solver. In Proceedings of the Twenty-fourth
International Conference on Logic Programming (ICLP’08), M. Garcia de la Banda
and E. Pontelli, Eds. Lecture Notes in Computer Science, vol. 5366. Springer-Verlag,
190–205.
Gelfond, M. and Lifschitz, V. 1988. The stable model semantics for logic programming. In Proceedings of International Logic Programming Conference and Symposium,
R. Kowalski and K. Bowen, Eds. MIT Press, 1070–1080.
Janhunen, T., Oikarinen, E., Tompits, H., and Woltran, S. 2009. Modularity aspects of disjunctive stable models. Journal of Artificial Intelligence Research 35, 813–
857.
Lee, J., Lifschitz, V., and Palla, R. 2008. A reductive semantics for counting and
choice in answer set programming. In Proceedings of the AAAI Conference on Artificial
Intelligence (AAAI). AAAI Press, 472–479.
Lee, J. and Meng, Y. 2012. Stable models of formulas with generalized quantifiers. In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).
http://peace.eas.asu.edu/joolee/papers/smgq-nmr.pdf.
Lee, J. and Palla, R. 2012. Reformulating the situation calculus and the event calculus
in the general theory of stable models and in answer set programming. Journal of
Artificial Inteligence Research (JAIR) 43, 571–620.
Lifschitz, V. 1994. Circumscription. In Handbook of Logic in AI and Logic Programming,
D. Gabbay, C. Hogger, and J. Robinson, Eds. Vol. 3. Oxford University Press, 298–352.
Oikarinen, E. and Janhunen, T. 2008. Achieving compositionality of the stable model
semantics for smodels programs. TPLP 8, 5-6, 717–761.

Appendix A Proofs
A.1 Splitting Lemma
We use the splitting lemma (Ferraris et al. 2009) to prove a few theorems below.
Splitting Lemma
Let F be a first-order sentence, and let p, q be lists of distinct predicate constants.
If each strongly connected component of DG[F ; pq] is a subset of p or a subset of q
then
SM[F ; pq] is equivalent to

SM[F ; p] ∧ SM[F ; q] .

The statement is slightly more general than the one from (Ferraris et al. 2009) in
that p and q are not required to be disjoint. The proof of this enhancement follows
from the Version 3 of the Splitting Lemma from (Ferraris et al. 2009).

A.2 Proof of Lemma 1
Lemma 1
X is a module answer set of (Π, I, Ø) iff X is an answer set of Π ∪ {{p} ← | p ∈ I}.

18

Joseph Babb and Joohyung Lee

Proof
X is an answer set of Π ∪ {p ← | p ∈ (I ∩ X)}
iff
X is an answer set of Π ∪ {p ← ınot ınot p | p ∈ I}
iff
X is an answer set of Π ∪ {{p} ← | p ∈ I} .
The equivalence between the first and the second follows from the equivalence
between the reducts of each program relative to X.
The equivalence between the second and third is because the transformation
preserves strong equivalence.

A.3 Proof of Theorem 3
Theorem 3
Let F , G, H be first-order sentences, and let p, q be finite lists of distinct predicate
constants. If
(a) each strongly connected component of DG[F ∧ G ∧ H; pq] is a subset of p or a
subset of q,
(b) F is negative on q, and
(c) G is negative on p
then
SM[F ∧ G ∧ H; pq] is equivalent to SM[F ∧ H; p] ∧ SM[G ∧ H; q] .

Proof
By the Splitting Lemma above, SM[F ∧ G ∧ H; pq] is equivalent to
SM[F ∧ G ∧ H; p] ∧ SM[F ∧ G ∧ H; q] .
Since G is negative on p, the first conjunctive term can be rewritten as
SM[F ∧ H; p] ∧ G .

(A1)

Similarly, the second conjunctive term can be rewritten as
SM[G ∧ H; q] ∧ F .

(A2)

It remains to observe that the second conjunctive term of each of the formulas (A1)
and (A2) is entailed by the first conjunctive term of the other.

Module Theorem for the General Theory of Stable Models

19

A.4 Proof of Proposition 1
Proposition 1
For any first-order modules F1 , F2 , and F3 , the following properties hold:
•
•
•
•

F1 ⊔ F2 is defined iff F2 ⊔ F1 is defined.
SM[F1 ⊔ F2 ] is equivalent to SM[F2 ⊔ F1 ].
(F1 ⊔ F2 ) ⊔ F3 is defined iff F1 ⊔ (F2 ⊔ F3 ) is defined.
SM[(F1 ⊔ F2 ) ⊔ F3 ] is equivalent to SM[F1 ⊔ (F2 ⊔ F3 )].

Proof
Claims (a) and (b) follow immediately from the definitions.
We prove Claim (c). Let Fi = (Fi , Ii , Øi ) for each i ∈ {1, 2, 3} and without loss
of generality assume that each Fi is a conjunction of the form Fi,1 ∧ · · · ∧ Fi,ki .
From left to right: Assume that (F1 ⊔ F2 ) ⊔ F3 is defined. Since F1 and F2 are
joinable,
(i) Ø1 ∩ Ø2 = ∅;
(ii) each conjunctive term of F1 is negative on Ø2 , or is one of the conjunctive terms of
F2 ;
(iii) each conjunctive term of F2 is negative on Ø1 , or is one of the conjunctive terms of
F1 ;
(iv) each strongly connected component of DG[F1 ∧ F2 ; Ø1 Ø2 ] is a subset of Ø1 or a
subset of Ø2 .
Also, since (F1 ⊔ F2 ) and F3 are joinable,
(v) (Ø1 ∪ Ø2 ) ∩ Ø3 = ∅;
(vi) each conjunctive term of F1 ∧ F2 is negative on Ø3 , or is one of the conjunctive
terms of F3 ;
(vii) each conjunctive term of F3 is negative on Ø1 ∪ Ø2 , or is one of the conjunctive
terms of F1 ∧ F2 ;
(viii) each strongly connected component of DG[F1 ∧ F2 ∧ F3 ; Ø1 Ø2 Ø3 ] is a subset of
Ø1 ∪ Ø2 or a subset of Ø3 .
We first prove that F2 ⊔ F3 is defined.
(ix) From (v), it follows that Ø2 ∩ Ø3 = ∅.
(x) From (vi), it follows that each conjunctive term of F2 is negative on Ø3 or is one
of the conjunctive terms of F3 .
(xi) We prove that each conjunctive term of F3 is negative on Ø2 or is one of the
conjunctive terms of F2 .
Consider any conjunctive term C of F3 . By (vii), C is negative on Ø1 ∪ Ø2 , or is
one of the conjunctive terms of F1 ∧ F2 .
— Case 1: C is negative on Ø1 ∪ Ø2 . Clearly, it is negative on Ø2 as well.

20

Joseph Babb and Joohyung Lee

— Case 2: C is one of the conjunctive terms of F1 ∧ F2 . If C is one of the conjunctive terms of F2 , the claim trivially follows. If C is one of the conjunctive
terms of F1 , by (ii), it is either negative on Ø2 or is one of the conjunctive
terms of F2 . In either case, the claim follows.
(xii) We first prove that each strongly connected component of DG[F1 ∧F2 ∧F3 ; Ø1 Ø2 Ø3 ]
is contained in only one of Ø1 , Ø2 or Ø3 , from which the fact that each strongly
connected component of DG[F2 ∧ F3 ; Ø2 Ø3 ] is contained in Ø2 or Ø3 follows, as
DG[F2 ∧ F3 ; Ø2 Ø3 ] is a subgraph of DG[F1 ∧ F2 ∧ F3 ; Ø1 Ø2 Ø3 ].
By (i) and (v), Ø1 , Ø2 and Ø3 are pairwise disjoint. Consider any strongly connected
component S of DG[F1 ∧ F2 ∧ F3 ; Ø1 Ø2 Ø3 ]. By (viii) S is a subset of Ø1 ∪ O2 or
a subset of Ø3 . Assume that S is a subset of Ø1 ∪ Ø2 . Clearly, S is also a strongly
connected component of DG[F1 ∧ F2 ∧ F3 ; Ø1 Ø2 ]. In view of (vii), DG[F1 ∧ F2 ∧
F3 ; Ø1 Ø2 ] is the same as DG[F1 ∧ F2 ; Ø1 Ø2 ], so that S is a strongly connected
component of DG[F1 ∧ F2 ; Ø1 Ø2 ] as well. By (iv) S is contained in Ø1 or Ø2 .
We now prove that F1 ⊔ (F2 ⊔ F3 ) is defined.
• From (i) and (v), it follows that Ø1 ∩ (Ø2 ∪ O3 ) = ∅;
• From (ii) and (vi), it follows that each conjunctive term of F1 is negative on Ø2 ∪Ø3
or is one of the conjunctive terms of F2 ∧ F3 ;
• From (iii) and (vii), it follows that each conjunctive term of F2 ∧ F3 is negative on
Ø1 or is one of the conjunctive terms of F1 ;
• From the claim proven in (viii), it follows that each strongly connected component
of DG[F1 ∧ F2 ∧ F3 ; Ø1 Ø2 Ø3 ] is contained in Ø1 or Ø2 ∪ Ø3 .
From right to left: Assume that F1 ⊔ (F2 ⊔ F3 ) is defined. By Claim (a), (F2 ⊔ F3 ) ⊔ F1
is defined, and then (F3 ⊔ F2 ) ⊔ F1 is defined. By the first part of Claim (c) that
was proven, F3 ⊔ (F2 ⊔ F1 ) is defined, and then by applying Claim (a) twice, we
have that (F1 ⊔ F2 ) ⊔ F3 is defined.
We now prove Claim (d). Using Theorem 4 and Claim (c),
SM[(F1 ⊔ F2 ) ⊔ F3 ] ⇔ SM[F1 ⊔ F2 ] ∧ SM[F3 ]
⇔ SM[F1 ] ∧ SM[F2 ] ∧ SM[F3 ]
⇔ SM[F1 ] ∧ SM[F2 ⊔ F3 ]
⇔ SM[F1 ⊔ (F2 ⊔ F3 )] .

A.5 Proof of Theorem 4
Theorem 4
Let F1 = (F1 , I1 , Ø1 ) and F2 = (F2 , I2 , Ø2 ) be first-order modules of a signature σ
that are joinable, and, for i = 0, 1, let ci be a subset of σ that contains c(Fi ) ∪ Øi ,

Module Theorem for the General Theory of Stable Models

21

and let Ii be a ci -partial interpretation of σ. If I1 and I2 are compatible with each
other, then
I1 ∪ I2 |= SM[F1 ⊔ F2 ] iff

I1 |= SM[F1 ] and I2 |= SM[F2 ] .

Proof
Let us identify F1 with (F1′ ∧ H, I1 , Ø1 ) and F2 with (F2′ ∧ H, I2 , Ø2 ) as in the
definition of join (Definition 8).
By definition SM[F1 ⊔ F2 ] is SM[F1′ ∧ F2′ ∧ H; Ø1 ∪ Ø2 ]. By Theorem 3,
I1 ∪ I2 |= SM[F1′ ∧ F2′ ∧ H; Ø1 ∪ Ø2 ] iff
I1 ∪ I2 |= SM[F1′ ∧ H; Ø1 ] and I1 ∪ I2 |= SM[F2′ ∧ H; Ø2 ]
Clearly, I1 ∪ I2 is compatible with I1 . Since c1 contains c(F1′ ∧ H) ∪ Ø1 , it follows
that I1 ∪ I2 |= SM[F1′ ∧ H; Ø1 ] iff I1 |= SM[F1′ ∧ H; Ø1 ]. Similarly, I1 ∪ I2 |=
SM[F2′ ∧ H; Ø2 ] iff I2 |= SM[F2′ ∧ H; Ø2 ]. Consequently, the claim follows.

A.6 Proof of Proposition 3
Lemma 2
Let hB, P [t], Q[t]i be an incremental first-order theory, and let Pi and Rk be as in
Proposition 3. It holds that
ıOut(Pi ) = ıpr(B ∧ P [1] ∧ · · · ∧ P [i]),
ıOut(Rk ) = ıpr(B ∧ P [1] ∧ · · · ∧ P [k] ∧ Q[k]).
Proof
We show the first clause by induction. The second clause is similar.
• Base case: P0 = ıF M (B, ∅) = (B ω , ∅, ıpr(B)).
• Inductive step: Assume that ıOut(Pi−1 ) = ıpr(B ∧P [1]∧· · ·∧P [i − 1]). The module
ıF M (P [i], ıOut(Pi−1 )) is
(P [i]ω , ıOut(Pi−1 ), ıpr(P [i])\ıOut(Pi−1 )) .
Thus

ıOut(Pi ) = ıOut(Pi−1 ) ∪ ıpr(P [i])\ıOut(Pi−1 ) = ıOut(Pi−1 ) ∪ ıpr(P [i])
and by the I.H., this is then ıpr(B ∧ P [1] ∧ · · · ∧ P [i]).

Lemma 3
Given any two first-order formulas F1 , F2 and disjoint sets of predicate constants
p1 , p2 such that ıpr(F1 ) ⊆ p1 , and F2 is negative on p1 . Every strongly connected
component of DG[F1 ∧ F2 ; p1 p2 ] is contained in p1 or p2 .

22

Joseph Babb and Joohyung Lee

Proof
Since F2 is negative on p1 , we have that ıhead(F2 ) ∩ p1 = ∅. Thus every outgoing
edge in the dependency graph from a predicate constant in p1 must be obtained
from F1 . Since ıpr(F1 ) ⊆ p1 , such outgoing edge always leads to a vertex in p1 .
Consequently, every strongly connected component of DG[F1 ∧F2 ; p1 p2 ] containing
a predicate constant from ıhead(F1 ) is contained in p1 , so the claim follows.
Proposition 3
If an incremental first-order theory hB, P [t], Q[t]i is acyclic, then the following modules are defined for all k ≥ 0.
P0 = ıF M (B, ∅),
Pi = Pi−1 ⊔ ıF M (P [i], ıOut(Pi−1 )),

(1 ≤ i ≤ k)

Rk = Pk ⊔ ıF M (Q[k], ıOut(Pk )) .

Proof
We first prove by induction that Pi is defined.
Base case: It is clear that P0 = ıF M (B, ∅) is defined.
Inductive step: Assume that Pi−1 = (Fi−1 , Ii−1 , Øi−1 ) is defined for any i > 0.
Also,
ıF M (P [i], Øi−1 ) = (P [i]ω , Øi−1 , ıpr(P [i])\Øi−1 )
is trivially defined. To show that they are joinable, we will check the following:
(i) ıhead(Fi−1 ) ∩ (ıpr(P [i])\Øi−1 ) = ∅;
(ii) ıhead(P [i]ω ) ∩ Øi−1 = ∅;
(iii) every strongly connected component of
DG[Fi−1 ∧ P [i]ω ; Øi−1 ∪ (ıpr(P [i])\Øi−1 )]
is a subset of Øi−1 or ıpr(P [i])\Øi−1 .
Note that
ıpr(Fi−1 ) ⊆ ıpr(B ∧ P [1] ∧ . . . P [i − 1])

(A3)

ıhead(P [i]ω ) ⊆ ıhead(P [i]) .

(A4)

and
Proof of Claim (i): By Lemma 2, Øi−1 is ıpr(B ∧ P [1] ∧ · · · ∧ P [i − 1]), and Claim
(i) trivially follows in view of (A3) and the fact that ıhead(Fi−1 ) ⊆ ıpr(Fi−1 ).
Proof of Claim (ii): Since the theory is acyclic,
ıhead(P [i]) ∩ ıpr(B ∧ P [1] ∧ · · · ∧ P [i − 1]) = ∅ ,
and from (A4) and Lemma 2, we have that
ıhead(P [i]ω ) ∩ Øi−1 = ∅ .

(A5)

Module Theorem for the General Theory of Stable Models

23

Proof of Claim (iii): The claim follows from (A5) and Lemma 3.
We next show that Rk is defined. By our previous result, Pk = (Fk , Ik , Øk ) is
defined. It also holds that
ıF M (Q[k], Øk ) = (Q[k]ω , Øk , ıpr(Q[k]) \ Øk )
is defined trivially. The rest of the reasoning is similar to the previous one.
A.7 Proof of Proposition 4
Proposition 4
Let hB, P [t], Q[t]i be an acyclic incremental first-order theory and let Rk be the
module as defined in the statement of Proposition 3. For any nonnegative integer k,
IB ∪ IP [1] ∪ · · · ∪ IP [k] ∪ IQ[k] |= SM[Rk ]
iff

IB |= SM[ıF M (B, ∅)]
and IP [1] |= SM[ıF M (P [1], ıOut(P0 ))]
and . . .
and IP [k] |= SM[ıF M (P [k], ıOut(Pk−1 ))]
and IQ[k] |= SM[ıF M (Q[k], ıOut(Pk ))] .

where IB (IP [1] , . . . , IP [k] , IQ[k] , respectively) is a c(B)-partial interpretation (c(P [1]),
. . . , c(P [k]), c(Q[k])-partial interpretation, respectively) such that IB , IP [1] , . . . , IP [k] , IQ[k]
are pairwise compatible.
Proof
Via repeated applications of Theorem 4 on Rk as indicated by Proposition 3.

A.8 Proof of Proposition 5
Lemma 4
Let hB, P [t], Q[t]i be an acyclic incremental first-order theory, let k be a nonnegative
integer, let Hk = B ∧ P [1] ∧ · · · ∧ P [k], and let Rk be the k-expansion of the
incremental theory. It holds that IB ∪ IP [1] ∪ · · · ∪ IP [k] ∪ IQ[k] |= SM[Rk ] iff
IB |= SM[B; ıpr(B)]
and IP [1] |= SM[P [1]; ıpr(P [1]) \ ıpr(H0 )]
and . . .

(A6)

and IP [k] |= SM[P [k]; ıpr(P [k]) \ ıpr(Hk−1 )]
and IQ[k] |= SM[Q[k]; ıpr(Q[k]) \ ıpr(Hk )]
where IB (IP [1] , . . . , IP [k] , IQ[k] , respectively) is a c(B)-partial interpretation (c(P [1]),
. . . , c(P [k]), c(Q[k])-partial interpretation, respectively) such that IB , IP [1] , . . . , IP [k] , IQ[k]
are pairwise compatible.

24

Joseph Babb and Joohyung Lee

Proof
Formula Hk is trivially negative on ıpr(Q[k]) \ ıpr(Hk ), and since the theory is
acyclic, Q[k] is negative on ıpr(Hk ). Also, by Lemma 3, every strongly connected
component of DG[Hk ∧Q[k]; ıpr(Hk )∪ıpr(Q[k])] is a subset of ıpr(Hk ) or ıpr(Q[k])\
ıpr(Hk ). By Theorem 4, it then holds that
IHk ∪ IQ[k] |= SM[Rk ]

iff

IHk |= SM[Hk ] and IQ[k] |= SM[Q[k]; ıpr(Q[k]) \ ıpr(Hk )]

where IHk is a c(Hk )-partial interpretation that is compatible with IQ[k] .
Next we check by induction that IHk |= SM[Hk ] is equivalent to
IB |= SM[B]
and IP [1] |= SM[P [1]; ıpr(P [1]) \ ıpr(H0 )]
and . . .

(A7)

and IP [k] |= SM[P [k]; ıpr(P [k]) \ ıpr(Hk−1 )] .
Base case: when k = 0, Hk = B. Trivial.
Inductive step: Let the property hold for Hk−1 . By definition, Hk = Hk−1 ∧
P [k]. Hk−1 is trivially negative on ıpr(P [k]) \ ıpr(Hk−1 ) and since the theory is
acyclic, P [k] is negative on ıpr(Hk−1 ). Also, by Lemma 3, every strongly connected
component of DG[Hk ; ıpr(Hk )] is a subset of ıpr(Hk−1 ) or ıpr(P [k]) \ ıpr(Hk−1 ).
By Theorem 4, it then holds that
IHk |= SM[Hk ]

iff

IHk−1 |= SM[Hk−1 ] and IP [k] |= SM[P [k]; ıpr(P [k])\ıpr(Hk−1 )].

The property then holds by the I.H.
Lemma 5
For any first-order formula F , SM[ıF M (F, I)] is equivalent to SM[F ; ıpr(F )\I].
Proof
We introduce a notion that helps us prove. By ıSimpl(F ) we denote the least
fixpoint of the sequence F0 , F1 , . . . : formula F0 is defined as F , and Fi+1 is defined
as Fi |head(Fi ) .
Formula SM[ıF M (F, I)] is SM[(F ω , I, ıpr(F ) \ I)], which in turn is defined as
SM[F ω ; ıpr(F )\ I]. By Theorem 2 from (Ferraris et al. 2011), this is equivalent to
SM[F ω ∧ ıChoice(I); ıpr(F )]. From the definition of ıSimpl, the latter is equivalent to SM[Simpl(F ∧ ıChoice(I)); ıpr(F )], and, furthermore, by Theorem 4
from (Ferraris et al. 2011), is equivalent to SM[F ∧ ıChoice(I); ıpr(F )].
Proposition 5
Let hB, P [t], Q[t]i be an acyclic incremental theory, let k be a nonnegative integer,
let Rk be the k-expansion of the incremental theory, and let Rk be the module as
defined in Proposition 3. For any c-partial interpretation I such that c ⊇ c(Rk ),
we have that
I |= SM[Rk ] iff I |= SM[Rk ].

Module Theorem for the General Theory of Stable Models

25

Proof
Without loss of generality, let I = IB ∪ IP [1] ∪ · · · ∪ IP [k] ∪ IQ[k] . By Lemma 4,
I |= SM[Rk ] is equivalent to (A6), and by Lemma 2, this is further equivalent to
IB |= SM[B; ıpr(B)]
and IP [1] |= SM[P [1]; ıpr(P [1]) \ ıOut(P0 )]
and . . .
and IP [k] |= SM[P [k]; ıpr(P [k]) \ ıOut(Pk−1 )]
and IQ[k] |= SM[Q[k]; ıpr(Q[k]) \ ıOut(Pk )] .
We check the following:
• IB |= SM[B; ıpr(B)] iff IB |= SM[ıF M (B, ∅)];
• IP [i] |= SM[P [i]; ıpr(P [i])\ıOut(Pi−1 )] iff IP [i] |= SM[ıF M (P [i], ıOut(Pi−1 ))];
• IQ[k] |= SM[Q[k]; ıpr(Q[k])\ıOut(Pk )] iff IQ[k] |= SM[ıF M (Q[k], ıOut(Pk ))].
The first clause is clear. The last two clauses follow from Lemma 5.
Therefore, by Proposition 4,
IB ∪ IP [1] ∪ · · · ∪ IP [k] ∪ IQ[k] |= SM[Rk ] .

Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence (AAAI-10)

Situation Calculus as Answer Set Programming
Joohyung Lee and Ravi Palla
School of Computing, Informatics and Decision Systems Engineering
Arizona State University
Tempe, AZ, 85287, USA
{joolee, Ravi.Palla}@asu.edu

Abstract

However, in the situation calculus, situations are treated
as objects that can be quantified over, and function
do takes actions and situations as arguments: the term
do(am , do(am−1 , do(. . . , do(a1 , S0 ))) represents the situation that is obtained by applying actions a1 , ..., am sequentially in the situation S0 . How do we build a system that can
ground such theories?
In this paper, we apply propositional reasoning methods
to the situation calculus by turning the situation calculus into
answer set programming. More specifically, we reformulate Lin’s causal action theories (Lin 1995) and Reiter’s basic action theories (Reiter 2001) in terms of the first-order
stable model semantics (Ferraris, Lee, & Lifschitz 2007;
2010). Under the assumption that the domain is given and
finite, a further transformation is applied to turn them into
answer set programs. We use the combination of systems
F 2 LP 3 and DLV- COMPLEX 4 to do reasoning with a bounded
number of situations. For basic action theories, we also provide an ASP encoding method that adopts the solution to the
frame problem in ASP, which tells us how the solutions to
the frame problem in the two formalisms are related to each
other.

We show how the situation calculus can be reformulated in
terms of the first-order stable model semantics. A further
transformation into answer set programs allows us to use an
answer set solver to perform propositional reasoning about
the situation calculus. We also provide an answer set programming style encoding method for Reiter’s basic action
theories, which tells us how the solution to the frame problem in answer set programming is related to the solution in
the situation calculus.

Introduction
The situation calculus (McCarthy & Hayes 1969; Reiter
2001) is one of the most well-known formalisms for reasoning about actions. Its language is first-order logic, sometimes enriched with second-order features. Prolog can be
used to implement the situation calculus, based on the fact
that Clark’s completion semantics accounts for definitional
axioms. This allows expressive first-order reasoning about
actions.
On the other hand, there has been significant progress in
efficient propositional reasoning thanks to the emergence of
SAT solvers. SAT-based planning (Kautz & Selman 1992)
was shown to be a competitive approach in planning. The
idea was extended to action formalisms that are more expressive than STRIPS, such as nonmonotonic causal theories (Giunchiglia et al. 2004), which led to the implementation of the Causal Calculator 1 and the discrete event calculus (Mueller 2004), which led to the implementation of
the DEC reasoner 2 . Answer set programming (ASP) is being widely applied, in part due to the availability of many
efficient answer set solvers, which use SAT solvers or techniques adapted from SAT.
The input languages of such systems allow variables, the
meaning of which is understood in terms of grounding—a
process that replaces every variable with every variable-free
(a.k.a. ground) term in the Herbrand universe. Under this
approach, the domain to be modelled is assumed to be given
and finite. Function symbols are usually disallowed as they
introduce infinite ground terms (hence an infinite domain).

Preliminaries
Review of General Stable Model Semantics
We follow the definition of a stable model from (Ferraris,
Lee, & Lifschitz 2010), a journal version of (Ferraris, Lee,
& Lifschitz 2007).
Let p be a list of distinct predicate constants p1 , . . . , pn
other than equality. Given a first-order formula F , recall
that CIRC[F ; p] is defined as the second-order formula
F ∧ ¬∃u((u < p) ∧ F (u))
where u is a list of distinct predicate variables of the same
length as p, expression u < p stands for a formula expressing that u is “stronger than” p, as defined in (Lifschitz 1994), and F (u) is the formula obtained from F by
substituting the variables u for the constants p. Similarly,
SM[F ; p] is defined as the second-order sentence
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where formula F ∗ (u) is defined recursively as follows:

c 2010, Association for the Advancement of Artificial
Copyright 
Intelligence (www.aaai.org). All rights reserved.
1
http://www.cs.utexas.edu/users/tag/cc/ .
2
http://decreasoner.sourceforge.net/ .

3
4

309

http://reasoning.eas.asu.edu/f2lp .
http://www.mat.unical.it/dlv-complex .

• pi (t)∗ = ui (t) for any tuple t of terms;
• F ∗ = F for any atomic F that does not contain members
of p;
• (F ⊙ G)∗ = (F ∗ ⊙ G∗ ), ⊙ ∈ {∧, ∨};
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (QxF )∗ = QxF ∗ , Q ∈ {∀, ∃}.
A model of F (in the sense of first-order logic) is stable
(relative to the list p of intensional predicates) if it satisfies SM[F ; p]. Let σ(F ) be the signature consisting of the
object, function and predicate constants occurring in F . If
F contains at least one object constant, an Herbrand interpretation of σ(F ) that satisfies SM[F ; p] where p is the list
of all predicate constants occurring in F , is called an answer
set of F . The answer sets of a logic program Π are defined
as the answer sets of the FOL-representation of Π (i.e., the
conjunction of the universal closures of implications corresponding to the rules).
Proposition 2 of (Kim, Lee, & Palla 2009) tells that for
the class of “canonical theories,” the stable model semantics
coincides with circumscription. We say that an occurrence
of a predicate constant in a formula F is strictly positive if
that occurrence is not in the antecedent of any implication.
For any list p of predicate constants and any formulas G
and H, an implication G → H is called canonical (relative
to p) if
• every occurrence of every predicate constant from p in G
is strictly positive in G, and
• every occurrence of every predicate constant from p in H
is strictly positive in H.
For instance, p(x) → q(x) is a canonical implication relative to {p, q}, while its contraposition ¬q(x) → ¬p(x) is
not.
A canonical theory (relative to p) is the conjunction of
the universal closures of canonical implications.
Proposition 1 (Kim, Lee, & Palla 2009, Proposition 2) For
any canonical theory F relative to p,
CIRC[F ; p] ↔ SM[F ; p]
is logically valid.
The stable model semantics can be extended to allow
strong negation (a.k.a. classical negation) (Ferraris, Lee, &
Lifschitz 2010). We distinguish between intensional predicates of two kinds, positive and negative, and assume that
each negative intensional predicate has the form ∼ p, where
p is a positive intensional predicate and ‘∼ ’ is a symbol for
strong negation. An interpretation of the underlying signature is coherent if the extent of every negative predicate ∼ p
in it is disjoint from the extent of the corresponding positive
predicate p.

(0 ≤ k ≤ m ≤ n ≤ p), where each Ai is an atomic formula.
Definition 1 (Translation F 2 LP) 1. Given a formula F and
a list of intensional predicates p, eliminate the quantifiers, possibly introducing new predicates, by the procedure given in Definition 1 from (Lee & Palla 2009).
2. Add choice formulas (q(x) ∨ ¬q(x)) for all nonintensional predicates q.
3. Turn the resulting quantifier-free formula into a logic program by applying the transformation rules from (Cabalar,
Pearce, & Valverde 2005).
(Lee & Palla 2009) shows the correctness of the translation under the assumption that every positive (negative, respectively) occurrence of a formula ∃xG(x) (∀xG(x), respectively) in F belongs to a subformula H of F such that
H contains no strictly positive occurrence of any intensional
predicate.
System F 2 LP is an implementation of the translation
above, so that existing answer set solvers can be used for
computing the answer sets (i.e., Herbrand stable models) of
a first-order theory.

Lin’s Causal Action Theories in ASP
Here we consider how to turn Lin’s causal action theories
(Lin 1995) into answer set programs. The language of causal
action theories is many-sorted first-order logic, whose sorts
are situation, action, fluent, truth value and object. As in that
paper we understand expression P (x, s) where P is a fluent
name, as shorthand for Holds(P (x), s). We do not consider
functional fluents in this paper.
According to Lin [1995], a formula φ(s) is called a simple
state formula about s if φ(s) does not mention Poss, Caused
or any situation term other than possibly the variable s.
We assume that a description D consists of a finite number
of the following sets of axioms. We often identify D with
the conjunction of the universal closures of all axioms in
D. In the following, F , Fi are fluent names, A is an action
name, V , Vi are truth values, s, s′ are situation variables,
φ(s) is a simple state formula about s, symbols a, a′ are
action variables, f is a variable of sort fluent, v is a variable
of sort truth value, and x, xi , y, yi are lists of variables.
• Dcaused is a set of axioms of the form
Poss(A(x), s) → (φ(s) → Caused(F (y), V, do(A(x), s)),
(direct effects) and
φ(s) ∧ Caused(F1 (x1 ), V1 , s) ∧ . . .
∧Caused(Fn (xn ), Vn , s) → Caused(F (x), V, s)
(indirect effects).
• Dposs is a set of axioms of the form
Poss(A(x), s) ↔ φ(s).

System F 2 LP
Building on the result of (Cabalar, Pearce, & Valverde
2005), Lee & Palla [2009] define a translation that turns an
arbitrary first-order formula under the stable model semantics into a logic program consisting of a finite set of rules of
the form
A1 ; . . . ; Ak ← Ak+1 , . . . , Am , not Am+1 , . . . , not An ,
not not An+1 , . . . , not not Ap

(1)

• Drest is a set of axioms of the following forms.
– The basic axioms:
Caused(f, true, s) → Holds(f, s)
Caused(f, false, s) → ¬Holds(f, s)
true 6= false ∧ ∀v(v = true ∨ v = false).

310

(2)

– The unique name assumptions for fluent and action
names:
Fi (x) 6= Fj (y), (i 6= j)
(3)
Fi (x) = Fi (y) → x = y.

In the context of answer set programming, since answer
sets are Herbrand interpretations, we can drop axioms (2)–
(5). Also we do not include (8) in the input to F 2 LP. Instead,
we include the following set of rules Πsituation (in the language of DLV- COMPLEX) to the program Πdescription that is
obtained by running F 2 LP on the rest of the axioms.

Similarly for action names.
– The foundational axioms for the discrete situation calculus: 5
s 6= do(a, s),
(4)
do(a, s) = do(a′ , s′ ) → (a = a′ ∧ s = s′ ),

nesting(0,s0).
nesting(L1,do(A,S)) :- nesting(L,S), #succ(L,L1),
action(A).
situation(S) :- nesting(L,S).

(5)

∀p(p(S0 ) ∧ ∀a, s(p(s) → p(do(a, s))) → ∀s p(s)).
(6)
– The frame axiom:

Πsituation is used to generate finitely many situation
terms whose height is up to #maxint, the value that
can be given as an option in invoking DLV- COMPLEX.
#succ is an arithmetic predicate in the language of DLVCOMPLEX defined over integers: #succ(L,L1) is true
iff L1 = L + 1. It is not difficult to check that if
a program Π containing these rules has no occurrence
of predicate nesting in the other rules and no occurrence of predicate situation in the head of any
other rule in Π, then every answer set of Π contains
atoms situation(do(am, do(am−1, do(. . . , do(a1, s0)))))
for all possible sequences of actions a1 , . . . , am for
m = 0, . . . , #maxint. The use of predefined symbols like
#succ and #maxint is not essential. Πsituation can be
written in the language of any other answer set solver by
explicitly providing the integer sort and defining the successor relation. However, no other answer set solvers, to the
best of our knowledge, can ground Πsituation . This is because the recursion in the second argument of nesting in
the second rule leads to violation of the syntactic conditions,
such as λ-restricted, ω-restricted, or finite domain programs,
that answer set solvers impose on the input languages in order to ensure finite grounding in the presence of function
symbols. Nonetheless, the rules can be finitely grounded by
DLV- COMPLEX since it allows us to turn off the finite domain checking (option -nofdcheck). It is not difficult to
see why the program leads to finite grounding since we provide an explicit upper limit for the function nesting.
Figure 1 shows the encoding of Lin’s suitcase example
(Lin 1995) in the language of F 2 LP. In order to turn the
many sorted signature into the non-sorted one, we add “domain predicates” in the antecedents of axioms. Since we fix
the domain of situations to be finite, we require that actions
not be allowed to be effective in the final situations. This is
done by introducing predicate final(S).
Consider the simple temporal projection problem from
(Lin 1995): Initially the first lock is down and the second
lock is up. What will happen if the action flip turns the first
lock up? We can check the answer using F 2 LP and DLVCOMPLEX: first, we add the following rules to the theory in
Figure 1. The last rule is the negation of the conclusion we
want to check.

Poss(a, s) → (¬∃vCaused(f, v, do(a, s))
→ (Holds(f, do(a, s)) ↔ Holds(f, s))).
– Axioms for other domain knowledge: φ(s).
Lin’s causal action theory is defined as
CIRC[Dcaused ; Caused] ∧ Dposs ∧ Drest .

(7)

Translation into ASP
We first reformulate Lin’s causal action theories in terms of
the first-order stable model semantics. It is easy to check
that the theory (7) is canonical relative to Caused.
Let Dposs→ be the set of axioms φ(s) → Poss(A(x), s)
for each axiom (1) in Dposs . Instead of the second-order axiom (6) we consider the following first-order formula, which
introduces new intensional predicate Sit.6
Sit(S0 ) ∧ ∀a, s(Sit(s) → Sit(do(a, s))) ∧ ¬∃s¬Sit(s).
(8)
−
In the following Drest
is the theory obtained from Drest by
dropping (6).
Theorem 1 The situation calculus domain description (7)
is equivalent to each of the following when we disregard the
auxiliary predicate Sit:
−
(a) SM[Dcaused ; Caused] ∧ Dposs ∧ Drest
∧ SM[(8); Sit];
−
(b) SM[Dcaused ; Caused] ∧ SM[Dposs→ ; Poss] ∧ Drest
∧
SM[(8); Sit];
−
(c) SM[Dcaused ∧ Dposs→ ∧ Drest
∧ (8); Caused, Poss, Sit].

The translation F 2 LP can be used to turn (c) into a logic
program syntax.
Theorem 2 Let D be a finite causal action theory (7) whose
signature contains finitely many predicate constants p, let
−
F be Dcaused ∧ Dposs→ ∧ Drest
∧ (8) and let ΠFOL be the
FOL representation of the program obtained by applying
the translation F 2 LP on F in which only predicates Caused,
Poss, Sit are assumed to be intensional. Then the models of
SM[ΠFOL ; p, Sit, q] restricted to the signature of D are precisely the models of D, where q is the list of all new predicates introduced by the translation.

% initial situation
:- h(up(l1),s0).
h(up(l2),s0).

5
For simplicity we skip two other axioms regarding the partialorder among situations.
6
Suggested by Vladimir Lifschitz (personal communication).

% query
:- h(open,do(flip(l1),s0)).

311

value(t).

value(f).

lock(l1).

Reiter’s Basic Action Theories in ASP

lock(l2).

As before, we understand P (x, s) where P is a fluent name,
as shorthand for Holds(P (x), s), and we do not consider
functional fluents.
A basic action theory (BAT) is of the form

fluent(up(X)) :- lock(X).
fluent(open).
action(flip(X)) :- lock(X).

Σ ∪ Dss ∪ Dap ∪ Duna ∪ DS0 ,
% defining the situation domain
nesting(0,s0).
nesting(L1,do(A,S)) :- nesting(L,S), #succ(L,L1),
action(A).
situation(S) :- nesting(L,S).
final(S) :- nesting(L,S), L = #maxint.

(10)

where
• Σ is the set of the foundational axioms;
• Dss is a set of successor state axioms of the form
F (x, do(a, s)) ↔ ΦF (x, a, s),

% basic axioms
fluent(F) & situation(S) & caused(F,t,S) -> h(F,S).
fluent(F) & situation(S) & caused(F,f,S) -> -h(F,S).

where ΦF (x, a, s) is a formula that is uniform in s (Reiter
2001) and whose free variables are among x, a, s;
• Dap is a set of action precondition axioms of the form
Poss(A(x), s) ↔ ΠA (x, s),

% D_caused
lock(X) & situation(S) & -final(S)
& poss(flip(X),S) ->
(h(up(X),S) -> caused(up(X),f,do(flip(X),S))).
lock(X) & situation(S) & -final(S)
& poss(flip(X),S) ->
(-h(up(X),S) -> caused(up(X),t,do(flip(X),S))).

where ΠA (x, s) is a formula that is uniform in s and
whose free variables are among x, s;
• Duna is the set of unique name axioms for fluents and
actions;
• DS0 is a set of first-order sentences that are uniform in S0 .

situation(S) & h(up(l1),S) & h(up(l2),S)
-> caused(open,t,S).

Translation into ASP
In the following, D is a finite BAT (10) whose signature contains finitely many predicate constants p, and D− is a theory
obtained from D by dropping (6).

% D_poss
lock(X) & situation(S) -> poss(flip(X),S).
% frame axioms
action(A) & situation(S) & -final(S) & fluent(F)
& poss(A,S) -> (-?[V]:caused(F,V,do(A,S)) ->
((h(F,do(A,S))->h(F,S)) & (h(F,S)->h(F,do(A,S))))).
% Holds is non-intensional
fluent(F) & situation(S) -> h(F,S) | -h(F,S).

Theorem 3 Let ΠFOL be the FOL-representation of the program obtained by applying translation F 2 LP on D− ∧ (8) in
which only predicate Sit is assumed to be intensional. Then
the models of SM[ΠFOL ; p, Sit, q] restricted to the signature
of D are precisely the models of D, where q is the list of all
new predicates introduced by the translation.
As with the case of Lin’s causal action theories, in order
to run ΠFOL using DLV- COMPLEX, we need to restrict the
domain of situations to be finite. Also axioms (3)–(5) can be
dropped since answer sets are Herbrand interpretations.

Figure 1: Lin’s Suitcase in the language of F 2 LP
We run F 2 LP on this theory to generate logic program
suitcase.lp and then call DLV- COMPLEX as follows:

Alternative Encoding in ASP

% dlv-complex -nofdcheck -N=1 suitcase.lp

In this section we consider an alternative encoding of BAT in
ASP, in which we do not need to provide explicit successor
state axioms Dss .
ASP-style BAT is of the form

“-N=1” sets the #maxint to be 1. DLV- COMPLEX returns
no answer set as expected.
Lin [1995] provides a computing method for his action
theories using completion. Since completion is weak to handle cycle and recursion, the limitation is noted in that paper.
This is not the case with our approach, which relies on the
stable model semantics. For instance, consider the Robby’s
apartment example from (Doğandağ, Ferraris, & Lifschitz
2004), in which Robby the robot has to find a plan to unlock
the doors so that any room is accessible from any other. A
part of the description shown below cannot be handled by
completion, but can be handled in our approach.

Σ∪Def f ect ∪Dprecond ∪DS0 ∪Duna ∪Dinertia ∪Dexogenous0
(11)
where
• Σ, DS0 , Duna are defined as before;
• Def f ect is a finite set of axioms of the form
+
γR
(x, a, s) → Holds(R(x), do(a, s))

(12)

or

Holds(Unlocked(x, y), s) → Caused(Accessible(x, y), true, s),
Holds(Unlocked(x, y), s) ∧ Caused(Accessible(y, z), true, s)
→ Caused(Accessible(x, z), true, s).
(9)

312

−
γR
(x, a, s) →∼ Holds(R(x), do(a, s)),
+
−
γR (x, a, s) and γR
(x, a, s) are formulas

(13)

where
that are
uniform in s and whose free variables are among x, a
and s;

Situation Calculus Planning in ASP

• Dprecond is a finite set of axioms of the form
πA (x, s) → Poss(A(x), s)
(14)
where πA (x, s) is a formula that is uniform in s and
whose free variables are among x, s;
• Dinertia is the set of the axioms
Holds(R(x), s) ∧ ¬ ∼ Holds(R(x), do(a, s))
→ Holds(R(x), do(a, s)),
∼ Holds(R(x), s) ∧ ¬Holds(R(x), do(a, s))
→ ∼ Holds(R(x), do(a, s))
for all fluent names R;
• Dexogenous0 is
Holds(R(x), S0 )∨ ∼ Holds(R(x), S0 )
for all fluent names R.
Note that Dinertia are axioms used in answer set planning to handle the frame problem (Lifschitz & Turner 1999).
Similarly, Dexogenous0 is used in ASP with strong negation
to represent that the initial value of a fluent is arbitrary.
We will show how this is related to Reiter’s BAT. Since we
are going to use strong negation, it is convenient to define the
following notion.
Let σ be a signature, let p be a set of predicate constants
in σ, and let σ p be a signature obtained from σ by adding
∼ p for all predicate constants p in p. We say that an interpretation I of σ p is complete on p if it satisfies
∀x(p(x)∨ ∼ p(x))
for every p in p.
Let I be a coherent interpretation of σ p that is complete
on p. By Ie we denote the interpretation of σ that agrees with
σ p on all constants not in p and for each p in p,

Not every situation is executable, but a plan is about executable situation. In (Reiter 2001), planning in situation calculus is described as follows: given a domain description D
and a situation calculus formula G(s) whose only free variable is s, a variable free situation term σ is a plan for G iff
D |= Executable(σ) ∧ G(σ)
where Executable(s) is an abbreviation of the formula
∀a, s∗ (do(a, s∗ ) ⊑ s → Poss(a, s∗ )).
Such σ can be obtained as a side-effect of proving the sentence ∃s(Executable(s) ∧ G(s)).
We provide an alternative method tailored to answer set
programming. We add to the domain description D the following axioms Dexecutable ,
Executable(S0 ),
Executable(s) ∧ Poss(a, s) ∧ ¬Final(s) → Executable(do(a, s)).
and a goal Dgoal ,
¬¬∃s(Executable(s) ∧ G(s)).
Given the program Πdescription obtained by applying
on the situation calculus description as explained
earlier, the answer sets of Πdescription ∪ Πsituation ∪
Dexecutable ∪ Dgoal contain all plans of length up to
#maxint. For instance, consider a simple planning problem to open the suitcase when the locks are initially down.
We add the following axioms to Figure 1.
F 2 LP

executable(s0).
executable(S) & poss(A,S) & -final(S)
& situation(S) & action(A) -> executable(do(A,S)).

• tI ∈ pI if tI ∈ pI
• tI ∈
/ pI if tI ∈ (∼ p)I .
′
Let Dss
be the set of successor state axioms
Holds(R(x), do(a, s)) ↔
−
Γ+
R (x, a, s) ∨ (Holds(R(x), s) ∧ ¬ΓR (x, a, s))

:- h(up(l1),s0).
:- h(up(l2),s0).
:- h(open,s0).
--?[S]: (executable(S) & h(open,S)).

+
where Γ+
R (x, a, s) is the disjunction of γR (x, a, s) for all
−
axioms (12) in Def f ect , and ΓR (x, a, s) is the disjunction of
−
γR
(x, a, s) for all axioms (13) in Def f ect .
′
By Dap
we denote the set of axioms
Poss(A(x), s) ↔ ΠA (x, s) where ΠA (x, s) is the disjunction of πA (x, s) for all axioms (14) in Dprecond .
In the following statement, for simplicity, we assume that
Σ does not contain the second-order axiom (6).7 Instead we
consider only the models I such that the domain of situation
is the smallest set S satisfying
• σ0 is in S, where σ0 = S0I ;
• if σ ∈ S and a is an element in the action domain,
doI (a, σ) is in S.
Theorem 4 Let T be a theory (11) of signature σ Holds . If I
−
satisfies ¬∃xas(Γ+
R (x, a, s) ∧ ΓR (x, a, s)) for every fluent
name R, then I satisfies SM[T ; Poss, Holds, ∼ Holds] iff Ie
′
′
satisfies the BAT Σ ∧ Dss
∧ Dap
∧ Duna ∧ DS0 .

When #maxint is 1, F 2 LP and DLV- COMPLEX
find no answer set and when #maxint is 2,
they find the unique answer set that contains both
h(open,do(flip(l2),do(flip(l1),s0))) and
h(open,do(flip(l1),do(flip(l2),s0))), each
of which encodes a plan. In other words, the single answer
set contains multiple plans in different branches of the
situation tree.

Related Work
Prolog provides a natural implementation for basic action
theories since definitional axioms can be represented by Prolog rules according to the Clark’s theorem (Reiter 2001,
Chapter 5). The Lloyd-Topor transformation that is used to
turn formulas into Prolog rules is similar to the translation
F 2 LP , but they are different in that the former preserves the
completion semantics and the latter the stable model semantics.
Gelfond & Lifschitz [1993] introduce action language A
and provide a translation from A to logic programs based

7
Alternatively, we can consider extending the notion SM[F ] to
second-order formula F , or as before consider (8) instead.

313

References

on the situation calculus approach. Their work was followed by several others. Lin & Wang [1999] provide an approach to generate successor state axioms from a restricted
set of “clausal” causal theories using answer set solvers. Our
translation scheme is close to (Kim, Lee, & Palla 2009),
which shows how to turn the event calculus into answer set
programming. There the ASP-based event calculus reasoner
was shown to be faster than the SAT-based DEC reasoner,
thanks to efficient grounding methods implemented in ASP
solvers. We expect that our ASP-based situation calculus
reasoning is efficient as well. However, to the best of our
knowledge, there is no other implementation that we can directly compare with in the propositional case.
Kautz & Selman [1992] introduce linear encodings that
are similar to a propositionalized version of situation calculus (McCarthy & Hayes 1969). Lin [2003] introduces an
action description language and describes a procedure that
generates successor state axioms. The soundness of the procedure is shown with respect to a translation from action
domain descriptions into his causal theories. (Claßen et al.
2007) proposes an integration of Golog with the state-of-theart PDDL planner FF, and shows the performance improvements over the original Golog. Alternatively an ASP based
situation calculus reasoner may substitute for FF, which
would enable us to perform more expressive reasoning tasks
than what Golog+FF can handle. It will be also interesting
to compare the performance of Golog+ASP with Golog+FF.

Cabalar, P.; Pearce, D.; and Valverde, A. 2005. Reducing propositional theories in equilibrium logic to logic programs. In Proceedings of Portuguese Conference on Artificial Intelligence (EPIA), 4–17.
Claßen, J.; Eyerich, P.; Lakemeyer, G.; and Nebel, B. 2007.
Towards an integration of golog and planning. In Proc. IJCAI, 1846–1851.
Doğandağ, S.; Ferraris, P.; and Lifschitz, V. 2004. Almost
definite causal theories. In Proc. LPNMR, 74–86.
Ferraris, P.; Lee, J.; and Lifschitz, V. 2007. A new perspective on stable models. In Proc. IJCAI, 372–379.
Ferraris, P.; Lee, J.; and Lifschitz, V. 2010. Stable models
and circumscription. 8 Artificial Intelligence. To appear.
Gelfond, M., and Lifschitz, V. 1993. Representing action
and change by logic programs. Journal of Logic Programming 17:301–322.
Giunchiglia, E.; Lee, J.; Lifschitz, V.; McCain, N.; and
Turner, H. 2004. Nonmonotonic causal theories. Artificial
Intelligence 153(1–2):49–104.
Kautz, H., and Selman, B. 1992. Planning as satisfiability.
In Proceedings of European Conference on Artificial Intelligence (ECAI), 359–363.
Kim, T.-W.; Lee, J.; and Palla, R. 2009. Circumscriptive
event calculus as answer set programming. In Proc. IJCAI,
823–829.
Lee, J., and Palla, R. 2009. System F 2 LP – computing answer sets of first-order formulas. In Proc. LPNMR, 515–521.
Lifschitz, V., and Turner, H. 1999. Representing transition
systems by logic programs. In Proc. LPNMR, 92–106.
Lifschitz, V. 1994. Circumscription. Handbook of Logic
in AI and Logic Programming, volume 3. Oxford University
Press. 298–352.
Lin, F., and Wang, K. 1999. From causal theories to logic
programs (sometimes). In Proc. LPNMR, 117–131.
Lin, F. 1995. Embracing causality in specifying the indirect
effects of actions. In Proc. IJCAI, 1985–1991.
Lin, F. 2003. Compiling causal theories to successor state
axioms and STRIPS-like systems. Journal of Artificial Intelligence Research 19:279–314.
McCarthy, J., and Hayes, P. 1969. Some philosophical problems from the standpoint of artificial intelligence. Machine
Intelligence, volume 4. Edinburgh: Edinburgh University
Press. 463–502.
Mueller, E. T. 2004. Event calculus reasoning through satisfiability. Journal of Logic and Computation 14(5):703–730.
Reiter, R. 2001. Knowledge in Action: Logical Foundations
for Specifying and Implementing Dynamical Systems. MIT
Press.

Conclusion
In this paper, we show how Lin’s causal theories and Reiter’s basic action theories can be reformulated in terms of
the first-order stable model semantics. Under the assumption that the domain is given and finite, system F 2 LP can be
used to turn the resulting formulas under the stable model
semantics into answer set programs so that DLV- COMPLEX
can be used for computing the propositional models of the
situation calculus description. In comparison with the computing method based on completion given in (Lin 1995), our
ASP-based method can handle recursive axioms that cannot be handled by completion. Also we show an ASP-style
encoding for Reiter’s BAT, which tells us how the solution
to the frame problem in ASP is related to the solution employed in BAT.
Our work shows that the first-order stable model semantics is useful in relating classical logic based action formalisms to answer set programming. The translations introduced in this paper would have been more complicated if
we did not involve the first-order stable model semantics.
Acknowledgements: We are grateful to Vladimir Lifschitz
for useful discussions related to this paper. This research
was partially supported by the National Science Foundation
under grants IIS-0916116 and by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced
Research Projects Activity (IARPA), through US army. All
statements of fact, opinion or conclusions contained herein
are those of the authors and should not be construed as representing the official views or policies of IARPA, the ODNI
or the U.S. Government.

8

314

http : //peace.eas.asu.edu/joolee/papers/smcirc.pdf.

Describing Additive Fluents in Action Language C+
Joohyung Lee and Vladimir Lifschitz
Department of Computer Sciences,
University of Texas, Austin, TX 78712
{appsmurf,vl}@cs.utexas.edu

Abstract
An additive fluent is a fluent with numerical values
such that the effect of several concurrently executed
actions on it can be computed by adding the effects
of the individual actions. We propose a method for
describing effects of actions on additive fluents in
the declarative language
An implementation of
this language, called the Causal Calculator, can be
used for the automation of examples of commonsense reasoning involving additive fluents.

1

Introduction

Action languages [Gelfond and Lifschitz, 1998] serve to describe effects of actions on the states of the world. For instance, the expression
Walk

causes Location(x) = /

of the individual actions. For example, the gross receipts of
a store are represented by an additive fluent: when several
customers pay to different cashiers simultaneously, the gross
receipts will increase by the sum of the "contributions" of the
individual customers. The voltage of a battery is an additive fluent: the increase in voltage obtained by adding several
cells to a battery can be computed by addition. In mechanics, the velocity of a particle is an additive fluent, because the
net effect of several forces on this fluent over a time interval
equals the sum of the effects of the individual forces. Additive fluents are ubiquitous; this may be the reason why adding
numbers is such a useful operation.
Unfortunately, the causes construct of
and similar languages is not directly applicable to describing the effects of
actions on additive fluents. Consider, for instance, the effect
of the action Buy
(customerbuys
books) on the
number of books available at the bookstore. The causal law

(1)

(2)

is a proposition, or "causal law," of action language
[Giunchiglia et al, 2003] that describes an effect of action Walk
: this action causes the location of to become /. The semantics of action languages is defined in
terms of "transition systems"—directed graphs whose vertices correspond to the states of the world, and whose edges
correspond to the execution of actions. The execution of a
sequence of actions can be represented by a path in such a
graph.
Some action languages, including _ , allow us to
talk about the effects of the concurrent execution of actions. Causal law (1) is understood in
to imply that
Location
holds after any event that involves the execution of Walk
, even if other actions are executed concurrently. To distinguish the events involving the concurrent
execution of actions a1 and < from the events that involve
but not
we can write

is applicable in the case when no customer other than
is
buying books at the same time:
books are available
after the event if there were books in the store before the
event. But (2) is not acceptable if we are interested in the
concurrent execution of such actions.
We introduce here a syntactic construct, increments, that
allows us to describe the effects of actions on additive fluents.
Semantically this construct is treated as "syntactic sugar"
on top of
the propositions involving that construct are
viewed as abbreviations for causal laws of
The interpretation of increments described below has been used to extend the implementation of
called the Causal Calculator
( C C A L C ) , to cover additive fluents.
After a review of transition systems and of the syntax of
in the next two sections, we describe the syntax of increment
laws (Section 4), define their semantics by showing how to
treat them as abbreviations (Section 5), and illustrate the use
of additive fluents in the language of CCALC by formalizing
an example that involves buying and selling (Section 6). Two
other examples of commonsense reasoning related to additive fluents are discussed in Sections 7 and 8. A proposition
stated in Section 9 confirms that additive fluents behave as
one would expect on the basis of the informal discussion of
additivity above, and thus provide a justification for the approach to formalizing additive fluents proposed in this paper.

In this paper we investigate the possibility of using i
to
represent the effects of actions on fluents of a special kind,
called "additive." An additive fluent is a fluent with numerical values such that the effect of several concurrently executed actions on it can be computed by adding the effects

REASONING ABOUT ACTIONS AND CHANGE

1079

diagonal edges correspond to Alice and Bob buying books
concurrently.

3

Syntax of C+

The review of the syntax of C+ in this section follows
[Giunchigiia et al., 2003, Section 4.2]. An atom is an expression of the form
where c is a constant and
Dom(c).
For instance, the equalities in Figure 1 are atoms. A formula
is a propositional combination of atoms. By a fluent formula
we mean a formula such that all constants occurring in it are
fluent constants. An action formula is a formula that contains
at least one action constant and no fluent constants.
A static law is an expression of the form
caused F if G
Figure 1: A transition system.

2

Transition Systems

Consider a set of symbols, called constants, along with a nonempty finite set of symbols Dom(c) assigned to each constant c. We call Dom(c) the domain of
The constants are divided into two groups—fluent constants and action constants. Intuitively, a fluent constant represents a fluent, and the elements of its domain are the possible values of that fluent. A state of the world is characterized
by a function that maps each fluent constant to an element of
its domain. In [Giunchiglia et al., 2003, Section 4.2], fluent
constants are further subdivided into simple and statically determined; in the examples below, only fluent constants of the
first kind will be used.
A function that maps each action constant to an element
of its domain characterizes an event occurring over a time
interval between two successive states. In many examples of
the use of
the domain of every action constant is the set
of truth values
constants with this domain are called
Boolean. Intuitively, a Boolean action constant represents an
action; the value of such a constant is t if the action is one of
those that are executed as part of the event.
A transition system is a directed graph whose vertices are
functions that map every fluent constant to an element of its
domain, and whose edges are labeled by functions that map
every action constant to an element of its domain. The vertices of a transition system are called its states. The functions
labeling the edges of a transition system are called events.
As an example, consider a transition system representing the
effect of buying a book on the number of books that the person owns (Figure 1). It uses two fluent constants—Has(A)
(the number of books that Alice has) and Has(B) (the number of books that Bob has)—with the domain { 0 , . . . , N},
where N is a fixed nonnegative integer, and two Boolean
action constants—Buy(A) (Alice buys a book) and Buy(B)
(Bob buys a book). Every state is represented by two equations showing the values of the fluent constants. Every event
is represented by the set of action constants that are mapped
to t. The loops are labeled by the trivial event 0 (no actions
are executed). The horizontal edges are labeled by the event
in which Alice buys a book and Bob doesn't; along each of
the vertical edges, Bob buys a book and Alice doesn't. The

1080

(3)

where F and G are fluent formulas. An action dynamic law is
an expression of the form (3) in which F is an action formula
and G is a formula. A fluent dynamic law is an expression of
the form
caused F if G a f t e r H
(4)
where F and G are fluent formulas and H is a formula, provided that F does not contain statically determined constants.
A causal law is a static law, or an action dynamic law, or a fluent dynamic law.
Here are two examples. The expression

, ,
where
for the fluent dynamic law

k

(5)

is an abbreviation

is an abbreviation for the fluent dynamic law
is the 0-place connective "false").
Causal laws (5) and (6) describe an effect of action Buy
and a restriction on its executability. To get a complete description of Figure 1 in language
we need two more postulates. First, we should specify that the edge labels of the
transition system may assign truth values to the action constants Buy
arbitrarily. This is expressed by
exogenous Buy

(7)

which stands for the pair of action dynamic laws

Action Buy
is exogenous in the sense that the action description does not determine whether that action is executed.
If it is not executed then there is a cause for this; if it is executed then there is a cause for that too. Second, we need
to say that the fluent constant Has
satisfies the "commonsense law of inertia": in the absence of evidence to the contrary, its value after an event is assumed to be the same as its
value before the event. This is expressed by
i n e r t i a l Has

(8)

REASONING ABOUT ACTIONS AND CHANGE

which stands for

fluent dynamic laws

Notation: x ranges over {A, B}.

caused Has
If the value of Has
after an event is the
same as the value before the event then there is a cause for
this. Intuitively, inertia is the cause.
An action description is a set of causal laws. The semantics
of
described in [Giunchiglia et al, 2003, Section 4.4],
specifies the transition system represented by any given action description. For instance, action description (5)-(8) represents the transition system shown in Figure 1.
This action description does not say explicitly that the trivial event has no effect on the values of Has(A) and Has(B),
or that event
does not affect the value of Has(B).
Nevertheless, every edge of the transition system labeled is
a loop, and every edge labeled
is horizontal, because of the postulates (8) that express, under the semantics
of
the persistence property of Has(x).
Similarly, causal laws (5)-(8) do not say anything about the
concurrent execution of actions Buy(A) and Buy(B). But the
edges labeled
in Figure 1 are directed diagonally, in accordance with our commonsense expectations.
This fact illustrates the convenience of the approach to concurrency incorporated in the semantics of
However, as discussed in the introduction, this built-in
mechanism is not directly applicable to the effects of actions
on additive fluents. We are now ready to turn to the main subject of this paper—extending
with the additional notation
that resolves this difficulty.

4

Increment Laws

In our proposed extension of
some of the simple fluent
constants can be designated as additive. The domain of every
additive fluent constant is assumed to be a finite set of numbers. We understand "numbers" as (symbols for) elements of
any set with an associative and commutative binary operation
that has a neutral element 0.' Effects of actions on additive
fluents are described in extended
by causal laws of a new
kind—"increment laws." Accordingly, we modify the definition of a causal law reproduced in Section 3 in two ways.
First, in causal laws (3) and (4) formula F is not allowed to
contain additive fluent constants. Second, we extend the class
of causal laws by including increment laws—expressions of
the form
a i n c r e m e n t s c by

if G

(9)

where
is a Boolean action constant,
is an additive fluent constant,
is a number, and
is a formula that contains no Boolean action constants.
[
Thc additive group of integers is the main example we are interested in, and this is the case that has been implemented. The max
operation on an ordered set with the smallest element is another interesting case.

REASONING ABOUT ACTIONS AND CHANGE

Action constants:
Buy

Domains:
Boolean

Additive fluent constant:
InStore

Domain:

Causal laws:
Buy
i n c r e m e n t s InStore by —1
exogenous Buy
Figure 2: An action description in extended C+.

Figure 3: The transition system described by Figure 2.
We will drop ' i f G' in (9) if G is T. In extended
an action
description is a set of causal laws that contains finitely many
increment laws.
In the next section we define the semantics of extended
by describing a translation that eliminates increment laws in
favor of additional action constants.
As an example, consider the effects of actions Buy (A),
Buy(B) on the number of books available in the bookstore
where Alice and Bob are buying books. A description of
these effects in extended
is shown in Figure 2 (as before,
TV is a fixed nonnegative integer). The transition system represented by the translation of Figure 2 into the non-extended
language
is depicted in Figure 3 (with the auxiliary action
constants dropped from the edge labels). The causal laws in
Figure 2 do not say explicitly that the trivial event has no
effect on the value of InStore, or that the concurrent execution
of actions Buy(A) and Buy(B) decrements the value of this
fluent by 2. Nevertheless, every edge of the corresponding
transition system labeled is a loop, and every edge labeled
goes up 2 levels, in accordance with our
commonsense expectations. This happens because Figure 2
classifies InStore as an additive fluent constant.
The causal laws in this action description do not say explicitly that actions Buy
are not executable when InStore = 0,
and that actions Buy(A), Buy(B) cannot be executed concurrently when InStore = 1. This is taken care of by our semantics of increment laws, in view of the fact that the domain
of InStore does not contain negative numbers.

1081

5

Translating Increment Laws

Notation:

Let D be an action description in extended i . In connection
with the increment laws (9) in / ) , the following terminology
will be used: about the Boolean action constant the additive
fluent constant c and the number in (9) we will say that
is a c-contributing constant, and that is a contribution of
to c.
The auxiliary action constants introduced in the translation
are expressions of the form Contr
where c is an additive
fluent constant, and a is a c-contributing action constant. The
domain of Contr
consists of all contributions of to c
and number 0.
To translate the increment laws from D, we

ranges over {A, B}.

Action constants:
Buy
Contr(Buy\
InStore)
Additive fluent constant:
InStore

(i) replace each increment law (9) in D with the action dynamic law
(10)
(ii) for every auxiliary constant Contr(a,c), add the action
dynamic law
caused

ConU

Figure 4: The result of translating increment laws from Figure 2.

(11)
in Figure 3 represent the following event E:

(iii) add the fluent dynamic laws
caused

(12)

for every additive fluent constant
and every function
that maps each
contributing constant a to an element of the domain of
Contr
so t h a t ~ ~
is in the domain of c.
The sum and the multiple conjunction in (12) range over all
c-contributing constants
Causal law (10) interprets increment law (9) as the assertion that executing (possibly along with other actions)
causes constant Contr
to get the value
under some
conditions characterized by formula G. Causal laws (11) say
that the value of this constant is 0 by default, that is to say,
when another value is not required by any increment law.
Causal laws (12) say that the value of an additive fluent constant after an event can be computed as the sum of the value
of this constant prior to the event and the contributions of all
actions to this constant.
The result of translating increment laws from Figure 2
is shown in Figure 4. In this case, the translation described above introduces two auxiliary action constants:
Contr{Buy{A), InStore) and Contr{Buy{B), InStore). The
domain of each of them has 2 elements: the contribution -1
of #MV(X) to InStore and number 0.
The edges of the transition system described by Figure 4,
and the corresponding events, can be computed using the
methods presented in [Giunchiglia et al.n 2003, Sections 4.2,
2.6]. (This calculation involves turning the action description into a definite causal theory and computing the models of the completion of this theory.) Every event assigns
values to each action constant, including the auxiliary constants Contr(Buy
InStore). For instance, the label

1082

The Causal Calculator, which implements
with increment laws, can be downloaded from
h t t p : //www.cs.utexas.edu/users/tag/ccalc/ .

6

Reasoning about Money

As an application of these ideas to automated commonsense
reasoning, consider the following example:
I have $6 in my pocket. A newspaper costs $ 1, and
a magazine costs $3. Can 1 buy 2 newspapers and a
magazine? A newspaper and 2 magazines?
These questions are about the executability of some concurrently executed actions, and the answers are determined by
the effect of these actions on an additive fluent—the amount
of money that 1 have.
Figure 5 describes the relevant properties of buying and
selling in the input language of C C A L C . There arc objects
of four sorts in this domain: agents, resources, items (to be
purchased) and (nonnegative) integers; items are a subset of
resources. The buyer and the seller are agents; money is a
resource; 0 , . . . ,maxlnt are integers. The price of an item is
an integer. The number of units of a resource that an agent
has is an integer-valued additive fluent. Buying is an exogenous action. The four causal laws that follow these declarations are self-explanatory; d e c r e m e n t s is an abbreviation
defined in terms of i n c r e m e n t s . The last causal law expresses that the number of units that are being purchased is
uniquely defined.
Figure 6 expresses the first of the two questions stated at
the beginning of this section. The line m a x s t e p : :
1
tells CCALC that the query is about paths of length 1 in the
transition system. The question is whether the transition system contains an edge that begins in a state in which the buyer

REASONING ABOUT ACTIONS AND CHANGE

- sorts
agent;

r e s o u r c e >> i t e m ;

nnlnteger.

variables
Ag :: a g e n t ;
It :: item;

Res : : r e s o u r c e ;
M,N : : n n l n t e g e r .

objects
buyer,seller
money
0..maxlnt

: agent;
: resource;
: nnlnteger.

: - constants
price(item)
:: nnlnteger;
has(agent,resource)
:: additiveFluent(nnlnteger);
b u y ( i t e m , n n l n t e g e r ) : : exogenousAction.
buy(It,N)
buy(It,N)
buy(It,N)
by M*N

i n c r e m e n t s h a s ( b u y e r , I t ) by N.
decrements h a s ( s e l l e r , I t ) b y N .
increments has(seller,money)
if p r i c e ( I t ) = M
where M*N =< m a x l n t .
b u y ( I t , N ) decrements has(buyer,money)
b y M*N i f p r i c e ( I t ) = M
where M*N =< m a x l n t .
nonexecutable b u y ( I t , M ) & b u y ( I t , N )
where M\=N.

and planets, the Integer is not affected by any external forces.
As its proud name suggests, the mass of the spacecraft is an
integer. For every integer the coordinates and all three components of the Integer's velocity vector at time are integers;
the forces applied to the spacecraft by its jet engines over
the interval
for any integer are constant vectors
whose components are integers as well. If the crew of the Integer attempts to violate any of these conditions, the jets fail
to operate!
Our formalization of the motion of the Integer uses the fluents Pos where a ranges over {X, Y, Z } , to represent the
current position of the Integer along the a axis. The additive
fluents Vel
are the components of its velocity. According
to Newton's Second Law, the acceleration created by firing a
jet can be computed by dividing the force by the mass of the
spacecraft. This relationship can be expressed without mentioning the acceleration explicitly—in terms of the change in
the velocity over a unit time interval:
Fire(j) i n c r e m e n t s Vel

objects
newspaper,magazine

price(newspaper)=1.

::

item.

price(magazine)=3.

: - query
maxstep : : 1 ;
0: has(buyer,money)=6,
buy(newspaper,2),
buy(magazine,1).
Figure 6: Do I have enough cash?
has $6, and whose label includes buying 2 newspapers and 1
magazine. CCALC responds to this query by finding such an
edge.2 Its reply to a similar question about 1 newspaper and
2 magazines is negative.

7

Reasoning about Motion

Some additive fluents mentioned in the introduction—for instance, the velocity of a particle—are real-valued, rather than
integer-valued. CCALC cannot deal with real numbers yet,
and its input language does not allow us to express properties
of such fluents.
But let's imagine a movable object that is immune to this
complication—the spacecraft Integer. Far away from stars
2

This example involves the concurrent execution of two actions,
but in general the CCALC implementation of additive fluents does
not impose any specific restriction on the number of actions that can
be executed concurrently.

REASONING ABOUT ACTIONS AND CHANGE

/Mass {{Force

To test our representation, we instructed C C A L C to answer
the following question:
The mass of the Integer is 1. The Integer has two
jets, and the force that can be applied by each jet
along each axis is at most 2. The current position
of the Integer is ( - 1 , 0 , 1 ) , and its current velocity
is (0,1,1). How can it get to (0,3,1) within 1 time
unit?

Figure 5: Buying and selling
:-

by

One of the solutions found by CCALC is to apply the forces
(2,2,0) and ( 0 , 2 , - 2 ) .

8

Missionaries and Cannibals with Two Boats

In the Missionaries and Cannibals Problem (MCP), three missionaries and three cannibals come to a river and find a boat
that can hold two people. If the cannibals ever outnumber the
missionaries on either bank, the missionaries will be eaten.
How shall they cross? The shortest solution involves 11 steps.
Lifschitz [2000] showed how to express this puzzle and
some of its elaborations due to McCarthy [1999] in the language of C C A L C . Some simple elaborations of MCP in the
spirit of this work require that the number of members of
a group (missionaries or cannibals) at a given location be
treated as an additive fluent. This is the case, for instance,
when several boats are available and are allowed to operate
concurrently.
Using the ideas of this paper, we formalized the modification of MCP in which the travelers find two boats: a small
boat that holds one, and a bigger boat that holds two. Using
our formalization, CCALC has determined that the modified
problem can be solved in 7 steps.

9

Properties of Additive Constants

By examining Figure 3 in isolation from its symbolic description in Figure 2 we can see that the constant In Store exhibits
some features typical for additive fluent constants.
Consider, for instance, the edges that start at the vertex
InStore = 2 and are labeled by the events {Buy(A)} and

1083

{Buy(B)}. Each of them leads to the vertex InStore = 1,
so that each of these two events, when it occurs in the
state InStore = 2, increments the value of InStore by - 1 .
In accordance with the intuitive idea of an additive fluent,
we can expect that the "union" of these events, when it occurs in the same state, will increment the value of InStore
by
And this is true, because the edge in Figure 3 that starts at the vertex InStore = 2 and is labeled
leads to the vertex InStore = 0.
Proposition 1 below generalizes this observation to a class
of action descriptions in the language C+ extended as described in Sections 4, 5. By D we denote any action description in this language.
About events
in the transition system
represented by D we say that eo is a disjoint union of
if, for every Boolean action constant a,
t then there exists a unique
for this
boolean action constant

such that
= t o r every

non-

then, for all
In the rest of this section we assume that the set of numbers
is a commutative group.

It is interesting to note that this treatment of additive
fluents would have been impossible if, instead of C+, we
used its predecessor C from IGiunchiglia and Lifschitz,
1998]. Non-Boolean, non-exogenous action constants such
as Contr(a, c), and action dynamic laws such as (10) and (11)
are among the features of C+ that were not available in C.
In literature on planning, fluents with numerical values are
often referred to as "resources" fKoehler, 1998]. The concurrent execution of the actions that involve resources is usually
limited to the "serializable" case, when all ways of sequencing the concurrent actions are well-defined and equivalent.
This condition is not satisfied, however, for many uses of additive fluents, including the space travel example (Section 7)
and the modified MCP (Section 8). Consider, for instance,
the state with two cannibals and three missionaries on the first
bank, and imagine that the missionaries are using both boats
to cross simultaneously. The concurrent execution of the actions cannot be replaced by the larger boat crossing first and
the smaller boat crossing after that—in the state between the
two actions, the missionaries on the first bank would be outnumbered by the cannibals. This example shows that crossing
the river in the modified MCP is not serializable.

Acknowledgements
We are grateful to Yuliya Babovich, Jonathan Campbell, Esra
Erdem, Selim Erdogan, Paolo Ferraris and Wanwan Ren for
useful discussions related to the subject of this paper. This
work was partially supported by the National Science Foundation under Grant IIS-9732744 and by the Texas Higher Education Coordinating Board under Grant 003658-0322-2001.

References
The special case corresponding to
=0 tells us that additive fluent constants are not affected by "trivial" events. In
this sense, they are similar to the fluent constants for which
inertia is postulated:
Corollary 1 Let e be an event such that for every Boolean
action constant
If the transition system represented by D contains an edge that leads from a state s to
a state $' and is labeled e then, for any additive fluent constant c, $'(c) = s(c).
The special case corresponding to n = 1 implies that the
effects of any set of actions on an additive fluent is deterministic:
Corollary 2 // the
tains an edge that
labeled e, and an
is also labeled e,
So{c) = 5 i ( c ) .

10

transition system represented by D conleads from state s to state so and is
edge that leads from s to state si and
then, for any additive fluent constant c,

Discussion

In this paper we showed how an implemented, declarative
language for describing actions can be used to talk about
the effects of actions on additive fluents. This was accomplished by extending the syntax of the action language C+
from iGiunchiglia et ai, 2003] by increment laws and by
showing how to treat these laws as abbreviations.

1084

[Gelfond and Lifschitz, 1998] Michael
Gelfond
and
Vladimir Lifschitz.
Action languages.3
Electronic
Transactions on AI, 3:195-210, 1998.
IGiunchiglia and Lifschitz, 1998] Enrico Giunchiglia and
Vladimir Lifschitz. An action language based on causal
explanation: Preliminary report. In Proc. AAAI-98, pages
623-630. AAA1 Press, 1998.
[Giunchiglia e/ al, 20031 Enrico Giunchiglia, Joohyung
Lee, Vladimir Lifschitz, Norman McCain, and Hudson
Turner.
Nonmonotonic causal theories.4
Artificial
Intelligence, 2003. To appear.
[Koehler, 1998] J ana Koehler. Planning under resource constraints. In Proc. ECAI-98, pages 489-493, 1998.
iLifschitz, 2000] Vladimir Lifschitz. Missionaries and cannibals in the Causal Calculator. In Principles of Knowledge Representation and Reasoning: Proc. Seventh Int'l
Conf, pages 85-96, 2000.
[McCarthy, 1999] John McCarthy. Elaboration tolerance.5
In progress, 1999.
3 h t t p : / / w w w . e p . l i u . s e / e a / c i s / 1 9 9 8 / 0 1 6 /

.

4 h t t p : / / w w w . c s . u t e x a s . e d u / u s e r s / v l / p a p e r s /

nmct.ps .
5http://www-formal.stanford.edu/jmc/

elaboration.html

.

REASONING ABOUT ACTIONS AND CHANGE

Journal of Artificial Intelligence Research 42 (2011) 125-180

Submitted 03/11; published 10/11

First-Order Stable Model Semantics
and First-Order Loop Formulas
Joohyung Lee
Yunsong Meng

joolee@asu.edu
Yunsong.Meng@asu.edu

School of Computing, Informatics,
and Decision Systems Engineering
Arizona State University
Tempe, AZ 85287, USA

Abstract
Lin and Zhao’s theorem on loop formulas states that in the propositional case the stable
model semantics of a logic program can be completely characterized by propositional loop
formulas, but this result does not fully carry over to the first-order case. We investigate
the precise relationship between the first-order stable model semantics and first-order loop
formulas, and study conditions under which the former can be represented by the latter.
In order to facilitate the comparison, we extend the definition of a first-order loop formula
which was limited to a nondisjunctive program, to a disjunctive program and to an arbitrary
first-order theory. Based on the studied relationship we extend the syntax of a logic program
with explicit quantifiers, which allows us to do reasoning involving non-Herbrand stable
models using first-order reasoners. Such programs can be viewed as a special class of firstorder theories under the stable model semantics, which yields more succinct loop formulas
than the general language due to their restricted syntax.

1. Introduction
According to the theorem on loop formulas (Lin & Zhao, 2004), the stable models of a
logic program (Gelfond & Lifschitz, 1988) can be characterized as the models of the logic
program that satisfy all its loop formulas. This idea has turned out to be widely applicable
in relating the stable model semantics to propositional logic, and has resulted in an efficient
method for computing answer sets using SAT solvers. Since the original invention of loop
formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been
extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee,
Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model
semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu &
Truszczynski, 2006; You & Liu, 2008). The theorem has also been applied to other nonmonotonic formalisms, such as nonmonotonic causal theories (Lee, 2004) and McCarthy’s
circumscription (Lee & Lin, 2006). The notion of a loop was further refined as an “elementary loop” (Gebser & Schaub, 2005; Gebser, Lee, & Lierler, 2006, 2011). However,
all this work is restricted to the propositional case. Variables contained in a program are
first eliminated by grounding—the process which replaces every variable with every object
constant—and then loop formulas are obtained from the ground program. As a result, loop
formulas were defined as formulas in propositional logic.
c

2011
AI Access Foundation. All rights reserved.

Lee & Meng

Chen, Lin, Wang, and Zhang’s definition (2006) of a first-order loop formula is different
in that loop formulas are directly obtained from a non-ground program, so that they are
first-order logic formulas which retain variables. However, since the semantics of a logic
program that they refer to is based on grounding, these first-order loop formulas are simply
understood as schemas for ground loop formulas, and only Herbrand models of the loop
formulas were considered in this context.
The stable model semantics that does not involve grounding appeared a year later
(Ferraris, Lee, & Lifschitz, 2007, 2011). The authors define the stable models of a firstorder sentence F as the models of the second-order sentence that is obtained by applying
the “stable model operator” SM to F . The definition of SM is close to the definition of the
circumscription operator CIRC (McCarthy, 1980, 1986). Under the first-order stable model
semantics, logic programs are viewed as a special class of first-order theories. A similar
definition of a stable model was given by Lin and Zhou (2011), via logic of knowledge
and justified assumption (Lin & Shoham, 1992). The first-order stable model semantics is
also closely related to quantified equilibrium logic (Pearce & Valverde, 2005), and indeed,
Ferraris et al. (2011) showed that they are essentially equivalent.
A natural question arising is how first-order loop formulas and the first-order stable
model semantics are related to each other. In general, the first-order stable model semantics
is more expressive than first-order logic, and as such cannot be completely characterized
by first-order loop formulas. Like circumscription, the concept of transitive closure can
be represented in the first-order stable model semantics, but not in any set of first-order
formulas, even if that set is allowed to be infinite.1 However, as we show in this paper,
understanding the precise relationship between them gives us insights into the first-order
stable model semantics and its computational properties.
In order to facilitate the comparison, we extend the definition of a first-order loop
formula which was limited to nondisjunctive programs, to disjunctive programs and to
arbitrary first-order theories. Also we present a reformulation of SM[F ] in the style of loop
formulas, which includes the characterization of a loop by a syntactic formula. From this
formulation, we derive several conditions, under which a first-order theory under the stable
model semantics can be equivalently rewritten as first-order loop formulas.
Based on the relationship between the first-order stable model semantics and first-order
loop formulas, we extend the syntax of logic programs with explicit quantifiers, which may be
useful in overcoming some limitations of traditional answer set programs in reasoning about
non-Herbrand models. We define the semantics of such extended programs by identifying
them as a special class of first-order theories under the stable model semantics. Such
programs inherit from the general language the ability to handle nonmonotonic reasoning
under the stable model semantics even in the absence of the unique name and the domain
closure assumptions that are built into the grounding-based answer set semantics. On
the other hand, the restricted syntax of an extended program leads to more succinct loop
formulas. The following program Π1 is a simple insurance policy example represented in

1. Vladimir Lifschitz, personal communication.

126

First-Order Stable Model Semantics and First-Order Loop Formulas

this syntax.
HasWife(x)
HasWife(x)
Married (x)
∃w Discount(x, w)

←
←
←
←

∃y Spouse(x, y)
Man(x), Married (x)
Man(x), HasWife(x)
Married (x), not ∃z Accident(x, z).

The second and the third rules express that Married (x) and HasWife(x) are synonymous
to each other when x is a Man. The last rule states that x is eligible for some discount
plan (with the name unknown) if x is married and has no record of accident. The quantifier
in the first rule can be dropped without affecting the meaning, but the other quantifiers
cannot. We will say that a program Π entails a query F (under the stable model semantics)
if every stable model of Π satisfies F . For example,
• Π1 conjoined with Π2 = {Man(John)} entails each of ¬∃x Married (x) and
¬∃xy Discount(x, y).
• Π1 ∪ Π2 conjoined with Π3 = {∃y Spouse(John, y)} entails neither ¬∃x Married (x)
nor ¬∃xy Discount(x, y), but entails each of ∃x Married (x), ∃xyDiscount(x, y), and
∀xy(Discount(x, y) → x = John).
• Π1 ∪ Π2 ∪ Π3 conjoined with Π4 = {∃z Accident(John, z)} does not entail
∀xy(Discount(x, y) → x = John), but entails ¬∃w Discount(John, w).
The nonmonotonic reasoning of this kind requires non-Herbrand models since the names
(or identifiers) of discount plans, spouses and accident records may be unknown. However,
the traditional answer set semantics is limited to Herbrand models due to the reference
to grounding. By turning the program into first-order loop formulas we can automate the
example reasoning using a first-order theorem prover.
The paper is organized as follows. The next section reviews the first-order stable model
semantics by Ferraris et al. (2007, 2011). Section 3 reviews the theorem on first-order loop
formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary
first-order sentences, limiting attention to Herbrand stable models. Section 4 extends these
results to allow non-Herbrand stable models as well (possibly allowing functions) under a
certain semantic condition, and compare the first-order stable model semantics with loop
formulas by reformulating the former in terms of the latter. In Section 5, we present a series
of syntactic conditions that imply the semantic condition in Section 4. Section 6 provides an
extension of logic programs that contain explicit quantifiers and shows how query answering
for such extended programs can sometimes be reduced to entailment checking in first-order
logic via loop formulas. In Section 7, the results are further extended to distinguish between
intensional and non-intensional predicates. Related work is described in Section 8, and long
proofs are given in Appendix A.
This article is an extended version of a conference paper by Lee and Meng (2008).

2. Review of the First-Order Stable Model Semantics
This review follows a journal paper by Ferraris et al. (2011) that extends a conference
paper by the same authors (Ferraris et al., 2007) by distinguishing between intensional and
non-intensional predicates.
127

Lee & Meng

A formula is defined the same as in first-order logic. A signature consists of function
constants and predicate constants. Function constants of arity 0 are called object constants.
We assume the following set of primitive propositional connectives and quantifiers:
⊥ (falsity), ∧, ∨, →, ∀, ∃ .
¬F is an abbreviation of F → ⊥, symbol > stands for ⊥ → ⊥, and F ↔ G stands for
(F → G) ∧ (G → F ). We distinguish between atoms and atomic formulas as follows:
an atom of a signature σ is an n-ary predicate constant followed by a list of n terms
that can be formed from function constants in σ (including object constants) and object
variables; atomic formulas of σ are atoms of σ, equalities between terms of σ, and the
0-place connective ⊥.
The stable models of F relative to a list of predicates p = (p1 , . . . , pn ) are defined via
the stable model operator with the intensional predicates p, denoted by SM[F ; p].2 Let u
be a list of distinct predicate variables u1 , . . . , un of the same length as p. By u = p we
denote the conjunction of the formulas ∀x(ui (x) ↔ pi (x)), where x is a list of distinct object
variables of the same length as the arity of pi , for all i = 1, . . . , n. By u ≤ p we denote the
conjunction of the formulas ∀x(ui (x) → pi (x)) for all i = 1, . . . , n, and u < p stands for
(u ≤ p) ∧ ¬(u = p). For any first-order sentence F , the expression SM[F ; p] stands for the
second-order sentence
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
(1)
where F ∗ (u) is defined recursively:
• pi (t)∗ = ui (t) for any list t of terms;
• F ∗ = F for any atomic formula F (including ⊥ and equality) that does not contain
members of p;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;
• (∃xF )∗ = ∃xF ∗ .
(There is no clause for negation here, because we treat ¬F as shorthand for F → ⊥.)
A model of a sentence F (in the sense of first-order logic) is called p-stable if it satisfies
SM[F ; p]. We will often simply write SM[F ] instead of SM[F ; p] when p is the list of all
predicate constants occurring in F , and call a model of SM[F ] simply a stable model of F .
We distinguish between the terms “stable models” and “answer sets” as follows.3 By σ(F )
we denote the signature consisting of the function and predicate constants occurring in F .
2. The intensional predicates p are the predicates that we “intend to characterize” by F .
3. The distinction is useful because in the first-order setting, stable models are no longer Herbrand interpretations and may not be represented by sets of atoms.

128

First-Order Stable Model Semantics and First-Order Loop Formulas

If F contains at least one object constant, an Herbrand interpretation4 of σ(F ) that satisfies
SM[F ] is called an answer set of F . The answer sets of a logic program Π are defined as the
answer sets of the FOL-representation of Π (i.e., the conjunction of the universal closures
of implications corresponding to the rules).
Example 1 For program Π that contains three rules
p(a)
q(b)
r(x) ← p(x), not q(x)
the FOL-representation F of Π is
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))

(2)

and SM[F ] is
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x(((u(x) ∧ (¬v(x) ∧ ¬q(x))) → w(x)) ∧ ((p(x) ∧ ¬q(x)) → r(x)))),
which is equivalent to the first-order sentence
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b) ∧ ∀x(r(x) ↔ (p(x) ∧ ¬q(x)))

(3)

(See Example 3 in the work of Ferraris et al., 2007). The stable models of F are any firstorder models of (3). The only answer set of F is the Herbrand model {p(a), q(b), r(a)}.

3. First-Order Loop Formulas and Herbrand Models
We review the definition of a first-order loop formula for a nondisjunctive program given
by Chen et al. (2006) and extend it to a disjunctive program and to an arbitrary first-order
sentence.
3.1 Review of First-Order Loop Formulas Defined by Chen et al. (2006)
We call a formula negative if every occurrence of every predicate constant in it belongs
to the antecedent of an implication. For instance, any formula of the form ¬F is negative
because this expression is shorthand for F → ⊥. An equality t1 = t2 is also negative because
it contains no predicate constants.
A nondisjunctive program is a finite set of rules of the form
A ← B, N,

(4)

4. Recall that an Herbrand interpretation of a signature σ (containing at least one object constant) is an
interpretation of σ such that its universe is the set of all ground terms of σ, and every ground term
represents itself. An Herbrand interpretation can be identified with the set of ground atoms to which it
assigns the value true.

129

Lee & Meng

where A is an atom, B is a set of atoms, and N is a negative formula. The rules may
contain function constants of positive arity.5
We will say that a nondisjunctive program is in normal form if, for all rules (4) in it, A
is of the form p(x) where x is a list of distinct variables. It is clear that every program can
be turned into normal form using equality in the body. For instance, p(a, b) ← q(a) can be
rewritten as p(x, y) ← x = a, y = b, q(a).
Let Π be a nondisjunctive program and let Norm(Π) be a normal form of Π. By σ(Π) we
denote the signature consisting of function and predicate constants occurring in Π. Given a
finite set Y of atoms, we assume that Norm(Π) does not contain variables in Y , by renaming
the variables in Norm(Π). The (first-order) external support formula of Y for Π, denoted
by ES Π (Y ), is the disjunction of
_


∃z Bθ ∧ N θ ∧

θ:Aθ∈Y

^

0

(t 6= t )


(5)

p(t)∈Bθ
p(t0 )∈Y

for all rules (4) in Norm(Π),6 where θ is a substitution that maps variables in A to terms
occurring in Y , and z is the list of all variables that occur in
Aθ ← Bθ, N θ
but not in Y .
The (first-order) loop formula of Y for Π, denoted by LF Π (Y ), is the universal closure
of
^
Y → ES Π (Y ).
(6)
V
(The expression Y in the antecedent stands for the conjunction of all elements of Y .)
When Π is a propositional program, LF Π (Y ) is equivalent to a conjunctive loop formula as
defined by Ferraris et al. (2006).
The definition of a first-order dependency graph and the definition of a first-order loop
are as follows. We say that an atom p(t) depends on an atom q(t0 ) in a rule (4) if p(t) is
A and q(t0 ) is in B. The (first-order) dependency graph of Π is an infinite directed graph
(V, E) such that
• V is the set of atoms of signature σ(Π);7
• (p(t)θ, q(t0 )θ) is in E if p(t) depends on q(t0 ) in a rule of Π and θ is a substitution
that maps variables in t and t0 to terms (including variables) of σ(Π).
A nonempty subset L of V is called a (first-order) loop of Π if the subgraph of the
first-order dependency graph of Π induced by L is strongly connected.

5. The original definition by Chen et al. (2006) does not allow function constants of positive arity.
6. For any lists of terms t = (t1 , . . . , tn ) and t0 = (t01 , . . . , t0n ) of the same length, t = t0 stands for
(t1 = t01 ) ∧ · · · ∧ (tn = t0n ).
7. Note that V is infinite since infinitely many object variables can be used to form atoms.

130

First-Order Stable Model Semantics and First-Order Loop Formulas

Example 2 Let Π be the following program:
p(x) ← q(x)
q(y) ← p(y)
p(z) ← not r(z).

(7)

The following sets of atoms are first-order loops (among many others): Y1 = {p(u)}, Y2 =
{q(u)}, Y3 = {r(u)}, Y4 = {p(u), q(u)}. Their loop formulas are
LF Π (Y1 )
LF Π (Y2 )
LF Π (Y3 )
LF Π (Y4 )

=
=
=
=

∀u(p(u) → (q(u) ∨ ¬r(u))),
∀u(q(u) → p(u)),
∀u(r(u) → ⊥),
∀u(p(u) ∧ q(u) → (q(u) ∧ u 6= u) ∨ (p(u) ∧ u 6= u) ∨ ¬r(u)).

Example 3 Let Π be the one-rule program
p(x) ← p(y).

(8)

Its finite first-order loops are Yk = {p(x1 ), . . . , p(xk )} where k > 0. Formula LF Π (Yk ) is


(9)
∀x1 . . . xk p(x1 ) ∧ . . . ∧ p(xk ) → ∃y(p(y) ∧ (y 6= x1 ) ∧ . . . ∧ (y 6= xk )) .
The following is a reformulation of Theorem 1 from the work of Chen et al. (2006).
Theorem 1 Let Π be a nondisjunctive program that contains at least one object constant
but no function constants of positive arity, and let I be an Herbrand interpretation of σ(Π)
that satisfies Π.8 The following conditions are equivalent to each other:
(a) I is a stable model of Π;
(b) for every nonempty finite set Y of atoms of σ(Π), I satisfies LF Π (Y );

9

(c) for every finite first-order loop Y of Π, I satisfies LF Π (Y ).
The sets of first-order loop formulas considered in conditions (b) and (c) above have
obvious redundancies. For instance, the loop formula of {p(x)} is equivalent to the loop
formula of {p(y)}; the loop formula of {p(x), p(y)} entails the loop formula of {p(z)}. Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2 , we say
that Y1 subsumes Y2 if there is a substitution θ that maps variables in Y1 to terms so that
Y1 θ = Y2 .
Proposition 1 (Chen et al., 2006, Proposition 7) For any nondisjunctive program Π and
any loops Y1 and Y2 of Π, if Y1 subsumes Y2 , then LF Π (Y1 ) entails LF Π (Y2 ).
Therefore in condition (c) from Theorem 1, it is sufficient to consider a set Γ of loops
such that, for every loop L of Π, there is a loop L0 in Γ that subsumes L. Chen et al. (2006)
called such Γ a complete set of loops. In Example 2, set {Y1 , Y2 , Y3 , Y4 } is a finite complete
set of loops of program (7). Program (8) in Example 3 has no finite complete set of loops.
8. We say that I satisfies Π if I satisfies the FOL-representation of Π.
9. Note that Y may contain variables.

131

Lee & Meng

3.2 Extension to Disjunctive Programs
A disjunctive program is a finite set of rules of the form
A ← B, N,

(10)

where A and B are sets of atoms, and N is a negative formula. Similar to a nondisjunctive
program, we say that a disjunctive program is in normal form if, for all rules (10) in it, all
atoms in A are of the form p(x) where x is a list of distinct variables.
Let Π be a disjunctive program and let Norm(Π) be a normal form of Π. Given a finite
set Y of atoms, we first rename variables in Norm(Π) so that no variables in Norm(Π)
occur in Y . The (first-order) external support formula of Y for Π, denoted by ES Π (Y ), is
the disjunction of

_
^
_
^

∃z Bθ ∧ N θ ∧
(t 6= t0 ) ∧ ¬
p(t) ∧
t 6= t0
(11)
θ:Aθ∩Y 6=∅

p(t)∈Bθ
p(t0 )∈Y

p(t)∈Aθ

p(t0 )∈Y

for all rules (10) in Norm(Π), where θ is a substitution that maps variables in A to terms
occurring in Y or to themselves, and z is the list of all variables that occur in
Aθ ← Bθ, N θ
but not in Y . The (first-order) loop formula of Y for Π, denoted by LF Π (Y ), is the universal
closure of
^
Y → ES Π (Y ).
Clearly, (11) is equivalent to (5) when Π is nondisjunctive. When Π and Y are propositional,
LF Π (Y ) is equivalent to the conjunctive loop formula for a disjunctive program as defined
by Ferraris et al. (2006).
Example 4 Let Π be the program
p(x, y) ; p(y, z) ← q(x)
and let Y = {p(u, v)}. Formula LF Π (Y ) is the universal closure of
p(u, v) → ∃z(q(u) ∧ ¬(p(v, z) ∧ ((v, z) 6= (u, v))))
∨ ∃x(q(x) ∧ ¬(p(x, u) ∧ ((x, u) 6= (u, v)))).
Similar to the nondisjunctive case, we say that p(t) depends on q(t0 ) in Π if there is
a rule (10) in Π such that p(t) is in A and q(t0 ) is in B. The definitions of a first-order
dependency graph and a first-order loop are extended to disjunctive programs in a straightforward way. Using these extended notions, the following theorem extends Theorem 1 to
a disjunctive program. It is also a generalization of the main theorem by Ferraris et al.
(2006) which was restricted to a propositional disjunctive program.
Theorem 1 d Let Π be a disjunctive program that contains at least one object constant but
no function constants of positive arity, and let I be an Herbrand interpretation of σ(Π) that
satisfies Π. The following conditions are equivalent to each other:
132

First-Order Stable Model Semantics and First-Order Loop Formulas

(a) I is a stable model of Π;
(b) for every nonempty finite set Y of atoms of σ(Π), I satisfies LF Π (Y );
(c) for every finite first-order loop Y of Π, I satisfies LF Π (Y ).

3.3 Extension to Arbitrary Sentences
In this section we extend the definition of a first-order loop formula to an arbitrary firstorder sentence.
As with a propositional loop formula defined for an arbitrary propositional theory (Ferraris et al., 2006), it is convenient to introduce a formula whose negation is close to ES . We
define formula NES F (Y ) (“Negation of (First-order) External Support Formula”), where F
is a first-order formula and Y is a finite set of atoms, as follows. As before we assume that
no variables in Y occur in F , by renaming variables.
• NES pi (t) (Y ) = pi (t) ∧

V

pi (t0 )∈Y

t 6= t0 ;

• NES t1 =t2 (Y ) = (t1 = t2 );
• NES ⊥ (Y ) = ⊥;
• NES F ∧G (Y ) = NES F (Y ) ∧ NES G (Y );
• NES F ∨G (Y ) = NES F (Y ) ∨ NES G (Y );
• NES F →G (Y ) = (NES F (Y ) → NES G (Y )) ∧ (F → G);
• NES ∀xG (Y ) = ∀xNES G (Y );
• NES ∃xG (Y ) = ∃xNES G (Y ).
The (first-order) loop formula of Y for F , denoted by LF F (Y ), is the universal closure
of
^

Y → ¬NES F (Y ).

(12)

Note that the definition of NES looks similar to the definition of F ∗ given in Section 2.
When F and Y are propositional, LF F (Y ) is equivalent to a conjunctive loop formula for
a propositional formula that is defined by Ferraris et al. (2006). The following lemma tells
us that the definition of a loop formula in this section generalizes the definition of a loop
formula for a disjunctive program in the previous section.
Lemma 1 Let Π be a disjunctive program in normal form, F an FOL-representation of
Π, and Y a finite set of atoms. Formula NES F (Y ) is equivalent to ¬ES Π (Y ) under the
assumption F .
133

Lee & Meng

In order to extend the first-order dependency graph to an arbitrary formula, we introduce
a few notions. We say that an occurrence of a subformula G in a formula F is positive if
the number of implications in F containing that occurrence in the antecedent is even; it is
strictly positive if that number is 0. A rule of a first-order formula F is an implication that
occurs strictly positively in F . We will say that a formula is rectified if it has no variables
that are both bound and free, and if all quantifiers in the formula refer to different variables.
Any formula can be easily rewritten into a rectified formula by renaming bound variables.
We say that an atom p(t) depends on an atom q(t0 ) in an implication G → H if
• p(t) has a strictly positive occurrence in H, and
• q(t0 ) has a positive occurrence in G that does not belong to any negative subformula
of G.10
The definition of a first-order dependency graph is extended to formulas as follows. The
(first-order) dependency graph of a rectified formula F is the infinite directed graph (V, E)
such that
• V is the set of atoms of signature σ(F );
• (p(t)θ, q(t0 )θ) is in E if p(t) depends on q(t0 ) in a rule of F and θ is a substitution
that maps variables in t and t0 to terms of σ(F ).
Note that the rectified formula assumption is required in order to distinguish between
dependency graphs of formulas such as
∀x(p(x) → q(x))
and
∀x p(x) → ∀x q(x).
Once the definition of a dependency graph is given, a loop of a first-order formula is
defined in the same way as with a disjunctive program. Theorem 1 can be extended to
first-order sentences using these extended notions.

Theorem 1 f Let F be a rectified sentence that contains at least one object constant but
no function constants of positive arity, and let I be an Herbrand interpretation of σ(F ) that
satisfies F . The following conditions are equivalent to each other:
(a) I is a stable model of F (i.e., I satisfies SM[F ]);
(b) for every nonempty finite set Y of atoms of σ(F ), I satisfies LF F (Y );
(c) for every finite first-order loop Y of F , I satisfies LF F (Y ).
Example 2 (continued) Consider the FOL-representation F of the program in Example 2,
for which {Y1 , Y2 , Y3 , Y4 } is a complete set of loops. Under the assumption F ,
10. Recall the definition of a negative formula in Section 3.1.

134

First-Order Stable Model Semantics and First-Order Loop Formulas

• LF F (Y1 ) is equivalent to the universal closure of

p(u) → ¬ ∀x(q(x) → p(x) ∧ x 6= u) ∧ ∀y(p(y) ∧ y 6= u → q(y))

∧ ∀z(¬r(z) → p(z) ∧ z 6= u) ;
• LF F (Y2 ) is equivalent to the universal closure of


q(u) → ¬ ∀x(q(x) ∧ x 6= u → p(x)) ∧ ∀y(p(y) → q(y) ∧ y 6= u) ;
• LF F (Y3 ) is equivalent to the universal closure of
r(u) → ⊥;
• LF F (Y4 ) is equivalent to the universal closure of

p(u) ∧ q(u) → ¬ ∀x(q(x) ∧ x 6= u → p(x) ∧ x 6= u)

∧ ∀y(p(y) ∧ y 6= u → q(y) ∧ y 6= u) ∧ ∀z(¬r(z) → p(z) ∧ z 6= u) .

Proposition 1 can be straightforwardly extended to arbitrary sentences even without
restricting the attention to loops.
Proposition 1 f For any sentence F and any nonempty finite sets of atoms Y1 and Y2
of σ(F ), if Y1 subsumes Y2 , then LF F (Y1 ) entails LF F (Y2 ).
Proof. Note that LF F (Y1 ) is
∀z

^


Y1 → ¬NES F (Y1 ) ,

(13)

where z is the set of all variables in Y1 . If Y1 subsumes Y2 , by definition, there is a
substitution θ from variables in Y1 to terms in Y2 such that Y1 θ = Y2 . It is clear that (13)
entails
^

∀z0
Y1 θ → ¬NES F (Y1 θ) ,
(14)
where z0 is the set of all variables in Y1 θ. (14) is exactly LF F (Y2 ).



Theorem 2 from the work of Ferraris et al. (2006) is a special case of Theorem 1f when
F is restricted to a propositional formula.
Corollary 1 (Ferraris et al., 2006, Thm. 2) For any propositional formula F , the following
formulas are equivalent to each other under the assumption F .
(a) SM[F ];
(b) the conjunction of LF F (Y ) for all nonempty sets Y of atoms occurring in F ;
(c) the conjunction of LF F (Y ) for all (ground) loops Y of F .
135

Lee & Meng

4. Comparing First-Order Stable Model Semantics and First-Order Loop
Formulas
The theorems in the previous section were restricted to Herbrand stable models. This
section extends the results to allow non-Herbrand stable models as well, and compare the
idea of loop formulas with SM by reformulating the latter in the style of loop formulas.
4.1 Loop Formulas Relative to an Interpretation
Recall that Theorem 1 and its extensions do not allow function constants of positive arity
and are limited to Herbrand models of the particular signature obtained from the given
theory. Indeed, the statements become wrong if these conditions are dropped.
Example 5 The following program contains a unary function constant f .
p(a)
p(x) ← p(f (x)).
The loops of this program are all singleton sets of atoms, and their loop formulas are satisfied
by the Herbrand model {p(a), p(f (a)), p(f (f (a))), . . . } of the program, but this model is not
stable.

Example 3 (continued) The mismatch can happen even in the absence of function constants of positive arity. Consider the program in Example 3 and an interpretation I such
that the universe is the set of all integers, and pI contains all integers. Interpretation I
satisfies all first-order loop formulas (9), but it is not a stable model.
These examples suggest that the mismatch between the first-order stable model semantics and the first-order loop formulas is related to the presence of an infinite path in the
dependency graph that visits infinitely many vertices. In the following we will make this
idea more precise, and extend Theorem 1f to allow non-Herbrand interpretations under a
certain condition.
First, we define a dependency graph relative to an interpretation. Let F be a rectified
formula whose signature is σ and let I be an interpretation of σ. For each element ξ of the
universe |I| of I, we introduce a new symbol ξ  , called an object name. By σ I we denote the
signature obtained from σ by adding all object names ξ  as additional object constants. We
will identify an interpretation I of signature σ with its extension to σ I defined by I(ξ  ) = ξ
(For details, see the work of Lifschitz, Morgenstern, & Plaisted, 2008).
The dependency graph of F w.r.t. I is the directed graph (V, E) where
• V is the set of all atoms of the form pi (ξ  ) where pi belongs to σ(F ) and ξ  is a list
of object names for |I|, and
• (pi (ξ  ), pj (η  )) is in E if there are atoms pi (t), pj (t0 ) such that pi (t) depends on pj (t0 )
in a rule of F and there is a substitution θ that maps variables in t and t0 to object
names such that (tθ)I = ξ and (t0 θ)I = η.
136

First-Order Stable Model Semantics and First-Order Loop Formulas

We call a nonempty subset L of V a loop of F w.r.t. I if the subgraph of the dependency
graph of F w.r.t. I that is induced by L is strongly connected. We say that F is bounded
w.r.t. I if every infinite path in the dependency graph of F w.r.t. I whose vertices are
satisfied by I visits only finitely many vertices. If F is bounded w.r.t. I, then, clearly, every
loop L of F w.r.t. I such that I |= L is finite. The definition is extended to a non-rectified
formula by first rewriting it as a rectified formula. It also applies to the program syntax by
referring to its FOL-representation.
Theorem 2 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is
bounded w.r.t. I, then the following conditions are equivalent to each other:
(a) I |= SM[F ];
(b) for every nonempty finite set Y of atoms formed from predicate constants in σ(F ) and
object names for |I|, I satisfies LF F (Y );
(c) for every finite loop Y of F w.r.t. I, I satisfies LF F (Y ).
The condition that F is bounded w.r.t. I is sufficient for ensuring the equivalence among
(a), (b), and (c), but it is not a necessary condition. For instance, consider F to be
∀x p(x) ∧ ∀xy(p(x) → p(y))
and I to be a model of F whose universe is infinite. Formula F is not bounded w.r.t. I, but
I satisfies every loop formula, as well as SM[F ].
When I is an Herbrand model of σ(F ), the dependency graph of F w.r.t. I is isomorphic to the subgraph of the first-order dependency graph of F that is induced by vertices
containing ground atoms. A set of ground atoms of σ(F ) is a loop of F iff it is a loop of F
w.r.t. I. Hence Theorem 2 is essentially a generalization of Theorem 1f .
Note that the programs considered in Examples 3 and 5 are not bounded w.r.t. the
interpretations considered there.
Clearly, if the universe of I is finite, then F is bounded w.r.t. I. This fact leads to the
following corollary.
Corollary 2 For any rectified sentence F and any model I of F whose universe is finite,
conditions (a), (b), and (c) of Theorem 2 are equivalent to each other.
In view of Proposition 1f and Corollary 2, if the size of the universe is known to be a
finite number n, it is sufficient to consider at most 2|p| − 1 loop formulas, where p is the
set of all predicate constants
occurring in the sentence. Each loop formula is to check the
S
external support of p∈K {p(x1 ), . . . , p(xnr )} for each K where
• K is a nonempty subset of p;
• r is the arity of p and each xi is a list of variables of the length r such that all variables
in x1 , . . . , xnr are pairwise distinct.
137

Lee & Meng

For instance, consider program (8). If the size of the universe is known to be 3, it is sufficient
to consider only one loop formula (9) where k = 3.
Theorem 1f essentially follows from Corollary 2 as the Herbrand universe of σ(F ) is
finite when F contains no function constants of positive arity.
Another corollary to Theorem 2 is acquired when F has only “trivial” loops. We say
that a formula F is atomic-tight w.r.t. I if every path in the dependency graph of F w.r.t. I
whose vertices are satisfied by I is finite. Clearly, this is a special case of boundedness
condition, and every loop L of an atomic-tight formula F w.r.t. I such that I |= L is a
singleton. The following is a corollary to Theorem 2, which tells us the condition under
which stable models can be characterized by loop formulas of singleton loops only. By
SLF[F ] (“loop formulas of singletons”) we denote
{LF F ({p(x)}) | p is a predicate constant in σ(F ), and x is a list
of distinct object variables whose length is the same as the arity of p}.

(15)

Corollary 3 Let F be a rectified sentence (possibly containing function constants of positive
arity), and let I be a model of F . If F is atomic-tight w.r.t. I, then I satisfies SM[F ] iff I
satisfies SLF[F ].
SLF[F ] is similar to Clark’s completion. In the propositional case, the relationship
between the loop formulas of singletons and the completion is studied by Lee (2005). Below
we describe their relationship in the first-order case. A sentence F is in Clark normal form
(Ferraris et al., 2011) if it is a conjunction of formulas of the form
∀x(G → p(x)),

(16)

one for each predicate constant p occurring in F , where x is a list of distinct variables, and
G has no free variables other than x. The completion of a sentence F in Clark normal form,
denoted by Comp[F ], is obtained from F by replacing each conjunctive term (16) with
∀x(p(x) ↔ G).
Any nondisjunctive program can be turned into Clark normal form (Ferraris et al., 2011,
Section 6.1).
Corollary 4 Let F be the FOL-representation of a nondisjunctive program Π, and let F 0
be the Clark normal form of F as obtained by the process described in the work of Ferraris
et al. (2011, Section 6.1). If F is atomic-tight w.r.t. an interpretation I, then I |= SM[F ]
iff I |= Comp[F 0 ].
Proof. Since F is atomic-tight w.r.t. I, by Corollary 3, I |= SM[F ] iff I |= F ∧ SLF[F ]. It
is sufficient to show that, for each predicate constant p occurring in F , under the assumption
that F is atomic-tight w.r.t. I,


_
^

I |= ∀x p(x) →
∃z (x = t0 ) ∧ B ∧ N ∧
(t 6= x)
(17)
p(t0 )←B,N ∈Π

p(t)∈B

138

First-Order Stable Model Semantics and First-Order Loop Formulas

iff




∃z (x = t ) ∧ B ∧ N ,

_

I |= ∀x p(x) →

0



(18)

p(t0 )←B,N ∈Π

where z is the list of all free variables in p(x) ← (x = t0 ), B, N that are not in x.
Note that (17) is equivalent to saying that


^
_

0
0
(t 6= t ) .
∃z (x = t ) ∧ B ∧ N ∧
I |= ∀x p(x) →
p(t0 )←B,N ∈Π

(19)

p(t)∈B

From the assumption that F is atomic-tight w.r.t. I, it follows that, for any rule p(t0 ) ←
B, N in Π and any atom of p(t) in B, I |= ∀y(t 6= t0 ), where y is the list of all variables in
t and t0 (otherwise we find a singleton loop with a self-cycle, which contradicts that F is
atomic tight w.r.t. I). Consequently, (19) is equivalent to (18).

For example, let F be the FOL-representation of the program
p(b) ← p(a)
← a 6= b

(20)

SLF[p(a) → p(b)] is ∀x(p(x) → x = b ∧ p(a) ∧ x 6= a), while Comp[∀x(x = b ∧ p(a) → p(x))]
is ∀x(p(x) ↔ x = b ∧ p(a)). The additional conjunctive term x 6= a can be dropped when
we consider any model I of F , for which aI 6= bI .
Corollary 4 is an enhancement of Theorem 11 from the work of Ferraris et al. (2011),
which states the equivalence between SM[F ] and Comp[F ] for any tight sentence F in Clark
normal form. (Tight sentences are defined in a similar way, but in terms of a predicate
dependency graph, whose vertices are predicate constants instead of atoms.) Every tight
sentence is atomic-tight w.r.t. any model of the sentence. On the other hand, program (20)
is atomic-tight w.r.t. any model of the program, but is not tight.
Theorem 2 tells us that one of the limitations of first-order loop formulas is that, even
if infinitely many first-order loop formulas are considered, they cannot ensure the external
support of a certain infinite set that forms an infinite path in the dependency graph of F
w.r.t. I. In the next section, by reformulating SM[F ], we show that the definition of SM[F ]
essentially encompasses loop formulas, ensuring the external support of any sets of atoms,
including those “difficult” infinite sets.
4.2 A Reformulation of SM
As before, let F be a first-order formula of a signature σ, let p = (p1 , . . . , pn ) be the list
of all predicate constants occurring in F , and let u and v be lists of predicate variables of
the same length as p. We define NSES F (u) (“Negation of Second-Order External Support
Formula”) recursively as follows.
• NSES pi (t) (u) = pi (t) ∧ ¬ui (t);
• NSES t1 =t2 (u) = (t1 = t2 );
• NSES ⊥ (u) = ⊥;
139

Lee & Meng

• NSES F ∧G (u) = NSES F (u) ∧ NSES G (u);
• NSES F ∨G (u) = NSES F (u) ∨ NSES G (u);
• NSES F →G (u) = (NSES F (u) → NSES G (u)) ∧ (F→ G);
• NSES ∀xF (u) = ∀xNSES F (u);
• NSES ∃xF (u) = ∃xNSES F (u).
Lemma 2 Let F be a rectified sentence of a signature σ, I an interpretation of σ, p the
list of predicate constants occurring in F , q a list of predicate names 11 of the same length
as p and Y a set of atoms formed from predicate constants from σ(F ) and object names
such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. If Y is finite, then
I |= NSES F (q) iff I |= NES F (Y ).
Proof. By induction on F . We only list the case when F is an atom. The other cases are
straightforward. Let F be an atom pi (ξ  ).
iff
iff
iff
iff
iff

I |= NSES F (q)
I |= pi (ξ  ) ∧ ¬qi (ξ  )
I |= pi (ξ  ) and pi (ξ  ) ∈
/Y
 such that p (η  ) ∈ Y, it holds that ξ  6= η 
I |= pi (ξ  ) and
for
all
η
i
V
I |= pi (ξ  ) ∧ pi (η )∈Y ξ  6= η 
I |= NES F (Y ).


SM[F ] can be written in terms of NSES as follows. By Nonempty(u) we denote the
formula
∃x1 u1 (x1 ) ∨ · · · ∨ ∃xn un (xn ),
where each xi is a list of distinct variables whose length is the same as the arity of pi .
Proposition 2 For any sentence F , SM[F ] is equivalent to
F ∧ ∀u((u ≤ p) ∧ Nonempty(u) → ¬NSES F (u)).

(21)

Now we represent the notion of a loop by a second-order formula. Given a rectified
formula F , by EF (v, u) we denote
_
∃z(vi (t) ∧ uj (t0 ) ∧ ¬vj (t0 )),
(pi (t),pj (t0 )) :
pi (t) depends on pj (t0 ) in a rule of F

11. Like object names, for every n > 0, each subset of |I|n has a name, which is an n-ary predicate constant
not from the underlying signature.

140

First-Order Stable Model Semantics and First-Order Loop Formulas

where z is the list of all object variables in t and t0 . By Loop F (u) we denote the second-order
formula
Nonempty(u) ∧ ∀v((v < u) ∧ Nonempty(v) → EF (v, u)).
(22)
Formula (22) represents the concept of a loop without referring to the notion of a dependency
graph explicitly. This is based on the following observation. Consider a finite propositional
program Π. A nonempty set U of atoms that occur in Π is a loop of Π iff, for every
nonempty proper subset V of U , there is an edge from an atom in V to an atom in U \ V
in the dependency graph of Π (Gebser et al., 2006).
Recall the definition of a dependency graph relative to an interpretation. Let F be
a rectified sentence of a signature σ, and let I be an interpretation of σ. The following
proposition describes the relationship between formula (22) and a loop of F w.r.t. I.
Proposition 3 Let q be a list of predicate names corresponding to p, and let Y be a set of
atoms in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. Then I |= Loop F (q) iff Y is a loop of F w.r.t. I.
One might expect that, similar to the equivalence between conditions (a) and (c) from
Theorem 2, formula SM[F ] is equivalent to the following formula:
F ∧ ∀u((u ≤ p) ∧ Loop F (u) → ¬NSES F (u)).

(23)

However, the equivalence does not hold in general, as the following example illustrates.
Example 6 Consider the FOL-representation F of the following program
p(x, y) ← q(x, z)
q(x, z) ← p(y, z),
and an interpretation I whose universe is the set of all nonnegative integers such that
pI = {(m, m) | m is a nonnegative integer},
q I = {(m, m+1) | m is a nonnegative integer}.
Formula F is not bounded w.r.t. I since the dependency graph of F w.r.t. I contains an
infinite path such as
hp(0 , 0 ), q(0 , 1 ), p(1 , 1 ), q(1 , 2 ), . . .i.

(24)

The interpretation I satisfies every loop formula of every finite loop of F w.r.t. I, but it is
not a stable model.
In the example, what distinguishes the set
{p(0 , 0 ), q(0 , 1 ), p(1 , 1 ), q(1 , 2 ), . . . }

(25)

from a loop is that, for every loop contained in (25), there is an outgoing edge in the dependency graph. This is an instance of what we call “unbounded set.” Given a dependency
graph of F w.r.t. I, we say that a nonempty set Y of vertices is unbounded w.r.t. I if, for
every subset Z of Y that is a loop, there is an edge from a vertex in Z to a vertex in Y \ Z.
The following proposition tells us how an unbounded set can be characterized by a
second-order formula.
141

Lee & Meng

Proposition 4 Let q be a list of predicate names corresponding to p, and let Y be a set of
atoms in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. Then
I |= Nonempty(q) ∧ ∀v((v ≤ q) ∧ Loop F (v) → EF (v, q))
iff Y is an unbounded set of F w.r.t. I.
In order to check the stability of a model, we need to check the external support of every
loop and every unbounded set. An extended loop of F w.r.t. I is a loop or an unbounded
set of F w.r.t. I. We define Ext-Loop F (u) as
Loop F (u) ∨ (Nonempty(u) ∧ ∀v((v ≤ u) ∧ Loop F (v) → EF (v, u))).

(26)

From Propositions 3 and 4, it follows that I |= Ext-Loop F (q) iff Y is an extended loop of
F w.r.t. I.
If we replace Loop F (u) with Ext-Loop F (u) in (23), the formula is equivalent to SM[F ],
as the following theorem states.
Theorem 3 For any rectified sentence F , the following sentences are equivalent to each
other:
(a) SM[F ];
(b) F ∧ ∀u((u ≤ p) ∧ Nonempty(u) → ¬NSES F (u));
(c) F ∧ ∀u((u ≤ p) ∧ Ext-Loop F (u) → ¬NSES F (u)).
In the following example we use the following fact to simplify the formulas.
Proposition 5 For any negative formula F , formula
NSES F (u) ↔ F
is logically valid.
Example 2 (continued) Consider program (7) from Example 2:
p(x) ← q(x)
q(y) ← p(y)
p(z) ← not r(z).
Let F be the FOL-representation of the program:



∀x q(x) → p(x) ∧ ∀y p(y) → q(y) ∧ ∀z ¬r(z) → p(z) .
142

First-Order Stable Model Semantics and First-Order Loop Formulas

1. SM[F ] is equivalent to
F ∧ ¬∃u1 u2 u3 ((u1 , u2 , u3 ) < (p, q, r))∧
∀x(u2 (x) → u1 (x)) ∧ ∀y(u1 (y) → u2 (y)) ∧ ∀z(¬r(z) → u1 (z))).
2. Formula in Theorem 3 (b):
F ∧ ∀u(u ≤ p ∧ Nonempty(u) → ¬NSES F (u))
is equivalent to
F ∧ ∀u1 u2 u3 ((u1 , u2 , u3 ) ≤ (p, q, r) ∧ (∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
→ ¬(∀x[q(x) ∧ ¬u2 (x) → p(x) ∧ ¬u1 (x)]
∧∀y[p(y) ∧ ¬u1 (y) → q(y) ∧ ¬u2 (y)]
∧∀z[¬r(z) → p(z) ∧ ¬u1 (z)])).

(27)

3. Formula in Theorem 3 (c): Similar to (27) except that
∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x)
in (27) is replaced with Ext-Loop F (u), which is
Loop F (u) ∨ [(∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
∧ ∀v1 v2 v3 (((v1 , v2 , v3 ) ≤ (u1 , u2 , u3 )) ∧ Loop F (v)
→ (∃x(v1 (x) ∧ u2 (x) ∧ ¬v2 (x)) ∨ ∃y(v2 (y) ∧ u1 (y) ∧ ¬v1 (y))))],
where Loop F (u) is
(∃x u1 (x) ∨ ∃x u2 (x) ∨ ∃x u3 (x))
∧ ∀v1 v2 v3 (((∃x v1 (x) ∨ ∃x v2 (x) ∨ ∃x v3 (x)) ∧ (v1 , v2 , v3 ) < (u1 , u2 , u3 ))
→ (∃x(v1 (x) ∧ u2 (x) ∧ ¬v2 (x)) ∨ ∃y(v2 (y) ∧ u1 (y) ∧ ¬v1 (y)))).
The proof of Theorem 2 follows from Theorem 3 using the following lemma.
Lemma 3 Let F be a rectified sentence of a signature σ (possibly containing function constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is bounded
w.r.t. I,
I |= ∃u(u ≤ p ∧ Ext-Loop F (u) ∧ NSES F (u))
iff there is a finite loop Y of F w.r.t. I such that
^

I |=
Y ∧ NES F (Y ) .

5. Representing First-Order Stable Model Semantics by First-Order
Loop Formulas
We noted in the previous section that if a sentence is bounded w.r.t. a model, then loop
formulas can be used to check the stability of the model. In this section, we provide a few
syntactic counterparts of the boundedness condition.
143

Lee & Meng

5.1 Bounded Formulas
We say that a rectified formula F is bounded if every infinite path in the first-order dependency graph of F visits only finitely many vertices. If F is bounded, then, clearly, every loop
of F is finite. Again, the definition is extended to a non-rectified formula by first rewriting
it as a rectified formula. It also applies to a program by referring to its FOL-representation.
One might wonder if the syntactic notion of boundedness ensures the semantic notion of
boundedness: that is, if a formula is bounded, then it is bounded w.r.t. any interpretation.
However, the following example tells us that this is not the case in general.
Example 7 Consider the FOL-representation F of the following program
p(a) ← q(x)
q(x) ← p(b),

(28)

and an interpretation I whose universe |I| is the set of all nonnegative integers, aI = bI = 0,
pI = {0} and q I = |I|. Formula (28) is bounded according to the above definition, but not
bounded w.r.t. I: the dependency graph of F w.r.t. I contains an infinite path such as
hp(0 ), q(1 ), p(0 ), q(2 ), . . . i.
5.1.1 Bounded Formulas and Clark’s Equational Theory
On the other hand, such a relationship holds if the interpretation satisfies Clark’s equational
theory (1978). Clark’s equational theory of a signature σ, denoted by CETσ , is the union
of the universal closures of the following formulas
f (x1 , . . . , xm ) 6= g(y1 , . . . , yn ),

(29)

for all pairs of distinct function constants f , g,
f (x1 , . . . , xn ) = f (y1 , . . . , yn ) → (x1 = y1 ∧ . . . ∧ xn = yn ),

(30)

for all function constants f of arity > 0, and
t 6= x,

(31)

where t is any term which contains the variable x.
Proposition 6 If a rectified formula F of a signature σ is bounded, then F is bounded
w.r.t. any interpretation of σ that satisfies CETσ .
The following lemma relates loops and loop formulas of different notions of dependency
graphs.
Proposition 7 For any rectified sentence F of a signature σ and for any interpretation I
of σ that satisfies CETσ , I is a model of
{LF F (Y ) | Y is a finite first-order loop of F }
iff I is a model of
{LF F (Y ) | Y is a finite loop of F w.r.t. I}.
144

First-Order Stable Model Semantics and First-Order Loop Formulas

The following theorem follows from Theorem 2, Proposition 6 and Proposition 7.
Theorem 4 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F and CETσ .
If F is bounded, then the following conditions are equivalent to each other:
(a) I |= SM[F ];
(b) for every nonempty finite set Y of atoms of σ(F ), I satisfies LF F (Y );
(c) for every finite first-order loop Y of F , I satisfies LF F (Y ).
Proof. By Proposition 6, if F is bounded then F is bounded w.r.t. any interpretation
that satisfies CETσ . Then the equivalence between (a) and (b) follows from the equivalence
between (a) and (b) of Theorem 2. The equivalence between (a) and (c) follows from the
equivalence between (a) and (c) of Theorem 2 and by Proposition 7.

As every Herbrand interpretation of σ satisfies CETσ , Theorem 4 applies to Herbrand
interpretations as a special case.
The theorem also applies to logic programs, since they can be viewed as a special case
of formulas. For example, consider the following program, which is bounded.
p(f (x)) ← q(x)
q(x) ← p(x), r(x)
p(a)
r(a)
r(f (a)).

(32)

The set {p(a), p(f (a)), p(f (f (a))), q(a), q(f (a)), r(a), r(f (a))} is an answer set of (32). In
accordance with Theorem 4, it is also the Herbrand interpretation of the signature obtained
from the program that satisfies the FOL-representation of (32) and the loop formulas, which
are the universal closures of
p(z) → (q(x) ∧ z = f (x)) ∨ z = a
q(z) → p(z) ∧ r(z)
r(z) → z = a ∨ z = f (a).
Consider another example program by Bonatti (2004), where a, . . . , z, nil are object
constants.
letter (a)
...
letter (z)
(33)
atomic([x]) ← letter (x)
atomic([x|y]) ← letter (x), atomic(y).
The expression [x|y] is a list whose head is x and whose tail is y, which stands for a function
cons(x, y). The expression [x] stands for cons(x, nil) where nil is a special symbol for
145

Lee & Meng

the empty list. This program is bounded. The only answer set of the program is the only
Herbrand interpretation of the FOL-representation of (33) and the universal closures of
letter (u) → u = a ∨ . . . ∨ u = z
atomic(u) → ∃v (letter (v) ∧ u = cons(v, nil))
∨ ∃xy (letter (x) ∧ atomic(y) ∧ y 6= u ∧ u = cons(x, y)).
In fact, the definitions of standard list processing predicates, such as member, append, and
reverse (Bonatti, 2004, Figure 1) are bounded, so they can be represented by first-order
formulas on Herbrand interpretations.12
We say that a formula F is atomic-tight if the first-order dependency graph of F has no
infinite paths. Every tight sentence is atomic-tight, but not vice versa. For example, the
FOL-representations of programs (32) and (33) are atomic-tight, but are not tight. Similar
to Proposition 6, if F is atomic-tight, then F is atomic-tight w.r.t. any interpretation that
satisfies CETσ , so that the following statement is derived from Corollary 3.
Corollary 5 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F and CETσ .
If F is atomic-tight, then I satisfies SM[F ] iff I satisfies SLF[F ].
The statement of Corollary 5 is restricted to interpretations that satisfy CETσ . Indeed,
the statement becomes wrong if this restriction is dropped. For example, program (28)
in Example 7 is atomic-tight, but the non-stable model considered there satisfies all loop
formulas, including those of singleton loops.
5.1.2 Bounded Formulas and Normal Form
Normal form is another syntactic condition that can be imposed so that the syntactic notion
of boundedness ensures the semantic notion of boundedness. We say that a formula is in
normal form if every strictly positive occurrence of an atom is of the form p(x), where x is
a list of distinct variables. It is clear that every formula can be turned into normal form
using equality.
Proposition 8 If a rectified formula F in normal form is bounded, then F is bounded w.r.t.
any interpretation.
Proposition 9 If a rectified sentence F in normal form is bounded, then for any interpretation I, I is a model of
{LF F (Y ) | Y is a finite first-order loop of F }
iff I is a model of
{LF F (Y ) | Y is a finite loop of F w.r.t. I}.
The following theorem follows from Theorem 2, Proposition 8 and Proposition 9.
12. They actually satisfy a stronger condition called “finitely recursive” (Bonatti, 2004). See Section 8 for
more details.

146

First-Order Stable Model Semantics and First-Order Loop Formulas

Theorem 5 Let F be a rectified sentence in normal form (possibly containing function
constants of positive arity). If F is bounded, then the following formulas are equivalent to
each other:
(a) SM[F ];
(b) {F } ∪ {LF F (Y ) | Y is a nonempty finite set of atoms of σ(F )};
(c) {F } ∪ {LF F (Y ) | Y is a finite first-order loop of F }.
Proof. By Proposition 8, if F is bounded then F is bounded w.r.t. any interpretation I.
Then the equivalence between (a) and (b) follows from the equivalence between (a) and (b)
of Theorem 2. The equivalence between (a) and (c) follows from the equivalence between
(a) and (c) of Theorem 2 and by Proposition 9.

Consider a program in normal form
p(x) ← x = a, q(a)
q(y) ← p(b)

(34)

and an interpretation I such that |I| = {1}, aI = bI = 1 and pI = q I = {1}. This
interpretation does not satisfy Clark’s equational theory, and is not a stable model. In
accordance with Theorem 5, I does not satisfy the loop formula of the loop {p(b), q(a)},
which is
p(b) ∧ q(a) → (b = a ∧ q(a) ∧ a 6= a) ∨ (p(b) ∧ b 6= b).
On the other hand, consider another program in non-normal form that has the same
stable models as (34):
p(a) ← q(a)
(35)
q(y) ← p(b)
Program (35) has a finite complete set of loops, {{p(z)}, {q(z)}}; their loop formulas are
the universal closures of
p(z) → z = a ∧ q(a)
q(z) → p(b)
and I satisfies all loop formulas. This example illustrates the role of normal form assumption
in Theorem 5 (in place of Clark’s equational theory in Theorem 4).
Note that a normal form conversion may turn a bounded sentence into a non-bounded
sentence. For instance, the normal form of the bounded program (32) is
p(y) ← y = f (x), q(x)
q(x) ← p(x), r(x)
p(x) ← x = a
r(x) ← x = a
r(x) ← x = f (a),

(36)

which is not bounded.
Unlike in Corollary 5, if a program is in normal form, atomic-tightness is not more
general than tightness. It is not difficult to check that a program in normal form is atomictight iff it is tight.
147

Lee & Meng

5.1.3 Decidability of Boundedness and Finite Complete Set of Loops
In general, checking whether F is bounded is not decidable, but it becomes decidable if F
contains no function constants of positive arity. The same is the case for checking whether
F is atomic-tight.
Proposition 10 For any rectified sentence F (allowing function constants of positive arity),
(a) checking whether F is bounded is not decidable;
(b) checking whether F is atomic-tight is not decidable.
If F contains no function constants of positive arity,
(c) checking whether F is bounded is decidable;
(d) checking whether F is atomic-tight is decidable.
The proof of Proposition 10 (c) is based on the following fact and the straightforward
extension of Theorem 2 by Chen et al. (2006) to first-order formulas, which asserts that
checking if F has a finite complete set of loops is decidable.
Proposition 11 For any rectified formula F that contains no function constants of positive
arity, F is bounded iff F has a finite complete set of loops.
Note that Proposition 11 does not hold if F is allowed to contain function constants of
positive arity. For instance,
p(x) ← p(f (x))
is not bounded, but has a finite complete set of loops {{p(x)}}.
The following corollary follows from Theorem 4 and Proposition 11.
Corollary 6 Let F be a rectified sentence of a signature σ that has no function constants
of positive arity, and let I be an interpretation of σ that satisfies F and CETσ . If F has a
finite complete set of loops, then conditions (a), (b), and (c) of Theorem 4 are equivalent
to each other.
The following corollary follows from Theorem 5 and Proposition 11.
Corollary 7 Let F be a rectified sentence in normal form that has no function constants
of positive arity. If F has a finite complete set of loops, formulas in (a), (b), and (c) of
Theorem 5 are equivalent to each other.
148

First-Order Stable Model Semantics and First-Order Loop Formulas

5.2 Semi-Safe Formulas
Semi-safety is another decidable syntactic condition that ensures that SM[F ] can be expressed by first-order sentences.
We assume that there are no function constants of positive arity. According to Lee,
Lifschitz, and Palla (2009), a semi-safe sentence has the “small predicate property”: the
relation represented by any of its predicate constants p can hold for a tuple of arguments
only if each member of the tuple is represented by an object constant occurring in F . We
will show that any semi-safe sentence under the stable model semantics can be turned into
a sentence in first-order logic.
First, we review the notion of semi-safety by Lee et al. (2009).13 As a preliminary step,
we assign to every formula F a set RV(F ) of its restricted variables as follows:
• For an atomic formula F ,
– if F is an equality between two variables, then RV(F ) = ∅;
– otherwise, RV(F ) is the set of all variables occurring in F ;
• RV(G ∧ H) = RV(G) ∪ RV(H);
• RV(G ∨ H) = RV(G) ∩ RV(H);
• RV(G → H) = ∅;
• RV(QvG) = RV(G) \ {v} where Q ∈ {∀, ∃}.
We say that a variable x is restricted in F if x ∈ RV(F ). A rectified formula F is semisafe if every strictly positive occurrence of every variable x belongs to a subformula G → H
where x is restricted in G.
If a sentence has no strictly positive occurrence of a variable, then it is obviously semisafe. The FOL-representation of a disjunctive program is semi-safe if, for each rule (10)
of the program, every variable occurring in the head of the rule occurs in B as well.
Example 8 The FOL-representation of (8) is not semi-safe. Formula
p(a) ∧ q(b) ∧ ∀xy((p(x) ∨ q(y)) → p(y))
is not semi-safe, while
p(a) ∧ q(b) ∧ ∀xy((p(x) ∧ q(y)) → p(y))

(37)

is semi-safe.
For any finite set c of object constants, in c (x) stands for the formula
_
x = c.
c∈c

13. The definition here is slightly more general in that it does not refer to prenex form. Instead we require
a formula to be rectified.

149

Lee & Meng

The small predicate property can be expressed by the conjunction of the sentences


^
∀v1 , . . . , vn p(v1 , . . . , vn ) →
inc (vi )
i=1,...,n

for all predicate constants p occurring in F , where v1 , . . . , vn are distinct variables. We
denote this conjunction of the sentences by SPP c . By c(F ) we denote the set of all object
constants occurring in F .
Proposition 12 (Lee et al., 2009) For any semi-safe sentence F , formula SM[F ] entails
SPP c(F ) .
For example, for the semi-safe sentence (37), SM[(37)] entails


∀x p(x) → (x = a ∨ x = b)) ∧ ∀x(q(x) → (x = a ∨ x = b) .

(38)

The following proposition tells us that for a semi-safe sentence F , formula SM[F ] can
be equivalently rewritten as a first-order sentence.
Theorem 6 Let F be a rectified sentence that has no function constants of positive arity.
If F is semi-safe, then SM[F ] is equivalent to the conjunction of F , SPP c(F ) and a finite
number of first-order loop formulas.
Proof. If F is semi-safe, then SM[F ] entails SPP c(F ) . So it is sufficient to prove that under
the assumption SPP c(F ) , SM[F ] is equivalent to the conjunction of F and a finite number
of first-order loop formulas. It follows from I |= SPP c(F ) that F is bounded w.r.t. I. Since
every finite loop of F w.r.t. I can be represented by a finite set of atoms whose terms are
object variables, it follows from Theorem 2 that I satisfies SM[F ] iff I satisfies the loop
formulas of those sets.

For example, SM[(37)] is equivalent to the conjunction of F , (38) and the universal
closures of
p(z) → z = a ∨ (p(x) ∧ q(z) ∧ z 6= x)
q(z) → z = b
Note that the condition on a finite complete set of loops in Corollaries 6 and 7, and the
condition on semi-safety in Theorem 6 do not entail each other. For instance, formula (37)
is semi-safe, but has no finite complete set of first-order loops, while ∃x p(x) has a finite
complete set of loops {{p(x)}}, but it is not semi-safe. Also program Π1 in Section 1 has a
finite complete set of loops, but it is not semi-safe due to w in the fourth rule.

6. Programs with Explicit Quantifiers
In the following we extend the syntax of a logic program by allowing explicit quantifiers. A
rule with quantifiers is of the form
H ← G,
(39)
where G and H are first-order formulas such that every occurrence of every implication
in G and H belongs to a negative formula. A program with quantifiers is a finite set of rules
150

First-Order Stable Model Semantics and First-Order Loop Formulas

with quantifiers. Program Π1 in Section 1 is an example. The semantics of such a program
is defined by identifying the program with its FOL-representation under the stable model
semantics. By restricting the syntax of a program like the one above, in comparison with
the syntax of an arbitrary formula, we are able to write a more succinct loop formulas, as
we show below.
Let F be a formula and Y a finite set of atoms. By FY we denote the formula obtained
from F by replacing every occurrence
of every atom p(t) in F that does not belong to a
V
negative formula with p(t) ∧ p(t0 )∈Y t 6= t0 . Let Π be a program with quantifiers. Given
a finite set Y of atoms of σ(Π), we first rename variables in Π so that no variables in Π
occur in Y . We define the formula QES Π (Y ) (“External Support Formula for Programs
with Quantifiers”) to be the disjunction of
∃z(GY ∧ ¬HY )

(40)

for every rule (39) such that H contains a strictly positive occurrence of a predicate constant
that occurs in Y , and z is the list of all free variables in the rule that do not occur in Y .
The loop formula of Y for Π is the universal closure of
^
Y → QES Π (Y ).
(41)
The following proposition tells us that (41) is equivalent to (12) when the notions are
applied to a program with explicit quantifiers. It also shows that (41) is a generalization of
the definition of a loop formula for a disjunctive program.
Proposition 13 Let Π be a program with quantifiers, F the FOL-representation of Π,
and Y a finite set of atoms. Under the assumption Π, formula QES Π (Y ) is equivalent to
¬NES F (Y ). If Π is a disjunctive program in normal form, then QES Π (Y ) is also equivalent
to ES Π (Y ) under the assumption Π.
Note that the size of (41) for each Y is polynomial to the size of the given program.
This is not the case when we apply (12) to the FOL-representation of the program, due to
the expansion of NES for nested implications. On the other hand, the syntactic condition
imposed on the rule with quantifiers avoids such an exponential blow up, as the following
lemma tells us.
Lemma 4 Let F be a formula such that every occurrence of an implication in F belongs
to a negative formula and let Y be a set of atoms. NES F (Y ) is equivalent to FY .
Proof. By induction on F .



Example 2 (continued) First-Order Loop Formula when Π is understood as an
extended program (Using QES Π (Y )) : Under the assumption Π,
• LF Π (Y1 ) is equivalent to the universal closure of
p(u) → (∃x(q(x) ∧ ¬(p(x) ∧ x 6= u)) ∨ ∃z(¬r(z) ∧ ¬(p(z) ∧ z 6= u))).
151

Lee & Meng

• LF Π (Y2 ) is equivalent to the universal closure of
q(u) → ∃y(p(y) ∧ ¬(q(y) ∧ y 6= u)).
• LF Π (Y3 ) is equivalent to the universal closure of
r(u) → ⊥.
• LF Π (Y4 ) is equivalent to the universal closure of
(p(u) ∧ q(u)) → (∃x((q(x) ∧ x 6= u) ∧ ¬(p(x) ∧ x 6= u))
∨ ∃y((p(y) ∧ y 6= u) ∧ ¬(q(y) ∧ y 6= u))
∨ ∃z(¬r(z) ∧ ¬(p(z) ∧ z 6= u))).

A finite set Γ of sentences entails a sentence F under the stable model semantics (symbolically, Γ |=SM F ), if every stable model of Γ satisfies F .
If SM[F ] can be reduced to a first-order sentence, as described in Theorem 5 and Theorem 6, then
Γ |=SM F iff Γ ∪ ∆ |= F,
where ∆ is the set of first-order loop formulas required (and possibly including SPP c(F )
when Theorem 6 is applied). This fact allows us to use first-order theorem provers to reason
about query entailment under the stable model semantics.
Example 9 Consider program Π1 in Section 1, which has the following finite complete
set of loops: {Man(u)}, {Spouse(u, v)}, {HasWife(u)}, {Married (u)}, {Accident(u, v)},
{Discount(u, v)}, and {HasWife(u), Married (u)}. Their loop formulas for Π1 ∪ Π2 ∪ Π3 are
equivalent to the universal closure of

Man(u) → ¬ Man(John) ∧ John 6= u ;

Spouse(u, v) → ¬ ∃y Spouse(John, y) ∧ (John, y) 6= (u, v) ;

HasWife(u) → ∃x ∃y Spouse(x, y) ∧ ¬(HasWife(x) ∧ x 6= u)

∨ ∃x Man(x) ∧ Married (x) ∧ ¬(HasWife(x) ∧ x 6= u) ;

Married (u) → ∃x Man(x) ∧ HasWife(x) ∧ ¬(Married (x) ∧ x 6= u) ;
Accident(u, v) → ⊥;
Discount(u, v) →

∃x Married (x) ∧ ¬∃z Accident(x, z) ∧ ¬(∃w(Discount(x, w) ∧ (x, w) 6= (u, v))) ;
Married (u) ∧ HasWife(u) →

∃x ∃y Spouse(x, y) ∧ ¬(HasWife(x) ∧ (x 6= u))

∨ ∃x Man(x) ∧ Married (x) ∧ x 6= u ∧ ¬(HasWife(x) ∧ x 6= u)
∨ ∃x Man(x) ∧ HasWife(x) ∧ x 6= u ∧ ¬(Married (x) ∧ x 6= u) .
152

First-Order Stable Model Semantics and First-Order Loop Formulas

These loop formulas, conjoined with the FOL-representation of Π1 ∪ Π2 ∪ Π3 , entail under
first-order logic each of ∃x Married (x) and ∀xy(Discount(x, y) → x = John). We verified
the answers using a first-order theorem prover Vampire 14 .

7. Extension to Allow Extensional Predicates
The definition of a stable model in the journal paper by Ferraris et al. (2011), reviewed in
Section 2, is more general than the definition in their conference paper (Ferraris et al., 2007)
in that it allows us to distinguish between intensional and non-intensional (a.k.a. extensional) predicates. Similar to Datalog, intensional (output) predicates are characterized in
terms of extensional (input) predicates. For instance, consider Example 9 again, but now assume that Man and Spouse are non-intensional. Π1 ∪ Π2 ∪ Π3 still entails ∃xyDiscount(x, y)
but no longer entails ∀xy(Discount(x, y) → x = John) because there may be a person other
than John who has a spouse.
The results in the earlier sections can be extended to this general semantics in view of
Proposition 14 below, which characterizes SM[F ; p] in terms of SM[F ]. By pr (F ) we denote
the list of all predicate constants occurring in F ; by Choice(p) we denote the conjunction
of “choice formulas” ∀x(p(x) ∨ ¬p(x)) for all predicate constants p in p, where x is a list of
distinct object variables; by False(p) we denote the conjunction of ∀x¬p(x) for all predicate
constants p in p. We sometimes identify a list with the corresponding set when there is no
confusion.
Proposition 14 For any list p of predicate constants, formula SM[F ; p] is equivalent to
SM[F ∧ Choice(pr (F )\p) ∧ False(p\pr (F ))]

(42)

SM[F ¬¬ ∧ Choice(pr (F )\p) ∧ False(p\pr (F ))],

(43)

and to
where F ¬¬ is obtained from F by replacing every atom of the form q(t) in F such that q
does not belong to p by ¬¬q(t).
This proposition allows us to extend the results established for SM[F ] to SM[F ; p]. For
instance, Theorem 3 can be extended to SM[F ; p] by first rewriting it into the form SM[G],
where G is
F ¬¬ ∧ Choice(pr (F )\p) ∧ False(p\pr (F )).
(44)
In the next three corollaries, σ is a signature, F is a rectified sentence of σ (possibly
containing function constants of positive arity), p is any finite list of predicate constants
from σ, and G is (44).
The first corollary follows from Theorem 2 and Proposition 14.
Corollary 8 For any interpretation I of σ that satisfies F , if G is bounded w.r.t. I, then
the following conditions are equivalent to each other:
(a) I |= SM[F ; p];
14. http://www.vampire.fm .

153

Lee & Meng

(b) for every nonempty finite set Y of atoms formed from predicate constants in p and
object names for |I|, I satisfies LF F (Y );
(c) for every finite loop Y of G w.r.t. I whose predicate constants are contained in p, I
satisfies LF F (Y ).
The next corollary follows from Theorem 4 and Proposition 14.
Corollary 9 If G is bounded, then, for any interpretation I of σ that satisfies F and CETσ ,
the following conditions are equivalent to each other:
(a) I |= SM[F ; p];
(b) for every nonempty finite set Y of atoms of σ(G) whose predicate constants are contained in p, I satisfies LF F (Y );
(c) for every finite first-order loop Y of G whose predicate constants are contained in p,
I satisfies LF F (Y ).
The last corollary follows from Theorem 5 and Proposition 14.
Corollary 10 If G is in normal form and is bounded, then the following formulas are
equivalent to each other:
(a) SM[F ; p];
(b) {F } ∪ {LF F (Y ) | Y is a nonempty finite set of atoms of σ(G) whose predicate
constants are contained in p};
(c) {F } ∪ {LF F (Y ) | Y is a finite first-order loop of G whose predicate constants are
contained in p}.
Example 10 Consider Example 9 again, assuming that Man and Spouse are extensional.
Let F be the FOL-presentation of Π1 ∪ Π2 ∪ Π3 and let G be the formula (44). The loops
of G are the same as the loops of F . The loop formulas remain the same as before except
for the following loop formulas of Man(u) and Spouse(u, v):


Man(u) → ¬ Man(John) ∧ John 6= u ∨ ∃x ¬ (Man(x) ∧ x 6= u) ∨ ¬Man(x) ;

Spouse(u, v) → ¬ ∃y Spouse(John, y) ∧ (John, y) 6= (u, v) ∨

∃xy ¬ (Spouse(x, y) ∧ (x, y) 6= (u, v)) ∨ ¬Spouse(x, y) .
These two formulas are tautologies. As a result, the loop formulas of all loops, conjoined
with G, entail ∃xyDiscount(x, y), but no longer entail ∀xy (Discount(x, y) → x = John).
In general, there are no loops of G that contain both intensional and extensional predicates. Also every loop of G that contains an extensional predicate is a singleton, and the
loop formula of such a loop is a tautology.
154

First-Order Stable Model Semantics and First-Order Loop Formulas

Corollary 3 is extended to allow extensional predicates as in the following. By SLF[F ; p],
we denote
{LF F ({p(x)}) | p is a predicate constant in p, and x is a list
of distinct object variables whose length is the same as the arity of p}.
We say that a formula F is p-atomic-tight w.r.t. I if every infinite path in the dependency
graph of F w.r.t. I whose vertices are satisfied by I contains an atom whose predicate
constant is not in p.
Corollary 11 Let F be a rectified sentence (possibly containing function constants of positive arity), and let I be a model of F . If F is p-atomic-tight w.r.t. I, then I satisfies
SM[F ; p] iff I satisfies SLF[F ; p].
The definition of semi-safety is extended to distinguish between intensional and nonintensional predicates as follows. Let F be a formula that has no function constants of
positive arity. To every first-order formula F we assign a set RVp (F ) of restricted variables
relative to p as follows.
• For an atomic formula F (including equality and ⊥),
– if F is an equality between two variables, or is an atom whose predicate constant
is not in p, then RVp (F ) = ∅;
– otherwise, RVp (F ) is the set of all variables occurring in F ;
• RVp (G ∧ H) = RVp (G) ∪ RVp (H);
• RVp (G ∨ H) = RVp (G) ∩ RVp (H);
• RVp (G → H) = ∅.
• RVp (QvG) = RVp (G) \ {v} where Q ∈ {∀, ∃}.
We say that a variable x is p-restricted in F if x ∈ RVp (F ). A rectified formula F is
semi-safe relative to p if every strictly positive occurrence of every variable x belongs to a
subformula G → H, where x is p-restricted in G.
The small predicate property is generalized as follows. Formula SPP pc is the conjunction
of the sentences


^
∀v1 , . . . , vn p(v1 , . . . , vn ) →
inc (vi )
i=1,...,n

for all predicate constants p in p, where v1 , . . . , vn are distinct variables.
Proposition 15 (Lee et al., 2009) For any semi-safe sentence F relative to p, formula
SM[F ; p] entails SPP pc(F ) .
The following proposition tells us that for a semi-safe sentence F , formula SM[F ; p] can
be equivalently rewritten as a first-order sentence.
155

Lee & Meng

Theorem 7 Let F be a rectified sentence that has no function constants of positive arity.
If F is semi-safe relative to p, then SM[F ; p] is equivalent to the conjunction of F , SPP pc(F )
and a finite number of first-order loop formulas.
Proof. Let F be a sentence of the signature σ. If F is semi-safe relative to p, then SM[F ; p]
entails SPP pc(F ) , so it is sufficient to prove that under the assumption SPP pc(F ) , SM[F ; p]
is equivalent to the conjunction of F and a finite number of first-order loop formulas. By
Proposition 14, SM[F ; p] is equivalent to SM[G], where G is (44). Consider any interpretation I of σ that satisfies G and SPP pc(F ) . Note that the dependency graph of G w.r.t. I
contains no outgoing edges from a vertex whose predicate constant does not belong to p.
Together with the fact that I |= SPP pc(F ) , we conclude that each path in the dependency
graph whose vertices are satisfied by I visits only finitely many vertices. Consequently, G
is bounded w.r.t. I. Since every finite loop of G w.r.t. I can be represented by a finite set
of atoms whose terms are object variables, it follows from Theorem 2 that I satisfies SM[G]
iff I satisfies the loop formulas of those sets.


8. Related Work
The notion of a bounded program is related to the notion of a finitely recursive program
studied by Bonatti (2004), where a different definition of a dependency graph was considered. The atom dependency graph of a nondisjunctive ground program defined by Bonatti
is a directed graph such that the vertices are the set of ground atoms, and the edges go
from the atom in the head to atoms in the body of every rule, including those in the negative body. A program is called finitely recursive if, for every atom, there are only finitely
many atoms reachable from it in the atom dependency graph. It is clear that every finitely
recursive program is bounded, but the converse does not hold. For instance, the program
p(x) ← not p(f (x))
is bounded, but is not finitely recursive because there are infinite paths that involve negative
edges. Also the program
p(a) ← q(f (x))
is bounded, but is not finitely recursive because infinitely many atoms q(f (a)), q(f (f (a))), . . .
can be reached from p(a) in the atom dependency graph. Like bounded programs, checking
finitely recursive programs is undecidable in the presence of function constants of positive
arity.
Lin and Wang (2008) extended answer set semantics with functions by extending the
definition of a reduct, and also provided loop formulas for such programs. We can provide
an alternative account of their results by considering the notions there as special cases of
the definitions presented in this paper. For simplicity, we assume non-sorted languages.15
Essentially, they restricted attention to a special case of non-Herbrand interpretations such
that object constants form the universe, and ground terms other than object constants are
mapped to object constants. According to Lin and Wang, an LW-program P consists of
15. Lin and Wang (2008) consider essentially many-sorted languages. The result of this section can be
extended to that case by considering many-sorted SM (Kim, Lee, & Palla, 2009).

156

First-Order Stable Model Semantics and First-Order Loop Formulas

type definitions and a set of rules. Type definitions introduce the domains for a many-sorted
signature consisting of some object constants, and includes the evaluation of each function
symbol of positive arity that maps a list of object constants to an object constant. Since we
assume non-sorted languages, we consider only a single domain (universe). We say that an
interpretation I is a P -interpretation if the universe is the set of object constants specified
by P , object constants are evaluated to itself, and ground terms other than object constants
are evaluated conforming to the type definitions of P .
Proposition 16 Let P be an LW-program and let F be the FOL-representation of the set
of rules in P . The following conditions are equivalent to each other:
(a) I is an answer set of P according to Lin and Wang (2008);
(b) I is a P -interpretation that satisfies SM[F ];
(c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of
F w.r.t. I.
The equivalence between (b) and (c) follows from Proposition 2 since the universe is
finite. The equivalence between (a) and (c) follows from the fact that LW answer sets can
be characterized by loop formulas that are defined by Lin and Wang (2008) and that these
loop formulas are essentially the same as the loop formulas in (c).
Since the proposal of the first-order stable model semantics, there have been some papers
about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program Π that has no function constants of positive arity, its first-order stable
model semantics can be reformulated by a progression based semantics. They also showed
that the programs whose answer sets can be found by a finite progression are exactly those
that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010)
show a game-theoretic characterization for the first-order indefinability of first-order answer
set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order
definability on finite structures by turning programs into modified completion using new
predicates to record levels. Chen, Lin, Zhang, and Zhou (2011) present a condition called
“loop-separable,” which is more refined than finite complete set of loops under which the
finite answer sets of a program can be captured by first-order sentences. However, like the
condition of finite complete set of loops, this condition is disjoint with semi-safety. The
following program is semi-safe but not loop-separable:
p(x) ← p(y), q(x, y).
However, all this work is limited to nondisjunctive programs that contain no function constants of positive arity. Our work is not limited to finite structures, and considers function
constants of positive arity as well. Nonetheless the above papers on first-order definability
are closely related to our work and more insights would be gained from the relationship
between them.
The use of first-order theorem provers for the stable model semantics was already investigated by Sabuncu and Alpaslan (2007), but their results are limited in several ways. They
157

Lee & Meng

considered nondisjunctive logic programs with “trivial” loops only, in which case the stable
model semantics is equivalent to the completion semantics. They also restricted attention
to Herbrand models.

9. Conclusion
This paper puts first-order loop formulas in the context of first-order reasoning and studies
how they are related to first-order stable model semantics. The similarities and mismatches
found in this paper provide useful insights into first-order reasoning with stable models.
Future work is to find further restrictions that make first-order stable model reasoning
decidable and computable in an efficient manner, like the conditions imposed in “finitary”
programs (Bonatti, 2004). Recently, the first-order stable model semantics was shown to
be used as a unifying nonmonotonic logic for integrating rules and ontologies (de Bruijn,
Pearce, Polleres, & Valverde, 2010; Lee & Palla, 2011), in which ontology predicates are
identified with extensional predicates. Based on the studied relationship between first-order
stable model semantics and first-order loop formulas, one may find further restrictions that
are tailored to the hybrid knowledge bases for efficient computation.

Acknowledgments
We are grateful to Joseph Babb, Michael Bartholomew, Piero Bonatti, Vladimir Lifschitz,
and Ravi Palla for useful discussions, and to the anonymous referees for their useful comments. The authors were partially supported by the National Science Foundation under
Grant IIS-0916116 and by the IARPA SCIL program.

Appendix A. Proofs
The proofs are presented in the order of dependencies. Theorem 3 is the main theorem.
The proof of Theorem 2 uses Theorem 3. The proofs of Theorems 4 and 5 follow from
Theorem 2. The proof of Lemma 1 follows from Proposition 13.
In the following, unless otherwise noted, F is a rectified first-order sentence, p is the list
of distinct predicate constants p1 , . . . , pn occurring in F , symbols u, v are lists of distinct
predicate variables of the same length as p, and symbols q, r are lists of distinct predicate
names of the same length as p.
A.1 Proof of Theorem 3
Theorem 3
other:

For any rectified sentence F , the following sentences are equivalent to each

(a) SM[F ];
(b) F ∧ ∀u((u ≤ p) ∧ Nonempty(u) → ¬NSES F (u));
(c) F ∧ ∀u((u ≤ p) ∧ Ext-Loop F (u) → ¬NSES F (u)).
158

First-Order Stable Model Semantics and First-Order Loop Formulas

The notation that we use in the proof involves predicate expressions (Lifschitz, 1994,
Section 3.1) of the form
λxF (x),
(45)
where F (x) is a formula. If e is (45) and G(p) is a formula containing a predicate constant
p of the same arity as the length of x then G(e) stands for the result of replacing each
atomic part of the form p(t) in G(p) with F (t), after renaming the bound variables in G(p)
in the usual way, if necessary. For instance, if G(p) is p(a) ∨ p(b) then G(λy(x = y)) is
x = a ∨ x = b. Substituting a tuple e of predicate expressions for a tuple p of predicate
constants is defined in a similar way.
Lemma 5 Let v be the list of λyi (pi (yi ) ∧ ¬ui (yi )). The following formulas are logically
valid:
• u ≤ p → (F ∗ (u) ↔ NSES F (v));
• u ≤ p → (F ∗ (v) ↔ NSES F (u)).
Proof. By induction.
A.1.1 Proof of Equivalence between (a) and (b) of Theorem 3
It is sufficient to show that
∃u(u < p ∧ F ∗ (u))
is equivalent to
∃v(v ≤ p ∧ Nonempty(v) ∧ NSES F (v)).
From left to right: Take u such that u < p∧F ∗ (u). Let v be the list of λyi (pi (yi ) ∧ ¬ui (yi )).
• Clearly, v ≤ p holds.
• From
u < p, it follows that there are x and i such that pi (x) ∧ ¬ui (x), from which
W
i
i
i ∃x vi (x ) follows, so that Nonempty(v) follows.
• By Lemma 5, NSES F (v) follows from u < p and F ∗ (u).
From right to left: Take v such that v ≤ p ∧ Nonempty(v) ∧ NSES F (v). Let u be the list
of λyi (pi (yi ) ∧ ¬vi (yi )).
• Clearly, u ≤ p holds. Moreover ¬(u = p) holds. Indeed, if u = p, then ∀xi ¬vi (xi )
follows, which contradicts the assumption Nonempty(v). Consequently, u < p follows.
• By Lemma 5, F ∗ (u) follows from v ≤ p and NSES F (v).

159

Lee & Meng

A.1.2 Proof of Proposition 3
Lemma 6 Let I be an interpretation of σ that contains σ(F ), and let q, r be lists of
predicate names corresponding to p. Let Z and Y be sets of atoms in the dependency graph
of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  )
and
pi (ξ  ) ∈ Z iff I |= ri (ξ  ),
where ξ  is a list of object names. Then
I |= r ≤ q ∧ EF (r, q)
iff Z is a subset of Y and there is an edge from an atom in Z to an atom in Y \ Z in the
dependency graph of F w.r.t. I.
Proof. From left to right: Assume I |= r ≤ q ∧ EF (r, q). The fact that Z is a subset of
Y follows from the assumption that I |= r ≤ q and the construction of Z and Y . Since
_
I |=
∃z(ri (t) ∧ qj (t0 ) ∧ ¬rj (t0 )),
(pi (t),pj (t0 )) : pi (t) depends on pj (t0 )
in a rule of F

where z is the list of all object variables in t and t0 , there is a substitution θ that maps
object variables in t and t0 to object names such that
_
I |=
ri (tθ) ∧ qj (t0 θ) ∧ ¬rj (t0 θ).
(pi (t),pj (t0 )) : pi (t) depends on pj (t0 )
in a rule of F

Consequently, there are atoms pi (t), pj (t0 ) such that pi (t) depends on pj (t0 ) in a rule of F
and I |= ri (tθ)∧qj (t0 θ)∧¬rj (t0 θ). From I |= ri (tθ) and the construction of Z, it follows that
pi (((tθ)I ) ) belongs to Z. Also from I |= qj (t0 θ) ∧ ¬rj (t0 θ), it follows that that pj (((t0 θ)I ) )
belongs to Y \ Z. Therefore, there is an edge from an atom in Z to an atom in Y \ Z in the
dependency graph of F w.r.t. I.
From right to left: Assume that Z is a subset of Y and there is an edge from an atom
pi (ξ  ) in Z to an atom pj (η  ) in Y \ Z in the dependency graph of F w.r.t. I. Clearly,
I |= r ≤ q.
From the assumption that pi (ξ  ) ∈ Z, pj (η  ) ∈ Y \ Z and the construction of Y and Z,
it follows that I |= ri (ξ  ) ∧ qj (η  ) ∧ ¬rj (η  ). From the definition of the dependency graph
w.r.t. I, it follows that there are pi (t), pj (t0 ) such that pi (t) depends on pj (t0 ) in a rule of
F with a substitution θ that maps object variables in t and t0 to object names such that
(tθ)I = ξ and (t0 θ)I = η.
Consequently,
_
I |=
ri (tθ) ∧ qj (t0 θ) ∧ ¬rj (t0 θ),
(pi (t),pj (t0 )) : pi (t) depends on pj (t0 )
in a rule of F

160

First-Order Stable Model Semantics and First-Order Loop Formulas

which is equivalent to saying that
_
I |=

∃z(ri (t) ∧ qj (t0 ) ∧ ¬rj (t0 )),

(pi (t),pj (t0 )) : pi (t) depends on pj (t0 )
in a rule of F

where z is the list of all variables in t and t0 .



Lemma 7 A graph (V, E) is strongly connected iff, for any nonempty proper subset U of
V , there is an edge from U to V \ U .
Proof. Follows from the definition of a strongly connected graph.



Proposition 3 Let q be a list of predicate names corresponding to p, and let Y be a set
of atoms in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. Then I |= Loop F (q) iff Y is a loop of F w.r.t. I.
Proof. From left to right: Assume that I |= Loop F (q). From I |= Nonempty(q), it
follows that Y is nonempty.
Take any nonempty proper subset Z of Y . Let r be the list of predicate names such
that
I |= ri (ξ  ) iff pi (ξ  ) ∈ Z.
It is clear that
I |= Nonempty(r) ∧ r < q.
Consequently, from I |= Loop F (q), it follows that I |= E F (r, q). By Lemma 6, there is an
edge from an atom in Z to an atom in Y \ Z. Consequently, by Lemma 7, Y induces a
strongly connected subgraph and thus a loop of F w.r.t. I.
From right to left: Let Y be loop of F w.r.t. I and q a list of predicate names such that
I |= qi (ξ  ) iff pi (ξ  ) ∈ Y.
Since Y is nonempty, I |= Nonempty(q).
Consider any list of predicate names r such that
I |= Nonempty(r) ∧ r < q.
Let Z be a set of vertices in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Z iff I |= ri (ξ  ).
Clearly, Z is a nonempty proper subset of Y . Since Y induces a strongly connected subgraph,
by Lemma 7, there is an edge from an atom in Z to an atom in Y \ Z. Consequently by
Lemma 6, I |= EF (r, q).


161

Lee & Meng

A.1.3 Proof of Proposition 4
Proposition 4 Let q be a list of predicate names corresponding to p, and let Y be a set
of atoms in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ),
where ξ  is a list of object names. Then
I |= Nonempty(q) ∧ ∀v((v ≤ q) ∧ Loop F (v) → EF (v, q))
iff Y is an unbounded set of F w.r.t. I.
Proof. From left to right: Assume
I |= Nonempty(q) ∧ ∀v(v ≤ q ∧ Loop F (v) → EF (v, q)).

(46)

Since I |= Nonempty(q), it is clear that Y is nonempty.
Take any subset Z of Y that is a loop of F w.r.t. I. Let r be a list of predicate names
such that
I |= ri (ξ  ) iff pi (ξ  ) ∈ Z.
Since Z is a subset of Y , it is clear that I |= r ≤ q. Since Z is a loop of F w.r.t. I, by
Proposition 3, I |= Loop F (r). Consequently, from (46) it follows that I |= E F (r, q). By
Lemma 6, there is an edge from an atom in Z to an atom in Y \ Z. Therefore, Y is an
unbounded set of F w.r.t. I.
From right to left: Let Y be an unbounded set of F w.r.t. I. Since Y is nonempty, it is
clear that I |= Nonempty(q).
Take any list of predicate names r such that I |= r ≤ q ∧ Loop F (r). Let Z be a set of
vertices in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Z iff I |= ri (ξ  ).
By Proposition 3, Z is a loop of F w.r.t. I. It is clear that Z is a subset of Y . Since Y is an
unbounded set of F w.r.t. I, there is an edge from Z to Y \ Z. Consequently by Lemma 6,
I |= EF (r, q).

A.1.4 Proof of Proposition 5
Proposition 5 For any negative formula F , formula
NSES F (u) ↔ F
is logically valid.
Proof. The proof follows immediately from the following two lemmas, which can be proved
by induction.


162

First-Order Stable Model Semantics and First-Order Loop Formulas

Lemma 8 For any formula F ,
NSES F (u) → F
is logically valid.
Lemma 9 Let F be a formula, and let SF be the set of pi (t) that has a strictly positive
occurrence in F . Formula
^
F∧
∀z¬vi (t) → NSES F (v)
(47)
pi (t)∈SF

is logically valid, where z is the tuple of variables in t that are not free in F .
A.1.5 Proof of Equivalence between (b) and (c) of Theorem 3
Lemma 10 Let F be a rectified formula, let SF+ be the set of all atoms pi (t) that have a
positive occurrence in F that does not belong to a negative formula, and let SF− be the set
of all atoms pi (t) that have a negative occurrence in F that does not belong to a negative
formula.16 The following formulas are logically valid, where z is the list of all variables in
t that are not free in F .
V
(a) (v ≤ u) ∧ pi (t)∈S + ∀z(ui (t) → vi (t)) ∧ NSES F (v) → NSES F (u);
F
V
(b) (v ≤ u) ∧ pi (t)∈S − ∀z(ui (t) → vi (t)) ∧ NSES F (u) → NSES F (v).
F

Proof. Both parts are proved simultaneously by induction on F .
Case 1: F is an atom pi (t).
Part (a): NSES F (v) entails NSES F (u) under the assumption
^
∀z(ui (t) → vi (t)).
+
pi (t)∈SF

Part (b): NSES F (u) entails NSES F (v) under the assumption v ≤ u.
Case 2: F is ⊥ or an equality. It is clear since NSES F (v) and NSES F (u) are the same as
F.
Case 3: F is G ∧ H or G ∨ H. Follows from I.H.
Case 4: F is G → H.
Part (a): Assume
(v ≤ u) ∧

^

∀z(ui (t) → vi (t)).

(48)

+
pi (t)∈SF

We need to show that
(NSES G (v) → NSES H (v)) ∧ (G → H)
16. Note that we distinguish between formula being negative and an occurrence being negative. See at the
end of Section 2.

163

Lee & Meng

entails
(NSES G (u) → NSES H (u)) ∧ (G → H).
Note that
^

∀z(ui (t) → vi (t))

−
pi (t)∈SG

and
^

∀z(ui (t) → vi (t))

+
pi (t)∈SH

are entailed by formula (48). By I.H., NSES G (u) entails NSES G (v) and NSES H (v) entails
NSES H (u).
Part (b): Similar to Part (a).
Case 5: F is ∀x G
Part (a): Assume
^

(v ≤ u) ∧

∀z(ui (t) → vi (t)) ∧ ∀xNSES G (v).

+
pi (t)∈SF

From the assumption NSES G (v), G follows by Lemma 8. Also
^
∀z0 (ui (t) → vi (t))
+
pi (t)∈SG

follows, where z0 is the list of all variables in t that are not free in G, so that by I.H. on G,
NSES G (u) holds from the assumption. Since x is not free in the assumption, ∀xNSES G (u)
holds as well.
Part (b): Similar to Part (a).
Case 6: F is ∃x G.
Part (a): Assume
^

(v ≤ u) ∧

∀z(ui (t) → vi (t)) ∧ ∃xNSES G (v).

(49)

∀z(ui (t) → vi (t)) ∧ NSES G (v).

(50)

+
pi (t)∈SF

Take x such that
(v ≤ u) ∧

^
+
pi (t)∈SF

From NSES G (v), by Lemma 8, G follows. Also
^
∀z0 (ui (t) → vi (t))
+
pi (t)∈SG

follows, where z0 is the list of all variables in t that are not free in G. By I.H. on G,
NSES G (u) holds under the assumption (50). Consequently, ∃xNSES G (u) holds from the
164

First-Order Stable Model Semantics and First-Order Loop Formulas

same assumption. Since x is not free in (49), we conclude that ∃xNSES G (u) holds from
the assumption (49).
Part (b): Similar to Part (a).



Lemma 11 For any rectified formula F ,
(v ≤ u) ∧ ¬EF (v, u) ∧ NSES F (u) → NSES F (v)
is logically valid.
Proof. By induction on F .
Case 1: F is an atom pi (t). NSES F (u) entails NSES F (v) under the assumption v ≤ u.
Case 2: F is ⊥ or equality. It is clear since NSES F (v) and NSES F (u) are the same as F .
Case 3: F is G ∧ H or G ∨ H. Follows from I.H.
Case 4: F is G → H. Assume
(v ≤ u) ∧ ¬EF (v, u) ∧ NSES F (u)
and NSES G (v). From NSES F (u), by Lemma 8, we conclude G → H. From NSES G (v),
by Lemma 8, G follows, and consequently H.
Assume ¬NSES H (v) for the sake of contradiction. By Lemma 9, from H and ¬NSES H (v),
it follows that
_
∃xvi (t)
(51)
pi (t) : pi (t) occurs strictly positively in H

, where x is the list of variables in t that are not free in H.
Since F is rectified, the variables in F can be partitioned into three sets: the list of
variables x that are not free in H, the list of variables y that are not free in G, and the
rest. Note that ¬EF (v, u) entails


^
∃xvi (t) → ∀y(uj (t0 ) → vj (t0 )) ,
(52)
(pi (t),pj (t0 )) : pi (t) depends on pj (t0 ) in a rule G→H in F
pi (t) occurs in H,pj (t0 ) occurs in G

where x is the list of all variables in t that are not free in H, and y is the list of all variables
in t0 that are not free in G. From (51) and (52), we conclude
^
∀y(uj (t0 ) → vj (t0 )).
pj (t0 ) : pj (t0 ) occurs positively and not in a negative subformula of G

From this, together with the assumption (v ≤ u) and NSES G (v), by Lemma 10 (a),
NSES G (u) follows. Thus NSES H (u) follows from NSES F (u) and NSES G (u). Since ¬E F (v, u)
entails ¬E H (v, u), by I.H. on H, NSES H (v) follows, which contradicts the assumption.
Case 5: F is ∀xG or ∃xG. Follows from I.H.
165



Lee & Meng

Lemma 12
Nonempty(u) → ∃v(v ≤ u ∧ Ext-Loop F (v) ∧ ¬EF (v, u))
is logically valid.
Proof. Take any list q of predicate names, and any interpretation I that satisfies Nonempty(q).
Let Y be a set of vertices in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ).
Consider the subgraph G of the dependency graph of F w.r.t. I that is induced by Y . If Y
is an unbounded set w.r.t. I, by Proposition 4, I |= Ext-Loop F (q). So
I |= q ≤ q ∧ Ext-Loop F (q) ∧ ¬EF (q, q).
Otherwise, consider the graph G0 that is obtained from G by collapsing strongly connected
components of G, i.e., the vertices of G0 are the strongly connected components of G and
G0 has an edge from V to V 0 if G has an edge from a vertex in V to a vertex in V 0 . Since
we assumed that Y is not an unbounded set w.r.t. I, there exists a vertex Z in G0 that has
no outgoing edges. Consider the list of predicate names r such that
I |= ri (ξ  ) iff pi (ξ  ) ∈ Z.
It is clear that I |= r ≤ q. By Proposition 3, I |= Loop F (r) thus I |= Ext-Loop F (r). Since
there is no edge from Z to Y \ Z, by Lemma 6, I |= ¬EF (r, q). Consequently, the claim
follows.

Proof of Equivalence Between (b) and (c) of Theorem 3
From (b) to (c):
valid.

Clear from that the formula Ext-Loop F (u) → Nonempty(u) is logically

From (c) to (b): Assume
F ∧ ∀v(v ≤ p ∧ Ext-Loop F (v) → ¬NSES F (v)).
Take any u such that u ≤ p ∧ Nonempty(u). By Lemma 12, it follows from Nonempty(u)
that there exists v such that v ≤ u ∧ Ext-Loop F (v) ∧ ¬EF (v, u). It is clear that v ≤ p
follows from v ≤ u and u ≤ p. It follows from the assumption that ¬NSES F (v). Then by
Lemma 11, ¬NSES F (u) follows from v ≤ u and ¬EF (v, u).

A.2 Proof of Theorem 2
Lemma 3 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is
bounded w.r.t. I,
I |= ∃u(u ≤ p ∧ Ext-Loop F (u) ∧ NSES F (u))
166

First-Order Stable Model Semantics and First-Order Loop Formulas

iff there is a finite loop Y of F w.r.t. I such that
^

I |=
Y ∧ NES F (Y ) .
Proof. From left to right: Assume
I |= q ≤ p ∧ Ext-Loop F (q) ∧ NSES F (q)
for some list of predicate names q. Consider Y to be the set of vertices in the dependency
graph of F w.r.t. I such that
pi (ξ  ) ∈ Y iff I |= qi (ξ  ).
Since I |= Ext-Loop F (q), by Proposition 3 and Proposition 4, it follows that Y is an
extended loop of F w.r.t. I. Since I |= qi (ξ  ) for all pi (ξ  ) ∈ Y and I |= q ≤ p, it follows
that I satisfies every atom in Y . Together with the assumption that F is bounded w.r.t. I,
this implies that set Y is finite. Since I |= NSES F (q) and Y is finite, by Lemma 2, it
follows that I |= NES F (Y ).
From right to left: Consider any finite loop Y of F w.r.t. I. Assume
^
I |=
Y ∧ NES F (Y ).
Let q be a list of predicate names such that
I |= qi (ξ  ) iff pi (ξ  ) ∈ Y.
• I |= q ≤ p follows from the construction of q and I |=

V

Y.

• Since Y is a loop of F w.r.t. I, by Proposition 3, I |= Loop F (q), and consequently,
I |= Ext-Loop F (q).
• From I |= NES F (Y ), by Lemma 2, I |= NSES F (q).
Consequently, I |= ∃u(u ≤ p ∧ Ext-Loop F (u) ∧ NSES F (u)).



Theorem 2 Let F be a rectified sentence of a signature σ (possibly containing function
constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is
bounded w.r.t. I, then the following conditions are equivalent to each other:
(a) I satisfies SM[F ];
(b) for every nonempty finite set Y of atoms formed from predicate constants in σ(F ) and
object names for |I|, I satisfies LF F (Y );
(c) for every finite loop Y of F w.r.t. I, I satisfies LF F (Y ).
Proof. Between (a) and (c): By Theorem 3 and Lemma 3.
Between (b) and (c):
167

Lee & Meng

• From (b) to (c): Clear.
• From (c) to (b): Assume that I satisfies LF F (L) for every finite loop L of F w.r.t I.
Consider any nonempty finite set V
Y of atoms formed from predicate constants in σ(F )
and object names such that I |= Y . Let q be a list of predicate names such that
I |= qi (ξ  ) iff pi (ξ  ) ∈ Y.
Since Y is nonempty, it is clear that Nonempty(q) follows. In view of Lemma 12,
there is a list of predicate names r such that
I |= r ≤ q ∧ Ext-Loop F (r) ∧ ¬EF (r, q).

(53)

Consider Z to be the set of vertices in the dependency graph of F w.r.t. I such that
pi (ξ  ) ∈ Z iff I |= ri (ξ  ).
Since I |= Ext-Loop F (r), by Proposition
3 and PropositionV4, Z is an extended loop
V
of F w.r.t. I. Clearly, I |= Z since Z ⊆ Y and I |= Y . Since F is bounded
w.r.t. I, and Z is satisfied by I, it follows that Z is a finite loop of F w.r.t. I.
Since I |= r ≤ q ∧ ¬EF (r, q), Z is a subset of Y and, by Lemma 6, there is no edge
from Z to Y \ Z in the dependency graph of F w.r.t. I. Since I |= LF F (Z), we
conclude that I |= ¬NES F (Z), and by Lemma 2, I |= ¬NSES F (r). From (53) and
that I |= ¬NSES F (r), by Lemma 11, we have I |= ¬NSES F (q). By Lemma 2 again,
I |= ¬NES F (Y ). Consequently, I |= LF F (Y ).

A.3 Proof of Proposition 6
Proposition 6
If a rectified formula F of a signature σ is bounded, then F is bounded
w.r.t. any interpretation of σ that satisfies CETσ .
Lemma 13 For any terms t1 and t2 of signature σ, any interpretation I that satisfies
CETσ , and any substitution θ from object variables in t1 and t2 to object names such that
(t1 θ)I = (t2 θ)I , Robinson’s unification algorithm (Robinson, 1965), when applied to t1 and
t2 , returns a most general unifier (mgu) γ of t1 and t2 such that
(a) t1 γ = t2 γ, and
(b) for every variable x in t1 or t2 , (xγθ)I = (xθ)I .
Proof. From the assumptions, by Lemma 5.1 from the work of Kunen (1987), t1 and t2
are unifiable, in which case Robinson’s algorithm returns a mgu for t1 and t2 that maps
variables occurring in t1 and t2 into terms. Given this, part (b) can be proven by induction.

The proof of Proposition 6 follows from the following lemma.
168

First-Order Stable Model Semantics and First-Order Loop Formulas

Lemma 14 Let F be a rectified sentence of a signature σ, and let I be an interpretation of
σ that satisfies CETσ . For any path
hp1 (ξ 1 ), p2 (ξ 2 ), . . . , pk (ξ k ), pk+1 (ξ k+1 )i

(54)

in the dependency graph of F w.r.t I, there is a path
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), pk+1 (uk+1 )i
in the first-order dependency graph of F with a substitution θ that maps object variables in
ui to object names such that (ui θ)I = ξ i for all i.
Proof. Each edge (pi (ξ i ), pi+1 (ξ i+1 )) in (54) is obtained from a pair of atoms (pi (ti ), pi+1 (t0i ))
and a substitution θi such that pi (ti ) depends on pi+1 (t0i ) in a rule of F , and
(t1 θ1 )I = ξ 1 , (t0i θi )I = (ti+1 θi+1 )I = ξ i+1 (1 ≤ i < k), (t0k θk )I = ξ k+1 .

(55)

For simplicity we assume that each pair (pi (ti ), pi+1 (t0i )) considered above has no common
variables with another pair by first renaming variables. This allows us to use one substitution θ = θ1 . . . θk in place of individual θi in the rest of the proof.
We will show by induction that, for each j where j ∈ {1 . . . k}, there are substitutions
j
σi (1 ≤ i ≤ j) from variables in ti and t0i to terms such that
(a) hp1 (t1 )σ1j , p2 (t2 )σ2j , . . . , pj (tj )σjj , pj+1 (t0j )σjj i is a path in the first-order dependency
graph of F , and
(b) (ti σij θ)I = ξ i for all 1 ≤ i ≤ j, and (t0j σjj θ)I = ξ j+1 .
When j = 1, we take σij to be an identity substitution. Clearly, conditions (a) and (b)
are satisfied.
Otherwise, by I.H. we assume that, for some j in {1, . . . , k−1}, there are substitutions
σ1j , . . . , σjj such that conditions (a) and (b) are satisfied. We will prove that there are
substitutions σij+1 (1 ≤ i ≤ j +1) from variables in ti and t0i to terms such that
j+1
j+1
(a’) hp1 (t1 )σ1j+1 , p2 (t2 )σ2j+1 , . . . , pj+1 (tj+1 )σj+1
, pj+2 (t0j+1 )σj+1
i is a path in the first-order dependency graph of F , and
j+1 I
(b’) (ti σij+1 θ)I = ξ i for all 1 ≤ i ≤ j +1, and (t0j+1 σj+1
θ) = ξ j+2 .

From I.H., we have (t0j σjj θ)I = ξ j+1 and from (55) we have (tj+1 θ)I = ξ j+1 . By Lemma 13
there is a substitution γ from variables in t0j σjj or tj+1 to terms such that t0j σjj γ = tj+1 γ and
for any variable x in t0j σjj or tj+1 ,
(xγθ)I = (xθ)I .
We define σij+1 as
• σij γ when 1 ≤ i ≤ j and
169

(56)

Lee & Meng

• γ when i = j +1.
It is easy to check that condition (a’) is satisfied. To check that condition (b’) is satisfied,
consider any variable x in the set
{t1 σ1j , t2 σ2j , . . . , tj σjj , t0j σjj , tj+1 , t0j+1 }.

(57)

If x is in t0j σjj or tj+1 , by (56), (xγθ)I = (xθ)I . Otherwise, since γ does not change the
variables that are not in t0j σjj or tj+1 , (xγθ)I = (xθ)I . Consequently, for any variable x in
(57), we get (xγθ)I = (xθ)I . It remains to check the following.
• For 1 ≤ i ≤ j, (ti σij+1 θ)I = (ti σij γθ)I = (ti σij θ)I . The last one is equal to ξ i by I.H.
j+1 I
• (tj+1 σj+1
θ) = (tj+1 γθ)I = (tj+1 θ)I . The last one is equal to ξ j+1 by (55).
j+1 I
• (t0j+1 σj+1
θ) = (t0j+1 γθ)I = (t0j+1 θ)I . The last one is equal to ξ j+2 by (55).


A.4 Proof of Proposition 7
Proposition 7 For any rectified sentence F of a signature σ and for any interpretation
I of σ that satisfies CETσ , I is a model of
{LF F (Y ) | Y is a finite first-order loop of F }
iff I is a model of
{LF F (Y ) | Y is a finite loop of F w.r.t. I}.

The proof follows immediately from the following fact and Lemma 15.
Fact 1 Let F be a rectified sentence of a signature σ, and let I be an interpretation of σ.
For any first-order loop Y of F and any substitution θ that maps variables in Y to object
names, Y 0 = {pi (ξ  ) | pi (t) ∈ Y θ, tI = ξ} is a loop of F w.r.t. I.
Lemma 15 Let F be a rectified sentence of a signature σ, and let I be an interpretation
of σ. If I satisfies CETσ , then, for any finite loop Y 0 of F w.r.t. I, there is a finite
loop Y of F with a substitution θ that maps variables in Y to object names such that
Y 0 = {pi (ξ  ) | pi (t) ∈ Y, (tθ)I = ξ}.
Proof. Without loss of generality, consider a path
hp1 (ξ 1 ), p2 (ξ 2 ), . . . , pk (ξ k ), p1 (ξ 1 )i
(k ≥ 1) in the dependency graph of F w.r.t. I that consists of the vertices in Y 0 . Since
I |= CETσ , by Lemma 14, there is a path
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), p1 (uk+1 )i
170

First-Order Stable Model Semantics and First-Order Loop Formulas

in the first-order dependency graph of F with a substitution θ that maps variables in ui
to object names such that (ui θ)I = ξ i for all 1 ≤ i ≤ k, and (uk+1 θ)I = ξ 1 . Since
(uk+1 θ)I = (u1 θ)I , by Lemma 13, there is a unifier γ for uk+1 and u1 such that, for any
variable x in uk+1 or u1 , (xγθ)I = (xθ)I . Consequently,
{p1 (u1 γ), p2 (u2 γ), . . . , pk (uk γ)}
induces a finite strongly connected subgraph such that (ui γθ)I = (ui θ)I = ξ i .



A.5 Proof of Proposition 8
Proposition 8 If a rectified formula F in normal form is bounded, then F is bounded
w.r.t. any interpretation.
The proof follows from the following lemma.
Lemma 16 Let F be a rectified sentence of a signature σ in normal form, and let I be an
interpretation of σ. For any path
hp1 (ξ 1 ), p2 (ξ 2 ), . . . , pk (ξ k ), pk+1 (ξ k+1 )i
in the dependency graph of F w.r.t I, there exists a path
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), pk+1 (uk+1 )i
in the first-order dependency graph of F with a substitution θ that maps object variables in
ui to object names such that (ui θ)I = ξ i for all i, and u1 is a list of object variables.
Proof. The proof is similar to the proof of Lemma 14 except that we do not require that
I satisfy CETσ . Instead, the existence of a unifier γ for t0j σjj and tj+1 is ensured by the
assumption on normal form that tj+1 is a list of variables and the assumption that t0j σjj
contains none of those variables (due to variable renaming).
A.6 Proof of Proposition 9
Proposition 9 If a rectified sentence F in normal form is bounded, then for any interpretation I, I is a model of
{LF F (Y ) | Y is a finite first-order loop of F }
iff I is a model of
{LF F (Y ) | Y is a finite loop of F w.r.t. I}.

The proof follows from Fact 1 and the following lemma.
Lemma 17 If a rectified sentence F in normal form is bounded, then for any finite loop
Y 0 of F w.r.t. I, there is a finite loop Y of F with a substitution θ that maps variables in
Y to object names such that Y 0 = {pi (ξ  ) | pi (t) ∈ Y, (tθ)I = ξ}.
171

Lee & Meng

Proof. Let Y 0 be a finite loop of F w.r.t. I. Without loss of generality, there is a path
hp1 (ξ 1 ), p2 (ξ 2 ), . . . , pk (ξ k ), p1 (ξ 1 )i
(k ≥ 1) in the dependency graph of F w.r.t. I that consists of the vertices in Y 0 . Since F
is in normal form, by Lemma 16, there are a path
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), p1 (uk+1 )i

(58)

in the first-order dependency graph of F , where u1 consists of object variables only, and
a substitution θ that maps variables in ui to object names such that (ui θ)I = ξ i for all
1 ≤ i ≤ k, and (uk+1 θ)I = ξ 1 . There are two cases to consider.
• Case 1: There is a unifier γ for u1 and uk+1 that maps variables in u1 to terms in uk+1
so that u1 γ = uk+1 . It follows that, for any variable x in uk+1 or u1 , (xγθ)I = (xθ)I .
Consequently,
{p1 (u1 γ), p2 (u2 γ), . . . , pk (uk γ)}
induces a finite strongly connected subgraph such that (ui γθ)I = (ui θ)I = ξ i .
• Case 2: There is no such unifier γ.
Consider another path
hp1 (v1 ), p2 (v2 ), . . . , pk (vk ), p1 (vk+1 )i
that is obtained similar to (58) except that the variables in the path are disjoint from
the variables in (58). Clearly, there is a unifier γ 0 for uk+1 and v1 that maps the
variables v1 to terms, so that
hp1 (u1 ), p2 (u2 ), . . . , pk (uk ), p1 (v1 γ 0 ), p2 (v2 γ 0 ), . . . , pk (vk γ 0 )i
is another path in the first-order dependency graph of F . It is clear that using the
same construction repeatedly, we can form an infinite path that visits infinitely many
vertices in the first-order dependency graph. But this contradicts the assumption that
F is bounded.

A.7 Proof of Proposition 11
We will use the following lemma in this section and the next section, which extends Theorem 2 in the work of Chen et al. (2006) that provides a few equivalent conditions for a
program to have a finite complete set of loops to a disjunctive program and a sentence.
Lemma 18 (Chen et al., 2006, Thm. 2) For any formula F that contains no function
constants of positive arity, the following conditions are equivalent:
(a) F has a finite complete set of loops.
172

First-Order Stable Model Semantics and First-Order Loop Formulas

(b) There is a nonnegative integer N such that for every loop L of F , the number of
variables in L is bounded by N .
(c) For any loop L of F and any atom A1 and A2 in L, the variables occurring in A1 are
identical to the variables occurring in A2 .
(d) For any loop L of Ground σ(F )∪{c1 ,c2 } (F ) where c1 , c2 are two new object constants,
there are no two atoms A1 and A2 in L such that A1 mentions c1 but A2 does not or
A1 mentions c2 but A2 does not.
Proposition 11 For any rectified formula F that contains no function constants of positive
arity, F is bounded iff F has a finite complete set of loops.
Proof. From left to right: Assume that F is bounded. Then every loop of F is finite. It
follows that there exists a nonnegative integer N such that the number of variables in any
loop is bounded by N . By Lemma 18 (b), F has a finite complete set of loops.
From right to left: Assume that F has a finite complete set of loops and, for the sake of
contradiction, assume that it is not bounded. Without loss of generality, there is an infinite
path
hp1 (t1 )σ1 , p2 (t2 )σ2 , . . .i
(59)
in the first-order dependency graph of F that visits infinitely many vertices, where pi (ti )
are atoms occurring in F and σi are substitutions.
Since F is a finite string, it contains finitely many atoms. It follows that there is an
atom pi (ti ) occurring in F with arbitrarily many substitutions σ such that atoms pi (ti )σ
are contained in (59). Without loss of generality, consider the path
hpi (ti )σi , pi+1 (ti+1 )σi+1 , . . . , pi (ti )σk i
that is contained in (59), where σk and σi agree on substituting object constants for variables
in ti . Since ti σi and ti σk contain no function constant, there exists a substitution σ0 that
maps variables in ti σk to terms in ti σi so that ti σk σ0 = ti σi . Consequently,
{pi (xi )σi σ0 , pi+1 (xi+1 )σi+1 σ0 , . . . , pi (xi )σk σ0 }
is a loop of F . Since the length of the path is arbitrarily large, there are arbitrarily many
variables occurring in the loop. By Lemma 18 (b), it follows that F has no finite complete
set of loops.

A.8 Proof of Proposition 10
Proposition 10
arity),

For any rectified sentence F (allowing function constants of positive

(a) checking whether F is bounded is not decidable;
(b) checking whether F is atomic-tight is not decidable.
If F contains no function constants of positive arity,
(c) checking whether F is bounded is decidable;
(d) checking whether F is atomic-tight is decidable.
173

Lee & Meng

A.8.1 Proof of Part (a) and (b)
We show the proof of Part (a) first. The proof repeats, with minor modifications, the
argument from the proof of Theorem 26 from the work of Bonatti (2004), which considers
the following program ΠM to simulate deterministic Turing machines M.
t(s, L, v, [V | R], C) ← t(s0 , [v 0 | L], V, R, C +1)
t(s, L, v, [ ], C) ← t(s0 , [v 0 | L], b, [ ], C +1)
t(s, [V | L], v, R, C) ← t(s0 , L, V, [v 0 | R], C +1)
t(s, [ ], v, R, C) ← t(s0 , [ ], b, [v 0 | R], C +1)
t(s, L, v, R, C)

for
for
for
for
for

all
all
all
all
all

instr.hs, v, v 0 , s0 , righti
instr.hs, v, v 0 , s0 , righti
instr.hs, v, v 0 , s0 , lefti
instr.hs, v, v 0 , s0 , lefti
final states s.

The Halting problem can be reduced to the problem of checking bounded formulas. More
precisely, we show that ΠM is bounded iff M terminates from every configuration.
We first establish the following facts:
(i) for every non-terminating computation of M on input x, there is a corresponding
infinite path in the first-order dependency graph of ΠM that visits infinitely many
vertices;
(ii) if there is an infinite path in the first-order dependency graph of ΠM , then there
is an infinite path starting with a legal encoding of an input and corresponds to a
non-terminating computation of M.
Fact (i) is immediate from the definition of ΠM : Note that the step counter (the last
argument of t) ensures that the dependency graph is acyclic. Then, whenever M falls into
a cycle, the dependency graph contains an infinite acyclic path that visits infinitely many
vertices and hence the program is not bounded.
Fact (ii) can be proven as follows. Assume that there is an infinite path in the dependency graph. We observe that the first argument of every vertex in the path must be a legal
state and the third argument of every vertex must be a legal tape value. Otherwise, there
is no outgoing edge from the vertices in the dependency graph of ΠM . So only the second,
fourth and fifth arguments can contain variables or illegal values which were obtained from
substitutions from the variables L, R, V and C. In this case, we can easily find substitutions
from these variables or illegal values to legal values and apply them uniformly along the
path, so that we obtain another infinite path starting from the vertex that correctly encodes
a configuration of M and thus M has a corresponding non-terminating computation.
The claim follows immediately from the two facts: if M does not terminate on some
computation, then by (i), ΠM is unbounded. If ΠM is unbounded, then by (ii), M does
not terminate.
The same proof works for Part (b) as well. This is because the step counter (the last
argument of t) ensures that the dependency graph is acyclic. Consequently, every infinite
path in the dependency graph visits infinitely many vertices, so that ΠM is atomic-tight iff
ΠM is bounded.

A.8.2 Proof of Part (c)
In view of the equivalence between (a) and (d) in Lemma 18, checking whether a formula
F containing no function constants of positive arity has a finite complete set of loops can
174

First-Order Stable Model Semantics and First-Order Loop Formulas

be done by examining a finite number of loops from a finite dependency graph, which is
decidable. By Proposition 11, it follows that checking whether F is bounded is decidable.

A.8.3 Proof of Part (d)
For any sentence F that has no function constants of positive arity and any finite set c of object constants, Ground c (F ) is defined recursively. If F is an atomic formula thenGround c (F )
is F . The function Ground c commutes with all propositional connectives; quantifiers turn
into finite conjunctions and disjunctions over all object constants occurring in c.
Lemma 19 Let c be the set consisting of all object constants occurring in F , and possibly a new object constant if F contains no object constants. F has a non-trivial loop iff
Ground c (F ) has a non-trivial loop.
In order to check whether F is atomic-tight, we first check whether F is bounded,
which is decidable. If F is not bounded, then F is not atomic-tight. Otherwise, in view of
Lemma 19, checking whether F is atomic-tight is the same as checking whether Ground c (F )
is atomic-tight. Since F contains no function constants of positive arity, the dependency
graph of Ground c (F ) is finite. So it is decidable to check whether the dependency graph of
Ground c (F ) has a non-trivial loop.

A.9 Proof of Proposition 13
Lemma 20 Let F be a formula and Y a set of atoms. If no predicate constant occurring
in Y occurs strictly positively in F , then NES F (Y ) is equivalent to F .
Proof. By induction.



Proposition 13 Let Π be a program with quantifiers, F the FOL-representation of Π,
and Y a finite set of atoms. Under the assumption Π, formula QES Π (Y ) is equivalent to
¬NES F (Y ). If Π is a disjunctive program in normal form, then QES Π (Y ) is also equivalent
to ES Π (Y ) under the assumption Π.
Proof. Between QES Π (Y ) and ¬NES F (Y ): ¬NES F (Y ) is
^
¬
∀x[(G → H) ∧ (NES G (Y ) → NES H (Y ))].

(60)

H←G∈Π

Under the assumption F , formula (60) is equivalent to
_
∃x(NES G (Y ) ∧ ¬NES H (Y )).

(61)

H←G∈Π

In view of Lemma 20, if H does not contain any strictly positive occurrence of a predicate
constant that belongs to Y , NES H (Y ) is equivalent to H. Also, it follows from Lemma 2
and Lemma 8 that NES G (Y ) implies G. So NES G (Y )∧¬NES H (Y ) conflicts the assumption
175

Lee & Meng

G → H when H does not contain any strictly positive occurrence of a predicate constant
that belongs to Y . As a result, under the assumption F , formula (61) is equivalent to the
disjunction of
∃x(NES G (Y ) ∧ ¬NES H (Y ))
(62)
for all rules H ← G, where H contains a strictly positive occurrence of a predicate constant
that belongs to Y . Note that G and H are formulas such that every occurrence of an
implication in G and H belongs to a negative formula. By Lemma 4, (62) is equivalent to
QES Π (Y ).
Between QES Π (Y ) and ES Π (Y ): When Π is a disjunctive program, QES Π (Y ) is the disjunction of


^
_
^

∃z B ∧ N ∧
(t 6= t0 ) ∧ ¬
(p(t) ∧
t 6= t0 )
(63)
p(t)∈B
p(t0 )∈Y

p(t0 )∈Y

p(t)∈A

over all rules (10) such that A contains a predicate constant that occurs in Y , where z is a
list of variables in (10) but not in Y . On the other hand, ES Π (Y ) is the disjunction of
0



∃z Bσ ∧ N σ ∧

^

_

0

(t 6= t ) ∧ ¬

p(t)∈Bσ
p(t0 )∈Y

^

(p(t) ∧

0

t 6= t )




(64)

p(t0 )∈Y

p(t)∈Aσ

over all rules (10) such that A contains a predicate constant that occurs in Y and Aσ∩Y 6= ∅,
where z0 is a list of variables in Aσ ← Bσ, N σ but not in Y .
It is clear that (64) implies (63). To prove that (63) implies (64), assume
B∧N ∧

^

_

(t 6= t0 ) ∧ ¬

p(t)∈B
p(t0 )∈Y

^

(p(t) ∧


t 6= t0 )

(65)

p(t0 )∈Y

p(t)∈A

and consider two cases.
V
If p(t0 )∈Y t 6= t0 for all p(t) ∈ A, then (65) is equivalent to
^

B∧N ∧

(t 6= t0 ) ∧ ¬

p(t)∈B
p(t0 )∈Y

_

p(t)

p(t)∈A

which contradicts the assumption Π.
Otherwise, there exists p(t) ∈ A and p(t0 ) ∈ Y such that t = t0 . Since Π is in normal form,
there exists σ that maps t to t0 , so that Aσ ∩ Y 6= ∅. Consequently, (65) is equivalent to
Bσ ∧ N σ ∧

^
p(t)∈Bσ
p(t0 )∈Y

_

(t 6= t0 ) ∧ ¬

p(t)∈Aσ

Thus the claim follows.

(p(t) ∧

^


t 6= t0 ) .

p(t0 )∈Y


176

First-Order Stable Model Semantics and First-Order Loop Formulas

A.10 Proof of Proposition 16
Proposition 16 Let P be an LW-program and let F be the FOL-representation of the set
of rules in P . The following conditions are equivalent to each other:
(a) I is an answer set of P according to Lin and Wang (2008);
(b) I is a P -interpretation that satisfies SM[F ];
(c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of
F w.r.t. I.
Given a program Π, Norm(Π) is a normal form of Π and Ground (Π) is a ground program
obtained from Π as described by Lin and Wang (2008). The proof of Proposition 16 follows
from the following lemma. We refer readers to the work of Lin and Wang for the definition
of ES (·, ·, ·) defined there.
Lemma
21 For any program Π and any set Y of ground atoms, ES Norm(Π) (Y ) is equivalent
W
to p(c)∈Y ES (p(c), Y, Ground (Π)).
Proof. By definition, ES Norm(Π) (Y ) is

_
∃z Bθ ∧ N θ ∧ xθ = tθ ∧

^


(t 6= t ) ,
0

(66)

q(t)∈Bθ
q(t0 )∈Y

p(x)←B,N,x=t is in Norm(Π)
θ:p(x)θ∈Y

where x is a list of distinct object variables, θ is a substitution that maps variables in x
to object constants occurring in Y , and z is the list of all variables that occur in the rule
p(x)θ ← Bθ, N θ, xθ = tθ. (66) is equivalent to


_
^
0
0
∃z B ∧ N ∧ t = c ∧
(t 6= t ) ,
(67)
p(t)←B,N ∈Π
p(c)∈Y

q(t)∈B
q(t0 )∈Y

where z0 is the list of all variables that occur in the rule p(t) ← B, N . In turn, (67) is
equivalent to


_
^
0
0
0
(tg 6= t ) .
(68)
B ∧N ∧d=c∧
p(d)←B 0 ,N 0 ∈Ground(Π)
p(c)∈Y

q(tg )∈B 0
q(t0 )∈Y

Note that when d does not cover c, there exists di ∈ d such that di mentions only constants
and pre-interpreted functions and di can not be evaluated to ci independent of interpretations. In that case, d = c is equivalent to ⊥. Thus (68) is equivalent to


_
_
^
0
0
0
(tg 6= t ) ,
(69)
B ∧N ∧d=c∧
p(c)∈Y

which is essentially

p(d)←B 0 ,N 0 ∈Ground(Π)
p(d) can cover p(c)

W

p(c)∈Y

q(tg )∈B 0
q(t0 )∈Y

ES (p(c), Y, Ground (Π)).

177



Lee & Meng

References
Asuncion, V., Lin, F., Zhang, Y., & Zhou, Y. (2010). Ordered completion for first-order
logic programs on finite structures. In AAAI, pp. 249–254.
Bonatti, P. A. (2004). Reasoning with infinite stable models. Artificial Intelligence, 156 (1),
75–111.
Chen, Y., Lin, F., Wang, Y., & Zhang, M. (2006). First-order loop formulas for normal
logic programs. In Proceedings of International Conference on Principles of Knowledge
Representation and Reasoning (KR), pp. 298–307.
Chen, Y., Lin, F., Zhang, Y., & Zhou, Y. (2011). Loop-separable programs and their firstorder definability. Artificial Intelligence, 175 (3-4), 890–913.
Chen, Y., Zhang, Y., & Zhou, Y. (2010). First-order indefinability of answer set programs
on finite structures. In AAAI, pp. 285–290.
Clark, K. (1978). Negation as failure. In Gallaire, H., & Minker, J. (Eds.), Logic and Data
Bases, pp. 293–322. Plenum Press, New York.
de Bruijn, J., Pearce, D., Polleres, A., & Valverde, A. (2010). A semantical framework for
hybrid knowledge bases. Knowl. Inf. Syst., 25 (1), 81–104.
Ferraris, P., Lee, J., & Lifschitz, V. (2006). A generalization of the Lin-Zhao theorem.
Annals of Mathematics and Artificial Intelligence, 47, 79–101.
Ferraris, P., Lee, J., & Lifschitz, V. (2007). A new perspective on stable models. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 372–379.
Ferraris, P., Lee, J., & Lifschitz, V. (2011). Stable models and circumscription. Artificial
Intelligence, 175, 236–263.
Gebser, M., Lee, J., & Lierler, Y. (2006). Elementary sets for logic programs. In Proceedings
of National Conference on Artificial Intelligence (AAAI), pp. 244–249.
Gebser, M., Lee, J., & Lierler, Y. (2011). On elementary loops of logic programs. Theory
and Practice of Logic Programming, To appear.
Gebser, M., & Schaub, T. (2005). Loops: Relevant or redundant?. In Proceedings of the
Eighth International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR’05), pp. 53–65.
Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming. In
Kowalski, R., & Bowen, K. (Eds.), Proceedings of International Logic Programming
Conference and Symposium, pp. 1070–1080. MIT Press.
Kim, T.-W., Lee, J., & Palla, R. (2009). Circumscriptive event calculus as answer set programming. In Proceedings of International Joint Conference on Artificial Intelligence
(IJCAI), pp. 823–829.
Kunen, K. (1987). Negation in logic programming. The Journal of Logic Programming,
4 (4), 289 – 308.
Lee, J. (2004). Nondefinite vs. definite causal theories. In Proceedings 7th Int’l Conference
on Logic Programming and Nonmonotonic Reasoning, pp. 141–153.
178

First-Order Stable Model Semantics and First-Order Loop Formulas

Lee, J. (2005). A model-theoretic counterpart of loop formulas. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 503–508.
Lee, J., Lierler, Y., Lifschitz, V., & Yang, F. (2010). Representing synonymity in causal logic
and in logic programming. In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR). http://peace.eas.asu.edu/joolee/papers/syn.pdf.
Lee, J., & Lifschitz, V. (2003). Loop formulas for disjunctive logic programs. In Proceedings
of International Conference on Logic Programming (ICLP), pp. 451–465.
Lee, J., Lifschitz, V., & Palla, R. (2009). Safe formulas in the general theory of stable models.
Technical Report. http://peace.eas.asu.edu/joolee/papers/safety.pdf.
Lee, J., & Lin, F. (2006). Loop formulas for circumscription. Artificial Intelligence, 170 (2),
160–185.
Lee, J., & Meng, Y. (2008). On loop formulas with variables. In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), pp. 444–453.
Lee, J., & Palla, R. (2011). Integrating rules and ontologies in the first-order stable model
semantics (preliminary report). In Proceedings of International Conference on Logic
Programming and Nonmonotonic Reasoning (LPNMR), pp. 248–253.
Lifschitz, V. (1994). Circumscription. In Gabbay, D., Hogger, C., & Robinson, J. (Eds.),
Handbook of Logic in AI and Logic Programming, Vol. 3, pp. 298–352. Oxford University Press.
Lifschitz, V., Morgenstern, L., & Plaisted, D. (2008). Knowledge representation and classical
logic. In van Harmelen, F., Lifschitz, V., & Porter, B. (Eds.), Handbook of Knowledge
Representation, pp. 3–88. Elsevier.
Lin, F., & Shoham, Y. (1992). A logic of knowledge and justified assumptions. Artificial
Intelligence, 57, 271–289.
Lin, F., & Wang, Y. (2008). Answer set programming with functions. In Brewka, G., &
Lang, J. (Eds.), Proceedings of International Conference on Principles of Knowledge
Representation and Reasoning (KR), pp. 454–465. AAAI Press.
Lin, F., & Zhao, Y. (2004). ASSAT: Computing answer sets of a logic program by SAT
solvers. Artificial Intelligence, 157, 115–137.
Lin, F., & Zhou, Y. (2011). From answer set logic programming to circumscription via logic
of GK. Artificial Intelligence, 175, 264–277.
Liu, L., & Truszczynski, M. (2006). Properties and applications of programs with monotone
and convex constraints. J. Artif. Intell. Res. (JAIR), 27, 299–334.
McCarthy, J. (1980). Circumscription—a form of non-monotonic reasoning. Artificial Intelligence, 13, 27–39,171–172.
McCarthy, J. (1986). Applications of circumscription to formalizing common sense knowledge. Artificial Intelligence, 26 (3), 89–116.
Pearce, D., & Valverde, A. (2005). A first order nonmonotonic extension of constructive
logic. Studia Logica, 80, 323–348.
179

Lee & Meng

Robinson, J. A. (1965). A machine-oriented logic based on the resolution principle. J. ACM,
12, 23–41.
Sabuncu, O., & Alpaslan, F. N. (2007). Computing answer sets using model generation
theorem provers. Unpublished Draft.
You, J.-H., & Liu, G. (2008). Loop formulas for logic programs with arbitrary constraint
atoms. In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI), pp.
584–589.
Zhang, Y., & Zhou, Y. (2010). On the progression semantics and boundedness of answer
set programs. In Proceedings of International Conference on Principles of Knowledge
Representation and Reasoning (KR), pp. 518–526.

180

2010 34th
IEEEAnnual
34th Annual
IEEE Computer Software and Applications Conference

Representing and Reasoning about Web Access Control Policies
Gail-Joon Ahn, Hongxin Hu, Joohyung Lee and Yunsong Meng
School of Computing, Informatics and Decision Systems Engineering
Arizona State University
Tempe, AZ 85287, USA
{gahn,hxhu,joolee,yunsong.meng}@asu.edu
access control policies for various Web applications. With
expressive policy languages such as XACML, assuring the
correctness of policy specifications becomes a crucial and
yet challenging task. Especially, identifying inconsistencies
and differences between policy specifications and their expected functions is critical since the correctness of the
implementation and enforcement of policies heavily relies
on the policy specification. Due to its flexibility, XACML
has been extended to support specialized access control
models. In particular, XACML profile for role-based access
control (RBAC) [4] provides a mapping between RBAC
and XACML. However, the current RBAC profile does
not support constraints that are an important element to
govern all other elements in RBAC. In RBAC, permissions
of specific actions on resources are assigned to authorized
users with the notion of roles and such assignments are
constrained with specific RBAC constraints. XACML-based
RBAC policies are written to specify such assignments
and corresponding rules, yet security leakage may occur
in specifying XACML-based RBAC policies without having
appropriate constraints in place. Furthermore, designing and
managing such Web access control policies are often errorprone due to the lack of logical and formal foundation.
In this paper, we propose a systematic method to represent
XACML policies in answer set programming (ASP), a
declarative programming paradigm oriented towards combinatorial search problems and knowledge intensive applications. Compared to a few existing approaches to formalizing
XACML policies, such as as [10], [16], our formal representation is more straightforward and can cover more XACML
features. Furthermore, translating XACML to ASP allows
us to leverage off-the-shelf ASP solvers for a variety of
analysis services such as policy verification, comparison and
querying. In addition, in order to support reasoning about
role-based authorization constraints, we introduce a general
specification scheme for RBAC constraints along with a
policy analysis framework, which facilitates the analysis
of constraint violations in XACML-based RBAC policies.
The expressivity of ASP, such as ability to handle default
reasoning and represent transitive closure, helps manage
XACML and RBAC constraints that cannot be handled in
other logic-based approaches [16]. We also overview our
tool XACML 2 ASP and conduct experiments with real-world

Abstract—The advent of emerging technologies such as Web
services, service-oriented architecture, and cloud computing
has enabled us to perform business services more efficiently
and effectively. However, we still suffer from unintended
security leakages by unauthorized services while providing
more convenient services to Internet users through such a
cutting-edge technological growth. Furthermore, designing and
managing Web access control policies are often error-prone due
to the lack of logical and formal foundation. In this paper,
we attempt to introduce a logic-based policy management
approach for Web access control policies especially focusing
on XACML (eXtensible Access Control Markup Language)
policies, which have become the de facto standard for specifying
and enforcing access control policies for various applications
and services in current Web-based computing technologies. Our
approach adopts Answer Set Programming (ASP) to formulate
XACML that allows us to leverage the features of ASP solvers
in performing various logical reasoning and analysis tasks such
as policy verification, comparison and querying. In addition,
we propose a policy analysis method that helps identify policy
violations in XACML policies accommodating the notion of
constraints in role-based access control (RBAC). We also
discuss a proof-of-concept implementation of our method called
XACML 2 ASP with the evaluation of several XACML policies
from real-world software systems.
Keywords-XACML; Role-based Access Control; Answer Set
Programming

I. I NTRODUCTION
With the explosive growth of Web applications and Web
services deployed on the Internet, the use of a policy-based
approach has received considerable attention to accommodate the security requirements covering large, open, distributed and heterogeneous computing environments. Policybased computing handles complex system properties by separating policies from system implementation and enabling
dynamic adaptability of system behaviors by changing policy configurations without reprogramming the systems. In
the era of distributed, heterogeneous and Web-oriented computing, the increasing complexity of policy-based computing
demands strong support of automated reasoning techniques.
Without analysis, most benefits of policy-based techniques
and declarative policy languages may be in vain.
XACML (eXtensible Access Control Markup Language)
[29], which is an XML-based language standardized by the
Organization for the Advancement of Structured Information
Standards (OASIS), has been widely adopted to specify
0730-3157/10 $26.00 © 2010 IEEE
DOI 10.1109/COMPSAC.2010.20

137

XACML policies to evaluate the effectiveness and efficiency
of our solution.
The rest of this paper is organized as follows. We give
an overview of XACML, RBAC and ASP in Section II. In
Section III, we show how XACML can be turned into ASP
and how XACML analysis can be carried out using ASP
solvers. We address XACML-based RBAC policy analysis
in Section IV. Section V presents the system XACML 2 ASP
along with experiments. We overview the related work in
Section VI. Section VII concludes this paper with the future
work.
II. BACKGROUND T ECHNOLOGIES
A. eXtensible Access Control Markup Language
XACML has become the de facto standard for describing
access control policies and offers a large set of built-in
functions, data types, combining algorithms, and standard
profiles for defining application-specific features. The root of
all XACML policies is a policy or a policy set. A policy set is
composed of a sequence of policies or other policy sets along
with a policy combining algorithm and a target. A policy
represents a single access control policy expressed through
a target, a set of rules and a rule combining algorithm. The
target defines a set of subjects, resources and actions the
policy or policy set applies to. For applicable policy sets and
policies, the corresponding targets should be true; otherwise,
the policy set or policy yields no decision on the request.
A rule set is a sequence of rules. Each rule in turn consists
of a target, a condition, and an effect. The target of a rule
has a similar structure as the target of a policy or a policy
set, and decides whether the request is applicable to the rule.
The condition is a Boolean expression to specify restrictions
on the attributes in the target and refines the applicability of
the rule and the effect is either one of “permit,” “deny,”
or “indeterminate.” If a request satisfies both the target
and condition of a rule, the response is sent with the decision specified by the effect element in the applicable rule.
Otherwise, the response yields “notApplicable” which is
typically considered as “deny.” Also, an XACML policy
description often has conflicting rules, policies or policy
sets, which are resolved by four different combining algorithms [29]: “Permit-overrides,” “Deny-Overrides,” “FirstApplicable,” and “Only-One-Applicable.”
• Permit-Overrides: If there is any applicable rule that
evaluates to permit, then the decision is permit. If
there is no applicable rule that evaluates to permit
but there is an applicable rule that evaluates to deny,
then the decision is deny. Otherwise, the decision is
notApplicable.
• Deny-Overrides: If there is any applicable rule that
evaluates to deny, then the decision is deny. If there
is no applicable rule that evaluates to deny but there
is an applicable rule that evaluates to permit, then

Figure 1.

•

•

An example XACML policy.

the decision is permit. Otherwise, the decision is
notApplicable.
First-Applicable: The decision is the effect of the
first applicable rule in the listed order. If there is no
applicable rule, then the decision is notApplicable.
Only-One-Applicable: If more than one rule is applicable, then the decision is indeterminate. If there is
only one applicable rule, then the decision is that of
the rule. If no rule is applicable, then the decision is
notApplicable.

Note that “Only-One-Applicable” combining algorithm is
defined only for policy sets.
Consider an example XACML policy for a software development company, which is utilized throughout this paper,
shown in Figure 1. Figure 2 gives a tree structure of this
example policy. The root policy set ps1 contains two policies
p1 and p2 which are combined using first−applicable
combining algorithm. The policy p1 , which is the global

138

Figure 2.

members of a role x are also implicitly members of a role
y. In addition, RBAC introduces constraints that are a powerful mechanism for laying out higher-level organizational
policies. Separation of duty (SoD) is a well-known principle
for preventing fraud by identifying conflicting roles and has
been studied in considerable depth by RBAC community [3],
[7], [17]. SoD constraints in RBAC can be divided into Static
SoD constraints, Dynamic SoD constraints and Historical
SoD constraints. Static SoD constraints typically require that
no user should be assigned to conflicting roles. Dynamic
SoD constraints–with respect to activated roles in sessions–
typically require that no user can activate conflicting roles
simultaneously. Historical SoD constraints restrict the assignment and activation of conflicting roles over the course
of time.

Tree structure of the example XACML policy.

policy of the entire company, has two rules r1 and r2
indicating that
• all employees can read and change codes during working hours from 8:00 to 17:00 (r1 ), and
• nobody can change code during non-working hours
(r2 ).
On the other hand, each department is responsible for
deciding whether employees can read codes during nonworking hours. A local policy p2 for a development department with three rules r3 , r4 and r5 is that
• developers can read codes during non-working hours
(r3 ),
• testers cannot read codes during non-working hours
(r4 ), and
• testers and developers cannot change codes during nonworking hours (r5 ).
Note that the rule combining algorithm for policy p1 is
permit−overrides and the rule combining algorithm for
policy p2 is deny−overrides.

C. Answer Set Programming
ASP [20], [18] is a recent form of declarative programming that has emerged from the interaction between two
lines of research—nonmonotonic semantics of negation in
logic programming and applications of satisfiability solvers
to search problems. The idea of ASP is to represent the
search problem we are interested in as a logic program
whose intended models, called “stable models (a.k.a. answer
sets),” correspond to the solutions of the problem, and then
find these models using an answer set solver—a system for
computing stable models. Like other declarative computing
paradigms, such as SAT (Satisfiability Checking) and CP
(Constraint Programming), ASP provides a common basis
for formalizing and solving various problems, but is distinct
from others such that it focuses on knowledge representation
and reasoning: its language is an expressive nonmonotonic
language based on logic programs under the stable model
semantics [11], [9], which allows elegant representation of
several aspects of knowledge such as causality, defaults, and
incomplete information, and provides compact encoding of
complex problems that cannot be translated into SAT and
CP [19]. As the mathematical foundation of answer set
programming, the stable model semantics was originated
from understanding the meaning of negation as failure in
Prolog, which has the rules of the form

B. Role-based Access Control
RBAC is a widely accepted alternative to traditional
mandatory access control (MAC) and discretionary access
control (DAC) [24]. As MAC is used in the classical defense
arena, the access is based on the classification of objects
such as security clearance [23] while the main idea of DAC
is that the owner of an object has the discretion over who
can access the object [15], [22]. However, RBAC is based
on the role of the subjects and can specify security policy
in a way that maps to an organizational structure. A general
family of RBAC models called RBAC96 was proposed by
Sandhu et al. [21]. Intuitively, a user is a human being
or an autonomous agent, a role is a job function or job
title within the organization with some associated semantics
regarding the authority and responsibility conferred on the
user assigned to the role, and a permission is an approval
of a particular mode of access to one or more objects in
the system or some privileges to carry out specified actions.
Roles are organized in a partial order ≥, so that if x ≥ y
then a role x inherits the permissions of a role y. Therefore,

a1 ← a2 , . . . , am , not am+1 , . . . , not an

(1)

where all ai are atoms and not is a symbol for negation
as failure, also known as default negation. Intuitively, under
the stable model semantics, rule (1) means that if you have
generated a2 , . . . , am and it is impossible to generate any of
am+1 , . . . , an then you may generate a1 . This explanation
seems to contain a vicious cycle, but the semantics are
carefully defined in terms of fixpoint.
While it is known that the transitive closure (e.g., reachability) cannot be expressed in first-order logic, it can be
handled in the stable model semantics. Given the fixed extent
of edge relation, the extent of reachable is the transitive

139

A. Abstracting XACML Policy Components

Figure 3.

We consider a subset of XACML that covers more constructs than the ones considered in [28] and [16]. We allow
the most general form of Target, take into account Condition,
and cover all four combining algorithms.
XACML components can be abstracted as follows: Attributes are the names of elements used by a policy.
Attributes are divided into three categories: subject attributes, resource attributes and action attributes. In the
example policy above, developer, tester and employee
are subject attributes; read and change are action attributes; codes is a resource attribute. A Target is a triple
Subjects, Resources, Actions. A Condition is a conjunction
of comparisons. An Effect is either “permit,” “deny,” or
“indeterminate.”

Logic-based policy reasoning for XACML.

closure of edge.

•

reachable(X, Y ) ← edge(X, Y )
reachable(X, Y ) ← reachable(X, Z), reachable(Z, Y )

RuleID, Effect, Target, Condition
where RuleID is a rule identifier. For example, rule r1
in Figure 1 can be viewed as

Several extensions were made over the last twenty years.
The addition of cardinality constraints turns out to be useful
in knowledge representation. A cardinality constraint is
of the form lower{l1 , . . . , ln }upper where l1 , . . . , ln are
literals and lower and upper are numbers. A cardinality
constraint is satisfied if the number of satisfied literals in
l1 , . . . , ln is in between lower and upper. It is also allowed
to contain variables in cardinality constraints. For instance,

r1 , permit, employee, read ∨ change, codes,
8 ≤ time ≤ 17.
•

where PolicyID is a policy identifier, r1 , . . . , rn
are rule identifiers and Combining Algorithm is
either permit−overrides, deny−overrides, or
first−applicable. For example, policy p1 in Figure 1 is abstracted as:

means that more than one edge(X) is true if there are at
least two edges connect X with other vertices.
The language also has useful constructs, such as strong
negations, weak constraints, and preferences. What distinguishes ASP from other nonmonotonic formalisms is the
availability of several efficient implementations, answer set
solvers, such as SMODELS1 , CMODELS2 , CLASP3 , which led
to practical nonmonotonic reasoning that can be applied to
industrial level applications.

p1 , Null, permit−overrides, r1 , r2 .
•

3 http://potassco.sourceforge.net

Similarly we can abstract an XACML policy set as
PolicySetID, Target, Combining Algorithm,
p1 , . . . , pm , psm+1 , . . . , psn 
where PolicySetID is a policy set identifier,
p1 , . . . , pm are policy identifiers, psm+1 , . . . , psn
are policy set identifiers, and Combining Algorithm
is either permit−overrides, deny−overrides,
first−applicable, or only−one−applicable. For
example, policy set ps1 can be viewed as

III. G ENERAL XACML P OLICY A NALYSIS
We introduce a logic-based policy reasoning approach for
XACML as shown in Figure 3. First, XACML policies are
converted to ASP programs. Then, by means of off-the-shelf
ASP solvers, several typical policy analysis services, such
as policy verification, comparison, redundancy and querying
are utilized. For instance, policy verification is to check
if ASP-based representation of XACML policies entails
the property as certain formulas in its specification, policy
comparison checks the equivalence between two answer set
programs, and policy redundancy checking can be viewed as
an instance of simplification of ASP programs.

ps1 , Null, first−applicable, p1 , p2 .
B. Turning XACML into ASP
We provide a translation module that turns an XACML
description into a program in ASP. This interprets a formal
semantics of XACML language in terms of the Answer Set
semantics.
The translation module coverts an XACML rule

.

2 http://www.cs.utexas.edu/users/tag/cmodels.html

An XACML policy can be abstracted as
PolicyID, Target , Combining Algorithm, r1 , . . . , rn 

more than one edge(X) ← 2{edge(X, Y ) : vertex(Y )}.

1 http://www.tcs.hut.fi/Software/smodels

An XACML rule can be abstracted as

.

RuleID, Effect, Target, Condition

.

140

into a set of ASP rules

__________________________________________________________
value(permit;deny;indeterminate).
rule(r1;r2;r3;r4;r5).
policy(p1;p2).
policyset(ps1).
time(0..23).
#domain value(V;V1).
#domain rule(R;R1).
#domain policy(P).
#domain time(T).
% domain definition
subject(employee) :- subject(developer).
subject(employee) :- subject(tester).
% r1
decision(r1,permit) :- subject(employee),action(read),
resource(codes),8<=T,T<=17, current_time(T).
decision(r1,permit) :- subject(employee),action(change),
resource(codes),8<=T,T<=17, current_time(T).
% r2
decision(r2,deny) :- subject(employee),action(change),
resource(codes).
% r3
decision(r3,permit) :- subject(developer),action(read),
resource(codes).
% r4
decision(r4,deny) :- subject(tester),action(read),
resource(codes).
% r5
decision(r5,deny) :- subject(tester),action(change),
resource(codes).
decision(r5,deny) :- subject(developer),action(change),
resource(codes).
% p1
decision_from(p1,r1,V) :- decision(r1,V).
decision_from(p1,r2,V) :- decision(r2,V).
decision(p1,permit) :- decision_from(p1,R,permit).
decision(p1,deny) :- decision_from(p1,R,deny),
not decision(p1,permit).
% p2
decision_from(p2,r3,V) :- decision(r3,V).
decision_from(p2,r4,V) :- decision(r4,V).
decision_from(p2,r5,V) :- decision(r5,V).
decision(p2,deny) :- decision_from(p2,R,deny).
decision(p2,permit) :- decision_from(p2,R,permit),
not decision(p2,deny).
% ps1
decision_from(ps1,p1,V) :- decision(p1,V).
decision_from(ps1,p2,V) :- decision(p2,V).
has_decision_from(ps1,p1) :- decision_from(ps1,p1,V).
decision(ps1,V) :- decision_from(ps1,p1,V).
decision(ps1,V) :- decision_from(ps1,p2,V),
not has_decision_from(ps1,p1).
__________________________________________________________

4

decision(RuleID, Effect) ← Target ∧ Condition.

An XACML policy
PolicyID, Target, Combining Algorithm, r1 , . . . , rn 
can be also translated into a set of ASP rules. In the
following we assume that R and R are variables that range
over all rule ids, and V is a variable that ranges over
{permit, deny, indeterminate}. In order to represent the
effect of each rule ri (1 ≤ i ≤ n) on policy, we write
decision from(PolicyID, ri , V ) ← decision(ri , V ).

Each rule combining algorithms is turned into logic programming rules under the stable model semantics as follows:
• permit−overrides of policy p is represented as
decision(p, permit) ←
decision f rom(p, R, permit) ∧ T arget.
decision(p, deny) ← decision f rom(p, R, deny)
∧ not decision(p, permit) ∧ T arget.
•

deny−overrides of policy p is represented as
decision(p, deny) ←
decision f rom(p, R, deny) ∧ T arget.
decision(p, permit) ← decision f rom(p, R, permit)
∧ not decision(p, deny) ∧ T arget.

•

first−applicable of policy p is represented as

has decision f rom(p, R) ← decision f rom(p, R, V ) .
decision(p, V ) ← decision f rom(p, ri , V ) ∧
^
not has decision f rom(p, rk ) ∧ T arget.
1≤k≤i−1

The translation of a policy set is similar to the translation
of a policy except that the policy combining algorithm
only−one−applicable needs to be taken into account.
For instance, only−one−applicable of policy set ps is
represented as follows:

Figure 4.

decision(ps, V ) ← decision f rom(ps, P, V )∧
1{has decision f rom(ps, P ) : policy(P )}1.
decision(ps, indeterminate) ←
2{has decision f rom(ps, P ) : policy(P )}.

ASP representation of the example XACML policy

The problem of verifying a security property F against
an XACML description can be cast into the problem of
checking whether the program

Figure 4 shows an ASP representation of the example
XACML policy in the language of GRINGO by applying our
translation approach.

Π ∪ Πquery ∪ Πconfig
has no answer sets, where Π is the program corresponding
to the XACML specification, Πquery is the program corresponding to the program that encodes the negation of the
property to check, and Πconfig is the following program that
generates arbitrary configurations.

C. XACML Policy Analysis Using ASP
Once we represent an XACML into an ASP program Π,
we can use off-the-shelf ASP solvers for several automated
analysis services. In this section, we mainly illustrate how
policy verification can be handled by our policy analysis
approach.

subject_attributes(developer;tester;employee).
action_attributes(read;change).
resource_attributes(codes).

4 We identify Target with the conjunction of its components. Also, we
identify “ ∧ ” with “,”, “ ← ” with “ :- ” and a rule of the form A ←
B, C ∨ D as a set of the two rules A ← B, C. and A ← B, D.

1{subject(X) : subject_attributes(X)}.
1{action(X) : action_attributes(X)}.

141

decision(ps1,deny) decision(p2,deny)
decision(r3,permit) decision(r4,deny)}

1{resource(X) : resource_attributes(X)}.
1{current_time(X) : time(X)}1.

If no answer set is found, this implies that the property
is verified. Otherwise, an answer set returned by an ASP
solver serves as a counterexample that indicates why the
description does not entail F . This helps the policy designer
find out the design flaws in the policy specification.
For example, consider the example XACML policy shown
in Figure 1. We need to ensure that a developer cannot
change codes during non-working hours. The input query
Πquery can be represented as follows:
working_hours :- 8<=T, T<=17,current_time(T).
check :- decision(ps1,permit),
subject(developer),action(change),
resource(codes),not working_hours.
:- not check.

Given the corresponding ASP program of ps1 , the negation of the property, and Πconfig , GRINGO and CLASP D
return no answer set from which we conclude that the
property is held.
As another example, consider the query if a developer
is always allowed to read codes during non-working hours.
This query Πquery can be represented as
working_hours :- 8<=T, T<=17,current_time(T).
check :- decision(ps1,deny),
subject(developer), action(read),
resource(codes),not working_hours.
:- not check.

A policy designer may intend that this property would
follow based on the policy specification. However, the
following answer set is found, which indicates a design flaw
of the policy.
{subject(developer) action(read)
action(change) resource(codes)
decision(ps1,deny) decision(p1,deny)
decision(p2,deny) decision(r2,deny)
decision(r3,permit) decision(r5,deny)}

That is, a developer’s request to read the codes is denied
if his request also includes changing the codes5 . From
this answer set, the policy designer finds that p2 , which
is supposed to return permit, returns deny. It is because
r5 returns deny, and the combining algorithm of p2 is
deny−overrides.
In fact, the reason that ps1 returns deny is because p1
returns deny. Rule r1 is not applicable since its condition
is not satisfied and rule r2 returns deny. Then, the policy
designer realizes the flaw and could disallow the concurrency
of two actions within a request. However, even after adding
such a constraint, another answer set is found as follows:

That is, when someone is both developer and tester,
he cannot read codes during non-working hours since rule r4
disallows it. In this answer set, ps1 returns deny because p1
is not applicable and p2 returns deny. In turn, it is because
r4 returns deny. If we add a constraint disallowing a person
to be both developer and tester roles simultaneously, the
program returns no answer set as intended. Disallowing two
conflicting roles to be assigned to the same user is called
separation of duty (SoD) in role-based access control, which
is discussed in the subsequent section.
IV. XACML- BASED RBAC P OLICY A NALYSIS
A. A Policy Analysis Framework
As we discussed in Section I, the current XACML profile
for RBAC [4] only supports elements and relations from core
and hierarchical RBAC omitting constraints in RBAC. This
section focuses on how XACML-based RBAC policies can
be analyzed based on the approaches that we discussed in
the previous sections while considering elements, relations
and constraints in RBAC. To support the reasoning for
XACML-based RBAC policy, we introduce a policy analysis
framework shown in Figure 5. Our framework first transforms XACML-based representation of core and hierarchical
RBAC to ASP-based RBAC representation. In addition, the
policy designers can specify the RBAC constraints using
a general constraint specification scheme derived from the
NIST/ANSI RBAC standard [8], [1]. Those general constraint specifications are translated to ASP-based constraint
specifications. Therefore, representing both RBAC system
configuration (core and hierarchical RBAC) and RBAC
constraints in ASP enables us to support rigorous analysis
of constraints that are not addressed in the current XACML
profile.

Figure 5.

A policy analysis framework for XACML-based RBAC.

B. Core and Hierarchical RBAC Representation
RBAC models define sets of elements including a set of
roles, a set of users, and a set of permissions, and relationships among users, roles and permissions. In XACML profile for RBAC, Role Assignment P olicy or P olicySet
defines which roles can be enabled or assigned to whom.
Suppose that a user john is assigned to two roles tester

{subject(developer) subject(tester)
action(read) resource(codes)
5 XACML supports multi-valued requests, which contains multiple idvalue pairs in the subject, resource, or action attribute.

142

and seniorDeveloper in the software development company. We can translate those user-to-role assignments (ura)
to ASP as follows:

as user and permission in RBAC. In the real world, we may
also have notions of conflicting permissions or conflicting
users based on the organizational policy. Second, historical
SoD constraints are not addressed in RBAC standard. To
address these issues, we provide a more general constraint
specification method based on the RBAC standard.
Definition 1: (SoD Constraint). A SoD constraint is a
tuple SoD = t, e, cs, n, where
• t ∈ {s, d, h} represents the types of SoD constraints,
where s, d and h stand for static, dynamic and
historical, respectively;
• e ∈ {U, R, P } is the RBAC element to which the
constraint is applied, where U , R and P denote U ser,
Role and P ermission, respectively;
• cs is the conflicting element set including conflict role
set (cr), conflict user set (cu) and conflict permission
set (cp); and
• n is an integer, such that 2 ≤ n ≤ |cs|.
RBAC constraints defined by this general scheme can be
used to construct ASP-based constraint specifications. A detailed construction algorithm is described in Algorithm 1. In
this algorithm, three kinds of SoD constraints are supported
depending on the value of t in a constraint specification. For
static SoD constraints, if the value of e is R, the algorithm
further examines the types of conflicting element, which
is either user or permission indicating user-centric
or permission-centric constraints, respectively. Note that us
indicates a user-to-session relation in this algorithm.
Next, we illustrate three typical RBAC constraints specified in our general scheme and give equivalent ASP expressions generated by our construction algorithm.
Constraint 1: (SSoD-CR): The number of conflicting roles,
which are from the same conflicting role set and authorized
to a user, cannot exceed the cardinality of the conflicting
role set.
Suppose tester and developer belong to a static conflicting role set and the cardinality of the conflicting role set
is two. That is, these roles cannot be assigned to the same
user at the same time.
Constraint Expression:

ura(john,tester).
ura(john,seniorDeveloper).

RBAC supports role hierarchy relations. For example,
developer is a junior role of seniorDeveloper in the software development company. The hierarchy relation between
two roles developer and seniorDeveloper represented
in XACML can be converted into ASP as follows:
junior(developer, seniorDeveloper).

In addition, we assume that relation junior is reflexive.
junior(R,R) :- rules(R).

tc junior is a transitive closure of junior relation.
tc_junior(R1,R2) :- junior(R1,R2).
tc_junior(R1,R3) :- tc_junior(R1,R2),
tc_junior(R2,R3).

Furthermore, the following definition is required to specify a user-to-role assignment considering the role hierarchy
relations. It implies if a role r2 is a junior role of r1 and
r1 is assigned to a user u, r2 is also implicitly assigned to
the user u.
ura(U,R2) :- ura(U,R1), tc_junior(R2, R1)

Similarly, a session-to-role relation with respect to the role
hierarchy relations is defined as follows:
sr(S,R2) :- sr(S,R1), tc_junior(R2, R1)

C. RBAC Constraint Representation
As part of RBAC constraints, we demonstrate how SoD
constraints can be represented in ASP programs based on our
framework. Most existing definitions of SoD constraints only
consider a conflicting set as a pair of elements. For example,
a constraint may declare a pair of conflicting roles r1 and r2 ,
and require that no user is allowed to simultaneously assign
to both r1 and r2 . These definitions are too restrictive in the
size of a conflicting set and the combination of elements in
the set for which assignment operation is constrained. Thus,
a more general example of SoD constraints should require
that no user is allowed to be simultaneously assigned to n or
more roles from a conflicting role set. In NIST/ANSI RBAC
standard, SoD constraints are defined with two arguments:
(a) a conflicting role set cr that includes two or more roles;
and (b) a natural number n, called the cardinality, with the
property that 2 ≤ n ≤ |cr| means a user can be assigned
to at most n roles from conflicting role set cr. A similar
definition is used in dynamic SoD constraints with respect
to the activation of roles in sessions.
The NIST/ANSI RBAC standard has limitations in the
constraint definitions. First, the conflicting notion is only
applied to role without considering other components such

s, U , tester, developer , 2
Constructed ASP Expression:
:- 2{ura(U, tester), ura(U, developer)}.

Constraint 2: (User-based DSoD): The number of conflicting roles, which are from the same conflicting role set
and activated directly (or indirectly via inheritance) by a
user, cannot exceed the cardinality of the conflicting role
set.
Assume tester and developer are contained in a dynamic conflicting role set and the cardinality of the conflicting role set is two. It means they are dynamic conflicting
roles and cannot be activated by a user simultaneously.

143

h, U , tester, developer , 2

Algorithm 1: Construction of ASP-based Constraint
Expression
1
2
3
4
5
6

:- 2{sr(S1, tester, T1),
sr(S2, developer, T2)},
us(U, S1, T1), us(U, S2, T2).

Note that we introduce two time variables T1 and T2 to
reflect the changing system states in this constraint representation. Thus, the constraint violations for the changing
system states can be identified. For example, we can evaluate
if a user ever activated two conflicting roles at different time
intervals by checking the historical SoD constraints as a
security property against the changing system states.



C ←−: −c.n{URA}.;

7
8
9
10
11

Constructed ASP Expression:

Input: A general constraint expression C.

Output: An ASP constraint expression C .
C ←−< t, e, cs, n >;
/* Static Constraint*/
if c.t = s then
if c.e = U  then
foreach r ∈ c.cs do
URA.append(ura(U, r));
if c.e = R then
if user(c.cs) = true then
foreach u ∈ c.cs do
URA.append(ura(u, R))


C ←−: −c.n{URA}.;

12

if permission(c.cs) = true then
foreach p ∈ c.cs do
P RA.append(pra(p, R))

13
14
15

D. Violation Analysis of RBAC Constraints



C ←−: −c.n{P RA}.;

16

17 /* Dynamic Constraint*/
18 if c.t = d then
19
i ←− 0;
20
foreach r ∈ c.cs do
21
i ←− i + 1;
22
SR.append(sr(Si, r));
23
US.append(us(U, Si));
24

john
john

tester



C ←−: −c.n{SR}, US.;

developer

Conflict

Conflict

25 /* Historical Constraint*/
26 if c.t = h then
27
i ←− 0;
28
foreach r ∈ c.cs do
29
i ←− i + 1;
30
SR.append(sr(Si, r, T i));
31
US.append(us(U, Si, T i));
32

seniorDevelopter

tester

Conflicting roles cannot be directly
assigned to the same user
(a)
Direct Assignment



C ←−: −c.n{SR}, US.;

developer

Conflicting roles cannot be indirectly
assigned to the same user via
inheritance
(b)

Indirect Assignment

Inheritance relation



33 return C ;

Figure 6.

Violation checking for SoD constraints.

RBAC constraints can be utilized as security properties
to check against access control policy configurations for
identifying constraint violations. Figure 6 shows a typical
example, which illustrates conflicting roles cannot be directly or indirectly (via inheritance) assigned to the same
user. Figure 6 (a) shows that the user john is assigned to
two roles tester and developer simultaneously. However,
since tester is mutually exclusive to developer, the
SSoD-CR constraint is violated. Figure 6 (b) depicts a
more complex example taking role hierarchy into account.
The user john acquires two conflicting roles tester and
developer through the permission inheritance. The SoD
property supporting the role hierarchy can be specified with
ASP as follows:

Constraint Expression:
d , U , tester, developer , 2
Constructed ASP Expression:
:- 2{sr(S1, tester), sr(S2, developer)},
us(U, S1), us(U, S2).

Most of existing work in specifying [3], [7], [17] and
analyzing [25], [27], [12] SoD constraints mainly focus on a
system state at one point in time. By introducing a temporal
variable time in ASP representation, the changing system
state can be taken into account for both RBAC constraint
specification and analysis in ASP representation.
Constraint 3: (Historical SoD): The number of activated
roles from a conflicting role set by a user cannot exceed the
cardinality of the historical conflicting role set.
Assume that two roles tester and developer are contained in a historical conflicting role set and the cardinality
of the conflicting role set is two.
Constraint Expression:

check :- ura(U,tester), ura(U,developer).

If an answer set that is returned by an ASP solver
contains check, it means that a user is assigned to two
conflicting roles tester and developer in current RBAC
configuration. Thus an SoD constraint violation is identified.

144

V. I MPLEMENTATION AND E VALUATION
We have implemented a tool called XACML 2 ASP in Java
1.6.3. XACML 2 ASP can automatically convert core XACML
and RBAC constraint expressions into ASP. The generated
ASP-based policy representations are then fed into an ASP
reasoner to carry out analysis services. We evaluated the
efficiency and effectiveness of our approach on several realworld XACML policies. GRINGO was employed as the ASP
solver for our evaluation. Our experiments were performed
on Intel Core 2 Duo CPU 3.00 GHz with 3.25 GB RAM
running on Windows XP SP2.
In our evaluation, we utilized ten real-world XACML
policies collected from three different sources. Six of the
policies, CodeA, CodeB, CodeC, CodeD, Continue-a and
Continue-b are XACML policies used by [10]; among
them, Continue-a and Continue-b are designed for a realworld Web application supporting a conference management. Three of the policies Weirdx, FreeCS and GradeSheet
are utilized by [5]. The Pluto policy is employed in ARCHON6 system, which is a digital library that federates the
collections of physics with multiple degrees of meta data
richness.

XACML policies is expensive and still needs to examine
its feasibility for larger size of policies. In [6], the authors
formalized XACML policies using a process algebra known
as Communicating Sequential Processes. This utilizes a
model checker to formally verify properties of policies, and
to compare access control policies with each other. Fisler
et al. [10] introduced an approach to represent XACML
policies with Multi-Terminal Binary Decision Diagrams
(MTBDDs). A policy analysis tool called Margrave was
developed. Margrave can verify XACML policies against
the given properties and perform change-impact analysis
based on the semantic differences between the MTBDDs
representing the policies. Kolovski et al. [16] presented a formalization of XACML using description logic (DL), which
is a family of languages that are decidable subsets of firstorder logic, and leveraged existing DL reasoners to conduct
policy verification. Compared with other work in XACML,
our approach provides a more straightforward formalization
with ASP addressing XACML features such as all four
combining algorithms and handling simple conditions.
Schaad and Moffett [25] specified the access control
policies under the RBAC96 and ARBAC97 models and a set
of separation of duty constraints in Alloy. They attempted
to check the constraint violations caused by administrative
operations. In [26], Sohr et al. demonstrated how the USE
tool, a validation tool for OCL constraints, can be utilized
to validate authorization constraints against RBAC configurations. The policy designers can employ the USE-based
approach to detect certain conflicts between authorization
constraints and to identify missing constraints. Assurance
Management Framework (AMF) was proposed in [2], [12],
where formal RBAC model and constraints can be analyzed.
Alloy was also utilized as an underlying formal verification
tool to analyze the formal specifications of an RBAC model
and corresponding constraints, which are then used for
access control system development. In addition, the verified
specifications are used to automatically derive the test cases
for conformance testing. Even though there has been a great
amount of work on XACML and RBAC analysis, there is
little work in providing reasoning in XACML-based RBAC
policies.

Table I
E XPERIMENTAL RESULTS ON REAL - LIFE XACML POLICIES
Policy
CodeA
CodeB
CodeC
CodeD
Weirdx
FreeCS
GradeSheet
Pluto
Continue-a
Continue-b

# of Rules
2
3
4
5
6
7
14
21
298
306

Converting Time(s)
0.000
0.000
0.000
0.000
0.005
0.005
0.015
0.016
0.120
0.125

Reasoning Time(s)
0.000
0.000
0.002
0.004
0.006
0.006
0.012
0.031
0.405
0.427

Table I shows the number of rules contained in each
policy, the conversion time from XACML to ASP, and the
reasoning time using GRINGO + CLASPD for each policy.
Note that the reasoning time was measured by enabling
GRINGO + CLASPD to generate answer sets representing
all permitted requests for each policy. From Table I, we
observe that the conversion time from XACML to ASP in
XACML 2 ASP is fast enough to handle larger size of policies,
such as Continue-a and Continue-b. It also indicates that the
reasoning process for policy analysis in ASP solver is also
efficient enough for a variety of policy analysis services.

VII. C ONCLUSION AND F UTURE W ORK
In this work, we have provided a formal foundation of
XACML in terms of ASP. Also, we further introduced a
policy analysis framework for identifying constraint violations in XACML-based RBAC policies, explicitly demonstrating existing XACML standard does not support the constrained RBAC. In addition, we have described a tool called
XACML 2 ASP , which can seamlessly work with existing
ASP solvers for XACML policy analysis. Our experiments
showed that the performance of our analysis approach could
efficiently support larger access control policies.

VI. R ELATED W ORK
In [13], a framework for automated verification of access
control policies based on relational first-order logic was
proposed. The authors demonstrated how XACML policies
can be translated to the Alloy language [14], and checked
their security properties using the Alloy Analyzer. However, using the first-order constructs of Alloy to model
6 http://archon.cs.odu.edu/.

145

For our future work, the coverage of our mapping approach needs to be further extended with more XACML
features such as handling complicated conditions, obligation
and other attribute functions. Also, it is necessary to enhance
our tool to provide those features and corresponding analysis
services while obscuring the details of the ASP formalism.

[12] H. Hu and G.-J. Ahn. Enabling verification and conformance
testing for access control model. In Proceedings of the 13th
ACM Symposium on Access control Models and Technologies,
pages 195–204. ACM, 2008.
[13] G. Hughes and T. Bultan. Automated verification of access
control policies. Computer Science Department, University
of California, Santa Barbara, CA, 93106:2004–22.
[14] D. Jackson. Alloy: a lightweight object modelling notation.
ACM Transactions on Software Engineering and Methodology
(TOSEM), 11(2):256–290, 2002.
[15] S. Jajodia, P. Samarati, V. S. Subrahmanian, and E. Bertino.
A unified framework for enforcing multiple access control
policies. pages 474–485, 1997.
[16] V. Kolovski, J. Hendler, and B. Parsia. Analyzing web access
control policies. In Proceedings of the 16th international
conference on World Wide Web, page 686. ACM, 2007.
[17] N. Li, M. Tripunitara, and Z. Bizri. On mutually exclusive
roles and separation-of-duty. ACM Transactions on Information and System Security (TISSEC), 10(2):5, 2007.
[18] V. Lifschitz. What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence, pages
1594–1597. MIT Press, 2008.
[19] V. Lifschitz and A. Razborov. Why are there so many
loop formulas? ACM Transactions on Computational Logic,
7:261–268, 2006.
[20] V. Marek and M. Truszczyński. Stable models and an alternative logic programming paradigm. In The Logic Programming
Paradigm: a 25-Year Perspective, pages 375–398. Springer
Verlag, 1999.
[21] R. Sandhu, E. Coyne, H. Feinstein, and C. Youman. Rolebased access control models. IEEE computer, 29(2):38–47,
1996.
[22] R. Sandhu and Q. Munawer. How to do discretionary
access control using roles. In Proceedings of the third ACM
workshop on Role-based access control, pages 47–54. ACM
New York, NY, USA, 1998.
[23] R. S. Sandhu. Lattice-based access control models. IEEE
Computer, 26(11):9–19, 1993.
[24] R. S. Sandhu and P. Samarati. Access control: Principles
and practice. IEEE Communications Magazine, 32(9):40–48,
1994.
[25] A. Schaad and J. D. Moffett. A lightweight approach
to specification and analysis of role-based access control
extensions. In SACMAT ’02: Proceedings of the seventh ACM
symposium on Access control models and technologies, pages
13–22, New York, NY, USA, 2002. ACM.
[26] K. Sohr, G.-J. Ahn, M. Gogolla, and L. Migge. Specification
and validation of authorisation constraints using UML and
OCL. Lecture notes in computer science, 3679:64, 2005.
[27] K. Sohr, G.-J. Ahn, and L. Migge. Articulating and enforcing
authorisation policies with UML and OCL. In Proceedings
of the 2005 workshop on Software engineering for secure
systems building trustworthy applications, pages 1–7, 2005.
[28] M. C. Tschantz and S. Krishnamurthi. Towards reasonability
properties for access-control policy languages. In SACMAT
’06: Proceedings of the eleventh ACM symposium on Access
control models and technologies, pages 160–169, New York,
NY, USA, 2006. ACM.
[29] XACML. OASIS eXtensible Access Control Markup Language (XACML) V2.0 Specification Set. http://www.oasisopen.org/committees/xacml/, 2007.

ACKNOWLEDGMENT
The work of Gail-J. Ahn and Hongxin Hu was partially
supported by the grants from National Science Foundation
(NSF-IIS-0900970 and NSF-CNS-0831360). The work of
Joohyung Lee and Yunsong Meng was partially supported
by the grants from National Science Foundation (NSFIIS-0916116) and by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research
Projects Activity (IARPA), through US army. All statements
of fact, opinion or conclusions contained herein are those
of the authors and should not be construed as representing
the official views or policies of IARPA, the ODNI or the
U.S. Government.
R EFERENCES
[1] American National Standards Institute Inc. Role Based
Access Control, ANSI-INCITS 359–2004, 2004.
[2] G.-J. Ahn and H. Hu. Towards realizing a formal RBAC
model in real systems. In Proceedings of the 12th ACM
symposium on Access control models and technologies, page
224. ACM, 2007.
[3] G.-J. Ahn and R. Sandhu. Role-based authorization constraints specification. ACM Transactions on Information and
System Security (TISSEC), 3(4):207–226, 2000.
[4] A. Anderson. Core and hierarchical role based access control
(RBAC) profile of XACML v2. 0. OASIS Standard, 2005.
[5] A. Birgisson, M. Dhawan, U. Erlingsson, V. Ganapathy, and
L. Iftode. Enforcing authorization policies using transactional
memory introspection. In Proceedings of the 15th ACM
conference on Computer and communications security, pages
223–234. ACM New York, NY, USA, 2008.
[6] J. Bryans. Reasoning about XACML policies using CSP. In
Proceedings of the 2005 workshop on Secure web services,
page 35. ACM, 2005.
[7] J. Crampton. Specifying and enforcing constraints in rolebased access control. In Proceedings of the Eighth ACM symposium on Access control models and Technologies, page 50.
ACM, 2003.
[8] D. F. Ferraiolo, R. S. Sandhu, S. I. Gavrila, D. R. Kuhn,
and R. Chandramouli. Proposed NIST standard for rolebased access control. ACM Trans. Inf. Syst. Secur. (TISSEC),
4(3):224–274, 2001.
[9] P. Ferraris, J. Lee, and V. Lifschitz. Stable models and
circumscription. Artificial Intelligence, 2010. To appear.
[10] K. Fisler, S. Krishnamurthi, L. Meyerovich, and M. Tschantz.
Verification and change-impact analysis of access-control
policies. In Proceedings of the 27th international conference
on Software engineering, pages 196–205. ACM New York,
NY, USA, 2005.
[11] M. Gelfond and V. Lifschitz. The stable model semantics for
logic programming. In R. Kowalski and K. Bowen, editors,
Proceedings of International Logic Programming Conference
and Symposium, pages 1070–1080. MIT Press, 1988.

146

Journal of Artificial Intelligence Research 43 (2012) 571-620

Submitted 09/11; published 04/12

Reformulating the Situation Calculus and the Event
Calculus in the General Theory of Stable Models and in
Answer Set Programming

Joohyung Lee
Ravi Palla

joolee@asu.edu
Ravi.Palla@asu.edu

School of Computing, Informatics,
and Decision Systems Engineering
Arizona State University
Tempe, AZ 85287, USA

Abstract
Circumscription and logic programs under the stable model semantics are two wellknown nonmonotonic formalisms. The former has served as a basis of classical logic based
action formalisms, such as the situation calculus, the event calculus and temporal action
logics; the latter has served as a basis of a family of action languages, such as language A
and several of its descendants. Based on the discovery that circumscription and the stable
model semantics coincide on a class of canonical formulas, we reformulate the situation
calculus and the event calculus in the general theory of stable models. We also present a
translation that turns the reformulations further into answer set programs, so that efficient
answer set solvers can be applied to compute the situation calculus and the event calculus.

1. Introduction
Circumscription (McCarthy, 1980, 1986) and logic programs under the stable model semantics (Gelfond & Lifschitz, 1988) are two well-known nonmonotonic formalisms. As one of the
oldest nonmonotonic formalisms, circumscription has found many applications in commonsense reasoning and model-based diagnoses (e.g., McCarthy, 1986; Shanahan, 1995; Besnard
& Cordier, 1994). The stable model semantics is the mathematical basis of Answer Set Programming (ASP) (Marek & Truszczyński, 1999; Niemelä, 1999; Lifschitz, 2008), which is
being widely applied thanks to the availability of several efficient implementations, known
as answer set solvers.
While the two nonmonotonic formalisms have been applied to overlapping classes of
problems, minimal model reasoning ensured by circumscription does not coincide with stable
model reasoning. Moreover, these formalisms have different roots. While circumscription
is defined in terms of translation into classical (second-order) logic, stable models proposed
by Gelfond and Lifschitz (1988) are defined in terms of grounding and fixpoints in the
style of Reiter’s default logic (Reiter, 1980). These differences in part account for the fact
that the two formalisms have formed rather disparate traditions in knowledge representation
research. In particular, in the area of temporal reasoning, the former has served as a basis of
classical logic based action calculi, such as the situation calculus (McCarthy & Hayes, 1969;
Reiter, 2001), the event calculus (Shanahan, 1995) and temporal action logics (Doherty,
c

2012
AI Access Foundation. All rights reserved.

Lee & Palla

Gustafsson, Karlsson, & Kvarnström, 1998), whereas the latter has served as a basis of a
family of action languages, such as language A (Gelfond & Lifschitz, 1998) and several of its
descendants which can be translated into logic programs under the stable model semantics.
However, a recent generalization of the stable model semantics shed new light on the
relationship between circumscription and stable models. The first-order stable model semantics defined by Ferraris, Lee and Lifschitz (2007, 2011) characterizes the stable models
of a first-order sentence as the models (in the sense of first-order logic) of the sentence
that satisfy the “stability” condition, expressed by a second-order formula that is similar
to the one used to define circumscription. Since logic programs are viewed as a special
class of first-order sentences under the stable model semantics, this definition extends the
stable model semantics by Gelfond and Lifschitz (1988) to the full first-order level without
limiting attention to Herbrand models. Essentially the same characterization was independently given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin
& Shoham, 1992). These definitions are also equivalent to the definition of Quantified Equilibrium Logic given by Pearce and Valverde (2005), which is defined in terms of the logic of
Here-and-There (Heyting, 1930).
The new definition of a stable model motivates us to investigate the relationship between
stable model reasoning and minimal model reasoning. In particular, we focus on their
relationship in the area of temporal reasoning. We show how the situation calculus and the
event calculus can be reformulated in the first-order stable model semantics, and further in
ASP. This is not only theoretically interesting, but also practically useful as it allows us to
leverage efficient answer set solvers for computing circumscriptive action theories.
For this, we develop two technical results. First, we show that circumscription and the
first-order stable model semantics coincide on the class of canonical formulas. This is the
largest syntactic class identified so far on which the two semantics coincide, and is general
enough to cover several circumscriptive action formalisms, such as the situation calculus,
the event calculus, and temporal action logics. The result allows us to reformulate those
action formalisms in the first-order stable model semantics. While minimal model reasoning
sometimes leads to unintuitive results, those circumscriptive action formalisms are carefully
designed to avoid such cases, and our result implies that minimal model reasoning in those
action formalisms can also be viewed as stable model reasoning.
Second, we identify a class of almost universal formulas, which can be turned into the
syntax of a logic program while preserving stable models. It turns out that the reformulations of the situation calculus and the event calculus in the first-order stable model
semantics fall into this class of formulas. We introduce system f2lp that turns formulas in
this class to logic programs, and, in conjunction with the result on canonical formulas, use
the combination of f2lp and answer set solvers to compute the situation calculus and the
event calculus.
Our work makes explicit the relationship between classical logic and logic program traditions in temporal reasoning. Interestingly, the development of the event calculus has
spanned over both traditions. The original version of the event calculus (Kowalski & Sergot, 1986) was formulated in logic programs, but not under the stable model semantics (that
was the time before the invention of the stable model semantics). More extensive developments have been later carried out on the classical logic foundation via circumscription (e.g.,
Shanahan, 1995, 1997, 1999; Miller & Shanahan, 1999; Mueller, 2004), but the relation to
572

Reformulating the Situation Calculus and the Event Calculus

the logic program formulation remained implicit. Based on the reduction of circumscription to completion, SAT-based event calculus systems were implemented, one by Shanahan
and Witkowski (2004) and another by Mueller (2004). The latter system is called the dec
reasoner,1 which outperforms the former thanks to a more efficient and general compilation
method into propositional logic. While the system handles a large fragment of the event
calculus, it still cannot handle recursive and disjunctive axioms since completion cannot
be applied to such axioms. Our ASP-based approach on the other hand can handle the
full version of the event calculus under the assumption that the domain is given and finite.
Thanks to the efficiency of ASP solvers, our experiments indicate that the ASP-based event
calculus reasoner is significantly faster than the dec reasoner (Appendix B).
Similar to the logic programming tradition of the event calculus, the situation calculus (McCarthy & Hayes, 1969; Reiter, 2001) can be implemented in Prolog, based on the
fact that Clark’s completion semantics accounts for definitional axioms. But unlike the
event calculus, to the best of our knowledge, efficient propositional solvers have not been
applied to directly compute the models of situation calculus theories. In this paper, we
reformulate Lin’s causal action theories (1995) and Reiter’s basic action theories (2001) in
the first-order stable model semantics and in ASP. For basic action theories, we also provide
an ASP-based encoding method that obtains Reiter’s successor state axioms from the effect
axioms and the generic inertia axioms adopted in ASP, the idea of which is close to Reiter’s
frame default (1980).
The paper is organized as follows. The next section reviews the definitions of circumscription and the first-order stable model semantics, and presents the definition of a
canonical formula. Based on this, Sections 3 and 4 reformulate the event calculus and the
situation calculus in the first-order stable model semantics. Section 5 shows a translation
that turns almost universal formulas into logic programs that can be accepted by ASP
solvers. Sections 6 and 7 use this result to turn the reformulations of the event calculus
and the situation calculus given in Sections 3 and 4 into the input language of ASP solvers.
Complete proofs are given in Appendix C.

2. Circumscription and First-Order Stable Model Semantics
We assume the following set of primitive propositional connectives and quantifiers:
⊥ (falsity), ∧, ∨, →, ∀, ∃ .
We understand ¬F as an abbreviation of F → ⊥; symbol > stands for ⊥ → ⊥, and F ↔ G
stands for (F → G) ∧ (G → F ).
2.1 Review: Circumscription
Let p be a list of distinct predicate constants p1 , . . . , pn , and let u be a list of distinct
predicate variables u1 , . . . , un . By u ≤ p we denote the conjunction of the formulas
∀x(ui (x) → pi (x)) for all i = 1, . . . n, where x is a list of distinct object variables whose
length is the same as the arity of pi . Expression u < p stands for (u ≤ p) ∧ ¬(p ≤ u). For
1. http://decreasoner.sourceforge.net

573

Lee & Palla

instance, if p and q are unary predicate constants then (u, v) < (p, q) is


∀x(u(x) → p(x)) ∧ ∀x(v(x) → q(x)) ∧ ¬ ∀x(p(x) → u(x)) ∧ ∀x(q(x) → v(x)) .
Circumscription is defined in terms of the CIRC operator with minimized predicates.
For any first-order formula F , expression CIRC[F ; p] stands for the second-order formula
F ∧ ¬∃u((u < p) ∧ F (u)),
where F (u) is the formula obtained from F by substituting ui for pi . When F is a sentence
(i.e., a formula with no free variables), intuitively, the models of CIRC[F ; p] are the models
of F that are “minimal” on p.
The definition is straightforwardly extended to the case when F is a many-sorted firstorder formula (Lifschitz, 1994, Section 2.4), which is the language that the event calculus
and the situation calculus are based on.
2.2 Review: First-Order Stable Model Semantics
This review follows the definition by Ferraris et al. (2011). There, the stable models are
defined in terms of the SM operator, whose definition is similar to the CIRC operator in
the previous section. For any first-order formula F and any finite list of predicate constants
p = (p1 , . . . , pn ), formula SM[F ; p] is defined as
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where u is defined the same as in CIRC[F ; p], and F ∗ (u) is defined recursively as follows:
• pi (t)∗ = ui (t) for any list t of terms;
• F ∗ = F for any atomic formula F (including ⊥ and equality) that does not contain
members of p;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;
• (∃xF )∗ = ∃xF ∗ .
The predicates in p are called intensional: these are the predicates that we “intend to
characterize” by F in terms of non-intensional predicates.2 When F is a sentence, the models
of the second-order sentence SM[F ; p] are called the p-stable models of F : they are the
models of F that are “stable” on p. We will often simply write SM[F ] in place of SM[F ; p]
when p is the list of all predicate constants occurring in F . According to Lee, Lifschitz, and
2. Intensional predicates are analogous to output predicates in Datalog, and non-intensional predicates are
analogous to input predicates in Datalog (Lifschitz, 2011).

574

Reformulating the Situation Calculus and the Event Calculus

Palla (2008), answer sets are defined as a special class of stable models as follows. By σ(F )
we denote the signature consisting of the object, function and predicate constants occurring
in F . If F contains at least one object constant, an Herbrand interpretation of σ(F ) that
satisfies SM[F ] is called an answer set of F . The answer sets of a logic program Π are defined
as the answer sets of the FOL-representation of Π (i.e., the conjunction of the universal
closures of implications corresponding to the rules). For example, the FOL-representation
of the program
p(a)
q(b)
r(x) ← p(x), not q(x)
is
p(a) ∧ q(b) ∧ ∀x(p(x) ∧ ¬q(x) → r(x))

(1)

and SM[F ] is
p(a) ∧ q(b) ∧ ∀x(p(x) ∧ ¬q(x) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x((u(x) ∧ (¬v(x) ∧ ¬q(x)) → w(x)) ∧ (p(x) ∧ ¬q(x) → r(x)))),
which is equivalent to the first-order sentence
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b) ∧ ∀x(r(x) ↔ (p(x) ∧ ¬q(x)))

(2)

(Ferraris et al., 2007, Example 3). The stable models of F are any first-order models of (2).
The only answer set of F is the Herbrand model {p(a), q(b), r(a)}.
According to Ferraris et al. (2011), this definition of an answer set, when applied to the
syntax of logic programs, is equivalent to the traditional definition of an answer set that is
based on grounding and fixpoints (Gelfond & Lifschitz, 1988).
Note that the definition of a stable model is more general than the definition of an
answer set in the following ways: stable models are not restricted to Herbrand models, the
underlying signature can be arbitrary, and the intensional predicates are not fixed to the
list of predicate constants occurring in the formula. The last fact is not essential in view of
the following proposition. By pr (F ) we denote the list of all predicate constants occurring
in F ; by Choice(p) we denote the conjunction of “choice formulas” ∀x(p(x) ∨ ¬p(x)) for
all predicate constants p in p, where x is a list of distinct object variables; by False(p) we
denote the conjunction of ∀x¬p(x) for all predicate constants p in p. We sometimes identify
a list with the corresponding set when there is no confusion.
Proposition 1 Formula
SM[F ; p] ↔ SM[F ∧ Choice(pr (F )\p) ∧ False(p\pr (F ))]

(3)

is logically valid.
Notice that the (implicit) intensional predicates on the right-hand side of (3) are those
in (pr (F ) ∪ p). The Choice formula makes the predicates in (pr (F ) \ p) to be exempt
from the stability checking. On the other hand, the False formula makes the predicates in
(p \ pr (F )) to be stabilized (i.e., to have empty extents), though they do not occur in F .
575

Lee & Palla

Ferraris et al. (2011) incorporate strong negation into the stable model semantics by
distinguishing between intensional predicates of two kinds, positive and negative. Each
negative intensional predicate has the form ∼p, where p is a positive intensional predicate
and ‘∼’ is a symbol for strong negation. Syntactically ∼ is not a logical connective, as
it can appear only as a part of a predicate constant. An interpretation of the underlying
signature is coherent if it satisfies the formula
¬∃x(p(x) ∧ ∼p(x)),

(4)

where x is a list of distinct object variables, for each negative predicate ∼p. We usually
consider coherent interpretations only. Intuitively, ∼p(t) represents that p(t) is false. This
is different from ¬p(t) which represents that it is not known that p(t) is true. Similarly,
¬ ∼p(t) represents that it is not known that p(t) is false, and ¬¬p(t) represents that it is
not known that p(t) is not known to be true. Note that, unlike in first-order logic, ¬¬p(t)
is different from p(t). For instance, formula p(a) has only one answer set {p(a)} but ¬¬p(a)
has no answer sets.
Like the extension of circumscription to many-sorted first-order sentences, the definition
of a stable model is straightforwardly extended to many-sorted first-order sentences.
2.3 Equivalence of the Stable Model Semantics and Circumscription on
Canonical Formulas
Neither the stable model semantics nor circumscription is stronger than the other. For
example,
CIRC[∀x(p(x) ∨ ¬p(x)); p]
(5)
is equivalent to ∀x¬p(x), and
SM[∀x(p(x) ∨ ¬p(x)); p]

(6)

is equivalent to >, so that (5) is stronger than (6). On the other hand,
CIRC[∀x(¬p(x) → q(x)); p, q]

(7)

is equivalent to ∀x(¬p(x) ↔ q(x)), and
SM[∀x(¬p(x) → q(x)); p, q]

(8)

is equivalent to ∀x(¬p(x) ∧ q(x)), so that (8) is stronger than (7).
In this section, we show that the two semantics coincide on a class of formulas called
canonical formulas, which we define below. We first review the notions of positive, negative,
and strictly positive occurrences.
Definition 1 We say that an occurrence of a predicate constant, or any other subexpression, in a formula F is positive if the number of implications containing that occurrence in
the antecedent is even, and negative otherwise. (Recall that we treat ¬G as shorthand for
G → ⊥.) We say that the occurrence is strictly positive if the number of implications in F
containing that occurrence in the antecedent is 0.
576

Reformulating the Situation Calculus and the Event Calculus

For example, in (1), both occurrences of q are positive, but only the first one is strictly
positive.
Definition 2 We say that a formula F is canonical relative to a list p of predicate constants
if
• no occurrence of a predicate constant from p is in the antecedents of more than one
implication in F , and
• every occurrence of a predicate constant from p that is in the scope of a strictly positive
occurrence of ∃ or ∨ in F is strictly positive in F .
Example 1 The formula
∀x(¬p(x) → q(x))

(9)

that is shown above is not canonical relative to {p, q} since it does not satisfy the first clause
of the definition (p occurs in the antecedents of two implications as ¬p(x) is shorthand for
p(x) → ⊥). On the other hand, the formula is canonical relative to {q}. The formula
∀x(p(x) ∨ ¬p(x))

(10)

is not canonical relative to {p} since it does not satisfy the second clause (the second occurrence of p is in the scope of a strictly positive occurrence of ∨, but is not strictly positive in
(10)); the formula
p(a) ∧ (∃x p(x) → ∃x q(x))
(11)
is canonical relative to {p, q}, while
p(a, a) ∧ ∃x(p(x, a) → p(b, x))

(12)

is not canonical relative to {p, q} since it does not satisfy the second clause (the second
occurrence of p is in the scope of a strictly positive occurrence of ∃, but is not strictly
positive in formula (12)).
The following theorem states that, for any canonical formula, circumscription coincides
with the stable model semantics.
Theorem 1 For any canonical formula F relative to p,
CIRC[F ; p] ↔ SM[F ; p]

(13)

is logically valid.
For instance, for formula (11), which is canonical relative to {p, q}, formulas CIRC[(11); p, q]
and SM[(11); p, q] are equivalent to each other. Also, any sentence F is clearly canonical
relative to ∅, so that CIRC[F ; ∅] is equivalent to SM[F ; ∅], which in turn is equivalent to F .
On the other hand, such equivalence may not necessarily hold for non-canonical formulas.
For instance, we observed that, for formula (10) that is not canonical relative to {p}, formulas (5) and (6) are not equivalent to each other. For formula (9) that is not canonical
577

Lee & Palla

relative to {p, q}, formulas (7) and (8) are not equivalent to each other. We also observe
that formula (12) that is not canonical relative to {p, q}, CIRC[(12); p, q] is not equivalent
to SM[(12); p, q]: the Herbrand interpretation {p(a, a), p(b, a)} satisfies SM[(12); p, q], but
does not satisfy CIRC[(12); p, q].
Note that non-canonical formulas can often be equivalently rewritten as canonical formulas. Since any equivalent transformation preserves the models of circumscription, Theorem 1 can be applied to such non-canonical formulas, by first rewriting them as canonical
formulas. For example, formula (9) is equivalent to
∀x(p(x) ∨ q(x)),

(14)

which is canonical relative to {p, q}, so that CIRC[(9); p, q] is equivalent to SM[(14); p, q].
For another example, formula (10) is equivalent to
∀x(p(x) → p(x)),

(15)

which is canonical relative to {p}, so that CIRC[(10); p] is equivalent to SM[(15); p]. It
is clear that this treatment can be applied to any quantifier-free formula (including any
propositional formula) because a quantifier-free formula can be equivalently rewritten as a
canonical formula by first rewriting it into a clausal normal form and then turning each
clause into the form C → D, where C is a conjunction of atoms and D is a disjunction of
atoms.3
Sections 3 and 4 use Theorem 1 to reformulate the event calculus and the situation
calculus in the first-order stable model semantics.

3. Reformulating the Event Calculus in the General Theory of Stable
Models
In this section, we review the syntax of circumscriptive event calculus described in Chapter 2
of the book by Mueller (2006). Based on the observation that the syntax conforms to the
condition of canonicality, we present a few reformulations of the event calculus in the general
theory of stable models.
3.1 Review: Circumscriptive Event Calculus
We assume a many-sorted first-order language, which contains an event sort, a fluent sort,
and a timepoint sort. A fluent term is a term whose sort is a fluent; an event term and a
timepoint term are defined similarly.
Definition 3 A condition is defined recursively as follows:
• If τ1 and τ2 are terms, then comparisons τ1 < τ2 , τ1 ≤ τ2 , τ1 ≥ τ2 , τ1 > τ2 , τ1 = τ2 ,
τ1 6= τ2 are conditions;
3. It appears unlikely that knowledge has to be encoded in a non-canonical formula such as (12) that
cannot be easily turned into an equivalent canonical formula. c.f. “Guide to Axiomatizing Domains
in First-Order Logic” (http://cs.nyu.edu/faculty/davise/guide.html). It is not a surprise that all
circumscriptive action theories mentioned in this paper satisfy the canonicality assumption.

578

Reformulating the Situation Calculus and the Event Calculus

• If f is a fluent term and t is a timepoint term, then HoldsAt(f, t) and ¬HoldsAt(f, t)
are conditions;
• If γ1 and γ2 are conditions, then γ1 ∧ γ2 and γ1 ∨ γ2 are conditions;
• If v is a variable and γ is a condition, then ∃vγ is a condition.
We will use e and ei to denote event terms, f and fi to denote fluent terms, t and ti to
denote timepoint terms, and γ and γi to denote conditions.
In the event calculus, we circumscribe Initiates, Terminates, and Releases to minimize
unexpected effects of events, circumscribe Happens to minimize unexpected events, and
circumscribe Ab i (abnormality predicates) to minimize abnormalities. Formally, an event
calculus description is a circumscriptive theory defined as
CIRC[Σ ; Initiates, Terminates, Releases] ∧ CIRC[∆ ; Happens]
∧ CIRC[Θ ; Ab 1 , . . . , Ab n ] ∧ Ξ,

(16)

where
• Σ is a conjunction of universal closures of axioms of the form
γ → Initiates(e, f, t)
γ → Terminates(e, f, t)
γ → Releases(e, f, t)
γ ∧ π1 (e, f1 , t) → π2 (e, f2 , t)
(“effect constraint”)
γ ∧ [¬]Happens(e1 , t) ∧ · · · ∧ [¬]Happens(en , t) → Initiates(e, f, t)
γ ∧ [¬]Happens(e1 , t) ∧ · · · ∧ [¬]Happens(en , t) → Terminates(e, f, t),
where each of π1 and π2 is either Initiates or Terminates (‘[¬]’ means that ‘¬’ is
optional);
• ∆ is a conjunction of universal closures of temporal ordering formulas (comparisons
between timepoint terms) and axioms of the form
γ → Happens(e, t)
σ(f, t) ∧ π1 (f1 , t) ∧ · · · ∧ πn (fn , t) → Happens(e, t)
(“causal constraints”)
Happens(e, t) → Happens(e1 , t) ∨ · · · ∨ Happens(en , t) (“disjunctive event axiom”),
where σ is Started or Stopped and each πj (1 ≤ j ≤ n) is either Initiated or
Terminated ;
• Θ is a conjunction of universal closures of cancellation axioms of the form
γ → Abi (..., t) ;
• Ξ is a conjunction of first-order sentences (outside the scope of CIRC) including unique
name axioms, state constraints, event occurrence constraints, and the set of domainindependent axioms in the event calculus, such as EC (for the continuous event calculus) and DEC (for the discrete event calculus) (Mueller, 2006, Chapter 2). It also
579

Lee & Palla

includes the following definitions of the predicates used in the causal constraints in ∆:
def

Started (f, t) ↔ (HoldsAt(f, t) ∨ ∃e(Happens(e, t) ∧ Initiates(e, f, t)))

(CC1 )

def

Stopped (f, t) ↔ (¬HoldsAt(f, t) ∨ ∃e(Happens(e, t) ∧ Terminates(e, f, t)))
def

Initiated (f, t) ↔ (Started (f, t) ∧ ¬∃e(Happens(e, t) ∧ Terminates(e, f, t)))
def

Terminated (f, t) ↔ (Stopped (f, t) ∧ ¬∃e(Happens(e, t) ∧ Initiates(e, f, t)))

(CC2 )
(CC3 )
(CC4 ).

Remark 1 The following facts are easy to check:
• Σ is canonical relative to {Initiates, Terminates, Releases};
• ∆ is canonical relative to {Happens};
• Θ is canonical relative to {Ab 1 , . . . , Ab n }.
These facts are used in the next section to reformulate the event calculus in the general
theory of stable models.
3.2 Reformulating the Event Calculus in the General Theory of Stable Models
Following Ferraris, Lee, Lifschitz, and Palla (2009), about a formula F we say that it
is negative on a list p of predicate constants if members of p have no strictly positive
occurrences in F .4 For example, formula (9) is negative on {p}, but is not negative on {p, q}.
A formula of the form ¬F (shorthand for F → ⊥) is negative on any list of predicates.
We assume that Ξ was already equivalently rewritten so that Ξ is negative on {Initiates,
Terminates, Releases, Happens, Ab 1 , . . . , Ab n }. This can be easily done by prepending ¬¬
to strictly positive occurrences of those predicates. The following theorem shows a few
equivalent reformulations of circumscriptive event calculus in the general theory of stable
models.
Theorem 2 For any event calculus description (16), the following theories are equivalent
to each other:5
(a) CIRC[Σ; I, T, R] ∧ CIRC[∆; H] ∧ CIRC[Θ; Ab 1 , . . . , Ab n ] ∧ Ξ ;
(b) SM[Σ; I, T, R] ∧ SM[∆; H] ∧ SM[Θ; Ab 1 , . . . , Ab n ] ∧ Ξ ;
(c) SM[Σ ∧ ∆ ∧ Θ ∧ Ξ; I, T, R, H, Ab 1 , . . . , Ab n ] ;
(d) SM[Σ ∧ ∆ ∧ Θ ∧ Ξ ∧ Choice(pr (Σ ∧ ∆ ∧ Θ ∧ Ξ) \ {I, T, R, H, Ab 1 , . . . , Ab n })] .
The equivalence between (a) and (b) is immediate from Theorem 1. The equivalence
between (b) and (c) can be shown using the splitting theorem by Ferraris et al. (2009).
The assumption that Ξ is negative on the intensional predicates is essential in showing that
4. Note that we distinguish between a formula being negative (on p) and an occurrence being negative
(Section 2.3).
5. For brevity, we abbreviate the names of circumscribed predicates.

580

Reformulating the Situation Calculus and the Event Calculus

equivalence (For more details, see the proof in Appendix C.4.). The equivalence between
(c) and (d) follows from Proposition 1 since
{I, T, R, H, Ab 1 , . . . , Ab n } \ pr (Σ ∧ ∆ ∧ Θ ∧ Ξ)
is the empty set.6

4. Reformulating the Situation Calculus in the General Theory of Stable
Models
In this section, we review and reformulate two versions of the situation calculus—Lin’s
causal action theories (1995) and Reiter’s basic action theories (2001).
4.1 Review: Lin’s Causal Action Theories
We assume a many-sorted first-order language which contains a situation sort, an action
sort, a fluent sort, a truth value sort and an object sort. We understand expression P (x, s),
where P is a fluent name, as shorthand for Holds(P (x), s). We do not consider functional
fluents here for simplicity.
According to Lin (1995), a formula φ(s) is called a simple state formula about s if φ(s)
does not mention Poss, Caused or any situation term other than possibly the variable s.
We assume that a causal action theory D consists of a finite number of the following
sets of axioms. We often identify D with the conjunction of the universal closures of all
axioms in D. In the following, F , Fi are fluent names, A is an action name, V , Vi are truth
values, s, s0 are situation variables, φ(s) is a simple state formula about s, symbols a, a0
are action variables, f is a variable of sort fluent, v is a variable of sort truth value, and x,
xi , y, yi are lists of variables.
• Dcaused is a conjunction of axioms of the form
Poss(A(x), s) → (φ(s) → Caused (F (y), V, do(A(x), s))
(direct effect axioms), and
φ(s) ∧ Caused (F1 (x1 ), V1 , s) ∧ · · · ∧ Caused (Fn (xn ), Vn , s) → Caused (F (x), V, s)
(indirect effect axioms).
• Dposs is a conjunction of precondition axioms of the form
Poss(A(x), s) ↔ φ(s).

(17)

• Drest is a conjunction of the following axioms:
– The basic axioms:
Caused (f, true, s) → Holds(f, s),
Caused (f, false, s) → ¬Holds(f, s),
true 6= false ∧ ∀v(v = true ∨ v = false).
6. I, T , R, H occur in the domain independent axioms as part of Ξ.

581

(18)

Lee & Palla

– The unique name assumptions for fluent names:
Fi (x) 6= Fj (y), (i 6= j)
Fi (x) = Fi (y) → x = y.

(19)

Similarly for action names.
– The foundational axioms for the discrete situation calculus:

7

s 6= do(a, s),
0

0

0

0

do(a, s) = do(a , s ) → (a = a ∧ s = s ),



∀p p(S0 ) ∧ ∀a, s p(s) → p(do(a, s)) → ∀s p(s) .

(20)
(21)
(22)

– The frame axiom:
Poss(a, s) → (¬∃vCaused (f, v, do(a, s))
→ (Holds(f, do(a, s)) ↔ Holds(f, s))).
– Axioms for other domain knowledge: φ(s).
A causal action theory is defined as
CIRC[Dcaused ; Caused ] ∧ Dposs ∧ Drest .

(23)

Remark 2 It is easy to check that Dcaused is canonical relative to Caused .
This fact is used in the next section to reformulate causal action theories in the general
theory of stable models.
4.2 Reformulating Causal Action Theories in the General Theory of Stable
Models
Let Dposs → be the conjunction of axioms φ(s) → Poss(A(x), s) for each axiom (17) in Dposs .
Instead of the second-order axiom (22), we consider the following first-order formula Dsit ,
which introduces a new intensional predicate constant Sit whose argument sort is situation.8
Sit(S0 ) ∧ ∀a, s(Sit(s) → Sit(do(a, s))) ∧ ¬∃s¬Sit(s).

(24)

−
In the following, Drest
is the theory obtained from Drest by dropping (22).

Theorem 3 Given a causal action theory (23), the following theories are equivalent to each
other when we disregard the auxiliary predicate Sit:
(a) CIRC[Dcaused ; Caused ] ∧ Dposs ∧ Drest ;
−
(b) SM[Dcaused ; Caused ] ∧ Dposs ∧ Drest
∧ SM[Dsit ; Sit] ;
−
(c) SM[Dcaused ; Caused ] ∧ SM[Dposs → ; Poss] ∧ Drest
∧ SM[Dsit ; Sit] ;
−
(d) SM[Dcaused ∧ Dposs → ∧ Drest
∧ Dsit ; Caused , Poss, Sit] .

7. For simplicity we omit two other axioms regarding the partial-order among situations.
8. Suggested by Vladimir Lifschitz (personal communication).

582

Reformulating the Situation Calculus and the Event Calculus

4.3 Review: Reiter’s Basic Action Theories
As in causal action theories, we understand P (x, s), where P is a fluent name, as shorthand
for Holds(P (x), s), and do not consider functional fluents.
A basic action theory (BAT) is of the form
Σ ∪ Dss ∪ Dap ∪ Duna ∪ DS0 ,

(25)

where
• Σ is the conjunction of the foundational axioms (Section 4.1);
• Dss is a conjunction of successor state axioms of the form
F (x, do(a, s)) ↔ ΦF (x, a, s),
where ΦF (x, a, s) is a formula that is uniform in s
among x, a, s;

9

and whose free variables are

• Dap is a conjunction of action precondition axioms of the form
Poss(A(x), s) ↔ ΠA (x, s),
where ΠA (x, s) is a formula that is uniform in s and whose free variables are among x, s;
• Duna is the conjunction of unique name axioms for fluents and actions;
• DS0 is a conjunction of first-order formulas that are uniform in S0 .
4.4 Reformulating Basic Action Theories in the General Theory of Stable
Models
Note that a BAT is a theory in first-order logic.10 In view of the fact that any first-order
logic sentence F is equivalent to SM[F ; ∅], it is trivial to view a BAT as a first-order theory
under the stable model semantics with the list of intensional predicates being empty.
In the rest of this section, we consider an alternative encoding of BAT in ASP, in which
we do not need to provide explicit successor state axioms Dss . Instead, the successor state
axioms are entailed by the effect axioms and the generic inertia axioms adopted in ASP by
making intensional both the positive predicate Holds and the negative predicate ∼Holds
(Recall the definitions of positive and negative predicates in Section 2.2). In the following
we assume that the underlying signature contains both these predicates.
An ASP-style BAT is of the form
Σ ∪ Deffect ∪ Dprecond ∪ Dinertia ∪ Dexogenous0 ∪ Duna ∪ DS0 ,
where
• Σ, Duna and DS0 are defined as before;
9. We refer the reader to the book by Reiter (2001) for the definition of a uniform formula.
10. For simplicity we disregard the second-order axiom (22).

583

(26)

Lee & Palla

• Deffect is a conjunction of axioms of the form
+
γR
(x, a, s) → Holds(R(x), do(a, s))

(27)

−
γR
(x, a, s) → ∼Holds(R(x), do(a, s)),

(28)

or
+
γR
(x, a, s)

−
γR
(x, a, s)

where
and
variables are among x, a and s;

are formulas that are uniform in s and whose free

• Dprecond is a conjunction of axioms of the form
πA (x, s) → Poss(A(x), s),

(29)

where πA (x, s) is a formula that is uniform in s and whose free variables are among x, s;
• Dinertia is the conjunction of the axioms
Holds(R(x), s) ∧ ¬ ∼Holds(R(x), do(a, s)) → Holds(R(x), do(a, s)),
∼Holds(R(x), s) ∧ ¬Holds(R(x), do(a, s)) → ∼Holds(R(x), do(a, s))
for all fluent names R;
• Dexogenous0 is the conjunction of
Holds(R(x), S0 )∨ ∼Holds(R(x), S0 )
for all fluent names R.
Note that axioms in Dinertia are typically used in answer set programming to represent
the common sense law of inertia (Lifschitz & Turner, 1999). Similarly, Dexogenous0 is used
to represent that the initial value of a fluent is arbitrary.11
We will show how this ASP-style BAT is related to Reiter’s BAT. First, since we use
strong negation, it is convenient to define the following notions. Given the signature σ of
a BAT, σ Holds is the signature obtained from σ by adding ∼Holds to σ. We say that an
interpretation I of σ Holds is complete on Holds if it satisfies
∀y(Holds(y)∨ ∼Holds(y)),
where y is a list of distinct variables. Given an interpretation I of σ Holds , expression I|σ
denotes the projection of I on σ.
Let Dss be the conjunction of successor state axioms
−
Holds(R(x), do(a, s)) ↔ Γ+
R (x, a, s) ∨ (Holds(R(x), s) ∧ ¬ΓR (x, a, s)),
+
−
where Γ+
R (x, a, s) is the disjunction of γR (x, a, s) for all axioms (27) in Deffect , and ΓR (x, a, s)
−
is the disjunction of γR (x, a, s) for all axioms (28) in Deffect . By Dap we denote the conjunction of axioms Poss(A(x), s) ↔ ΠA (x, s), where ΠA (x, s) is the disjunction of πA (x, s)
for all axioms (29) in Dprecond .

11. The axioms Dinertia and Dexogenous0 are also closely related to the translation of C+ into nonmonotonic
causal logic (Giunchiglia, Lee, Lifschitz, McCain, & Turner, 2004).

584

Reformulating the Situation Calculus and the Event Calculus

Theorem 4 Let T be a theory (26) of signature σ Holds , and I a coherent interpretation of
σ Holds that is complete on Holds. If I satisfies
−
¬∃x a s(Γ+
R (x, a, s) ∧ ΓR (x, a, s))

for every fluent name R, then I satisfies
SM[T ; Poss, Holds, ∼Holds]
iff I|σ satisfies the BAT
Σ ∧ Dss ∧ Dap ∧ Duna ∧ DS0 .

5. Translating Almost Universal Sentences into Logic Programs
Theorems 2—4 present reformulations of the situation calculus and the event calculus in the
general theory of stable models, which may contain nested quantifiers and connectives. On
the other hand, the input languages of ASP solvers are limited to simple rule forms, which
are analogous to clausal normal form in classical logic. Although any first-order formula can
be rewritten in clausal normal form while preserving satisfiability, such transformations do
not necessarily preserve stable models. This is due to the fact that the notion of equivalence
is “stronger” under the stable model semantics (Lifschitz, Pearce, & Valverde, 2001).
Definition 4 (Ferraris et al., 2011) A formula F is strongly equivalent to formula G if,
for any formula H containing F as a subformula (and possibly containing object, function
and predicate constants that do not occur in F , G), and for any list p of distinct predicate
constants, SM[H; p] is equivalent to SM[H 0 ; p], where H 0 is obtained from H by replacing
an occurrence of F by G.
In other words, replacing a subformula with another strongly equivalent subformula
does not change the stable models of the whole formula. While strongly equivalent theories
are classically equivalent (i.e., equivalent under classical logic), the converse does not hold.
Consequently, classically equivalent transformations do not necessarily preserve stable models. For instance, consider p and ¬¬p. When p is intensional, the former has stable models
and the latter does not.
It is known that every propositional formula can be rewritten as a logic program (Cabalar
& Ferraris, 2007; Cabalar, Pearce, & Valverde, 2005; Lee & Palla, 2007), and such translations can be extended to quantifier-free formulas in a straightforward way (Section 5.1).
However, the method does not work in the presence of arbitrary quantifiers, because in the
target formalism (logic programs), all variables are implicitly universally quantified.
In this section, we present a translation that turns a certain class of sentences called
“almost universal” sentences into logic programs while preserving stable models. It turns
out that the reformulations of the situation calculus and the event calculus in Sections 3
and 4 belong to the class of almost universal sentences, so that we can use ASP solvers for
computing them.
585

Lee & Palla

5.1 Translating Quantifier-Free Formulas into Logic Programs
Cabalar et al. (2005) define the following transformation that turns any propositional formula under the stable model semantics into a logic program.
• Left side rules:
>∧F →G

7→

{F → G}

(L1)

⊥∧F →G

7→

∅

(L2)

¬¬F ∧ G → H

7→

(L3)

(F ∨ G) ∧ H → K

7→

(F → G) ∧ H → K

7→

{G → ¬F ∨ H}


F ∧H →K
G∧H →K



 ¬F ∧ H → K
G∧H →K


H → F ∨ ¬G ∨ K

F →⊥∨G

7→

{F → G}

(R1)

F →>∨G

7→

∅

(R2)

F → ¬¬G ∨ H

7→

(R3)

F → (G ∧ H) ∨ K

7→

F → (G → H) ∨ K

7→

{¬G ∧ F → H}


F →G∨K
F →H ∨K


G∧F →H ∨K
¬H ∧ F → ¬G ∨ K

(L4)

(L5)

• Right side rules:

(R4)
(R5)

Before applying this transformation to each formula on the lefthand side, we assume
that the formula is already written in negation normal form, in which negation is applied
to literals only, by using the following transformation:
• Negation normal form conversion:
¬>
¬⊥
¬¬¬F
¬(F ∧ G)
¬(F ∨ G)
¬(F → G)

7→
7
→
7
→
7
→
7
→
7
→

⊥
>
¬F
¬F ∨ ¬G
¬F ∧ ¬G
¬¬F ∧ ¬G

According to Cabalar et al. (2005), successive application of the rewriting rules above
turn any propositional formula into a disjunctive logic program. This result can be simply
extended to turn any quantifier-free formula into a logic program.
As noted by Cabalar et al. (2005), this translation may involve an exponential blowup in
size, and Theorem 1 from their paper shows that indeed there is no vocabulary-preserving
polynomial time algorithm to convert general propositional theories under the stable model
semantics into disjunctive logic programs. Alternatively, one can use another translation
from the same paper, which is linear in size but involves auxiliary atoms and is more
complex.
586

Reformulating the Situation Calculus and the Event Calculus

5.2 Quantifier Elimination
We introduce a quantifier elimination method that distinguishes between two kinds of occurrences of quantifiers: “singular” and “non-singular.” Any “non-singular” occurrence of
a quantifier is easy to eliminate, while a “singular” occurrence is eliminated under a certain
syntactic condition.
Definition 5 We say that an occurrence of QxG in F is singular if
• Q is ∃, and the occurrence of QxG is positive in F , or
• Q is ∀, and the occurrence of QxG is negative in F .
For example, the occurrence of ∃x q(x) is singular in (11), but the occurrence of ∃x p(x) is
not.
Non-singular occurrences of quantifiers can be eliminated in view of the fact that every
first-order sentence can be rewritten in prenex form. The prenex form conversion rules given
in Section 6.3.1 of Pearce and Valverde (2005) preserve strong equivalence, which leads to
the following theorem.12
Theorem 5 (Lee & Palla, 2007, Proposition 5) Every first-order formula is strongly
equivalent to a formula in prenex form.
The prenex form conversion turns a non-singular occurrence of a quantifier into an
outermost ∀ while preserving strong equivalence. Consequently, if a sentence contains no
singular occurrence of a quantifier, then the above results can be used to turn the sentence
into a universal sentence and then into a set of ASP rules. However, in the presence of a
singular occurrence of a quantifier, the prenex form conversion turns the occurrence into
an outermost ∃, which is not allowed in logic programs. Below we consider how to handle
such occurrences.
Obviously, if the Herbrand universe is finite, and if we are interested in Herbrand stable
models (i.e., answer sets) only, quantified formulas can be rewritten as multiple disjunctions
and conjunctions. We do not even need to consider turning the formula into prenex form.
For example, for a formula
r ∧ ¬∃x(p(x) ∧ q(x)) → s

(30)

occurring in a theory whose signature contains {1, . . . , n} as the only object constants (and
no other function constants), if we replace ∃x(p(x) ∧ q(x)) with multiple disjunctions and
then turn the resulting program with nested expressions into a usual disjunctive program
(Lifschitz, Tang, & Turner, 1999), 2n rules are generated. For instance, if n = 3, the
12. Pearce and Valverde (2005) show that a sentence in QNc5 , the monotonic basis of Quantified Equilibrium
Logic, can be turned into prenex form, from which the result follows.

587

Lee & Palla

resulting logic program is
s ← r, not
s ← r, not
s ← r, not
s ← r, not
s ← r, not
s ← r, not
s ← r, not
s ← r, not

p(1), not
p(1), not
p(1), not
p(1), not
q(1), not
q(1), not
q(1), not
q(1), not

p(2), not
p(2), not
q(2), not
q(2), not
p(2), not
p(2), not
q(2), not
q(2), not

p(3)
q(3)
p(3)
q(3)
p(3)
q(3)
p(3)
q(3).

Also, the translation is not modular as it depends on the underlying domain; the multiple
disjunctions or conjunctions need to be updated when the domain changes. More importantly, this method is not applicable if the theory contains function constants of positive
arity, as its Herbrand universe is infinite.
One may also consider introducing Skolem constants as in first-order logic, presuming
that, for any sentence F and its “Skolem form” F 0 , SM[F ; p] is satisfiable iff SM[F 0 ; p] is
satisfiable. However, this idea does not work.13
Example 2 For formula
F = (∀x p(x) → q) ∧ ¬¬∃x(q ∧ ¬p(x)),
SM[F ; q] is equivalent to the first-order sentence
(q ↔ ∀x p(x)) ∧ ∃x(q ∧ ¬p(x)),
which is unsatisfiable (the equivalence can be established using Theorems 3 and 11 from Ferraris et al., 2011). Formula F is strongly equivalent to its prenex form

∃x∃y (p(x) → q) ∧ ¬¬(q ∧ ¬p(y)) ,

(31)

However, if we introduce new object constants a and b to replace the existentially quantified
variables as in
F 0 = (p(a) → q) ∧ ¬¬(q ∧ ¬p(b)),
formula SM[F 0 ; q] is equivalent to
(q ↔ p(a)) ∧ (q ∧ ¬p(b)),
which is satisfiable.
Here we present a method of eliminating singular occurrences of quantifiers by introducing auxiliary predicates. Our idea is a generalization of the practice in logic programming
13. Pearce and Valverde (2005) show that Skolemization works with QNc5 , the monotonic basis of Quantified Equilibrium Logic, but as our example shows, this does not imply that Skolemization works with
Quantified Equilibrium Logic.

588

Reformulating the Situation Calculus and the Event Calculus

that simulates negated existential quantification in the body of a rule by introducing auxiliary predicates. For instance, in order to eliminate ∃ in (30), we will introduce a new
predicate constant p0 , and turn (30) into
(r ∧ ¬p0 → s) ∧ ∀x(p(x) ∧ q(x) → p0 ),

(32)

which corresponds to the logic program
s ← r, not p0
p0 ← p(x), q(x).

(33)

The models of SM[(30); p, q, r, s] are the same as the stable models of (33) if we disregard
p0 . This method does not involve grounding, so that the translation does not depend on
the domain and is not restricted to Herbrand models. The method is formally justified by
the following proposition.
Recall that a formula H is negative on p if members of p have no strictly positive
occurrences in H. Given a formula F , we say that an occurrence of a subformula G is
p-negated in F if it is contained in a subformula H of F that is negative on p.
Proposition 2 Let F be a sentence, let p be a finite list of distinct predicate constants,
and let q be a new predicate constant that does not occur in F . Consider any non-strictly
positive, p-negated occurrence of ∃yG(y, x) in F , where x is the list of all free variables of
∃yG(y, x). Let F 0 be the formula obtained from F by replacing that occurrence of ∃yG(y, x)
with q(x). Then
SM[F ; p] ∧ ∀x(q(x) ↔ ∃yG(y, x))
is equivalent to
SM[F 0 ∧ ∀xy(G(y, x) → q(x)); p, q].
Proposition 2 tells us that SM[F ; p] and SM[F 0 ∧ ∀xy(G(y, x) → q(x); p, q] have the
same models if we disregard the new predicate constant q. Notice that F 0 does not retain
the occurrence of ∃y.
Example 3 In formula (30), ∃x(p(x) ∧ q(x)) is contained in a negative formula (relative
to any set of intensional predicates). In accordance with Proposition 2, SM[(30); p, q, r, s]
has the same models as SM[(32); p, q, r, s, p0 ] if we disregard p0 .
Any singular, p-negated occurrence of a subformula ∀yG(y, x) can also be eliminated
using Proposition 2 by first rewriting ∀yG(y, x) as ¬∃y¬G(y, x). Note that ∀yG(y, x) is
not strongly equivalent to ¬∃y¬G(y, x), and in general such a classically equivalent transformation may not necessarily preserve stable models. However, the Theorem on Double
Negations (Ferraris et al., 2009, also reviewed in Appendix C) tells us that such a transformation is ensured to preserve p-stable models if the replaced occurrence is p-negated in
the given formula.
Now we are ready to present our quantifier elimination method, which applies to the
class of almost universal formulas.
589

Lee & Palla

Definition 6 We say that a formula F is almost universal relative to p if every singular
occurrence of QxG in F is p-negated in F .
For example, formula (30) is almost universal relative to any set of predicates because the
only singular occurrence of ∃x(p(x) ∧ q(x)) in (30) is contained in ¬∃x(p(x) ∧ q(x)), which
is negative on any list of predicates. Formula F in Example 2 is almost universal relative
to {q} because the singular occurrence of ∀x p(x) is contained in the formula itself, which is
negative on {q}, and the singular occurrence of ∃x(q ∧¬p(x)) is contained in ¬∃x(q ∧¬p(x)),
which is also negative on {q}.
The following procedure can be used to eliminate all (possibly nested) quantifiers in any
almost universal sentence.
Definition 7 (Translation elim-quantifiers) Given a formula F , first prepend ¬¬ to
every maximal strictly positive occurrence of a formula of the form ∃yH(y, x),14 and then
repeat the following process until there are no occurrences of quantifiers remaining: Select
a maximal occurrence of a formula of the form QyG(y, x) in F , where Q is ∀ or ∃, and x
is the list of all free variables in QyG(y, x).
(a) If the occurrence of QyG(y, x) in F is non-singular in F , then set F to be the formula
obtained from F by replacing the occurrence of QyG(y, x) with G(z, x), where z is a
new variable.
(b) Otherwise, if Q is ∃ and the occurrence of QyG(y, x) in F is positive, then set F to
be
F 0 ∧ (G(y, x) → pG (x)),
where pG is a new predicate constant and F 0 is the formula obtained from F by replacing the occurrence of QyG(y, x) with pG (x).
(c) Otherwise, if Q is ∀ and the occurrence of QyG(y, x) in F is negative, then set F
to be the formula obtained from F by replacing the occurrence of QyG(y, x) with
¬∃y¬G(y, x).
We assume that the new predicate constants introduced by the translation do not belong
to the signature of the input formula F . It is clear that this process terminates, and yields
a formula that is quantifier-free. Since the number of times step (b) is applied is no more
than the number of quantifiers in the input formula, and the new formulas added have the
size polynomial to the input formula, it follows that the size of the resulting quantifier-free
formula is polynomial in the size of the input formula.
The following theorem tells us that any almost universal sentence F can be turned into
the form ∀xG, where G is a quantifier-free formula. For any (second-order) sentences F
and G of some signature and any subset σ of that signature, we say that F is σ-equivalent
to G, denoted by F ⇔σ G, if the class of models of F restricted to σ is identical to the class
of models of G restricted to σ.
14. The maximality is understood here in terms of subformula relation. That is, we select a strictly positive
occurrence of a subformula of F of the form ∃yH(y, x) that is not contained in any other subformula of
F of the same form.

590

Reformulating the Situation Calculus and the Event Calculus

Theorem 6 Let F be a sentence of a signature σ, let F 0 be the universal closure of the
formula obtained from F by applying translation elim-quantifiers, and let q be the list
of new predicate constants introduced by the translation. If F is almost universal relative
to p, then SM[F ; p] is σ-equivalent to SM[F 0 ; p, q].
The statement of the theorem becomes incorrect if we do not require F to be almost
universal relative to p. For instance, if elim-quantifiers is applied to ∃x p(x), it results
in ¬¬q ∧ (p(x) → q). However, SM[∃x p(x); p] is not {p}-equivalent to
SM[∀x(¬¬q ∧ (p(x) → q)); p, q]. The former is equivalent to saying that p is a singleton.
The latter is equivalent to q ∧ ∀x¬p(x) ∧ (q ↔ ∃xp(x)), which is inconsistent.
5.3 f2lp: Computing Answer Sets of First-Order Formulas
Using translation elim-quantifiers defined in the previous section, we introduce translation f2lp that turns an almost universal formula into a logic program. We assume that the
underlying signature contains finitely many predicate constants.
Definition 8 (Translation f2lp)
1. Given a formula F and a list of intensional predicates p, apply translation elim-quantifiers (Definition 7) to F ;
2. Add choice formulas (q(x) ∨ ¬q(x)) for all non-intensional predicates q.
3. Turn the resulting quantifier-free formula into a logic program by applying the translation from Section 3 of the paper by Cabalar et al. (2005), which was also reviewed
in Section 5.1.
As explained in Section 5.1, due to the third step, this transformation may involve an
exponential blowup in size. One can obtain a polynomial translation by replacing Step 3
with an alternative translation given in Section 4 of the paper by Cabalar et al.
The following theorem asserts the correctness of the translation.
Theorem 7 Let F be a sentence of a signature σ, let p be a list of intensional predicates,
and let F 0 be the FOL representation of the program obtained from F by applying translation
f2lp with p as intensional predicates. If F is almost universal relative to p, then SM[F ; p]
is σ-equivalent to
SM[F 0 ∧ False(p \ pr (F 0 ))].
Example 4 Consider one of the domain independent axioms in the discrete event calculus
(DEC5 axiom):
HoldsAt(f, t) ∧ ¬ReleasedAt(f, t+1)∧
¬∃e(Happens(e, t) ∧ Terminates(e, f, t)) → HoldsAt(f, t+1).
Step 1 of translation f2lp introduces the formula
Happens(e, t) ∧ Terminates(e, f, t) → q(f, t),
and replaces (34) with
HoldsAt(f, t) ∧ ¬ReleasedAt(f, t+1) ∧ ¬q(f, t) → HoldsAt(f, t+1).
591

(34)

Lee & Palla

Step 3 turns these formulas into rules
q(f, t) ← Happens(e, t), Terminates(e, f, t)
HoldsAt(f, t+1) ← HoldsAt(f, t), not ReleasedAt(f, t+1), not q(f, t).
Turning the program obtained by applying translation f2lp into the input languages of
lparse 15 and gringo 16 requires minor rewriting, such as moving equality and negated
atoms in the head to the body 17 and adding domain predicates in the body for all variables
occurring in the rule in order to reduce the many-sorted signature into the non-sorted one.18
System f2lp is an implementation of translation f2lp, which turns a first-order formula
into the languages of lparse and gringo. The system can be downloaded from its home
page
http://reasoning.eas.asu.edu/f2lp .
First-order formulas can be encoded in f2lp using the extended rule form F ← G, where
F and G are first-order formulas that do not contain →. The ASCII representation of the
quantifiers and connectives are shown in the following table.
Symbol
ASCII

¬
not

∼
-

∧
&

∨
|

←
<-

⊥
false

>
true

∀xyz
![X,Y,Z]:

∃xyz
?[X,Y,Z]:

For example, formula (34) can be encoded in the input language of f2lp as
holdsAt(F,T+1) <- holdsAt(F,T) & not releasedAt(F,T+1) &
not ?[E]:(happens(E,T) & terminates(E,F,T)).

The usual lparse and gringo rules (which have the rule arrow ‘:-’) are also allowed
in f2lp. Such rules are simply copied to the output. The program returned by f2lp can
be passed to ASP grounders and solvers that accept lparse and gringo languages.

6. Computing the Event Calculus Using ASP Solvers
Using translation f2lp, we further turn the event calculus reformulation in Section 3.2 into
answer set programs. The following procedure describes the process.
Definition 9 (Translation ec2asp)
1. Given an event calculus description (16), rewrite
all the definitional axioms of the form
def

∀x(p(x) ↔ G)

(35)

in Ξ as ∀x(G¬¬ → p(x)), where G¬¬ is obtained from G by prepending ¬¬ to
all occurrences of intensional predicates Initiates, Terminates, Releases, Happens,
Ab 1 , . . . , Ab n . Also prepend ¬¬ to the strictly positive occurrences of the intensional
predicates in the remaining axioms of Ξ. Let Ξ0 be the resulting formula obtained
from Ξ.
15.
16.
17.
18.

http://www.tcs.hut.fi/Software/smodels
http://potassco.sourceforge.net
For instance, (X=Y) | -q(X,Y) :- p(X,Y) is turned into :- X!=Y, {not q(X,Y)}0, p(X,Y).
Alternatively this can be done by declaring variables using the #domain directive in lparse and gringo
languages.

592

Reformulating the Situation Calculus and the Event Calculus

2. Apply translation f2lp on Σ ∧ ∆ ∧ Θ ∧ Ξ0 with the intensional predicates
{Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n } ∪ p,
where p is the set of all predicate constants p in (35) as considered in Step 1.
The following theorem states the correctness of the translation.
Theorem 8 Let T be an event calculus description (16) of signature σ that contains finitely
many predicate constants, let F be the FOL representation of the program obtained from T
by applying translation ec2asp. Then T is σ-equivalent to SM[F ].
In view of the theorem, system f2lp can be used to compute event calculus descriptions
by a simple rewriting as stated in translation ec2asp.19 The system can be used in place
of the dec reasoner in many existing applications of the event calculus, such as in robotics,
security, video games, and web service composition, as listed in
http://decreasoner.sourceforge.net/csr/decapps.html .
The computational mechanism of the dec reasoner is similar to our method as it is
based on the reduction of event calculus reasoning to propositional satisfiability and uses
efficient SAT solvers for computation. However, our method has some advantages.
First, it is significantly faster due to the efficient grounding mechanisms implemented
in ASP systems. This is evidenced in some experiments reported in Appendix B.
Second, f2lp allows us to compute the full version of the event calculus, assuming that
the domain is given and finite. On the other hand, the reduction implemented in the dec
reasoner is based on completion, which is weaker than circumscription. This makes the
system unable to handle recursive axioms and disjunctive axioms, such as effect constraints
and disjunctive event axioms (Section 3.1). For example, the dec reasoner does not allow
the following effect constraints which describe the indirect effects of an agent’s walking on
the objects that he is holding:
HoldsAt(Holding(a, o), t) ∧ Initiates(e, InRoom(a, r), t)
→ Initiates(e, InRoom(o, r), t)
HoldsAt(Holding(a, o), t) ∧ Terminates(e, InRoom(a, r), t)
→ Terminates(e, InRoom(o, r), t).

(36)

Third, we can enhance the event calculus reasoning by combining ASP rules with the
event calculus description. In other words, the event calculus can be viewed as a high
level action formalism on top of ASP. We illustrate this using the example from the work
of Doğandağ, Ferraris, and Lifschitz (2004). There are 9 rooms and 12 doors as shown in
Figure 1. Initially the robot “Robby” is in the middle room and all the doors are closed.
The goal of the robot is to make all rooms accessible from each other. Figure 2 (File robby)
shows an encoding of the problem in the language of f2lp. Atom door(x, y) denotes that
there is a door between rooms x and y; open(x, y) denotes the event “Robby opening the door
19. Kim, Lee, and Palla (2009) presented a prototype of f2lp called ecasp that is tailored to the event
calculus computation.

593

Lee & Palla

Figure 1: Robby’s apartment in a 3 × 3 grid
between rooms x and y”; goto(x) denotes the event “Robby going to room x”; opened(x, y)
denotes that the door between x and y has been opened; inRoom(x) denotes that Robby
is in room x; accessible(x, y) denotes that y is accessible from x. Note that the rules
defining the relation accessible are not part of event calculus axioms (Section 3.1). This
example illustrates an advantage of allowing ASP rules in event calculus descriptions.
The minimal number of steps to solve the given problem is 11. We can find such a
plan using the combination of f2lp, gringo (grounder) and claspD (solver for disjunctive
programs) in the following way. 20
$ f2lp dec robby | gringo -c maxstep=11 | claspD
File dec is an f2lp encoding of the domain independent axioms in the Discrete Event
Calculus (The file is listed in Appendix A).21 The following is one of the plans found:
happens(open(5,8),0) happens(open(5,2),1) happens(open(5,4),2)
happens(goto(4),3) happens(open(4,1),4) happens(open(4,7),5)
happens(goto(5),6) happens(open(5,6),7) happens(goto(6),8)
happens(open(6,9),9) happens(open(6,3),10)

7. Computing the Situation Calculus Using ASP Solvers
Using translation f2lp, we further turn the situation calculus reformulations in Sections 4.2
and 4.4 into answer set programs.
7.1 Representing Causal Action Theories by Answer Set Programs
The following theorem shows how to turn causal action theories into answer set programs.
Theorem 9 Let D be a finite causal action theory (23) of signature σ that contains finitely
many predicate constants, and let F be the FOL representation of the program obtained by
applying translation f2lp on
−
Dcaused ∧ Dposs → ∧ Drest
∧ Dsit

(37)

with the intensional predicates {Caused , Poss, Sit}. Then D is σ-equivalent to SM[F ].
20. One can use clingo instead of gringo and claspD if the output of f2lp is a nondisjunctive program.
21. The file is also available at http://reasoning.eas.asu.edu/f2lp, along with f2lp encodings of the
domain independent axioms in other versions of the event calculus.

594

Reformulating the Situation Calculus and the Event Calculus

% File ’robby’
% objects
step(0..maxstep).
astep(0..maxstep-1) :- maxstep > 0.
room(1..9).
% variables
#domain step(T).
#domain room(R).
#domain room(R1).
#domain room(R2).
% position of the
door(R1,R2) <- R1
door(R1,R2) <- R1
door(R1,R2) <- R1
door(R1,R2) <- R2

doors
>= 1 &
>= 4 &
>= 7 &
< 10 &

R2
R2
R2
R2

>=1 & R1 < 4 & R2 < 4 & R2 = R1+1.
>= 4 & R1 < 7 & R2 < 7 & R2 = R1+1.
>= 7 & R1 < 10 & R2 < 10 & R2 = R1+1.
= R1+3.

door(R1,R2) <- door(R2,R1).
% fluents
fluent(opened(R,R1)) <- door(R1,R2).
fluent(inRoom(R)).
% F ranges over the fluents
#domain fluent(F).
% events
event(open(R,R1)) <- door(R,R1).
event(goto(R)).
% E and E1 range over the events
#domain event(E).
#domain event(E1).
% effect axioms
initiates(open(R,R1),opened(R,R1),T).
initiates(open(R,R1),opened(R1,R),T).
initiates(goto(R2),inRoom(R2),T)
<- holdsAt(opened(R1,R2),T) & holdsAt(inRoom(R1),T).
terminates(E,inRoom(R1),T)
<- holdsAt(inRoom(R1),T) & initiates(E,inRoom(R2),T).
% action precondition axioms
holdsAt(inRoom(R1),T) <- happens(open(R1,R2),T).

595

Lee & Palla

% event occurrence constraint
not happens(E1,T) <- happens(E,T) & E != E1.
% state constraint
not holdsAt(inRoom(R2),T) <- holdsAt(inRoom(R1),T) & R1 != R2.
% accessibility
accessible(R,R1,T) <- holdsAt(opened(R,R1),T).
accessible(R,R2,T) <- accessible(R,R1,T) & accessible(R1,R2,T).
% initial state
not holdsAt(opened(R1,R2),0).
holdsAt(inRoom(5),0).
% goal state
not not accessible(R,R1,maxstep).
% happens is exempt from minimization in order to find a plan.
{happens(E,T)} <- T < maxstep.
% all fluents are inertial
not releasedAt(F,0).

Figure 2: Robby in f2lp

Similar to the computation of the event calculus in Section 6, the Herbrand stable
models of (37) can be computed using f2lp and answer set solvers. The input to f2lp can
be simplified as we limit attention to Herbrand models. We can drop axioms (18)–(21) as
they are ensured by Herbrand models. Also, in order to ensure finite grounding, instead of
Dsit , we include the following set of rules Πsituation in the input to f2lp.
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & action(A) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).

Πsituation is used to generate finitely many situation terms whose depth is up to maxdepth,
the value that can be given as an option in invoking gringo. Using the splitting theorem
(Section C.1), it is not difficult to check that if a program Π containing these rules has
no occurrence of predicate nesting in any other rules and has no occurrence of predicate situation in the head of any other rules, then every answer set of Π contains
atoms situation(do(am , do(am−1 , do(. . . , do(a1 , s0))))) for all possible sequences of actions
a1 , . . . , am for m = 0, . . . , maxdepth. Though this program does not satisfy syntactic conditions, such as λ-restricted (Gebser, Schaub, & Thiele, 2007), ω-restricted (Syrjänen, 2004),
or finite domain programs (Calimeri, Cozza, Ianni, & Leone, 2008), that answer set solvers
usually impose in order to ensure finite grounding, the rules can still be finitely grounded
596

Reformulating the Situation Calculus and the Event Calculus

% File: suitcase
value(t).
value(f).

lock(l1).

lock(l2).

#domain value(V).
#domain lock(X).
fluent(up(X)).
fluent(open).
#domain fluent(F).
action(flip(X)).
#domain action(A).
depth(0..maxdepth).
#domain depth(L).
% defining the situation domain
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).
% basic axioms
h(F,S) <- situation(S) & caused(F,t,S).
not h(F,S) <- situation(S) & caused(F,f,S).
% D_caused
caused(up(X),f,do(flip(X),S)) <situation(S) & not final(S) & poss(flip(X),S) & h(up(X),S).
caused(up(X),t,do(flip(X),S)) <situation(S) & not final(S) & poss(flip(X),S) & not h(up(X),S).
caused(open,t,S) <- situation(S) & h(up(l1),S) & h(up(l2),S).
% D_poss
poss(flip(X),S) <- situation(S).
% frame axioms
h(F,do(A,S)) <h(F,S) & situation(S) & not final(S) & poss(A,S)
& not ?[V]:caused(F,V,do(A,S)).
not h(F,do(A,S)) <not h(F,S) & situation(S) & not final(S) & poss(A,S)
& not ?[V]:caused(F,V,do(A,S)).
% h is non-intensional.
{h(F,S)} <- situation(S).

Figure 3: Lin’s Suitcase in the language of f2lp
597

Lee & Palla

by gringo Version 3.x, which does not check such syntactic conditions.22 It is not difficult
to see why the program above leads to finite grounding since we provide an explicit upper
limit for the nesting depth of function do.
In addition to Πsituation , we use the following program Πexecutable in order to represent
the set of executable situations (Reiter, 2001):
executable(s0).
executable(do(A,S)) <- executable(S) & poss(A,S) & not final(S)
& situation(S) & action(A).

Figure 3 shows an encoding of Lin’s suitcase example (1995) in the language of f2lp
(h is used to represent Holds), which describes a suitcase that has two locks and a spring
loaded mechanism which will open the suitcase when both locks are up. This example
illustrates how the ramification problem is handled in causal action theories. Since we fix
the domain of situations to be finite, we require that actions not be effective in the final
situations. This is done by introducing atom final(S).
Consider the simple temporal projection problem by Lin (1995). Initially the first lock
is down and the second lock is up. What will happen if the first lock is flipped? Intuitively,
we expect both locks to be up and the suitcase to be open. We can automate the reasoning
by using the combination of f2lp, gringo and claspD. First, we add Πexecutable and the
following rules to the theory in Figure 3. In order to check if the theory entails that flipping
the first lock is executable, and that the suitcase is open after the action, we encode the
negation of these facts in the last rule.
% initial situation
<- h(up(l1),s0).
h(up(l2),s0).
% query
<- executable(do(flip(l1),s0)) & h(open,do(flip(l1),s0)).

We check the answer to the temporal projection problem by running the command:
$ f2lp suitcase | gringo -c maxdepth=1 | claspD

claspD returns no answer set as expected.
Now, consider a simple planning problem for opening the suitcase when both locks are
initially down. We add Πexecutable and the following rules to the theory in Figure 3. The
last rule encodes the goal.
% initial situation
<- h(up(l1),s0).
<- h(up(l2),s0).
<- h(open,s0).
% goal
<- not ?[S]: (executable(S) & h(open,S)).

When maxdepth is 1, the combined use of f2lp, gringo and claspD results in no
answer sets, and when maxdepth is 2, it finds the unique answer set that contains both
22. Similarly, system dlv-complex allows us to turn off the finite domain checking (option -nofdcheck).
That system was used in a conference paper (Lee & Palla, 2010) that this article is based on.

598

Reformulating the Situation Calculus and the Event Calculus

h(open, do(flip(l2), do(flip(l1), s0))) and h(open, do(flip(l1), do(flip(l2), s0))), each
of which encodes a plan. In other words, the single answer set encodes multiple plans
in different branches of the situation tree, which allows us to combine information about
the different branches in one model. This is an instance of hypothetical reasoning that is
elegantly handled in the situation calculus due to its branching time structure. Belleghem,
Denecker, and Schreye (1997) note that the linear time structure of the event calculus is
limited to handle such hypothetical reasoning allowed in the situation calculus.
7.2 Representing Basic Action Theories by Answer Set Programs
Since a BAT T (not including the second-order axiom (22)) can be viewed as a first-order
theory under the stable model semantics with the list of intensional predicates being empty,
it follows that f2lp can be used to turn T into a logic program. As before, we focus on
ASP-style BAT.
Theorem 10 Let T be a ASP-style BAT (26) of signature σ that contains finitely many
predicate constants, and let F be the FOL representation of the program obtained by applying translation f2lp on T with intensional predicates {Holds, ∼ Holds, Poss}. Then
SM[T ; Holds, ∼Holds, Poss] is σ-equivalent to SM[F ; σ(F ) ∪ {Poss}].
Figure 4 shows an encoding of the “broken object” example discussed by Reiter (1991).
Consider the simple projection problem of determining if an object o, which is next to
bomb b, is broken after the bomb explodes. We add Πexecutable and the following rules to
the theory in Figure 4.
% initial situation
not h(broken(o),s0) & h(fragile(o),s0) & h(nexto(b,o),s0).
not h(holding(p,o),s0) & not h(exploded(b),s0).
% query
<- executable(do(explode(b),s0)) & h(broken(o),do(explode(b),s0)).

The command
$ f2lp broken | gringo -c maxdepth=1 | claspD

returns no answer set as expected.

8. Related Work
Identifying a syntactic class of theories on which different semantics coincide is important
in understanding the relationship between them. It is known that, for tight logic programs
and tight first-order formulas, the stable model semantics coincides with the completion
semantics (Fages, 1994; Erdem & Lifschitz, 2003; Ferraris et al., 2011). This fact helps us
understand the relationship between the two semantics, and led to the design of the answer
set solver cmodels-1 23 that computes answer sets using completion. Likewise the class
of canonical formulas introduced here helps us understand the relationship between the
stable model semantics and circumscription. The class of canonical formulas is the largest
23. http://www.cs.utexas.edu/users/tag/cmodels

599

Lee & Palla

% File: broken
% domains other than situations
person(p).
object(o).
bomb(b).
#domain person(R).
#domain object(Y).
#domain bomb(B).
fluent(holding(R,Y)).
fluent(broken(Y)).

fluent(nexto(B,Y)).
fluent(exploded(B)).

fluent(fragile(Y)).

action(drop(R,Y)).

action(explode(B)).

action(repair(R,Y)).

#domain fluent(F).
#domain action(A).
depth(0..maxdepth).
#domain depth(L).
% defining the situation domain
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).
% Effect Axioms
h(broken(Y),do(drop(R,Y),S)) <- situation(S) & h(fragile(Y),S) & not final(S).
h(broken(Y),do(explode(B),S)) <- situation(S) & h(nexto(B,Y),S) & not final(S).
h(exploded(B),do(explode(B),S)) <- situation(S) & not final(S).
-h(broken(Y),do(repair(R,Y),S)) <- situation(S) & not final(S).
-h(holding(R,Y),do(drop(R,Y),S)) <- situation(S) & not final(S).
% Action precondition axioms
poss(drop(R,Y),S) <- h(holding(R,Y),S) & situation(S).
poss(explode(B),S) <- situation(S) & not h(exploded(B),S).
poss(repair(R,Y),S) <- situation(S) & h(broken(Y),S).
% inertial axioms
h(F,do(A,S)) <- h(F,S) & not -h(F,do(A,S)) & situation(S) & not final(S).
-h(F,do(A,S)) <- -h(F,S) & not h(F,do(A,S)) & situation(S) & not final(S).
% D_exogeneous_0
h(F,s0) | -h(F,s0).
% Consider only those interpretations that are complete on Holds
<- not h(F,S) & not -h(F,S) & situation(S).

Figure 4: Broken object example in the language of f2lp

600

Reformulating the Situation Calculus and the Event Calculus

syntactic class of first-order formulas identified so far on which the stable models coincide
with the models of circumscription. In other words, minimal model reasoning and stable
model reasoning are indistinguishable on canonical formulas.
Proposition 8 from the work of Lee and Lin (2006) shows an embedding of propositional circumscription in logic programs under the stable model semantics. Our theorem
on canonical formulas is a generalization of this result to the first-order case. Janhunen
and Oikarinen (2004) showed another embedding of propositional circumscription in logic
programs, and implemented the system circ2dlp,24 but their translation appears quite
different from the one by Lee and Lin.
Zhang, Zhang, Ying, and Zhou (2011) show an embedding of first-order circumscription
in first-order stable model semantics. Theorem 3 from that paper is reproduced as follows.25
Theorem 11 (Zhang et al., 2011, Thm. 3) Let F be a formula in negation normal form
and let p be a finite list of predicate constants. Let F ¬¬ be the formula obtained from F
by replacing every p(t) by ¬¬p(t), and let F c be the formula obtained from F by replacing
every ¬p(t) by p(t) → Choice(p), where p is in p and t is a list of terms. Then CIRC[F ; p]
is equivalent to SM[F ¬¬ ∧ F c ; p].
In comparison with Theorem 1, this theorem can be applied to characterize circumscription of arbitrary formulas in terms of stable models by first rewriting the formulas into
negation normal form. While Theorem 1 is applicable to canonical formulas only, it does
not require any transformation, and the characterization is bidirectional in the sense that
it can be also viewed as a characterization of stable models in terms of circumscription.
Zhang et al. (2011) also introduce a translation that turns arbitrary first-order formulas
into logic programs, but this work is limited to finite structures only. On the other hand,
our translation f2lp (Definition 8) works for almost universal formulas only, but is not
limited to finite structures.
The situation calculus and the event calculus are widely studied action formalisms,
and there are several papers that compare and relate them (e.g., Belleghem, Denecker, &
Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997).
Prolog provides a natural implementation for basic action theories since definitional
axioms can be represented by Prolog rules according to the Clark’s theorem (Reiter, 2001,
Chapter 5). The Lloyd-Topor transformation that is used to turn formulas into Prolog rules
is similar to translation f2lp, but the difference is that the former preserves the completion
semantics and the latter preserves the stable model semantics.
Lin and Wang (1999) describe a language that can be used to represent a syntactically
restricted form of Lin’s causal situation calculus, called “clausal causal theories,” which does
not allow quantifiers. They show how to translate that language into answer set programs
with strong negation, the answer sets of which are then used to obtain fully instantiated
successor state axioms and action precondition axioms. This is quite different from our
approach, which computes the propositional models of the full situation calculus theories
directly.
Kautz and Selman (1992) introduce linear encodings that are similar to a propositionalized version of the situation calculus (McCarthy & Hayes, 1969). Lin (2003) introduces
24. http://www.tcs.hut.fi/Software/circ2dlp
25. This is a bit simpler than the original statement because some redundancy is dropped.

601

Lee & Palla

an action description language and describes a procedure to compile an action domain in
that language into a complete set of successor state axioms, from which a STRIPS-like
description can be extracted. The soundness of the procedure is shown with respect to a
translation from action domain descriptions into Lin’s causal action theories. However, that
procedure is based on completion and as such cannot handle recursive axioms unlike our
approach.
Denecker and Ternovska (2007) present an inductive variant of the situation calculus
represented in ID-logic (Denecker & Ternovska, 2008)—classical logic extended with inductive definitions. ID-logic and the first-order stable model semantics appear to be closely
related, but the precise relationship between them has yet to be shown.

9. Conclusion
The first-order stable model semantics is defined similar to circumscription. This paper
takes advantage of that definition to identify a class of formulas on which minimal model
reasoning and stable model reasoning coincide, and uses this idea to reformulate the situation calculus and the event calculus in the first-order stable model semantics. Together
with the translation that turns an almost universal sentence into a logic program, we show
that reasoning in the situation calculus and the event calculus can be reduced to computing
answer sets. We implemented system f2lp, a front-end to ASP solvers that allows us to
compute these circumscriptive action theories. The mathematical tool sets and the system presented in this paper may also be useful in relating other circumscriptive theories
to logic programs. Also, the advances in ASP solvers may improve the computation of
circumscriptive theories.

Acknowledgments
We are grateful to Yuliya Lierler, Vladimir Lifschitz, Erik Mueller, Heng Zhang, Yan Zhang,
and the anonymous referees for their useful comments and discussions. The authors were
partially supported by the National Science Foundation under Grant IIS-0916116.

Appendix A. File ‘dec’ in the Language of f2lp
File ’dec’ encodes the domain independent axioms in the discrete event calculus. This file
is to be used together with event calculus domain descriptions as shown in Section 6.
% File ‘dec’
#domain
#domain
#domain
#domain
#domain
#domain
#domain

fluent(F).
fluent(F1).
fluent(F2).
event(E).
time(T).
time(T1).
time(T2).

time(0..maxstep).
602

Reformulating the Situation Calculus and the Event Calculus

% DEC 1
stoppedIn(T1,F,T2) <- happens(E,T) & T1<T & T<T2 & terminates(E,F,T).
% DEC 2
startedIn(T1,F,T2) <- happens(E,T) & T1<T & T<T2 & initiates(E,F,T).
% DEC 3
holdsAt(F2,T1+T2) <- happens(E,T1) & initiates(E,F1,T1) & T2>0 &
trajectory(F1,T1,F2,T2) & not stoppedIn(T1,F1,T1+T2) & T1+T2<=maxstep.
% DEC 4
holdsAt(F2,T1+T2) <- happens(E,T1) & terminates(E,F1,T1) & 0<T2 &
antiTrajectory(F1,T1,F2,T2) & not startedIn(T1,F1,T1+T2) &
T1+T2<=maxstep.
% DEC 5
holdsAt(F,T+1) <- holdsAt(F,T) & not releasedAt(F,T+1) &
not ?[E]:(happens(E,T) & terminates(E,F,T)) & T<maxstep.
% DEC 6
not holdsAt(F,T+1) <- not holdsAt(F,T) & not releasedAt(F,T+1) &
not ?[E]:(happens(E,T) & initiates(E,F,T)) & T<maxstep.
% DEC 7
releasedAt(F,T+1) <releasedAt(F,T) & not ?[E]:(happens(E,T) &
(initiates(E,F,T) | terminates(E,F,T))) & T<maxstep.
% DEC 8
not releasedAt(F,T+1) <- not releasedAt(F,T) &
not ?[E]: (happens(E,T) & releases(E,F,T)) & T<maxstep.
% DEC 9
holdsAt(F,T+1) <- happens(E,T) & initiates(E,F,T) & T<maxstep.
% DEC 10
not holdsAt(F,T+1) <- happens(E,T) & terminates(E,F,T) & T<maxstep.
% DEC 11
releasedAt(F,T+1) <- happens(E,T) & releases(E,F,T) & T<maxstep.
% DEC 12
not releasedAt(F,T+1) <- happens(E,T) &
(initiates(E,F,T) | terminates(E,F,T)) & T<maxstep.
{holdsAt(F,T)}.
{releasedAt(F,T)}.

603

Lee & Palla

Problem
(max. step)

dec
reasoner

dec
reasoner (minisat)

f2lp with
lparse + cmodels

f2lp with
gringo + cmodels

f2lp with
gringo + clasp(D)

f2lp with
clingo

BusRide
(15)

—

—

—

—

—

0.2s
(0.07s + 0.13s)
A:13174/R:24687

0.14s

Kitchen
Sink (25)

39.0s
(38.9s + 0.1s)
A:1014/C:12109

38.9s
(38.9s + 0.00s)
A:1014/C:12109

0.24s
(0.18s + 0.06s)
A:11970/R:61932

0.20s

Thielscher
Circuit (40)

6.5s
(6.3s + 0.2s)
A:1394/C:42454

6.3s
(6.3s + 0.0s)
A:1394/C:42454

0.12s
(0.09s + 0.03s)
A:4899/R:35545

0.1s

Walking
Turkey (15)

—

—

0.00s
(0.00s + 0.00s)
A:316/R:456

0.00s

Falling w/
AntiTraj (15)

141.8s
(141.4s + 0.4s)
A:416/C:3056

141.7s
(141.7s + 0.00s)
A:416/C:3056

0.03s
(0.03s + 0.00s)
A:3702/R:7414

0.03s

Falling w/
Events (25)

59.5s
(59.5s + 0.0s)
A:1092/C:12351

59.4s
(59.4s + 0.0s)
A:1092/C:12351

0.28s
(0.20s + 0.08s)
A:13829/R:71266

0.22s

HotAir
Baloon (15)

32.2s
(32.2s + 0.0s)
A:288/C:1163

32.3s
(32.3s + 0.0s)
A:288/C:1163

0.0s
(0.0s + 0.0s)
A:1063/R:1835

0.01s

Telephone1
(40)

9.3s
(9.2s + 0.1s)
A:5419/C:41590

9.1s
(9.1s + 0.0s)
A:5419/C:41590

0.00s
(0.00s + 0.00s)
A:355/R:555
C:0
0.15s
(0.07s + 0.08s)
A:5269/R:24687
C:5308
0.44s
(0.19s + 0.25s)
A:11970/R:61932
C:0
0.19s
(0.09s + 0.1s)
A:4899/R:35545
C:0
0.00s
(0.00s + 0.00s)
A:316/R:456
C:0
0.04s
(0.02s + 0.02s)
A:3702/R:7414
C:0
0.46s
(0.20s + 0.26s)
A:1219/R:71266
C:1415
0.0s
(0.0s + 0.0s)
A:492/R:1835
C:681
0.11s
(0.08s + 0.03s)
A:9455/R:13140
C:0

0.01s
(0.00s + 0.01s)
A:448/R:647

Commuter
(15)

0.04s
(0.03s + 0.01s)
A:902/R:7779
C:0
77.29s
(45.74s + 31.55s)
A:32861/R:8734019
C:0
6.19s
(2.99s + 3.20s)
A:121621/R:480187
C:0
0.42s
(0.27s + 0.15s)
A:9292/R:53719
C:0
0.00s
(0.00s + 0.00s)
A:370/R:518
C:0
0.08s
(0.05s + 0.03s)
A:4994/R:9717
C:0
4.95s
(2.57s + 2.38s)
A:1240/R:388282
C:1436
0.01s
(0.01s + 0.00s)
A:494/R:2451
C:689
0.22s
(0.13s + 0.09s)
A:21414/R:27277
C:0

0.07s
(0.06s + 0.01s)
A:9455/R:13140

0.07s

A: number of atoms, C: number of clauses, R: number of ground rules
Figure 5: Comparing the dec reasoner and f2lp with answer set solvers

Appendix B. Comparing the dec Reasoner with ASP-based Event
Calculus Reasoner
We compared the performance of the dec reasoner (v 1.0) running relsat (v 2.2) and
minisat (v 2.2) with the following:
• f2lp (v 1.11) with lparse (v 1.0.17)+cmodels (v 3.79) running minisat (v 2.0
beta),
• f2lp (v 1.11) with gringo (v 3.0.3)+cmodels (v 3.79) running minisat (v 2.0 beta),
• f2lp (v 1.11) with gringo (v 3.0.3) +clasp (v 2.0.2) (claspD (v 1.1.2) used instead
for disjunctive programs), and
• f2lp (v 1.11) with clingo (v 3.0.3 (clasp v 1.3.5)).
f2lp turns an input theory into the languages of lparse and gringo, and lparse and
gringo turn the result into a ground ASP program. cmodels turns this ground program
into a set of clauses and then invokes a SAT solver to compute answer sets, while clasp
computes answer sets using the techniques similar to those used in SAT solvers. clingo is
a system that combines gringo and clasp in a monolithic way.
The first five examples in Figure 5 are part of the benchmark problems from the work
of Shanahan (1997, 1999). The next four are by Mueller (2006). (We increased timepoints
604

Reformulating the Situation Calculus and the Event Calculus

Problem
(max. step)
ZooTest1
(16)

f2lp with
gringo + cmodels
50.48s
(6.66s + 43.82s)
A:930483/R:2272288
C:3615955
ZooTest2
> 2h
159.51s
(22)
(12.36s + 147.15s)
A:2241512/R:4153670
C:8864228
ZooTest3
> 2h
142.68s
(23)
(13.55s + 129.13s)
A:2505940/R:4556928
C:9914568
A: number of atoms, C: number of clauses, R: number
dec
reasoner (minisat)
> 2h

f2lp with
gringo + clasp
29.01s
(6.66s + 22.35s)
A:153432/R:2271175
210.55s
(12.36s + 198.19s)
A:219220/R:4152137
196.63s
(13.55s + 183.08s)
A:230731/R:4555325
of ground rules

Figure 6: Zoo World in dec reasoner and ASP

to see more notable differences.) More examples can be found from the f2lp homepage. All
experiments were done on a Pentium machine with 3.06 GHz CPU and 4GB RAM running
64 bit Linux. The reported run times are in seconds and were obtained using the Linux
time command (“user time + sys time”), except for the dec reasoner for which we recorded
the times reported by the system. This was for fair comparisons in order to avoid including
the time spent by the dec reasoner in producing output in a neat format, which sometimes
takes non-negligible time. For the dec reasoner, the times in parentheses are “(SAT encoding time + SAT solving time).” For the others, they are the times spent by each of the
grounder and the solver. cmodels time includes the time spent in converting the ground
program generated by lparse/gringo into a set of clauses, and calling the SAT solver.
The time spent by f2lp in translating an event calculus description into an answer set
program (retaining variables) is negligible for these problems. ’—’ denotes that the system
cannot solve the example due to the limited expressivity. For instance, BusRide includes
disjunctive event axioms, which results in a disjunctive program that cannot be handled
by clingo. Similarly, the dec reasoner cannot handle BusRide (disjunctive event axioms),
Commuter (compound events) and Walking Turkey (effect constraints). As is evident from
the experiments, the main reason for the efficiency of the ASP-based approach is the efficient grounding mechanisms implemented in the ASP grounders. Though the dec reasoner
and cmodels call the same SAT solver minisat, the number of atoms processed by the dec
reasoner is in general much smaller. This is because the dec reasoner adopts an optimized
encoding method (that is based on predicate completion) which avoids a large number of
ground instances of atoms such as Initiates(e, f, t), Terminates(e, f, t), and Releases(e, f, t)
(Mueller, 2004, Section 4.4). On the other hand, in several examples, the number of clauses
generated by cmodels is 0, which means that the answer sets were found without calling
the SAT solver. This is because for these examples the unique answer set coincides with
the well-founded model, which is efficiently computed by cmodels in a preprocessing step
before calling SAT solvers. Out of the 14 benchmark examples by Shanahan (1997, 1999),
10 of them belong to this case when lparse is used for grounding.
605

Lee & Palla

In the experiments in Figure 5, the solving times are negligible for most of the problems. We also experimented with some computationally hard problems, where solving takes
more time than grounding. Figure 6 shows runs of a medium-size action domain, the Zoo
World (Akman, Erdoğan, Lee, Lifschitz, & Turner, 2004). All the tests shown in the table
are planning problems where max. step is the length of a minimal plan. The cut-off time
was 2 hours and the dec reasoner did not terminate within that time for any of the problems. In fact, the entire time was spent on SAT encoding and the SAT solver was never
called. On the other hand, the ASP grounder gringo took only a few seconds to ground
the domain and, unlike in Figure 5, the solvers took much more time than the grounder. As
we can see, cmodels with minisat performed better than clasp on two of the problems.
To check the time taken by minisat on the encoding generated by the dec reasoner, we
ran ZooTest1 to completion. The dec reasoner terminated after 116578.1 seconds (32.38
hours).

Appendix C. Proofs
C.1 Review of Some Useful Theorems
We review some theorems by Ferraris et al. (2011) and Ferraris et al. (2009) which will be
used to prove our main results. In fact, we will provide a version of the splitting theorem
which is slightly more general than the one given by Ferraris et al. (2009), in order to
facilitate our proof efforts.
Lemma 1 Formula
u ≤ p → ((¬F )∗ (u) ↔ ¬F )
is logically valid.
Theorem 12 (Ferraris et al., 2011, Thm. 2) For any first-order formula F and any
disjoint lists p, q of distinct predicate constants,
SM[F ; p] ↔ SM[F ∧ Choice(q); p ∪ q]
is logically valid.
Let F be a first-order formula. A rule of F is an implication that occurs strictly positively
in F . The predicate dependency graph of F (relative to p) is the directed graph that
• has all members of p as its vertices, and
• has an edge from p to q if, for some rule G → H of F ,
– p has a strictly positive occurrence in H, and
– q has a positive occurrence in G that does not belong to any subformula of G
that is negative on p.
Theorem 13 (Ferraris et al., 2009, Splitting Thm.) Let F , G be first-order sentences,
and let p, q be finite disjoint lists of distinct predicate constants. If
606

Reformulating the Situation Calculus and the Event Calculus

(a) each strongly connected component of the predicate dependency graph of F ∧ G relative
to p, q is either a subset of p or a subset of q,
(b) F is negative on q, and
(c) G is negative on p
then
SM[F ∧ G; p ∪ q] ↔ SM[F ; p] ∧ SM[G; q]
is logically valid.
The theorem is slightly more general than the one by Ferraris et al. (2009) in that the
notion of a dependency graph above yields less edges than the one given by Ferraris et al.
Instead of
– q has a positive occurrence in G that does not belong to any subformula of G
that is negative on p,
Ferraris et al.’s definition has
– q has a positive occurrence in G that does not belong to any subformula of the
form ¬K.
For instance, according to Ferraris et al., the dependency graph of
((p → q) → r) → p

(38)

relative to p has two edges (from p to r, and from p to p), while the dependency graph
according to our definition has no edges.
On the other hand, the generalization is not essential in view of the following theorem.
Theorem 14 (Ferraris et al., 2009, Thm. on Double Negations) Let H be a sentence, F
a subformula of H, and H ¬¬ the sentence obtained from H by inserting ¬¬ in front of F .
If the occurrence of F is p-negated in H, then SM[H; p] is equivalent to SM[H ¬¬ ; p].
For instance, SM[(38); p] is equivalent to SM[¬¬((p → q) → r) → p; p]. The dependency
graph of ¬¬((p → q) → r) → p relative to p according to the definition by Ferraris et al. is
identical to the dependency graph of (38) relative to p according to our definition.
Next, we say that a formula F is in Clark normal form (relative to the list p of intensional
predicates) if it is a conjunction of sentences of the form
∀x(G → p(x)),

(39)

one for each intensional predicate p, where x is a list of distinct object variables, and G has
no free variables other than those in x. The completion (relative to p) of a formula F in
Clark normal form is obtained by replacing each conjunctive term (39) with
∀x(p(x) ↔ G).
The following theorem relates SM to completion. We say that F is tight on p if the
predicate dependency graph of F relative to p is acyclic.
Theorem 15 (Ferraris et al., 2011) For any formula F in Clark normal form that is tight
on p, formula SM[F ; p] is equivalent to the completion of F relative to p.
607

Lee & Palla

C.2 Proof of Proposition 1
Using Theorem 12 and Theorem 13,
SM[F ; p] ⇔ SM[F ; p ∩ pr (F )] ∧ SM[>; p\pr (F )]
⇔ SM[F ; p ∩ pr (F )] ∧ False(p\pr (F ))
⇔ SM[F ∧ Choice(pr (F )\p)] ∧ False(p\pr (F ))
⇔ SM[F ∧ Choice(pr (F )\p) ∧ False(p\pr (F ))].

C.3 Proof of Theorem 1
In the following, F is a formula, p is a list of distinct predicate constants p1 , . . . , pn , and u
is a list of distinct predicate variables u1 , . . . , un of the same length as p.
Lemma 2 (Ferraris et al., 2011, Lemma 5) Formula
u ≤ p → (F ∗ (u) → F )
is logically valid.
Lemma 3 If every occurrence of every predicate constant from p is strictly positive in F ,
(u ≤ p) → (F ∗ (u) ↔ F (u))
is logically valid.
Proof. By induction. We will show only the case when F is G → H. The other cases are
straightforward. Consider
F ∗ (u) = (G∗ (u) → H ∗ (u)) ∧ (G → H).
Since every occurrence of predicate constants from p in F is strictly positive, G contains
no predicate constants from p, so that G∗ (u) is equivalent to G(u), which is the same as
G. Also, by I.H., H ∗ (u) ↔ H(u) is logically valid. Therefore it is sufficient to prove that
under the assumption u ≤ p,
(G → H(u)) ∧ (G → H) ↔ (G → H(u))
is logically valid. From left to right is clear. Assume (u ≤ p), G → H(u), and G. We get
H(u), which is equivalent to H ∗ (u) by I.H. By Lemma 2, we conclude H.

The proof of Theorem 1 is immediate from the following lemma, which can be proved
by induction.
Lemma 4 If F is canonical relative to p, then formula
(u ≤ p) ∧ F → (F ∗ (u) ↔ F (u))
is logically valid.
608

Reformulating the Situation Calculus and the Event Calculus

Proof.
• F is an atomic formula. Trivial.
• F = G ∧ H. Follows from I.H.
• F = G ∨ H. Assume (u ≤ p) ∧ (G ∨ H). Since G ∨ H is canonical relative to p,
every occurrence of every predicate constant from p is strictly positive in G or in H,
so that, by Lemma 3, G∗ (u) is equivalent to G(u), and H ∗ (u) is equivalent to H(u).
• F = G → H. Assume (u ≤ p) ∧ (G → H). It is sufficient to show
(G∗ (u) → H ∗ (u)) ↔ (G(u) → H(u)).

(40)

Since G → H is canonical relative to p, every occurrence of every predicate constant
from p in G is strictly positive in G, so that, by Lemma 3, G∗ (u) is equivalent to
G(u).
– Case 1: ¬G. By Lemma 2, ¬G∗ (u). The claim follows since ¬G∗ (u) is equivalent
to ¬G(u).
– Case 2: H. By I.H. H ∗ (u) is equivalent to H(u). The claim follows since G∗ (u)
is equivalent to G(u).
• F = ∀xG. Follows from I.H.
• F = ∃xG. Since every occurrence of every predicate constant from p in G is strictly
positive in G, the claim follows from Lemma 3.

C.4 Proof of Theorem 2
Proof. Between (a) and (b):
Between (b) and (c):

Follows immediately from Theorem 1.

Note first that Ξ is equivalent to SM[Ξ; ∅]. Since

• every strongly connected component in the dependency graph of Σ ∧ ∆ relative to
{I, T, R, H} either belongs to {I, T, R} or {H},
• Σ is negative on {H}, and
• ∆ is negative on {I, T, R},
it follows from Theorem 13 that (b) is equivalent to
SM[Σ ∧ ∆; I, T, R, H] ∧ SM[Θ; Ab1 , . . . , Abn ] ∧ SM[Ξ; ∅]
Similarly, applying Theorem 13 repeatedly, we can show that the above formula is
equivalent to (c).
Between (c) and (d):

By Proposition 1.



609

Lee & Palla

C.5 Proof of Theorem 3
Since Dcaused is canonical relative to Caused , by Theorem 1, (a)

Between (a) and (b):
is equivalent to

−
SM[Dcaused ; Caused ] ∧ Dposs ∧ Drest
∧ (22).

(41)

Consequently, it is sufficient to prove the claim that, under the assumption ∀s Sit(s),
formula (22) is equivalent to SM[Dsit ; Sit].
First note that under the assumption, (22) can be equivalently rewritten as

∀p p(S0 ) ∧ ∀a, s(p(s) → p(do(a, s))) → p = Sit .
(42)
On the other hand, under ∀s Sit(s), SM[Dsit ; Sit] is equivalent to
Sit(S0 ) ∧ ∀a, s(Sit(s) → Sit(do(a, s)))

∧ ∀p p < Sit → ¬(p(S0 ) ∧ ∀a, s(p(s) → p(do(a, s))) ∧ ∀a, s(Sit(s) → Sit(do(a, s)))) ,
which, under the assumption ∀s Sit(s), is equivalent to
∀p p(S0 ) ∧ ∀a, s(p(s) → p(do(a, s))) → ¬(p < Sit)



and furthermore to (42).
Between (b) and (c): Since φ(s) does not contain Poss, the equivalence follows from the
equivalence between completion and the stable model semantics.
Between (c) and (d): Since Dcaused contains no strictly positive occurrence of Poss
and Dposs → contains no occurrence of Caused , every strongly connected component in the
predicate dependency graph of Dcaused ∧ Dposs → relative to {Caused , Poss} either belongs
to {Caused } or belongs to {Poss}. By Theorem 13, it follows that (b) is equivalent to
−
SM[Dcaused ∧ Dposs → ; Caused , Poss] ∧ Drest
∧ SM[Dsit ; Sit].

Similarly, applying Theorem 13 two more times, we get that the above formula is equivalent
to (c).

C.6 Proof of Theorem 4
Theory T is
Σ ∧ Deffect ∧ Dprecond ∧ DS0 ∧ Duna ∧ Dinertia ∧ Dexogenous0 ,
and the corresponding BAT is
Σ ∧ Dss ∧ Dap ∧ DS0 ∧ Duna .
Without loss of generality, we assume that T is already equivalently rewritten so that there
are exactly one positive effect axiom and exactly one negative effect axiom for each fluent R,
and that there is exactly one action precondition axiom for each action A.
610

Reformulating the Situation Calculus and the Event Calculus

Consider
SM[Σ ∧ Deffect ∧ Dprecond ∧ DS0 ∧ Duna ∧ Dinertia ∧ Dexogenous0 ; Poss, Holds, ∼Holds].
Since Σ and Duna are negative on the intensional predicates, the formula is equivalent to
SM[Deffect ∧ Dprecond ∧ DS0 ∧ Dinertia ∧ Dexogenous0 ; P oss, Holds, ∼Holds] ∧ Σ ∧ Duna .
(43)
Since P oss does not occur in
Deffect ∧ DS0 ∧ Dinertia ∧ Dexogenous0 ,
and since Dprecond is negative on {Holds, ∼Holds}, by Theorem 13, (43) is equivalent to
SM[Deffect ∧ DS0 ∧ Dinertia ∧ Dexogenous0 ; Holds, ∼Holds]
∧ SM[Dprecond ; P oss] ∧ Σ ∧ Duna ,

(44)

which is equivalent to
SM[Deffect ∧ DS0 ∧ Dinertia ∧ Dexogenous0 ; Holds, ∼Holds]
∧ Dap ∧ Σ ∧ Duna .
Therefore the statement of the theorem can be proven by showing the following: if
−
I |= ¬∃x a s(Γ+
R (x, a, s) ∧ ΓR (x, a, s))

(45)

I |= Σ

(46)

SM[DS0 ∧ Dexogenous0 ∧ Deffect ∧ Dinertia ; Holds, ∼Holds]

(47)

for every fluent R, and
then I satisfies

iff I|σ satisfies
DS0 ∧ Dss .
From Dexogenous0 , it follows that (47) is equivalent to
SM[DS¬¬
∧ Dexogenous0 ∧ Deffect ∧ Dinertia ; Holds, ∼Holds],
0

(48)

where DS¬¬
is the formula obtained from DS0 by prepending ¬¬ to all occurrences of Holds.
0
Under the assumption (46),
DS¬¬
∧ Dexogenous0 ∧ Deffect ∧ Dinertia
0
is {Holds}-atomic-tight w.r.t. I, 26 so that by the relationship between completion and SM
that is stated in Corollary 11 of (Lee & Meng, 2011), we have that I |= (48) iff I satisfies
DS0 , and, for each fluent R,
26. See Section 7 from the work of Lee and Meng (2011) for the definition.

611

Lee & Palla

Holds(R(x), do(a, s)) ↔ Γ+
R (x, a, s) ∨ (Holds(R(x, s) ∧ ¬ ∼Holds(R(x), do(a, s)))

(49)

and
∼Holds(R(x), do(a, s)) ↔ Γ−
R (x, a, s) ∨ (∼Holds(R(x), s) ∧ ¬Holds(R(x), do(a, s))), (50)
where x, a, s are any (lists of) object names of corresponding sorts.
It remains to show that, under the assumption (45), I satisfies (49) ∧ (50) iff I|σ satisfies
−
Holds(R(x), do(a, s)) ↔ Γ+
R (x, a, s) ∨ (Holds(R(x), s) ∧ ¬ΓR (x, a, s)).

(51)

In the following we will use the following facts.
• I |=∼Holds(R(x), s) iff I|σ 6|= Holds(R(x), s).
• if F is a ground formula that does not contain ∼, then I |= F iff I|σ |= F .
Left to Right: Assume I |= (49) ∧ (50).
• Case 1: I|σ |= Holds(R(x), do(a, s)). Clearly, I |= Holds(R(x), do(a, s)), so that,
from (49), there are two subcases to consider.
– Subcase 1: I |= Γ+
R (x, a, s). Clearly, I|σ satisfies both LHS and RHS of (51).
– Subcase 2: I |= Holds(R(x), s). From (50), it follows that I 6|= Γ−
R (x, a, s), and
(x,
a,
s).
Clearly,
I|
satisfies
both
LHS
and
RHS of (51).
consequently, I|σ 6|= Γ−
σ
R
• Case 2: I|σ 6|= Holds(R(x), do(a, s)). It follows from (49) that I 6|= Γ+
R (x, a, s), which
(x,
a,
s).
Also
since
I
|=∼Holds(R(x),
do(a, s)),
is equivalent to saying that I|σ 6|= Γ+
R
from (50), there are two subcases to consider.
– Subcase 1: I |= Γ−
R (x, a, s). Clearly, I|σ satisfies neither LHS nor RHS of (51).
– Subcase 2: I |= ∼ Holds(R(x), s). This is equivalent to saying that I|σ 6|=
Holds(R(x), s). Clearly, I|σ satisfies neither LHS nor RHS of (51).
Right to Left: Assume I|σ |= (51).
• Case 1: I |= Holds(R(x), do(a, s)). It follows from (51) that I|σ satisfies RHS of (51),
so that there are two subcases to consider.
– Subcase 1: I|σ |= Γ+
R (x, a, s). Clearly, I satisfies both LHS and RHS of (49).
Also from (45), it follows that I 6|= Γ−
R (x, a, s). Consequently, I satisfies neither
LHS nor RHS of (50).
– Subcase 2: I|σ |= Holds(R(x), s) ∧ ¬Γ−
R (x, a, s). Clearly, I satisfies both LHS and
RHS of (49). Since I 6|= Γ−
(x,
a,
s),
I
satisfies neither LHS nor RHS of (50).
R
• Case 2: I |=∼Holds(R(x), do(a, s)). It follows from (51) that I|σ 6|= Γ+
R (x, a, s), and
I|σ 6|= (Holds(R(x), s) ∧ ¬Γ−
(x,
a,
s)).
From
the
latter,
consider
the
two
subcases.
R
612

Reformulating the Situation Calculus and the Event Calculus

– Subcase 1: I|σ 6|= Holds(R(x), s). Clearly, I satisfies neither LHS nor RHS of
(49), and satisfies both LHS and RHS of (50).
– Subcase 2: I|σ 6|= ¬Γ−
R (x, a, s). Clearly, I satisfies neither LHS nor RHS of (49),
and satisfies both LHS and RHS of (50).

C.7 Proof of Proposition 2
Lemma 5 Let F be a formula, let p be a list of distinct predicate constants, let G be a
subformula of F and let G0 be any formula that is classically equivalent to G. Let F 0 be the
formula obtained from F by substituting G0 for G. If the occurrence of G is in a subformula
of F that is negative on p and the occurrence of G0 is in a subformula of F 0 that is negative
on p, then
SM[F ; p] ↔ SM[F 0 ; p]
is logically valid.
Proof. Let F ¬¬ be the formula obtained from F by prepending ¬¬ to G, and let (F 0 )¬¬
be the formula obtained from F 0 by prepending ¬¬ to G0 . By the Theorem on Double
Negations (Theorem 14), the following formulas are logically valid.
SM[F ; p] ↔ SM[F ¬¬ ; p],
SM[F 0 ; p] ↔ SM[(F 0 )¬¬ ; p].
From Lemma 1, it follows that
(u ≤ p ∧ (G ↔ G0 )) → ((F ¬¬ )∗ (u) ↔ ((F 0 )¬¬ )∗ (u))
is logically valid, where u is a list of predicate variables corresponding to p. Consequently,
SM[F ¬¬ ; p] ↔ SM[(F 0 )¬¬ ; p]
is logically valid.



Proof of Proposition 2. In formula
SM[F 0 ∧ ∀xy(G(y, x) → q(x)); p, q],

(52)

clearly, F 0 is negative on q and ∀xy(G(y, x) → q(x)) is negative on p. Let H be any
subformula of F that is negative on p and contains the occurrence of ∃yG(y, x). Consider
two cases.
• Case 1: the occurrence of ∃yG(y, x) in H is not strictly positive. Thus the dependency
graph of F 0 ∧ ∀xy(G(y, x) → q(x)) relative to {p, q} has no incoming edges into q.
• Case 2: the occurrence of ∃yG(y, x) in H is strictly positive. Since H is negative on p, ∃yG(y, x) is negative on p as well, so that the dependency graph of
F 0 ∧ ∀xy(G(y, x) → q(x)) relative to {p, q} has no outgoing edges from q.
613

Lee & Palla

Therefore, every strongly connected component in the dependency graph belongs to either
p or {q}. Consequently, by Theorem 13, (52) is equivalent to
SM[F 0 ; p] ∧ SM[∀xy(G(y, x) → q(x)); q]

(53)

Since ∃yG(y, x) is negative on q, formula ∀xy(G(y, x) → q(x)) is tight on {q}. By Theorem 15, (53) is equivalent to
SM[F 0 ; p] ∧ ∀x(∃yG(y, x) ↔ q(x)).

(54)

By Lemma 5, it follows that (54) is equivalent to
SM[F ; p] ∧ ∀x(∃yG(y, x) ↔ q(x)).
Consequently, the claim follows.



C.8 Proof of Theorem 6
It is clear that the algorithm terminates and yields a quantifier-free formula K. We will
prove that SM[F ; p] ⇔σ SM[∀xK; p ∪ q], where x is the list of all (free) variables of K.
Let F ¬¬ be the formula obtained from the initial formula F by prepending double
negations in front of every maximal strictly positive occurrence of formulas of the form
∃yG(x, y). Since F is almost universal relative to p, such an occurrence is in a subformula
of F that is negative on p. Thus by the Theorem on Double Negations (Theorem 14),
SM[F ; p] is equivalent to SM[F ¬¬ ; p]. Note that F ¬¬ contains no strictly positive occurrence
of formulas of the form ∃yG(x, y).
For each iteration, let us assume that the formula before the iteration is
H0 ∧ · · · ∧ Hn ,
where H0 is transformed from F ¬¬ by the previous iterations, and each Hi (i > 0) is a
formula of the form G(x, y) → pG (x) that is introduced by Step (b). Initially H0 is F ¬¬
and n = 0. Let r0 be p, and let ri be each pG for Hi (i > 0). By induction we can prove
that
(i) every positive occurrence of formulas of the form ∃yG(x, y) in Hi is not strictly positive, and is in a subformula of Hi that is negative on ri ;
(ii) every negative occurrence of formulas of the form ∀yG(x, y) in Hi is in a subformula
of Hi that is negative on ri .
We will prove that if Step (a) or Step (c) is applied to turn Hk into Hk0 , then
SM[∀x0 H0 ; r0 ] ∧ · · · ∧ SM[∀xn Hn ; rn ]

(55)

SM[∀x00 H00 ; r0 ] ∧ · · · ∧ SM[∀x0n Hn0 ; rn ],

(56)

is equivalent to
where Hj0 = Hj for all j different from k, and xi (i ≥ 0) is the list of all free variables of
Hi , and x0i (i ≥ 0) is the list of all free variables of Hi0 .
614

Reformulating the Situation Calculus and the Event Calculus

Indeed, Step (a) is a part of prenex form conversion, which preserves strong equivalence
(Theorem 5). So it is clear that (55) is equivalent to (56).
When Step (c) is applied to turn (55) into (56), since ∀yH(x, y) is in a subformula of
Hk that is negative on rk , the equivalence between (55) and (56) follows from Lemma 5.
When Step (b) is applied to turn Hk into Hk0 and introduces a new conjunctive term
0
Hn+1 , formula (55) is (σ, r1 , . . . , rn )-equivalent to
0
SM[∀x00 H00 ; r0 ] ∧ · · · ∧ SM[∀x0n Hn0 ; rn ] ∧ SM[∀x0n+1 Hn+1
; rn+1 ]

(57)

by Proposition 2 due to condition (i).
Let
00
H000 ∧ · · · ∧ Hm

(58)

be the final quantifier-free formula, where H000 is transformed from F ¬¬ . By the induction,
it follows that SM[F ; p] is σ-equivalent to
00
SM[∀x000 H000 ; r0 ] ∧ · · · ∧ SM[∀x00m Hm
; rm ],

(59)

where each x00i (0 ≤ i ≤ m) is the list of all free variables of Hi00 .
Since every non-strictly positive occurrence of new predicate ri (i > 0) in any Hj00 (0 ≤
j ≤ m) is positive, there is no incoming edge into ri in the dependency graph of (58) relative
to r0 , r1 , . . . , rm . Consequently, every strongly connected component of the dependency
graph belongs to one of ri (i ≥ 0). Moreover, it is clear that each Hi00 (i ≥ 0) is negative
on every rj for j 6= i. (In the case of H000 , recall that the occurrence of rj for any j > 0
is not strictly positive since F ¬¬ , from which H000 is obtained, contains no strictly positive
occurrence of formulas of the form ∃yG(x, y).) Thus by the splitting theorem (Theorem 13),
formula (59) is equivalent to
00
SM[∀x000 H000 ∧ · · · ∧ ∀x00m Hm
; r0 ∪ · · · ∪ rm ].

(60)


C.9 Proof of Theorem 7
We use the notations introduced in the proof of Theorem 6. By Theorem 6, SM[F ; p] is
σ-equivalent to (60) and, by Theorem 12, (60) is equivalent to
00
SM[∀x000 H000 ∧ · · · ∧ ∀x00m Hm
∧ Choice(σ pred \ p); σ pred ∪ r1 ∪ · · · ∪ rm ]

(61)

(r0 is p), where σ pred is the set of all predicate constants in signature σ. It follows from
Proposition 3 from (Cabalar et al., 2005) that (61) is equivalent to
000
SM[∀x000 H0000 ∧ · · · ∧ ∀x00m Hm
∧ Choice(σ pred \ p); σ pred ∪ r1 ∪ · · · ∪ rm ],

(62)

where Hi000 is obtained from Hi00 by applying the translation from (Cabalar et al., 2005,
Section 3) that turns a quantifier-free formula into a set of rules. It is easy to see that F 0
is the same as the formula
000
∀x000 H0000 ∧ · · · ∧ ∀x00m Hm
∧ Choice(σ pred \ p)

615

Lee & Palla

and σ pred ∪ r1 ∪ · · · ∪ rm is the same as p ∪ pr (F 0 ), so that (62) can be written as
SM[F 0 ; p ∪ pr (F 0 )],
which is equivalent to
SM[F 0 ∧ False(p \ pr (F 0 ))].
by Proposition 1.



C.10 Proof of Theorem 8
Assume that T is
CIRC[Σ; Initiates, Terminates, Releases] ∧ CIRC[∆; Happens]
∧ CIRC[Θ; Ab 1 , . . . , Ab n ] ∧ Ξ,
which is equivalent to
SM[Σ; Initiates, Terminates, Releases] ∧ SM[∆; Happens]
∧ SM[Θ; Ab 1 , . . . , Ab n ] ∧ Ξ

(63)

by Theorem 2.
Let Ξdef be the set of all definitions (35) in Ξ, and let Ξ0 be the formula obtained from Ξ
by applying Step 1. By Theorem 15, it follows that each formula (35) in Ξdef is equivalent
to
SM[∀x(G0 → p(x)); p],
where G0 is as described in Step 1. Consequently, (63) is equivalent to
SM[Σ; Initiates, Terminates,
V Releases] ∧ SM[∆; Happens]
∧ SM[Θ; Ab 1 , . . . , Ab n ] ∧ (35)∈Ξdef SM[∀x(G0 → p(x)); p] ∧ Ξ00 ,

(64)

where Ξ00 is the conjunction of all the axioms in Ξ0 other than the ones obtained from
definitional axioms (35).
Applying Theorem 13 repeatedly, it follows that (64) is equivalent to
V
SM[Σ ∧ ∆ ∧ Θ ∧ Ξ00 ∧ (35)∈Ξdef ∀x(G0 → p(x));
Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n , p] .

(65)

According to the syntax of the event calculus reviewed in Section 3.1,
• every positive occurrence of a formula of the form ∃yG(y) in (65) is contained in a
subformula that is negative on
{Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n , p}, and
• there are no negative occurrences of any formula of the form ∀yG(y) in (65).
Consequently, the statement of the theorem follows from Theorem 7.

616



Reformulating the Situation Calculus and the Event Calculus

C.11 Proof of Theorem 9
Since (37) is almost universal relative to {Caused , Poss, Sit}, the result follows from Theorems 7 and 3.

C.12 Proof of Theorem 10
From Dexogenous0 , it follows that SM[T ; Holds, ∼Holds, Poss] is equivalent to
SM[T ¬¬ ; Holds, ∼ Holds, Poss], where T ¬¬ is obtained from T by prepending ¬¬ to all
occurrences of Holds in DS0 . From the definition of a uniform formula (Reiter, 2001), it
follows that T ¬¬ is almost universal relative to {Holds, ∼Holds, Poss}. The result follows
from Theorem 7.


References
Akman, V., Erdoğan, S., Lee, J., Lifschitz, V., & Turner, H. (2004). Representing the Zoo
World and the Traffic World in the language of the Causal Calculator. Artificial
Intelligence, 153(1–2), 105–140.
Belleghem, K. V., Denecker, M., & Schreye, D. D. (1995). Combining situation calculus
and event calculus. In Proceedings of International Conference on Logic Programming
(ICLP), pp. 83–97.
Belleghem, K. V., Denecker, M., & Schreye, D. D. (1997). On the relation between situation
calculus and event calculus. Journal of Logic Programming, 31 (1-3), 3–37.
Besnard, P., & Cordier, M.-O. (1994). Explanatory diagnoses and their characterization by
circumscription. Annals of Mathematics and Artificial Intelligence, 11 (1-4), 75–96.
Cabalar, P., & Ferraris, P. (2007). Propositional theories are strongly equivalent to logic
programs. Theory and Practice of Logic Programming, 7 (6), 745–759.
Cabalar, P., Pearce, D., & Valverde, A. (2005). Reducing propositional theories in equilibrium logic to logic programs. In Proceedings of Portuguese Conference on Artificial
Intelligence (EPIA), pp. 4–17.
Calimeri, F., Cozza, S., Ianni, G., & Leone, N. (2008). Computable functions in ASP: theory
and implementation. In Proceedings of International Conference on Logic Programming (ICLP), pp. 407–424.
Denecker, M., & Ternovska, E. (2007). Inductive situation calculus. Artificial Intelligence,
171 (5-6), 332–360.
Denecker, M., & Ternovska, E. (2008). A logic of nonmonotone inductive definitions. ACM
Transactions on Computational Logic, 9 (2).
Doherty, P., Gustafsson, J., Karlsson, L., & Kvarnström, J. (1998). TAL: Temporal action
logics language specification and tutorial. Linköping Electronic Articles in Computer
and Information Science ISSN 1401-9841, 3 (015). http://www.ep.liu.se/ea/cis/
1998/015/.
617

Lee & Palla

Doğandağ, S., Ferraris, P., & Lifschitz, V. (2004). Almost definite causal theories.. In
Proceedings of International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR), pp. 74–86.
Erdem, E., & Lifschitz, V. (2003). Tight logic programs. Theory and Practice of Logic
Programming, 3, 499–518.
Fages, F. (1994). Consistency of Clark’s completion and existence of stable models. Journal
of Methods of Logic in Computer Science, 1, 51–60.
Ferraris, P., Lee, J., & Lifschitz, V. (2007). A new perspective on stable models. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 372–379.
Ferraris, P., Lee, J., & Lifschitz, V. (2011). Stable models and circumscription. Artificial
Intelligence, 175, 236–263.
Ferraris, P., Lee, J., Lifschitz, V., & Palla, R. (2009). Symmetric splitting in the general
theory of stable models. In Proceedings of International Joint Conference on Artificial
Intelligence (IJCAI), pp. 797–803.
Gebser, M., Schaub, T., & Thiele, S. (2007). Gringo : A new grounder for answer set
programming. In Proceedings of International Conference on Logic Programming and
Nonmonotonic Reasoning (LPNMR), pp. 266–271.
Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming. In
Kowalski, R., & Bowen, K. (Eds.), Proceedings of International Logic Programming
Conference and Symposium, pp. 1070–1080. MIT Press.
Gelfond, M., & Lifschitz, V. (1998). Action languages. Electronic Transactions on Artificial
Intelligence, 3, 195–210. http://www.ep.liu.se/ea/cis/1998/016/.
Giunchiglia, E., Lee, J., Lifschitz, V., McCain, N., & Turner, H. (2004). Nonmonotonic
causal theories. Artificial Intelligence, 153(1–2), 49–104.
Heyting, A. (1930). Die formalen Regeln der intuitionistischen Logik. Sitzungsberichte
der Preussischen Akademie von Wissenschaften. Physikalisch-mathematische Klasse,
42–56.
Janhunen, T., & Oikarinen, E. (2004). Capturing parallel circumscription with disjunctive
logic programs. In Proc. of 9th European Conference in Logics in Artificial Intelligence
(JELIA-04), pp. 134–146.
Kautz, H., & Selman, B. (1992). Planning as satisfiability. In Proceedings of European
Conference on Artificial Intelligence (ECAI), pp. 359–363.
Kim, T.-W., Lee, J., & Palla, R. (2009). Circumscriptive event calculus as answer set programming. In Proceedings of International Joint Conference on Artificial Intelligence
(IJCAI), pp. 823–829.
Kowalski, R., & Sergot, M. (1986). A logic-based calculus of events. New Generation
Computing, 4, 67–95.
Kowalski, R. A., & Sadri, F. (1997). Reconciling the event calculus with the situation
calculus. Journal of Logic Programming, 31 (1-3), 39–58.
618

Reformulating the Situation Calculus and the Event Calculus

Lee, J., Lifschitz, V., & Palla, R. (2008). A reductive semantics for counting and choice
in answer set programming. In Proceedings of the AAAI Conference on Artificial
Intelligence (AAAI), pp. 472–479.
Lee, J., & Lin, F. (2006). Loop formulas for circumscription. Artificial Intelligence, 170 (2),
160–185.
Lee, J., & Meng, Y. (2011). First-order stable model semantics and first-order loop formulas.
Journal of Artificial Inteligence Research (JAIR), 42, 125–180.
Lee, J., & Palla, R. (2007). Yet another proof of the strong equivalence between propositional
theories and logic programs. In Working Notes of the Workshop on Correspondence
and Equivalence for Nonmonotonic Theories.
Lee, J., & Palla, R. (2010). Situation calculus as answer set programming. In Proceedings
of the AAAI Conference on Artificial Intelligence (AAAI), pp. 309–314.
Lifschitz, V. (1994). Circumscription. In Gabbay, D., Hogger, C., & Robinson, J. (Eds.),
Handbook of Logic in AI and Logic Programming, Vol. 3, pp. 298–352. Oxford University Press.
Lifschitz, V. (2008). What is answer set programming?. In Proceedings of the AAAI Conference on Artificial Intelligence, pp. 1594–1597. MIT Press.
Lifschitz, V. (2011). Datalog programs and their stable models. In de Moor, O., Gottlob,
G., Furche, T., & Sellers, A. (Eds.), Datalog Reloaded: First International Workshop,
Datalog 2010, Oxford, UK, March 16-19, 2010. Revised Selected Papers. Springer.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM
Transactions on Computational Logic, 2, 526–541.
Lifschitz, V., Tang, L. R., & Turner, H. (1999). Nested expressions in logic programs. Annals
of Mathematics and Artificial Intelligence, 25, 369–389.
Lifschitz, V., & Turner, H. (1999). Representing transition systems by logic programs. In
Proceedings of International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR), pp. 92–106.
Lin, F. (1995). Embracing causality in specifying the indirect effects of actions. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 1985–
1991.
Lin, F. (2003). Compiling causal theories to successor state axioms and STRIPS-like systems. Journal of Artificial Intelligence Research, 19, 279–314.
Lin, F., & Shoham, Y. (1992). A logic of knowledge and justified assumptions. Artificial
Intelligence, 57, 271–289.
Lin, F., & Wang, K. (1999). From causal theories to logic programs (sometimes). In
Proceedings of International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR), pp. 117–131.
Lin, F., & Zhou, Y. (2011). From answer set logic programming to circumscription via logic
of GK. Artificial Intelligence, 175, 264–277.
619

Lee & Palla

Marek, V., & Truszczyński, M. (1999). Stable models and an alternative logic programming
paradigm. In The Logic Programming Paradigm: a 25-Year Perspective, pp. 375–398.
Springer Verlag.
McCarthy, J. (1980). Circumscription—a form of non-monotonic reasoning. Artificial Intelligence, 13, 27–39,171–172.
McCarthy, J. (1986). Applications of circumscription to formalizing common sense knowledge. Artificial Intelligence, 26 (3), 89–116.
McCarthy, J., & Hayes, P. (1969). Some philosophical problems from the standpoint of
artificial intelligence. In Meltzer, B., & Michie, D. (Eds.), Machine Intelligence, Vol. 4,
pp. 463–502. Edinburgh University Press, Edinburgh.
Miller, R., & Shanahan, M. (1999). The event calculus in classical logic - alternative axiomatisations. Electronic Transactions on Artificial Intelligence, 3 (A), 77–105.
Mueller, E. (2006). Commonsense reasoning. Morgan Kaufmann.
Mueller, E. T. (2004). Event calculus reasoning through satisfiability. Journal of Logic and
Computation, 14 (5), 703–730.
Niemelä, I. (1999). Logic programs with stable model semantics as a constraint programming
paradigm. Annals of Mathematics and Artificial Intelligence, 25, 241–273.
Pearce, D., & Valverde, A. (2005). A first order nonmonotonic extension of constructive
logic. Studia Logica, 80, 323–348.
Provetti, A. (1996). Hypothetical reasoning about actions: From situation calculus to event
calculus. Computational Intelligence, 12, 478–498.
Reiter, R. (1980). A logic for default reasoning. Artificial Intelligence, 13, 81–132.
Reiter, R. (1991). The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. In Lifschitz, V. (Ed.), Artificial
Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, pp. 359–380. Academic Press.
Reiter, R. (2001). Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems. MIT Press.
Shanahan, M. (1995). A circumscriptive calculus of events. Artif. Intell., 77 (2), 249–284.
Shanahan, M. (1997). Solving the Frame Problem: A Mathematical Investigation of the
Common Sense Law of Inertia. MIT Press.
Shanahan, M. (1999). The event calculus explained. In Artificial Intelligence Today, LNCS
1600, pp. 409–430. Springer.
Shanahan, M., & Witkowski, M. (2004). Event calculus planning through satisfiability.
Journal of Logic and Computation, 14 (5), 731–745.
Syrjänen, T. (2004). Cardinality constraint programs.. In Proceedings of European Conference on Logics in Artificial Intelligence (JELIA), pp. 187–199.
Zhang, H., Zhang, Y., Ying, M., & Zhou, Y. (2011). Translating first-order theories into logic
programs. In Proceedings of International Joint Conference on Artificial Intelligence
(IJCAI), pp. 1126–1131.

620

Proceedings, Fifteenth International Conference on
Principles of Knowledge Representation and Reasoning (KR 2016)

Weighted Rules under the Stable Model Semantics
Joohyung Lee and Yi Wang
School of Computing, Informatics and Decision Systems Engineering
Arizona State University, Tempe, USA
{joolee, ywang485}@asu.edu

It is also interesting that the relationship between Markov
Logic and SAT is analogous to the relationship between
LPMLN and ASP: the way that Markov Logic extends SAT
in a probabilistic way is similar to the way that LPMLN extends ASP in a probabilistic way. This can be summarized
as in the following ﬁgure. (The parallel edges imply that
the ways that the extensions are deﬁned are similar to each
other.)

Abstract
We introduce the concept of weighted rules under the stable
model semantics following the log-linear models of Markov
Logic. This provides versatile methods to overcome the deterministic nature of the stable model semantics, such as resolving inconsistencies in answer set programs, ranking stable models, associating probability to stable models, and
applying statistical inference to computing weighted stable
models. We also present formal comparisons with related
formalisms, such as answer set programs, Markov Logic,
ProbLog, and P-log.

1

Introduction

Logic programs under the stable model semantics (Gelfond
and Lifschitz 1988) is the language of Answer Set Programming (ASP). Many extensions of the stable model semantics have been proposed to incorporate various constructs
in knowledge representation. Some of them are related to
overcoming the “crisp” or deterministic nature of the stable model semantics by ranking stable models using weak
constraints (Buccafurri, Leone, and Rullo 2000), by resolving inconsistencies using Consistency Restoring rules (Balduccini and Gelfond 2003) or possibilistic measure (Bauters
et al. 2010), and by assigning probability to stable models (Baral, Gelfond, and Rushton 2009; Nickles and Mileo
2014).
In this paper, we present an alternative approach by introducing the notion of weights into the stable model semantics following the log-linear models of Markov Logic
(Richardson and Domingos 2006), a successful approach to
combining ﬁrst-order logic and probabilistic graphical models. Instead of the concept of classical models adopted in
Markov Logic, language LPMLN adopts stable models as
the logical component. The relationship between LPMLN
and Markov Logic is analogous to the known relationship
between ASP and SAT. Indeed, many technical results about
the relationship between SAT and ASP naturally carry over
between LPMLN and Markov Logic. In particular, an implementation of Markov Logic can be used to compute “tight”
LPMLN programs, similar to the way “tight” ASP programs
can be computed by SAT solvers.

$63

/30/1

6$7

0/1

Weighted rules of LPMLN provides a way to resolve inconsistencies among ASP knowledge bases, possibly obtained from different sources with different certainty levels.
For example, consider the simple ASP knowledge base KB1 :
Bird(x)
Bird(x)

← ResidentBird(x)
← MigratoryBird(x)
← ResidentBird(x), MigratoryBird(x).

One data source KB2 (possibly acquired by some information extraction module) says that Jo is a ResidentBird:
ResidentBird(Jo)
while another data source KB3 states that Jo is a
MigratoryBird:
MigratoryBird(Jo).
The data about Jo is actually inconsistent w.r.t. KB1 , so under the (deterministic) stable model semantics, the combined
knowledge base KB = KB1 ∪ KB2 ∪ KB3 is not so meaningful. On the other hand, it is still intuitive to conclude
that Jo is likely a Bird, and may be a ResidentBird or a
MigratoryBird. Such reasoning is supported in LPMLN .
Under some reasonable assumption, normalized weights
of stable models can be understood as probabilities of the
stable models. We show that ProbLog (De Raedt, Kimmig,
and Toivonen 2007; Fierens et al. 2015) can be viewed as a
special case of LPMLN . Furthermore, we present a subset of
LPMLN where probability is naturally expressed and show
how it captures a meaningful fragment of P-log (Baral, Gelfond, and Rushton 2009). In combination of the result that

c 2016, Association for the Advancement of Artiﬁcial
Copyright 
Intelligence (www.aaai.org). All rights reserved.

145

relates LPMLN to Markov Logic, the translation from P-log
to LPMLN yields an alternative, more scalable method for
computing the fragment of P-log using standard implementations of Markov Logic.
The paper is organized as follows. After reviewing the
deterministic stable model semantics, we deﬁne the language LPMLN and demonstrate how it can be used for resolving inconsistencies. Then we relate LPMLN to each of
ASP, Markov Logic, and ProbLog, and deﬁne a fragment of
LPMLN language that allows probability to be represented in
a more natural way. Next we show how a fragment of P-log
can be turned into that fragment of LPMLN , and demonstrate
the effectiveness of the translation-based computation of the
P-log fragment over the existing implementation of P-log.
This paper is an extended version of (Lee and Wang 2015;
Lee, Meng, and Wang 2015). The proofs are available from
the longer version at http://reasoning.eas.asu.edu/papers/
lpmln-kr-long.pdf.

2

3

Language LPMLN

Syntax of LPMLN
The syntax of LPMLN deﬁnes a set of weighted rules. More
precisely, an LPMLN program Π is a ﬁnite set of weighted
rules w : R, where R is a rule of the form (1) and w is
either a real number or the symbol α denoting the “inﬁnite
weight.” We call rule w : R soft rule if w is a real number,
and hard rule if w is α.
We say that an LPMLN program is ground if its rules contain no variables. We identify any LPMLN program Π of
signature σ with a ground LPMLN program grσ [Π], whose
rules are obtained from the rules of Π by replacing every
variable with every ground term of σ. The weight of a
ground rule in grσ [Π] is the same as the weight of the rule
in Π from which the ground rule is obtained. By Π we denote the unweighted logic program obtained from Π, i.e.,
Π = {R | w : R ∈ Π}.

Review: Stable Model Semantics

Semantics of LPMLN

We assume a ﬁrst-order signature σ that contains no function constants of positive arity, which yields ﬁnitely many
Herbrand interpretations.
We say that a formula is negative if every occurrence of
every atom in this formula is in the scope of negation.
A rule is of the form
A←B∧N
(1)
where A is a disjunction of atoms, B is a conjunction of
atoms, and N is a negative formula constructed from atoms
using conjunction, disjunction and negation. We identify
rule (1) with formula B ∧ N → A. We often use comma
for conjunction, semi-colon for disjunction, not for negation, as widely used in the literature on logic programming.
For example, N could be
¬Bm+1 ∧. . .∧¬Bn ∧¬¬Bn+1 ∧. . .∧¬¬Bp ,
which can be also written as
not Bm+1 , . . . , not Bn , not not Bn+1 , . . . , not not Bp .
We write {A1 }ch ← Body, where A1 is an atom, to denote
the rule A1 ← Body ∧ ¬¬A1 . This expression is called a
“choice rule” in ASP. If the head of a rule (A in (1)) is ⊥,
we often omit it and call such a rule constraint.
A logic program is a ﬁnite conjunction of rules. A logic
program is called ground if it contains no variables.
We say that an Herbrand interpretation I is a model of
a ground program Π if I satisﬁes all implications (1) in Π
(as in classical logic). Such models can be divided into two
groups: “stable” and “non-stable” models, which are distinguished as follows. The reduct of Π relative to I, denoted
ΠI , consists of “A ← B” for all rules (1) in Π such that
I |= N . The Herbrand interpretation I is called a (deterministic) stable model of Π if I is a minimal Herbrand model
of ΠI . (Minimality is understood in terms of set inclusion.
We identify an Herbrand interpretation with the set of atoms
that are true in it.)
The deﬁnition is extended to any non-ground program Π
by identifying it with grσ [Π], the ground program obtained
from Π by replacing every variable with every ground term
of σ.

A model of a Markov Logic Network (MLN) does not have
to satisfy all formulas in the MLN. For each model, there is
a unique maximal subset of the formulas that are satisﬁed
by the model, and the weights of the formulas in that subset
determine the probability of the model.
Likewise, a stable model of an LPMLN program does not
have to be obtained from the whole program. Instead, each
stable model is obtained from some subset of the program,
and the weights of the rules in that subset determine the
probability of the stable model. Unlike MLNs, it may not
seem obvious if there is a unique maximal subset that derives such a stable model. The following proposition tells us
that this is indeed the case, and furthermore that the subset
is exactly the set of all rules that are satisﬁed by I.
Proposition 1 For any (unweighted) logic program Π and
any subset Π of Π, if I is a stable model of Π and I satisﬁes Π, then I is a stable model of Π as well.
The proposition tells us that if I is a stable model of a
program, adding more rules to this program does not affect
that I is a stable model of the resulting program as long as I
satisﬁes the rules added. On the other hand, it is clear that I
is no longer a stable model if I does not satisfy at least one
of the rules added.
For any LPMLN program Π, by ΠI we denote the set of
rules w : R in Π such that I |= R, and by SM[Π] we denote
the set {I | I is a stable model of ΠI }. We deﬁne the unnormalized weight of an interpretation I under Π, denoted
WΠ (I), as


⎧
⎪

⎨
exp
w
if I ∈ SM[Π];
WΠ (I) =
w:R ∈ ΠI
⎪
⎩
0
otherwise.
Notice that SM[Π] is never empty because it always contains ∅. It is easy to check that ∅ always satisﬁes Π∅ , and it
is the smallest set that satisﬁes the reduct (Π∅ )∅ .

146

The normalized weight of an interpretation I under Π, denoted PΠ (I), is deﬁned as
PΠ (I) = lim 
α→∞

Examples
The weight scheme of LPMLN provides a simple but effective way to resolve certain inconsistencies in ASP programs.

WΠ (I)
.
J∈SM[Π] WΠ (J)

Example 1 The example in the introduction can be represented in LPMLN as

It is easy to check that normalized weights satisfy the Kolmogorov axioms of probability. So we also call them probabilities.
We omit the subscript Π if the context is clear. We say
that I is a (probabilistic) stable model of Π if PΠ (I) 	= 0.
The intuition here is similar to that of Markov Logic.
For each interpretation I, we try to ﬁnd a maximal subset
(possibly empty) of Π for which I is a stable model (under the standard stable model semantics). In other words,
the LPMLN semantics is similar to the MLN semantics except that the possible worlds are the stable models of some
maximal subset of Π, and the probability distribution is over
these stable models. Intuitively, PΠ (I) indicates how likely
to draw I as a stable model of some maximal subset of Π.
For any proposition A, PΠ (A) is deﬁned as
	
PΠ (A) =
PΠ (I).

KB1

KB2
KB3

I
∅
{R(Jo)}
{M (Jo)}
{B(Jo)}
{R(Jo), B(Jo)}
{M (Jo), B(Jo)}
{R(Jo), M (Jo)}
{R(Jo), M (Jo), B(Jo)}

WΠ (I) =

⎪
⎩

exp

w

w:R ∈ (Πsoft )I

0

if I ∈ SM [Π];
otherwise,

PΠ (I)

=



.

J∈SM [Π] WΠ (J)

α→∞

2:

ResidentBird(Jo)

(r4 )

KB3

1:

MigratoryBird(Jo)

(r5 )

I

ΠI

WΠ (I)

∅

{r1 , r2 , r3 }

e3α

{R(Jo)}
{M (Jo)}
{B(Jo)}

{r2 , r3 , r4 }
{r1 , r3 , r5 }
{r1 , r2 , r3 }

e2α+2
e2α+1
0

{R(Jo), B(Jo)}

{r1 , r2 , r3 , r4 }

e3α+2

{M (Jo), B(Jo)}

{r1 , r2 , r3 , r5 }
{r4 , r5 }
{r1 , r2 , r4 , r5 }

3α+1

{R(Jo), M (Jo)}
{R(Jo), M (Jo), B(Jo)}

WΠ (I)

Notice the absence of lim in the deﬁnition of

KB2

Then the table changes as follows.





PΠ [I].

PΠ (I)
0
0
0
0
1/3
1/3
0
1/3

Instead of α, one can assign different certainty levels to
the additional knowledge bases, such as

{I | I is a stable model of ΠI that satisfy Πhard },


WΠ (I)
e3α
e3α
e3α
0
e4α
e4α
e2α
e4α

ΠI
{r1 , r2 , r3 }
{r2 , r3 , r4 }
{r1 , r3 , r5 }
{r1 , r2 , r3 }
{r1 , r2 , r3 , r4 }
{r1 , r2 , r3 , r5 }
{r4 , r5 }
{r1 , r2 , r4 , r5 }

• P (Bird(Jo)) = 1/3 + 1/3 + 1/3 = 1.
• P (Bird(Jo) | ResidentBird(Jo)) = 1.
• P (ResidentBird(Jo) | Bird(Jo)) = 2/3.

PΠ (A ∧ B)
.
PΠ (B)

Often we are interested in stable models that satisfy all
hard rules (hard rules encode deﬁnite knowledge), in which
case the probabilities of stable models can be computed from
the weights of the soft rules only, as described below.
For any LPMLN program Π, by Πsoft we denote the set
of all soft rules in Π, and by Πhard the set of all hard rules
in Π. Let SM [Π] be the set

⎧
⎪
⎨

(r1)
(r2)
(r3)
(r4)
(r5)

(The weight of I = {Bird(Jo)} is 0 because I is not a stable
model of ΠI .) Thus we can check that

Conditional probability under Π is deﬁned as usual. For
propositions A and B,

and let

Bird(x) ← ResidentBird(x)
Bird(x) ← MigratoryBird(x)
← ResidentBird(x), MigratoryBird(x)
ResidentBird(Jo)
MigratoryBird(Jo)

Assuming that the Herbrand universe is {Jo}, the following table shows the weight and the probability of each interpretation.

I: I|=A

PΠ (A | B) =

α:
α:
α:
α:
α:

e

e3
e2α+3

PΠ (I)

e0
e2 +e1 +e0

0
0
0

e2
e2 +e1 +e0
e1
e2 +e1 +e0

0
0

P (Bird(Jo)) = (e2 + e1 )/(e2 + e1 + e0 ) = 0.67 + 0.24, so
it becomes less certain, though it is still a high chance that
we can conclude that Jo is a Bird.
Notice that the weight changes not only affect the probability, but also the stable models (having non-zero probabilities) themselves: Instead of {R(Jo), M (Jo), B(Jo)}, the
empty set is a stable model of the new program.

Also,

unlike PΠ (I), SM [Π] may be empty, in which case PΠ (I)
is not deﬁned. Otherwise, the following proposition tells us
that the probability of an interpretation can be computed by
considering the weights of the soft rules only.
Proposition 2 If SM [Π] is not empty, for every interpretation I, PΠ (I) coincides with PΠ (I).

Assigning a different certainty level to each rule affects
the probability associated with each stable model, representing how certain we can derive the stable model from the
knowledge base. This could be useful as more incoming
data reinforces the certainty levels of the information.

It follows from this proposition that if SM [Π] is not
empty, then every stable model of Π (with non-zero probability) should satisfy all hard rules in Π.

147

Weak Constraints and LPMLN

Remark. In some sense, the distinction between soft
rules and hard rules in LPMLN is similar to the distinction CR-Prolog (Balduccini and Gelfond 2003) makes between consistency-restoring rules (CR-rules) and standard
ASP rules: some CR-rules are added to the standard ASP
program part until the resulting program has a stable model.
On the other hand, CR-Prolog has little to say when the ASP
program has no stable models no matter what CR-rules are
added (c.f. Example 1).

The idea of softening rules in LPMLN is similar to the
idea of weak constraints in ASP, which is used for certain
optimization problems. A weak constraint has the form
“ :∼ Body [Weight : Level].” The stable models of a program Π (whose rules have the form (1)) plus a set of weak
constraints are the stable models of Π with the minimum
penalty, where a penalty is calculated from Weight and Level
of violated weak constraints.
Since levels can be compiled into weights (Buccafurri,
Leone, and Rullo 2000), we consider weak constraints of
the form
:∼ Body [Weight]
(2)
where Weight is a positive integer. We assume all weak constraints are grounded. The penalty of a stable model is deﬁned as the sum of the weights of all weak constraints whose
bodies are satisﬁed by the stable model.
Such a program can be turned into an LPMLN program as
follows. Each weak constraint (2) is turned into

Example 2 “Markov Logic has the drawback that it cannot
express (non-ground) inductive deﬁnitions” (Fierens et al.
2015) because it relies on classical models. This is not the
case with LPMLN . For instance, consider that x may inﬂuence y if x is a friend to y, and the inﬂuence relation is a
minimal relation that is closed under transitivity.
α : Friend(A, B)
α : Friend(B, C)
1 : Inﬂuence(x, y) ← Friend(x, y)
α : Inﬂuence(x, y) ← Inﬂuence(x, z), Inﬂuence(z, y).

−w : ⊥ ← ¬Body.

Note that the third rule is soft: a person does not necessarily
inﬂuence his/her friend. The fourth rule says if x inﬂuences
z, and z inﬂuences y, we can say x inﬂuences y. On the other
hand, we do not want this relation to be vacuously true.
Assuming that there are only three people A, B, C in the
domain (thus there are 1+1+9+27 ground rules), there are
four stable models with non-zero probabilities. Let Z = e9 +
2e8 + e7 . (Fr abbreviates for Friend and Inf for Inﬂuence)

The standard ASP rules are identiﬁed with hard rules in
LPMLN . For example, the program with weak constraints
a∨b
c←b
is turned into
α: a∨b
α: c←b

• I1 = {Fr(A, B), Fr(B, C), Inf (A, B), Inf (B, C),
Inf (A, C)} with probability e9 /Z.
• I2 = {Fr(A, B), Fr(B, C), Inf (A, B)} with probability
e8 /Z.
• I3 = {Fr(A, B), Fr(B, C), Inf (B, C)} with probability
e8 /Z.
• I4 = {Fr(A, B), Fr(B, C)} with probability e7 /Z.

−1 :
−1 :
−1 :

⊥ ← ¬a
⊥ ← ¬b
⊥ ← ¬c.

The LPMLN program has two stable models: {a} with the
−1
normalized weight e−1e+e−2 and {b, c} with the normalized
−2

weight e−1e+e−2 . The former, with the larger normalized
weight, is the stable model of the original program containing the weak constraints.

Thus we get

Proposition 3 For any program with weak constraints that
has a stable model, its stable models are the same as the
stable models of the corresponding LPMLN program with
the highest normalized weight.

• P (Inf (A, B)) = P (Inf (B, C)) = (e9 +e8 )/Z = 0.7311.
• P (Inf (A, C)) = e9 /Z = 0.5344.
Increasing the weight of the third rule yields higher probabilities for deriving Inﬂuence(A, B), Inﬂuence(B, C), and
Inﬂuence(A, C). Still, the ﬁrst two have the same probability, and the third has less probability than the ﬁrst two.

4

:∼ a [1]
:∼ b [1]
:∼ c [1]

5

Relating LPMLN to MLNs

Embedding MLNs in LPMLN

Relating LPMLN to ASP

Similar to the way that SAT can be embedded in ASP,
Markov Logic can be easily embedded in LPMLN . More
precisely, any MLN L can be turned into an LPMLN program ΠL so that the models of L coincide with the stable
models of ΠL while retaining the same probability distribution.
LPMLN program ΠL is obtained from L by turning each
weighted formula w : F into weighted rule w : ⊥ ← ¬F
and adding
w : {A}ch
for every ground atom A of σ and any weight w. The effect
of adding the choice rules is to exempt A from minimization
under the stable model semantics.

Any logic program under the stable model semantics can
be turned into an LPMLN program by assigning the inﬁnite weight to every rule. That is, for any logic program
Π = {R1 , . . . , Rn }, the corresponding LPMLN program PΠ
is {α : R1 , . . . , α : Rn }.
Theorem 1 For any logic program Π, the (deterministic)
stable models of Π are exactly the (probabilistic) stable
models of PΠ whose weight is ekα , where k is the number of
all (ground) rules in Π. If Π has at least one stable model,
then all stable models of PΠ have the same probability, and
are thus the stable models of Π as well.

148

Theorem 2 Any MLN L and its LPMLN representation ΠL
have the same probability distribution over all interpretations.

In ProbLog, ground atoms over σ are divided into two
groups: probabilistic atoms and derived atoms. A (ground)
ProbLog program P is a tuple PF, Π
, where
• PF is a set of ground probabilistic facts of the form
pr :: a,
• Π is a set of ground rules of the following form
A ← B1 , . . . , Bm , not Bm+1 , . . . , not Bn
where A, B1 , . . . Bn are atoms from σ (0 ≤ m ≤ n), and
A is not a probabilistic atom.
Probabilistic atoms act as random variables and are assumed to be independent from each other. A total choice TC
is any subset of the probabilistic atoms. Given a total choice
TC = {a1 , . . . , am }, the probability of a total choice TC,
denoted PrP (TC), is deﬁned as
pr(a1 )×. . .×pr(am )×(1−pr(b1 ))×. . .×(1−pr(bn ))
where b1 , . . . , bn are probabilistic atoms not belonging
to TC, and each of pr(ai ) and pr(bj ) is the probability assigned to ai and bj according to the set PF of ground probabilistic atoms.
The ProbLog semantics is only well-deﬁned for programs
P = PF, Π
 such that Π ∪ TC has a “total” (two-valued)
well-founded model for each total choice TC. Given such
P, the probability of an interpretation I, denoted PP (I), is
deﬁned as PrP (TC) if there exists a total choice TC such that
I is the total well-founded model of Π∪TC, and 0 otherwise.

The embedding tells us that the exact inference in LPMLN
is at least as hard as the one in MLNs, which is #P-hard.
In fact, it is easy to see that when all rules in LPMLN are
non-disjunctive, counting the stable models of LPMLN is in
#P, which yields that the exact inference for non-disjunctive
LPMLN programs is #P-complete. Therefore, approximation algorithms, such as Gibbs sampling, may be desirable
for computing large LPMLN programs. The next section
tells us that we can apply the MLN approximation algorithms to computing LPMLN based on the reduction of the
latter to the former.

Completion: Turning LPMLN to MLN
It is known that the stable models of a tight logic program
coincide with the models of the program’s completion (Erdem and Lifschitz 2003). This yielded a way to compute stable models using SAT solvers. The method can be extended
to LPMLN so that probability queries involving the stable
models can be computed using existing implementations
of MLNs, such as Alchemy (http://alchemy.cs.washington.
edu).
We deﬁne the completion of Π, denoted Comp(Π), to be
the MLN which is the union of Π and the hard formula


α: A→

w:A1 ∨···∨Ak ←Body∈ Π
A∈{A1 ,...,Ak }


Body∧



¬A



ProbLog as a Special Case of LPMLN



Given a ProbLog program P = PF, Π
, we construct the
corresponding LPMLN program P as follows:
• For each probabilistic fact pr :: a in P, LPMLN program
P contains (i) ln(pr) : a and ln(1−pr) : ← a if 0 <
pr < 1; (ii) α : a if pr = 1; (iii) α : ← a if pr = 0.
• For each rule R ∈ Π, P contains α : R. In other words,
R is identiﬁed with a hard rule in P .
Theorem 4 Any well-deﬁned ProbLog program P and its
LPMLN representation P have the same probability distribution over all interpretations.
Example 3 Consider the ProbLog program
0.6 :: p
r←p
0.3 :: q
r←q

A ∈{A1 ,...,Ak }\{A}

for each ground atom A.
This is a straightforward extension of the completion
from (Lee and Lifschitz 2003) by simply assigning the inﬁnite weight α to the completion formulas. Likewise, we
say that LPMLN program Π is tight if Π is tight according to
(Lee and Lifschitz 2003), i.e., the positive dependency graph
of Π is acyclic.
Theorem 3 For any tight LPMLN program Π such that
SM [Π] is not empty, Π (under the LPMLN semantics) and
Comp(Π) (under the MLN semantics) have the same probability distribution over all interpretations.

which can be identiﬁed with the LPMLN program
ln(0.6) : p
ln(0.3) : q
α: r←p
ln(0.4) : ← p
ln(0.7) : ← q
α: r←q

The theorem can be generalized to non-tight programs by
considering loop formulas (Lin and Zhao 2004), which we
skip here for brevity.

6

Syntactically, LPMLN allows more general rules than
ProbLog, such as disjunctions in the head, as well as
the empty head and double negations in the body. Further, LPMLN allows rules to be weighted as well as facts,
and do not distinguish between probabilistic facts and derived atoms. Semantically, while the ProbLog semantics
is based on well-founded models, LPMLN handles stable
model reasoning for more general classes of programs. Unlike ProbLog which is only well-deﬁned when each total
choice leads to a unique well-founded model, LPMLN can
handle multiple stable models in a ﬂexible way similar to
the way MLN handles multiple models.

Relation to ProbLog

It turns out that LPMLN is a proper generalization of
ProbLog, a well-developed probabilistic logic programming
language that is based on the distribution semantics by
Sato (1995).

Review: ProbLog
The review follows (Fierens et al. 2015). As before, we
identify a non-ground ProbLog program with its ground instance. So for simplicity we restrict attention to ground
ProbLog programs only.

149

7

is understood as shorthand for the LPMLN program

Multi-Valued Probabilistic Programs

In this section we deﬁne a simple fragment of LPMLN that
allows us to represent probability in a more natural way.
For simplicity of the presentation, we will assume a propositional signature. An extension to ﬁrst-order signatures is
straightforward.
We assume that the propositional signature σ is constructed from “constants” and their “values.” A constant c is
a symbol that is associated with a ﬁnite set Dom(c), called
the domain. The signature σ is constructed from a ﬁnite set
of constants, consisting of atoms c = v 1 for every constant c
and every element v in Dom(c). If the domain of c is {f, t}
then we say that c is Boolean, and abbreviate c = t as c and
c = f as ∼c.
We assume that constants are divided into probabilistic
constants and regular constants. A multi-valued probabilistic program Π is a tuple PF, Π
, where
• PF contains probabilistic constant declarations of the following form:
(3)
p 1 : c = v 1 | · · · | pn : c = v n
one for each probabilistic constant c, where
. . . , vn } = Dom(c), vi 	= vj , 0 ≤ p1 , . . . , pn ≤ 1
{v1 , 
n
and i=1 pi = 1. We use MΠ (c = vi ) to denote pi .
In other words, PF describes the probability distribution
over each “random variable” c.
• Π is a set of rules of the form (1) such that A contains no
probabilistic constants.
The semantics of such a program Π is deﬁned as a shorthand for LPMLN program T (Π) of the same signature as
follows.
• For each probabilistic constant declaration (3), T (Π) contains, for each i = 1, . . . , n, (i) ln(pi ) : c = vi if
0 < pi < 1; (ii) α : c = vi if pi = 1; (iii) α : ← c = vi if
pi = 0.
• For each rule in Π of form (1), T (Π) contains
α : A ← B, N.

ln(0.25) : Outcome = 6
ln(0.15) : Outcome = i
(i = 1, . . . , 5)
α : W in ← Outcome = 6
α : ⊥ ← Outcome
= i ∧ Outcome = j (i 	= j)


α : ⊥ ← ¬ i=1,...6 Outcome = i.
We say an interpretation of Π is consistent if it satisﬁes
the hard rules (4) for every constant and (5) for every
probabilistic constant.
For any consistent interpretation I, we deﬁne the set TC(I) (“Total Choice”) to be
{c = v | c is a probabilistic constant such that c = v ∈ I}
and deﬁne
SM [Π] = {I | I is consistent
and is a stable model of Π ∪ TC(I)}.
For any interpretation I, we deﬁne
⎧

⎨
MΠ (c = v)

WΠ
(I) = c = v ∈ T C(I)
⎩0
and

(I) = 
PΠ

if I ∈ SM [Π]
otherwise


(I)
WΠ
.

J∈SM  [Π] WΠ (J)

The following proposition tells us that the probability of
an interpretation can be computed from the probabilities assigned to probabilistic atoms, similar to the way ProbLog is
deﬁned.
Proposition 4 For any multi-valued probabilistic program Π such that each pi in (3) is positive for every probabilistic constant c, if SM [Π] is not empty, then for any

(I) coincides with PT (Π) (I).
interpretation I, PΠ

8

P-log and LPMLN

Simple P-log
In this section, we deﬁne a fragment of P-log, which we call
simple P-log.

• For each constant c, T (Π) contains the uniqueness of
value constraints
α : ⊥ ← c = v1 ∧ c = v2
(4)
for all v1 , v2 ∈ Dom(c) such that v1 	= v2 . For each
probabilistic constant c, T (Π) also contains the existence
of value constraint


α: ⊥←¬
c=v .
(5)

Syntax Let σ be a multi-valued propositional signature as
in the previous section. A simple P-log program Π is a tuple
Π = R, S, P, Obs, Act

(6)

where
• R is a set of normal rules of the form
A ← B1 , . . . , Bm , not Bm+1 , . . . , not Bn .

v∈Dom(c)

(7)

Here and after we assume A, B1 , . . . , Bn are atoms
from σ (0 ≤ m ≤ n).
• S is a set of random selection rules of the form

This means that a regular constant may be undeﬁned (i.e.,
have no values associated with it), while a probabilistic
constant is always associated with some value.
Example 4 The multi-valued probabilistic program
0.25 : Outcome = 6 | 0.15 : Outcome = 5
| 0.15 : Outcome = 4 | 0.15 : Outcome = 3
| 0.15 : Outcome = 2 | 0.15 : Outcome = 1
W in ← Outcome = 6.

[r] random(c) ← B1 , . . . , Bm , not Bm+1 , . . . , not Bn
(8)
where r is an identiﬁer and c is a constant.
• P is a set of probability atoms (pr-atoms) of the form
prr (c = v | B1 , . . . , Bm , not Bm+1 , . . . , not Bn ) = p
where r is the identiﬁer of some random selection rule
in S, c is a constant, and v ∈ Dom(c), and p ∈ [0, 1].

1
Note that here “=” is just a part of the symbol for propositional
atoms, and is not equality in ﬁrst-order logic.

150

• Obs is a set of atomic facts of the form Obs(c = v) where
c is a constant and v ∈ Dom(c).
• Act is a set of atomic facts of the form Do(c = v) where
c is a constant and v ∈ Dom(c).

atom c = v, we say c = v is possible in W with respect to Π
if Π contains a random selection rule for c
[r] random(c) ← B,
where B is a set of atoms possibly preceded with not, and
W satisﬁes B. We say r is applied in W if W |= B.
We say that a pr-atom prr (c = v | B) = p is applied in W
if W |= B and r is applied in W .
As in (Baral, Gelfond, and Rushton 2009), we assume that
simple P-log programs Π satisfy the following conditions:

Example 5 We use the following simple P-log program as
our main example (d ∈ {D1 , D2 }, y ∈ {1, . . . 6}):
Owner(D1 ) = Mike
Owner(D2 ) = John
Even(d) ← Roll(d) = y, y mod 2 = 0
∼Even(d) ← not Even(d)
[r(d)] random(Roll(d))
pr(Roll(d) = 6 | Owner(d) = Mike) = 14 .

• Unique random selection rule For any constant c, program Π contains at most one random selection rule for c
that is applied in W .
• Unique probability assignment If Π contains a random
selection rule r for constant c that is applied in W , then,
for any two different probability atoms

Semantics Given a simple P-log program Π of the
form (6), a (standard) ASP program τ (Π) with the multivalued signature σ  is constructed as follows:

prr (c = v1 | B  ) = p1
prr (c = v2 | B  ) = p2

• σ  contains all atoms in σ, and atom Intervene(c) = t (abbreviated as Intervene(c)) for every constant c of σ; the
domain of Intervene(c) is {t}.
• τ (Π) contains all rules in R.
• For each random selection rule of the form (8) with
Dom(c) = {v1 , . . . , vn }, τ (Π) contains the following
rules:
c = v1 ; . . . ; c = vn ←
B1 , . . . , Bm , not Bm+1 , . . . , not Bn , not Intervene(c).

in Π that are applied in W , we have v1 	= v2 and
B  = B  .
Given a simple P-log program Π, a possible world W ∈
ω(Π) and a constant c for which c = v is possible in W , we
ﬁrst deﬁne the following notations:
• Since c = v is possible in W , by the unique random selection rule assumption, it follows that there is exactly one
random selection rule r for constant c that is applied in W .
Let rW,c denote this random selection rule. By the unique
probability assignment assumption, if there are pr-atoms
of the form prrW,c (c = v | B) that are applied in W , all B
in those pr-atoms should be the same. We denote this B
by BW,c . Deﬁne PRW (c) as

• τ (Π) contains all atomic facts in Obs and Act.
• For every atom c = v in σ,
← Obs(c = v), not c = v.
• For every atom c = v in σ, τ (Π) contains

{prrW,c (c = v | BW,c ) = p ∈ Π | v ∈ Dom(c)}.

c = v ← Do(c = v)
Intervene(c) ← Do(c = v).

if W 	|= Intervene(c) and ∅ otherwise.
• Deﬁne AVW (c) as


v | prrW,c (c = v | BW,c ) = p ∈ PRW (c) .

Example 5 continued The following is τ (Π) for the simple P-log program Π in Example 5 (x ∈ {Mike, John},
b ∈ {t, f}):

• For each v ∈ AVW (c), deﬁne the assigned probability of
c = v w.r.t. W , denoted by apW (c = v), as the value p for
which prrW,c (c = v | BW,c ) = p ∈ PRW (c).
• Deﬁne the default probability for c w.r.t. W , denoted by
dpW (c), as

1 − v∈AVW (c) apW (c = v)
dpW (c) =
.
|Dom(c) \ AVW (c)|

Owner(D1 ) = Mike
Owner(D2 ) = John
Even(d) ← Roll(d) = y, y mod 2 = 0
∼Even(d) ← not Even(d)
Roll(d) = 1; Roll(d) = 2; Roll(d) = 3; Roll(d) = 4;
Roll(d) = 5; Roll(d) = 6 ← not Intervene(Roll(d))
← Obs(Owner(d) = x), not Owner(d) = x
← Obs(Even(d) = b), not Even(d) = b
← Obs(Roll(d) = y), not Roll(d) = y
Owner(d) = x ← Do(Owner(d) = x)
Even(d) = b ← Do(Even(d) = b)
Roll(d) = y ← Do(Roll(d) = y)
Intervene(Owner(d)) ← Do(Owner(d) = x)
Intervene(Even(d)) ← Do(Even(d) = b)
Intervene(Roll(d)) ← Do(Roll(d) = y).

For every possible world W ∈ ω(Π) and every atom c = v
possible in W , the causal probability P (W, c = v) is deﬁned
as follows:

apW (c = v) if v ∈ AVW (c)
P (W, c = v) =
otherwise.
dpW (c)
The unnormalized probability of a possible world W , denoted by μ̂Π (W ), is deﬁned as

P (W, c = v).
μ̂Π (W ) =

The stable models of τ (Π) are called the possible worlds
of Π, and denoted by ω(Π). For an interpretation W and an

c=v∈W and
c=v is possible in W

151

Assuming Π has at least one possible world with nonzero
unnormalized probability, the normalized probability of W ,
denoted by μΠ (W ), is deﬁned as
μΠ (W ) = 

• We deﬁne the default probability for c w.r.t. B and r,
denoted by dpB,r (c), as

1 − v∈AVB,r (c) apB,r (c = v)
.
dpB,r (c) =
|Dom(c) \ AVB,r (c)|

μ̂Π (W )
.
Wi ∈ω(Π) μ̂Π (Wi )

• For each c ∈ v, deﬁne its causal probability w.r.t. B and
r, denoted by P (B, r, c = v), as

apB,r (c = v) if v ∈ AVB,r (c)
P (B, r, c = v) =
otherwise.
dpB,r (c)

Given a simple P-log program Π and a formula A, the
probability of A with respect to Π is deﬁned as
	
μΠ (W ).
PΠ (A) =
W is a possible world of Π that satisﬁes A

Now we translate Π into the corresponding multi-valued
MLN
as follows:
probabilistic program ΠLP

We say Π is consistent if Π has at least one possible world.
Example 5 continued Given the possible world W =
{Owner(D1 ) = Mike, Owner(D2 ) = John, Roll(D1 ) = 6,
Roll(D2 ) = 3, Even(D1 )}, the probability of Roll(D1 ) = 6 is
P (W, Roll(D1 ) = 6) = 0.25, the probability of Roll(D2 ) =
3 is 16 . The unnormalized probability of W , i.e., μ̂(W ) =
1
.
P (W, Roll(D1 ) = 6) · P (W, Roll(D2 ) = 3) = 24
The main differences between simple P-log and P-log are
as follows.
• The unique probability assignment assumption in P-log is
more general: it does not require the part B  = B  . However, all the examples in the P-log paper (Baral, Gelfond,
and Rushton 2009) satisfy our stronger unique probability
assignment assumption.
• P-log allows a more general random selection rule of the
form
[r] random(c : {x : P (x)}) ← B  .
Among the examples in (Baral, Gelfond, and Rushton
2009), only the “Monty Hall Problem” encoding and the
“Moving Robot Problem” encoding use “dynamic range
{x : P (x)}” in random selection rules and cannot be represented as simple P-log programs.

• The signature of ΠLP


σ ∪

is

| PRB,r (c) 	= ∅ and v ∈ Dom(c)}

| r is a random selection rule of Π for c
and v ∈ Dom(c)}
∪ {Assignedr = t | r is a random selection rule of Π}.

∪

MLN

• ΠLP
contains all rules in τ (Π).
• For any constant c, any random selection rule r for c, and
any set B of literals such that PRB,r (c) 	= ∅, include in
MLN
ΠLP
:
– the probabilistic constant declaration:
c
P (B, r, c = v1 ) : pfB,r
= v1 | . . .
c
| P (B, r, c = vn ) : pfB,r
= vn
c
for each probabilistic constant pfB,r
of the signature,
c
is
where {v1 , . . . , vn } = Dom(c). The constant pfB,r
used for representing the probability distribution for c
when condition B holds in the experiment represented
by r.
– the rules
c
= v, not Intervene(c).
c = v ← B, B  , pfB,r

Turning Simple P-log into Multi-Valued
Probabilistic Programs

(9)

for all v ∈ Dom(c), where B  is the body of the random
selection rule r. These rules assign v to c when the
assigned probability distribution applies to c = v.
– the rule

The main idea of the syntactic translation is to introduce
auxiliary probabilistic constants for encoding the assigned
probability and the default probability.
Given a simple P-log program Π, a constant c, a set of
literals B,2 and a random selection rule [r] random(c) ←
B  in Π, we ﬁrst introduce several notations, which resemble
the ones used for deﬁning the P-log semantics.

Assignedr ← B, B  , not Intervene(c)
where B  is the body of the random selection rule r
(we abbreviate Assignedr = t as Assignedr ). Assignedr
becomes true when any pr-atoms for c related to r is
applied.

• We deﬁne PRB,r (c) as
{prr (c = v | B) = p ∈ Π | v ∈ Dom(c)}

• For any constant c and any random selection rule r for c,
MLN
:
include in ΠLP

if Act in Π does not contain Do(c = v  ) for any v  ∈
Dom(c) and ∅ otherwise.
• We deﬁne AVB,r (c) as

– the probabilistic constant declaration
1
1
c
c
= v1 | · · · |
= vn
: pf,r
: pf,r
|Dom(c)|
|Dom(c)|

{v | prr (c = v | B) = p ∈ PRB,r (c)} .
• For each v ∈ AVB,r (c), we deﬁne the assigned probability of c = v w.r.t. B, r, denoted by apB,r (c = v), as the
value p for which prr (c = v | B) = p ∈ PRB,r (c).
2

c
{pfB,r
=v
c
{pf,r = v

MLN

c
for each probabilistic constant pf,r
of the signature,
c
where {v1 , . . . , vn } = Dom(c). The constant pf,r
is
used for representing the default probability distribution for c when there is no applicable pr-atom.

A literal is either an atom A or its negation not A.

152

Example

Parameter
Ndice = 2
Ndice = 7
Ndice = 8
Ndice = 9
Ndice = 10
Ndice = 100
maxstep = 5
maxstep = 10
maxstep = 12
maxstep = 13
maxstep = 15
maxstep = 20

dice

robot

plog1
0.00s + 0.00sa
1.93s + 31.37s
12.66s + 223.02s
timeout
timeout
timeout
0.00s + 0.00s
0.37s + 4.86s
3.65 + 51.76s
11.68s + 168.15s
timeout
timeout

Alchemy (default)
0.02s + 0.21sc
0.13s + 0.73s
0.16s + 0.84s
0.19s + 0.95s
0.23s + 1.06s
19.64s + 16.34s
2.34s + 2.54s
4.78s + 5.24s
5.72s + 6.34s
6.2s + 6.89s
7.18s + 7.99s
9.68s + 10.78s

plog2
0.00s + 0.00sb
0.00s + 1.24s
0.00s + 6.41s
0.00s + 48.62s
timeout
timeout
segment fault
segment fault
segment fault
segment fault
segment fault
segment fault

Alchemy (maxstep=5000)
0.02s + 0.96s
0.12s + 3.39s
0.16s + 3.86s
0.19s + 4.37s
0.24s + 4.88s
19.55s + 76.18s
2.3s + 11.75s
4.74s + 24.34s
5.75s + 29.46s
6.2s + 31.96s
7.34s + 37.67s
9.74s + 50.04s

Table 1: Performance Comparison between Two Ways to Compute Simple P-log Programs
a

smodels answer set ﬁnding time + probability computing time
partial grounding time + probability computing time
c
mrf creating time + sampling time

b

FW is

– the rules
c=v ← B



c
, pf,r
= v, not

Roll(D1 ) = 6 ∧ Roll(D2 ) = 3 ∧ Even(D1 )∧ ∼Even(D2 )
∧ Owner(D1 ) = Mike ∧ Owner(D2 ) = John
Roll(D1 )
Roll(D )
= 6 ∧ pf,r 2 = 3.
∧ pfO(D1 )=M,r

Assignedr .

for all v ∈ Dom(c), where B  is the body of the random
selection rule r. These rules assign v to c when the
uniform distribution applies to c = v.

It can be seen that μ̂Π (W ) = 14 × 16 = PΠLPMLN (FW ).
The embedding tells us that the exact inference in simple
P-log is no harder than the one in LPMLN .

Example 5 continued The simple P-log program Π in Example 5 can be turned into the following multi-valued probabilistic program. In addition to τ (Π) we have
Roll(d)

Experiments

Roll(d)

0.25 : pfO(d)=M,r(d) = 6 | 0.15 : pfO(d)=M,r(d) = 5 |
Roll(d)

Following the translation described above, it is possible to
compute a tight P-log program by translating it to LPMLN ,
and further turn that into the MLN instance following the
translation introduced in Section 5, and then compute it using an MLN solver.
Table 1 shows the performance comparison between this
method and the native P-log implementation on some examples, which are modiﬁed from the ones from (Baral, Gelfond, and Rushton 2009). P-log 1.0.0 (http://www.depts.ttu.
edu/cs/research/krlab/plog.php) implements two algorithms.
The ﬁrst algorithm (plog1) translates a P-log program to an
ASP program and uses ASP solver SMODELS to ﬁnd all possible worlds of the P-log program. The second algorithm
(plog2) produces a partially ground P-log program relevant
to the query, and evaluates partial possible worlds to compute the probability of formulas. ALCHEMY 2.0 implements
several algorithms for inference and learning. Here we use
MC-SAT for lazy probabilistic inference, which combines
MCMC with satisﬁability testing. ALCHEMY ﬁrst creates
Markov Random Field (MRF) and then perform MC-SAT
on the MRF created. The default setting of ALCHEMY performs 1000 steps sampling. We also tested with 5000 steps
sampling to produce probability that is very close to the true
probability. The experiments were performed on an Intel
Core2 Duo CPU E7600 3.06GH with 4GB RAM running
Ubuntu 13.10. The timeout was for 10 minutes.
The experiments showed the clear advantage of the translation method that uses ALCHEMY. It is more scalable, and
can be tuned to yield more precise probability with more
sampling or less precise but fast computation, by changing

Roll(d)

0.15 : pfO(d)=M,r(d) = 4 | 0.15 : pfO(d)=M,r(d) = 3 |
Roll(d)

Roll(d)

0.15 : pfO(d)=M,r(d) = 2 | 0.15 : pfO(d)=M,r(d) = 1

1
6

Roll(d)
Roll(d)
1
: pf,r(d) = 5 | 16 : pf,r(d) = 4 |
6
Roll(d)
Roll(d)
Roll(d)
pf,r(d) = 3 | 16 : pf,r(d) = 2 | 16 : pf,r(d) = 1

Roll(d)

: pf,r(d) = 6 |
1
6

:

Roll(d)

Roll(d) = x ← Owner(d) = Mike, pfO(d)=M,r(d) = x,
not Intervene(Roll(d))
Assignedr(d) ← Owner(d) = Mike, not Intervene(Roll(d))
Roll(d)

Roll(d) = x ← pf,r(d) = x, not Assignedr(d) .

Theorem 5 For any consistent simple P-log program Π of
signature σ and any possible world W of Π, we construct a
formula FW as follows.

FW = (c=v∈W c = v)∧
c, v :
(
pfBc W,c ,rW,c = v)
∧(

c = v is possible in W ,
|= c = v and PRW (c) = ∅
c, v :
c = v is possible in W ,
W |= c = v and PRW (c) = ∅

W

c
pf,r
= v)
W,c

We have

μΠ (W ) = PΠLPMLN (FW ),
and, for any proposition A of signature σ,
PΠ (A) = PΠLPMLN (A).
Example 5 continued For the possible world
W =

{Roll(D1 ) = 6, Roll(D2 ) = 3, Even(D1 ), ∼Even(D2 ),
Owner(D1 ) = Mike, Owner(D2 ) = John},

153

References

sampling parameters. The P-log implementation of the second algorithm led to segment faults in many cases.

9

Balduccini, M., and Gelfond, M. 2003. Logic programs with
consistency-restoring rules. In International Symposium on Logical Formalization of Commonsense Reasoning, AAAI 2003 Spring
Symposium Series, 9–18.
Baral, C.; Gelfond, M.; and Rushton, J. N. 2009. Probabilistic
reasoning with answer sets. TPLP 9(1):57–144.
Bauters, K.; Schockaert, S.; De Cock, M.; and Vermeir, D. 2010.
Possibilistic answer set programming revisited. In 26th Conference
on Uncertainty in Artiﬁcial Intelligence (UAI 2010).
Buccafurri, F.; Leone, N.; and Rullo, P. 2000. Enhancing disjunctive datalog by constraints. Knowledge and Data Engineering,
IEEE Transactions on 12(5):845–860.
De Raedt, L.; Kimmig, A.; and Toivonen, H. 2007. ProbLog: A
probabilistic prolog and its application in link discovery. In IJCAI,
volume 7, 2462–2467.
Denecker, M., and Ternovska, E. 2007. Inductive situation calculus. Artiﬁcial Intelligence 171(5-6):332–360.
Erdem, E., and Lifschitz, V. 2003. Tight logic programs. TPLP
3:499–518.
Fierens, D.; Van den Broeck, G.; Renkens, J.; Shterionov, D.; Gutmann, B.; Thon, I.; Janssens, G.; and De Raedt, L. 2015. Inference and learning in probabilistic logic programs using weighted
boolean formulas. TPLP 15(03):358–401.
Gelfond, M., and Lifschitz, V. 1988. The stable model semantics
for logic programming. In Kowalski, R., and Bowen, K., eds.,
Proceedings of International Logic Programming Conference and
Symposium, 1070–1080. MIT Press.
Gutmann, B. 2011. On Continuous Distributions and Parameter
Estimation in Probabilistic Logic Programs. Ph.D. Dissertation,
KU Leuven.
Lee, J., and Lifschitz, V. 2003. Loop formulas for disjunctive logic
programs. In Proceedings of International Conference on Logic
Programming (ICLP), 451–465.
Lee, J., and Wang, Y. 2015. A probabilistic extension of the stable
model semantics. In International Symposium on Logical Formalization of Commonsense Reasoning, AAAI 2015 Spring Symposium
Series.
Lee, J.; Meng, Y.; and Wang, Y. 2015. Markov logic style weighted
rules under the stable model semantics. In Technical Communications of the 31st International Conference on Logic Programming.
Lin, F., and Zhao, Y. 2004. ASSAT: Computing answer sets of a
logic program by SAT solvers. Artiﬁcial Intelligence 157:115–137.
Nickles, M., and Mileo, A. 2014. Probabilistic inductive logic programming based on answer set programming. In 15th International
Workshop on Non-Monotonic Reasoning (NMR 2014).
Niepert, M.; Noessner, J.; and Stuckenschmidt, H. 2011. Loglinear description logics. In IJCAI, 2153–2158.
Poole, D. 1997. The independent choice logic for modelling multiple agents under uncertainty. Artiﬁcial Intelligence 94:7–56.
Richardson, M., and Domingos, P. 2006. Markov logic networks.
Machine Learning 62(1-2):107–136.
Sato, T. 1995. A statistical learning method for logic programs with
distribution semantics. In Proceedings of the 12th International
Conference on Logic Programming (ICLP), 715–729.
Vennekens, J.; Verbaeten, S.; Bruynooghe, M.; and A, C. 2004.
Logic programs with annotated disjunctions. In Proceedings of International Conference on Logic Programming (ICLP), 431–445.
Vennekens, J.; Denecker, M.; and Bruynooghe, M. 2009. CP-logic:
A language of causal probabilistic events and its relation to logic
programming. TPLP 9(3):245–308.

Other Related Work

We observed that ProbLog can be viewed as a special case
of LPMLN . This result can be extended to embed Logic
Programs with Annotated Disjunctions (LPAD) in LPMLN
based on the fact that any LPAD program can be further
turned into a ProbLog program by eliminating disjunctions
in the heads (Gutmann 2011, Section 3.3).
It is known that LPAD is related to several other languages. In (Vennekens et al. 2004), it is shown that Poole’s
ICL (Poole 1997) can be viewed as LPAD, and that acyclic
LPAD programs can be turned into ICL. This indirectly tells
us how ICL is related to LPMLN .
CP-logic (Vennekens, Denecker, and Bruynooghe 2009)
is a probabilistic extension of FO(ID) (Denecker and Ternovska 2007) that is closely related to LPAD.
PrASP (Nickles and Mileo 2014) is another probabilistic
ASP language. Like P-log and LPMLN , probability distribution is deﬁned over stable models, but the weights there
directly represent probabilities.
Similar to LPMLN , log-linear description logics (Niepert,
Noessner, and Stuckenschmidt 2011) follow the weight
scheme of log-linear models in the context of description
logics.

10

Conclusion

Adopting the log-linear models of MLN, language LPMLN
provides a simple and intuitive way to incorporate the concept of weights into the stable model semantics. While MLN
is an undirected approach, LPMLN is a directed approach,
where the directionality comes from the stable model semantics. This makes LPMLN closer to P-log and ProbLog.
On the other hand, the weight scheme adopted in LPMLN
makes it amenable to apply the statistical inference methods developed for MLN computation. More work needs to
be done to ﬁnd how the methods studied in machine learning will help us to compute weighted stable models. While a
fragment of LPMLN can be computed by existing implementations of and MLNs, one may design a native computation
method for the general case.
The way that we associate weights to stable models is orthogonal to the way the stable model semantics are extended
in a deterministic way. Thus it is rather straightforward to
extend LPMLN to allow other advanced features, such as aggregates, intensional functions and generalized quantiﬁers.
Acknowledgements We are grateful to Michael Gelfond
for many useful discussions regarding the different ideas
behind P-log and LPMLN , and to Evgenii Balai, Michael
Bartholomew, Amelia Harrison, Yunsong Meng, and the
anonymous referees for their useful comments. This work
was partially supported by the National Science Foundation
under Grants IIS-1319794 and IIS-1526301, and ICT R&D
program of MSIP/IITP 10044494 (WiseKB).

154

Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence

Functional Stable Model Semantics and
Answer Set Programming Modulo Theories
Michael Bartholomew and Joohyung Lee
School of Computing, Informatics and Decision Systems Engineering
Arizona State University, Tempe, USA
{mjbartho, joolee}@asu.edu
Abstract

The other group of work focuses on improving the computational efficiency by integrating ASP with other declarative
computing paradigms, such as constraint processing, satisfiability modulo theories, or mixed integer programming [Gebser et al., 2009; Balduccini, 2009; Janhunen et al., 2011;
Liu et al., 2012], and exploiting the efficient constraint processing techniques on functions (or called “variables” in
CSP/SMT) without having to generate a large set of ground
instances. Constraint variables are functions that are mapped
to values in their domains. In SMT with difference logic or
linear constraints, arithmetic variables are functions that are
mapped to numbers. However, these functions are not as expressive as intensional functions.
This paper combines the advantages of the two groups of
work resulting in the framework of Answer Set Programming
Modulo Theories (ASPMT)—a tight integration of answer
set programming and satisfiability modulo theories, where
functions are as expressive as predicates in answer set programming, and can be computed efficiently without having
to ground w.r.t. their value domains. The existing languages
in the second group can be viewed as special cases of this
language. A fragment of ASPMT can be translated into the
language of SMT, allowing SMT solvers to be used for computation.
Section 2 reviews the functional stable model semantics by
Bartholomew and Lee [2012]. Section 3 presents a reformulation of this semantics in terms of grounding and reduct for
infinitary ground formulas. In Section 4 we define the concept
of ASPMT as a special case of the functional stable model semantics, and presents a syntactic class of ASPMT instances
that can be translated into SMT instances, which in turn allows us to use SMT solvers to compute ASPMT. In Section 5
we compare ASPMT with other similar approaches, clingcon
programs and ASP(LC) programs.

Recently there has been an increasing interest in
incorporating “intensional” functions in answer
set programming. Intensional functions are those
whose values can be described by other functions and predicates, rather than being pre-defined
as in the standard answer set programming. We
demonstrate that the functional stable model semantics plays an important role in the framework
of “Answer Set Programming Modulo Theories
(ASPMT)” —a tight integration of answer set programming and satisfiability modulo theories, under which existing integration approaches can be
viewed as special cases where the role of functions
is limited. We show that “tight” ASPMT programs
can be translated into SMT instances, which is similar to the known relationship between ASP and
SAT.

1

Introduction

In answer set programming (ASP), variables are understood
in terms of grounding, and this limits answer sets to Herbrand models, under which interpretations of functions are
pre-defined: every ground term represents itself, and is distinct from each other. Nonmonotonicity of the stable model
semantics is related to minimizing the extents of predicates,
but has nothing to do with functions, which forces us to represent the concept of nonBoolean fluents indirectly in terms
of predicates, and not by functions. A drawback of such representation is that grounding often becomes a bottleneck in
computation as the value domain of a nonBoolean fluent gets
large.
There are two recent groups of work to extend the stable
model semantics, each of which focuses only on one aspect
of the issues above. One group is interested in enriching
the modeling language by incorporating “intensional” functions [Cabalar, 2011; Lifschitz, 2012; Bartholomew and Lee,
2012; Balduccini, 2012]. Intensional functions are functions
whose values can be described by other functions and predicates, rather than being pre-defined. Such semantics allow
us to represent nonBoolean fluents by intensional functions
without having to rely on predicates.

2
2.1

Functional Stable Model Semantics
Review of the Bartholomew-Lee Semantics

We review the stable model semantics of intensional functions from [Bartholomew and Lee, 2012]. Formulas are built
the same as in first-order logic. A signature consists of function constants and predicate constants. Function constants of
arity 0 are called object constants, and predicate constants of
arity 0 are called propositional constants.

718

Similar to circumscription, for predicate symbols (constants or variables) u and c, expression u ≤ c is defined as
shorthand for ∀x(u(x) → c(x)). Expression u = c is defined
as ∀x(u(x) ↔ c(x)) if u and c are predicate symbols, and
∀x(u(x) = c(x)) if they are function symbols. For lists of
symbols u = (u1 , . . . , un ) and c = (c1 , . . . , cn ), expression
u ≤ c is defined as (u1 ≤ c1 )∧· · ·∧(un ≤ cn ), and similarly,
expression u = c is defined as (u1 = c1 ) ∧ · · · ∧ (un = cn ).
Let c be a list of distinct predicate and function constants,
and let b
c be a list of distinct predicate and function variables
corresponding to c. By cpred (cfunc , respectively) we mean
the list of all predicate constants (function constants, respectively) in c, and by b
cpred (b
cfunc , respectively) the list of the
corresponding predicate variables (function variables, respectively) in b
c.
For any formula F , expression SM[F ; c] is defined as

as a fact), this behavior is overridden, and the amount is set
to the maximum value.
Consider an interpretation I that has the set of nonnegative integers as the universe, interprets integers, arithmetic
functions and comparison operators in the standard way,
and has FillUpI = FALSE, AmountI0 = 6, AmountI1 = 5.
One can check that I is a model of SM[F ; Amount1 ].
Consider another interpretation I1 that agrees with I except that AmountI11 = 8. This is a model of F but not
of SM[F ; Amount1 ]. Another interpretation I2 that agrees
with I except that FillUpI2 = TRUE, AmountI12 = 10 satisfies
SM[F ; Amount1 ].
This example demonstrates the ability to assign a default
value to an intensional function, which is different from the
previous value of the function.

F ∧ ¬∃b
c(b
c < c ∧ F ∗ (b
c)),
pred

3

pred

where b
c < c is shorthand for (b
c
≤c
) ∧ ¬(b
c = c),
and F ∗ (b
c) is defined recursively as follows.

Instead of relying on a transformation into second-order
logic, the definition of a stable model in the previous section can be characterized in terms of grounding and reduct.
While the definition in terms of second-order logic is succinct, the reduct-based definition is more familiar, and tells
us some other insights.

• When F is an atomic formula, F ∗ is F 0 ∧ F where F 0
is obtained from F by replacing all intensional (function
and predicate) constants c in it with the corresponding
(function and predicate) variables from b
c;
• (G ∧ H)∗ = G∗ ∧ H ∗ ;
∗

∗

(G ∨ H)∗ = G∗ ∨ H ∗ ;

3.1

∗

∗

• (∀xG) = ∀xG ;

∗

Review: Infinitary ground Formulas

Since the universe can be infinite, grounding a quantified sentence introduces infinite conjunctions and disjunctions over
the elements in the universe. Here we rely on the concept
of grounding relative to an interpretation from [Truszczynski, 2012]. The following is the definition of an infinitary
ground formula, which is adapted from [Truszczynski, 2012].
The main difference between them is that we do not replace
ground terms with their corresponding object names, leaving
intensional functions in grounding. This is essential for defining a reduct for the functional stable model semantics.
For each element ξ of the universe |I| of I, we introduce
a new symbol ξ  , called an object name. By σ I we denote
the signature obtained from σ by adding all object names ξ 
as additional object constants. We will identify an interpretation I of signature σ with its extension to σ I defined by
I(ξ  ) = ξ.1
We assume the primary connectives to be ⊥, {}∧ , {}∨ ,
and →. Propositional connectives ∧, ∨, ¬, > are considered
as shorthands: F ∧ G as {F, G}∧ ; F ∨ G as {F, G}∨ .
Let A be the set of all ground atomic formulas of signature σ. The sets F0 , F1 , . . . are defined recursively as follows:
• F0 = A ∪ {⊥};
• Fi+1 (i ≥ 0) consists of expressions H∧ and H∨ , for
all subset H of F0 ∪ . . . ∪ Fi , and of the expressions
F → G, where F, G ∈ F0 ∪ · · · ∪ Fi .
S∞
We define Linf
= i=0 Fi . We call elements of Linf
A
A
infinitary ground formulas of σ.
For any interpretation I of σ and any infinitary ground formula F , the definition of satisfaction, I |= F , is as follows:

• (G → H) = (G → H ) ∧ (G → H);
∗

FSM in terms of Grounding and Reduct

∗

(∃xF ) = ∃xF .

(We understand ¬F as shorthand for F → ⊥; > as ¬⊥; and
F ↔ G as (F → G) ∧ (G → F ).) Members of c are called
intensional constants.
When F is a sentence, the models of SM[F ; c] are called
the stable models of F relative to c. They are the models of F
that are “stable” on c. The definition can be easily extended
to formulas of many-sorted signatures.
This definition of a stable model is a proper generalization
of the one from [Ferraris et al., 2011], which views logic programs as a special case of first-order formulas.
We will often write G ← F , in a rule form as in logic programs, to denote the universal closure of F → G. A finite set
of formulas is identified with the conjunction of the formulas
in the set.
Example 1 The following set F of formulas describes the capacity of a container of water that has a leak but that can
be refilled to the maximum amount, say 10, with the action
FillUp.
{Amount1 = x} ← Amount0 = x+1
Amount1 = 10 ← FillUp .
Here Amount1 is an intensional function constant, and x is a
variable ranging over nonnegative integers. According to the
semantics from [Bartholomew and Lee, 2012], the first rule
is a default rule (or choice rule) standing for
(Amount1 = x) ∨ ¬(Amount1 = x) ← Amount0 = x+1, (1)
and expresses that the amount at next time decreases by default. However, if FillUp action is executed (if we add FillUp

1

719

For details, see [Lifschitz et al., 2008].

• For atomic formulas, the definition is the same as in the
standard first-order logic;

Example 1 continued Among the ground formulas in (2),
only the implication

• I |= H∧ if for every formula G ∈ H, I |= G;

{Amount1 = 5} ← Amount0 = 5+1

• I |= H∨ if there is a formula G ∈ H such that I |= G;

which stands for

• I |= G → H if I 6|= G or I |= H.

(Amount1 = 5) ∨ ¬(Amount1 = 5) ← Amount0 = 5+1

Let F be any first-order sentence of a signature σ, and let
I be an interpretation of σ. By grI [F ] we denote the infinitary ground formula w.r.t. I, which is obtained from F by the
following process:

has its antecedent satisfied by I, so the reduct (grI [F ])I is
equivalent to
(Amount1 = 5) ∨ ⊥ ← Amount0 = 5+1

• If F is an atomic formula, grI [F ] is F ;
• grI [F  G] = grI [F ]  grI [G]

No interpretation that is different from I only on Amount1
satisfies the reduct. On the other hand, the reduct (grI1 [F ])I1
is equivalent to

( ∈ {∧, ∨, →});

• grI [∀xF (x)] = {grI [F (ξ  )] | ξ ∈ |I|}∧ ;

⊥ ∨ ¬⊥ ← Amount0 = 5+1,

• grI [∃xF (x)] = {grI [F (ξ  )] | ξ ∈ |I|}∨ .
I

and other interpretations that are different from I1 only on
Amount1 satisfy the reduct. (grI2 [F ])I2 is equivalent to

Note that grI [F ] is an infinitary ground formula of σ .
Example 1 continued Consider again F in Example 1, and
the same interpretation I there. grI (F ) is the following set
of formulas:
{Amount1 = 0} ← Amount0 = 0+1
{Amount1 = 1} ← Amount0 = 1+1
...
Amount1 = 10 ← FillUp .

⊥ ∨ ¬⊥ ← Amount0 = 5+1,
Amount1 = 10 ← FillUp
and I2 is the only interpretation that satisfies the reduct.
In accordance with Theorem 1, I and I2 are the stable models of F relative to Amount1 , but I1 is not.

(2)

4
3.2

4.1

Reduct-Based Definition of SM

• J and I have the same universe and agree on all constants not in c;
• pJ ⊆ pI for all predicate constants p in c; and
• J and I do not agree on c.
The reduct F I of an infinitary ground formula F relative
to an interpretation I is defined as follows:
• For each atomic formula F , F I = ⊥ if I 6|= F and
F I = F otherwise;
6|=

H∧ ;

otherwise

• (H∨ )I
=
⊥ if I
(H∨ )I = {GI | G ∈ H}∨ ;

6|=

H∨ ;

otherwise

ASPMT as a Special Case of FSM

Formally, an SMT instance is a formula in many-sorted firstorder logic, where some designated function and predicate
constants are constrained by some fixed background interpretation. SMT is the problem of determining whether such a
formula has a model that expands the background interpretation [Barrett et al., 2009].
The syntax of ASPMT is the same as that of SMT. Let σ bg
be the (many-sorted) signature of the background theory bg.
An interpretation of σ bg is called a background interpretation if it satisfies the background theory. For instance, in the
theory of reals, we assume that σ bg contains the set R of symbols for all real numbers, the set of arithmetic functions over
real numbers, and the set {<, >, ≤, ≥} of binary predicates
over real numbers. Background interpretations interpret these
symbols in the standard way.
Let σ be a signature that is disjoint from σ bg . We say that
an interpretation I of σ satisfies F w.r.t. the background theory bg, denoted by I |=bg F , if there is a background interpretation J of σ bg that has the same universe as I, and I ∪ J
satisfies F . For any ASPMT sentence F with background
theory σ bg , interpretation I is a stable model of F relative
to c (w.r.t. background theory σ bg ) if I |=bg SM[F ; c].

For any two interpretations I, J of the same signature and any
list c of distinct predicate and function constants, we write
J <c I if

• (H∧ )I
=
⊥ if I
(H∧ )I = {GI | G ∈ H}∧ ;

Answer Set Programming Modulo Theories

• (G → H)I = ⊥ if I 6|= G → H; otherwise
(G → H)I = GI → H I .
The following theorem states the reformulation of FSM in
terms of grounding and reduct.

Example 1 continued Formula F can be understood as an
ASPMT formula with the theory of integers as the background theory. Arithmetic functions and comparison operators belong to the background signature. If I 0 is an interpretation of signature {Amount0 , Amount1 , FillUp} which
agrees with I on these constants, We say that I 0 |=bg
SM[F ; Amount1 ].

Theorem 1 Let F be a first-order sentence and c a list of
intensional constants. For any interpretation I of σ, I |=
SM[F ; c] iff
• I satisfies F , and
• every interpretation J such that J <c I does not satisfy
(grI [F ])I .

720

Instance
Size
10
50
100
500
1000
5000
10000

CLINGO v3.0.5 Execution
Run Time (Grounding + Solving)
0s (0s + 0s)
.02s (.02s + 0s)
.12s (.12s + 0s)
8.18s (8.17s + 0.01s)
55.17s (55.15s + 0.02s)
Did not terminate in 2 hours
Did not terminate in 2 hours

Atoms
210
2970
10920
254520
1009020

iSAT v1.0 Execution
Run Time (Last step) Variables
0s(0s)
86
.05s(0s)
406
.15s(0s)
806
4.41s(.03s)
4006
18.57s(.09s)
8006
500.17s(.45s)
40006
2008.97s(.93s)
80006

Z 3 V 4.3.0 Execution
Run time Memory
.05s
2.07
.18s
2.17
.33s
2.28
1.68
3.38s
3.35s
4.73
17.42s
17.32
36.49s
31.42

Table 1: Leaking Bucket Experiment Results

4.2

Turning ASPMT into SMT for Tight Programs

We say that a formula F is in Clark normal form (relative
to the list c of intensional constants) if it is a conjunction of
sentences of the form

Theorem 2 For any sentence F in Clark normal form that is
tight on c, an interpretation I that satisfies ∃xy(x 6= y) is
a model of SM[F ; c] iff I is a model of the completion of F
relative to c.

∀x(G → p(x))

Example 1 continued Formula (1) is strongly equivalent to

(3)

Amount1 = x ← ¬¬(Amount1 = x) ∧ Amount0 = x+1,

and
∀xy(G → f (x) = y)

(4)

so that formula F in Example 1 can be turned into Clark normal form relative to Amount1 :

one for each intensional predicate p and each intensional
function f , where x is a list of distinct object variables, y
is an object variable, and G is an arbitrary formula that has
no free variables other than those in x and y.
The completion of a formula F in Clark normal form (relative to c) is obtained from F by replacing each conjunctive
term (3) with
∀x(p(x) ↔ G)

Amount1 = x ← (¬¬(Amount1 = x) ∧ Amount0 = x+1)
∨ (x = 10 ∧ FillUp).
and the completion turns it into
Amount1 = x ↔ (¬¬(Amount1 = x) ∧ Amount0 = x+1)
∨ (x = 10 ∧ FillUp).
Using equality, the formula can be written without mentioning the variable x as

and each conjunctive term (4) with
∀xy(f (x) = y ↔ G).

(Amount0 = Amount1 + 1) ∨ (Amount1 = 10 ∧ FillUp)
FillUp → Amount1 = 10 .

An occurrence of a symbol or a subformula in a formula F
is called strictly positive in F if that occurrence is not in the
antecedent of any implication in F . The t-dependency graph
of F (relative to c) is the directed graph that

In the language of iSAT, this formula can be represented as
(Amt = Amt’+1) or (Amt’=10 and FillUp);
FillUp -> Amt’=10;

• has all members of c as its vertices, and

and in the language of Z3, it can be represented as

• has an edge from c to d if, for some strictly positive occurrence of G → H in F ,

(assert (or (= Amt0 (+ Amt1 1))
(and (= Amt1 10) FillUp)))
(assert (=> FillUp0 (= Amt1 10))) .

– c has a strictly positive occurrence in H, and
– d has a strictly positive occurrence in G.

Alternatively, according to the method in [Bartholomew
and Lee, 2012], formula F in Example 1 can be turned into
the input language of GRINGO by eliminating intensional
functions in favor of intensional predicates.
Our first experiment has the bucket initially at capacity 5
and the goal is to get the bucket to capacity 10 at a certain
fixed timepoint. The different instance sizes correspond to
the maximum capacity of the bucket and the certain timepoint
(they are both the same in each case). iSAT finds a model of
bounded length k, where k starts from 0 and increases by 1
until a model is found. The run time reported is the total
cumulative times for k = 0, 1, . . . , m where m is the instance
size. The last step time is for the run when k = m. For other
systems, we fixed the length k = m from the beginning. The
results shown in Table 1 demonstrate that even for a relatively
simple domain, ASP suffers a grounding bottleneck that is not
present when using SMT solvers. We see that the number of

We say that F is tight (on c) if the t-dependency graph of
F (relative to c) is acyclic. For example,
((p → q) → r) → p
is tight on {p, q, r} because its t-dependency graph has only
one edge, which goes from p to r. On the other hand, the formula is not tight according to [Ferraris et al., 2011] because,
according to the definition of a dependency graph in that paper, there is an additional edge that goes from p to itself.
Theorem 12 from [Bartholomew and Lee, 2012] extended
the theorem on completion from [Ferraris et al., 2011] to
allow intensional functions, but it was restricted to a class
of formulas called c-plain formulas. The following theorem
generalizes that theorem by removing that restriction and by
referring to the weaker notion of tightness as described above.

721

Instance Size
5
10
20
30
50
100

CLINGO v3.0.5 Execution
Run Time (Grounding + Solving)
.02s (.02s + 0s)
.3s (.3s + 0s)
9.46s (4.02s + 5.11s)
42.56s (22.32s + 20.24s)
923.74s (297.26 + 626.48s)
out of memory

Atoms
3174
10161
36695
77627
207706

iSAT v1.0 Execution
Run Time Variables
.03s
331
.19s
596
.79s
1126
2.05s
1656
14.35s
2716
494.77s
5366

Z 3 V 4.3.0 Execution
Run time Memory
.03s
2.79
.09s
4.91
.2s
8.65
.36s
12.22
1.09s
20.35
5.52s
43.86

Table 2: Gears World Experiment Results
A clingcon program Π with a constraint satisfaction problem (V, D, C) is a set of rules of the form

atoms for CLINGO increases quadratically to the instance size
while the number of variables for iSAT increases linearly.
Next, consider the Gears World domain in which we have
two gears, Gear1 with radius 7 and Gear2 with radius 17.
Each gear is connected to a motor that has integral running
speeds which can be incremented by 1 using the corresponding action. The gears can also be moved close together so
that both gears spin at the speed of the higher value (between
M1Speed × Radius1 or M2Speed × Radius2). The goal is
to have Gear1 spinning at a multiple of Gear2’s radius. That
multiple is the instance size in Table 2, so for example, instance size 3 means at the end, we want Gear1 spinning at
a speed of 51(= 3 × 17). This domain can be expressed in
the language of ASPMT with the theory of integers. Here is
a part of the program that governs the speed of a motor. The
speed does not change unless the increase action happens, in
which case it is incremented by 1 unit.

a ← B, N, Cn,

M1Speedt = x ← M1Speedt−1 = x−1 ∧ IncreaseM1t−1
M1Speedt = x ← ¬¬(M1Speedt = x) ∧ M1Speedt−1 = x
(t is a step counter, which can be represented by an ASP variable to be grounded).
The ASPMT description of the Gears World is tight and
can be turned into the input language of SMT solvers by completion. For example, the completion relative to M1Speedt is
M1Speeedt = x ↔ (M1Speedt−1 = x − 1 ∧ IncreaseM1t−1 )
∨(M1Speedt−1 = x ∧ ¬¬M1Speedt = x) .
The Gears World domain can also be computed by ASP
solvers by eliminating the intensional functions in favor of
intensional predicates as described in [Bartholomew and Lee,
2012]. Table 2 compares the two approaches and reveals that
the SMT solvers iSAT and Z 3 were able to perform comparatively very well as the instance size increased.
The experiments were performed on an Intel Core 2 Duo
CPU 3.00 GHz with 4 GB RAM.

5
5.1

(5)

where a is a propositional atom or ⊥, B is a set of positive
propositional literals, N is a set of negative propositional literals, and Cn is a set of constraints from C, possibly preceded
by not.
Clingcon programs can be viewed as ASPMT instances.
Below is a reformulation of the semantics in terms of
ASPMT. We assume that constraints are expressed by
ASPMT sentences of signature V ∪ σ bg , where V is a set
of object constants identified with constraint variables V in
(V, D, C), whose value sorts are identified with domains in
D; we assume that σ bg is disjoint from V and contains all
values in D as object constants, and other symbols to represent constraints, such as +, ×, and ≥. In other words, we represent a constraint as a formula F (v1 , . . . , vn ) over V ∪ σ bg
where F (x1 , . . . , xn ) is a formula of the signature σ bg and
F (v1 , . . . , vn ) is obtained from F (x1 , . . . , xn ) by substituting the object constants (v1 , . . . , vn ) in V for (x1 , . . . , xn ).
For any signature σ that consists of object constants and
propositional constants, we identify an interpretation I of σ
as the tuple hI f , Xi, where I f is the restriction of I on the
object constants in σ, and X is a set of propositional constants
in σ that are true under I.
Given a clingcon program Π with (V, D, C), and an interpretation I = hI f , Xi, we define the constraint reduct of
Π relative to X and I f (denoted by ΠX
I f ) as the set of rules
a ← B for each rule (5) is in Π such that I f |=bg Cn, and
X |= N . We say that a set X of propositional atoms is a constraint answer set of Π relative to I f if X is a minimal model
of ΠX
If .
Example 1 continued The rules
Amount1 +1 =$ Amount0 ← not FillUp,
Amount1 =$ 10 ← FillUp
are identified with

Comparison with Other Approaches to ASP
Modulo Theories

⊥ ← not FillUp, not(Amount1 +1 =$ Amount0 )
⊥ ← FillUp, not(Amount1 =$ 10)

Clingcon programs as a special case of ASPMT

under the semantics of clingcon programs. Consider I in Example 1, which can be represented as hI f , Xi where I f maps
Amount0 to 6, and Amount1 to 5, and X = ∅. X is the constraint answer set relative to I f because X is the minimal
model of the constraint reduct relative to X and I f , which is
the empty set.

A constraint satisfaction problem (CSP) is a tuple (V, D, C),
where V is a set of constraint variables with the respective
domains D, and C is a set of constraints that specify legal
assignments of values in the domains to the constraint variables.

722

An LJN-intepretation is a pair (X, T ) where X ⊆ σ p and
T is a subset of theory atoms occurring in Π such that there is
some interpretation I of signature σ f such that I |=bg T ∪ T ,
where T is the set of negations of each theory atom occurring
in Π but not in T . An LJN-interpretation (X, T ) satisfies an
atom b if b ∈ X, the negation of an atom not c if c ∈
/ X,
and a theory atom t if t ∈ T . The notion of satisfaction is
extended to other propositional connectives as usual.
The LJN-reduct of a program Π with respect to an LJNinterpretation (X, T ), denoted by Π(X,T ) , consists of rules
a ← B for each rule (6) such that (X, T ) satisfies N ∧ LC.
(X, T ) is an LJN-answer set of Π if (X, T ) satisfies Π, and
X is the smallest set of atoms satisfying Π(X,T ) .
The following theorem tells us that there is a one-to-many
relationship between LJN-answer sets and the stable models
in the sense of ASPMT.

Similar to the way that rules are identified as a special case
of formulas [Ferraris et al., 2011], we identify a clingcon program Π with the conjunction of implications B ∧N ∧Cn → a
for all rules (5) in Π. The following theorem tells us that
clingcon programs are a special case of ASPMT, in which the
background theory is specified by (V, D, C), and intensional
constants are limited to propositional constants only, and do
not allow function constants.
Theorem 3 Let Π be a clingcon program with CSP
(V, D, C), let p be the set of all propositional constants occurring in Π, and let I be an interpretation hI f , Xi of signature V ∪ p. Set X is a constraint answer set of Π relative
to I f iff I |=bg SM[Π; p].
Note that a clingcon program does not allow an atom that
consists of elements from both V and p. Thus the truth value
of any atom is determined by either I f or X, but not by involving both of them. This allows loose coupling of an ASP
solver and a constraint solver. On the other hand, [Gebser
et al., 2009] sketches a method to extend clingcon programs
to allow predicate constants of positive arity, possibly containing constraint variables as arguments. This however leads
to some unintuitive cases under the semantics of CLINGCON
programs, as the following example shows.
$domain(100..199).
myoffice(a).
:- myoffice(b).
:- not a $==b.

%
%
%
%

Theorem 4 Let Π be an ASP(LC) program, and σ p and σ f
are defined as above.
(a) If (X, T ) is an LJN-answer set of Π, then for any interpretation hI f , Xi of signature σ p ∪ σ f such that
I f |=bg T ∪ T , we have hI f , Xi |=bg SM[Π; σ p ].
(b) For any interpretation I = hI f , Xi of signature σ p ∪σ f ,
if hI f , Xi |=bg SM[Π; σ p ], then an LJN-interpretation
(X, T ) where

Office numbers
a is my office number,
and b is not.
Nevertheless, a equals b.

T = {t | t is a theory atom in Π such that I f |=bg t}
is an LJN-answer set of Π.

System CLINGCON does not notice that this set of assumptions is inconsistent. This is because symbols a and b in ASP
atoms and the same symbols in the constraint are not related.
On the other hand, ASPMT, which allows first-order signatures, does not have this anomaly; there is no stable model
under ASPMT.

5.2

Example 2 Let F be
a ← x−z > 0.
c ← b, y−z ≤ 0.
b ← c.

Comparison with ASP(LC) Programs by Liu
et al.

The LJN-interpretation L = h{a}, {x−z > 0}i is an answer
set of F since {(x − z > 0, ¬(x − y ≤ 0), ¬(y − z ≤ 0)} is
satisfiable (e.g. take xI = 2, y I = 1, z I = 0) and the set
{a} is the minimal model satisfying the reduct F L = (> →
a) ∧ c → b. On the other hand the interpretation I such that
xI = 2, y I = 1, z I = 0, aI = TRUE, bI = FALSE, cI = FALSE
satisfies I |=bg SM[F ; abc].

[Liu et al., 2012] considers logic programs with linear constraints, or ASP(LC) programs, comprised of rules of the form
a ← B, N, LC

b ← x−y ≤ 0.
← not a.

(6)

where a is a propositional atom or ⊥, B is a set of positive
propositional literals, and N is a set of negative propositional
literals, and LC is a set of theory atoms—linear constraints
n
X
of the form
(ci × xi ) ./ k where ./∈ {≤, ≥, =}, each

As with clingcon programs, ASP(LC) programs are more
restrictive than ASPMT. ASP(LC) programs do not allow theory atoms in the head of a rule, and like clingcon programs,
cannot express intensional functions.

i=1

xi is an object constant whose value sort is integers (or reals),
and each ci , k is an integer (or real).
An ASP(LC) program Π can be viewed as an ASPMT formula whose background theory bg is the theory of integers
or the theory of reals. Let σ p denote the set of all propositional atoms occurring in Π and σ f denote all object constants occurring in Π that do not belong to the background
signature. Theory atoms are essentially ASPMT formulas of
signature σ f ∪ σ bg . We identify ASP(LC) program Π with
the conjunction of ASPMT formulas B ∧ N ∧ LC → a for
all rules (6) in Π.

6

Conclusion

In this paper, we related the two lines of research on functions in answer set programming that originated from different motivations, leading to an expressive KR formalism
called ASPMT, which can be efficiently computed by SMT
solvers. The relationship between ASPMT and SMT is similar to the relationship between ASP and SAT. We expect
that, in addition to completion, many results known between
ASP and SAT can be carried over to the relationship between
ASPMT and SMT.

723

Acknowledgements

[Liu et al., 2012] Guohua Liu, Tomi Janhunen, and Ilkka
Niemelä. Answer set programming via mixed integer programming. In Proceedings of International Conference
on Principles of Knowledge Representation and Reasoning (KR), pages 32–42, 2012.
[Truszczynski, 2012] Miroslaw Truszczynski. Connecting
first-order ASP and the logic FO(ID) through reducts. In
Correct Reasoning, pages 543–559, 2012.

We are grateful to Yunsong Meng for useful discussions related to this paper. We are also grateful to the anonymous
referees for their useful comments. This work was partially supported by the National Science Foundation under
Grant IIS-0916116 and by the South Korea IT R&D program
MKE/KIAT 2010-TD-300404-001.

References
[Balduccini, 2009] Marcello Balduccini. Representing constraint satisfaction problems in answer set programming.
In Working Notes of the Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP),
2009.
[Balduccini, 2012] Marcello Balduccini. A ”conservative”
approach to extending answer set programming with nonherbrand functions. In Correct Reasoning - Essays on
Logic-Based AI in Honour of Vladimir Lifschitz, pages 24–
39, 2012.
[Barrett et al., 2009] Clark W. Barrett, Roberto Sebastiani,
Sanjit A. Seshia, and Cesare Tinelli. Satisfiability modulo
theories. In Armin Biere, Marijn Heule, Hans van Maaren,
and Toby Walsh, editors, Handbook of Satisfiability, volume 185 of Frontiers in Artificial Intelligence and Applications, pages 825–885. IOS Press, 2009.
[Bartholomew and Lee, 2012] Michael Bartholomew and
Joohyung Lee. Stable models of formulas with intensional
functions. In Proceedings of International Conference on
Principles of Knowledge Representation and Reasoning
(KR), pages 2–12, 2012.
[Cabalar, 2011] Pedro Cabalar. Functional answer set programming. TPLP, 11(2-3):203–233, 2011.
[Ferraris et al., 2011] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. Stable models and circumscription.
Artificial Intelligence, 175:236–263, 2011.
[Gebser et al., 2009] M. Gebser, M. Ostrowski, and
T. Schaub. Constraint answer set solving. In Proceedings
of International Conference on Logic Programming
(ICLP), pages 235–249, 2009.
[Janhunen et al., 2011] Tomi Janhunen, Guohua Liu, and
Ilkka Niemel. Tight integration of non-ground answer set
programming and satisfiability modulo theories. In Working notes of the 1st Workshop on Grounding and Transformations for Theories with Variables, 2011.
[Lifschitz et al., 2008] Vladimir Lifschitz, Leora Morgenstern, and David Plaisted. Knowledge representation and
classical logic. In Frank van Harmelen, Vladimir Lifschitz, and Bruce Porter, editors, Handbook of Knowledge
Representation, pages 3–88. Elsevier, 2008.
[Lifschitz, 2012] Vladimir Lifschitz. Logic programs with
intensional functions. In Proceedings of International
Conference on Principles of Knowledge Representation
and Reasoning (KR), pages 24–31, 2012.

724

TLP 13 (4–5): Online Supplement, July 2013.
JOOHYUNG LEE]

C 2013 [MICHAEL BARTHOLOMEW and


863

URL: http://dx.doi.org/10.1017/S1471068413000549

On the stable model semantics for intensional
functions
M I C H A E L B A R T H O L O M E W and J O O H Y U N G L E E
School of Computing, Informatics, and Decision Systems Engineering
Arizona State University, Tempe, USA
(e-mail: {mjbartho,joolee}@asu.edu)

submitted 10 April 2013; revised 23 June 2013; accepted 5 July 2013

Abstract
Several extensions of the stable model semantics are available to describe “intensional”
functions—functions that can be described in terms of other functions and predicates by
logic programs. Such functions are useful for expressing inertia and default behaviors of
systems, and can be exploited for alleviating the grounding bottleneck involving functional
ﬂuents. However, the extensions were deﬁned in diﬀerent ways under diﬀerent intuitions. In
this paper we provide several reformulations of the extensions, and note that they are in fact
closely related to each other and coincide on large syntactic classes of logic programs.
KEYWORDS: answer set programming, stable models, intensional functions

1 Introduction
Several extensions of the stable model semantics were proposed to allow “intensional” functions—functions that can be described in terms of other functions
and predicates by logic programs (Cabalar 2011; Lifschitz 2012; Bartholomew and
Lee 2012; Balduccini 2012b). Such functions signiﬁcantly enhance the modeling
capability of the language of answer set programming by providing natural representations of nonBoolean ﬂuents, such as the location of an object, or the level of
a water tank. The following example demonstrates the ability to assign a default
value to a function, which is useful for expressing inertia and default behaviors of
systems.
Example 1
The following program F describes the capacity of a water tank that has a leak but
that can be reﬁlled to the maximum amount, say 10, with the action FillUp.
{Amount 1 = x} ← Amount 0 = x+1
Amount 1 = 10 ← FillUp .

(1)

Here Amount 1 is an intensional function constant, and x is a variable ranging over
nonnegative integers. According to (Bartholomew and Lee 2013), the ﬁrst rule is a
choice rule standing for (Amount 1 = x) ∨ ¬(Amount 1 = x) ← Amount 0 = x+1, which

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

864

M. Bartholomew and J. Lee

asserts that the amount decreases by default. However, if FillUp action is executed
(e.g., if we add FillUp as a fact), this behavior is overridden, and the amount is set to
the maximum value.
Recently, (Bartholomew and Lee 2013) showed that functional stable model
semantics can be used as a natural basis of combining answer set programming and
satisﬁability modulo theories. For instance, the paper showed that, if a program is
“tight,” as is the case in the example above, it can be turned into the input language
of Satisﬁability Modulo Theories (SMT) solvers, thereby allowing us to apply
eﬃcient constraint solving methods in SMT to alleviate the grounding bottleneck
involving functional ﬂuents. For example, program (1) can be turned into the SMT
instance


(Amount 0 = Amount 1 + 1) ∨ (Amount 1 = 10 ∧ FillUp)
∧ (FillUp → Amount 1 = 10).
Similarly, (Balduccini 2012a) reports the computational eﬃciency of a system that
computes the semantics of intensional functions deﬁned in Balduccini (2012b).
However, the existing semantics of intensional functions were deﬁned in very
diﬀerent styles under diﬀerent intuitions, which obscures the relationships among
them. Though the relationship between the language of Lifschitz (2012) and the
language of Bartholomew and Lee (2012) was discussed in Bartholomew and
Lee (2012), their relationships to other functional stable model semantics were
left open. Roughly speaking, the languages in Lifschitz (2012) and (Bartholomew
and Lee 2012) are deﬁned in terms of second-order formulas, which express the
nonmonotonicity of the semantics by ensuring the uniqueness of function values. On
the other hand, the language in Cabalar (2011) is deﬁned in terms of a modiﬁcation
to equilibrium logic by allowing functions to be partially deﬁned, and applying
a “minimality” condition on such functions. The idea behind the language in
(Balduccini 2012b) appears similar to the one in Cabalar (2011), but the deﬁnition
looks very diﬀerent. It is deﬁned in terms of a modiﬁcation to the notion of a
reduct.
In this paper we provide several reformulations of the extensions, which reveal
that these semantics are in fact closely related to each other, and coincide on
large syntactic classes of logic programs. The relationships allow us to transfer
some mathematical results established for one language to another language.
Additionally, an implementation of one language can be viewed as an implementation of another language when restricting attention to one of these syntactic
classes.
Section 2 reviews the Bartholomew-Lee semantics from (Bartholomew and Lee
2012; Bartholomew and Lee 2013) and the Cabalar semantics from (Cabalar 2011).
Section 3 presents reformulations of these deﬁnitions, and based on the result,
Section 4 relates the two semantics. Further, Section 5 shows how to reduce the
Cabalar semantics to the ﬁrst-order stable model semantics from (Ferraris et al.
2011), and Section 6 shows how the Balduccini semantics (Balduccini 2012b) can be
viewed as a special case of the Cabalar semantics.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

On the stable model semantics for intensional functions

865

2 Preliminaries
2.1 Review: original deﬁnition of Bartholomew-Lee semantics in terms of SOL
Formulas are built the same as in ﬁrst-order logic. A signature consists of function
constants and predicate constants. Function constants of arity 0 are called object
constants, and predicate constants of arity 0 are called propositional constants.
Similar to circumscription, for predicate symbols (constants or variables) v and
c, expression v 6 c is deﬁned as shorthand for ∀x(v(x) → c(x)). Expression v = c is
deﬁned as ∀x(v(x) ↔ c(x)) if v and c are predicate symbols, and ∀x(v(x) = c(x)) if
they are function symbols. For lists of symbols v = (v1 , . . . , vn ) and c = (c1 , . . . , cn ),
expression v 6 c is deﬁned as (v1 6 c1 )∧· · ·∧(vn 6 cn ), and similarly, expression v = c
is deﬁned as (v1 = c1 )∧· · ·∧(vn = cn ). Let c be a list of distinct predicate and function
constants, and let c be a list of distinct predicate and function variables corresponding
to c. Members of c are called intensional constants. By cpred (cfunc , respectively) we
mean the list of all predicate constants (function constants, respectively) in c, and
by cpred (cfunc , respectively) we mean the list of the corresponding predicate variables
(function variables, respectively) in c.
For any ﬁrst-order formula F, expression SM[F; c] is deﬁned as
F ∧ ¬∃c(c < c ∧ F ∗ (c)),
where c < c is shorthand for (cpred 6 cpred )∧¬(c = c), and F ∗ (c) is deﬁned recursively
as follows.
• When F is an atomic formula, F ∗ is F(c) ∧ F, where F(c) is obtained from F
by replacing all (function and predicate) constants from c occurring in F with
the corresponding (function and predicate) variables from c;
(G ∨ H)∗ = G∗ ∨ H ∗ ;
• (G ∧ H)∗ = G∗ ∧ H ∗ ;
∗
∗
∗
• (G → H) = (G → H ) ∧ (G → H);
(∃xG)∗ = ∃xG∗ .
• (∀xG)∗ = ∀xG∗ ;
(We understand ¬F as shorthand for F → ⊥; and  as ¬⊥.)
When F is a sentence (formula with no free variables), the models of SM[F; c]
are called the stable models of F relative to c. They are the models of F that are
“stable” on c. This deﬁnition of a stable model is a proper generalization of the one
from (Ferraris et al. 2011), which views logic programs as a special case of formulas.
We will often write the implication F → G in a rule form G ← F as in logic
programs. We often identify a program with a ﬁnite conjunction of universal closures
of formulas.
Example 1 continued. Consider the formula F in Example 1 and an interpretation I
that has the set of nonnegative integers as the universe, interprets integers, arithmetic
functions and comparison operators in the standard way, and has FillUp I = false,
Amount I0 = 6, Amount I1 = 5. One can check that I is a model of SM[F; Amount 1 ].
Consider another interpretation I1 that agrees with I except that Amount I11 = 8. This
is a model of F but not of SM[F; Amount 1 ]. Another interpretation I2 that agrees with
I except that FillUp I2 = true, Amount I12 = 10 is a model of F as well as a model
of SM[F; Amount 1 ].

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

866

M. Bartholomew and J. Lee
2.2 Review: Bartholomew-Lee semantics in terms of grounding and reduct
2.2.1 Inﬁnitary ground formulas

Since the universe can be inﬁnite, grounding a quantiﬁed sentence introduces inﬁnite
conjunctions and disjunctions over the elements in the universe. Here we rely on
the concept of grounding relative to an interpretation from (Truszczynski 2012).
The following is the deﬁnition of an inﬁnitary ground formula, which is adapted
from (Truszczynski 2012). One diﬀerence is that we do not replace ground terms
with their corresponding object names, leaving them unchanged during grounding.
This change is necessary in deﬁning a reduct for functional stable model semantics.1
For each element ξ in the universe |I| of I, we introduce a new symbol ξ 
 , called
an object name. By σ I we denote the signature obtained from σ by adding all object
names ξ 
 as additional object constants. We will identify an interpretation I of
signature σ with its extension to σ I deﬁned by I(ξ 
 ) = ξ.2
We assume the primary connectives to be ⊥, {}∧ , {}∨ , and →. Propositional
connectives ∧, ∨, ¬,  are considered as shorthands: F∧G as {F, G}∧ ; F∨G as {F, G}∨ .
¬ and  are deﬁned as before.
Let A be the set of all ground atomic formulas of signature σ I . The sets F0 , F1 , . . .
are deﬁned recursively as follows:
• F0 = A ∪ {⊥};
• Fi+1 (i > 0) consists of expressions H∨ and H∧ , for all subsets H of F0 ∪
. . . ∪ Fi , and of the expressions F → G, where F, G ∈ F0 ∪ · · · ∪ Fi .
∞
inf
We deﬁne Linf
A =
i=0 Fi , and call elements of LA inﬁnitary ground formulas of σ
w.r.t. I.
For any interpretation I of σ and any inﬁnitary ground formula F w.r.t. I, the
deﬁnition of satisfaction, I |= F, is as follows:
• For atomic formulas, the deﬁnition of satisfaction is the same as in the standard
ﬁrst-order logic;
• I |= H∨ if there is a formula G ∈ H such that I |= G;
• I |= H∧ if, for every formula G ∈ H, I |= G;
• I |= G → H if I |= G or I |= H.
2.2.2 Bartholomew-Lee Semantics in Terms of Grounding and Reduct
Let F be any ﬁrst-order sentence of a signature σ, and let I be an interpretation
of σ. By grI [F] we denote the inﬁnitary ground formula w.r.t. I that is obtained
from F by the following process:
• If F is an atomic formula, grI [F] is F;
• grI [G  H] = grI [G]  grI [H] ( ∈ {∧, ∨, →});
1

2

Another diﬀerence is that grounding in Truszczynski (2012) refers to “inﬁnitary propositional formulas,”
which can be deﬁned on any propositional signature. This generality is not essential for our purpose
in this paper.
For details, see (Lifschitz et al. 2008).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

On the stable model semantics for intensional functions
• grI [∃xG(x)] = {grI [G(ξ 
 )] | ξ ∈ |I|}∨ ;
|I|}∧ .

867

grI [∀xG(x)] = {grI [G(ξ 
 )] | ξ ∈

Example 1 continued. Consider again F in Example 1, and the same interpretation I.
grI [F] is the following set of formulas.
(Amount 1 = 0) ∨ ¬(Amount 1 = 0) ← Amount 0 = 0+1
(Amount 1 = 1) ∨ ¬(Amount 1 = 1) ← Amount 0 = 1+1
...
Amount 1 = 10 ← FillUp
For any two interpretations I, J of the same signature and any list c of distinct
predicate and function constants, we write J <c I if
• J and I have the same universe and agree on all constants not in c;
• pJ ⊆ pI for all predicate constants p in c; and
• J and I do not agree on c.
The reduct F I of an inﬁnitary ground formula F relative to an interpretation I is
deﬁned as follows:
•
•
•
•

For each atomic formula F, F I = ⊥ if I |= F and F I = F otherwise;
(H∧ )I = ⊥ if I |= H∧ ; otherwise (H∧ )I = {GI | G ∈ H}∧ ;
(H∨ )I = ⊥ if I |= H∨ ; otherwise (H∨ )I = {GI | G ∈ H}∨ ;
(G → H)I = ⊥ if I |= G → H; otherwise (G → H)I = GI → H I .

Theorem 1
Let F be a ﬁrst-order sentence of signature σ and let c be a list of intensional
constants. For any interpretation I of σ, I |= SM[F; c] iﬀ
• I satisﬁes F, and
• every interpretation J such that J <c I does not satisfy (grI [F])I .
Example 1 continued. The reduct (grI [F])I is equivalent to
(Amount 1 = 5) ∨ ⊥ ← Amount 0 = 5+1.

(2)

No interpretation that is diﬀerent from I only on Amount 1 satisﬁes the reduct. On the
other hand, the reduct (grI1 [F])I1 is equivalent to ⊥ ∨ ¬⊥ ← Amount 0 = 5+1, and
other interpretations that are diﬀerent from I1 only on Amount 1 satisfy the reduct.
2.3 Review: original deﬁnition of the cabalar semantics
2.3.1 Partial interpretation
We ﬁrst deﬁne the notion of a partial interpretation. Given a ﬁrst-order signature
σ comprised of function and predicate constants, a partial interpretation I of σ
consists of
• a non-empty set |I|, called the universe of I;

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

868

M. Bartholomew and J. Lee
• for every function constant f of arity n, a function f I from (|I| ∪ {u})n to
|I| ∪ {u}, where u is not in |I| (“u” stands for undeﬁned);
• for every predicate constant p of arity n, a function pI from (|I| ∪ {u})n to
{true, false}.

For each term f(t1 , . . . , tn ), we deﬁne

u
f(t1 , . . . , tn )I =
f I (tI1 , . . . , tIn )

if tIi = u for some i ∈ {1, . . . , n};
otherwise.

The satisfaction relation |=p between a partial interpretation I and a ﬁrst-order
formula F is the same as the one for ﬁrst-order logic except for the following base
cases:
• For each atomic formula p(t1 , . . . , tn ),

false
if tIi = u for some i ∈ {1, . . . , n};
I
p(t1 , . . . , tn ) =
pI (tI1 , . . . , tIn ) otherwise.
• For each atomic formula t1 = t2 ,

true
(t1 = t2 )I =
false

if tI1 = u, tI2 = u, and tI1 = tI2 ;
otherwise.

We say that I |=p F if F I = true.
Observe that under a partial interpretation, t = t is not necessarily true: I |=p t = t
iﬀ tI = u. On the other hand, ¬(t1 = t2 ), also denoted by t1 = t2 , is true under I
even when both tI1 and tI2 are mapped to the same u.
2.3.2 Functional equilibrium models by cabalar
Given any two partial interpretations J and I of the same signature σ, and a set of
constants c, we write J c I if
• J and I have the same universe and agree on all constants not in c;
• pJ ⊆ pI for all predicate constants in c; and
• f J (ξ) = u or f J (ξ) = f I (ξ) for all function constants in c and all lists ξ of
elements in the universe.
We write J ≺c I if J c I but not I c J. Note that J ≺c I is deﬁned similar to
J <c I (Section 2.2.2) except for the treatment of functions.
A PHT-interpretation (“Partial HT-interpretation”) I of signature σ is a tuple
Ih , It  such that Ih and It are partial interpretations of σ that have the same
universe.
between a PHT-interpretation I, a world w ∈ {h, t}
The satisfaction relation |=
pht
ordered by h < t , and a ﬁrst-order sentence F of the signature σ is deﬁned
recursively:
F if Iw |=p F;
• If F is an atomic formula, I, w |=
pht
• I, w |=
F ∧ G if I, w |=
F and I, w |=
G;
pht
pht
pht
• I, w |=
F ∨ G if I, w |=
F or I, w |=
G;
pht
pht
pht

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

On the stable model semantics for intensional functions

869

F → G if, for every world w  such that w 6 w  , I, w  |=
F or I, w  |=
G;
• I, w |=
pht
pht
pht

∀xF(x) if, for every ξ ∈ |I|, I, w |=
F(ξ );
• I, w |=
pht
pht

∃xF(x)
if,
for
some
ξ
∈
|I|,
I,
w
|
=
F(ξ
).
• I, w |=
pht
pht
F, if I, h |=
F.
We say that an HT-interpretation I satisﬁes F, written as I |=
pht
pht
A PHT-interpretation I = I, I of signature σ is a partial equilibrium model of a
sentence F relative to c if
F, and
• I, I |=
pht
F.
• for every partial interpretation J such that J ≺c I, we have J, I |=
pht

3 Reformulations
3.1 Cabalar semantics in terms of grounding and reduct
The Cabalar semantics can also be reformulated in terms of grounding and reduct.
A theorem similar to Theorem 1 can be stated for the Cabalar semantics.
Theorem 2
Let F be a ﬁrst-order sentence of signature σ and let c be a list of intensional
constants. For any partial interpretation I of σ, I, I is a partial equilibrium model
of F iﬀ
• I |=p F, and
• for every partial interpretation J of σ such that J ≺c I, we have J |=p grI [F]I .
Example 1 continued. Consider the same F, I, and the reduct grI [F]I , which is
equivalent to (2). If we view I as a partial interpretation, there is only one partial
interpretation J such that J ≺c I, which agrees with I except Amount J1 = u. Clearly, J
does not satisfy the reduct. In accordance with Theorem 2, I, I is a partial equilibrium
model of F.
Interestingly, this reformulation of the Cabalar semantics is closely related to the
language ASP{f} (Balduccini 2012b). We discuss the details in Section 6.
Comparing the reformulation of the Cabalar semantics in Theorem 2 and the
reformulation of the Bartholomew-Lee semantics in Theorem 1 tells us that the
reducts are deﬁned in the same way, whereas interpretations we consider for
stability checking and the notions of satisfaction are diﬀerent. That is, if the
intensional constants are function constants only, under the Bartholomew-Lee
semantics, the interpretations J we consider for stability checking are all other
classical interpretations that are diﬀerent from I, while under the Cabalar semantics,
they are partial interpretations that are “smaller” than I. For instance, in Example 1,
there are multiple such Js for the Bartholomew-Lee semantics, while there is only
one such J for the Cabalar semantics.
In Section 4, we present some syntactic classes of formulas on which the two
semantics coincide despite these diﬀerences.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

870

M. Bartholomew and J. Lee
3.2 Cabalar semantics in terms of second-order logic

The Cabalar semantics can also be formulated in the style of second-order logic.
We extend the formulas to allow predicate and function variables as in the
standard second-order logic, but consider partial interpretations in place of classical
interpretations. We deﬁne c  c as
(cpred 6 cpred ) ∧ (cfunc 6 cfunc ),
where cpred 6 cpred is deﬁned as in Section 2.1, and cfunc 6 cfunc is deﬁned as the
conjunction of
∀x((
f(x) = 
f(x)) ∨ (
f(x) = f(x))).
f in
for all function constants f in cfunc and the corresponding function variables 
cfunc . As we explained earlier, the ﬁrst disjunctive term is satisﬁable under a partial
interpretation, meaning that 
f is undeﬁned on x; the second disjunctive term means
that 
f and f are both deﬁned on x and map to the same element in the universe.
We deﬁne c ≺ c as (c  c) ∧ ¬(c  c).
We reformulate the Cabalar semantics by using the expression CBL that looks
similar to SM. It is deﬁned as:
CBL[F; c] = F ∧ ¬∃c(c ≺ c ∧ F † (c)),
where F † (c) is deﬁned the same as F ∗ (c) in Section 2.1 except for the base case:
• When F is an atomic formula, F † (c) is F(c) (as deﬁned in Section 2.1).

3

The following theorem states the correctness of the reformulation.
Theorem 3
For any sentence F, a PHT-interpretation I, I is a partial equilibrium model of F
relative to c iﬀ I |=p CBL[F; c].
Note the similarity between this reformulation of the Cabalar semantics given
in Theorem 3 and the deﬁnition of SM in Section 2.1. The diﬀerences are in the
comparison operators ≺ vs. <, and whether to consider partial interpretations or
classical interpretations.
3.3 Bartholomew-Lee semantics in terms of HT-Logic
The Bartholomew-Lee semantics can be reformulated in terms of a modiﬁcation to
equilibrium logic, similar to the way the Cabalar semantics is deﬁned in Cabalar
(2011), and is also reviewed in Section 2.3
An FHT-interpretation (“Functional HT-interpretation”) I of signature σ is a
tuple Ih , It  such that Ih and It are classical interpretations of σ that have the
same universe. The satisfaction relation |=fht between an FHT-interpretation I, a
world w ∈ {h, t} ordered by h < t, and a ﬁrst-order sentence of signature σ is deﬁned
3

In fact, F ∗ (c) can be also used in place of F † (c) for deﬁning CBL[F; c] as well, without aﬀecting the
models.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

On the stable model semantics for intensional functions

871

for PHT-interpretations in Section 2.3 except for the base
in the same way as |=
pht
case:
• If F is an atomic formula, I, w |=fht F if, for every world w  such that w 6 w  ,

Iw |= F.
We say that FHT-interpretation I satisﬁes F, written as I |=fht F, if I, h |=fht F.
The following theorem asserts the correctness of the reformulation of the
Bartholomew-Lee semantics in terms of equilibrium logic style.
Theorem 4
Let F be a ﬁrst-order sentence of signature σ and let c be a list of predicate and
function constants. For any interpretation I of σ, I |= SM[F; c] iﬀ
• I, I |=fht F, and
• for every interpretation J of σ such that J <c I, we have J, I |=fht F.
4 Comparing Bartholomew-Lee semantics and cabalar semantics
Neither semantics is stronger than the other. The following example presents a
formula that has a stable model under the Cabalar semantics, but not under the
Bartholomew-Lee semantics.
Example 2
SM[f = g; f, g] has no models if the universe contains more than one element.
Take any I such that I |= f = g. The reduct of f = g relative to I is f = g itself,
and there are other models of the reduct. Since I is not the unique model of the
reduct, I is not a (f, g)-stable model of f = g. On the other hand, assuming that
the universe is {1, 2, 3}, an interpretation I that assigns 1 to both f and g satisﬁes
CBL[f = g; f, g]. The reduct is the same as before, but any interpretation J smaller
than I maps either or both f and g to u, and hence does not satisfy the reduct.
Similarly, there are two other models of CBL[f = g; f, g] with the same universe.
On the other hand, in the following example, the formula has a stable model
under the Bartholomew-Lee semantics, but not under the Cabalar semantics.
Example 3
Let F be the formula f(1) = 1 ∧ f(2) = 1 ∧ (f(g) = 1 → g = 1), and I be an
interpretation such that the universe is {1, 2}, and 1I = 1, 2I = 2, f(1)I = 1,
f(2)I = 1, g I = 1. One can check that I is a model of SM[F; f, g], but not a model
of CBL[F; f, g].
4.1 Coincidence on c-plain formulas
This section presents a syntactic class of formulas, called “c-plain,” on which the
Bartholomew-Lee semantics and the Cabalar semantics coincide when we consider
“total” interpretations only. A partial interpretation I is called total if I does not
map any function constant to u. Obviously, a total interpretation can be identiﬁed
with the classical interpretation.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

872

M. Bartholomew and J. Lee

For any function constant f, a ﬁrst-order formula F is called f-plain if each
atomic formula in F
• does not contain f, or
• is of the form f(t) = t1 where t is a list of terms not containing f, and t1 is a
term not containing f.
For example, f = 1 is f-plain, but each of p(f), g(f) = 1, and 1 = f is not f-plain.
For a list c of predicate and function constants, we say that F is c-plain if F is
f-plain for each function constant f in c. Roughly speaking, c-plain formulas do
not allow the functions in c to be nested in another predicate or function, and at
most one function in c is allowed in each atomic formula. For example, the formula
in (1) in Example 1 is Amount 1 -plain; f = g (Example 2) is not (f, g)-plain (because
it is not g-plain), and neither is f(g) = 1 → g = 1 (Example 3).
The following theorem states that the two semantics coincide on c-plain formulas.
Theorem 5
For any c-plain sentence F of signature σ, any list c of intensional constants, and
any total interpretation I of σ satisfying ∃xy(x = y), I |= SM[F; c] iﬀ I |=p CBL[F; c].
In accordance with the theorem, we already noted that the two semantics coincide
on formula (1). Examples 2 and 3 above demonstrate why the restriction to cplain formulas is necessary in Theorem 5. This theorem is useful in relating several
mathematical results established for the Bartholomew-Lee semantics to the Cabalar
semantics as we will see in Section 5 and Appendix B.
The requirement in Theorem 5 that every occurrence of every atomic formula
be c-plain can be relaxed if the formula is tight.4 An occurrence of a symbol or a
subformula in a formula F is called strictly positive in F if that occurrence is not in
the antecedent of any implication in F. We say that a formula is head-c-plain if every
strictly positively occurring atomic formula is c-plain. For instance, f(g) = 1 → h = 1
is head-(f, g, h)-plain, though it is not (f, g, h)-plain.
Theorem 6
For any head-c-plain sentence F of signature σ that is tight on c, and any total
interpretation I of σ satisfying ∃xy(x = y), I |= SM[F; c] iﬀ I |=p CBL[F; c].
4.2 Diﬀerent behaviors for nested functions
Theorem 5 can be extended to non-c-plain formulas by ﬁrst unfolding F, which,
roughly speaking, moves nested functions outside by introducing existential quantiﬁers and variables. The process of unfolding F w.r.t. c, denoted by UF c (F), is
formally deﬁned as follows.
• If F is of the form p(t1 , . . . , tn ) (n > 0) such that tk1 , . . . , tkj are all the terms in
t1 , . . . , tn that contain some members of c, then UF c (p(t1 , . . . , tn )) is

	

∃x1 . . . xj p(t1 , . . . , tn ) ∧
UF c (tki = xi )
16i6j

4

Tight formulas are deﬁned in (Bartholomew and Lee 2013) and also reviewed in Appendix A.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

On the stable model semantics for intensional functions

873

where p(t1 , . . . , tn ) is obtained from p(t1 , . . . , tn ) by replacing each tki with the
variable xi .
• If F is of the form f(t1 , . . . , tn ) = t0 (n > 0) such that tk1 , . . . , tkj are all the
terms in t0 , . . . , tn that contain some members of c, then UF c (f(t1 , . . . , tn ) = t0 )
is

	

∃x1 . . . xj (f(t1 , . . . , tn ) = t0 ) ∧
UF c (tki = xi )
06i6j


where (f(t1 , . . . , tn ) = t0 ) is obtained from f(t1 , . . . , tn ) = t0 by replacing each
tki with the variable xi .
• UF c (F  G) is UF c (F)  UF c (G) where  ∈ {∧, ∨, →}.
• UF c (QxF) is Qx UF c (F(x)) where Q ∈ {∀, ∃}.
For example, UF (f,g) (f = g) is ∃xy(x = y ∧ f = x ∧ g = y).
It is clear that UF c (F) is equivalent to F under classical logic. Similarly, Theorem 7
below shows that the Cabalar semantics preserves stable models when unfolding is
applied. However, this is not the case under the Bartholomew-Lee semantics.
Theorem 7
For any sentence F, any list c of constants, and any partial interpretation I, we have
I |=p CBL[F; c] iﬀ I |=p CBL[UF c (F); c].
Example 4
Let F be f = g. Recall that UF c (F) is ∃xy(x = y ∧ f = x ∧ g = y). Let I1 , I2 , I3 be
interpretations whose universe is {1, 2, 3}, and each Ii maps f and g to i (1 6 i 6 3).
Each of them satisﬁes CBL[F; f, g] and CBL[UF (f,g) (F); f, g], but as we observed,
none of them is a model of SM[F; f, g].
However, since UF c (F) is c-plain, the following corollary follows from Theorems 5
and 7.
Corollary 1
For any sentence F, any list c of constants, and any total interpretation I satisfying
∃xy(x = y), we have I |=p CBL[F; c] iﬀ I |=p CBL[UF c (F); c] iﬀ I |= SM[UF c (F); c].
For example, SM[UF (f,g) (f = g); f, g] has the same models as CBL[f = g; f, g].

5 Relating the cabalar semantics to general stable models
Corollary 1 tells us that the results established for the Bartholomew-Lee semantics
can be transferred to the Cabalar semantics as long as we are interested in total
interpretations only. For instance, (Bartholomew and Lee 2012) shows a method of
eliminating intensional function constants in favor of intensional predicate constants;
(Bartholomew and Lee 2013) shows that, for tight programs, the stable model
semantics and completion coincide. These results can be extended to the Cabalar
semantics as well by ﬁrst rewriting the formula to be c-plain by applying unfolding
(Theorem 7), and then applying Corollary 1 since the two semantics coincide on
c-plain formulas.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

874

M. Bartholomew and J. Lee

Below we show how to turn formulas under the Cabalar semantics into formulas
under the stable model semantics from (Ferraris et al. 2011). The method is similar
to the one from (Bartholomew and Lee 2012). This is done by eliminating intensional
functions under the Cabalar semantics in favor of intensional predicates.
Let F be an f-plain formula, where f is an intensional function constant. Formula
Fpf is obtained from F as follows:
• in the signature of F, replace f with a new intensional predicate constant p of
arity n + 1, where n is the arity of f;
• replace each subformula f(t) = t in F with p(t, t ).
Theorem 8
For any f-plain sentence F and any partial interpretation I, if I |=p ∀xy(p(x, y) ↔
f(x) = y), then I |=p CBL[F; f, c] iﬀ I |=p CBL[Fpf ; p, c].
By UEC p , we denote the following formulas that enforce the functional image on
the predicate p:
∀xyz(y = z ∧ p(x, y) ∧ p(x, z) → ⊥),
(3)
¬¬∀x∃y p(x, y),
where x is a n-tuple of variables, and all variables in x, y, and z are pairwise distinct.
Note that each formula is a constraint,5 which can only remove stable models when
it is added.
The following corollary shows that there is a simple 1–1 correspondence between
the models of F and the models of Fpf . Recall that the signature of Fpf is obtained
from the signature of F by replacing f with p. For any interpretation I of the
signature of F, by Ipf we denote the interpretation of the signature of Fpf obtained
from I by replacing the function f I with the set pI that consists of the tuples
ξ1 , . . . , ξn , f I (ξ1 , . . . , ξn )
for all ξ1 , . . . , ξn from the universe of I. The notations are straightforwardly extended
to Fpf and Ipf where f and p are lists of function and predicate constants.
Corollary 2
Let F be an f-plain sentence. (a) For any partial interpretation I of the signature of
F, I |=p CBL[F; f, c] iﬀ Ipf |=p CBL[Fpf ∧UEC p ; p, c]. (b) For any partial interpretation
J of the signature of Fpf , J |=p CBL[Fpf ∧ UEC p ; p, c] iﬀ J = Ipf for some partial
interpretation I such that I |=p CBL[F; f, c].
Repeated applications of Corollary 2 tells us that all intensional functions
under the Cabalar semantics can be eliminated in favor of intensional predicates,
which essentially reduces the Cabalar semantics to the ﬁrst-order stable model
semantics deﬁned in Ferraris et al. (2011). In the following cfp denotes the list of
constants where every member of f in c is replaced with a new predicate constant
in p.
5

A rule with the empty head, or a formula that has no strictly positive occurrence of an atom (Ferraris
et al. 2011).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

On the stable model semantics for intensional functions

875

Corollary 3
Let c be a set of intensional constants consisting of intensional function constants f
and intensional predicate constants, and let F be an c-plain sentence. (a) For any total
interpretation I of the signature of F, I |=p CBL[F; c] iﬀ Ipf |= SM[Fpf ∧ UEC p ; cfp ].
(b) For any total interpretation J of the signature of Fpf , J |= SM[Fpf ∧ UEC p ; cfp ] iﬀ
J = Ipf for some total interpretation I such that I |=p CBL[F; c].
Corollary 3 generalizes Theorem 1 from (Cabalar 2011), which restricted F to be in
the syntax of “FLP rules.” The corollary is similar to Corollary 2 from (Bartholomew
and Lee 2012), which shows how to turn c-plain formulas under the BartholomewLee semantics to formulas under the ﬁrst-order stable model semantics. On the other
hand, since any formula under the Cabalar semantics can be turned into a c-plain
formula (Corollary 1), Corollary 3 can be extended to arbitrary formulas.

6 Comparing cabalar semantics and balduccini semantics
Due to lack of space, we refer the reader to the online appendix for the review of
the Balduccini Semantics.
It turns out that the Balduccini semantics is closely related to the Cabalar
semantics. This is shown by reformulating the Balduccini semantics using the notion
of partial interpretations and partial satisfaction. We identify a consistent set of
seed literals I with a partial interpretation that maps all object constants in σ \ c to
themselves. For example, for signature σ = {f, g, 1, 2} where f, g ∈ c, we identify the
consistent set of seed literals I = {f = 1} with the partial interpretation I such that
f I = 1, g I = u, 1I = 1, 2I = 2.
The following theorem states that, in the absence of strong negation, Balduccini
semantics can be viewed as a special, ground case of the Cabalar semantics.
Theorem 9
For any ASP{f} program Π with intensional constants c and any consistent set I
of seed literals, if Π contains no strong negation, then I is a Balduccini answer set
of Π iﬀ I |=p CBL[Π; c].
Theorem 9 can be extended to full ASP{f} programs that contain strong negation.
Since the language in Cabalar (2011) does not allow strong negation, this requires
us to eliminate strong negation. It is well known that strong negation in front of
standard atoms can be eliminated using new atoms.
In order to eliminate strong negation in front of t-atoms, by Π# we denote the
program obtained from Π by replacing ∼ (f = g) with (f = f) ∧ (g = g) ∧ ¬(f = g).
As we noted earlier, this formula is true iﬀ f I and g I are deﬁned, and have diﬀerent
values. This is the same understanding as the construct f#g in (Cabalar 2011).
Theorem 10
For any ASP{f} program Π with intensional constants c and any consistent set I of
seed literals, I is a Balduccini answer set of Π iﬀ I is a Balduccini answer set of Π# .

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

876

M. Bartholomew and J. Lee
7 Conclusion

We presented several reformulations of functional stable models—in terms of secondorder logic, in terms of grounding and reduct, and in terms of variants of the logic
of here-and-there. The reformulations helped us compare them and identify the
relationships between them. The functional stable model semantics by Bartholomew
and Lee is simpler as it does not need to rely on the extra notion of partial
satisfaction, but is limited to total interpretations only. On the other hand, the
Cabalar semantics and its special case, the Balduccini semantics, allow functions to
be undeﬁned at the price of relying on a rather complicated non-standard deﬁnition
of partial satisfaction. Nevertheless, all three semantics coincide on large syntactic
classes of formulas.
Acknowledgements: We are grateful to Pedro Cabalar and the anonymous referees for
their useful comments. This work was partially supported by the National Science
Foundation under Grant IIS-0916116 and by the South Korea IT R&D program
MKE/KIAT 2010-TD-300404-001.

References
Balduccini, M. 2012a. An answer set solver for non-Herbrand programs: Progress report.
In ICLP (Technical Communications), 49–60.
Balduccini, M. 2012b. A ”conservative” approach to extending answer set programming
with non-Herbrand functions. In Correct Reasoning - Essays on Logic-Based AI in Honour
of Vladimir Lifschitz, 24–39.
Bartholomew, M. and Lee, J. 2012. Stable models of formulas with intensional functions.
In Proceedings of International Conference on Principles of Knowledge Representation and
Reasoning (KR), 2–12.
Bartholomew, M. and Lee, J. 2013. Functional stable model semantics and answer set
programming modulo theories. In Proceedings of International Joint Conference on Artiﬁcial
Intelligence (IJCAI), To appear.
Cabalar, P. 2011. Functional answer set programming. TPLP 11, 2-3, 203–233.
Ferraris, P., Lee, J. and Lifschitz, V. 2011. Stable models and circumscription. Artiﬁcial
Intelligence 175, 236–263.
Lifschitz, V. 2012. Logic programs with intensional functions. In Proceedings of International
Conference on Principles of Knowledge Representation and Reasoning (KR), 24–31.
Lifschitz, V., Morgenstern, L. and Plaisted, D. 2008. Knowledge representation and
classical logic. In Handbook of Knowledge Representation, F. van Harmelen, V. Lifschitz
and B. Porter, Eds. Elsevier, 3–88.
Truszczynski, M. 2012. Connecting ﬁrst-order ASP and the logic FO(ID) through reducts.
In Correct Reasoning - Essays on Logic-Based AI in Honour of Vladimir Lifschitz, 543–559.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:28:08, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068413000549

Technical Communications of ICLP 2015. Copyright with the Authors.

1

Automated Reasoning about XACML 3.0 Delegation
Using Answer Set Programming
JOOHYUNG LEE and YI WANG
Arizona State University, Tempe, AZ, USA (e-mail: {joolee,ywang485}@asu.edu)

YU ZHANG
Intel, Chandler, AZ, USA (e-mail: yzhan289@asu.edu)
submitted 29 April 2015; accepted 5 June 2015

Abstract
XACML is an XML-based declarative access control language standardized by OASIS. Its latest version
3.0 has several new features including the concept of delegation for decentralized administration of access
control. Though it is important to avoid unintended consequences of ill-designed policies, delegation makes
formal analysis of XACML policies highly complicated. In this paper, we present a logic-based approach
to XACML 3.0 policy analysis. We formulate XACML 3.0 in Answer Set Programming (ASP) and use
ASP solvers to perform automated reasoning about XACML policies. To the best of our knowledge this is
the first work that fully captures the XACML delegation model in a formal executable language.
KEYWORDS: Policy, XACML, Delegation, Answer Set Programming

1 Introduction
Policy-based computing is being widely adopted to accommodate security requirements for
large, complex, distributed, heterogenous computing environments. Extensible Access Control
Markup Language (XACML) is an XML-based declarative access control policy language, standardized by the Organization for the Advancement of Structured Information Standards (OASIS). The latest version, XACML 3.0, was standardized in 2013, and is significantly more enhanced and expressive than the previous version by introducing several new features, such as
multiple decision profile, delegation, obligation/advice expressions, and more enhanced combining algorithms. In particular, delegation in XACML 3.0 is an important addition to facilitate
decentralized administration of access control for a large scale distributed systems. In the previous version of XACML, any policy is assumed to be trusted, but how to ensure such trust was not
specified. This actually puts strict constraints on policy makers’ authority verification in practice
and therefore restricts the number of policy issuers to be handful, which does not meet the need
of modern distributed systems. In contrast, in XACML 3.0, anyone can write policies to permit
or deny an access, but not all these policies would be trusted. XACML 3.0 provides a means
of ensuring how untrusted policies are properly authorized by a delegation chain from trusted
policies. This mechanism provides a flexible decentralized access control management reducing the administration cost of the organization. On the other hand, it makes formal analysis of
XACML 3.0 highly complicated. Lack of such analysis jeopardizes safety-critical applications
by being vulnerable to unexpected consequences originating from complex dependencies among
distributed policies. Due to the complexity, there are few implementations that fully support the
delegation model in XACML 3.0.

2

J. Lee, Y. Wang and Y. Zhang

In this paper, we present a logic-based approach to formal reasoning about XACML policies.
We turn the semi-formal XACML 3.0 specification from the OASIS standard document (OASIS
2013) into a formal description, turn that further into the language of Answer Set Programming
(ASP), and show how ASP solvers can be used to perform various logical reasoning and analysis
of policies.
Our goal is not on improving XACML, but on formalizing the language as described in the
standard document as closely as possible.1 This is a challenging task. The syntax of XACML
is XML, which is verbose. The semantics there is described in English, which reads humanfriendly, but is lacking some precision and is sometimes ambiguous. In order to facilitate the
formulation of XACML in ASP, we first construct an abstract syntax and the formal semantics of XACML. It is rather straightforward to turn that further into ASP, which illustrates the
expressivity of ASP.
In comparison with the previous work on formalizing XACML 2.0 (Ahn et al. 2010; Hughes
and Bultan 2004; Bryans 2005; Fisler et al. 2005; Kolovski et al. 2007), which mostly focused on
representing combining algorithms, our work provides a comprehensive coverage of XACML
3.0, such as delegation, the new structure of htargeti, new combining algorithms, and indeterminate values. The combining algorithms of XACML 2.0 were formalized in other logical
languages as well, such as description logic (Kolovski et al. 2007) and the language of Alloy
(Hughes and Bultan 2004), but it is not apparent how those approaches can be extended to handle delegation, which requires reasoning about reachability. To the best of our knowledge, the
work presented here is the first one that fully captures the XACML 3.0 delegation model in a
formal executable language. Due to the space limit, we defer the description of other features in
a longer version.
2 XACML 3.0
2.1 Access vs. Administrative Policies in XACML 3.0
In XACML 3.0, policies are either access policies or administrative policies. An access policy
specifies access rights based on the attributes of possible access requests. This type of policies
is present in XACML 2.0, but XACML 3.0 has added an optional new element hPolicyIssueri,
whose authority needs to be verified. An example is “Bob says Alice can access printers,”
where Bob is the policy issuer, Alice is the requesting subject, and printer is the requested
resource. An administrative policy specifies the authorization of a delegate to issue policies
regarding the attributes. This type of policies also has an optional element hPolicyIssueri, and
may need to be further verified. An example is “Carol says Bob has the right to let Alice access
printers.” This does not mean that the delegate Bob has the right unless the authority of the
policy issuer Carol is verified. The process of finding a valid authorization of a delegation is
called reduction.
2.2 Abstract Syntax of XACML 3.0
XACML is mainly an Attribute Based Access Control system (ABAC), in which attributes associated with a user, an action, or a resource are inputs to the decision of whether the user may
access the resource in a particular way.
Table 1 summarizes each syntax component of XACML 3.0. An attribute consists of AttrIdentifier
and AttrVal, and an AttrIdentifier in turn consists of an attrID, a category, and an issuer. The
1

Thus comparing XACML with other policy languages, such as SecPAL, is out of scope of this paper.

Automated Reasoning about XACML 3.0 Delegation Using Answer Set Programming
Component
PDP
PolicySet
Policy
Rule
Target
AnyOf
AllOf
Match
AttrIdentifier
AttrVal
AttrRetriever

Abstraction

Component

hh(Policy|PolicySet)* i, combAlgi
hTarget, h(Policy|PolicySet)+ i,
combAlg, Issuer, maxDelDepi
hTarget, hRule+ i, combAlg, Issuer,
maxDelDepi
hTarget, effect, conditioni
∗
{AnyOf }
{AllOf + }
{Match+ }
hmFunc, AttrRetriever, AttrVali
hattrID, category, attrIssueri
hdataType, valuei
hAttrIdentifier, mustBePresenti

Issuer
Request
maxDelDep
combAlg
attrID
attrIssuer
dataType
value
effect
condition
mFunc
category
mustBePresent

3

Abstraction
{hAttrIdentifier, AttrVali* }
{hAttrIdentifier, AttrVali+ }
a nonnegative integer or inf (∞)
po | do | pud | dup | fa | ooa | ...
a string
a string
string | integer | date |...
a value of the corresponding data-type
permit | deny
a boolean function call
a boolean function
subject | resource | action | ...
true | false

Table 1: XACML 3.0 elements abstraction

AttrVal of the attribute is a value of a specific datatype. An attribute retriever (AttrRetriever)
consists of an AttrIdentifier and a Boolean value mustBePresent. A request is formed by conjoining all the attributes in the request context.
A match is a simple attribute matching condition. It contains an AttrRetriever for the attribute
to be matched, a value (AttrVal) that the identified attribute is supposed to match, and a matching
function (mFunc) for comparison between the actual value and the value specified in the match.
An allOf represents the conjunction of matchs. An anyOf represents the disjunction of allOf s.
A target represents the conjunction of anyOf s, and in this way it expresses a complex attribute
matching condition.
A rule represents a single statement about whether a request satisfying certain conditions
(expressed by condition and target elements) should be granted access or not. The intended
effect of the rule to applicable requests is specified by its effect.
A policy consists of a set of rules, a target, a “rule-combining algorithm” (combAlg), which
specifies the way how conflicting decisions from children rules are combined, a set of attributes describing the policy’s issuer, and a nonnegative integer called maximum delegation
depth (maxDelDep), which limits the depth of any delegation that is authorized by this policy.
The issuer of a policy can be null, indicating that the policy is trusted. A policy set is similar
to a policy except that it contains a set of children policies and policy sets. The PDP consists of
the set of all top level policies/policy sets and a policy-combining algorithm.
pdp
deny-unless-permit

ps1
Issuer: trusted
CombAlg: first-applicable
Target: any

p2
Issuer: trusted
Target:
Subject: patient
Resource: record
Action: modify
RuleEffect: deny

p3
Issuer: trusted
Target:
Subject: patient
Resource: record
Action: read
IsBusinessHour: false
RuleEffect: deny

p1
Issuer: trusted
Target:
Delegate: record_admin
DelegatedResource: record
RuleEffect: permit
MaxDep: 2

p4
Issuer: trusted
Target:
Subject: doctor
Resource: record
Action: modify
IsBusinessHour: false
RuleEffect: deny

p5
Issuer: hospital_manager
Target:
Subject: doctor
Resource: record
Action: modify/read
IsBusinessHour: true
RuleEffect: permit

ps2
Issuer: record_admin
CombAlg: first-applicable
Target: any
MaxDep: 5

p6
Issuer: trusted
Target:
Delegate: doctor
DelegatedSubject: patient
DelegatedResource: record
DelegatedAction: read
DelegatedIsBusinessHour:true
RuleEffect: permit
MaxDep: 5

Fig. 1: Policy Hierarchy of Example 1

Example 1

Access request

p7
Issuer: trusted
Target:
Delegate: hospital_manager
DelegatedSubject: doctor
DelegatedResource: record
DlegatedAction: modify/read
RuleEffect: permit
MaxDep:3

4

J. Lee, Y. Wang and Y. Zhang

Consider the following access control requirements for patient records.
(1)
(2)
(3)
(4)
(5)
(6)
(7)

Record administrators can delegate any rights associated with records.
Hospital managers are allowed to delegate any right associated with records to doctors.
Patients cannot modify records.
Patients cannot read records during non-business hours.
Doctors cannot modify records during non-business hours.
Doctors are allowed to read or modify records during business hours.
Doctors may allow patients to read their records during business hours.
Figure 1 shows the policy hierarchy of this example. Policy p1 expresses requirement (1)
above. It is trusted with the maximum delegation depth 2, meaning that a delegation chain starting from p1 should be aborted if it goes through more than 2 policies or policy sets. Policy set
ps1 is trusted and has the first-applicable policy-combining algorithm. Policies p2,
p3, p4 are children policies of ps1, describing requirements (3), (4), and (5) above, respectively. Policy set ps2 is issued by record admin, again having the policy-combining algorithm first-applicable. Policies p5, p6 and p7 are children of ps2, describing (6), (7)
and (2) respectively.
2.3 Semantics
The semantics of XACML 3.0 describes how to make a decision on a request based on the policy
description. A decision is any one of the following values: permit (p), deny (d), indeterminateP
(ip ), indeterminateD (id ), indeterminateDP (idp ), and notApplicable (na). A decision is
applicable if it is not na. Given an access request consisting of certain attributes, a rule evaluates
to a single decision. A policy combines the decisions from its children rules to a single decision
according to its rule combining algorithm. Similarly, a policy set combines the decisions from
its children policies/policy sets into a single decision according to its policy combining algorithm. At the top level, the PDP returns a single decision as if it had evaluated a single policy set
consisting of the set of all top level policies/policy sets.
Below, for each element E, we formally define the function evalE (e, Rq) that maps to a value
the specific instance of E denoted by e and the request Rq.
2.3.1 Evaluation of Rules
In order to determine a rule’s decision, its target needs to be evaluated first, whose value is
either match (m), no match (nm) or indeterminate (i). In XACML 3.0, a target is a Boolean
combination of matchs using allOf s (conjunctions) and anyOf s (disjunctions). Due to lack of
space, we skip the details of evaluation of Target and its descendants.
Given a rule R = hTarget, eff , condi and a request Rq,


eff
evalRule (R, Rq) = na


ieff

if evalT arget (Target, Rq) = m and cond is true
if evalT arget (T arget, Rq) = nm or cond is false
otherwise.

(1)

2.3.2 Evaluation of Policies
Given a policy P = hT, hR1 , . . . , Rn i, alg, Issuer, maxDelDepi, and a request Rq, we define
combDec(P, Rq) = alg(DECP ), where DECP is the list of decisions hevalRule (R1 , Rq), . . . ,
evalRule (Rn , Rq)i, and alg denotes one of the combining algorithms specifying how the children rules’ decisions are combined. Combining algorithms in XACML 3.0 are more refined than
those in XACML 2.0, but since they are not new, we skip the details.

Automated Reasoning about XACML 3.0 Delegation Using Answer Set Programming

5

The evaluation of a policy P against a request Rq is defined as:


combDec(P, Rq) if evalT arget (T, Rq) = m




if evalT arget (T, Rq) = nm
na
evalP olicy (P, Rq) = na
if evalT arget (T, Rq) = i and combDec(P, Rq) = na



i
if evalT arget (T, Rq) = i and combDec(P, Rq) = e (e ∈ {p, d})

e



ie
if evalT arget (T, Rq) = i and combDec(P, Rq) = ie (e ∈ {p, d, dp})
(2)

The value of this function is discarded if the policy is not trusted. The next section explains
how trust can be established.
2.3.3 The Reduction Process
A policy/policy set is said to be trusted if it does not have an issuer (or its issuer is null);
otherwise it is said to be untrusted. Any applicable decision from an untrusted policy/policy
set should go through a process called reduction to get authorized before they are combined into
their parent policy set’s decision. The reduction process is essentially a graph search to find a path
from the untrusted policy/policy set whose decision is being reduced to a trusted policy/policy
set.
In XACML 3.0, a policy/policy set concerning delegation is called an administrative policy/policy set. In these policy/policy set, attributes of the accesses that are allowed to be delegated have categories prefixed by “delegated:”, and a special category called “delegate”
is used to specify the attributes of the delegate. The approach that XACML 3.0 uses to check if
a decision of one policy/policy set PL is authorized by another policy/policy set PH, given the
context of a request Rq, is to generate a special request called administrative request based on
the content of Rq, a candidate decision (p or d), and the issuer of PL, and then check, using the
same evaluation for access requests, if PH evaluates to permit or deny upon this administrative
request. Intuitively, an administrative request is a request asking whether an issuer can authorize
an access. This process is formally defined as follows.
1) Generating
 administrative
	 requests: Given a policy/policy set P , a request Rq, and a decision e ∈ p, d, id , ip , idp to be reduced, the administrative request ARP,Rq,d is constructed.
Roughly speaking, the content is similar to the request Rq except that the categories of attributes
in the original access request are prefixed with “delegated:” and the policy issuer of P becomes the attribute of the administrative request with category “delegate.”
2) Constructing the reduction graph: In a policy set, once the administrative request w.r.t. a
request for each child policy/policy set is constructed, the authorization relations between children policies/policy sets can be calculated by evaluating each administrative request against each
policy/policy set. Based on the authorization relations, the reduction graph can be constructed.
We write evalP (·, ·) to denote either evalP olicy (·, ·) or evalP olicySet (·, ·). Given a policy set
PS and a request Rq, the reduction graph RGP S,Rq is defined as follows.
• The nodes of RGP S,Rq are the immediate children policies and policy sets of PS.
• There are 4 types of directed edges in the graph: PP, PI, DP and DI. For each ordered pair (P1 , P2 ) of policies/policy sets in PS, from P1 to P2 , (i) there is a PP edge if
evalP (P2 , ARP1 ,Rq,p ) = p; (ii) there is a PI edge if evalP (P2 , ARP1 ,Rq,p ) = id /ip /idp ;
(iii) there is a DP edge if evalP (P2 , ARP1 ,Rq,d ) = p; (iv) there is a DI edge if evalP (P2 , ARP1 ,Rq,d ) =
id /ip /idp ;
In the graph, we say that a path is a (i) PP path if it consists of PP edges only; (ii) PI path if

6

J. Lee, Y. Wang and Y. Zhang

it consists of PP and PI edges only; (iii) DP path if it consists of DP edges only; (iv) DI path if
it consists of DP and DI edges only.
3) Reduction of policies: Let P be a policy or a policy set and PS be the parent policy set of P .
We say that P is PP-authorized (DP-authorized / PI-authorized / DI-authorized, respectively)
if there is a PP (DP / PI / DI, respectively) path of length ≤ maxDelDep from P to a trusted
policy or policy set in RGP S,Rq , where maxDelDep is the maximum delegation depth of the
trusted policy or policy set.
We define the operator reduce(P, Rq) that maps a policy/policy set P to a decision or null,
w.r.t. a request as follows.


evalP (P, Rq) if P is trusted



p
if P is untrusted, evalP (P, Rq) = p and P is PP-authorized





d
if P is untrusted, evalP (P, Rq) = d and P is DP-authorized



i
if P is untrusted, evalP (P, Rq) = p and P is PI-authorized
p
reduce(P, Rq) =
id
if P is untrusted, evalP (P, Rq) = d and P is DI-authorized





i
if P is untrusted, evalP (P, Rq) = ie and P is PP-authorized or
e





DP-authorized or PI-authorized or DI-authorized (e ∈ {p, d, dp})



null otherwise.
(3)

Note that there is a mutual recursion between reduce(P, Rq) and evalP (P, Rq) (See Figure 3
for an example run).
2.3.4 Evaluation of Policy Sets
Policy set evaluation is similar to Policy evaluation. The only difference is that the decisions
from a policy set’s children policies/policy sets need to go through the reduction process before
being combined, possibly being disregarded if the reduction process determines that they are not
trusted.
Given a policy set P S = hT, hP1 , . . . , Pn i, alg, Issuer, maxDelDepi, and a request Rq,
define combDec(P S, Rq) = alg(DECP S ), where DECP S is the sequence of decisions obtained
by removing all null elements from hreduce(P1 , Rq), . . . , reduce(Pn , Rq)i. Other than this,
evalP olicySet (P S, Rq) is defined in the same way as evalP olicy (P S, Rq).
According to (OASIS 2013), the PDP is evaluated as a policy set with the policy-combining
algorithm specified in the PDP and all the top level policies and/or policy sets as its children.
Given the PDP defined as hcombAlg, hP1 , . . . , Pn ii where each Pi is a top level policy or policy set, the final decision of the PDP on a request Rq is defined by evalP DP (pdp, Rq) =
evalP olicySet (ps0 , Rq) where ps0 is the policy set h∅, hP1 , . . . , Pn i, combAlg, null, inf i
2.3.5 Example of Evaluation
Consider the policy hierarchy in Example 1 and the
access request rq by a doctor who wants to modPP, DP
p1
ps2
ify a record during business hours. According to the
PP, DP
p5
p7
evaluation semantics, all the children policies of ps1
ps1
are trusted. So none of them are disregarded. As
p6
all of them return notApplicable to rq, we have
RGPS2,rq
RGPDP,rq
evalP olicySet (ps1 , rq) = na.
Fig. 2: Reduction graph RGps2,rq and RGPDP,rq
Although p5 returns permit, p5 is untrusted, so the
decision of p5 needs to go through the reduction process. The reduction graph RGps2,rq has three
nodes, p5 , p6 , and p7 . The administrative request arp5 ,rq,p is generated. Evaluating arp5 ,rq,p

Automated Reasoning about XACML 3.0 Delegation Using Answer Set Programming

7

Evaluate rq against PDP
Reduce decision from ps2

Combine

Generate admin. req. arp1/ps1/ps2, rq, p/d
Reduce decision
from p1

Reduce decision
from ps1

Reduce decision
from ps2
Evaluate ar against ps1

Evaluate rq
against p1

Evaluate rq
against ps1
Combine

Reduce decision
from p2

Reduce decision
from p3

Evaluate rq
against p2

Evaluate rq
against p3

Reduce decision
from p4

Evaluate rq
against p4

Evaluate ar against p1

Evaluate ar against ps2

Evaluate rq
against ps2

Combine

Combine

…...

Reduce decision
from p5

Reduce decision
from p6

Reduce decision
from p7

Evaluate rq
against p5

Evaluate rq
against p6

Evaluate rq
against p7

Reduce decision
from p5

Reduce decision
from p6

Reduce decision
from p7

Evaluate ar
against p5

Evaluate ar
against p6

Evaluate ar
against p7

Fig. 3: Top-down procedure illustration: The tree structure on the left shows how PDP evaluation boils down to policy evaluations,
where arrows denote subroutine calls.

against p6 and p7 yields
evalP olicy (p7 , arp5 ,rq,p ) = p, evalP olicy (p6 , arp5 ,rq,p ) = na,
so there is a PP edge from p5 to p7 in the reduction graph RGps2 ,rq (Figure 2). Since p7 is trusted
and there is a PP path from p5 to p7 , the decision of p5 is authorized and is combined as permit.
Since the permit returned by p5 is the first applicable decision from ps2 ’s children policies, we
have evalP olicySet (ps2 , rq) = p.
However, again ps2 is untrusted, so the decision of ps2 needs to go through the reduction process. The reduction graph RGpdp,rq (Figure 2) has three nodes, p1 , ps1 and ps2 . The new administrative request arps2 ,rq,p has almost the same content as arp5 ,rq,p except that the delegate
category is filled with “record admin” instead of “hospital manager”. Evaluating arps2 ,rq,p against
p1 and ps1 , we have evalP olicy (p1 , arps2 ,rq,p ) = p. So there is a PP edge from ps2 to p1 .
As p1 is trusted and there is a PP path from ps2 to p1 , reduce(ps2 , rq) results in p. Since in
this example the PDP’s combining algorithm is deny-unless-permit, the final decision is permit:
evalP DP (pdp, rq) = p. Figure 3 shows the overall evaluation procedure.
3 Implementing XACML 3.0 in ASP
In this section, we show how to construct an ASP program such that, given the ASP representation of policy description and a request, its answer set corresponds to the PDP’s response to this
request. The basic idea is to represent the evaluation function that we constructed in the previous
section by ASP rules.
Due to lack of space, we refer the reader to http://reasoning.eas.asu.edu/xacml2asp
for the complete formalization of XACML 3.0 elements in ASP.
3.1 Representing XACML policy and requests as ASP facts
We first show how to represent each of XACML 3.0 elements as ASP facts. Given a policy
document, we assign a unique identifier (mostly an integer), denoted by Id(E), to each element.
• A policy set PS = hTarget, hP1 , . . . , Pn i, combAlg, Issuer, maxDelDepi is represented as
policySet(Id(PS), Id(Target), combAlg, Id(Issuer), maxDelDep).
hasChild(Id(PS), Id(Pi ), i).
(1 ≤ i ≤ n)
• A policy P = hTarget, hR1 , . . . , Rn i, combAlg, Issuer, maxDelDepi is represented in a
similar way except that its children are rules.
• A rule R = hTarget, effect, conditioni is represented as rule(Id(R), Id(Target), effect, Id(condition)).
• A target T = {AnyOf 1 , . . . , AnyOf n } is represented as
hasAnyOf(Id(T ), Id(AnyOf i )).
(1 ≤ i ≤ n)

8

J. Lee, Y. Wang and Y. Zhang
An anyOf A = {AllOf 1 , . . . , AllOf n } and an allOf A = {M1 , . . . , Mn } are represented
in a similar way.
• A match M = hmF unc, AR, hdataType, valueii where AR = hhattrID, category, issueri, mbpi,
is represented as the set of facts
attrRetriever(Id(AR),AttrID, category, issuer, mbp).
match(Id(M ), mFunc, Id(AR), dataType, attrVal).
• An issuer I = {Attr1 , . . . , Attrn }, where each Attri is hhattrIDi , cati , attrIssueri i, htypei , vali ii,
is represented as
hasAttr(Id(I), attrIDi , cati , atIssueri , typei , vali ).
(1 ≤ i ≤ n)
• The PDP is translated as a special policy set. PDP = hhP1 , . . . , Pn i, combAlgi is represented as
policySet(pdp, empty target, combAlg, null, inf).
hasChild(pdp, Id(Pi ), i).
(1 ≤ i ≤ n)
A request Rq = {Attr1 , . . . , Attrn } is represented in the same way as an issuer.
3.2 Reasoning about PDP Decision by ASP

In this section, we show how to represent the evaluation semantics discussed in Section 2.3 in
ASP rules. The representation is modular and turns each of the formal definitions in that section
into ASP rules (to be precise, in the input language of F 2 LP (Lee and Palla 2009)).2
We use atom evaluate(e, Rq, V) to represent the mapping from an element to a value,
evalE (e, Rq) = V .
3.2.1 Representing Rule Evaluation
We represent the evaluation of rule described in (1) as follows.
evaluate(R, Rq, Effect) <rule(R, T, Effect, Condition) & evaluate(T, Rq, m) & evaluate(Condition, Rq, t).
evaluate(R, Rq, na) <rule(R, T, Effect, Condition) & (evaluate(T, Rq, nm) | evaluate(Condition, Rq, f)).
evaluate(R, Rq, i(Effect)) <- rule(R, _, Effect, _) & request(Rq, _, _, _, _, _) &
not evaluate(R, Rq, Effect) & not evaluate(R, Rq, na).

3.2.2 Representing Combining Algorithms
We use atom reduce(Id(P ), Id(Rq), Dec) to represent the reduction operator reduce(P, Rq) =
Dec in Section 2.3.3.
Given a policy or a policy set P , we use atom combined decision(Id(P ), Id(Rq), Dec)
to represent combDec(P, Rq) = Dec. We also add the following rule to simplify the representation.
combining_algo(P, Alg) <- (policy(P, _, Alg, _, _) | policySet(P, _, Alg, _, _).

The actual evaluation of combDec(P, Rq) depends on the specific combining algorithm alg that
P has.
3.2.3 Evaluating policy and policy set
The evaluation of policy described in (2) can be represented by the following ASP rules, each of
which describes each case in (2).
2

The use of F 2 LP language is not essential, but it is often more concise than the CLINGO language.

Automated Reasoning about XACML 3.0 Delegation Using Answer Set Programming

9

evaluate(P, Rq, Dec) <- policy(P, T, _, _, _) & evaluate(T, Rq, m) & combined_decision(P, Rq, Dec).
evaluate(P, Rq, na) <- policy(P, T, _, _, _) & evaluate(T, Rq, nm).
evaluate(P, Rq, na) <- policy(P, T, _, _, _) & evaluate(T, Rq, i) & combined_decision(P, Rq, na).
evaluate(P, Rq, i(Dec)) <policy(P, T, _, _, _) & evaluate(T, Rq, i) & combined_decision(P, Rq, Dec) & (Dec=p | Dec=d).
evaluate(P, Rq, i(Dec)) <- policy(P, T, _, _, _) & evaluate(T, Rq, i) &
combined_decision(P, Rq, i(Dec)) & (Dec=p | Dec=d | Dec=dp).

The evaluation of policy set is very similar to the evaluation of policy.
3.2.4 Representing the Reduction Process
The reduction process discussed in Section 2.3.3 can be represented in ASP as follows.
Generating administrative requests: Given a policy or policy set P , a request Rq, and a decision Dec, we use the atom ar(Id(P ), Id(Rq), Dec) to denote ARP,Rq,Dec . The following ASP
rule maps an attribute in Rq with a delegated category to an identical attribute in ARP,Rq,Dec .
request(ar(P, Rq, Dec), AttrID, Cat, AttrIssuer, Type, AttrVal) <to_evaluate_against(Rq, PS) & policySet(PS, _, _, _, _) & hasChild(PS, P, _) &
request(Rq, AttrID, Cat, AttrIssuer, Type, AttrVal) &
@isDelegatedPrefixed(Cat) == 1 & (Dec = d | Dec = p).

to evaluate against(Rq,PS) is defined to be true if the evaluation of Rq against policy
set PS needs to invoke the reduction process. The term @isDelegatedPrefixed(Cat) is
an external LUA function call that returns 1 if Cat is prefixed by “delegated:”, 0 otherwise.
The following ASP rule maps an attribute in Rq whose category is not prefixed by “delegated”
and is different from “delegationInfo” and “delegate” to an identical attribute prefixed
by “delegated:”.
request(ar(P, Rq, Dec), AttrID, @addDelegatedPrefix(Cat), AttrIssuer,Type, AttrVal) <to_evaluate_against(Rq, PS) & policySet(PS, _, _, _, _) & hasChild(PS, P, _) &
request(Rq, AttrID, Cat, AttrIssuer, Type, AttrVal) & @equalsDelegationInfo(Cat) == 0 &
@equalsDelegate(Cat) == 0 & @isDelegatedPrefixed(Cat) == 0 & (Dec = d | Dec = p).

(The term @addDelegatedPrefix(Cat) is an external LUA function call that returns Cat
prefixed by “delegated:”. @equalsDelegationInfo(Cat) is a LUA function call that
returns 1 if Cat is the string delegation-info and 0 otherwise; @equalsDelegate(Cat)
is the LUA function call that returns 1 if Cat is the string delegate, and 0 otherwise.)
Similarly, we copy every attribute of P ’s issuer to an identical attribute with the category
delegate to the administrative request, as well as decision-info.
Constructing the reduction graph: Given a request Rq and a policy set P S, we use the atom
path(Id(Rq), Id(PL), Id(PH), Type, Length) for the reduction graph RGP S,Rq , which
is true if and only if there is a path of type Type and length Length from PL to PH in RGP S,Rq ,
where P S is the parent policy set of PL and PH.
The following ASP rules define PP and PI edges in the reduction graph.
path(Rq, PL, PH, pp, 1) <- evaluate(PH, ar(PL, Rq, p), p) & policySet(PS, _, _, _, _) & PH != PL &
hasChild(PS, PH, _) & hasChild(PS, PL, _).
indeterminate(i(Dec)) <- Dec = p | Dec = d | Dec = dp.
path(Rq, PL, PH, pi, 1) <evaluate(PH, ar(PL, Rq, p), Dec) & policySet(PS, _, _, _, _) & PH != PL &
hasChild(PS, PH, _) & hasChild(PS, PL, _) & indeterminate(Dec).

DP and DI edges are defined similarly.
Based on the definition of edges (paths of length 1), we recursively define paths of arbitrary
lengths in the reduction graph.

10

J. Lee, Y. Wang and Y. Zhang

path(Rq, PL, PH, Type, L) <- path(Rq, PL, PM, Type, L1) & path(Rq, PM, PH, Type, L2) & L = L1 + L2.
path(Rq, PL, PH, pi, L) <- path(Rq, PL, PM, T1, L1) & path(Rq, PM, PH, T2, L2) &
((T1 == pp & T2 == pi) | (T1 == pi & T2 == pp)) & L = L1 + L2.
path(Rq, PL, PH, di, L) <- path(Rq, PL, PM, T1, L1) & path(Rq, PM, PH, T2, L2) &
((T1 == dp & T2 == di) | (T1 == di & T2 == dp)) & L = L1 + L2.

Reduction of policies: First we define the notion of trusted and untrusted policies/policy sets
as follows.
trusted(P) <- (policy(P, _, _, Issuer, _) | policySet(P, _, _, Issuer, _)) & Issuer == null.
untrusted(P) <- (policy(P, _, _, Issuer, _) | policySet(P, _, _, Issuer, _)) & not trusted(P).

Then we define the authorization property of a policy/policy set w.r.t. a request.
pp_authorized(Rq, P) <- path(Rq, P, TP, pp, L) & trusted(TP) &
(policy(TP, _, _, _, Dep) | policySet(TP, _, _, _, Dep)) & L <= Dep.

pi authorized, dp authorized, di authorized are defined in a similar way.
Based on the above definitions, (3) can be represented as
reduce(P, Rq, Dec) <- evaluate(P, Rq, Dec) & trusted(P).
reduce(P, Rq, p) <- untrusted(P) & evaluate(P, Rq, p) & pp_authorized(Rq, P).
reduce(P, Rq, d) <- untrusted(P) & evaluate(P, Rq, d) & dp_authorized(Rq, P).
reduce(P, Rq, i(p)) <- untrusted(P) & evaluate(P, Rq, p) & pi_authorized(Rq, P).
reduce(P, Rq, i(d)) <- untrusted(P) & evaluate(P, Rq, d) & di_authorized(Rq, P).
reduce(P, Rq, i(Dec)) <- untrusted(P) & evaluate(P, Rq, i(Dec)) &
(pp_authorized(Rq, P) | pi_authorized(Rq, P) | dp_authorized(Rq, P) | di_authorized(Rq, P)).

The final decision is determined by evaluating the access request rq against the policy set
PDP.
final_decision(Dec) <- evaluate(pdp, rq, Dec).

3.3 XACML Delegation Analysis using ASP
Once we turn XACML into ASP that has formal executable semantics, we can apply formal
reasoning techniques in ASP to analyze XACML policies.
3.3.1 Delegation-Based Decision on Access Requests
Given a set of ASP facts describing a policy hierarchy, we can simulate the PDP to make the
decision on a certain request, by finding the answer sets of Π ∪ Πpolicy ∪ Πrequest , where Π is
the PDP simulating program constructed in Section 3.2, Πpolicy is the given policy description
constructed in Section 3.1, and Πrequest is the ASP facts representing the request.
For example, in Example 1, we can check if the given policy permits the request by a doctor
who wants to modify a record during the business hours. The program Πrequest is
request(rq,
request(rq,
request(rq,
request(rq,

"group", "subject", null, "string", "doctor").
"group", "resource", null, "string", "record").
"action-id", "action", null, "string", "modify").
"is-business-hour", "environment", null, "string", "true").

The answer set of Π ∪ Πpolicy ∪ Πrequest contains
path(rq,p5,p7,dp,1) path(rq,p5,p7,pp,1) path(rq,ps2,p1,dp,1) path(rq,ps2,p1,pp,1) final_decision(p)

which is in accordance with the evaluation discussed in the example in Section 2.3.5.
3.3.2 Analysis of Possible Delegation
In (Ahn et al. 2010) the authors showed how to verify a security property against a given policy
description. As XACML 3.0 has introduced the delegation feature, where everyone can write

Automated Reasoning about XACML 3.0 Delegation Using Answer Set Programming

11

policies, security leakages can be caused not only by a malicious request context, but also by an
unforeseen delegation chain. Here we assume that new (untrusted) policies can be added, and
check whether this may lead to a breach.
We define several additional programs. Program Πquery represents the negation of the security
property to check, and program Πdomain defines the domain of attributes. We use Πreq conf ig to
denote the program that generates arbitrary access request given the domain defined in Πdomain .
Finally, we use Πnpolicy conf ig to denote the program that generates 0 ∼ n arbitrary untrusted
policies (which are to be set as the children of PDP). The generated policies have empty targets,
so they are applicable to any access request. The contents of these programs are specific to
particular domains and queries.
The problem of checking whether a security property holds, assuming that new (untrusted)
policies can be added, can be considered as the problem of checking whether the program
Π ∪ Πpolicy ∪ Πdomain ∪ Πrequest conf ig ∪ Πnpolicy conf ig ∪ Πquery
has no answer sets. If the program being checked is unsatisfiable, we can conclude that the
security property specified by Πquery holds w.r.t. the attribute domain and the maximum number
n of policies that can be added. Otherwise the answer sets returned provide counterexamples
showing why the security property does not hold. In other words, the checking ensures that
Π ∪ Πpolicy ∪ Πdomain ∪ Πrequest conf ig ∪ Πnpolicy conf ig entails the property being checked.
Consider the policy in Example 1. For this example, Πdomain is the following set of facts.
subject_group("record_admin"). subject_group("doctor"). subject_group("patient").
subject_group("hospital_manager"). resource_group("record"). action_id("read").
action_id("modify"). boolean_string("true"). boolean_string("false").

Πrequest conf ig is the following program
%
1
1
1
1

generate arbitrary access request
{request(rq, "group", "subject", null, "string", Val): subject_group(Val)}.
{request(rq, "group", "resource", null, "string", Val): resource_group(Val)}.
{request(rq, "action-id", "action", null, "string", Val): action_id(Val)}.
{request(rq, "is-business-hour", "environment", null,"string", Val): boolean_string(Val)} 1.

and Πnpolicy conf ig where n = 6 (since any delegation chain has length less than 6) is the following program
% for each policy set, generate 0 ˜ max_num_policy arbitrary policies
valid_policy_number(1..6).
{policy(policy_gen(NUM), empty_target, fa, issuer(NUM), #supremum) :
valid_policy_number(NUM)} max_num_policy.
hasChild(pdp, policy_gen(NUM), NUM + 3) <- valid_policy_number(NUM).
hasChild(policy_gen(NUM), r(DEC), 1) <- valid_policy_number(NUM) & dec_queried(DEC).
rule(r(permit), empty_target, p, null).
rule(r(deny), empty_target, d, null).
% generate arbitrary subject attributes for issuer of each policy
1 {hasAttr(issuer(NUM), "group", "subject", null,"string", Val): subject_group(Val)} <policy(policy_gen(NUM), _, _, issuer(NUM), _).

Suppose we are checking whether patients can modify the records in any case. The query is
written as
dec_queried(permit).
request(rq, "group", "subject", null, "string", "patient").
request(rq, "group", "resource", null, "string", "record").
request(rq, "action-id", "action", null, "string", "modify").
<- not final_decision(p).

For the program Π ∪ Πpolicy ∪ Πdomain ∪ Πrequest conf ig ∪ Π6policy conf ig ∪ Πquery , the ASP

12

J. Lee, Y. Wang and Y. Zhang

solver returns an answer set that suggests that even when no new policy is added, if the patient is
at the same time a doctor, then he would be allowed to modify a record. For the policy designer,
this means he must decide whether it should be allowed for a patient to be a doctor at the same
time. This is an instance of the problem known as “separation of duty.” Suppose he decides not
to allow such a case.
Even with prohibiting such instances,
the answer set found suggests that if a
RG
RG
PP, DP
PP, DP
record admin writes a policy to allow a paps2
p1
ps2
p1
PP, DP
PP, DP
tient to modify a record, the patient would
gen(1)
ps1
ps1
PP, DP
have access to the record. This is because the
Deny
Deny
Permit
PDP is set to have the combining algorithm
Patient wants to modify the record
Patient wants to modify the record
deny-unless-permit. So even if p2 denies this
Before policy_gen(1) is added
After policy_gen(1) is added
access,
causing ps1 to deny this access, the
Fig. 4: The reduction graph before and after the generated policy is
added
permit decision of the newly generated policy (policy gen(1)) (which can be authorized by p1) overrides the deny decision. Figure 4
shows how the generated policy policy gen(1) affects the original reduction graph. So the
system designer must consider, whether a record admin’s permission can defeat the constraint
that a patient cannot modify the record. Suppose he decides not to allow this situation. To make
sure a patient cannot modify the record even when he has permission from a record admin, we
change the combining algorithm of the PDP to first-applicable, making the decision of ps1 to
override the decision of any newly-written policy. After making this change, the solver returns
no answer set, suggesting that there is no way for a patient to modify the record.
To evaluate the effectiveness of our analysis approach, we implemented in Java the translation of
XACML into ASP (http://reasoning.eas.
asu.edu/xacml2asp). The software XACML 2 ASP
turns a policy description in XACML in the language
of F 2 LP and then calls F 2 LP (v1.3) to turn it into the input language of ASP solver CLINGO (v3.0.5). Figure 5
Fig. 5: Experiments
shows experiments with a few examples.3 The experiment was performed on an Intel Core2 Duo CPU E7600 3.06GH with 4GB RAM running
Ubuntu 13.10. For each example, we arbitrarily constructed a partially defined access request
and check whether the request can be granted in some case.
pdp, rq

pdp, rq

4 Conclusion
The previous version of XACML was represented in several formal languages, such as answer
set programs (Ahn et al. 2010), first-order logic (Hughes and Bultan 2004), a process algebra (Bryans 2005), MTBDDs (Fisler et al. 2005), Description Logics (Kolovski et al. 2007),
and automated reasoning was performed by leveraging the reasoners available for these formal
languages.
In comparison with (Ahn et al. 2010), due to the coverage of delegation, our work is unavoidably more sophisticated. The formal semantics of ASP, being able to represent reachability and
nonmonotonicity unlike other formal languages, provides a natural basis for formalizing delegation in XACML 3.0.
3

Since XACML 3.0 delegation model has not been widely applied yet, not many examples are available.

Automated Reasoning about XACML 3.0 Delegation Using Answer Set Programming

13

Acknowledgements We are grateful to Michael Bartholomew, Amelia Harrison, and the anonymous referees for their useful comments. This work was partially supported by the National Science Foundation under Grant IIS-1319794, South Korea IT R&D program MKE/KIAT 2010TD-300404-001, and ICT R&D program of MSIP/IITP 10044494 (WiseKB).
References
A HN , G.-J., H U , H., L EE , J., AND M ENG , Y. 2010. Representing and reasoning about web access control
policies. In Proc. 34th Annual IEEE Computer Software and Applications Conference (COMPSAC
2010). 137–146.
B RYANS , J. 2005. Reasoning about XACML policies using CSP. In Proceedings of the 2005 workshop on
Secure web services. ACM, 35.
F ISLER , K., K RISHNAMURTHI , S., M EYEROVICH , L., AND T SCHANTZ , M. 2005. Verification and
change-impact analysis of access-control policies. In Proceedings of the 27th international conference
on Software engineering. ACM New York, NY, USA, 196–205.
H UGHES , G. AND B ULTAN , T. 2004. Automated verification of access control policies. Computer Science
Department, University of California, Santa Barbara, CA.
KOLOVSKI , V., H ENDLER , J., AND PARSIA , B. 2007. Analyzing web access control policies. In WWW
’07: Proceedings of the 16th international conference on World Wide Web. ACM, New York, NY, USA,
677–686.
L EE , J. AND PALLA , R. 2009. System F 2 LP – computing answer sets of first-order formulas. In Procedings
of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 515–521.
OASIS. 2013. OASIS eXtensible Access Control Markup Language (XACML) V3.0. http://www.oasisopen.org/committees/xacml/.

Proceedings of the Thirteenth International Conference on Principles of Knowledge Representation and Reasoning

Stable Models of Formulas with Intensional Functions
Michael Bartholomew and Joohyung Lee
School of Computing, Informatics, and Decision Systems Engineering
Arizona State University, Tempe, AZ, USA
{mjbartho,joolee}@asu.edu

atoms” that have the form c = v. In view of (Lifschitz
1997), which provides a first-order semantics of nonmonotonic causal logic, c is essentially a function that is mapped
to a value v in the domain. Under the principle of the universal causation, every “causally explained” symbol should be
uniquely characterized by the reduct of a program. In other
words, nonmonotonicity of this semantics is related to the
uniqueness of function values.
Recently, Lifschitz (2011; 2012) introduced yet another
nonmonotonic formalism called “logic programs with intensional functions (a.k.a. IF-programs)”, which is related to
both the stable model semantics and nonmonotonic causal
logic. This formalism takes into account the negation as failure as in logic programs, but also can express nonBoolean
fluents by functions as in nonmonotonic causal logic. However, the semantics diverges from the stable model semantics
in some essential aspects (as we discuss in this paper), and
as mentioned in (Lifschitz 2012), it is not obvious how various mathematical results established for the first-order stable
model semantics, such as strong equivalence, the splitting
theorem and the theorem on completion, can be extended to
this formalism.
In this paper, we present an alternative approach to incorporate intensional functions in the stable model semantics by
a simple modification to the first-order stable model semantics from (Ferraris, Lee, & Lifschitz 2011). It turns out that
in comparison with IF-programs, this formalism is closer to
the first-order stable model semantics than to nonmonotonic
causal logic. On the other hand, IF-programs are closer to
nonmonotonic causal logic.
The paper is organized as follows. In the next section, we
introduce the stable model semantics for formulas with intensional functions, in terms of translation into second-order
logic formulas, and also in terms of a reduct. Next, we show
how to eliminate intensional predicates in favor of intensional functions, and vice versa. We extend several theorems
established in the absence of intensional functions, such as
the theorem on constraints, the theorem on strong equivalence, the splitting theorem and the completion theorem, to
allow intensional functions. We also extend the language
RASPL-1 (Lee, Lifschitz, & Palla 2008) to allow intensional
functions and how its fragments can be computed by ASP
solvers and CSP solvers. We also compare this formalism
with several other related nonmonotonic logics. Proofs are

Abstract
In classical logic, nonBoolean fluents, such as the location of
an object and the color of a ball, can be naturally described
by functions, but this is not the case with the traditional stable model semantics, where the values of functions are predefined, and nonmonotonicity of the semantics is related to
minimizing the extents of predicates but has nothing to do
with functions. We extend the first-order stable model semantics by Ferraris, Lee and Lifschitz to allow intensional
functions. The new formalism is closely related to multivalued nonmonotonic causal logic, logic programs with intensional functions, and other extensions of logic programs
with functions, while keeping similar properties as those of
the first-order stable model semantics. We show how to eliminate intensional functions in favor of intensional predicates
and vice versa, and use these results to encode fragments of
the language in the input language of ASP solvers and CSP
solvers.

Introduction
NonBoolean fluents, such as the location of an object and
the color of a ball, are important in describing the states of
the world. In classical logic, nonBoolean fluents can be naturally represented by functions, but this is not the case with
the traditional stable model semantics (Gelfond & Lifschitz
1988) and various extensions thereafter, where the values
of functions are pre-defined, and the principle of “minimal
belief with negation as failure” is related to the minimality
condition for predicates in the definition of a stable model,
but has nothing to do with functions. Also, most extensions
of the stable model semantics are limited to Herbrand models,1 in which the behavior of functions is governed by the
built-in unique name assumption. This is often too strong an
assumption for expressing nonBoolean fluents by functions.
For instance, loc(b) = loc(b1 ) is always false for two different blocks b and b1 , which prevents us from expressing that
the two blocks can be on the table.
On the other hand, in nonmonotonic causal logic and its
high level notation action language C+ (Giunchiglia et al.
2004), nonBoolean fluents are represented by “multi-valued
c 2012, Association for the Advancement of Artificial
Copyright 
Intelligence (www.aaai.org). All rights reserved.
1
There are exceptions, such as those defined in (Ferraris, Lee,
& Lifschitz 2011; Lin & Zhou 2011).

2

Example 2 Let F2 be (f = 1 ∨ g = 1) ∧ (f = 2 ∨ g = 2).
SM[F2 ; f g] is

omitted due to the space limit.

Definition and Examples

F2 ∧ ¬∃fcg((fcg 6= f g)∧
((fb = 1 ∧ f = 1) ∨ (b
g = 1 ∧ g = 1))∧
b
((f = 2 ∧ f = 2) ∨ (b
g = 2 ∧ g = 2))),

Stable Model Semantics of Formulas with
Intensional Functions
Formulas are built the same as in first-order logic. A signature consists of function constants and predicate constants.
Function constants of arity 0 are called object constants. We
assume the following set of primitive propositional connectives and quantifiers:

which is equivalent to (f = 1 ∧ g = 2) ∨ (f = 2 ∧ g = 1).
The following lemma is often useful.
Lemma 1 Formula b
c < c → ((¬F )∗ (b
c) ↔ ¬F ) is logically valid.

⊥ (falsity), ∧, ∨, →, ∀, ∃ .

Example 3 (From (Lifschitz 2012)) Let F3 be the formula

We understand ¬F as an abbreviation of F → ⊥; symbol >
stands for ⊥ → ⊥, and F ↔ G stands for (F → G)∧(G →
F ).
For predicate symbols (constants or variables) u and c,
we define u ≤ c as ∀x(u(x) → c(x)). We define u = c
as ∀x(u(x) ↔ c(x)) if u and c are predicate symbols, and
∀x(u(x) = c(x)) if they are function symbols.
Let c be a list of distinct predicate and function constants
and let b
c be a list of distinct predicate and function variables
corresponding to c. We call members of c intensional constants. By cpred we mean the list of the predicate constants
in c, and by b
cpred the list of the corresponding predicate
variables in b
c. We define b
c < c as

∀x(¬¬(f (x) = a) → f (x) = a)
∧ ∀x(p(x) → f (x) = b),
where f , a, b are function constants, and p is a predicate
constant. Using Lemma 1, SM[F3 ; f ] is equivalent to
F3 ∧ ¬∃fb (fb 6= f ) ∧ ∀x(f (x) = a → fb(x) = a)

∧ ∀x(p(x) → fb(x) = b) ,
which in turn is equivalent to the first-order formula
∀x(p(x) → f (x) = b) ∧ ∀x(¬p(x) → f (x) = a).

Constraints, Choice, Defaults and Strong
Equivalence

(b
cpred ≤ cpred ) ∧ ¬(b
c = c)

Constraints

and SM[F ; c] as

Following Ferraris et al. (2009), we say that an occurrence
of a constant, or any other subexpression, in a formula F
is positive if the number of implications containing that occurrence in the antecedent is even, and negative otherwise.
We say that the occurrence is strictly positive if the number
of implications in F containing that occurrence in the antecedent is 0. For example, in ¬(f = 1) → g = 1, the
occurrences of f and g are both positive, but only the occurrence of g is strictly positive.
We say that a formula F is negative on a list c of predicate and function constants if members of c have no strictly
positive occurrences in F . We say that F is a constraint if it
has no strictly positive occurrences of any constant. Clearly,
a constraint is negative on any list of constants. For instance,
a formula of the form ¬H (shorthand for H → ⊥) is a constraint.

F ∧ ¬∃b
c(b
c < c ∧ F ∗ (b
c)),
where F ∗ (b
c) is defined as follows.
• When F is an atomic formula, F ∗ is F 0 ∧ F , where F 0 is
obtained from F by replacing all intensional (function and
predicate) constants in it with the corresponding (function
and predicate) variables;2
• (F ∧ G)∗ = F ∗ ∧ G∗ ;

(F ∨ G)∗ = F ∗ ∨ G∗ ;

• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;

(1)

(∃xF )∗ = ∃xF ∗ .

When F is a sentence, the models of SM[F ; c] are called
the c-stable models of F . They are the models of F that are
“stable” on c.
If c contains predicate constants only, this definition of a
stable model reduces to the one in (Ferraris, Lee, & Lifschitz
2011). The definition of F ∗ above is the same as in (Ferraris,
Lee, & Lifschitz 2011) except for the case when F is an
atomic formula.

Theorem 1 For any first-order formulas F and G, if G is
negative on c, SM[F ∧ G; c] is equivalent to SM[F ; c] ∧ G.
Example 4 Consider SM[F2 ∧ ¬(f = 1); f g] where F2 is
the formula in Example 2. Since ¬(f = 1) is negative on
{f, g}, according to Theorem 1, SM[F2 ∧ ¬(f = 1); f g] is
equivalent to SM[F2 ; f g] ∧ ¬(f = 1), which is equivalent
to f = 2 ∧ g = 1.

Example 1 Let F1 be f = 1 ∨ f = 2. SM[F1 ; f ] is
F1 ∧ ¬∃fb(fb 6= f ∧ ((fb = 1 ∧ f = 1) ∨ (fb = 2 ∧ f = 2))),

Choice and Defaults

which is equivalent to F1 .

Similar to Theorem 2 from (Ferraris, Lee, & Lifschitz 2011),
the theorem below shows that making the set of intensional constants smaller can only make the result of applying SM weaker, and that this can be compensated by

2

If an atomic formula F contains no intensional function constants, then F ∗ can be defined as F 0 , as in (Ferraris, Lee, & Lifschitz 2011).

3

Theorem 3 Let F and G be first-order formulas, let c be the
list of all constants occurring in F or G and let b
c be a list
of distinct predicate and function variables corresponding
to c. The following conditions are equivalent to each other.
• F and G are strongly equivalent to each other;
• Formula

adding “choice formulas.” For any predicate constant p,
by Choice(p) we denote the formula ∀x(p(x) ∨ ¬p(x)),
where x is a list of distinct object variables. For any
function constant f , by Choice(f ) we denote the formula
∀xy((f (x) = y) ∨ ¬(f (x) = y)), where y is an object variable that is distinct from x. For any finite list of predicate
and function constants c, Choice(c) stands for the conjunction of the formulas Choice(c) for all members c of c. We
sometimes identify a list with the corresponding set when
there is no confusion.

(F ↔ G) ∧ (b
c < c → (F ∗ (b
c) ↔ G∗ (b
c)))
is logically valid.
According to the theorem, formula {F } (shorthand for
F ∨ ¬F ) is strongly equivalent to ¬¬F → F . This allows
us to rewrite formula F3 in Example 3 as

Theorem 2 For any first-order formula F and any disjoint
lists c, d of distinct constants, the following formulas are
logically valid:

∀x{f (x) = a} ∧ ∀x(p(x) → f (x) = b),

SM[F ; cd] → SM[F ; c],
SM[F ∧ Choice(d); cd] ↔ SM[F ; c].

which represents that by default f (x) is mapped to a, but
when x belongs to p, f (x) is mapped to b. This is in agreement with (1). Also, the theorem allows us to rewrite formula (2) as an implication in which the consequent is an
atomic formula:

For example, SM[g = 1 → f = 1; f ] is equivalent to
SM[(g = 1 → f = 1) ∧ ∀y(g = y ∨ ¬(g = y)); f g], which in
turn is equivalent to g = 1 ∧ f = 1.
We abbreviate the formula F ∨ ¬F (“the law of excluded middle”) as {F }. Then Choice(f ) can be written as
∀xy{f (x) = y}; Choice(p) can be written as ∀x{p(x)}. A
formula {t = t0 }, where t contains an intensional function
constant and t0 does not, represents that t takes the value t0
by default. For example, the f -stable models of

Loc(b, t) = l ∧ ¬¬(Loc(b, t + 1) = l) → Loc(b, t+1) = l.

Reduct-Based Semantics for Ground Formulas
For a ground formula (i.e., a first-order formula with no variables), the stable models above can be alternatively defined
in terms of a reduct, which is similar to the one given in (Ferraris 2005) for propositional formulas.
For two interpretations I, J of the same signature and a
list c of distinct predicate and function constants, we write
J <c I if
• J and I have the same universe and agree on all constants
not in c,
• pJ ⊆ pI for all predicates p in c, and
• J and I do not agree on c.
The reduct F I of a formula F relative to an interpretation I
is the formula obtained from F by replacing every maximal
subformula that is not satisfied by I with ⊥.

{f = 1},
maps f to 1. On the other hand, the default behavior is overridden when we conjoin the formula with (f = 2): the f stable models of
{f = 1} ∧ (f = 2)
maps f to 2, not to 1.
A default formula is useful to describe the commonsense
law of inertia:
Loc(b, t) = l → {Loc(b, t+1) = l},

(2)

where Loc is an intensional function constant, represents
that the location of a block b at next step keeps its previous
value by default. The default behavior can be overridden if
some action moves the block.

Theorem 4 Let F be a ground formula of signature σ and c
a list of intensional constants. For any interpretation I of σ,
I |= SM[F ; c] iff
• I satisfies F , and
• every interpretation J of σ such that J <c I does not
satisfy F I .

Strong Equivalence
Strong equivalence (Lifschitz, Pearce, & Valverde 2001) is
an important notion that allows us to substitute one subformula for another subformula without affecting the stable
models. The theorem on strong equivalence can be extended
to formulas with intensional functions as follows.
About first-order formulas F and G we say that F is
strongly equivalent to G if, for any formula H, any occurrence of F in H, and any list c of distinct predicate and
function constants, SM[H; c] is equivalent to SM[H 0 ; c],
where H 0 is obtained from H by replacing the occurrence
of F by G. In this definition, H is allowed to contain function and predicate constants that do not occur in F , G; Theorem 3 below shows, however, that this is not essential.

Example 5 For F2 in Example 2, recall that an interpretation I that maps f to 1, g to 2, and maps numbers to themselves satisfies SM[F2 ; f g]. In accordance with Theorem 4,
(F2 )I = (f = 1 ∧ g = 2), and there is no interpretation J
of the same signature such that J <f g I and satisfies (F2 )I .

Stable Models of Multi-Valued Propositional
Formulas
Review of Multi-Valued Propositional Formulas
We first review the definition of a multi-valued propositional
formula from (Giunchiglia et al. 2004), where atomic parts

4

Theorem 5 Let F be a multi-valued propositional formula
of signature σ, let I be a multi-valued propositional interpretation of σ. I |= SM[F ; σ] iff

of a formula can be equalities of the kind found in constraint
satisfaction problems.
A (multi-valued propositional) signature is a set σ of
symbols called constants, along with a nonempty finite
set Dom(c) of symbols, disjoint from σ, assigned to each
constant c. We call Dom(c) the domain of c. A Boolean
constant is one whose domain is the set {TRUE, FALSE}. An
atom of a signature σ is an expression of the form c = v (“the
value of c is v”) where c ∈ σ and v ∈ Dom(c). A multivalued propositional formula of σ is a propositional combination of atoms.
A (multi-valued propositional) interpretation of σ is a
function that maps every element of σ to an element of its
domain. An interpretation I satisfies an atom c = v (symbolically, I |= c = v) if I(c) = v. The satisfaction relation is
extended from atoms to arbitrary formulas according to the
usual truth tables for the propositional connectives.

• I satisfies F , and
• no multi-valued propositional interpretation J of σ that
disagrees with I (on σ) satisfies F I .
Example 6 continued The reduct F I is
(⊥ ∨ ColorBlue = FALSE) ∧ (ColorRed = TRUE ∨ ⊥)
∧ (⊥ → ⊥) ∧ (ColorRed = TRUE → TapeColor = Red),
or equivalently
(ColorBlue = FALSE) ∧ (ColorRed = TRUE)
∧ (ColorRed = TRUE → TapeColor = Red).
No interpretation J of the same signature as I that
differs from I on TapeColor, ColorBlue, ColorRed satisfies F I . In accordance with Theorem 5, I satisfies
SM[F ; TapeColor, ColorBlue, ColorRed].

Stable Models of a Multi-Valued Propositional
Formula
Multi-valued propositional formulas can be viewed as a special class of ground first-order formulas of many-sorted signatures. We identify a multi-valued propositional signature
with a signature in first-order logic by understanding each
multi-valued constant c as an intensional object constant,
and Dom(c) as a set of non-intensional object constants. A
multi-valued propositional atom c = v can be understood as
an equality between an intensional object constant c and a
non-intensional object constant v.
We identify a multi-valued propositional interpretation
with the standard first-order logic interpretation of manysorted signature in which

The following proposition tells us that any stable model of
a multi-valued propositional formula maps a constant only
to values that occur in the formula.
Proposition 1 Let σ be a multi-valued propositional signature such that, for each c ∈ σ, Dom(c) has at least two
elements. For any multi-valued propositional formula F of
signature σ,
^
_
SM[F ; σ] →
c=v
c∈σ

v is a value in Dom(c)
that occurs in F

is logically valid.

• the sort of an intensional object constant c is represented
by Dom(c), and

For example, for the formula F in Example 6,

• each non-intensional object constant is mapped to itself,
and is identified with an element in Dom(c) for some intensional object constant c.

SM[F ; TapeColor, ColorBlue, ColorRed] →
(ColorBlue = TRUE ∨ ColorBlue = FALSE)
∧ (ColorRed = TRUE ∨ ColorBlue = FALSE)
∧ (TapeColor = Red ∨ TapeColor = Blue)

Example 6 Consider a multi-valued propositional signature σ = {ColorBlue, ColorRed, TapeColor}, where
Dom(ColorBlue) = Dom(ColorRed) = {TRUE, FALSE}
and Dom(TapeColor) = {Red, Blue, Green}. The following is a multi-valued propositional formula F :

is logically valid. In view of Proposition 1, an interpretation
that maps TapeColor to Green cannot be a stable model.

Relation to the 1988 Definition of a Stable
Model

(ColorBlue = TRUE ∨ ColorBlue = FALSE)
∧ (ColorRed = TRUE ∨ ColorRed = FALSE)
∧ (ColorBlue = TRUE → TapeColor = Blue)
∧ (ColorRed = TRUE → TapeColor = Red)

Let Π be a finite set of rules of the form
A0 ← A1 , . . . , Am , not Am+1 , . . . , not An

(3)

(n ≥ m ≥ 0), where each Ai is a propositional atom.
The stable models of Π in the sense of (Gelfond & Lifschitz 1988) can be characterized in terms of SM, in the same
way as is handled in IF programs (Lifschitz 2012). Lifschitz (2012) defines the functional image of Π as follows.
First, reclassify all propositional atoms as intensional object
constants, and add to the signature two non-intensional object constants 0 and 1. Each rule (3) is rewritten as

An interpretation I such that I(ColorBlue) = FALSE,
I(ColorRed) = TRUE and I(TapeColor) = Red satisfies
F.
The reduct F I of a multi-valued propositional formula F
relative to a multi-valued propositional interpretation I is the
formula obtained from F by replacing each maximal subformula that is not satisfied by I with ⊥. The following theorem
provides an alternative definition of a stable model in terms
of a reduct.

A0 = 1 ← A1 = 1∧· · ·∧Am = 1∧Am+1 6= 1∧· · ·∧An 6= 1

5

(A =
6 1 is shorthand for ¬(A = 1)). For each atom A in the
signature of Π we add the default rule

The following corollary shows that there is a 1–1 correspondence between the stable models of F and the stable
models of its “functional image” Ffp ∧ DF f ∧ FCf . For any
interpretation I of the signature of F , by Ifp we denote the
interpretation of the signature of Ffp obtained from I by replacing the set pI with the function f I such that

A = 0 ← ¬¬(A = 0)
(by default, atoms get the value false). Finally, we add constraints
0 6= 1,
(4)
x = 0 ∨ x = 1.
The resulting program is called the functional image of Π.
Clearly, the models of (4) can be viewed as sets of propositional atoms. The following theorem is similar to Proposition 5 from (Lifschitz 2012), but applies to the stable model
semantics presented in this paper.

f I (ξ1 , . . . , ξn ) = 1 if pI (ξ1 , . . . , ξn ) =
f I (ξ1 , . . . , ξn ) = 0 otherwise .

We also assume that Ifp satisfies (5). Consequently, Ifp satisfies FCf .
Corollary 1 (a) An interpretation I of the signature of F is
a model of SM[F ; pc] iff Ifp is a model of SM[Ffp ∧DF f ; f c].
(b) An interpretation J of the signature of Ffp is a model of
SM[Ffp ∧ DF f ∧ FCf ; f c] iff J = Ifp for some model I of
SM[F ; pc].

Theorem 6 The functional image of Π has the same stable
models as Π.

Eliminating Intensional Predicates
The process in the previous section can be extended to eliminate intensional predicates in favor of intensional functions.
Given a formula F and an intensional predicate constant p,
formula Ffp is obtained from F as follows:

Eliminating Intensional Functions
We discuss how to eliminate intensional functions in favor
of intensional predicates. Unlike the previous section, the
result is first established for “f -plain” formulas,3 and then
extended to allow “synonymity” rules.
Let f be a function constant. A first-order formula is
called f -plain if each atomic formula

• in the signature of F , replace p with a new intensional
function constant f of arity n, where n is the arity of p,
and add two non-intensional object constants 0 and 1;
• replace each subformula p(t) in F with f (t) = 1.
By FCf (“Functional Constraint on f ”) we denote the
conjunction of the following formulas, which enforces f to
behave like predicates:
0=
6 1,

TRUE

• does not contain f , or
• is of the form f (t) = u where t is a tuple of terms not
containing f , and u is a term not containing f .

(5)

(7)

For a list f of function constants, we say that F is f -plain
if F is f -plain for each member f of f .
Let F be an f -plain formula, where f is an intensional
function constant. Formula Fpf is obtained from F as follows:

Example 7 Let F be the conjunction of the universal closures of the following formulas, which describes the effect
of a monkey moving:

• in the signature of F , replace f with a new intensional
predicate constant p of arity n + 1, where n is the arity
of f ;

¬¬∀x(f (x) = 0 ∨ f (x) = 1).
(6)
where x is a list of distinct object variables. By DF f (“Default False on f ”) we denote the following formula:
∀x(¬¬(f (x) = 0) → f (x) = 0).

• replace each subformula f (t) = c in F with p(t, c).

Loc(Monkey, 0) = L1,
Loc(Monkey, 1) = L2,
Move(Monkey, l, t) → Loc(Monkey, t + 1) = l

By UECp we denote the following formulas that enforce
the functional image on the predicates:

(lower case symbols are variables). We eliminate the intensional predicate Move in favor of an intensional function
Move
Movef to obtain FMove
∧ FCMovef ∧ DF Movef , which is the
f
conjunction of the universal closures of the following formulas:

∀xyz(y 6= z ∧ p(x, y) ∧ p(x, z) → ⊥),
¬¬∀x∃y p(x, y),

(8)

where x is a n-tuple of variables, and all variables in x, y,
and z are pairwise distinct. Note that each formula is a constraint. Clearly, UECp is strongly equivalent to

Loc(Monkey, 0) = L1,
Loc(Monkey, 1) = L2,
Movef (Monkey, l, t) = 1 → Loc(Monkey, t + 1) = l,
0 6= 1,
¬¬∀xyz(Movef (x, y, z) = 0 ∨ Movef (x, y, z) = 1)
∀xyz(¬¬(Movef (x, y, z) = 0) → Movef (x, y, z) = 0).

¬¬∀x∃!y p(x, y)

(9)

and also classically equivalent to
∀x∃!y p(x, y) .

Theorem 7 Formulas ∀x(f (x) = 1 ↔ p(x)), FCf entail
SM[F ; pc] ↔ SM[Ffp ∧ DF f ; f c].

(10)

3
The notion of f -plain formulas are adapted from f -plain
causal theories from (Lifschitz & Yang 2011a).

6

• is of the form f (t) = u where f is in f , symbol t is a
tuple of terms not containing any member of f , and u is a
term not containing any member of f , or

Example 8 Consider the same formula F in Example 7. We
eliminate the function Loc in favor of an intensional prediLoc
∧ UECLocp , which is the conjunccate Locp to obtain FLoc
p
tion of the universal closures of the following formulas:

• is of the form f1 (t1 ) = f2 (t2 ) where f1 , f2 are in f ,
symbols t1 and t2 are tuples of terms not containing any
member of f .

Locp (Monkey, 0, L1),
Locp (Monkey, 1, L2),
Move(Monkey, l, t) → Locp (Monkey, t + 1, l),
∀wxyz(y =
6 z ∧ Locp (w, x, y) ∧ Locp (w, x, z) → ⊥),
¬¬∀wx∃y(Locp (w, x, y)).
Theorem 8 For any f -plain formula F ,
∀xy(p(x, y) ↔ f (x) = y), ∃xy(x 6= y) entail

Let F be an f -plain-syn formula. The elimination is done
by extending the previous method by turning atomic formulas of the form f1 (t1 ) = f2 (t2 ) into
∀y(p1 (t1 , y) ↔ p2 (t2 , y)),

formulas

where p1 , p2 are new intensional predicate constants corresponding to f1 , f2 .
Fpf is defined similar to Fpf except that it applies to the list
of symbols.

SM[F ; f c] ↔ SM[Fpf ; pc].
The following corollary shows that there is a simple 1–1
correspondence between the stable models of F and the stable models of Fpf ∧ UECp . Recall that the signature of Fpf is
obtained from the signature of F by replacing f with p. For
any interpretation I of the signature of F , by Ipf we denote
the interpretation of the signature of Fpf obtained from I by
replacing the function f I with the set pI that consists of the
tuples
hξ1 , . . . , ξn , f I (ξ1 , . . . , ξn )i

Theorem 9 For any f -plain-syn formula F , the set of formulas ∀xy(p(x, y) ↔ f (x) = y) for each f ∈ f and the
corresponding p, and ∃xy(x =
6 y) entail
SM[F ; fq] ↔ SM[Fpf ; pq].
Unlike in Theorem 8, the elimination in Theorem 9 applies to the list of intensional functions simultaneously.

for all ξ1 , . . . , ξn from the universe of I.

RASPL-1 with Intensional Functions

Corollary 2 Let F be an f -plain sentence. (a) An interpretation I of the signature of F that satisfies ∃xy(x =
6 y)
is a model of SM[F ; f c] iff Ipf is a model of SM[Fpf ; pc].
(b) An interpretation J of the signature of Fpf that satisfies
∃xy(x 6= y) is a model of SM[Fpf ∧ UECp ; pc] iff J = Ipf
for some model I of SM[F ; f c].

In (Lee, Lifschitz, & Palla 2008), the language RASPL-1
is introduced, which defines the meaning of counting and
choice in answer set programming by reducing them to
first-order formulas. The restriction in RASPL-1 that does
not allow function constants of positive arity is removed
in (Bartholomew & Lee 2010), but such functions are restricted to be non-intensional.
Here we extend RASPL-1 to allow intensional functions,
and note that this extension provides a convenient way to
describe nonBoolean fluents.
As in (Lee, Lifschitz, & Palla 2008), an aggregate expression has the form
b {x : F (x)}
(12)

Theorem 8 and Corollary 2 are similar to Theorem 3 and
Corollary 5 from (Lifschitz & Yang 2011a), which are about
eliminating explainable functions in nonmonotonic causal
logic in favor of explainable predicates.
The method above eliminates only one intensional function constant at a time, but repeated applications can eliminate all intensional functions f from a given f -plain formula.
This allows us to represent the f -plain formula by a logic
program, which we illustrate in the next section.
We expect that many domains can be described by f -plain
formulas, but we know one place where f -plain formulas
are limited. This is when we want to express “synonymity”
rules (Lee et al. 2010; Lifschitz & Yang 2011a) that have
the form
B → f1 (t1 ) = f2 (t2 ),
(11)

(k ≥ 1), where b is a positive integer (“the bound”), x is a
list of variables (possibly empty), and F (x) is a first-order
formula. This expression reads: there are at least b values
of x such that F (x).
A rule is an expression of the form
A1 ; . . . ; Al ← E1 , . . . , Em , not Em+1 , . . . , not En (13)
(l ≥ 0; n ≥ m ≥ 0), where each Ai is an atom, and each Ei
is an aggregate expression. A program is a list of rules.
The semantics of RASPL-1 is defined by a procedure
that turns every aggregate expression, every rule, and every
program into a formula of first-order logic, called its FOLrepresentation. The FOL-representation of an aggregate expression b {x : F (x)} is the formula


^
^
∃x1 · · · xb 
F (xi ) ∧
¬(xi = xj ) (14)

where f1 , f2 are intensional function constants in f , and t1 ,
t2 are tuples of terms not containing members of f . This
rule expresses that we believe f1 (t1 ) to be “synonymous”
to f2 (t2 ) under condition B. We can eliminate f1 and f2 in
favor of predicate constants p1 and p2 as follows.
We consider a more general case than an f -plain formula.
We define a new class of f -plain-syn formulas in which every atomic formula
• does not contain any member of f , or

1≤i≤b

7

1≤i<j≤b

where x1 , . . . xb are lists of new variables of the same length
as x. An expression 1{: A}, where A is an atomic formula,
can be identified with A. A choice rule of the form

1
2
3
4

{A} ← E1 , . . . , Em , not Em+1 , . . . , not En

5
6

where A is an atomic formula, stands for

7

A; not A ← E1 , . . . , Em , not Em+1 , . . . , not En ,

9
10

A ← E1 , . . . , Em , not Em+1 , . . . , not En , not not A.

11

For instance, the Blocks World domain can be succinctly
described in RASPL-1 as follows. First, we say that no two
blocks can be on the same block at the same time.

13

⊥ ← 2{b1 : Loc(b1 , t) = b}

17

(15)

12

15
16

19

(17)

21

% the table is a location
location(table).
% uniqueness constraint
:- 2{on(B,LL,ST): location(LL)}.
% existence constraint
:- {on(B,LL,ST): location(LL)}0.
:- 2{on(BB,B,ST): block(BB)}.

22
23

on(B,L,T+1) :- move(B,L,T).

24
25
27
28

% preconditions
:- (g+1) {move(BB,LL,T): block(BB): location(LL)}.
:- move(B,L,T), on(B1,B,T).
:- move(B,B1,T), move(B1,L,T).

29
30

{on(B,L,0)}.

31
32

{move(BB,LL,T): block(BB): location(LL)}.

33
34

{on(B,L,T+1)} :- on(B,L,T).

Figure 1: Blocks World Encoding in ASP

(18)

and that actions are exogenous by

A loop of F (relative to a list c of intensional predicates)
is a nonempty subset l of c such that the subgraph of DGc [F ]
induced by l is strongly connected.
The following theorem extends the splitting lemma
from (Ferraris et al. 2009) to allow intensional functions.
Theorem 10 Let F be a c-plain formula, and let c be a list
of constants. If l1 , . . . , ln are all the loops of F relative to c
then
SM[F ; c] is equivalent to SM[F ; l1 ] ∧ · · · ∧ SM[F ; ln ].
The following theorem extends the splitting theorem
from (Ferraris et al. 2009) to allow intensional functions.
Theorem 11 Let F , G be first-order sentences, and let c, d
be finite disjoint lists of distinct constants. If
(a) each strongly connected component of the predicate dependency graph of F ∧G relative to c, d is either a subset
of c or a subset of d,
(b) F is negative on d, and
(c) G is negative on c
then
SM[F ∧ G; c ∪ d] ↔ SM[F ; c] ∧ SM[G; d]
is logically valid.

(19)

The commonsense law of inertia is expressed by
{Loc(b, t+1) = l} ← Loc(b, t) = l.

% every block is a location
location(B) :- block(B).

20

26

The first rule of (17) describes that the concurrent move
actions are limited by the number of grippers (denoted by
the symbol g). The next rule describes that a block can be
moved only when it is clear, and the last rule describes that
a block cannot be moved onto a block that is being moved
also. We describe that the fluents are initially exogenous by

{Move(b, l, t)}.

step(ST).
astep(T).
block(B;B1).
location(L;L1).

14

18

(b, b1 are variables for blocks; t is a variable for timepoints).
Next we describe the effect of moving a block b to a location l:
Loc(b, t+1) = l ← Move(b, l, t).
(16)
The preconditions of the action are described by the following constraints:

{Loc(b, 0) = l},

#domain
#domain
#domain
#domain

8

which is strongly equivalent to

⊥ ← (g+1){b l : Move(b, l, t)},
⊥ ← Move(b, l, t) ∧ Loc(b1 , t) = b,
⊥ ← Move(b, b1 , t) ∧ Move(b1 , l, t).

step(0..maxstep).
astep(0..maxstep-1) :- maxstep > 0.

(20)

Corollary 2 allows us to represent the theory in the input
language of ASP grounder GRINGO as follows, by eliminating function constant Loc in favor of predicate constant On.
Lines 1–13 are sort and variable declarations. Lines 16, 19
are UECOn . The rest is the representation of (15)–(20).

Splitting Theorem and Completion
A rule of a first-order formula F is a strictly positive occurrence of an implication in F .
Let F be a c-plain formula. The dependency graph of F
(relative to c), denoted by DGc [F ], is the directed graph that
• has all members of c as its vertices, and
• has an edge from c to d if, for some rule G → H of F ,
– c has a strictly positive occurrence in H, and
– d has a positive occurrence in G that does not belong to
any subformula of G that is negative on c.

8

It is clear that Theorem 1 is a special case of Theorem 11,
when d is empty.
As shown in (Lee, Lifschitz, & Palla 2008), the splitting
theorem is useful in reasoning about ASP programs. It is
also useful in proving other theorems, such as the theorem
on completion below. We say that a formula F is in Clark
normal form (relative to the list c of intensional constants) if
it is a conjunction of sentences of the form
∀x(G → p(x))

(21)

instances. We take the advantage of EZCSP with grounding,
but do not rely on any nonmonotonic feature of the input
language. In fact, the completion can be expressed in the
input language of other CSP solvers.
1
2
3
4
5

and

6

∀xy(G → f (x) = y)
(22)
one for each intensional predicate p and each intensional
function f , where x is a list of distinct object variables, y
is a variable, and G is a formula that has no free variables
other than those in x and y.
The completion of a formula F in Clark normal form (relative to c) is obtained from F by replacing each conjunctive
term (21) with
∀x(p(x) ↔ G)
(23)
and each conjunctive term (22) with

7

∀xy(f (x) = y ↔ G).

(24)

We say that F is tight (on c) if the dependency graph of
F (relative to c) is acyclic. The following theorem tells
us that, for a tight theory, completion is a process that allows us to reclassify intensional constants as non-intensional
ones. It is similar to the main theorem of (Lifschitz & Yang
2011b), which describes functional completion in nonmonotonic causal logic.
Theorem 12 For any formula F in Clark normal form that
is tight on c, an interpretation I that satisfies ∃xy(x 6= y) is
a model of SM[F ; c] iff I is a model of the completion of F
relative to c.
For example, the conjunction of the universal closures of
(16), (18), (19), (20) can be turned into Clark normal form,
and is equivalent to the completion relative to {Loc, Move}:

step(0..maxstep).
astep(0..maxstep-1) :- maxstep > 0.
#domain
#domain
#domain
#domain

step(ST).
astep(T).
block(B;B1;B2).
location(L;L2;L2).

8
9
10

% every block is a location
location(B) :- block(B).

11
12
13

% the table (denoted by 0) is a location
location(0).

14
15
16
17

% constraint variable declarations
cspvar(loc(B,ST),0,blocks).
cspvar(move(B,L,T),0,1).

18
19
20
21

% no two blocks can be on a single block
required((loc(B,T)=B2 /\ loc(B1,T)=B2 /\ B!=B1)
-> 1=2).

22
23
24
25
26
27
28

% preconditions
required((move(B,L,T)=1 /\ move(B1,L1,T)=1 /\
move(B2,L2,T)=1 /\ (B!=B1 \/ L!=L1) /\
(B!=B2 \/ L!=L2) /\ (B1!=B2 \/ L1!=L2)) -> 1=2).
required((move(B,L,T)=1 /\ loc(B1,T)=B) -> 1=2).
required((move(B,B1,T)=1 /\ move(B1,L,T)=1) -> 1=2).

29
30
31
32
33
34
35
36
37

Loc(b, t1 ) = l
↔ (Move(b, l, t) ∧ (t1 = t + 1))
∨ (¬¬(Loc(b, 0) = l) ∧ t1 = 0)
∨ (¬¬(Loc(b, t + 1) = l) ∧ Loc(b, t) = l ∧ (t1 = t+1)),
Move(b, l, t) ↔ ¬¬Move(b, l, t).

% completion
required(((move(B,L,T)=1 /\ ST=T+1)
\/ (loc(B,ST)=L /\ ST=0)
\/ (loc(B,T)=L /\ loc(B,ST)=L /\ ST=T+1))
-> loc(B,ST)=L).
required((loc(B,ST)=L /\ ST=T+1)
-> ((move(B,L,T)=1)
\/ (loc(B,T)=L /\ loc(B,ST)=L /\ ST=T+1))).

Figure 2: Blocks World Encoding in EZCSP
Our preliminary experiments indicates that for the blocks
world encoding in Figures 1 and 2, CLINGO runs significantly faster than EZCSP using B-P ROLOG, but a more systematic comparison has to be conducted.

The assumption ∃xy(x =
6 y) in the statement of Theorem 12 is essential. For instance, take F to be > and
c to be an intensional function constant f . If the universe |I| of an interpretation I is a singleton, then I satisfies SM[F ], but does not satisfy the completion formula
∀xy(f (x) = y ↔ ⊥).
In view of Theorem 1, the RASPL-1 program consisting of (15)–(20) is equivalent to the conjunction of the
completion above and the FOL-representation of the constraints (15) and (17). The resulting theory can be represented in the language of CSP solvers. Below we show an
encoding in the language of EZCSP (Balduccini 2009), a system that allows us to use an ASP grounder to generate CSP

Relation to Nonmonotonic Causal Logic
Review: Nonmonotonic Causal Logic
A (nonmonotonic) causal theory is a finite list of rules of the
form
F ⇐G
where F and G are formulas. We identify a rule with the
universal closure of the implication G → F . A causal model
of a causal theory T is defined as the models of the secondorder sentence
f ))
CM[T ; f ] = T ∧ ¬∃b
f (b
f 6= f ∧ T † (b

9

where f is a list of explainable function constants, and T † (b
f)
denotes the conjunction of the formulas
e
∀(G → F (b
f ))

Theorem 14 Let F be the FOL-representation of a ground
IF-program of signature σ and let f be a list of intensional function constants. For any interpretation I of σ,
I |= IF[F ; f ] iff

(25)

for all rules F ⇐ G of T .
By a definite casual theory, we mean the causal theory
whose rules have the form either
f (t) = t1 ⇐ B

(26)

⊥ ⇐ B,

(27)

• I satisfies Π, and
• no interpretation J of σ that disagrees with I only on f
satisfies ΠI .

Comparison

or

The definition of the IF operator above looks close to our
definition of the SM operator. However, they often behave quite differently. Neither semantics is stronger than
the other.

where f is an explainable function constant, t is a list of
terms that does not contain explainable function constants,
and t1 is a term that does not contain explainable function
constants. By Tr(T ) we denote the theory consisting of conjunction of the following formulas: e
∀(¬¬B → f (t) = t1 )
for each rule (26) in T , and e
∀¬B for each rule (27) in T . The
causal models of such T coincide with the stable models of
Tr(T ).
Theorem 13 For any definite causal theory T , I
CM[T ; f ] iff I |= SM[Tr(T ); f ].

Example 9 Let F be the following program
d = 2 ← c = 1,
d=1
and let I be an interpretation such that |I| = {1, 2}, I(c) =
2 and I(d) = 1. I is a model of IF[F ; cd], but not a model
of SM[F ; cd].

|=

Relation to IF-Programs

Example 10 Let F be the following program

Review of IF-Programs

(c = 1 ∨ d = 1) ∧ (c = 2 ∨ d = 2)

We consider rules of the form
H ← B,

and let I1 and I2 be interpretations such that |I1 | = |I2 | =
{1, 2, 3} and I1 (c) = 1, I1 (d) = 2, I2 (c) = 2, I2 (d) =
1. I1 and I2 are models of SM[F ; cd]. On the other hand,
IF[F ; cd] has no models.

(28)

where H and B are formulas that do not contain →. As
before, we identify a rule with the universal closure of the
implication B → H. An IF-program is a finite list of those
rules.
An occurrence of a symbol in a formula is negated if it
belongs to a subformula of that begins with negation, and is
non-negated otherwise. Let F be a formula, let f be a list
of distinct function constants, and let b
f be a list of distinct
function variables corresponding to f . By F  (b
f ) we denote
the formula obtained from F by replacing each non-negated
occurrence of a member of f with the corresponding function variable in b
f . By IF[F ; f ] we denote the second-order
sentence
F ∧ ¬∃b
f (b
f 6= f ∧ F  (b
f )).

Example 11 Let F be c =
6 1 ← > and let F1 be ⊥ ← c =
1. Under our semantics, they are strongly equivalent to each
other, and neither of them has a stable model. However,
this is not the case with IF-programs. For instance, let I be
an interpretation such that |I| = {1, 2} and I(c) = 2. I
satisfies IF[F1 ; c] but not IF[F ; c].
While ⊥ ← F is a constraint in our formalism, in view of
Theorem 1, the last example illustrates that ⊥ ← F is not
considered as a constraint in the semantics of IF-programs.
Indeed, the definition of a constraint given in (Lifschitz
2012) is stronger than ours.
Also, the statement of Proposition 1 does not apply to
IF-programs. Example 11 illustrates that a model of an IFprogram may map a function to a value that does not even
occur in the program.
Let T be an IF-program whose rules have the form

According to (Lifschitz 2012), the f -stable models of an IFprogram Π are defined as the models of IF[F ; f ], where F is
the FOL-representation of Π.

Reduct-based Semantics of IF-Programs
For any ground formula F , F I is a formula obtained from F
by replacing every negated formula that is not satisfied by I
with ⊥.
Let Π be a ground IF-program. The IF-reduct ΠI of an
IF-program Π relative to an interpretation I consists of rules

f (t) = t1 ← ¬¬B

(29)

where f is an intensional function constant, t and t1 do not
contain intensional function constants, and B is an arbitrary
formula. We identify T with the corresponding first-order
formula.

H I ← BI

Theorem 15 I |= SM[T ; f ] iff I |= IF[T ; f ].

for every rule H ← B in Π.

10

Relation to Cabalar’s Functional Logic
Programs

Conclusion
The absence of intensional functions in several extensions
of the stable model semantics prevents us from expressing the commonsense law of inertia involving nonBoolean
fluents, such as formula (2). IF-programs introduced by
Lifschitz is distinct in the sense that functions are allowed
to be intensional. Here we presented an alternative stable
model semantics that allows intensional functions. Unlike
IF-programs, where the syntax is limited and only function
constants are intensional, our semantics is applied to arbitrary first-order formulas and allows both function and predicate constants to be intensional. A major difference between
IF-programs and our formalism is that the former is closer
to nonmonotonic causal logic, and the latter is closer to the
first-order stable model semantics. Indeed, we observed that
several properties established for first-order stable model semantics can be easily extended to the formalism presented
here.
RASPL-1 with intensional functions is shorthand for formulas with intensional functions, and allows succinct representation of domains that involve nonBoolean constants.
The computation can be done by either turning it into answer set programs or into CSP.

Cabalar defines functional answer set programs based on an
extension of HT-models that allows “partial” functions. The
presence of partial functions is essential in Cabalar’s semantics to enforce a strict order between the two worlds, H and
T. When all constants other than f are evaluated the same for
both worlds, H is “strictly smaller” than T when function f
is undefined in H and defined in T. In the absence of partial
functions, H and T evaluate the same for all functions.
If we require every function to be total, it is easy to check
that the semantics from (Cabalar 2011) is equivalent to the
first-order stable model semantics from (Ferraris, Lee, &
Lifschitz 2007), or, put in another way, results in the special case of our semantics in which every function constant
is non-intensional.
As described by Lifschitz (2012), the essential difference
between IF-programs and Cabalar’s functional answer set
programs is that the latter relies on partial functions and minimization, instead of total functions and uniqueness as in the
former. This remark also applies to the relationship between
our formalism and Cabalar’s.

Relation to Lin and Wang’s Logic Programs
with Functions

Acknowledgements
We are grateful to Vladimir Lifschitz and Yunsong Meng for
many useful discussions and comments. We are also grateful to the anonymous referees for their comments and suggestions. This work was partially supported by the National
Science Foundation under Grant IIS-0916116.

Lin & Wang (2008) extended answer set semantics with
functions by extending the definition of a reduct, and also
provided loop formulas for such programs. We can provide
an alternative account of their results by considering the notions there as special cases of the definitions presented in
this paper. For simplicity, we assume non-sorted languages.4
Essentially, they restricted attention to a special case of nonHerbrand interpretations such that object constants form the
universe, and ground terms other than object constants are
mapped to object constants. According to (Lin & Wang
2008), an LW-program P consists of type definitions and
a set of rules. Type definitions introduce the domains for a
many-sorted signature consisting of some object constants,
and includes the evaluation of each function symbol of positive arity that maps a list of object constants to an object
constant. Since we assume here non-sorted languages, we
consider only a single domain (universe). We say that an interpretation I is a P -interpretation if the universe is the set
of object constants specified by P , object constants are evaluated to itself, and ground terms other than object constants
are evaluated conforming to the type definitions of P .
Theorem 16 Let P be an LW-program and let F be the
FOL-representation of the set of rules in P . The following
conditions are equivalent to each other:
(a) I is an answer set of P in the sense of (Lin & Wang 2008);
(b) I is a P -interpretation that satisfies SM[F ; p] where p is
the list of all predicate constants occurring in F .
Thus the definition does not allow functions to be intensional.

References
Balduccini, M. 2009. Representing constraint satisfaction
problems in answer set programming. In Working Notes of
the Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP).
Bartholomew, M., and Lee, J. 2010. A decidable class of
groundable formulas in the general theory of stable models.
In Proceedings of International Conference on Principles of
Knowledge Representation and Reasoning (KR), 477–485.
Cabalar, P. 2011. Functional answer set programming.
TPLP 11(2-3):203–233.
Ferraris, P.; Lee, J.; Lifschitz, V.; and Palla, R. 2009. Symmetric splitting in the general theory of stable models. In
Proceedings of International Joint Conference on Artificial
Intelligence (IJCAI), 797–803.
Ferraris, P.; Lee, J.; and Lifschitz, V. 2007. A new perspective on stable models. In Proceedings of International Joint
Conference on Artificial Intelligence (IJCAI), 372–379.
Ferraris, P.; Lee, J.; and Lifschitz, V. 2011. Stable models
and circumscription. Artificial Intelligence 175:236–263.
Ferraris, P. 2005. Answer sets for propositional theories. In
Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 119–131.
Gelfond, M., and Lifschitz, V. 1988. The stable model
semantics for logic programming. In Kowalski, R., and

4

(Lin & Wang 2008) considers essentially many-sorted languages. The result of this section can be extended to that case by
considering many-sorted SM (Kim, Lee, & Palla 2009).

11

Bowen, K., eds., Proceedings of International Logic Programming Conference and Symposium, 1070–1080. MIT
Press.
Giunchiglia, E.; Lee, J.; Lifschitz, V.; McCain, N.; and
Turner, H. 2004. Nonmonotonic causal theories. Artificial
Intelligence 153(1–2):49–104.
Kim, T.-W.; Lee, J.; and Palla, R. 2009. Circumscriptive
event calculus as answer set programming. In Proceedings
of International Joint Conference on Artificial Intelligence
(IJCAI), 823–829.
Lee, J.; Lierler, Y.; Lifschitz, V.; and Yang, F. 2010. Representing synonymity in causal logic and in logic programming5 . In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).
Lee, J.; Lifschitz, V.; and Palla, R. 2008. A reductive semantics for counting and choice in answer set programming.
In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI), 472–479.
Lifschitz, V., and Yang, F. 2011a. Eliminating function symbols from a nonmonotonic causal theory. In Lakemeyer, G.,
and McIlraith, S. A., eds., Knowing, Reasoning, and Acting:
Essays in Honour of Hector J. Levesque. College Publications.
Lifschitz, V., and Yang, F. 2011b. Functional completion6 .
Unpublished Draft.
Lifschitz, V.; Pearce, D.; and Valverde, A. 2001. Strongly
equivalent logic programs. ACM Transactions on Computational Logic 2:526–541.
Lifschitz, V. 1997. On the logic of causal explanation. Artificial Intelligence 96:451–465.
Lifschitz, V. 2011. Logic programs with intensional functions (preliminary report). In Working Notes of the Workshop on Answer Set Programming and Other Computing
Paradigms (ASPOCP).
Lifschitz, V. 2012. Logic programs with intensional functions. In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR).
This volume.
Lin, F., and Wang, Y. 2008. Answer set programming
with functions. In Proceedings of International Conference
on Principles of Knowledge Representation and Reasoning
(KR), 454–465.
Lin, F., and Zhou, Y. 2011. From answer set logic programming to circumscription via logic of GK. Artificial Intelligence 175:264–277.

5
6

http://peace.eas.asu.edu/joolee/papers/syn.pdf
http://www.cs.utexas.edu/users/vl/papers/if.pdf

12

966

IEEE JOURNAL OF SOLID-STATE CIRCUITS, VOL. 51, NO. 4, APRIL 2016

A Hybrid AMOLED Driver IC for Real-Time TFT
Nonuniformity Compensation
Jun-Suk Bang, Hyun-Sik Kim, Member, IEEE, Ki-Duk Kim, Student Member, IEEE, Oh-Jo Kwon,
Choong-Sun Shin, Joohyung Lee, and Gyu-Hyeong Cho, Fellow, IEEE

Abstract—An active matrix organic light emitting diode
(AMOLED) display driver IC, enabling real-time thin-film transistor (TFT) nonuniformity compensation, is presented with a
hybrid driving method to satisfy fast driving speed, high TFT
current accuracy, and a high aperture ratio. The proposed
hybrid column-driver IC drives a mobile UHD (3840 × 2160)
AMOLED panel, with one horizontal time of 7.7 µs at a scan
frequency of 60 Hz, simultaneously senses the TFT current for
back-end TFT variation compensation. Due to external compensation, a simple 3T1C pixel circuit is employed in each pixel.
Accurate current sensing and high panel noise immunity is guaranteed by a proposed current-sensing circuit. By reusing the
hybrid column-driver circuitries, the driver embodies an 8 bit
current-mode ADC to measure OLED V –I transfer characteristic
for OLED luminance-degradation compensation. Measurement
results show that the hybrid driving method reduces the maximum
current error between two emulated TFTs with a 60 mV threshold voltage difference under 1 gray-level error of 0.94 gray level
(37 nA) in 8 bit gray scales from 12.82 gray level (501 nA). The
circuit-reused current-mode ADC achieves 0.56 LSB DNL and
0.75 LSB INL.
Index Terms—Active matrix organic light emitting diode
(AMOLED), circuit-reused current-mode ADC, data driver,
hybrid driver, offset-compensated integrating comparator
(OCIC), OLED degradation, thin-film transistor (TFT), threshold
voltage shift.

I. I NTRODUCTION

A

CTIVE matrix organic light emitting diode (AMOLED)
displays have several strengths suitable for highresolution flat-panel displays, such as a wide viewing angle,
a high contrast ratio, and fast response time [1]. Moreover,
because the OLED is self-emissive and no backlight units are
needed, the AMOLED display consumes little power, making
its application thin and light. Also, it is noted for being a key
technology in displays of the future, such as flexible displays
and transparent displays [2].
Manuscript received September 01, 2015; revised October 23, 2015;
accepted November 17, 2015. Date of publication February 08, 2016; date
of current version March 29, 2016. This paper was approved by Guest Editor
Masato Motomura.
J.-S. Bang, K.-D. Kim, and G.-H. Cho are with the Department
of Electrical Engineering, Korea Advanced Institute of Science and
Technology (KAIST), Daejeon 34141, South Korea (e-mail: ghcho@
ee.kaist.ac.kr).
H.-S. Kim is with the Department of Display Engineering, Dankook
University, Cheonan 31116, South Korea (e-mail: hs.kim@dankook.
ac.kr).
O.-J. Kwon, C.-S. Shin, and J. Lee are with Samsung Display Co. Ltd.,
Yongin 17113, South Korea.
Color versions of one or more of the figures in this paper are available online
at http://ieeexplore.ieee.org.
Digital Object Identifier 10.1109/JSSC.2015.2504416

Fig. 1 shows an AMOLED display system including column driver ICs [6]–[8], [10], [11] and pixel circuits [3], [5].
The AMOLED display-driving systems have been developed
in terms of three important aspects as follows.
1) High driving speed: As resolution and panel size increase,
a one-horizontal (1 H) time for the driver to program
data voltages (VDATA ) into pixels in a row is continuously
reduced, which means that the driver must have a fast
driving speed.
2) Pixel-to-pixel luminance uniformity: This is mainly due
to temporal and spatial variation in thin-film transistor
(TFT) threshold voltage (VTH ) and mobility (µ), which
results in difference among TFT currents (ITFT ) determining pixel luminance (L). Either internal pixel circuits or
external column drivers must compensate for this.
3) Aperture ratio: Since the aperture ratio determines luminance efficiency, it should be maximized by minimizing
the number (effective area) of pixel circuit components,
such as TFTs and storage capacitors.
A voltage-driving method with in-pixel VTH compensation
circuits, as seen in Fig. 2(a), is commonly used due to the fast
driving speed [3]. However, the pixel circuit cannot compensate for mobility variation. Furthermore, a conventional fiveTFTs/two-storage-capacitors (5T2C) VTH compensation pixel
circuit reduces the aperture ratio. For a high aperture ratio,
the voltage driving with external TFT compensation method
was presented [4]. This method has the advantages of both
a fast driving speed and a high aperture ratio, because no
in-pixel compensation circuit is used. However, it requires additional sensing time before or after displaying with additional
memory and computation resources. Accordingly, human-user
would be very uncomfortable due to wait-time during sensing
operation, and external components may lead to increase in
production costs. Thus, it is thought that the additional compensation time has to be hidden by real-time sensing technique,
and the solution to reduce external memory size is highly
required.
The current-driving method shown in Fig. 2(b) can guarantee
high-current (luminance) uniformity over the panel regardless
of the TFT characteristics [5]–[8]. A 4T1C pixel circuit is used
for the above operation. However, slow driving speed due to
large line capacitance (CP ) and a low-level data current (IDATA )
makes it unsuitable for high-resolution display. Although several proposed settling time reduction techniques have been
proposed, they require line-multiplexing for charge feedforward [7] or an elaborate feedback loop where the bandwidth
is strictly limited by data-line parasitic RC [8].

0018-9200 © 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

BANG et al.: HYBRID AMOLED DRIVER IC FOR REAL-TIME TFT NONUNIFORMITY COMPENSATION

967

Fig. 1. AMOLED driving systems.

Fig. 2. AMOLED driving methods. (a) Voltage driving with in-pixel threshold voltage (VTH ) compensation. (b) Current driving. (c) Digital driving.

As an another alternative, a digital driving method in
Fig. 2(c) has emerged because it is also free from TFT variation
with a simple 2T1C pixel circuit [9]. However, as resolution and
panel size grow, gate scan time becomes too inadequate to even
turn ON the TFT gate.
This paper presents a new innovative approach: a hybrid driving method in which the advantages of both voltage-driving and
current-driving methods are combined. Thus, it achieves driving speed as fast as the voltage-driving method and high TFT
current accuracy as high as the current-driving method [10].

The hybrid-driving method is accompanied with the external
compensation performed in real time; it means that the proposed driving method is able to maintain TFT current uniformity under temporal VTH variation without any inconvenience
for users. In order to measure TFT characteristics in real time,
a hybrid column driver is proposed to accurately sense the TFT
current while driving the data voltage. In addition, since the inpixel VTH compensation circuit is not required, a 3T1C pixel
for high aperture ratio can be employed for the hybrid-driving
method.

968

IEEE JOURNAL OF SOLID-STATE CIRCUITS, VOL. 51, NO. 4, APRIL 2016

Fig. 3. Functional diagram of proposed hybrid-driving method.

Fig. 4. (a) Reduction of TFT current error (ΔI) under hybrid driving. (b) Gray-level grouping for mobility compensation.

This paper is organized as follows. Section II describes
how the proposed hybrid driving method drives the data and
compensates for TFT variation. Section III presents a differential sensing method for accurate current sensing under
display panel noise. Section IV shows circuit implementation of the hybrid column driver. Section V introduces the
circuit-reused current-mode successive-approximation register
(SAR) ADC to measure OLED V-I characteristics for OLED
luminance-degradation compensation. Section VI shows measurement results of a fabricated hybrid column-driver IC, and
Section VII concludes this paper.
II. H YBRID AMOLED D RIVING M ETHOD
The hybrid AMOLED driving method shown in Fig. 3 is
the voltage-driving method with real-time external TFT compensation. To determine the TFT V-I characteristics, the hybrid
column-driver senses the TFT current (ITFT ) and compares it
to the target data current (IDATA ) from a current DAC (CDAC)
right after a voltage-driver programs the data voltage (VDATA ) to
a TFT gate. The comparison (1 bit) results are used to adjust the
next VDATA for the corresponding pixel. Nonuniformity of the
TFT V –I characteristics among pixels and its temporal variation can be digitally compensated for during a normal display

operation. This iterative correction works as an external digital
feedback which minimizes error between ITFT and IDATA .
In the hybrid driving method, programming VDATA and sensing ITFT are performed for every pixel in a row within the 1 H
time. During the first half-period of the 1 H time (SCAN = L),
the voltage driver, which consists of a voltage DAC (VDAC)
and a buffer amplifier, drives VDATA to the TFT gate through
a scan switch. The VDATA corresponding to IDATA is initially
defined in a look-up table (LUT) in a timing controller. At the
next half-period (SENSE = L), when a sense switch is turned
ON , the ITFT corresponding to VDATA flows into the column
driver, and the column driver compares it to IDATA . The comparison results (CMP) differ among pixels, because every TFT
suffers from different variations and every column driver has an
intrinsic offset (VOS ). When the column drivers are in the same
operation for the next rows, a TFT compensation block in the
timing controller increases or decreases the correction voltage
(ΔV) for each pixel by 1 LSB voltage of the VDAC (ΔVLSB )
based on CMP to reduce error between ITFT and IDATA and then
stores ΔV to memory as a graph, as seen in Fig. 4(a). After all
the pixels are programmed and sensed, an OLED cathode voltage (VC,OLED ) is globally connected to ground (proper ELVSS).
Thus, all pixels simultaneously emit the light. After emission,
ΔV for each pixel is added to the voltage data (VDATA,2 ) for the

BANG et al.: HYBRID AMOLED DRIVER IC FOR REAL-TIME TFT NONUNIFORMITY COMPENSATION

969

Fig. 6. Main error sources in current-sensing of hybrid-driving method.

Fig. 7. Simplified block diagram of hybrid column-driver for differential
sensing method.

Fig. 5. Algorithm of real-time TFT current nonuniformity compensation.
(a) Flowchart. (b) Timing operation example. (c) Memory cell for one graylevel group of one pixel.

next frame. Fig. 4(a) shows that the TFT current error (ΔI2 ) is
smaller than the original error (ΔI) by adding ΔV to VDATA,2 . If
the same ΔV is applied to all gray levels, this scheme can only
compensate for dc shifts, such as VTH variation and the driver
offset VOS . Meanwhile, if each gray levels has its own ΔV , it
requires a large amount of memory even though all the variations are elaborately compensated for. Thus, we divided the
256 gray levels into several groups and applied different correction voltages (ΔVk=1,2,...,NGR ) to different groups for mobility
variation compensation. The number of groups (NGR ) is determined by how severe the mobility variation is. Fig. 4(b) shows
an example of gray-level grouping that has four groups.
The front-end driving and sensing by the hybrid column
driver and back-end digital calibration by the timing controller
are repeated until all the pixels are corrected. The algorithm
in Fig. 5(a) shows how the hybrid-driving method adjusts ΔV
until the end of the correction, and Fig. 5(b) describes a timingoperation example. The algorithm to search ΔV for a gray-level
group of a pixel is based on a binary search fashion. EOC is the

end of compensation flag, and CMP* is a previous comparison
result. They are stored in memory for each gray-level group
of each pixel. The compensation is ended (EOC = 1) when
CMP is inverted (CMP∗ = CMP), and the finally searched ΔV
is applied to the driving until EOC is reset after the periodic
refresh time (TR ). Since the varying speed of TFT I–V transfer
characteristics under the normal stress condition is moderately
slow, the refresh time can be longer than 100 s [12]. For a grayscale group of a pixel, the calibration time depends on how
many LSBs are in error between IDATA and ITFT . For example,
if the ITFT at a certain data voltage (VDATA ) has 150 nA difference (< 4 LSB) from the corresponding IDATA , four frame times
(66.7 ms at a frame rate of 60 Hz) are needed to compensate for
this amount of error. Fig. 5(c) shows the memory cell required
for the hybrid-driving method. The number of bits for determines the range of ΔV . The m-bit memory assigned to the ΔV
covers the data-voltage variation of ±(1/210−(m−1) )VFS when
the 10 bit VDAC divides the full-scale voltage (VFS ). Each
(m + 2)- bit memory cell is for a gray-level group of a pixel,
so that the memory cells of (3NROW NCOL NGR ) are required,
where NROW , NCOL , and NGR are the number of rows, columns,
and gray-level groups, respectively. For example, the ultrahigh-definition (UHD, 3840 × 2160) AMOLED display with
four gray groups and a 5 bit ΔV needs just memory size of
83 MB.

970

IEEE JOURNAL OF SOLID-STATE CIRCUITS, VOL. 51, NO. 4, APRIL 2016

Fig. 9. (a) Conventional channel reference current distribution method.
(b) Reference current calibration (RCC). (c) Current sample and hold (S/H).

Fig. 8. (a) Entire block diagram and (b) timing diagram of the
hybrid column-driver operation for odd-column TFT current-sensing
(ODD = H, EVEN = L, TFT = H, OLED = L).

While sensing ITFT , several error sources in Fig. 6 may
deteriorate the sensing accuracy of the hybrid column driver.
The main error sources are classified into two groups: one
from the pixel circuits and the other from the column driver.

From the pixel circuits, a charge injection from the scan switch
(Qsw ) introduces a little error in the voltage stored in the storage capacitor. However, this error can be compensated by the
hybrid driving because the gate voltage error (ΔVG ) is converted to the TFT current error (ΔITFT ), which will be added
to the original ITFT and sensed by the hybrid column driver.
In addition, the drain-source voltage (VDS ) difference of the
main TFT between the case when sensing ITFT (VDS,S ) and
the case when emitting the OLED (VDS,E ) results in the difference between the sensed ITFT (ITFT,S ) and the actual ITFT

BANG et al.: HYBRID AMOLED DRIVER IC FOR REAL-TIME TFT NONUNIFORMITY COMPENSATION

971

of ITFT . Two main sources are the nonlinearity of the CDAC and
the offset of a current comparator (IOS ). Circuit techniques to
minimize these nonidealities will be introduced in Section IV.

III. D IFFERENTIAL S ENSING M ETHOD

Fig. 10. Bit-inversion cascade-dividing CDAC (BICCDAC).

Fig. 11. DNL and INL of BICCDAC from a behavior simulation with a 1%
intentional mismatch in the current divider.

flowing to the OLED (ITFT,E ). However, pixel-to-pixel luminance uniformity is less sensitive to the VDS difference than the
difference between ITFT,S and ITFT,E , because the main TFTs
at a same gray scale suffer a similar VDS difference. Also, the
leakage current (ILEAK ) through the off-resistance of the scan
switches and the sense switches on the data line is also added to
IT F T , and acts as an error source. The off-current of a recently
developed LTPS TFT was reported to be less than 3 pA at VDS
of −5 V within a temperature range from 30 ◦ C to 70 ◦ C [19].
Thus, the total leakage current through 2160 scan and sense
switches on a data line is less than 12.96 nA in the worst case,
which is less than one-third of LSB of the 8 bit CDAC, whose
full-scale current is 10 µA. Lastly, display panel noise on the
data line, which will be discussed in Section III, is an additional error source in the panel. On the other hand, the error
sources from the column driver determine the sensing accuracy

Since one LSB of the 8 bit CDAC, which generates IDATA ,
is less than 40 nA when the full-scale current is 10 µA, ITFT
should be sensed very accurately. However, display panel noise
coming from power supply ripple and ground noise, shown in
Fig. 7, degrades the signal-to-noise ratio (SNR). These voltage noise sources are converted to noise current (iNOISE ) by
capacitance between the data line and the sources, and iNOISE
is added to ITFT . If it is assumed that the peak-to-peak supply ripple is 10 mV at 1 MHz and the parasitic capacitance
between the supply and the data line is 10 pF, the peak-topeak iNOISE is larger than 600 nA. Fortunately, two iNOISE s
from two adjacent data lines show high similarity, because they
suffer from the same noise–source coupling via similar capacitances. Therefore, when sensing the ITFT of only either odd
or even columns, similar iNOISE,o and iNOISE,e induced from
odd and even columns, respectively, can be cancelled by adopting fully differential sensing technique; this differential sensing
method significantly improves panel noise immunity in the
hybrid column driver.
The proposed hybrid column driver in Fig. 7 is designed to
compare ITFT with IDATA by integrating the difference between
two currents and the difference between iNOISE,O and iNOISE,E .
The reason for difference integration is also high noise immunity because noise currents from two lines would be dissimilar
at several points, but the average difference is small. With the
differential sensing method, the hybrid column driver can only
sense the ITFT from one of the two adjacent columns in a
frame even though it can drive both columns. Thus, two column drivers can share one current sensor, including the CDAC,
a Gm -C integrator, and a comparator. If iNOISE,O and iNOISE,E
are similar, integrated voltage (VINT ) by the integrator for the
integration time (TINT ) is given by
 TINT
Gm RS
(ITFT + iNOISE,O ) − (IDATA + iNOISE,E ) dt
CINT 0
Gm RS TINT
(ITFT − IDATA )
(1)
≈
CINT

VINT =

where RS is a current-sensing resistor, Gm is the transconductance of the Gm -C integrator, and CINT is an integration
capacitor. VINT represents the difference between the ITFT and
IDATA , and consequently its polarity implies the comparison
result.

IV. H YBRID C OLUMN -D RIVER C IRCUIT
I MPLEMENTATION
A. Overall Architecture and Operation
To realize the hybrid-driving method, the hybrid column
driver should drive the VDATA and accurately compare ITFT with
IDATA in 1 H time. The driver is also required to support the
differential sensing method for high panel noise immunity.

972

IEEE JOURNAL OF SOLID-STATE CIRCUITS, VOL. 51, NO. 4, APRIL 2016

Fig. 12. Offset-compensated integrating comparator.

Fig. 14. (a) Chip micrograph of prototype IC and (b) layout of the hybrid
column-driver for two columns.

Fig. 13. (a) 8 bit circuit-reused current-mode SAR ADC and (b) its current
data/SAR logic connection in data logic mode and ADC mode.

Fig. 8(a) shows an entire block diagram of the proposed
hybrid column driver for two columns and its connection for
odd-column TFT current sensing (ODD = H). It consists of
two voltage drivers and one current sensor for differential current sensing of two columns. The voltage driver includes a
10 bit VDAC [13] and a class AB buffer amplifier [14] with two
current-sensing resistors (RS1 for sensing the pulling-current
and RS2 for sensing the pushing-current), and the current sensor

is composed of an 8 bit bit-inversion cascaded-dividing CDAC
(BICCDAC) with a reference current calibrator (RCC) and a
proposed offset-compensated integrating comparator (OCIC).
In addition, two bias current sources can source or sink constant
currents (IBIAS ) depending on which current is to be sensed so
as to ensure the legroom of noise current swing.
Fig. 8(b) depicts the timing diagram of the hybrid columndriver operation. It is an example of odd-column TFT current
sensing (ODD = H, EVEN = L, TFT = H, OLED = L). The
first-half of the 1 H time (SCAN = L, OSENSE = H) is a
voltage-driving phase. The SCAN switch in the pixel and
SW1 ∼ 4 in the driver are all closed to drive the VDATA , generated by the VDAC, into the TFT gate by the class AB output
stage. During the next current-sensing phase (SCAN = H),
the SENSE switch of the odd-column pixel is turned ON
(OSENSE = L) so that the ITFT corresponding to VDATA flows
into the odd-column driver through the data line. When the
SCAN switch is turned OFF, its clock feedthrough error is also
reflected in ITFT . On the even channel, IDATA from the CDAC
goes to RS1,E for comparison between ITFT and IDATA . The
noise currents iNOISE from both columns and the IBIAS s go into

BANG et al.: HYBRID AMOLED DRIVER IC FOR REAL-TIME TFT NONUNIFORMITY COMPENSATION

973

Fig. 15. Monte-Carlo simulation results from 100 samples. (a) Worst DNL and INL of the BICCDAC. (b) Histogram of the maximum DNL and INL of the
BICCDAC. (c) Histogram of input-current-referred offset in the OCIC with 100 kΩ of the current-sensing resistor (RS ).

the driver as well. Also, SW1 is turned OFF so that RS1,O and
RS1,E convert these incoming currents to the voltage. Since the
current from a PMOS of the class AB output stage is unwanted,
it is blocked by turning OFF SW3. Here, the outgoing noise current from the driver can break the feedback loop of the voltage
driver because the class AB stage can only sink the output current when SW3 is OFF. Therefore, IBIAS , which is larger than
the amplitude of the noise current, guarantees that some current is always flowing through the NMOS in the output stage.
After the ITFT arrives at the driver, the voltages across RS1,O
and RS1,E (vRS1,O and vRS1,E ), respectively, are given by
vRS1,O = (ITFT + iNOISE,O + IBIAS )RS1,O ,
vRS1,E = (IDATA + iNOISE,E + IBIAS )RS1,E .

(2)

If two RS1 S, two iNOISE S, and two IBIAS S are well-matched,
vRS1,O − vRS1,E is approximately equal to RS1 · (ITFT −
IDATA ). Since the mismatch between two RS1 s is directly
related to column-to-column luminance nonuniformity, their
matching inaccuracy less than 0.4% is required for 8 bit accuracy. The OCIC can compare ITFT to IDATA by integrating this
vRS1,O − vRS1,E during the error-integration phase (INT = H)
and determining the polarity of the integrated voltage VINT at
the end of the integration. In the middle of the integration, an
inversion signal (INV) is toggled to swap the path of two IBIAS s.
By doing so, the mismatch between two bias current sources
is cancelled by averaging. Moreover, the INV signal swaps the
current path of the BICCDAC to reduce its integral nonlinearity
(INL), which will be explained in Section IV-B.

974

Fig. 16. DNL and INL of the 8 bit circuit-reused current-mode SAR ADC.

Fig. 17. Measured waveform of the hybrid-driving under emulated panel noise
of 10 mVpp at 500 kHz with/without the differential sensing method when
sensing the odd-column TFT current.

For high accuracy of the current comparison, which is
directly related to the pixel luminance uniformity, we should
consider linearity of the CDAC, a channel-to-channel reference current uniformity. Section IV-B describes the BICCDAC
and the RCC for these performances. The offset of the OCIC
detailed in Section IV-C also plays an important role in high
accuracy.

B. Data Current Generation
In the hybrid-driving method, what actually determines pixel
luminance is the data current generated by the CDAC. Even
though the voltage driver has the offset and the TFT has VTH and
mobility variation, they can be compensated for by the hybriddriving method if the data current has no error. Thus, the data
current-generation block in the hybrid column driver should
generate the precise data current in terms of column-to-column
current uniformity and CDAC linearity.
Unlike reference voltage, reference current (IREF ) is conventionally distributed to the columns via current mirrors, as
seen in Fig. 9(a), which is prone to mismatch. The IREF mismatch among columns results in column-to-column luminance

IEEE JOURNAL OF SOLID-STATE CIRCUITS, VOL. 51, NO. 4, APRIL 2016

Fig. 18. Current error between two emulated TFTs with threshold voltage
(VTH ) difference of 60 mV before and after compensation.

nonuniformity. To cope with the mismatch problem, the proposed hybrid column-driver IC employs the RCC scheme [15],
which distributes IREF by the current sample and holds (S/H)
circuits in every two columns rather than the current mirrors,
as shown in Fig. 9(b). In turn, the current S/Hs sample IREF
during the voltage-driving phase when the CDAC is not used
and hold it until their turns come again. Since the holding time,
which is proportional to the number of columns, can be several
tens of milliseconds for high resolution display, the current S/H
in Fig. 9(c) should be carefully designed to minimize leakage
current. The main leakage path is an off-resistance of a sample
switch (M2 ). In order to make voltage across M2 nearly zero, a
dummy current S/H in Fig. 9(b) is turned ON (ΦD = H) while
no S/H samples IREF . Thus, a sampling line voltage (VL ) can
be kept to VDDH − VGS1 . In addition, to minimize error from
charge injection to output current (IOUT ), a sampling transistor
(M1 ) is assisted with a constant current source of 0.8 IREF , and
a dummy switch (M2D ) is added.
To convert the digital current data to analog, the bit-inversion
cascaded-dividing CDAC (BICCDAC) in Fig. 10 is adopted in
the hybrid column driver for its small area occupation and high
linearity [15]. The stacked current dividers, biased by VB1−8 ,
divide the IREF of 10 µA and switch flow of these divided
currents based on digital input (D[7:0]). The BICCDAC occupies a small area because no decoder is required. However, the
binary-weighted output current shows bad differential nonlinearity (DNL) and discontinuous INL due to divider mismatches.
Thus, a bit-inversion scheme, realized by path exchangers after
the dividers, is employed to enhance continuity of the INL
curve, and thus, drastically reduces the DNL [16]. This scheme
simply swaps the paths of the current dividers according to their
corresponding digital input. For example, the current paths of
the N th divider are swapped when D[8 − N ] = 1. The effect of
the bit-inversion is shown as DNL curves in Fig. 11. The DNL
and INL in Fig. 11 are obtained from a behavioral simulation of
the BICCDAC with a 1% intentional current divider mismatch.
With the bit-inversion scheme, the maximum DNL of 2.5 LSB
without bit inversion is reduced to less than 0.1 LSB, and the
INL curves become continuous. In addition, the current paths

BANG et al.: HYBRID AMOLED DRIVER IC FOR REAL-TIME TFT NONUNIFORMITY COMPENSATION

975

TABLE I
P ERFORMANCE S UMMARY

of all dividers are swapped by the INV signal, which enables
the hybrid driver to average out the INL.

C. Offset-Compensated Integrating Comparator
Fig. 12 shows the OCIC which accurately compares vRS1,O
to vRS1,E . It is necessary to integrate the input difference and
have a low offset. It is based on a Gm -C integrator composed
of two input pairs (M1,2 and M3−8 ), which can be selected
as incoming (TFT = H) or outgoing (OLED = H) current
sensing, and an integration capacitor (CINT ). A following comparator compares the final integrated voltage across CINT . For
a low offset, an offset-current S/H (M17 , M18 , CS1 , and CS2 )
is connected to the output of Gm in parallel. During an offset
sampling phase (TOS ), inputs are shorted, and the offset-current
S/H is also in sampling mode (Φ1 = H). The S/H samples
common-mode current error between sourcing and sinking current sources, as well as differential-mode current offset. Thus,
it acts as a common-mode feedback circuit unless an input
common-mode level changes for the 1 H time. To maintain the
input common-mode level, one input is always connected to the
resistor which IDATA flows through (EVEN or ODD = H). At
the same time, the following preamplifier (A1 ) samples its own
offset and the difference between VGS17 and VGS18 to offsetsampling capacitor (CS3 and CS4 ). After sampling the offset,
the OCIC integrates the input difference vRS1,O − vRS1,E during the integration phase (TINT ) when inputs are connected to
RS1,O and RS1,E (Φ2 = H). Meanwhile, the following comparator has to detect the polarity of the output (VINT ) right after
integration to exactly average out the IBIAS mismatch and the
CDAC nonlinearity. For that, the comparator needs to be fast to
make a decision in a short time. Instead, the OCIC has an additional decision phase (TD ) to sample VINT (Φ3 = H) and give
the comparator enough time to make a right decision. Since the
transconductor is separated from CINT , it can begin its offset
sampling operation.
To reduce power consumption, all circuits except for the
NMOS input pairs (M3−8 ) and the switches operate under a
low supply voltage (VDDL ) used for logic circuits. The OCIC
consumes 2 µA for incoming-current sensing (TFT = H) and
2.6 µA for outgoing-current sensing (OLED = H).

V. C IRCUIT-R EUSED C URRENT-M ODE SAR ADC
In addition to the TFT variation, OLED luminance degradation due to its limited life span is another source of luminance
nonuniformity in the AMOLED display [17]. Luminance in
OLED pixels degrades depending on luminance time and intensity. Therefore, OLED degradation measurement and compensation are necessary to maximize the lifetime of the AMOLED
display. As one of the principles for OLED degradation measurement, correlation between luminance degradation and electrical degradation of the OLED has been reported in the literature [18]. It was reported that a decrement of an OLED current
(IOLED ) at a constant test anode voltage (VTEST ) is interdependent with degradation of the OLED luminance. This implies
that the display driving system is capable of compensating for
luminance degradation by programming a larger current to the
pixel rather than nominal current if the column driver can measure the VTEST − IOLED relationship. Also, the column driver
is required to sense IOLED in a column-parallel fashion during
a short measurement time, because the measurement is usually done when the display system is turned ON or OFF. In
other words, long time for OLED compensation could give
inconvenience of undesirable light-emitting to the user.
For these reasons, the hybrid column-driver IC embodies a
proposed 8 bit circuit-reused current-mode SAR ADC, shown
in Fig. 13(a). It enables column-parallel OLED current sensing
and requires almost no additional chip area because building blocks of the SAR ADC, such as a DAC, a comparator,
and a SAR logic, are already prepared for hybrid-driving.
The BICCDAC and the OCIC are reused as the DAC and
the comparator, and D flip-flops in the current data logic are
reconfigured as SAR logic by rerouting interconnections, as
shown in Fig. 13(b). Since the direction of the OLED current
is outgoing while that of the TFT current is incoming, sensing circuits must be reconfigured (OLED = H). The outgoing
current-sensing resistor (RS2 ) is used for OLED current sensing, and the BICCDAC in Fig. 10 can change the direction of
the IDATA . The OCIC in Fig. 12 also uses the NMOS input pair
(M3 , M4 ) when sensing the OLED current and repeats its threestep operation (offset-sampling, integration, and decision) for
the 8 bit successive approximation, which takes 8 12 1 H times
of hybrid-driving (65.5 µs) to convert the OLED current to
the digital output. That implies measurement time of 283.3 ms

976

IEEE JOURNAL OF SOLID-STATE CIRCUITS, VOL. 51, NO. 4, APRIL 2016

is needed for sensing the OLED currents of all pixels in the
UHD AMOLED display by virtue of proposed column-parallel
sensing.
VI. C OLUMN -D RIVER IC M EASUREMENT R ESULTS
The prototype of the hybrid driver IC is fabricated in a
1P4M 0.18 µm CMOS process. A chip micrograph is shown
in Fig. 14(a). A prototype includes 102 channels of the hybrid
column driver and the test-element groups (TEG) in a chip
area of 5 × 1.5 mm2 . Fig. 14(b) shows a layout of the twocolumn hybrid column driver. It shows that only 55% of the
conventional voltage-driver area is additional for data current
generation, the current comparison, and the current-mode ADC.
The linearity of the BICCDAC and the offset of the OCIC
were verified with 100 samples in a Monte-Carlo simulation.
Fig. 15(a) shows the worst DNL and INL curves from 100
samples of the BICCDAC when the full-scale reference current
(IREF ) is designed to be 10 µA. With the bit-inversion scheme,
the DNLs at the bit-transition points are significantly reduced
so that the INL curve becomes more continuous. Also, the
INL of the averaged current output of INV = 0 and INV = 1
is less than 0.1 LSB even in the worst case. A histogram of
the maximum DNL is also shown in Fig. 15(b). Thanks to
the bit-inversion scheme, the maximum DNL of 100 samples
is reduced from 1.538 LSB to 0.152 LSB. The histogram in
Fig. 15(c) demonstrates the spread of the input-current-referred
offset of the OCIC when 100 kΩ of the current-sensing resistor
(RS ) is used. The linearity of the BICCDAC and the offset of
the OCIC were also verified by the measured INL and DNL
plots of the 8 bit circuit-reused current-mode ADC in Fig. 16,
because the ADC includes the BICCDAC and the OCIC.
The maximum DNL is 0.56 LSB and the maximum INL is
0.75 LSB.
Fig. 17 shows the measured waveform of hybrid-driving
under emulated panel noise of 10mVpp at 500 kHz, coupling via
data line capacitance of 30 pF, when sensing the odd-column
TFT current. The vINT is the output of the Gm -C integrator in
the OCIC, and the vRS1,O and vRS1,E are the voltages of the
current-sensing resistors (RS1,O and RS2,E , respectively). The
differential sensing method enables the OCIC to unilaterally
integrate ITFT − IDATA . The slope change in the middle of the
TINT is from exchanging the paths of the IBIAS s and the inversion of the BICCDAC. On the other hand, it is clearly observed
in the right-hand side of the waveform that the monotonicity
of the vINT during the integration of small current difference is
significantly broken by the panel noise without the differential
sensing method.
In order to verify the performance of the hybrid-driving
method, we measured TFT current error between two CMOSmodeled TFTs with a VTH difference of 60 mV, as shown in
Fig. 18. First, we measured the VG − ITFT curve of the reference TFT and selected 256 data voltages corresponding to 256
gray levels among 1024 data voltages. The VTH difference is
realized by adjusting body voltage of the CMOS-modeled TFT.
Without the compensation, which means that the same data
voltage is applied to each gray level, the maximum current error
is 501 nA (12.82 gray level). However, after hybrid driving with
random input data for 256 times, the maximum error is reduced

by 59 nA (1.45 gray level) when the identical ΔV is obtained
by hybrid-driving and applied to all gray levels. If dividing gray
levels into two or four groups and finding ΔV of each group for
more accurate compensation, the maximum error is measured
as 37 nA (0.94 gray level) when separating into four groups.
A performance summary is given in Table I. The hybrid column driver occupies 794 × 24.5 µm2 per channel. Under data
line resistance and capacitance of 30 kΩ and 30 pF, the hybrid
column driver takes 7.5 µs, which is the 1 H time for UHD
60 Hz driving, to drive the data voltage and sense the TFT current with static power consumption of 63.60 µW per channel.
The driver statically consumes 68.52 µW per channel in ADC
mode for OLED current sensing. The voltage driver divides the
full-scale output voltage swing ranging from 1.5 to 5 V into
1024 gray levels under a 5 V supply, and the full-scale reference
current is 10 µA.

VII. C ONCLUSION
A hybrid AMOLED driver IC with real-time TFT nonuniformity compensation has been designed and verified through
chip fabrication and measurements. The proposed hybriddriving method achieves driving speed as fast as voltage-driving
while maintaining TFT current accuracy as high as currentdriving through accurate TFT current-sensing of the hybrid
column driver. The differential sensing method enhances panel
noise immunity, and the OCIC and the bit-inversion cascadeddividing DAC (BICCDAC) increase current-sensing accuracy
of the driver. The 8 bit circuit-reused current-mode SAR ADC
embedded in the column driver measures the OLED current
to compensate for luminance degradation with a minimum
increase in area. The proposed hybrid-driving method and column driver IC are applicable to high-resolution, high-quality
AMOLED applications.

R EFERENCES
[1] A. Nathan, A. Kumar, K. Sakariya, P. Servati, S. Sambandan, and
D. Striakhilev, “Amorphous silicon thin film transistor circuit integration for organic LED displays on glass and plastic,” IEEE J. Solid-State
Circuits, vol. 39, no. 9, pp. 1477–1486, Sep. 2004.
[2] D.-U. Jin et al., “World-largest (6.5”) flexible full color top emission
AMOLED display on plastic film and its bending properties,” in SID
Symp. Dig. Tech. Papers, 2012, pp. 983–985.
[3] N. Komiya, C. Oh, K. Eom, Y. Kim, S. Park, and S. Kim, “A 2.0-in.
AMOLED panel with voltage programming pixel circuits and point scanning data driver circuits,” in Proc. Int. Disp. Workshops (IDW’04), 2004,
pp. 283–286.
[4] H.-J. In and O.-K. Kwon, “External compensation of nonuniform electrical characteristics of thin-film transistors and degradation of OLED
devices in AMOLED displays,” IEEE Electron. Device Lett., vol. 30,
no. 4, pp. 377–379, Apr. 2009.
[5] M. Ohta, H. Tsutsu, H. Takahara, I. Kobayashi, T. Uemura, and
Y. Takubo, “A novel current programmed pixel for active matrix OLED
displays,” in SID Symp. Dig. Tech. Papers, 2003, pp. 108–111.
[6] J. H. Baek et al., “A current-mode display driver IC using sample-andhold scheme for QVGA full-color AMOLED displays,” IEEE J. SolidState Circuits, vol. 41, no. 12, pp. 2974–2982, Dec. 2006.
[7] Y.-J. Jeon, J.-Y. Jeon, Y.-S. Son, J. Huh, and G.-H. Cho, “A high-speed
current-mode data driver with push-pull transient current feedforward for
full-HD AMOLED displays,” IEEE J. Solid-State Circuits, vol. 45, no. 9,
pp. 1881–1895, Sep. 2010.
[8] J.-Y. Jeon et al., “A direct-type fast feedback current driver for mediumto large-size AMOLED displays,” in IEEE Int. Solid-State Circuits Conf.
(ISSCC) Dig. Tech. Papers, 2008, pp. 174–175.

BANG et al.: HYBRID AMOLED DRIVER IC FOR REAL-TIME TFT NONUNIFORMITY COMPENSATION

[9] J. Jang, M. Kwon, E. Tjandranegara, K. Lee, and B. Jung, “A digital
driving technique for an 8 b QVGA AMOLED display using ΔΣ modulation,” in IEEE Int. Solid-State Circuits Conf. (ISSCC) Dig. Tech. Papers,
2009, pp. 270–271.
[10] J.-S. Bang et al., “Hybrid driver IC for real-time TFT non-uniformity
compensation of ultra high-definition AMOLED display,” in IEEE Symp.
VLSI Circuits Dig. Tech. Papers, 2015, pp. 326–327.
[11] J.-S. Bang, H.-S. Kim, S.-H. Park, G.-H. Kim, and G.-H. Cho, “A
real-time TFT compensation through power line current sensing for highresolution AMOLED displays,” in SID Symp. Dig. Tech. Papers, 2014,
pp. 724–727.
[12] G. R. Chaji and A. Nathan, “A current-mode comparator for digital calibration of amorphous silicon AMOLED displays,” IEEE Trans. Circuits
Syst. II, vol. 55, no. 7, pp. 614–618, Jul. 2008.
[13] J.-S. Kang et al., “10-bit driver IC using 3-bit DAC embedded operational
amplifier for spatial optical modulators (SOMs),” IEEE J. Solid-State
Circuits, vol. 42, no. 12, pp. 2913–2922, Dec. 2007.
[14] R. Hogervorst, J. P. Tero, R. G. H. Eschauzier, and J. H. Huijsing, “A
compact power-efficient 3 V CMOS rail-to-rail input/output operational
amplifier for VLSI cell libraries,” IEEE J. Solid-State Circuits, vol. 29,
no. 12, pp. 1505–1513, Dec. 1994.
[15] K.-D. Kim et al., “A 10-bit compact current DAC architecture for largesize AMOLED displays,” in SID Symp. Dig. Tech. Papers, 2011, pp. 334–
337.
[16] Y.-K. Choi et al., “A compact low-power CDAC architecture for mobile
TFT-LCD driver ICs,” in IEEE Int. Solid-State Circuits Conf. (ISSCC)
Dig. Tech. Papers, Feb. 2008, pp. 176–177.
[17] C. Féry, B. Racine, D. Vaufrey, H. Doyeux, and S. Ciná, “Physical mechanism responsible for the stretched exponential decay behavior of aging
organic light-emitting diodes,” Appl. Phys. Lett., vol. 87, p. 213502, Nov.
2005.
[18] G. R. Chaji et al., “Electrical compensation of OLED luminance degradation,” IEEE Electron Device Lett., vol. 28, no. 12, pp. 1108–1110, Dec.
2007.
[19] H.-S. Kim and K.-Y. Han, “High-linearity in-pixel thermal sensor using
low-temperature poly-si thin-film transistors,” IEEE Sensors J., vol. 15,
no. 2, pp. 963–970, Feb. 2015.

and the IEEE SSCS Seoul Chapter Best Student JSSC Paper Award in 2014.
His research result of the high-definition multienergy medical image sensor was
specially selected as one of Top 10 Achievements of 2011 that put KAIST on
the spotlight. Medical X-ray image sensor ICs and LCD/OLED display driver
ICs that were architected and designed by him received three IEEE ISSCC
presentations from 2011 to 2013, consecutively.

Ki-Duk Kim (S’14) received the B.S. degree (highest Hons.) from Korea Aerospace University, Seoul,
South Korea, in 2007, and the M.S. degree from
Korea Advanced Institute of Science and Technology
(KAIST), Daejeon, South Korea, in 2009, both in
electrical engineering. He has been pursuing the
Ph.D. degree in electrical engineering at KAIST since
2014.
From 2009 to 2014, he was with Samsung
Electronics, Suwon, South Korea, and worked on circuit and system designs for display driver IC and
touch controller IC. He has authored and coauthored over 10 journal publications and conference presentations in the solid-state circuits and display area
including ISSCC, VLSI, SID, ASSCC, and the IEEE JSSC. He holds more
than 30 U.S., European, Japanese, Chinese, and Korea patents. His research
interests include 3-D touch system for next generation smartphone, QUHD
AMOLED display driver, and high-efficiency buck-boost dc–dc converter for
power management system, in the field of CMOS analog integrated circuit
design.
Mr. Kim was the recipient of the Bronze Medal in the Human-Tech Paper
Awards hosted by Samsung Electronics in 2010, the First Prize Award in the
Samsung Semiconductor Technical Paper in 2010 and 2011 (twice), and the
Distinguished Paper Award in SID (2011). The ICs that were architected and
designed by him won six ISSCC, VLSI, and SID presentations from 2009 to
2014.

Oh-Jo Kwon received the B.S. degree in electrical
engineering from Korea University, Seoul, Korea, in
2001.
He is currently with Samsung Display Co. Ltd. His
research interests include analog circuit design for
displays.

Jun-Suk Bang received the B.S. degree from
Hanyang University, Seoul, Korea, in 2011, and
the M.S. degree from Korea Advanced Institute of
Science and Technology (KAIST), Daejeon, Korea,
in 2014, all in electrical engineering. He is currently
working toward the Ph.D. degree in the Department
of Electrical Engineering at KAIST.
His research interests include analog circuit
designs for AMOLED displays and sensing circuits
for biomedical CMOS ICs.

Hyun-Sik Kim (S’11–M’15) received the B.S.
degree (with the top academic rank) from Hanyang
University, Seoul, South Korea, in 2009, and the M.S.
and Ph.D. degrees from Korea Advanced Institute of
Science and Technology (KAIST), Daejeon, Korea,
in 2011 and 2014, respectively, all in electrical
engineering.
In 2014, He joined Samsung Display Company
Ltd., Yongin, Korea, where he was involved in developments of new display driving system, TFT backplane panel design, module manufacturing process,
and visual inspection process for large-sized OLED/LCD displays. Since
September of 2015, he has been with the Department of Display Engineering,
Dankook University, Cheonan, South Korea, where he is currently an Assistant
Professor. He has authored or coauthored 25 international journal publications
and conference presentations in the solid-state circuits and display areas. He
holds over 45 U.S., European, Japanese, and Korean patents. His research interests include CMOS analog-integrated circuit design, TFT back-plane panel
design, CMOS mixed-signal circuits, and display driver ICs with new driving
schemes for large-sized OLED/LCD TVs.
Dr. Kim was the recipient of the two Gold Prizes in the 18th and 19th HumanTech Paper Awards hosted by Samsung Electronics in 2012 and 2013, the IEEE
Solid-State Circuits Society (SSCS) Pre-Doctoral Achievement Award in 2014,

977

Choong-Sun Shin received the B.S. and M.S.
degrees in electronics engineering from Seoul
National University, Seoul, South Korea, in 1989 and
1991, respectively.
He had designed various DRAMs such as LPDDR2
and DDR3 until 2011. Since joining Samsung
Display, Yongin, Korea, in 2011, he has been developing display driving circuitry. He is also an Inventor
on over 30 US and Korean patents in semiconductor memory device and display driving. His research
interests include display driver ICs, readout ICs, and
touch panel controllers.

Joohyung Lee received the B.S. and M.S. degrees in
electronics from Pohang University of Science and
Technology (POSTECH), Pohang, South Korea, in
1991 and 1993, respectively, and the Ph.D. degree
in electrical engineering from the University of
Wisconsin, Madison, WI, USA, in 2003.
Since 1993, he has been with Samsung Electronics
Co. Ltd., Suwon, South Korea. Currently, he is a
Vice President of Samsung Display Co. Ltd., Yongin,
South Korea, and working on display product development. His research interests include panel-driving
technology, integrated circuit design using TFTs, image processing algorithm,
and integrated sensor and sensing circuitry.

978

Gyu-Hyeong
Cho
(S’76–M’80–SM’11–F’16)
received the B.S. degree from Hanyang University,
Seoul, South Korea, and the M.S. and Ph.D. degrees
from Korea Advanced Institute of Science and
Technology (KAIST), Seoul, South Korea, in
1975, 1977, and 1981, respectively, all in electrical
engineering.
From 1982 to 1983, he was with Westinghouse
R&D Center, Pittsburgh, PA, USA. In 1984, he joined
the Department of Electrical Engineering, KAIST,
where he has been a Full Professor since 1991. He
has authored 1 book on advanced electronic circuits and authored or coauthored
over 200 technical papers and 80 patents. His research interests include power
electronics, soft switching converters, high power converters, analog integrated
circuit design, power management ICs, class-D amplifiers, touch sensors, and
drivers for AMOLED and LCD flat panel displays, biosensors, and wireless
power transfer systems.
Dr. Cho is currently an Associate Editor of the IEEE J OURNAL OF S OLID S TATE C IRCUITS . He served as a member of the ISSCC international technical
program committee. He was the recipient of the Outstanding Teaching Award
from KAIST, and the ISSCC Author-Recognition Award at the ISSCC 60th
Anniversary in 2013, as one of the top 16 contributors of the conference during
last 60 years in ISSCC.

IEEE JOURNAL OF SOLID-STATE CIRCUITS, VOL. 51, NO. 4, APRIL 2016

Journal of Artificial Intelligence Research 43 (2012) 571-620

Submitted 09/11; published 04/12

Reformulating the Situation Calculus and the Event
Calculus in the General Theory of Stable Models and in
Answer Set Programming

Joohyung Lee
Ravi Palla

joolee@asu.edu
Ravi.Palla@asu.edu

School of Computing, Informatics,
and Decision Systems Engineering
Arizona State University
Tempe, AZ 85287, USA

Abstract
Circumscription and logic programs under the stable model semantics are two wellknown nonmonotonic formalisms. The former has served as a basis of classical logic based
action formalisms, such as the situation calculus, the event calculus and temporal action
logics; the latter has served as a basis of a family of action languages, such as language A
and several of its descendants. Based on the discovery that circumscription and the stable
model semantics coincide on a class of canonical formulas, we reformulate the situation
calculus and the event calculus in the general theory of stable models. We also present a
translation that turns the reformulations further into answer set programs, so that efficient
answer set solvers can be applied to compute the situation calculus and the event calculus.

1. Introduction
Circumscription (McCarthy, 1980, 1986) and logic programs under the stable model semantics (Gelfond & Lifschitz, 1988) are two well-known nonmonotonic formalisms. As one of the
oldest nonmonotonic formalisms, circumscription has found many applications in commonsense reasoning and model-based diagnoses (e.g., McCarthy, 1986; Shanahan, 1995; Besnard
& Cordier, 1994). The stable model semantics is the mathematical basis of Answer Set Programming (ASP) (Marek & Truszczyński, 1999; Niemelä, 1999; Lifschitz, 2008), which is
being widely applied thanks to the availability of several efficient implementations, known
as answer set solvers.
While the two nonmonotonic formalisms have been applied to overlapping classes of
problems, minimal model reasoning ensured by circumscription does not coincide with stable
model reasoning. Moreover, these formalisms have different roots. While circumscription
is defined in terms of translation into classical (second-order) logic, stable models proposed
by Gelfond and Lifschitz (1988) are defined in terms of grounding and fixpoints in the
style of Reiter’s default logic (Reiter, 1980). These differences in part account for the fact
that the two formalisms have formed rather disparate traditions in knowledge representation
research. In particular, in the area of temporal reasoning, the former has served as a basis of
classical logic based action calculi, such as the situation calculus (McCarthy & Hayes, 1969;
Reiter, 2001), the event calculus (Shanahan, 1995) and temporal action logics (Doherty,
c

2012
AI Access Foundation. All rights reserved.

Lee & Palla

Gustafsson, Karlsson, & Kvarnström, 1998), whereas the latter has served as a basis of a
family of action languages, such as language A (Gelfond & Lifschitz, 1998) and several of its
descendants which can be translated into logic programs under the stable model semantics.
However, a recent generalization of the stable model semantics shed new light on the
relationship between circumscription and stable models. The first-order stable model semantics defined by Ferraris, Lee and Lifschitz (2007, 2011) characterizes the stable models
of a first-order sentence as the models (in the sense of first-order logic) of the sentence
that satisfy the “stability” condition, expressed by a second-order formula that is similar
to the one used to define circumscription. Since logic programs are viewed as a special
class of first-order sentences under the stable model semantics, this definition extends the
stable model semantics by Gelfond and Lifschitz (1988) to the full first-order level without
limiting attention to Herbrand models. Essentially the same characterization was independently given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin
& Shoham, 1992). These definitions are also equivalent to the definition of Quantified Equilibrium Logic given by Pearce and Valverde (2005), which is defined in terms of the logic of
Here-and-There (Heyting, 1930).
The new definition of a stable model motivates us to investigate the relationship between
stable model reasoning and minimal model reasoning. In particular, we focus on their
relationship in the area of temporal reasoning. We show how the situation calculus and the
event calculus can be reformulated in the first-order stable model semantics, and further in
ASP. This is not only theoretically interesting, but also practically useful as it allows us to
leverage efficient answer set solvers for computing circumscriptive action theories.
For this, we develop two technical results. First, we show that circumscription and the
first-order stable model semantics coincide on the class of canonical formulas. This is the
largest syntactic class identified so far on which the two semantics coincide, and is general
enough to cover several circumscriptive action formalisms, such as the situation calculus,
the event calculus, and temporal action logics. The result allows us to reformulate those
action formalisms in the first-order stable model semantics. While minimal model reasoning
sometimes leads to unintuitive results, those circumscriptive action formalisms are carefully
designed to avoid such cases, and our result implies that minimal model reasoning in those
action formalisms can also be viewed as stable model reasoning.
Second, we identify a class of almost universal formulas, which can be turned into the
syntax of a logic program while preserving stable models. It turns out that the reformulations of the situation calculus and the event calculus in the first-order stable model
semantics fall into this class of formulas. We introduce system f2lp that turns formulas in
this class to logic programs, and, in conjunction with the result on canonical formulas, use
the combination of f2lp and answer set solvers to compute the situation calculus and the
event calculus.
Our work makes explicit the relationship between classical logic and logic program traditions in temporal reasoning. Interestingly, the development of the event calculus has
spanned over both traditions. The original version of the event calculus (Kowalski & Sergot, 1986) was formulated in logic programs, but not under the stable model semantics (that
was the time before the invention of the stable model semantics). More extensive developments have been later carried out on the classical logic foundation via circumscription (e.g.,
Shanahan, 1995, 1997, 1999; Miller & Shanahan, 1999; Mueller, 2004), but the relation to
572

Reformulating the Situation Calculus and the Event Calculus

the logic program formulation remained implicit. Based on the reduction of circumscription to completion, SAT-based event calculus systems were implemented, one by Shanahan
and Witkowski (2004) and another by Mueller (2004). The latter system is called the dec
reasoner,1 which outperforms the former thanks to a more efficient and general compilation
method into propositional logic. While the system handles a large fragment of the event
calculus, it still cannot handle recursive and disjunctive axioms since completion cannot
be applied to such axioms. Our ASP-based approach on the other hand can handle the
full version of the event calculus under the assumption that the domain is given and finite.
Thanks to the efficiency of ASP solvers, our experiments indicate that the ASP-based event
calculus reasoner is significantly faster than the dec reasoner (Appendix B).
Similar to the logic programming tradition of the event calculus, the situation calculus (McCarthy & Hayes, 1969; Reiter, 2001) can be implemented in Prolog, based on the
fact that Clark’s completion semantics accounts for definitional axioms. But unlike the
event calculus, to the best of our knowledge, efficient propositional solvers have not been
applied to directly compute the models of situation calculus theories. In this paper, we
reformulate Lin’s causal action theories (1995) and Reiter’s basic action theories (2001) in
the first-order stable model semantics and in ASP. For basic action theories, we also provide
an ASP-based encoding method that obtains Reiter’s successor state axioms from the effect
axioms and the generic inertia axioms adopted in ASP, the idea of which is close to Reiter’s
frame default (1980).
The paper is organized as follows. The next section reviews the definitions of circumscription and the first-order stable model semantics, and presents the definition of a
canonical formula. Based on this, Sections 3 and 4 reformulate the event calculus and the
situation calculus in the first-order stable model semantics. Section 5 shows a translation
that turns almost universal formulas into logic programs that can be accepted by ASP
solvers. Sections 6 and 7 use this result to turn the reformulations of the event calculus
and the situation calculus given in Sections 3 and 4 into the input language of ASP solvers.
Complete proofs are given in Appendix C.

2. Circumscription and First-Order Stable Model Semantics
We assume the following set of primitive propositional connectives and quantifiers:
⊥ (falsity), ∧, ∨, →, ∀, ∃ .
We understand ¬F as an abbreviation of F → ⊥; symbol > stands for ⊥ → ⊥, and F ↔ G
stands for (F → G) ∧ (G → F ).
2.1 Review: Circumscription
Let p be a list of distinct predicate constants p1 , . . . , pn , and let u be a list of distinct
predicate variables u1 , . . . , un . By u ≤ p we denote the conjunction of the formulas
∀x(ui (x) → pi (x)) for all i = 1, . . . n, where x is a list of distinct object variables whose
length is the same as the arity of pi . Expression u < p stands for (u ≤ p) ∧ ¬(p ≤ u). For
1. http://decreasoner.sourceforge.net

573

Lee & Palla

instance, if p and q are unary predicate constants then (u, v) < (p, q) is


∀x(u(x) → p(x)) ∧ ∀x(v(x) → q(x)) ∧ ¬ ∀x(p(x) → u(x)) ∧ ∀x(q(x) → v(x)) .
Circumscription is defined in terms of the CIRC operator with minimized predicates.
For any first-order formula F , expression CIRC[F ; p] stands for the second-order formula
F ∧ ¬∃u((u < p) ∧ F (u)),
where F (u) is the formula obtained from F by substituting ui for pi . When F is a sentence
(i.e., a formula with no free variables), intuitively, the models of CIRC[F ; p] are the models
of F that are “minimal” on p.
The definition is straightforwardly extended to the case when F is a many-sorted firstorder formula (Lifschitz, 1994, Section 2.4), which is the language that the event calculus
and the situation calculus are based on.
2.2 Review: First-Order Stable Model Semantics
This review follows the definition by Ferraris et al. (2011). There, the stable models are
defined in terms of the SM operator, whose definition is similar to the CIRC operator in
the previous section. For any first-order formula F and any finite list of predicate constants
p = (p1 , . . . , pn ), formula SM[F ; p] is defined as
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where u is defined the same as in CIRC[F ; p], and F ∗ (u) is defined recursively as follows:
• pi (t)∗ = ui (t) for any list t of terms;
• F ∗ = F for any atomic formula F (including ⊥ and equality) that does not contain
members of p;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;
• (∃xF )∗ = ∃xF ∗ .
The predicates in p are called intensional: these are the predicates that we “intend to
characterize” by F in terms of non-intensional predicates.2 When F is a sentence, the models
of the second-order sentence SM[F ; p] are called the p-stable models of F : they are the
models of F that are “stable” on p. We will often simply write SM[F ] in place of SM[F ; p]
when p is the list of all predicate constants occurring in F . According to Lee, Lifschitz, and
2. Intensional predicates are analogous to output predicates in Datalog, and non-intensional predicates are
analogous to input predicates in Datalog (Lifschitz, 2011).

574

Reformulating the Situation Calculus and the Event Calculus

Palla (2008), answer sets are defined as a special class of stable models as follows. By σ(F )
we denote the signature consisting of the object, function and predicate constants occurring
in F . If F contains at least one object constant, an Herbrand interpretation of σ(F ) that
satisfies SM[F ] is called an answer set of F . The answer sets of a logic program Π are defined
as the answer sets of the FOL-representation of Π (i.e., the conjunction of the universal
closures of implications corresponding to the rules). For example, the FOL-representation
of the program
p(a)
q(b)
r(x) ← p(x), not q(x)
is
p(a) ∧ q(b) ∧ ∀x(p(x) ∧ ¬q(x) → r(x))

(1)

and SM[F ] is
p(a) ∧ q(b) ∧ ∀x(p(x) ∧ ¬q(x) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x((u(x) ∧ (¬v(x) ∧ ¬q(x)) → w(x)) ∧ (p(x) ∧ ¬q(x) → r(x)))),
which is equivalent to the first-order sentence
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b) ∧ ∀x(r(x) ↔ (p(x) ∧ ¬q(x)))

(2)

(Ferraris et al., 2007, Example 3). The stable models of F are any first-order models of (2).
The only answer set of F is the Herbrand model {p(a), q(b), r(a)}.
According to Ferraris et al. (2011), this definition of an answer set, when applied to the
syntax of logic programs, is equivalent to the traditional definition of an answer set that is
based on grounding and fixpoints (Gelfond & Lifschitz, 1988).
Note that the definition of a stable model is more general than the definition of an
answer set in the following ways: stable models are not restricted to Herbrand models, the
underlying signature can be arbitrary, and the intensional predicates are not fixed to the
list of predicate constants occurring in the formula. The last fact is not essential in view of
the following proposition. By pr (F ) we denote the list of all predicate constants occurring
in F ; by Choice(p) we denote the conjunction of “choice formulas” ∀x(p(x) ∨ ¬p(x)) for
all predicate constants p in p, where x is a list of distinct object variables; by False(p) we
denote the conjunction of ∀x¬p(x) for all predicate constants p in p. We sometimes identify
a list with the corresponding set when there is no confusion.
Proposition 1 Formula
SM[F ; p] ↔ SM[F ∧ Choice(pr (F )\p) ∧ False(p\pr (F ))]

(3)

is logically valid.
Notice that the (implicit) intensional predicates on the right-hand side of (3) are those
in (pr (F ) ∪ p). The Choice formula makes the predicates in (pr (F ) \ p) to be exempt
from the stability checking. On the other hand, the False formula makes the predicates in
(p \ pr (F )) to be stabilized (i.e., to have empty extents), though they do not occur in F .
575

Lee & Palla

Ferraris et al. (2011) incorporate strong negation into the stable model semantics by
distinguishing between intensional predicates of two kinds, positive and negative. Each
negative intensional predicate has the form ∼p, where p is a positive intensional predicate
and ‘∼’ is a symbol for strong negation. Syntactically ∼ is not a logical connective, as
it can appear only as a part of a predicate constant. An interpretation of the underlying
signature is coherent if it satisfies the formula
¬∃x(p(x) ∧ ∼p(x)),

(4)

where x is a list of distinct object variables, for each negative predicate ∼p. We usually
consider coherent interpretations only. Intuitively, ∼p(t) represents that p(t) is false. This
is different from ¬p(t) which represents that it is not known that p(t) is true. Similarly,
¬ ∼p(t) represents that it is not known that p(t) is false, and ¬¬p(t) represents that it is
not known that p(t) is not known to be true. Note that, unlike in first-order logic, ¬¬p(t)
is different from p(t). For instance, formula p(a) has only one answer set {p(a)} but ¬¬p(a)
has no answer sets.
Like the extension of circumscription to many-sorted first-order sentences, the definition
of a stable model is straightforwardly extended to many-sorted first-order sentences.
2.3 Equivalence of the Stable Model Semantics and Circumscription on
Canonical Formulas
Neither the stable model semantics nor circumscription is stronger than the other. For
example,
CIRC[∀x(p(x) ∨ ¬p(x)); p]
(5)
is equivalent to ∀x¬p(x), and
SM[∀x(p(x) ∨ ¬p(x)); p]

(6)

is equivalent to >, so that (5) is stronger than (6). On the other hand,
CIRC[∀x(¬p(x) → q(x)); p, q]

(7)

is equivalent to ∀x(¬p(x) ↔ q(x)), and
SM[∀x(¬p(x) → q(x)); p, q]

(8)

is equivalent to ∀x(¬p(x) ∧ q(x)), so that (8) is stronger than (7).
In this section, we show that the two semantics coincide on a class of formulas called
canonical formulas, which we define below. We first review the notions of positive, negative,
and strictly positive occurrences.
Definition 1 We say that an occurrence of a predicate constant, or any other subexpression, in a formula F is positive if the number of implications containing that occurrence in
the antecedent is even, and negative otherwise. (Recall that we treat ¬G as shorthand for
G → ⊥.) We say that the occurrence is strictly positive if the number of implications in F
containing that occurrence in the antecedent is 0.
576

Reformulating the Situation Calculus and the Event Calculus

For example, in (1), both occurrences of q are positive, but only the first one is strictly
positive.
Definition 2 We say that a formula F is canonical relative to a list p of predicate constants
if
• no occurrence of a predicate constant from p is in the antecedents of more than one
implication in F , and
• every occurrence of a predicate constant from p that is in the scope of a strictly positive
occurrence of ∃ or ∨ in F is strictly positive in F .
Example 1 The formula
∀x(¬p(x) → q(x))

(9)

that is shown above is not canonical relative to {p, q} since it does not satisfy the first clause
of the definition (p occurs in the antecedents of two implications as ¬p(x) is shorthand for
p(x) → ⊥). On the other hand, the formula is canonical relative to {q}. The formula
∀x(p(x) ∨ ¬p(x))

(10)

is not canonical relative to {p} since it does not satisfy the second clause (the second occurrence of p is in the scope of a strictly positive occurrence of ∨, but is not strictly positive in
(10)); the formula
p(a) ∧ (∃x p(x) → ∃x q(x))
(11)
is canonical relative to {p, q}, while
p(a, a) ∧ ∃x(p(x, a) → p(b, x))

(12)

is not canonical relative to {p, q} since it does not satisfy the second clause (the second
occurrence of p is in the scope of a strictly positive occurrence of ∃, but is not strictly
positive in formula (12)).
The following theorem states that, for any canonical formula, circumscription coincides
with the stable model semantics.
Theorem 1 For any canonical formula F relative to p,
CIRC[F ; p] ↔ SM[F ; p]

(13)

is logically valid.
For instance, for formula (11), which is canonical relative to {p, q}, formulas CIRC[(11); p, q]
and SM[(11); p, q] are equivalent to each other. Also, any sentence F is clearly canonical
relative to ∅, so that CIRC[F ; ∅] is equivalent to SM[F ; ∅], which in turn is equivalent to F .
On the other hand, such equivalence may not necessarily hold for non-canonical formulas.
For instance, we observed that, for formula (10) that is not canonical relative to {p}, formulas (5) and (6) are not equivalent to each other. For formula (9) that is not canonical
577

Lee & Palla

relative to {p, q}, formulas (7) and (8) are not equivalent to each other. We also observe
that formula (12) that is not canonical relative to {p, q}, CIRC[(12); p, q] is not equivalent
to SM[(12); p, q]: the Herbrand interpretation {p(a, a), p(b, a)} satisfies SM[(12); p, q], but
does not satisfy CIRC[(12); p, q].
Note that non-canonical formulas can often be equivalently rewritten as canonical formulas. Since any equivalent transformation preserves the models of circumscription, Theorem 1 can be applied to such non-canonical formulas, by first rewriting them as canonical
formulas. For example, formula (9) is equivalent to
∀x(p(x) ∨ q(x)),

(14)

which is canonical relative to {p, q}, so that CIRC[(9); p, q] is equivalent to SM[(14); p, q].
For another example, formula (10) is equivalent to
∀x(p(x) → p(x)),

(15)

which is canonical relative to {p}, so that CIRC[(10); p] is equivalent to SM[(15); p]. It
is clear that this treatment can be applied to any quantifier-free formula (including any
propositional formula) because a quantifier-free formula can be equivalently rewritten as a
canonical formula by first rewriting it into a clausal normal form and then turning each
clause into the form C → D, where C is a conjunction of atoms and D is a disjunction of
atoms.3
Sections 3 and 4 use Theorem 1 to reformulate the event calculus and the situation
calculus in the first-order stable model semantics.

3. Reformulating the Event Calculus in the General Theory of Stable
Models
In this section, we review the syntax of circumscriptive event calculus described in Chapter 2
of the book by Mueller (2006). Based on the observation that the syntax conforms to the
condition of canonicality, we present a few reformulations of the event calculus in the general
theory of stable models.
3.1 Review: Circumscriptive Event Calculus
We assume a many-sorted first-order language, which contains an event sort, a fluent sort,
and a timepoint sort. A fluent term is a term whose sort is a fluent; an event term and a
timepoint term are defined similarly.
Definition 3 A condition is defined recursively as follows:
• If τ1 and τ2 are terms, then comparisons τ1 < τ2 , τ1 ≤ τ2 , τ1 ≥ τ2 , τ1 > τ2 , τ1 = τ2 ,
τ1 6= τ2 are conditions;
3. It appears unlikely that knowledge has to be encoded in a non-canonical formula such as (12) that
cannot be easily turned into an equivalent canonical formula. c.f. “Guide to Axiomatizing Domains
in First-Order Logic” (http://cs.nyu.edu/faculty/davise/guide.html). It is not a surprise that all
circumscriptive action theories mentioned in this paper satisfy the canonicality assumption.

578

Reformulating the Situation Calculus and the Event Calculus

• If f is a fluent term and t is a timepoint term, then HoldsAt(f, t) and ¬HoldsAt(f, t)
are conditions;
• If γ1 and γ2 are conditions, then γ1 ∧ γ2 and γ1 ∨ γ2 are conditions;
• If v is a variable and γ is a condition, then ∃vγ is a condition.
We will use e and ei to denote event terms, f and fi to denote fluent terms, t and ti to
denote timepoint terms, and γ and γi to denote conditions.
In the event calculus, we circumscribe Initiates, Terminates, and Releases to minimize
unexpected effects of events, circumscribe Happens to minimize unexpected events, and
circumscribe Ab i (abnormality predicates) to minimize abnormalities. Formally, an event
calculus description is a circumscriptive theory defined as
CIRC[Σ ; Initiates, Terminates, Releases] ∧ CIRC[∆ ; Happens]
∧ CIRC[Θ ; Ab 1 , . . . , Ab n ] ∧ Ξ,

(16)

where
• Σ is a conjunction of universal closures of axioms of the form
γ → Initiates(e, f, t)
γ → Terminates(e, f, t)
γ → Releases(e, f, t)
γ ∧ π1 (e, f1 , t) → π2 (e, f2 , t)
(“effect constraint”)
γ ∧ [¬]Happens(e1 , t) ∧ · · · ∧ [¬]Happens(en , t) → Initiates(e, f, t)
γ ∧ [¬]Happens(e1 , t) ∧ · · · ∧ [¬]Happens(en , t) → Terminates(e, f, t),
where each of π1 and π2 is either Initiates or Terminates (‘[¬]’ means that ‘¬’ is
optional);
• ∆ is a conjunction of universal closures of temporal ordering formulas (comparisons
between timepoint terms) and axioms of the form
γ → Happens(e, t)
σ(f, t) ∧ π1 (f1 , t) ∧ · · · ∧ πn (fn , t) → Happens(e, t)
(“causal constraints”)
Happens(e, t) → Happens(e1 , t) ∨ · · · ∨ Happens(en , t) (“disjunctive event axiom”),
where σ is Started or Stopped and each πj (1 ≤ j ≤ n) is either Initiated or
Terminated ;
• Θ is a conjunction of universal closures of cancellation axioms of the form
γ → Abi (..., t) ;
• Ξ is a conjunction of first-order sentences (outside the scope of CIRC) including unique
name axioms, state constraints, event occurrence constraints, and the set of domainindependent axioms in the event calculus, such as EC (for the continuous event calculus) and DEC (for the discrete event calculus) (Mueller, 2006, Chapter 2). It also
579

Lee & Palla

includes the following definitions of the predicates used in the causal constraints in ∆:
def

Started (f, t) ↔ (HoldsAt(f, t) ∨ ∃e(Happens(e, t) ∧ Initiates(e, f, t)))

(CC1 )

def

Stopped (f, t) ↔ (¬HoldsAt(f, t) ∨ ∃e(Happens(e, t) ∧ Terminates(e, f, t)))
def

Initiated (f, t) ↔ (Started (f, t) ∧ ¬∃e(Happens(e, t) ∧ Terminates(e, f, t)))
def

Terminated (f, t) ↔ (Stopped (f, t) ∧ ¬∃e(Happens(e, t) ∧ Initiates(e, f, t)))

(CC2 )
(CC3 )
(CC4 ).

Remark 1 The following facts are easy to check:
• Σ is canonical relative to {Initiates, Terminates, Releases};
• ∆ is canonical relative to {Happens};
• Θ is canonical relative to {Ab 1 , . . . , Ab n }.
These facts are used in the next section to reformulate the event calculus in the general
theory of stable models.
3.2 Reformulating the Event Calculus in the General Theory of Stable Models
Following Ferraris, Lee, Lifschitz, and Palla (2009), about a formula F we say that it
is negative on a list p of predicate constants if members of p have no strictly positive
occurrences in F .4 For example, formula (9) is negative on {p}, but is not negative on {p, q}.
A formula of the form ¬F (shorthand for F → ⊥) is negative on any list of predicates.
We assume that Ξ was already equivalently rewritten so that Ξ is negative on {Initiates,
Terminates, Releases, Happens, Ab 1 , . . . , Ab n }. This can be easily done by prepending ¬¬
to strictly positive occurrences of those predicates. The following theorem shows a few
equivalent reformulations of circumscriptive event calculus in the general theory of stable
models.
Theorem 2 For any event calculus description (16), the following theories are equivalent
to each other:5
(a) CIRC[Σ; I, T, R] ∧ CIRC[∆; H] ∧ CIRC[Θ; Ab 1 , . . . , Ab n ] ∧ Ξ ;
(b) SM[Σ; I, T, R] ∧ SM[∆; H] ∧ SM[Θ; Ab 1 , . . . , Ab n ] ∧ Ξ ;
(c) SM[Σ ∧ ∆ ∧ Θ ∧ Ξ; I, T, R, H, Ab 1 , . . . , Ab n ] ;
(d) SM[Σ ∧ ∆ ∧ Θ ∧ Ξ ∧ Choice(pr (Σ ∧ ∆ ∧ Θ ∧ Ξ) \ {I, T, R, H, Ab 1 , . . . , Ab n })] .
The equivalence between (a) and (b) is immediate from Theorem 1. The equivalence
between (b) and (c) can be shown using the splitting theorem by Ferraris et al. (2009).
The assumption that Ξ is negative on the intensional predicates is essential in showing that
4. Note that we distinguish between a formula being negative (on p) and an occurrence being negative
(Section 2.3).
5. For brevity, we abbreviate the names of circumscribed predicates.

580

Reformulating the Situation Calculus and the Event Calculus

equivalence (For more details, see the proof in Appendix C.4.). The equivalence between
(c) and (d) follows from Proposition 1 since
{I, T, R, H, Ab 1 , . . . , Ab n } \ pr (Σ ∧ ∆ ∧ Θ ∧ Ξ)
is the empty set.6

4. Reformulating the Situation Calculus in the General Theory of Stable
Models
In this section, we review and reformulate two versions of the situation calculus—Lin’s
causal action theories (1995) and Reiter’s basic action theories (2001).
4.1 Review: Lin’s Causal Action Theories
We assume a many-sorted first-order language which contains a situation sort, an action
sort, a fluent sort, a truth value sort and an object sort. We understand expression P (x, s),
where P is a fluent name, as shorthand for Holds(P (x), s). We do not consider functional
fluents here for simplicity.
According to Lin (1995), a formula φ(s) is called a simple state formula about s if φ(s)
does not mention Poss, Caused or any situation term other than possibly the variable s.
We assume that a causal action theory D consists of a finite number of the following
sets of axioms. We often identify D with the conjunction of the universal closures of all
axioms in D. In the following, F , Fi are fluent names, A is an action name, V , Vi are truth
values, s, s0 are situation variables, φ(s) is a simple state formula about s, symbols a, a0
are action variables, f is a variable of sort fluent, v is a variable of sort truth value, and x,
xi , y, yi are lists of variables.
• Dcaused is a conjunction of axioms of the form
Poss(A(x), s) → (φ(s) → Caused (F (y), V, do(A(x), s))
(direct effect axioms), and
φ(s) ∧ Caused (F1 (x1 ), V1 , s) ∧ · · · ∧ Caused (Fn (xn ), Vn , s) → Caused (F (x), V, s)
(indirect effect axioms).
• Dposs is a conjunction of precondition axioms of the form
Poss(A(x), s) ↔ φ(s).

(17)

• Drest is a conjunction of the following axioms:
– The basic axioms:
Caused (f, true, s) → Holds(f, s),
Caused (f, false, s) → ¬Holds(f, s),
true 6= false ∧ ∀v(v = true ∨ v = false).
6. I, T , R, H occur in the domain independent axioms as part of Ξ.

581

(18)

Lee & Palla

– The unique name assumptions for fluent names:
Fi (x) 6= Fj (y), (i 6= j)
Fi (x) = Fi (y) → x = y.

(19)

Similarly for action names.
– The foundational axioms for the discrete situation calculus:

7

s 6= do(a, s),
0

0

0

0

do(a, s) = do(a , s ) → (a = a ∧ s = s ),



∀p p(S0 ) ∧ ∀a, s p(s) → p(do(a, s)) → ∀s p(s) .

(20)
(21)
(22)

– The frame axiom:
Poss(a, s) → (¬∃vCaused (f, v, do(a, s))
→ (Holds(f, do(a, s)) ↔ Holds(f, s))).
– Axioms for other domain knowledge: φ(s).
A causal action theory is defined as
CIRC[Dcaused ; Caused ] ∧ Dposs ∧ Drest .

(23)

Remark 2 It is easy to check that Dcaused is canonical relative to Caused .
This fact is used in the next section to reformulate causal action theories in the general
theory of stable models.
4.2 Reformulating Causal Action Theories in the General Theory of Stable
Models
Let Dposs → be the conjunction of axioms φ(s) → Poss(A(x), s) for each axiom (17) in Dposs .
Instead of the second-order axiom (22), we consider the following first-order formula Dsit ,
which introduces a new intensional predicate constant Sit whose argument sort is situation.8
Sit(S0 ) ∧ ∀a, s(Sit(s) → Sit(do(a, s))) ∧ ¬∃s¬Sit(s).

(24)

−
In the following, Drest
is the theory obtained from Drest by dropping (22).

Theorem 3 Given a causal action theory (23), the following theories are equivalent to each
other when we disregard the auxiliary predicate Sit:
(a) CIRC[Dcaused ; Caused ] ∧ Dposs ∧ Drest ;
−
(b) SM[Dcaused ; Caused ] ∧ Dposs ∧ Drest
∧ SM[Dsit ; Sit] ;
−
(c) SM[Dcaused ; Caused ] ∧ SM[Dposs → ; Poss] ∧ Drest
∧ SM[Dsit ; Sit] ;
−
(d) SM[Dcaused ∧ Dposs → ∧ Drest
∧ Dsit ; Caused , Poss, Sit] .

7. For simplicity we omit two other axioms regarding the partial-order among situations.
8. Suggested by Vladimir Lifschitz (personal communication).

582

Reformulating the Situation Calculus and the Event Calculus

4.3 Review: Reiter’s Basic Action Theories
As in causal action theories, we understand P (x, s), where P is a fluent name, as shorthand
for Holds(P (x), s), and do not consider functional fluents.
A basic action theory (BAT) is of the form
Σ ∪ Dss ∪ Dap ∪ Duna ∪ DS0 ,

(25)

where
• Σ is the conjunction of the foundational axioms (Section 4.1);
• Dss is a conjunction of successor state axioms of the form
F (x, do(a, s)) ↔ ΦF (x, a, s),
where ΦF (x, a, s) is a formula that is uniform in s
among x, a, s;

9

and whose free variables are

• Dap is a conjunction of action precondition axioms of the form
Poss(A(x), s) ↔ ΠA (x, s),
where ΠA (x, s) is a formula that is uniform in s and whose free variables are among x, s;
• Duna is the conjunction of unique name axioms for fluents and actions;
• DS0 is a conjunction of first-order formulas that are uniform in S0 .
4.4 Reformulating Basic Action Theories in the General Theory of Stable
Models
Note that a BAT is a theory in first-order logic.10 In view of the fact that any first-order
logic sentence F is equivalent to SM[F ; ∅], it is trivial to view a BAT as a first-order theory
under the stable model semantics with the list of intensional predicates being empty.
In the rest of this section, we consider an alternative encoding of BAT in ASP, in which
we do not need to provide explicit successor state axioms Dss . Instead, the successor state
axioms are entailed by the effect axioms and the generic inertia axioms adopted in ASP by
making intensional both the positive predicate Holds and the negative predicate ∼Holds
(Recall the definitions of positive and negative predicates in Section 2.2). In the following
we assume that the underlying signature contains both these predicates.
An ASP-style BAT is of the form
Σ ∪ Deffect ∪ Dprecond ∪ Dinertia ∪ Dexogenous0 ∪ Duna ∪ DS0 ,
where
• Σ, Duna and DS0 are defined as before;
9. We refer the reader to the book by Reiter (2001) for the definition of a uniform formula.
10. For simplicity we disregard the second-order axiom (22).

583

(26)

Lee & Palla

• Deffect is a conjunction of axioms of the form
+
γR
(x, a, s) → Holds(R(x), do(a, s))

(27)

−
γR
(x, a, s) → ∼Holds(R(x), do(a, s)),

(28)

or
+
γR
(x, a, s)

−
γR
(x, a, s)

where
and
variables are among x, a and s;

are formulas that are uniform in s and whose free

• Dprecond is a conjunction of axioms of the form
πA (x, s) → Poss(A(x), s),

(29)

where πA (x, s) is a formula that is uniform in s and whose free variables are among x, s;
• Dinertia is the conjunction of the axioms
Holds(R(x), s) ∧ ¬ ∼Holds(R(x), do(a, s)) → Holds(R(x), do(a, s)),
∼Holds(R(x), s) ∧ ¬Holds(R(x), do(a, s)) → ∼Holds(R(x), do(a, s))
for all fluent names R;
• Dexogenous0 is the conjunction of
Holds(R(x), S0 )∨ ∼Holds(R(x), S0 )
for all fluent names R.
Note that axioms in Dinertia are typically used in answer set programming to represent
the common sense law of inertia (Lifschitz & Turner, 1999). Similarly, Dexogenous0 is used
to represent that the initial value of a fluent is arbitrary.11
We will show how this ASP-style BAT is related to Reiter’s BAT. First, since we use
strong negation, it is convenient to define the following notions. Given the signature σ of
a BAT, σ Holds is the signature obtained from σ by adding ∼Holds to σ. We say that an
interpretation I of σ Holds is complete on Holds if it satisfies
∀y(Holds(y)∨ ∼Holds(y)),
where y is a list of distinct variables. Given an interpretation I of σ Holds , expression I|σ
denotes the projection of I on σ.
Let Dss be the conjunction of successor state axioms
−
Holds(R(x), do(a, s)) ↔ Γ+
R (x, a, s) ∨ (Holds(R(x), s) ∧ ¬ΓR (x, a, s)),
+
−
where Γ+
R (x, a, s) is the disjunction of γR (x, a, s) for all axioms (27) in Deffect , and ΓR (x, a, s)
−
is the disjunction of γR (x, a, s) for all axioms (28) in Deffect . By Dap we denote the conjunction of axioms Poss(A(x), s) ↔ ΠA (x, s), where ΠA (x, s) is the disjunction of πA (x, s)
for all axioms (29) in Dprecond .

11. The axioms Dinertia and Dexogenous0 are also closely related to the translation of C+ into nonmonotonic
causal logic (Giunchiglia, Lee, Lifschitz, McCain, & Turner, 2004).

584

Reformulating the Situation Calculus and the Event Calculus

Theorem 4 Let T be a theory (26) of signature σ Holds , and I a coherent interpretation of
σ Holds that is complete on Holds. If I satisfies
−
¬∃x a s(Γ+
R (x, a, s) ∧ ΓR (x, a, s))

for every fluent name R, then I satisfies
SM[T ; Poss, Holds, ∼Holds]
iff I|σ satisfies the BAT
Σ ∧ Dss ∧ Dap ∧ Duna ∧ DS0 .

5. Translating Almost Universal Sentences into Logic Programs
Theorems 2—4 present reformulations of the situation calculus and the event calculus in the
general theory of stable models, which may contain nested quantifiers and connectives. On
the other hand, the input languages of ASP solvers are limited to simple rule forms, which
are analogous to clausal normal form in classical logic. Although any first-order formula can
be rewritten in clausal normal form while preserving satisfiability, such transformations do
not necessarily preserve stable models. This is due to the fact that the notion of equivalence
is “stronger” under the stable model semantics (Lifschitz, Pearce, & Valverde, 2001).
Definition 4 (Ferraris et al., 2011) A formula F is strongly equivalent to formula G if,
for any formula H containing F as a subformula (and possibly containing object, function
and predicate constants that do not occur in F , G), and for any list p of distinct predicate
constants, SM[H; p] is equivalent to SM[H 0 ; p], where H 0 is obtained from H by replacing
an occurrence of F by G.
In other words, replacing a subformula with another strongly equivalent subformula
does not change the stable models of the whole formula. While strongly equivalent theories
are classically equivalent (i.e., equivalent under classical logic), the converse does not hold.
Consequently, classically equivalent transformations do not necessarily preserve stable models. For instance, consider p and ¬¬p. When p is intensional, the former has stable models
and the latter does not.
It is known that every propositional formula can be rewritten as a logic program (Cabalar
& Ferraris, 2007; Cabalar, Pearce, & Valverde, 2005; Lee & Palla, 2007), and such translations can be extended to quantifier-free formulas in a straightforward way (Section 5.1).
However, the method does not work in the presence of arbitrary quantifiers, because in the
target formalism (logic programs), all variables are implicitly universally quantified.
In this section, we present a translation that turns a certain class of sentences called
“almost universal” sentences into logic programs while preserving stable models. It turns
out that the reformulations of the situation calculus and the event calculus in Sections 3
and 4 belong to the class of almost universal sentences, so that we can use ASP solvers for
computing them.
585

Lee & Palla

5.1 Translating Quantifier-Free Formulas into Logic Programs
Cabalar et al. (2005) define the following transformation that turns any propositional formula under the stable model semantics into a logic program.
• Left side rules:
>∧F →G

7→

{F → G}

(L1)

⊥∧F →G

7→

∅

(L2)

¬¬F ∧ G → H

7→

(L3)

(F ∨ G) ∧ H → K

7→

(F → G) ∧ H → K

7→

{G → ¬F ∨ H}


F ∧H →K
G∧H →K



 ¬F ∧ H → K
G∧H →K


H → F ∨ ¬G ∨ K

F →⊥∨G

7→

{F → G}

(R1)

F →>∨G

7→

∅

(R2)

F → ¬¬G ∨ H

7→

(R3)

F → (G ∧ H) ∨ K

7→

F → (G → H) ∨ K

7→

{¬G ∧ F → H}


F →G∨K
F →H ∨K


G∧F →H ∨K
¬H ∧ F → ¬G ∨ K

(L4)

(L5)

• Right side rules:

(R4)
(R5)

Before applying this transformation to each formula on the lefthand side, we assume
that the formula is already written in negation normal form, in which negation is applied
to literals only, by using the following transformation:
• Negation normal form conversion:
¬>
¬⊥
¬¬¬F
¬(F ∧ G)
¬(F ∨ G)
¬(F → G)

7→
7
→
7
→
7
→
7
→
7
→

⊥
>
¬F
¬F ∨ ¬G
¬F ∧ ¬G
¬¬F ∧ ¬G

According to Cabalar et al. (2005), successive application of the rewriting rules above
turn any propositional formula into a disjunctive logic program. This result can be simply
extended to turn any quantifier-free formula into a logic program.
As noted by Cabalar et al. (2005), this translation may involve an exponential blowup in
size, and Theorem 1 from their paper shows that indeed there is no vocabulary-preserving
polynomial time algorithm to convert general propositional theories under the stable model
semantics into disjunctive logic programs. Alternatively, one can use another translation
from the same paper, which is linear in size but involves auxiliary atoms and is more
complex.
586

Reformulating the Situation Calculus and the Event Calculus

5.2 Quantifier Elimination
We introduce a quantifier elimination method that distinguishes between two kinds of occurrences of quantifiers: “singular” and “non-singular.” Any “non-singular” occurrence of
a quantifier is easy to eliminate, while a “singular” occurrence is eliminated under a certain
syntactic condition.
Definition 5 We say that an occurrence of QxG in F is singular if
• Q is ∃, and the occurrence of QxG is positive in F , or
• Q is ∀, and the occurrence of QxG is negative in F .
For example, the occurrence of ∃x q(x) is singular in (11), but the occurrence of ∃x p(x) is
not.
Non-singular occurrences of quantifiers can be eliminated in view of the fact that every
first-order sentence can be rewritten in prenex form. The prenex form conversion rules given
in Section 6.3.1 of Pearce and Valverde (2005) preserve strong equivalence, which leads to
the following theorem.12
Theorem 5 (Lee & Palla, 2007, Proposition 5) Every first-order formula is strongly
equivalent to a formula in prenex form.
The prenex form conversion turns a non-singular occurrence of a quantifier into an
outermost ∀ while preserving strong equivalence. Consequently, if a sentence contains no
singular occurrence of a quantifier, then the above results can be used to turn the sentence
into a universal sentence and then into a set of ASP rules. However, in the presence of a
singular occurrence of a quantifier, the prenex form conversion turns the occurrence into
an outermost ∃, which is not allowed in logic programs. Below we consider how to handle
such occurrences.
Obviously, if the Herbrand universe is finite, and if we are interested in Herbrand stable
models (i.e., answer sets) only, quantified formulas can be rewritten as multiple disjunctions
and conjunctions. We do not even need to consider turning the formula into prenex form.
For example, for a formula
r ∧ ¬∃x(p(x) ∧ q(x)) → s

(30)

occurring in a theory whose signature contains {1, . . . , n} as the only object constants (and
no other function constants), if we replace ∃x(p(x) ∧ q(x)) with multiple disjunctions and
then turn the resulting program with nested expressions into a usual disjunctive program
(Lifschitz, Tang, & Turner, 1999), 2n rules are generated. For instance, if n = 3, the
12. Pearce and Valverde (2005) show that a sentence in QNc5 , the monotonic basis of Quantified Equilibrium
Logic, can be turned into prenex form, from which the result follows.

587

Lee & Palla

resulting logic program is
s ← r, not
s ← r, not
s ← r, not
s ← r, not
s ← r, not
s ← r, not
s ← r, not
s ← r, not

p(1), not
p(1), not
p(1), not
p(1), not
q(1), not
q(1), not
q(1), not
q(1), not

p(2), not
p(2), not
q(2), not
q(2), not
p(2), not
p(2), not
q(2), not
q(2), not

p(3)
q(3)
p(3)
q(3)
p(3)
q(3)
p(3)
q(3).

Also, the translation is not modular as it depends on the underlying domain; the multiple
disjunctions or conjunctions need to be updated when the domain changes. More importantly, this method is not applicable if the theory contains function constants of positive
arity, as its Herbrand universe is infinite.
One may also consider introducing Skolem constants as in first-order logic, presuming
that, for any sentence F and its “Skolem form” F 0 , SM[F ; p] is satisfiable iff SM[F 0 ; p] is
satisfiable. However, this idea does not work.13
Example 2 For formula
F = (∀x p(x) → q) ∧ ¬¬∃x(q ∧ ¬p(x)),
SM[F ; q] is equivalent to the first-order sentence
(q ↔ ∀x p(x)) ∧ ∃x(q ∧ ¬p(x)),
which is unsatisfiable (the equivalence can be established using Theorems 3 and 11 from Ferraris et al., 2011). Formula F is strongly equivalent to its prenex form

∃x∃y (p(x) → q) ∧ ¬¬(q ∧ ¬p(y)) ,

(31)

However, if we introduce new object constants a and b to replace the existentially quantified
variables as in
F 0 = (p(a) → q) ∧ ¬¬(q ∧ ¬p(b)),
formula SM[F 0 ; q] is equivalent to
(q ↔ p(a)) ∧ (q ∧ ¬p(b)),
which is satisfiable.
Here we present a method of eliminating singular occurrences of quantifiers by introducing auxiliary predicates. Our idea is a generalization of the practice in logic programming
13. Pearce and Valverde (2005) show that Skolemization works with QNc5 , the monotonic basis of Quantified Equilibrium Logic, but as our example shows, this does not imply that Skolemization works with
Quantified Equilibrium Logic.

588

Reformulating the Situation Calculus and the Event Calculus

that simulates negated existential quantification in the body of a rule by introducing auxiliary predicates. For instance, in order to eliminate ∃ in (30), we will introduce a new
predicate constant p0 , and turn (30) into
(r ∧ ¬p0 → s) ∧ ∀x(p(x) ∧ q(x) → p0 ),

(32)

which corresponds to the logic program
s ← r, not p0
p0 ← p(x), q(x).

(33)

The models of SM[(30); p, q, r, s] are the same as the stable models of (33) if we disregard
p0 . This method does not involve grounding, so that the translation does not depend on
the domain and is not restricted to Herbrand models. The method is formally justified by
the following proposition.
Recall that a formula H is negative on p if members of p have no strictly positive
occurrences in H. Given a formula F , we say that an occurrence of a subformula G is
p-negated in F if it is contained in a subformula H of F that is negative on p.
Proposition 2 Let F be a sentence, let p be a finite list of distinct predicate constants,
and let q be a new predicate constant that does not occur in F . Consider any non-strictly
positive, p-negated occurrence of ∃yG(y, x) in F , where x is the list of all free variables of
∃yG(y, x). Let F 0 be the formula obtained from F by replacing that occurrence of ∃yG(y, x)
with q(x). Then
SM[F ; p] ∧ ∀x(q(x) ↔ ∃yG(y, x))
is equivalent to
SM[F 0 ∧ ∀xy(G(y, x) → q(x)); p, q].
Proposition 2 tells us that SM[F ; p] and SM[F 0 ∧ ∀xy(G(y, x) → q(x); p, q] have the
same models if we disregard the new predicate constant q. Notice that F 0 does not retain
the occurrence of ∃y.
Example 3 In formula (30), ∃x(p(x) ∧ q(x)) is contained in a negative formula (relative
to any set of intensional predicates). In accordance with Proposition 2, SM[(30); p, q, r, s]
has the same models as SM[(32); p, q, r, s, p0 ] if we disregard p0 .
Any singular, p-negated occurrence of a subformula ∀yG(y, x) can also be eliminated
using Proposition 2 by first rewriting ∀yG(y, x) as ¬∃y¬G(y, x). Note that ∀yG(y, x) is
not strongly equivalent to ¬∃y¬G(y, x), and in general such a classically equivalent transformation may not necessarily preserve stable models. However, the Theorem on Double
Negations (Ferraris et al., 2009, also reviewed in Appendix C) tells us that such a transformation is ensured to preserve p-stable models if the replaced occurrence is p-negated in
the given formula.
Now we are ready to present our quantifier elimination method, which applies to the
class of almost universal formulas.
589

Lee & Palla

Definition 6 We say that a formula F is almost universal relative to p if every singular
occurrence of QxG in F is p-negated in F .
For example, formula (30) is almost universal relative to any set of predicates because the
only singular occurrence of ∃x(p(x) ∧ q(x)) in (30) is contained in ¬∃x(p(x) ∧ q(x)), which
is negative on any list of predicates. Formula F in Example 2 is almost universal relative
to {q} because the singular occurrence of ∀x p(x) is contained in the formula itself, which is
negative on {q}, and the singular occurrence of ∃x(q ∧¬p(x)) is contained in ¬∃x(q ∧¬p(x)),
which is also negative on {q}.
The following procedure can be used to eliminate all (possibly nested) quantifiers in any
almost universal sentence.
Definition 7 (Translation elim-quantifiers) Given a formula F , first prepend ¬¬ to
every maximal strictly positive occurrence of a formula of the form ∃yH(y, x),14 and then
repeat the following process until there are no occurrences of quantifiers remaining: Select
a maximal occurrence of a formula of the form QyG(y, x) in F , where Q is ∀ or ∃, and x
is the list of all free variables in QyG(y, x).
(a) If the occurrence of QyG(y, x) in F is non-singular in F , then set F to be the formula
obtained from F by replacing the occurrence of QyG(y, x) with G(z, x), where z is a
new variable.
(b) Otherwise, if Q is ∃ and the occurrence of QyG(y, x) in F is positive, then set F to
be
F 0 ∧ (G(y, x) → pG (x)),
where pG is a new predicate constant and F 0 is the formula obtained from F by replacing the occurrence of QyG(y, x) with pG (x).
(c) Otherwise, if Q is ∀ and the occurrence of QyG(y, x) in F is negative, then set F
to be the formula obtained from F by replacing the occurrence of QyG(y, x) with
¬∃y¬G(y, x).
We assume that the new predicate constants introduced by the translation do not belong
to the signature of the input formula F . It is clear that this process terminates, and yields
a formula that is quantifier-free. Since the number of times step (b) is applied is no more
than the number of quantifiers in the input formula, and the new formulas added have the
size polynomial to the input formula, it follows that the size of the resulting quantifier-free
formula is polynomial in the size of the input formula.
The following theorem tells us that any almost universal sentence F can be turned into
the form ∀xG, where G is a quantifier-free formula. For any (second-order) sentences F
and G of some signature and any subset σ of that signature, we say that F is σ-equivalent
to G, denoted by F ⇔σ G, if the class of models of F restricted to σ is identical to the class
of models of G restricted to σ.
14. The maximality is understood here in terms of subformula relation. That is, we select a strictly positive
occurrence of a subformula of F of the form ∃yH(y, x) that is not contained in any other subformula of
F of the same form.

590

Reformulating the Situation Calculus and the Event Calculus

Theorem 6 Let F be a sentence of a signature σ, let F 0 be the universal closure of the
formula obtained from F by applying translation elim-quantifiers, and let q be the list
of new predicate constants introduced by the translation. If F is almost universal relative
to p, then SM[F ; p] is σ-equivalent to SM[F 0 ; p, q].
The statement of the theorem becomes incorrect if we do not require F to be almost
universal relative to p. For instance, if elim-quantifiers is applied to ∃x p(x), it results
in ¬¬q ∧ (p(x) → q). However, SM[∃x p(x); p] is not {p}-equivalent to
SM[∀x(¬¬q ∧ (p(x) → q)); p, q]. The former is equivalent to saying that p is a singleton.
The latter is equivalent to q ∧ ∀x¬p(x) ∧ (q ↔ ∃xp(x)), which is inconsistent.
5.3 f2lp: Computing Answer Sets of First-Order Formulas
Using translation elim-quantifiers defined in the previous section, we introduce translation f2lp that turns an almost universal formula into a logic program. We assume that the
underlying signature contains finitely many predicate constants.
Definition 8 (Translation f2lp)
1. Given a formula F and a list of intensional predicates p, apply translation elim-quantifiers (Definition 7) to F ;
2. Add choice formulas (q(x) ∨ ¬q(x)) for all non-intensional predicates q.
3. Turn the resulting quantifier-free formula into a logic program by applying the translation from Section 3 of the paper by Cabalar et al. (2005), which was also reviewed
in Section 5.1.
As explained in Section 5.1, due to the third step, this transformation may involve an
exponential blowup in size. One can obtain a polynomial translation by replacing Step 3
with an alternative translation given in Section 4 of the paper by Cabalar et al.
The following theorem asserts the correctness of the translation.
Theorem 7 Let F be a sentence of a signature σ, let p be a list of intensional predicates,
and let F 0 be the FOL representation of the program obtained from F by applying translation
f2lp with p as intensional predicates. If F is almost universal relative to p, then SM[F ; p]
is σ-equivalent to
SM[F 0 ∧ False(p \ pr (F 0 ))].
Example 4 Consider one of the domain independent axioms in the discrete event calculus
(DEC5 axiom):
HoldsAt(f, t) ∧ ¬ReleasedAt(f, t+1)∧
¬∃e(Happens(e, t) ∧ Terminates(e, f, t)) → HoldsAt(f, t+1).
Step 1 of translation f2lp introduces the formula
Happens(e, t) ∧ Terminates(e, f, t) → q(f, t),
and replaces (34) with
HoldsAt(f, t) ∧ ¬ReleasedAt(f, t+1) ∧ ¬q(f, t) → HoldsAt(f, t+1).
591

(34)

Lee & Palla

Step 3 turns these formulas into rules
q(f, t) ← Happens(e, t), Terminates(e, f, t)
HoldsAt(f, t+1) ← HoldsAt(f, t), not ReleasedAt(f, t+1), not q(f, t).
Turning the program obtained by applying translation f2lp into the input languages of
lparse 15 and gringo 16 requires minor rewriting, such as moving equality and negated
atoms in the head to the body 17 and adding domain predicates in the body for all variables
occurring in the rule in order to reduce the many-sorted signature into the non-sorted one.18
System f2lp is an implementation of translation f2lp, which turns a first-order formula
into the languages of lparse and gringo. The system can be downloaded from its home
page
http://reasoning.eas.asu.edu/f2lp .
First-order formulas can be encoded in f2lp using the extended rule form F ← G, where
F and G are first-order formulas that do not contain →. The ASCII representation of the
quantifiers and connectives are shown in the following table.
Symbol
ASCII

¬
not

∼
-

∧
&

∨
|

←
<-

⊥
false

>
true

∀xyz
![X,Y,Z]:

∃xyz
?[X,Y,Z]:

For example, formula (34) can be encoded in the input language of f2lp as
holdsAt(F,T+1) <- holdsAt(F,T) & not releasedAt(F,T+1) &
not ?[E]:(happens(E,T) & terminates(E,F,T)).

The usual lparse and gringo rules (which have the rule arrow ‘:-’) are also allowed
in f2lp. Such rules are simply copied to the output. The program returned by f2lp can
be passed to ASP grounders and solvers that accept lparse and gringo languages.

6. Computing the Event Calculus Using ASP Solvers
Using translation f2lp, we further turn the event calculus reformulation in Section 3.2 into
answer set programs. The following procedure describes the process.
Definition 9 (Translation ec2asp)
1. Given an event calculus description (16), rewrite
all the definitional axioms of the form
def

∀x(p(x) ↔ G)

(35)

in Ξ as ∀x(G¬¬ → p(x)), where G¬¬ is obtained from G by prepending ¬¬ to
all occurrences of intensional predicates Initiates, Terminates, Releases, Happens,
Ab 1 , . . . , Ab n . Also prepend ¬¬ to the strictly positive occurrences of the intensional
predicates in the remaining axioms of Ξ. Let Ξ0 be the resulting formula obtained
from Ξ.
15.
16.
17.
18.

http://www.tcs.hut.fi/Software/smodels
http://potassco.sourceforge.net
For instance, (X=Y) | -q(X,Y) :- p(X,Y) is turned into :- X!=Y, {not q(X,Y)}0, p(X,Y).
Alternatively this can be done by declaring variables using the #domain directive in lparse and gringo
languages.

592

Reformulating the Situation Calculus and the Event Calculus

2. Apply translation f2lp on Σ ∧ ∆ ∧ Θ ∧ Ξ0 with the intensional predicates
{Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n } ∪ p,
where p is the set of all predicate constants p in (35) as considered in Step 1.
The following theorem states the correctness of the translation.
Theorem 8 Let T be an event calculus description (16) of signature σ that contains finitely
many predicate constants, let F be the FOL representation of the program obtained from T
by applying translation ec2asp. Then T is σ-equivalent to SM[F ].
In view of the theorem, system f2lp can be used to compute event calculus descriptions
by a simple rewriting as stated in translation ec2asp.19 The system can be used in place
of the dec reasoner in many existing applications of the event calculus, such as in robotics,
security, video games, and web service composition, as listed in
http://decreasoner.sourceforge.net/csr/decapps.html .
The computational mechanism of the dec reasoner is similar to our method as it is
based on the reduction of event calculus reasoning to propositional satisfiability and uses
efficient SAT solvers for computation. However, our method has some advantages.
First, it is significantly faster due to the efficient grounding mechanisms implemented
in ASP systems. This is evidenced in some experiments reported in Appendix B.
Second, f2lp allows us to compute the full version of the event calculus, assuming that
the domain is given and finite. On the other hand, the reduction implemented in the dec
reasoner is based on completion, which is weaker than circumscription. This makes the
system unable to handle recursive axioms and disjunctive axioms, such as effect constraints
and disjunctive event axioms (Section 3.1). For example, the dec reasoner does not allow
the following effect constraints which describe the indirect effects of an agent’s walking on
the objects that he is holding:
HoldsAt(Holding(a, o), t) ∧ Initiates(e, InRoom(a, r), t)
→ Initiates(e, InRoom(o, r), t)
HoldsAt(Holding(a, o), t) ∧ Terminates(e, InRoom(a, r), t)
→ Terminates(e, InRoom(o, r), t).

(36)

Third, we can enhance the event calculus reasoning by combining ASP rules with the
event calculus description. In other words, the event calculus can be viewed as a high
level action formalism on top of ASP. We illustrate this using the example from the work
of Doğandağ, Ferraris, and Lifschitz (2004). There are 9 rooms and 12 doors as shown in
Figure 1. Initially the robot “Robby” is in the middle room and all the doors are closed.
The goal of the robot is to make all rooms accessible from each other. Figure 2 (File robby)
shows an encoding of the problem in the language of f2lp. Atom door(x, y) denotes that
there is a door between rooms x and y; open(x, y) denotes the event “Robby opening the door
19. Kim, Lee, and Palla (2009) presented a prototype of f2lp called ecasp that is tailored to the event
calculus computation.

593

Lee & Palla

Figure 1: Robby’s apartment in a 3 × 3 grid
between rooms x and y”; goto(x) denotes the event “Robby going to room x”; opened(x, y)
denotes that the door between x and y has been opened; inRoom(x) denotes that Robby
is in room x; accessible(x, y) denotes that y is accessible from x. Note that the rules
defining the relation accessible are not part of event calculus axioms (Section 3.1). This
example illustrates an advantage of allowing ASP rules in event calculus descriptions.
The minimal number of steps to solve the given problem is 11. We can find such a
plan using the combination of f2lp, gringo (grounder) and claspD (solver for disjunctive
programs) in the following way. 20
$ f2lp dec robby | gringo -c maxstep=11 | claspD
File dec is an f2lp encoding of the domain independent axioms in the Discrete Event
Calculus (The file is listed in Appendix A).21 The following is one of the plans found:
happens(open(5,8),0) happens(open(5,2),1) happens(open(5,4),2)
happens(goto(4),3) happens(open(4,1),4) happens(open(4,7),5)
happens(goto(5),6) happens(open(5,6),7) happens(goto(6),8)
happens(open(6,9),9) happens(open(6,3),10)

7. Computing the Situation Calculus Using ASP Solvers
Using translation f2lp, we further turn the situation calculus reformulations in Sections 4.2
and 4.4 into answer set programs.
7.1 Representing Causal Action Theories by Answer Set Programs
The following theorem shows how to turn causal action theories into answer set programs.
Theorem 9 Let D be a finite causal action theory (23) of signature σ that contains finitely
many predicate constants, and let F be the FOL representation of the program obtained by
applying translation f2lp on
−
Dcaused ∧ Dposs → ∧ Drest
∧ Dsit

(37)

with the intensional predicates {Caused , Poss, Sit}. Then D is σ-equivalent to SM[F ].
20. One can use clingo instead of gringo and claspD if the output of f2lp is a nondisjunctive program.
21. The file is also available at http://reasoning.eas.asu.edu/f2lp, along with f2lp encodings of the
domain independent axioms in other versions of the event calculus.

594

Reformulating the Situation Calculus and the Event Calculus

% File ’robby’
% objects
step(0..maxstep).
astep(0..maxstep-1) :- maxstep > 0.
room(1..9).
% variables
#domain step(T).
#domain room(R).
#domain room(R1).
#domain room(R2).
% position of the
door(R1,R2) <- R1
door(R1,R2) <- R1
door(R1,R2) <- R1
door(R1,R2) <- R2

doors
>= 1 &
>= 4 &
>= 7 &
< 10 &

R2
R2
R2
R2

>=1 & R1 < 4 & R2 < 4 & R2 = R1+1.
>= 4 & R1 < 7 & R2 < 7 & R2 = R1+1.
>= 7 & R1 < 10 & R2 < 10 & R2 = R1+1.
= R1+3.

door(R1,R2) <- door(R2,R1).
% fluents
fluent(opened(R,R1)) <- door(R1,R2).
fluent(inRoom(R)).
% F ranges over the fluents
#domain fluent(F).
% events
event(open(R,R1)) <- door(R,R1).
event(goto(R)).
% E and E1 range over the events
#domain event(E).
#domain event(E1).
% effect axioms
initiates(open(R,R1),opened(R,R1),T).
initiates(open(R,R1),opened(R1,R),T).
initiates(goto(R2),inRoom(R2),T)
<- holdsAt(opened(R1,R2),T) & holdsAt(inRoom(R1),T).
terminates(E,inRoom(R1),T)
<- holdsAt(inRoom(R1),T) & initiates(E,inRoom(R2),T).
% action precondition axioms
holdsAt(inRoom(R1),T) <- happens(open(R1,R2),T).

595

Lee & Palla

% event occurrence constraint
not happens(E1,T) <- happens(E,T) & E != E1.
% state constraint
not holdsAt(inRoom(R2),T) <- holdsAt(inRoom(R1),T) & R1 != R2.
% accessibility
accessible(R,R1,T) <- holdsAt(opened(R,R1),T).
accessible(R,R2,T) <- accessible(R,R1,T) & accessible(R1,R2,T).
% initial state
not holdsAt(opened(R1,R2),0).
holdsAt(inRoom(5),0).
% goal state
not not accessible(R,R1,maxstep).
% happens is exempt from minimization in order to find a plan.
{happens(E,T)} <- T < maxstep.
% all fluents are inertial
not releasedAt(F,0).

Figure 2: Robby in f2lp

Similar to the computation of the event calculus in Section 6, the Herbrand stable
models of (37) can be computed using f2lp and answer set solvers. The input to f2lp can
be simplified as we limit attention to Herbrand models. We can drop axioms (18)–(21) as
they are ensured by Herbrand models. Also, in order to ensure finite grounding, instead of
Dsit , we include the following set of rules Πsituation in the input to f2lp.
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & action(A) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).

Πsituation is used to generate finitely many situation terms whose depth is up to maxdepth,
the value that can be given as an option in invoking gringo. Using the splitting theorem
(Section C.1), it is not difficult to check that if a program Π containing these rules has
no occurrence of predicate nesting in any other rules and has no occurrence of predicate situation in the head of any other rules, then every answer set of Π contains
atoms situation(do(am , do(am−1 , do(. . . , do(a1 , s0))))) for all possible sequences of actions
a1 , . . . , am for m = 0, . . . , maxdepth. Though this program does not satisfy syntactic conditions, such as λ-restricted (Gebser, Schaub, & Thiele, 2007), ω-restricted (Syrjänen, 2004),
or finite domain programs (Calimeri, Cozza, Ianni, & Leone, 2008), that answer set solvers
usually impose in order to ensure finite grounding, the rules can still be finitely grounded
596

Reformulating the Situation Calculus and the Event Calculus

% File: suitcase
value(t).
value(f).

lock(l1).

lock(l2).

#domain value(V).
#domain lock(X).
fluent(up(X)).
fluent(open).
#domain fluent(F).
action(flip(X)).
#domain action(A).
depth(0..maxdepth).
#domain depth(L).
% defining the situation domain
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).
% basic axioms
h(F,S) <- situation(S) & caused(F,t,S).
not h(F,S) <- situation(S) & caused(F,f,S).
% D_caused
caused(up(X),f,do(flip(X),S)) <situation(S) & not final(S) & poss(flip(X),S) & h(up(X),S).
caused(up(X),t,do(flip(X),S)) <situation(S) & not final(S) & poss(flip(X),S) & not h(up(X),S).
caused(open,t,S) <- situation(S) & h(up(l1),S) & h(up(l2),S).
% D_poss
poss(flip(X),S) <- situation(S).
% frame axioms
h(F,do(A,S)) <h(F,S) & situation(S) & not final(S) & poss(A,S)
& not ?[V]:caused(F,V,do(A,S)).
not h(F,do(A,S)) <not h(F,S) & situation(S) & not final(S) & poss(A,S)
& not ?[V]:caused(F,V,do(A,S)).
% h is non-intensional.
{h(F,S)} <- situation(S).

Figure 3: Lin’s Suitcase in the language of f2lp
597

Lee & Palla

by gringo Version 3.x, which does not check such syntactic conditions.22 It is not difficult
to see why the program above leads to finite grounding since we provide an explicit upper
limit for the nesting depth of function do.
In addition to Πsituation , we use the following program Πexecutable in order to represent
the set of executable situations (Reiter, 2001):
executable(s0).
executable(do(A,S)) <- executable(S) & poss(A,S) & not final(S)
& situation(S) & action(A).

Figure 3 shows an encoding of Lin’s suitcase example (1995) in the language of f2lp
(h is used to represent Holds), which describes a suitcase that has two locks and a spring
loaded mechanism which will open the suitcase when both locks are up. This example
illustrates how the ramification problem is handled in causal action theories. Since we fix
the domain of situations to be finite, we require that actions not be effective in the final
situations. This is done by introducing atom final(S).
Consider the simple temporal projection problem by Lin (1995). Initially the first lock
is down and the second lock is up. What will happen if the first lock is flipped? Intuitively,
we expect both locks to be up and the suitcase to be open. We can automate the reasoning
by using the combination of f2lp, gringo and claspD. First, we add Πexecutable and the
following rules to the theory in Figure 3. In order to check if the theory entails that flipping
the first lock is executable, and that the suitcase is open after the action, we encode the
negation of these facts in the last rule.
% initial situation
<- h(up(l1),s0).
h(up(l2),s0).
% query
<- executable(do(flip(l1),s0)) & h(open,do(flip(l1),s0)).

We check the answer to the temporal projection problem by running the command:
$ f2lp suitcase | gringo -c maxdepth=1 | claspD

claspD returns no answer set as expected.
Now, consider a simple planning problem for opening the suitcase when both locks are
initially down. We add Πexecutable and the following rules to the theory in Figure 3. The
last rule encodes the goal.
% initial situation
<- h(up(l1),s0).
<- h(up(l2),s0).
<- h(open,s0).
% goal
<- not ?[S]: (executable(S) & h(open,S)).

When maxdepth is 1, the combined use of f2lp, gringo and claspD results in no
answer sets, and when maxdepth is 2, it finds the unique answer set that contains both
22. Similarly, system dlv-complex allows us to turn off the finite domain checking (option -nofdcheck).
That system was used in a conference paper (Lee & Palla, 2010) that this article is based on.

598

Reformulating the Situation Calculus and the Event Calculus

h(open, do(flip(l2), do(flip(l1), s0))) and h(open, do(flip(l1), do(flip(l2), s0))), each
of which encodes a plan. In other words, the single answer set encodes multiple plans
in different branches of the situation tree, which allows us to combine information about
the different branches in one model. This is an instance of hypothetical reasoning that is
elegantly handled in the situation calculus due to its branching time structure. Belleghem,
Denecker, and Schreye (1997) note that the linear time structure of the event calculus is
limited to handle such hypothetical reasoning allowed in the situation calculus.
7.2 Representing Basic Action Theories by Answer Set Programs
Since a BAT T (not including the second-order axiom (22)) can be viewed as a first-order
theory under the stable model semantics with the list of intensional predicates being empty,
it follows that f2lp can be used to turn T into a logic program. As before, we focus on
ASP-style BAT.
Theorem 10 Let T be a ASP-style BAT (26) of signature σ that contains finitely many
predicate constants, and let F be the FOL representation of the program obtained by applying translation f2lp on T with intensional predicates {Holds, ∼ Holds, Poss}. Then
SM[T ; Holds, ∼Holds, Poss] is σ-equivalent to SM[F ; σ(F ) ∪ {Poss}].
Figure 4 shows an encoding of the “broken object” example discussed by Reiter (1991).
Consider the simple projection problem of determining if an object o, which is next to
bomb b, is broken after the bomb explodes. We add Πexecutable and the following rules to
the theory in Figure 4.
% initial situation
not h(broken(o),s0) & h(fragile(o),s0) & h(nexto(b,o),s0).
not h(holding(p,o),s0) & not h(exploded(b),s0).
% query
<- executable(do(explode(b),s0)) & h(broken(o),do(explode(b),s0)).

The command
$ f2lp broken | gringo -c maxdepth=1 | claspD

returns no answer set as expected.

8. Related Work
Identifying a syntactic class of theories on which different semantics coincide is important
in understanding the relationship between them. It is known that, for tight logic programs
and tight first-order formulas, the stable model semantics coincides with the completion
semantics (Fages, 1994; Erdem & Lifschitz, 2003; Ferraris et al., 2011). This fact helps us
understand the relationship between the two semantics, and led to the design of the answer
set solver cmodels-1 23 that computes answer sets using completion. Likewise the class
of canonical formulas introduced here helps us understand the relationship between the
stable model semantics and circumscription. The class of canonical formulas is the largest
23. http://www.cs.utexas.edu/users/tag/cmodels

599

Lee & Palla

% File: broken
% domains other than situations
person(p).
object(o).
bomb(b).
#domain person(R).
#domain object(Y).
#domain bomb(B).
fluent(holding(R,Y)).
fluent(broken(Y)).

fluent(nexto(B,Y)).
fluent(exploded(B)).

fluent(fragile(Y)).

action(drop(R,Y)).

action(explode(B)).

action(repair(R,Y)).

#domain fluent(F).
#domain action(A).
depth(0..maxdepth).
#domain depth(L).
% defining the situation domain
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).
% Effect Axioms
h(broken(Y),do(drop(R,Y),S)) <- situation(S) & h(fragile(Y),S) & not final(S).
h(broken(Y),do(explode(B),S)) <- situation(S) & h(nexto(B,Y),S) & not final(S).
h(exploded(B),do(explode(B),S)) <- situation(S) & not final(S).
-h(broken(Y),do(repair(R,Y),S)) <- situation(S) & not final(S).
-h(holding(R,Y),do(drop(R,Y),S)) <- situation(S) & not final(S).
% Action precondition axioms
poss(drop(R,Y),S) <- h(holding(R,Y),S) & situation(S).
poss(explode(B),S) <- situation(S) & not h(exploded(B),S).
poss(repair(R,Y),S) <- situation(S) & h(broken(Y),S).
% inertial axioms
h(F,do(A,S)) <- h(F,S) & not -h(F,do(A,S)) & situation(S) & not final(S).
-h(F,do(A,S)) <- -h(F,S) & not h(F,do(A,S)) & situation(S) & not final(S).
% D_exogeneous_0
h(F,s0) | -h(F,s0).
% Consider only those interpretations that are complete on Holds
<- not h(F,S) & not -h(F,S) & situation(S).

Figure 4: Broken object example in the language of f2lp

600

Reformulating the Situation Calculus and the Event Calculus

syntactic class of first-order formulas identified so far on which the stable models coincide
with the models of circumscription. In other words, minimal model reasoning and stable
model reasoning are indistinguishable on canonical formulas.
Proposition 8 from the work of Lee and Lin (2006) shows an embedding of propositional circumscription in logic programs under the stable model semantics. Our theorem
on canonical formulas is a generalization of this result to the first-order case. Janhunen
and Oikarinen (2004) showed another embedding of propositional circumscription in logic
programs, and implemented the system circ2dlp,24 but their translation appears quite
different from the one by Lee and Lin.
Zhang, Zhang, Ying, and Zhou (2011) show an embedding of first-order circumscription
in first-order stable model semantics. Theorem 3 from that paper is reproduced as follows.25
Theorem 11 (Zhang et al., 2011, Thm. 3) Let F be a formula in negation normal form
and let p be a finite list of predicate constants. Let F ¬¬ be the formula obtained from F
by replacing every p(t) by ¬¬p(t), and let F c be the formula obtained from F by replacing
every ¬p(t) by p(t) → Choice(p), where p is in p and t is a list of terms. Then CIRC[F ; p]
is equivalent to SM[F ¬¬ ∧ F c ; p].
In comparison with Theorem 1, this theorem can be applied to characterize circumscription of arbitrary formulas in terms of stable models by first rewriting the formulas into
negation normal form. While Theorem 1 is applicable to canonical formulas only, it does
not require any transformation, and the characterization is bidirectional in the sense that
it can be also viewed as a characterization of stable models in terms of circumscription.
Zhang et al. (2011) also introduce a translation that turns arbitrary first-order formulas
into logic programs, but this work is limited to finite structures only. On the other hand,
our translation f2lp (Definition 8) works for almost universal formulas only, but is not
limited to finite structures.
The situation calculus and the event calculus are widely studied action formalisms,
and there are several papers that compare and relate them (e.g., Belleghem, Denecker, &
Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997).
Prolog provides a natural implementation for basic action theories since definitional
axioms can be represented by Prolog rules according to the Clark’s theorem (Reiter, 2001,
Chapter 5). The Lloyd-Topor transformation that is used to turn formulas into Prolog rules
is similar to translation f2lp, but the difference is that the former preserves the completion
semantics and the latter preserves the stable model semantics.
Lin and Wang (1999) describe a language that can be used to represent a syntactically
restricted form of Lin’s causal situation calculus, called “clausal causal theories,” which does
not allow quantifiers. They show how to translate that language into answer set programs
with strong negation, the answer sets of which are then used to obtain fully instantiated
successor state axioms and action precondition axioms. This is quite different from our
approach, which computes the propositional models of the full situation calculus theories
directly.
Kautz and Selman (1992) introduce linear encodings that are similar to a propositionalized version of the situation calculus (McCarthy & Hayes, 1969). Lin (2003) introduces
24. http://www.tcs.hut.fi/Software/circ2dlp
25. This is a bit simpler than the original statement because some redundancy is dropped.

601

Lee & Palla

an action description language and describes a procedure to compile an action domain in
that language into a complete set of successor state axioms, from which a STRIPS-like
description can be extracted. The soundness of the procedure is shown with respect to a
translation from action domain descriptions into Lin’s causal action theories. However, that
procedure is based on completion and as such cannot handle recursive axioms unlike our
approach.
Denecker and Ternovska (2007) present an inductive variant of the situation calculus
represented in ID-logic (Denecker & Ternovska, 2008)—classical logic extended with inductive definitions. ID-logic and the first-order stable model semantics appear to be closely
related, but the precise relationship between them has yet to be shown.

9. Conclusion
The first-order stable model semantics is defined similar to circumscription. This paper
takes advantage of that definition to identify a class of formulas on which minimal model
reasoning and stable model reasoning coincide, and uses this idea to reformulate the situation calculus and the event calculus in the first-order stable model semantics. Together
with the translation that turns an almost universal sentence into a logic program, we show
that reasoning in the situation calculus and the event calculus can be reduced to computing
answer sets. We implemented system f2lp, a front-end to ASP solvers that allows us to
compute these circumscriptive action theories. The mathematical tool sets and the system presented in this paper may also be useful in relating other circumscriptive theories
to logic programs. Also, the advances in ASP solvers may improve the computation of
circumscriptive theories.

Acknowledgments
We are grateful to Yuliya Lierler, Vladimir Lifschitz, Erik Mueller, Heng Zhang, Yan Zhang,
and the anonymous referees for their useful comments and discussions. The authors were
partially supported by the National Science Foundation under Grant IIS-0916116.

Appendix A. File ‘dec’ in the Language of f2lp
File ’dec’ encodes the domain independent axioms in the discrete event calculus. This file
is to be used together with event calculus domain descriptions as shown in Section 6.
% File ‘dec’
#domain
#domain
#domain
#domain
#domain
#domain
#domain

fluent(F).
fluent(F1).
fluent(F2).
event(E).
time(T).
time(T1).
time(T2).

time(0..maxstep).
602

Reformulating the Situation Calculus and the Event Calculus

% DEC 1
stoppedIn(T1,F,T2) <- happens(E,T) & T1<T & T<T2 & terminates(E,F,T).
% DEC 2
startedIn(T1,F,T2) <- happens(E,T) & T1<T & T<T2 & initiates(E,F,T).
% DEC 3
holdsAt(F2,T1+T2) <- happens(E,T1) & initiates(E,F1,T1) & T2>0 &
trajectory(F1,T1,F2,T2) & not stoppedIn(T1,F1,T1+T2) & T1+T2<=maxstep.
% DEC 4
holdsAt(F2,T1+T2) <- happens(E,T1) & terminates(E,F1,T1) & 0<T2 &
antiTrajectory(F1,T1,F2,T2) & not startedIn(T1,F1,T1+T2) &
T1+T2<=maxstep.
% DEC 5
holdsAt(F,T+1) <- holdsAt(F,T) & not releasedAt(F,T+1) &
not ?[E]:(happens(E,T) & terminates(E,F,T)) & T<maxstep.
% DEC 6
not holdsAt(F,T+1) <- not holdsAt(F,T) & not releasedAt(F,T+1) &
not ?[E]:(happens(E,T) & initiates(E,F,T)) & T<maxstep.
% DEC 7
releasedAt(F,T+1) <releasedAt(F,T) & not ?[E]:(happens(E,T) &
(initiates(E,F,T) | terminates(E,F,T))) & T<maxstep.
% DEC 8
not releasedAt(F,T+1) <- not releasedAt(F,T) &
not ?[E]: (happens(E,T) & releases(E,F,T)) & T<maxstep.
% DEC 9
holdsAt(F,T+1) <- happens(E,T) & initiates(E,F,T) & T<maxstep.
% DEC 10
not holdsAt(F,T+1) <- happens(E,T) & terminates(E,F,T) & T<maxstep.
% DEC 11
releasedAt(F,T+1) <- happens(E,T) & releases(E,F,T) & T<maxstep.
% DEC 12
not releasedAt(F,T+1) <- happens(E,T) &
(initiates(E,F,T) | terminates(E,F,T)) & T<maxstep.
{holdsAt(F,T)}.
{releasedAt(F,T)}.

603

Lee & Palla

Problem
(max. step)

dec
reasoner

dec
reasoner (minisat)

f2lp with
lparse + cmodels

f2lp with
gringo + cmodels

f2lp with
gringo + clasp(D)

f2lp with
clingo

BusRide
(15)

—

—

—

—

—

0.2s
(0.07s + 0.13s)
A:13174/R:24687

0.14s

Kitchen
Sink (25)

39.0s
(38.9s + 0.1s)
A:1014/C:12109

38.9s
(38.9s + 0.00s)
A:1014/C:12109

0.24s
(0.18s + 0.06s)
A:11970/R:61932

0.20s

Thielscher
Circuit (40)

6.5s
(6.3s + 0.2s)
A:1394/C:42454

6.3s
(6.3s + 0.0s)
A:1394/C:42454

0.12s
(0.09s + 0.03s)
A:4899/R:35545

0.1s

Walking
Turkey (15)

—

—

0.00s
(0.00s + 0.00s)
A:316/R:456

0.00s

Falling w/
AntiTraj (15)

141.8s
(141.4s + 0.4s)
A:416/C:3056

141.7s
(141.7s + 0.00s)
A:416/C:3056

0.03s
(0.03s + 0.00s)
A:3702/R:7414

0.03s

Falling w/
Events (25)

59.5s
(59.5s + 0.0s)
A:1092/C:12351

59.4s
(59.4s + 0.0s)
A:1092/C:12351

0.28s
(0.20s + 0.08s)
A:13829/R:71266

0.22s

HotAir
Baloon (15)

32.2s
(32.2s + 0.0s)
A:288/C:1163

32.3s
(32.3s + 0.0s)
A:288/C:1163

0.0s
(0.0s + 0.0s)
A:1063/R:1835

0.01s

Telephone1
(40)

9.3s
(9.2s + 0.1s)
A:5419/C:41590

9.1s
(9.1s + 0.0s)
A:5419/C:41590

0.00s
(0.00s + 0.00s)
A:355/R:555
C:0
0.15s
(0.07s + 0.08s)
A:5269/R:24687
C:5308
0.44s
(0.19s + 0.25s)
A:11970/R:61932
C:0
0.19s
(0.09s + 0.1s)
A:4899/R:35545
C:0
0.00s
(0.00s + 0.00s)
A:316/R:456
C:0
0.04s
(0.02s + 0.02s)
A:3702/R:7414
C:0
0.46s
(0.20s + 0.26s)
A:1219/R:71266
C:1415
0.0s
(0.0s + 0.0s)
A:492/R:1835
C:681
0.11s
(0.08s + 0.03s)
A:9455/R:13140
C:0

0.01s
(0.00s + 0.01s)
A:448/R:647

Commuter
(15)

0.04s
(0.03s + 0.01s)
A:902/R:7779
C:0
77.29s
(45.74s + 31.55s)
A:32861/R:8734019
C:0
6.19s
(2.99s + 3.20s)
A:121621/R:480187
C:0
0.42s
(0.27s + 0.15s)
A:9292/R:53719
C:0
0.00s
(0.00s + 0.00s)
A:370/R:518
C:0
0.08s
(0.05s + 0.03s)
A:4994/R:9717
C:0
4.95s
(2.57s + 2.38s)
A:1240/R:388282
C:1436
0.01s
(0.01s + 0.00s)
A:494/R:2451
C:689
0.22s
(0.13s + 0.09s)
A:21414/R:27277
C:0

0.07s
(0.06s + 0.01s)
A:9455/R:13140

0.07s

A: number of atoms, C: number of clauses, R: number of ground rules
Figure 5: Comparing the dec reasoner and f2lp with answer set solvers

Appendix B. Comparing the dec Reasoner with ASP-based Event
Calculus Reasoner
We compared the performance of the dec reasoner (v 1.0) running relsat (v 2.2) and
minisat (v 2.2) with the following:
• f2lp (v 1.11) with lparse (v 1.0.17)+cmodels (v 3.79) running minisat (v 2.0
beta),
• f2lp (v 1.11) with gringo (v 3.0.3)+cmodels (v 3.79) running minisat (v 2.0 beta),
• f2lp (v 1.11) with gringo (v 3.0.3) +clasp (v 2.0.2) (claspD (v 1.1.2) used instead
for disjunctive programs), and
• f2lp (v 1.11) with clingo (v 3.0.3 (clasp v 1.3.5)).
f2lp turns an input theory into the languages of lparse and gringo, and lparse and
gringo turn the result into a ground ASP program. cmodels turns this ground program
into a set of clauses and then invokes a SAT solver to compute answer sets, while clasp
computes answer sets using the techniques similar to those used in SAT solvers. clingo is
a system that combines gringo and clasp in a monolithic way.
The first five examples in Figure 5 are part of the benchmark problems from the work
of Shanahan (1997, 1999). The next four are by Mueller (2006). (We increased timepoints
604

Reformulating the Situation Calculus and the Event Calculus

Problem
(max. step)
ZooTest1
(16)

f2lp with
gringo + cmodels
50.48s
(6.66s + 43.82s)
A:930483/R:2272288
C:3615955
ZooTest2
> 2h
159.51s
(22)
(12.36s + 147.15s)
A:2241512/R:4153670
C:8864228
ZooTest3
> 2h
142.68s
(23)
(13.55s + 129.13s)
A:2505940/R:4556928
C:9914568
A: number of atoms, C: number of clauses, R: number
dec
reasoner (minisat)
> 2h

f2lp with
gringo + clasp
29.01s
(6.66s + 22.35s)
A:153432/R:2271175
210.55s
(12.36s + 198.19s)
A:219220/R:4152137
196.63s
(13.55s + 183.08s)
A:230731/R:4555325
of ground rules

Figure 6: Zoo World in dec reasoner and ASP

to see more notable differences.) More examples can be found from the f2lp homepage. All
experiments were done on a Pentium machine with 3.06 GHz CPU and 4GB RAM running
64 bit Linux. The reported run times are in seconds and were obtained using the Linux
time command (“user time + sys time”), except for the dec reasoner for which we recorded
the times reported by the system. This was for fair comparisons in order to avoid including
the time spent by the dec reasoner in producing output in a neat format, which sometimes
takes non-negligible time. For the dec reasoner, the times in parentheses are “(SAT encoding time + SAT solving time).” For the others, they are the times spent by each of the
grounder and the solver. cmodels time includes the time spent in converting the ground
program generated by lparse/gringo into a set of clauses, and calling the SAT solver.
The time spent by f2lp in translating an event calculus description into an answer set
program (retaining variables) is negligible for these problems. ’—’ denotes that the system
cannot solve the example due to the limited expressivity. For instance, BusRide includes
disjunctive event axioms, which results in a disjunctive program that cannot be handled
by clingo. Similarly, the dec reasoner cannot handle BusRide (disjunctive event axioms),
Commuter (compound events) and Walking Turkey (effect constraints). As is evident from
the experiments, the main reason for the efficiency of the ASP-based approach is the efficient grounding mechanisms implemented in the ASP grounders. Though the dec reasoner
and cmodels call the same SAT solver minisat, the number of atoms processed by the dec
reasoner is in general much smaller. This is because the dec reasoner adopts an optimized
encoding method (that is based on predicate completion) which avoids a large number of
ground instances of atoms such as Initiates(e, f, t), Terminates(e, f, t), and Releases(e, f, t)
(Mueller, 2004, Section 4.4). On the other hand, in several examples, the number of clauses
generated by cmodels is 0, which means that the answer sets were found without calling
the SAT solver. This is because for these examples the unique answer set coincides with
the well-founded model, which is efficiently computed by cmodels in a preprocessing step
before calling SAT solvers. Out of the 14 benchmark examples by Shanahan (1997, 1999),
10 of them belong to this case when lparse is used for grounding.
605

Lee & Palla

In the experiments in Figure 5, the solving times are negligible for most of the problems. We also experimented with some computationally hard problems, where solving takes
more time than grounding. Figure 6 shows runs of a medium-size action domain, the Zoo
World (Akman, Erdoğan, Lee, Lifschitz, & Turner, 2004). All the tests shown in the table
are planning problems where max. step is the length of a minimal plan. The cut-off time
was 2 hours and the dec reasoner did not terminate within that time for any of the problems. In fact, the entire time was spent on SAT encoding and the SAT solver was never
called. On the other hand, the ASP grounder gringo took only a few seconds to ground
the domain and, unlike in Figure 5, the solvers took much more time than the grounder. As
we can see, cmodels with minisat performed better than clasp on two of the problems.
To check the time taken by minisat on the encoding generated by the dec reasoner, we
ran ZooTest1 to completion. The dec reasoner terminated after 116578.1 seconds (32.38
hours).

Appendix C. Proofs
C.1 Review of Some Useful Theorems
We review some theorems by Ferraris et al. (2011) and Ferraris et al. (2009) which will be
used to prove our main results. In fact, we will provide a version of the splitting theorem
which is slightly more general than the one given by Ferraris et al. (2009), in order to
facilitate our proof efforts.
Lemma 1 Formula
u ≤ p → ((¬F )∗ (u) ↔ ¬F )
is logically valid.
Theorem 12 (Ferraris et al., 2011, Thm. 2) For any first-order formula F and any
disjoint lists p, q of distinct predicate constants,
SM[F ; p] ↔ SM[F ∧ Choice(q); p ∪ q]
is logically valid.
Let F be a first-order formula. A rule of F is an implication that occurs strictly positively
in F . The predicate dependency graph of F (relative to p) is the directed graph that
• has all members of p as its vertices, and
• has an edge from p to q if, for some rule G → H of F ,
– p has a strictly positive occurrence in H, and
– q has a positive occurrence in G that does not belong to any subformula of G
that is negative on p.
Theorem 13 (Ferraris et al., 2009, Splitting Thm.) Let F , G be first-order sentences,
and let p, q be finite disjoint lists of distinct predicate constants. If
606

Reformulating the Situation Calculus and the Event Calculus

(a) each strongly connected component of the predicate dependency graph of F ∧ G relative
to p, q is either a subset of p or a subset of q,
(b) F is negative on q, and
(c) G is negative on p
then
SM[F ∧ G; p ∪ q] ↔ SM[F ; p] ∧ SM[G; q]
is logically valid.
The theorem is slightly more general than the one by Ferraris et al. (2009) in that the
notion of a dependency graph above yields less edges than the one given by Ferraris et al.
Instead of
– q has a positive occurrence in G that does not belong to any subformula of G
that is negative on p,
Ferraris et al.’s definition has
– q has a positive occurrence in G that does not belong to any subformula of the
form ¬K.
For instance, according to Ferraris et al., the dependency graph of
((p → q) → r) → p

(38)

relative to p has two edges (from p to r, and from p to p), while the dependency graph
according to our definition has no edges.
On the other hand, the generalization is not essential in view of the following theorem.
Theorem 14 (Ferraris et al., 2009, Thm. on Double Negations) Let H be a sentence, F
a subformula of H, and H ¬¬ the sentence obtained from H by inserting ¬¬ in front of F .
If the occurrence of F is p-negated in H, then SM[H; p] is equivalent to SM[H ¬¬ ; p].
For instance, SM[(38); p] is equivalent to SM[¬¬((p → q) → r) → p; p]. The dependency
graph of ¬¬((p → q) → r) → p relative to p according to the definition by Ferraris et al. is
identical to the dependency graph of (38) relative to p according to our definition.
Next, we say that a formula F is in Clark normal form (relative to the list p of intensional
predicates) if it is a conjunction of sentences of the form
∀x(G → p(x)),

(39)

one for each intensional predicate p, where x is a list of distinct object variables, and G has
no free variables other than those in x. The completion (relative to p) of a formula F in
Clark normal form is obtained by replacing each conjunctive term (39) with
∀x(p(x) ↔ G).
The following theorem relates SM to completion. We say that F is tight on p if the
predicate dependency graph of F relative to p is acyclic.
Theorem 15 (Ferraris et al., 2011) For any formula F in Clark normal form that is tight
on p, formula SM[F ; p] is equivalent to the completion of F relative to p.
607

Lee & Palla

C.2 Proof of Proposition 1
Using Theorem 12 and Theorem 13,
SM[F ; p] ⇔ SM[F ; p ∩ pr (F )] ∧ SM[>; p\pr (F )]
⇔ SM[F ; p ∩ pr (F )] ∧ False(p\pr (F ))
⇔ SM[F ∧ Choice(pr (F )\p)] ∧ False(p\pr (F ))
⇔ SM[F ∧ Choice(pr (F )\p) ∧ False(p\pr (F ))].

C.3 Proof of Theorem 1
In the following, F is a formula, p is a list of distinct predicate constants p1 , . . . , pn , and u
is a list of distinct predicate variables u1 , . . . , un of the same length as p.
Lemma 2 (Ferraris et al., 2011, Lemma 5) Formula
u ≤ p → (F ∗ (u) → F )
is logically valid.
Lemma 3 If every occurrence of every predicate constant from p is strictly positive in F ,
(u ≤ p) → (F ∗ (u) ↔ F (u))
is logically valid.
Proof. By induction. We will show only the case when F is G → H. The other cases are
straightforward. Consider
F ∗ (u) = (G∗ (u) → H ∗ (u)) ∧ (G → H).
Since every occurrence of predicate constants from p in F is strictly positive, G contains
no predicate constants from p, so that G∗ (u) is equivalent to G(u), which is the same as
G. Also, by I.H., H ∗ (u) ↔ H(u) is logically valid. Therefore it is sufficient to prove that
under the assumption u ≤ p,
(G → H(u)) ∧ (G → H) ↔ (G → H(u))
is logically valid. From left to right is clear. Assume (u ≤ p), G → H(u), and G. We get
H(u), which is equivalent to H ∗ (u) by I.H. By Lemma 2, we conclude H.

The proof of Theorem 1 is immediate from the following lemma, which can be proved
by induction.
Lemma 4 If F is canonical relative to p, then formula
(u ≤ p) ∧ F → (F ∗ (u) ↔ F (u))
is logically valid.
608

Reformulating the Situation Calculus and the Event Calculus

Proof.
• F is an atomic formula. Trivial.
• F = G ∧ H. Follows from I.H.
• F = G ∨ H. Assume (u ≤ p) ∧ (G ∨ H). Since G ∨ H is canonical relative to p,
every occurrence of every predicate constant from p is strictly positive in G or in H,
so that, by Lemma 3, G∗ (u) is equivalent to G(u), and H ∗ (u) is equivalent to H(u).
• F = G → H. Assume (u ≤ p) ∧ (G → H). It is sufficient to show
(G∗ (u) → H ∗ (u)) ↔ (G(u) → H(u)).

(40)

Since G → H is canonical relative to p, every occurrence of every predicate constant
from p in G is strictly positive in G, so that, by Lemma 3, G∗ (u) is equivalent to
G(u).
– Case 1: ¬G. By Lemma 2, ¬G∗ (u). The claim follows since ¬G∗ (u) is equivalent
to ¬G(u).
– Case 2: H. By I.H. H ∗ (u) is equivalent to H(u). The claim follows since G∗ (u)
is equivalent to G(u).
• F = ∀xG. Follows from I.H.
• F = ∃xG. Since every occurrence of every predicate constant from p in G is strictly
positive in G, the claim follows from Lemma 3.

C.4 Proof of Theorem 2
Proof. Between (a) and (b):
Between (b) and (c):

Follows immediately from Theorem 1.

Note first that Ξ is equivalent to SM[Ξ; ∅]. Since

• every strongly connected component in the dependency graph of Σ ∧ ∆ relative to
{I, T, R, H} either belongs to {I, T, R} or {H},
• Σ is negative on {H}, and
• ∆ is negative on {I, T, R},
it follows from Theorem 13 that (b) is equivalent to
SM[Σ ∧ ∆; I, T, R, H] ∧ SM[Θ; Ab1 , . . . , Abn ] ∧ SM[Ξ; ∅]
Similarly, applying Theorem 13 repeatedly, we can show that the above formula is
equivalent to (c).
Between (c) and (d):

By Proposition 1.



609

Lee & Palla

C.5 Proof of Theorem 3
Since Dcaused is canonical relative to Caused , by Theorem 1, (a)

Between (a) and (b):
is equivalent to

−
SM[Dcaused ; Caused ] ∧ Dposs ∧ Drest
∧ (22).

(41)

Consequently, it is sufficient to prove the claim that, under the assumption ∀s Sit(s),
formula (22) is equivalent to SM[Dsit ; Sit].
First note that under the assumption, (22) can be equivalently rewritten as

∀p p(S0 ) ∧ ∀a, s(p(s) → p(do(a, s))) → p = Sit .
(42)
On the other hand, under ∀s Sit(s), SM[Dsit ; Sit] is equivalent to
Sit(S0 ) ∧ ∀a, s(Sit(s) → Sit(do(a, s)))

∧ ∀p p < Sit → ¬(p(S0 ) ∧ ∀a, s(p(s) → p(do(a, s))) ∧ ∀a, s(Sit(s) → Sit(do(a, s)))) ,
which, under the assumption ∀s Sit(s), is equivalent to
∀p p(S0 ) ∧ ∀a, s(p(s) → p(do(a, s))) → ¬(p < Sit)



and furthermore to (42).
Between (b) and (c): Since φ(s) does not contain Poss, the equivalence follows from the
equivalence between completion and the stable model semantics.
Between (c) and (d): Since Dcaused contains no strictly positive occurrence of Poss
and Dposs → contains no occurrence of Caused , every strongly connected component in the
predicate dependency graph of Dcaused ∧ Dposs → relative to {Caused , Poss} either belongs
to {Caused } or belongs to {Poss}. By Theorem 13, it follows that (b) is equivalent to
−
SM[Dcaused ∧ Dposs → ; Caused , Poss] ∧ Drest
∧ SM[Dsit ; Sit].

Similarly, applying Theorem 13 two more times, we get that the above formula is equivalent
to (c).

C.6 Proof of Theorem 4
Theory T is
Σ ∧ Deffect ∧ Dprecond ∧ DS0 ∧ Duna ∧ Dinertia ∧ Dexogenous0 ,
and the corresponding BAT is
Σ ∧ Dss ∧ Dap ∧ DS0 ∧ Duna .
Without loss of generality, we assume that T is already equivalently rewritten so that there
are exactly one positive effect axiom and exactly one negative effect axiom for each fluent R,
and that there is exactly one action precondition axiom for each action A.
610

Reformulating the Situation Calculus and the Event Calculus

Consider
SM[Σ ∧ Deffect ∧ Dprecond ∧ DS0 ∧ Duna ∧ Dinertia ∧ Dexogenous0 ; Poss, Holds, ∼Holds].
Since Σ and Duna are negative on the intensional predicates, the formula is equivalent to
SM[Deffect ∧ Dprecond ∧ DS0 ∧ Dinertia ∧ Dexogenous0 ; P oss, Holds, ∼Holds] ∧ Σ ∧ Duna .
(43)
Since P oss does not occur in
Deffect ∧ DS0 ∧ Dinertia ∧ Dexogenous0 ,
and since Dprecond is negative on {Holds, ∼Holds}, by Theorem 13, (43) is equivalent to
SM[Deffect ∧ DS0 ∧ Dinertia ∧ Dexogenous0 ; Holds, ∼Holds]
∧ SM[Dprecond ; P oss] ∧ Σ ∧ Duna ,

(44)

which is equivalent to
SM[Deffect ∧ DS0 ∧ Dinertia ∧ Dexogenous0 ; Holds, ∼Holds]
∧ Dap ∧ Σ ∧ Duna .
Therefore the statement of the theorem can be proven by showing the following: if
−
I |= ¬∃x a s(Γ+
R (x, a, s) ∧ ΓR (x, a, s))

(45)

I |= Σ

(46)

SM[DS0 ∧ Dexogenous0 ∧ Deffect ∧ Dinertia ; Holds, ∼Holds]

(47)

for every fluent R, and
then I satisfies

iff I|σ satisfies
DS0 ∧ Dss .
From Dexogenous0 , it follows that (47) is equivalent to
SM[DS¬¬
∧ Dexogenous0 ∧ Deffect ∧ Dinertia ; Holds, ∼Holds],
0

(48)

where DS¬¬
is the formula obtained from DS0 by prepending ¬¬ to all occurrences of Holds.
0
Under the assumption (46),
DS¬¬
∧ Dexogenous0 ∧ Deffect ∧ Dinertia
0
is {Holds}-atomic-tight w.r.t. I, 26 so that by the relationship between completion and SM
that is stated in Corollary 11 of (Lee & Meng, 2011), we have that I |= (48) iff I satisfies
DS0 , and, for each fluent R,
26. See Section 7 from the work of Lee and Meng (2011) for the definition.

611

Lee & Palla

Holds(R(x), do(a, s)) ↔ Γ+
R (x, a, s) ∨ (Holds(R(x, s) ∧ ¬ ∼Holds(R(x), do(a, s)))

(49)

and
∼Holds(R(x), do(a, s)) ↔ Γ−
R (x, a, s) ∨ (∼Holds(R(x), s) ∧ ¬Holds(R(x), do(a, s))), (50)
where x, a, s are any (lists of) object names of corresponding sorts.
It remains to show that, under the assumption (45), I satisfies (49) ∧ (50) iff I|σ satisfies
−
Holds(R(x), do(a, s)) ↔ Γ+
R (x, a, s) ∨ (Holds(R(x), s) ∧ ¬ΓR (x, a, s)).

(51)

In the following we will use the following facts.
• I |=∼Holds(R(x), s) iff I|σ 6|= Holds(R(x), s).
• if F is a ground formula that does not contain ∼, then I |= F iff I|σ |= F .
Left to Right: Assume I |= (49) ∧ (50).
• Case 1: I|σ |= Holds(R(x), do(a, s)). Clearly, I |= Holds(R(x), do(a, s)), so that,
from (49), there are two subcases to consider.
– Subcase 1: I |= Γ+
R (x, a, s). Clearly, I|σ satisfies both LHS and RHS of (51).
– Subcase 2: I |= Holds(R(x), s). From (50), it follows that I 6|= Γ−
R (x, a, s), and
(x,
a,
s).
Clearly,
I|
satisfies
both
LHS
and
RHS of (51).
consequently, I|σ 6|= Γ−
σ
R
• Case 2: I|σ 6|= Holds(R(x), do(a, s)). It follows from (49) that I 6|= Γ+
R (x, a, s), which
(x,
a,
s).
Also
since
I
|=∼Holds(R(x),
do(a, s)),
is equivalent to saying that I|σ 6|= Γ+
R
from (50), there are two subcases to consider.
– Subcase 1: I |= Γ−
R (x, a, s). Clearly, I|σ satisfies neither LHS nor RHS of (51).
– Subcase 2: I |= ∼ Holds(R(x), s). This is equivalent to saying that I|σ 6|=
Holds(R(x), s). Clearly, I|σ satisfies neither LHS nor RHS of (51).
Right to Left: Assume I|σ |= (51).
• Case 1: I |= Holds(R(x), do(a, s)). It follows from (51) that I|σ satisfies RHS of (51),
so that there are two subcases to consider.
– Subcase 1: I|σ |= Γ+
R (x, a, s). Clearly, I satisfies both LHS and RHS of (49).
Also from (45), it follows that I 6|= Γ−
R (x, a, s). Consequently, I satisfies neither
LHS nor RHS of (50).
– Subcase 2: I|σ |= Holds(R(x), s) ∧ ¬Γ−
R (x, a, s). Clearly, I satisfies both LHS and
RHS of (49). Since I 6|= Γ−
(x,
a,
s),
I
satisfies neither LHS nor RHS of (50).
R
• Case 2: I |=∼Holds(R(x), do(a, s)). It follows from (51) that I|σ 6|= Γ+
R (x, a, s), and
I|σ 6|= (Holds(R(x), s) ∧ ¬Γ−
(x,
a,
s)).
From
the
latter,
consider
the
two
subcases.
R
612

Reformulating the Situation Calculus and the Event Calculus

– Subcase 1: I|σ 6|= Holds(R(x), s). Clearly, I satisfies neither LHS nor RHS of
(49), and satisfies both LHS and RHS of (50).
– Subcase 2: I|σ 6|= ¬Γ−
R (x, a, s). Clearly, I satisfies neither LHS nor RHS of (49),
and satisfies both LHS and RHS of (50).

C.7 Proof of Proposition 2
Lemma 5 Let F be a formula, let p be a list of distinct predicate constants, let G be a
subformula of F and let G0 be any formula that is classically equivalent to G. Let F 0 be the
formula obtained from F by substituting G0 for G. If the occurrence of G is in a subformula
of F that is negative on p and the occurrence of G0 is in a subformula of F 0 that is negative
on p, then
SM[F ; p] ↔ SM[F 0 ; p]
is logically valid.
Proof. Let F ¬¬ be the formula obtained from F by prepending ¬¬ to G, and let (F 0 )¬¬
be the formula obtained from F 0 by prepending ¬¬ to G0 . By the Theorem on Double
Negations (Theorem 14), the following formulas are logically valid.
SM[F ; p] ↔ SM[F ¬¬ ; p],
SM[F 0 ; p] ↔ SM[(F 0 )¬¬ ; p].
From Lemma 1, it follows that
(u ≤ p ∧ (G ↔ G0 )) → ((F ¬¬ )∗ (u) ↔ ((F 0 )¬¬ )∗ (u))
is logically valid, where u is a list of predicate variables corresponding to p. Consequently,
SM[F ¬¬ ; p] ↔ SM[(F 0 )¬¬ ; p]
is logically valid.



Proof of Proposition 2. In formula
SM[F 0 ∧ ∀xy(G(y, x) → q(x)); p, q],

(52)

clearly, F 0 is negative on q and ∀xy(G(y, x) → q(x)) is negative on p. Let H be any
subformula of F that is negative on p and contains the occurrence of ∃yG(y, x). Consider
two cases.
• Case 1: the occurrence of ∃yG(y, x) in H is not strictly positive. Thus the dependency
graph of F 0 ∧ ∀xy(G(y, x) → q(x)) relative to {p, q} has no incoming edges into q.
• Case 2: the occurrence of ∃yG(y, x) in H is strictly positive. Since H is negative on p, ∃yG(y, x) is negative on p as well, so that the dependency graph of
F 0 ∧ ∀xy(G(y, x) → q(x)) relative to {p, q} has no outgoing edges from q.
613

Lee & Palla

Therefore, every strongly connected component in the dependency graph belongs to either
p or {q}. Consequently, by Theorem 13, (52) is equivalent to
SM[F 0 ; p] ∧ SM[∀xy(G(y, x) → q(x)); q]

(53)

Since ∃yG(y, x) is negative on q, formula ∀xy(G(y, x) → q(x)) is tight on {q}. By Theorem 15, (53) is equivalent to
SM[F 0 ; p] ∧ ∀x(∃yG(y, x) ↔ q(x)).

(54)

By Lemma 5, it follows that (54) is equivalent to
SM[F ; p] ∧ ∀x(∃yG(y, x) ↔ q(x)).
Consequently, the claim follows.



C.8 Proof of Theorem 6
It is clear that the algorithm terminates and yields a quantifier-free formula K. We will
prove that SM[F ; p] ⇔σ SM[∀xK; p ∪ q], where x is the list of all (free) variables of K.
Let F ¬¬ be the formula obtained from the initial formula F by prepending double
negations in front of every maximal strictly positive occurrence of formulas of the form
∃yG(x, y). Since F is almost universal relative to p, such an occurrence is in a subformula
of F that is negative on p. Thus by the Theorem on Double Negations (Theorem 14),
SM[F ; p] is equivalent to SM[F ¬¬ ; p]. Note that F ¬¬ contains no strictly positive occurrence
of formulas of the form ∃yG(x, y).
For each iteration, let us assume that the formula before the iteration is
H0 ∧ · · · ∧ Hn ,
where H0 is transformed from F ¬¬ by the previous iterations, and each Hi (i > 0) is a
formula of the form G(x, y) → pG (x) that is introduced by Step (b). Initially H0 is F ¬¬
and n = 0. Let r0 be p, and let ri be each pG for Hi (i > 0). By induction we can prove
that
(i) every positive occurrence of formulas of the form ∃yG(x, y) in Hi is not strictly positive, and is in a subformula of Hi that is negative on ri ;
(ii) every negative occurrence of formulas of the form ∀yG(x, y) in Hi is in a subformula
of Hi that is negative on ri .
We will prove that if Step (a) or Step (c) is applied to turn Hk into Hk0 , then
SM[∀x0 H0 ; r0 ] ∧ · · · ∧ SM[∀xn Hn ; rn ]

(55)

SM[∀x00 H00 ; r0 ] ∧ · · · ∧ SM[∀x0n Hn0 ; rn ],

(56)

is equivalent to
where Hj0 = Hj for all j different from k, and xi (i ≥ 0) is the list of all free variables of
Hi , and x0i (i ≥ 0) is the list of all free variables of Hi0 .
614

Reformulating the Situation Calculus and the Event Calculus

Indeed, Step (a) is a part of prenex form conversion, which preserves strong equivalence
(Theorem 5). So it is clear that (55) is equivalent to (56).
When Step (c) is applied to turn (55) into (56), since ∀yH(x, y) is in a subformula of
Hk that is negative on rk , the equivalence between (55) and (56) follows from Lemma 5.
When Step (b) is applied to turn Hk into Hk0 and introduces a new conjunctive term
0
Hn+1 , formula (55) is (σ, r1 , . . . , rn )-equivalent to
0
SM[∀x00 H00 ; r0 ] ∧ · · · ∧ SM[∀x0n Hn0 ; rn ] ∧ SM[∀x0n+1 Hn+1
; rn+1 ]

(57)

by Proposition 2 due to condition (i).
Let
00
H000 ∧ · · · ∧ Hm

(58)

be the final quantifier-free formula, where H000 is transformed from F ¬¬ . By the induction,
it follows that SM[F ; p] is σ-equivalent to
00
SM[∀x000 H000 ; r0 ] ∧ · · · ∧ SM[∀x00m Hm
; rm ],

(59)

where each x00i (0 ≤ i ≤ m) is the list of all free variables of Hi00 .
Since every non-strictly positive occurrence of new predicate ri (i > 0) in any Hj00 (0 ≤
j ≤ m) is positive, there is no incoming edge into ri in the dependency graph of (58) relative
to r0 , r1 , . . . , rm . Consequently, every strongly connected component of the dependency
graph belongs to one of ri (i ≥ 0). Moreover, it is clear that each Hi00 (i ≥ 0) is negative
on every rj for j 6= i. (In the case of H000 , recall that the occurrence of rj for any j > 0
is not strictly positive since F ¬¬ , from which H000 is obtained, contains no strictly positive
occurrence of formulas of the form ∃yG(x, y).) Thus by the splitting theorem (Theorem 13),
formula (59) is equivalent to
00
SM[∀x000 H000 ∧ · · · ∧ ∀x00m Hm
; r0 ∪ · · · ∪ rm ].

(60)


C.9 Proof of Theorem 7
We use the notations introduced in the proof of Theorem 6. By Theorem 6, SM[F ; p] is
σ-equivalent to (60) and, by Theorem 12, (60) is equivalent to
00
SM[∀x000 H000 ∧ · · · ∧ ∀x00m Hm
∧ Choice(σ pred \ p); σ pred ∪ r1 ∪ · · · ∪ rm ]

(61)

(r0 is p), where σ pred is the set of all predicate constants in signature σ. It follows from
Proposition 3 from (Cabalar et al., 2005) that (61) is equivalent to
000
SM[∀x000 H0000 ∧ · · · ∧ ∀x00m Hm
∧ Choice(σ pred \ p); σ pred ∪ r1 ∪ · · · ∪ rm ],

(62)

where Hi000 is obtained from Hi00 by applying the translation from (Cabalar et al., 2005,
Section 3) that turns a quantifier-free formula into a set of rules. It is easy to see that F 0
is the same as the formula
000
∀x000 H0000 ∧ · · · ∧ ∀x00m Hm
∧ Choice(σ pred \ p)

615

Lee & Palla

and σ pred ∪ r1 ∪ · · · ∪ rm is the same as p ∪ pr (F 0 ), so that (62) can be written as
SM[F 0 ; p ∪ pr (F 0 )],
which is equivalent to
SM[F 0 ∧ False(p \ pr (F 0 ))].
by Proposition 1.



C.10 Proof of Theorem 8
Assume that T is
CIRC[Σ; Initiates, Terminates, Releases] ∧ CIRC[∆; Happens]
∧ CIRC[Θ; Ab 1 , . . . , Ab n ] ∧ Ξ,
which is equivalent to
SM[Σ; Initiates, Terminates, Releases] ∧ SM[∆; Happens]
∧ SM[Θ; Ab 1 , . . . , Ab n ] ∧ Ξ

(63)

by Theorem 2.
Let Ξdef be the set of all definitions (35) in Ξ, and let Ξ0 be the formula obtained from Ξ
by applying Step 1. By Theorem 15, it follows that each formula (35) in Ξdef is equivalent
to
SM[∀x(G0 → p(x)); p],
where G0 is as described in Step 1. Consequently, (63) is equivalent to
SM[Σ; Initiates, Terminates,
V Releases] ∧ SM[∆; Happens]
∧ SM[Θ; Ab 1 , . . . , Ab n ] ∧ (35)∈Ξdef SM[∀x(G0 → p(x)); p] ∧ Ξ00 ,

(64)

where Ξ00 is the conjunction of all the axioms in Ξ0 other than the ones obtained from
definitional axioms (35).
Applying Theorem 13 repeatedly, it follows that (64) is equivalent to
V
SM[Σ ∧ ∆ ∧ Θ ∧ Ξ00 ∧ (35)∈Ξdef ∀x(G0 → p(x));
Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n , p] .

(65)

According to the syntax of the event calculus reviewed in Section 3.1,
• every positive occurrence of a formula of the form ∃yG(y) in (65) is contained in a
subformula that is negative on
{Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n , p}, and
• there are no negative occurrences of any formula of the form ∀yG(y) in (65).
Consequently, the statement of the theorem follows from Theorem 7.

616



Reformulating the Situation Calculus and the Event Calculus

C.11 Proof of Theorem 9
Since (37) is almost universal relative to {Caused , Poss, Sit}, the result follows from Theorems 7 and 3.

C.12 Proof of Theorem 10
From Dexogenous0 , it follows that SM[T ; Holds, ∼Holds, Poss] is equivalent to
SM[T ¬¬ ; Holds, ∼ Holds, Poss], where T ¬¬ is obtained from T by prepending ¬¬ to all
occurrences of Holds in DS0 . From the definition of a uniform formula (Reiter, 2001), it
follows that T ¬¬ is almost universal relative to {Holds, ∼Holds, Poss}. The result follows
from Theorem 7.


References
Akman, V., Erdoğan, S., Lee, J., Lifschitz, V., & Turner, H. (2004). Representing the Zoo
World and the Traffic World in the language of the Causal Calculator. Artificial
Intelligence, 153(1–2), 105–140.
Belleghem, K. V., Denecker, M., & Schreye, D. D. (1995). Combining situation calculus
and event calculus. In Proceedings of International Conference on Logic Programming
(ICLP), pp. 83–97.
Belleghem, K. V., Denecker, M., & Schreye, D. D. (1997). On the relation between situation
calculus and event calculus. Journal of Logic Programming, 31 (1-3), 3–37.
Besnard, P., & Cordier, M.-O. (1994). Explanatory diagnoses and their characterization by
circumscription. Annals of Mathematics and Artificial Intelligence, 11 (1-4), 75–96.
Cabalar, P., & Ferraris, P. (2007). Propositional theories are strongly equivalent to logic
programs. Theory and Practice of Logic Programming, 7 (6), 745–759.
Cabalar, P., Pearce, D., & Valverde, A. (2005). Reducing propositional theories in equilibrium logic to logic programs. In Proceedings of Portuguese Conference on Artificial
Intelligence (EPIA), pp. 4–17.
Calimeri, F., Cozza, S., Ianni, G., & Leone, N. (2008). Computable functions in ASP: theory
and implementation. In Proceedings of International Conference on Logic Programming (ICLP), pp. 407–424.
Denecker, M., & Ternovska, E. (2007). Inductive situation calculus. Artificial Intelligence,
171 (5-6), 332–360.
Denecker, M., & Ternovska, E. (2008). A logic of nonmonotone inductive definitions. ACM
Transactions on Computational Logic, 9 (2).
Doherty, P., Gustafsson, J., Karlsson, L., & Kvarnström, J. (1998). TAL: Temporal action
logics language specification and tutorial. Linköping Electronic Articles in Computer
and Information Science ISSN 1401-9841, 3 (015). http://www.ep.liu.se/ea/cis/
1998/015/.
617

Lee & Palla

Doğandağ, S., Ferraris, P., & Lifschitz, V. (2004). Almost definite causal theories.. In
Proceedings of International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR), pp. 74–86.
Erdem, E., & Lifschitz, V. (2003). Tight logic programs. Theory and Practice of Logic
Programming, 3, 499–518.
Fages, F. (1994). Consistency of Clark’s completion and existence of stable models. Journal
of Methods of Logic in Computer Science, 1, 51–60.
Ferraris, P., Lee, J., & Lifschitz, V. (2007). A new perspective on stable models. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 372–379.
Ferraris, P., Lee, J., & Lifschitz, V. (2011). Stable models and circumscription. Artificial
Intelligence, 175, 236–263.
Ferraris, P., Lee, J., Lifschitz, V., & Palla, R. (2009). Symmetric splitting in the general
theory of stable models. In Proceedings of International Joint Conference on Artificial
Intelligence (IJCAI), pp. 797–803.
Gebser, M., Schaub, T., & Thiele, S. (2007). Gringo : A new grounder for answer set
programming. In Proceedings of International Conference on Logic Programming and
Nonmonotonic Reasoning (LPNMR), pp. 266–271.
Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming. In
Kowalski, R., & Bowen, K. (Eds.), Proceedings of International Logic Programming
Conference and Symposium, pp. 1070–1080. MIT Press.
Gelfond, M., & Lifschitz, V. (1998). Action languages. Electronic Transactions on Artificial
Intelligence, 3, 195–210. http://www.ep.liu.se/ea/cis/1998/016/.
Giunchiglia, E., Lee, J., Lifschitz, V., McCain, N., & Turner, H. (2004). Nonmonotonic
causal theories. Artificial Intelligence, 153(1–2), 49–104.
Heyting, A. (1930). Die formalen Regeln der intuitionistischen Logik. Sitzungsberichte
der Preussischen Akademie von Wissenschaften. Physikalisch-mathematische Klasse,
42–56.
Janhunen, T., & Oikarinen, E. (2004). Capturing parallel circumscription with disjunctive
logic programs. In Proc. of 9th European Conference in Logics in Artificial Intelligence
(JELIA-04), pp. 134–146.
Kautz, H., & Selman, B. (1992). Planning as satisfiability. In Proceedings of European
Conference on Artificial Intelligence (ECAI), pp. 359–363.
Kim, T.-W., Lee, J., & Palla, R. (2009). Circumscriptive event calculus as answer set programming. In Proceedings of International Joint Conference on Artificial Intelligence
(IJCAI), pp. 823–829.
Kowalski, R., & Sergot, M. (1986). A logic-based calculus of events. New Generation
Computing, 4, 67–95.
Kowalski, R. A., & Sadri, F. (1997). Reconciling the event calculus with the situation
calculus. Journal of Logic Programming, 31 (1-3), 39–58.
618

Reformulating the Situation Calculus and the Event Calculus

Lee, J., Lifschitz, V., & Palla, R. (2008). A reductive semantics for counting and choice
in answer set programming. In Proceedings of the AAAI Conference on Artificial
Intelligence (AAAI), pp. 472–479.
Lee, J., & Lin, F. (2006). Loop formulas for circumscription. Artificial Intelligence, 170 (2),
160–185.
Lee, J., & Meng, Y. (2011). First-order stable model semantics and first-order loop formulas.
Journal of Artificial Inteligence Research (JAIR), 42, 125–180.
Lee, J., & Palla, R. (2007). Yet another proof of the strong equivalence between propositional
theories and logic programs. In Working Notes of the Workshop on Correspondence
and Equivalence for Nonmonotonic Theories.
Lee, J., & Palla, R. (2010). Situation calculus as answer set programming. In Proceedings
of the AAAI Conference on Artificial Intelligence (AAAI), pp. 309–314.
Lifschitz, V. (1994). Circumscription. In Gabbay, D., Hogger, C., & Robinson, J. (Eds.),
Handbook of Logic in AI and Logic Programming, Vol. 3, pp. 298–352. Oxford University Press.
Lifschitz, V. (2008). What is answer set programming?. In Proceedings of the AAAI Conference on Artificial Intelligence, pp. 1594–1597. MIT Press.
Lifschitz, V. (2011). Datalog programs and their stable models. In de Moor, O., Gottlob,
G., Furche, T., & Sellers, A. (Eds.), Datalog Reloaded: First International Workshop,
Datalog 2010, Oxford, UK, March 16-19, 2010. Revised Selected Papers. Springer.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM
Transactions on Computational Logic, 2, 526–541.
Lifschitz, V., Tang, L. R., & Turner, H. (1999). Nested expressions in logic programs. Annals
of Mathematics and Artificial Intelligence, 25, 369–389.
Lifschitz, V., & Turner, H. (1999). Representing transition systems by logic programs. In
Proceedings of International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR), pp. 92–106.
Lin, F. (1995). Embracing causality in specifying the indirect effects of actions. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 1985–
1991.
Lin, F. (2003). Compiling causal theories to successor state axioms and STRIPS-like systems. Journal of Artificial Intelligence Research, 19, 279–314.
Lin, F., & Shoham, Y. (1992). A logic of knowledge and justified assumptions. Artificial
Intelligence, 57, 271–289.
Lin, F., & Wang, K. (1999). From causal theories to logic programs (sometimes). In
Proceedings of International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR), pp. 117–131.
Lin, F., & Zhou, Y. (2011). From answer set logic programming to circumscription via logic
of GK. Artificial Intelligence, 175, 264–277.
619

Lee & Palla

Marek, V., & Truszczyński, M. (1999). Stable models and an alternative logic programming
paradigm. In The Logic Programming Paradigm: a 25-Year Perspective, pp. 375–398.
Springer Verlag.
McCarthy, J. (1980). Circumscription—a form of non-monotonic reasoning. Artificial Intelligence, 13, 27–39,171–172.
McCarthy, J. (1986). Applications of circumscription to formalizing common sense knowledge. Artificial Intelligence, 26 (3), 89–116.
McCarthy, J., & Hayes, P. (1969). Some philosophical problems from the standpoint of
artificial intelligence. In Meltzer, B., & Michie, D. (Eds.), Machine Intelligence, Vol. 4,
pp. 463–502. Edinburgh University Press, Edinburgh.
Miller, R., & Shanahan, M. (1999). The event calculus in classical logic - alternative axiomatisations. Electronic Transactions on Artificial Intelligence, 3 (A), 77–105.
Mueller, E. (2006). Commonsense reasoning. Morgan Kaufmann.
Mueller, E. T. (2004). Event calculus reasoning through satisfiability. Journal of Logic and
Computation, 14 (5), 703–730.
Niemelä, I. (1999). Logic programs with stable model semantics as a constraint programming
paradigm. Annals of Mathematics and Artificial Intelligence, 25, 241–273.
Pearce, D., & Valverde, A. (2005). A first order nonmonotonic extension of constructive
logic. Studia Logica, 80, 323–348.
Provetti, A. (1996). Hypothetical reasoning about actions: From situation calculus to event
calculus. Computational Intelligence, 12, 478–498.
Reiter, R. (1980). A logic for default reasoning. Artificial Intelligence, 13, 81–132.
Reiter, R. (1991). The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. In Lifschitz, V. (Ed.), Artificial
Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, pp. 359–380. Academic Press.
Reiter, R. (2001). Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems. MIT Press.
Shanahan, M. (1995). A circumscriptive calculus of events. Artif. Intell., 77 (2), 249–284.
Shanahan, M. (1997). Solving the Frame Problem: A Mathematical Investigation of the
Common Sense Law of Inertia. MIT Press.
Shanahan, M. (1999). The event calculus explained. In Artificial Intelligence Today, LNCS
1600, pp. 409–430. Springer.
Shanahan, M., & Witkowski, M. (2004). Event calculus planning through satisfiability.
Journal of Logic and Computation, 14 (5), 731–745.
Syrjänen, T. (2004). Cardinality constraint programs.. In Proceedings of European Conference on Logics in Artificial Intelligence (JELIA), pp. 187–199.
Zhang, H., Zhang, Y., Ying, M., & Zhou, Y. (2011). Translating first-order theories into logic
programs. In Proceedings of International Joint Conference on Artificial Intelligence
(IJCAI), pp. 1126–1131.

620

IEEE ICC 2016 SAC Access Systems and Networks

A Performance Study of Proxy-based TCP Rate
Control Design for Mobile Video Streaming
Services
Joohyung Lee, Hyungho Lee, Jinsung Lee, Hanna Lim, Jungshin Park and Jicheol Lee
Mobile Communications Business, Samsung Electronics, South Korea
Email: {j14.lee, hyungho0.lee, js81.lee, hanna.lim, shin02.park, jicheol.lee}@samsung.com
Abstract—Reducing startup delay of video streaming is important for attracting more users. In LTE networks, even though
available bandwidth has increased, behavior of TCP, which has
a slow start phase and estimates available capacity based on
packet loss event, increases the startup delay of video streaming.
To solve this issue, we design a proxy-based TCP rate control
(PTRC) scheme for achieving low startup delay of mobile video
streaming by using the explicit radio related information from a
base station (BS). We introduce a target queue length (Qtarget )
as feedback information to a proxy, which represents a desired
value at the BS. Here, the Qtarget is dynamically calculated by
referring to average data rate of a radio link and backhaul
delay. Then the proxy is informed of this Qtarget by an in-band
signaling message from the BS, and controls its sending rate
accordingly. Hence, the proposed PTRC scheme can boost up its
transmission rates in the initial phase, and keep instant queue
length at the BS close to the Qtarget . We verify that the proposed
PTRC scheme achieves about 71.2% reduction of startup delay
for mobile video streaming in LTE environment, compared to
conventional schemes.

I. I NTRODUCTION
The demand for mobile video streaming services has significantly increased in the last decade with widespread adoption
of smartphones as well as evolution of radio access network
technologies [1]. For satisfactory video streaming services, operators try to ensure that the video starts up quickly and plays
without re-buffering, which leads to less user abandonment
and more user engagement. Hence, startup delay, which is
the time to begin a video streaming service, and re-buffering
rates have been considered as major quality metrics for video
streaming [2].
Various approaches to improve the quality of video streaming have been studied in the literature, aiming for reduction
of startup delay and re-buffering rate. One of most popular
methods is that a user decides its encoding bitrates at application level by monitoring dynamic network conditions and then
requests the corresponding video data from a server, which can
easily prevent rebuffering problems, e.g., [3]–[5]. On the other
hand, for the startup delay reduction, operators relocate their
own content servers close to end users (i.e., nearby a gateway
in LTE networks) so that end-to-end distance can be shortened
[6]. Nevertheless, the startup delay still remains unsatisfactory.
The root cause of this problem is that TCP, the transport
protocol for most of video streaming today, begins with very
low transmission rates due to its slow start mechanism during

978-1-4799-6664-6/16/$31.00 ©2016 IEEE

the initial phase, leading to under-utilization of radio resources
and long startup delay, as studied in [7]. TCP also induces a
large queueing delay at a Base Station (BS), which is named
as “bufferbloat”, given that the BS has a large queue size [8].
This over-buffering problem makes startup delay of mobile
video streaming much worse in the presence of a background
long-lived TCP ﬂow.
This concern has motivated studies to control TCP’s sending
rate to utilize radio resources efﬁciently [7]–[10]. The common
goal of these studies is to ﬁnd optimal TCP’s sending rate for
achieving maximum TCP throughput with minimum queuening delay. In [8], Jiang proposed dynamic receive window
adjustment for achieving minimal end-to-end latency, which
modiﬁes the existing receive window adjustment scheme of
TCP to indirectly control its sending rate. Similarly, the
work in [9] proposed a solution which modiﬁes the existing
advertised window of TCP ﬂows to bound them to their fair
bandwidth share by monitoring how long packets remain in
the queue at access point. These novel approaches in [8], [9]
can limit the sending rates not to exceed the available radio
link speed. Nevertheless, there is little consideration on the
problem of slow start mechanism implemented in TCP. The
work of [7] directly used the explicit radio related information
from a BS to control TCP’s sending rate for improving TCP
performance, which is the closest to this paper. However, since
they aim to keep queue length at the BS close to a predetermined ﬁxed value, it does not guarantee to keep queueing
delay as an adequate value at the BS. In addition, they use
UDP signaling for delivering the feedback information, which
requires additional signaling overhead. Thus, there is still room
to improve the work in [7], which inspired our work.
In this paper, we design a proxy-based TCP rate control
(PTRC) scheme which achieves low startup delay of mobile
video streaming by using the explicit radio related information
from a BS. A target queue length (Qtarget ) is introduced as
feedback information which represents a desired queue length
at the BS. Speciﬁcally, the Qtarget is dynamically calculated
by referring to 1) average data rate of a radio link, 2) backhaul
delay, and 3) desirable queueing delay (i.e., web page delay
requirement) at the BS. The proxy is informed of this Qtarget
by using in-band signaling such as TCP acknowledgement
(ACK) packet from the BS, and controls its sending rate
in order to keep instant queue length at the BS close to

2

Proposed BS Operation
Qtarget-QL = į Calculation

Feedback į using TCP ACK

Proposed Proxy
Operation :
W update

TCP sending Rate W

Radio link
speed R

Backhaul
Network

BS

Proxy

Backhaul delay (DBH)
Fig. 1.

Origin Server

System model of the proposed PTRC scheme.

the Qtarget . Thus, compared to the work of [7], which used
UDP signaling, our PTRC scheme does not require any extra
signaling overhead. In summary, the contributions of this paper
include:
• We propose a simple and immediately deployable proxybased solution which does not require any modiﬁcation
of an origin server. In our proposed scheme, by using the
explicit radio related information (Qtarget ) from a BS, the
proxy controls its sending rate in order to keep instant
queue length at the BS close to the Qtarget . Detailed
speciﬁcations and implementation parts of our proposed
PTRC scheme in NS-3 simulator are provided.
• Through extensive NS-3 simulations, we newly provide
interesting results in terms of startup delay of mobile
video streaming in LTE environment. From performance
study, our proposed solution achieves almost 71.2% reduction of startup delay compared to TCP CUBIC [11]
which is most widely used in LINUX under conditions
with no background trafﬁc. We also ﬁnd out that as
the backhaul delay increases, the startup delay of other
TCP schemes signiﬁcantly increases (i.e., up to 4 sec)
while ours is almost 1 sec. In addition, as the available
bandwidth at the BS increases, more performance gain of
our PTRC scheme can be achieved. When there is other
background TCP trafﬁc, our solution has almost 62.5%
reduction in startup delay.

TABLE I
S UMMARY OF MAJOR SYMBOLS
Symbol

Deﬁnition

Qtarget

Target queue length

QL(t)

Queue length at BS at t

DBH

Backhaul delay

DBS

Desired queueing delay at BS

R(t)

Average data rate of radio link at BS at t

W

Congestion window size decided by proxy

in T CPS<−>P is out of scope. Our proxy is deployed in
the system architecture evolution gateway (SAE-GW) where
there is constant backhaul delay (DBH ) between the SAE-GW
and the BS. This proxy deployment location is considered as
most straightforward option since the SAE-GW is the mobility
anchor point in LTE networks [12]. Furthermore, we assumed
that the origin server is also located close to the SAE-GW.
This is reasonable assumption when the operator has own
content server in LTE networks. Thus, our paper can focus on
ideal performance evaluation of the proposed scheme since the
additional delay acquiring the video content over T CPS<−>P
is negligible. Detailed BS and proxy operation will be covered
below. Table I summarizes a list of symbols used in the paper.
A. Proposed BS operation

II. P ROXY- BASED TCP R ATE C ONTROL (PTRC) S CHEME
In this section, we ﬁrst explain our system model as
illustrated in Fig. 1. We consider that there is a single user
attached to the BS. This user requests video streaming from
an origin server using downlink TCP connection. The video
content consists of small-sized chunks, each of which contains
split data for a ﬁxed duration of playback. The chunk requested
for video streaming is delivered to the user via a proposed
proxy, which the proxy divides an end-to-end TCP connection into two separate connections ensuring transparency to
both end points. Throughout the paper, we call one TCP
connection between the proxy and the user T CPU <−>P and
another TCP connection between the origin server and the
proxy T CPS<−>P . Thus, the proposed proxy can control the
sending rate of T CPP <−>U . In this paper, we do not consider
modiﬁcation of the origin server, so control of sending rate

In the proposed PTRC scheme, the BS has a role to feedback
explicit radio related information to the proxy by using TCP
ACK packet. To do this, it requires the modiﬁcation of current
BS in LTE networks. This is an reasonable modiﬁcation
because many efforts for providing radio related information
from the BS have been considered in standardization sector
[13] and will be realized in near future by utilizing the network
function virtualization (NFV) concept [14]. We consider that
the BS has the average data rate of radio link R(t) for an
intended user at arbitrary time t. Based on R(t), we provide a
target queue length (Qtarget ), which can be used as feedback
information for the proxy’s rate control by representing a
desired queue length at the BS. Speciﬁcally, in addition to
R(t), the Qtarget is dynamically calculated by referring to
backhaul delay DBH and appropriate queueing delay at the
BS DBS . Thus, for the n-th updating period at arbitrary time

3
BS queue QL(t) Qtarget(n)

Ⱦ = Qtarget(n)-QL(t) >0G

R(t)

Proxy

•

Linear Growth Phase

W(i)

W(i)=W(i-1)+ȻȒ ȟ

(a) Linear growth phase
BS queue Qtarget(n) QL(t)

Ⱦ = Qtarget(n)-QL(t) <0

R(t)

Proxy Exponential

W(i)

Reduction Phase

W(i)=W(i-1)Ȓ (1-ȼ )

W (i) = W (i − 1) + α · δ,

(b) Exponential reduction phase
Fig. 2.

Proposed proxy operation.
•

t, Qtarget is updated by
Qtarget (n)=(1−k)·Qtarget (n−1)+k·(DBH +DBS )·R(t),

Linear growth phase (δ > 0): as shown in Fig. 2(a), our
proposed scheme understands that there is still room to
increase TCP’s sending rate to reach Qtarget . Thus, the
proxy boosts up its sending rate by increasing W . For
the i-th updating period, W is updated by

(1)

where, k is a constant smoothing factor between 0 and 1.
In (1), we update the Qtarget by using moving average
method in order to smooth out short-term ﬂuctuations of
Qtarget . Note that our design goal is to boost up TCP’s
transmission rates in the initial phase, and keep instant queue
length at the BS close to the Qtarget for reducing video startup
delay from efﬁcient use of radio resources. Thus, the BS
calculates the difference between the Qtarget (n) and instant
queue length QL(t) at t, which is denoted by δ, whenever
the BS captures the TCP ACK packet. Accordingly, the BS
feedbacks δ to the proxy by piggybacking into the TCP ACK
packet. After that, the proxy can refer to this information to
adjust its sending rate. For such an in-band signaling, we
utilize TCP option ﬁeld in TCP ACK header (4bytes), thus
implying that our PTRC scheme does not require any extra
signaling overhead. This approach is very effective, compared
to UDP-based signaling as used in e.g., [7]. We can reduce
90.5% signaling over UDP-based method from the overhead
calculation used in [15] (to deliver the same feedback, ours
only requires 4 bytes, while UDP-based one requires 42 bytes
due to minimum payload for feedback information 4 bytes
+ LTE header 10bytes + IP header 20bytes + UDP header
8bytes).

where, α is a weight factor to represent aggressiveness
of increment between 0 and 1.
Exponential reduction phase (δ ≤ 0): as shown in Fig.
2(b), our proposed scheme understands that current buffer
length at the BS exceeds the Qtarget so the proxy needs
to slow down its sending rate to keep the buffer length
at Qtarget by reducing W . For the i-th updating period,
W is updated by
W (i) = W (i − 1) · (1 − β),

(3)

where, β is a constant for exponential reduction phase.
C. Implementation of proposed PTRC scheme
We implement our proposed PTRC scheme on NS-3 simulator in LTE environment. The overall procedure of the proposed
scheme and its implementation part are illustrated in Fig. 3.
Basically, TCP setup procedure follows normal TCP operation.
1) Calculation and delivery of feedback information and 2)
proxy’s sending rate control are newly implemented in NS-3
simulator. We make the following changes in NS-3 to support
our proposed scheme:
•

•

B. Proposed Proxy Operation
The proxy in our proposed scheme has a role to control
its sending rate instead of the origin server by adjusting
the TCP congestion window size W based on δ received
from the BS. Note that the sending rate of TCP can be
approximated by congestion window size and round trip time
(RTT). Basically, our proposed TCP rate control design uses a
modiﬁed version of Additive-Increase-Multiplicative-Decrease
(AIMD) algorithm so that we can guarantee the convergence of
our algorithm. Also it is easy to implement from conventional
TCP algorithms in practice.
The proposed proxy operation is divided by two different
phases according to the value of δ acquired from the BS. If
δ represents a positive value, the congestion window control
enters a linear growth phase, otherwise, it enters an exponential
reduction phase otherwise as depicted in Fig. 2. Details of both
phases are explained as follows:

(2)

•

For 1), NS-3, by default, medium access control (MAC)
scheduler calculates the R(t) periodically in pf-ff-macscheduler ﬁle. Thus, by extracting this R(t) from scheduler, we implement calculation function for δ in lteenb-mac ﬁle where current queue level (QL(t)) can be
extracted from radio link control (RLC) buffer status
information, and the Qtarget can be calculated by using
(1).
We also implement piggybacking mechanism into a BS
to deliver the δ to the proxy in lte-enb-mac ﬁle whenever
the BS captures the TCP ACK packet.
For 2), we modify the conventional TCP window control
mechanism at the proxy by using (2) and (3). To do this,
we implement δ extraction procedure from TCP ACK
packet in tcp-socket-base ﬁle. Accordingly, the proxy
updates its congestion window size by referring to this
feedback information δ.
III. P ERFORMANCE E VALUATION

In this section, we provide a performance evaluation of
startup delay for video streaming in LTE environment. We
compare our proposed PTRC scheme with two prevalent TCP
congestion control schemes such as CUBIC and NewReno
[11], [16] because 3.31%-14.47% of web servers and 46.92%
of web servers use NewReno (or Reno) and CUBIC (or BIC),
respectively [17].

4

User
Device

Proxy

BS
After TCP setup, TCP
data transfer

Implementation of New Function
TCP ACK

1) Ƈ Calculation
2) piggybacking into TCP ACK

TCP ACK
with feedback info

Implementation of New Function
TCP data

1) Ƈ extraction from TCP ACK
2) TCP sending rate control
Fig. 3.

Overall procedure and implementation part of proposed scheme.

For extensive simulations, we utilize the NS-3 source code
of TCP NewReno and LTE model which are already implemented in NS-3 simulator (version 3.21), and TCP CUBIC
brought from [18]. Detailed explanation of simulation environment with its parameters and results are covered at following
sections.

A. Simulation Environment and Parameters

TABLE II
S IMULATION PARAMETERS
Simulation Parameters

Value

Downlink Bandwidth

20 MHz

MAC Scheduler Type

Proportional Fair Scheduler

Channel Model
BS’s Queue Size

4 Mbytes

TCP receiving buffer size

2 Mbytes

Segment Size (SS)

For simulation, we conﬁgure the wired link between the
BS and the proxy with a high bandwidth (100 Gbps), a
desired queueing delay at BS DBS (40 ms) and a constant
backhaul delay DBH (10, 50 ms) [19]. And, Qtarget and
W are initialized as 0 and 10, respectively. Regarding LTE
conﬁguration, downlink bandwidth of the BS is 20 MHz, and
MAC scheduler type is a proportional fair scheduler, which
is a default scheduler in NS-3. BS’s maximum queue size
is conﬁgured as 4 Mbytes. Furthermore, we set the channel
model as log distance propagation loss model [20]. In the
sense of TCP conﬁguration, TCP’s receiving buffer size is
2 Mbytes, which represents the upper-bound of congestion
window size, and TCP segment size (SS) is 1400 bytes. In
our environment, we set the slow start threshold (ssthresh) to
100 x SS as NS-3 default value, which is a safe value without
incurring TCP packet loss in slow start phase (The bandwidthdelay product (BDP) is 134 SS, since max bandwidth is 75
Mbps and minimum one-way delay between proxy and user
is 20 ms). Regarding the video streaming, we consider a static
user requests the full high deﬁnition (FHD) video streaming
with 16 Mbits chunk size from origin server [21]. Here, since
the user can playback after downloading at least one chunk
ﬁle, the startup delay of video streaming is the download time
of 16 Mbits chunk ﬁle. Detailed parameters are summarized
in Table II.

Log Distance Propagation Loss Model

1400 Bytes

Slow start Threshold (ssthresh)

100 x SS

Downlink Bandwidth

20 MHz

Chunk Size

16 Mbits

α

1

β

0.02

DBS

40 ms

DBH

10, 50 ms

k

0.001

B. Simulation Results
Fig. 4 illustrates the instantaneous throughput while downloading 16 Mbits chunk ﬁle for video streaming. We observe that the proposed scheme achieves maximum throughput
within almost 0.2 sec and complete the download at 0.34
sec. On the other hand, conventional TCP schemes take more
than 1 sec due to their slow start mechanism. Therefore,
from this start-up performance improvement by using feedback
information, the proposed scheme can achieve almost 71.2%
reduction of the video startup delay compared to TCP CUBIC.
In Fig. 5, we change the value of the backhaul delay
(DBH ) and check its impacts on the video startup delay.
As DBH increases, the startup delay of other TCP schemes

5

Inst. Throughput (Mb/s)

70

Proposed PTRC
TCP NewReno
TCP CUBIC

60
50
40
30
20
10
0
0

0.5

1

Time (s)

1.5

2

Fig. 4. Instantaneous throughput comparison for downloading an initial
chunk (DBH =10ms).

Fig. 6. Startup delay cmparison with respect to different available bandwidth
(DBH =10ms).

about 8 sec and 4 sec. Interestingly, as shown in Fig. 7(a), our
proposed scheme only takes about 1.5 sec. It means that we
can achieve almost 62.5 % reduction of video startup delay.
The reason is that our proposed scheme controls its sending
rate in order to keep instant queue length at the BS close
to the Qtarget , which requires short queueing delay. Thus,
background TCP trafﬁc using proposed scheme does not result
in “bufferbloat”problem.
C. Further Discussions

Fig. 5. Startup delay comparison with respect to different backhual delay
(DBH =10ms, 50ms).

signiﬁcantly increases such that at 50 ms DBH , both TCP
NewReno and TCP CUBIC take almost 4 sec to download
initial chunk ﬁle while our proposed scheme completes the
download within 1 sec. This is because slow start mechanism
performance become worse when TCP ACK response time
is getting longer due to large DBH . We also check that as
the available bandwidth at the BS increases, high performance
gain can be achieved as shown in Fig. 6. This is due to fact
that the proposed scheme can utilize full radio resources by
referring to the feedback information from the BS other than
conventional TCP schemes experience slow start phase. From
this result, we can expect that the proposed scheme can achieve
more gains at future 5G networks which has almost giga bps
data rate.
Finally, in Fig. 7, we demonstrate the performance of instantaneous throughput when there is background TCP trafﬁc in order to check startup delay. After slow start phase, conventional
schemes keep increasing its sending rate unless there is packet
loss so that they result in large queueing delay at the BS,
which called “bufferbloat”. Thus, when there is background
TCP trafﬁc which already occupies BS’s buffer with large
sending rate, video startup delay can extremely increase due to
its impact. For evaluation in background TCP environment, we
generate the background TCP trafﬁc at second 1 and request
video streaming at second 30, respectively. As shown in Fig.
7(b) and (c), TCP CUBIC and TCP NewReno almost takes

As we mentioned in the previous section, we assumed that
the proposed proxy is deployed in a nearby origin server.
Thus, the download time from the origin server to the proxy is
considered negligible. In reality, if a service provider does not
have its own content server in LTE networks, the download
time from origin server to the proposed proxy might become a
bottleneck point in reducing startup delay of a video streaming.
Since control of sending rate in T CPS<−>P is out of scope of
this study, we suggest its impact on the overall performance as
further discussions. To do this, we provide simple experiment
to evaluate startup delay when there is 20 ms delay between
the proxy and the origin server. In this evaluation, the startup
delay of proposed PTRC scheme and TCP CUBIC is 2.9 sec
and 7.7 sec, respectively. Thus, based on our initial ﬁndings,
startup delay of both schemes increases due to impact of
additional delay between the proxy and the origin server.
Nevertheless, we can conjecture the proposed PTRC scheme
still outperforms conventional TCP scheme. The reason to
achieve this gain is that our proposed PTRC scheme can still
boost up its sending rate in T CPU <−>P even though we
follow conventional TCP sending rate control in T CPS<−>P .
Moreover, even though we provide the result of 16 Mbits
chunk ﬁle for video streaming, we also conducted same
simulation for different chunk size such as 500 Kbits, 2
Mbits, 4 Mbits and 8 Mbits. From the simulation for different
chunk size, we also check that proposed scheme outperforms
conventional TCP variants with almost 50-70% startup delay
reduction.
IV. C ONCLUSION
In this paper, we proposed the proxy-based TCP rate control
scheme. In the proposed scheme, we introduce a target queue

6

60

40

20

0
25

PTRC−Flow1
PTRC−Flow2
30

Time (s)

35

(a) Proposed PTRC
Fig. 7.

40

80

60
TCP CUBIC−Flow1
TCP CUBIC−Flow2

40

20

0
25

30

Time (s)

35

(b) TCP CUBIC

40

Inst.Throughput (Mb/s)

80
Inst. Throughput (Mb/s)

Inst. Throughput (Mb/s)

80

60

40

TCP NewReno−Flow1
TCP NewReno−Flow2

20

0
25

30

Time (s)

35

40

(c) TCP NewReno

Instantaneous throughput comparison when there is background TCP trafﬁc (DBH =10ms).

length (Qtarget ) as feedback information, which represent a
desired queue length at the BS. The Qtarget is dynamically
calculated by referring to average data rate of a radio link
and backhaul delay as well as desired queueing delay at the
BS. By using in-band signaling, the Qtarget can be delivered
to the proxy, so the proxy controls its sending rate based on
this Qtarget . Simulation results using NS-3 have veriﬁed that
our proposed scheme achieves almost 71.2% reduced startup
delay of video streaming in LTE environment compared to
conventional TCP variants.
R EFERENCES
[1] T. C. Thang, H. T. Le, A. T. Pham and Y. M. Ro, “An Evaluation of
Bitrate Adaptation Methods for HTTP Live Streaming,” IEEE J. Sel.
Areas Commun., vol. 31, no. 4, pp. 693–705, Apr. 2014.
[2] S. S. Krishnan and R. K. Sitaraman, “Video Stream Quality Impacts
Viewer Behavior: Inferring Causality Using Quasi-Experimental Designs,” IEEE/ACM Trans. Netw., vol. 21, no. 6, pp. 2001–2014, Dec.
2013.
[3] S. Akhshabi, A. C. Begen and C. Dovrolis, “An Experimental Evaluation
of Rate-Adaptation Algorithms in Adaptive Streaming over HTTP,” ACM
MMSys ’11, pp. 157–168, Feb. 2011.
[4] T. Y. Huang, N. Handigol, B. Heller, N. Mackeown and R. Johari,
“Confused, timid, and unstable: picking a video streaming rate is hard,”
ACM IMC ’12, pp. 225–238 , Nov. 2012.
[5] T. Y. Huang, R. Johari, N. Mackeown, M. Trunnell and M. Watson, “A
buffer-based approach to rate adaptation: evidence from a large video
streaming service,” ACM SIGCOMM ’14, pp. 187–198 , Aug. 2014.
[6] J. Dilley, B. M. Maggs, J. Parikh, H. Prokop, R. K. Sitaraman and W. E.
Weihl, “Globally distributed content delivery,” IEEE Internet Comput.,
pp. 50–58, Sep./Oct. 2002.
[7] N. Moller, I. C. Molero, K. H. Johansson, J. Petersson, R. Skog
and A. Arvidsson, “Using Radio Network Feedback to Improve TCP
Performance over Cellular Networks,” IEEE Conference on Decision
and Control, and the European Control Conference ’05, 2005.
[8] H. Jiang, Y. Wang, K. Lee and I. Rhee, “Tackling Bufferbloat in 3G/4G
Networks,” ACM IMC ’12, pp. 329–342, Nov. 2012.
[9] M. Massaro, C. E. Palazzi and A. Bujari, “Exploiting TCP Vegas’ Algorithm to Improve Real-Time Multimedia Applications,” IEEE Consumer
Communications and Networking Conference (CCNC) ’15, pp. 316–321,
Jan. 2015.
[10] I. C. Molero, N. Mller, J. Petersson, R. Skog, A. Arvidsson, O. Flardh
and K. H. Johansson, “Cross-Layer Adaptation for TCP-Based Applications in WCDMA Systems,” IST Mobile and Wireless Communication
Summit ’05, 2005.
[11] S. Ha, I. Rhee and L. Xu, “Cubic: a new tcp-friendly high-speed tcp
variant,” ACM SIGOPS OS Rev., vol. 42, no. 5, pp. 64–74, Jul. 2008.
[12] V. Farkas, B. Heder, and S. Novaczki, ‘’A Split Connection TCP Proxy
in LTE Networks,” Springer EUNICE, vol. 7479, pp. 263–274, Aug.
2012.

[13] A. Jain, A. Terzis, H. Flinck, N. Sprecher, S. Arunachalam and K. Smith,
“Mobile Throughput Guidance Inband Signaling Protocol draft-ﬂinckmobile-throughput-guidance-03,” Sep. 2015, IETF Active Internet-Draft.
[14] R. Mijumbi, J. Serrat, J. L. Gorricho, N. Bouten, F. D. Turck and
R. Boutaba, “Network Function Virtualization : State-of-the-art and
Research Challenges,” IEEE Commun. Surveys Tuts., accepted for publication, 2015.
[15] A. Larmo, M. Lindstrm, M. Meyer, G. Pelletier, J. Torsner and H. Wiemann, “The LTE Link-Layer Design,” IEEE Commun. Mag., vol. 47,
no. 4, pp. 52–59, Apr. 2009.
[16] T. Henderson, S. Floyd, A. Gurtov and Y. Nishida, “The newreno
modiﬁcation to tcp’s fast recovery algorithm,” April 2012, RFC 6582.
[17] P. Yang, J. Shao, W. Luo, J. Deogun and Y. Lu, “TCP Congestion
Avoidance Algorithm Identiﬁcation,” IEEE/ACM Trans. Netw., vol. 22,
no. 4, pp. 1311–1324, Aug. 2014.
[18] “TCP CUBIC,”http://perform.wpi.edu/downloads/cubic.
[19] Why Latency Matters to Mobile Backhaul, O3b Networks and Sofrecom.
[20] “Ns-3 simulator,” http://www.nsnam.org.
[21] “SKT-BTV,” http://www.netmanias.com/en/?m=view&id=blog&no=6014.

TLP 12 (4–5): 719–735, 2012.

C Cambridge University Press 2012


719

doi:10.1017/S1471068412000269

Module theorem for the general
theory of stable models
JOSEPH BABB and JOOHYUNG LEE
School of Computing, Informatics, and Decision Systems Engineering,
Arizona State University, Tempe, AZ, USA
(e-mail: {Joseph.Babb, joolee}@asu.edu)

Abstract
The module theorem by Janhunen et al. demonstrates how to provide a modular structure
in answer set programming, where each module has a well-deﬁned input/output interface
which can be used to establish the compositionality of answer sets. The theorem is useful in
the analysis of answer set programs, and is a basis of incremental grounding and reactive
answer set programming. We extend the module theorem to the general theory of stable
models by Ferraris et al. The generalization applies to non-ground logic programs allowing
useful constructs in answer set programming, such as choice rules, the count aggregate, and
nested expressions. Our extension is based on relating the module theorem to the symmetric
splitting theorem by Ferraris et al. Based on this result, we reformulate and extend the theory
of incremental answer set computation to a more general class of programs.
KEYWORDS: answer set programming, module theorem, splitting theorem

1 Introduction
The module theorem (Oikarinen and Janhunen 2008; Janhunen et al. 2009) demonstrates how to provide a modular structure for logic programs under the stable model
semantics, where each module has a well-deﬁned input/output interface which can
be used to establish the compositionality of answer sets of diﬀerent modules. The
theorem was shown to be useful in the analysis of answer set programs and was
used as a basis of incremental grounding (Gebser et al. 2008) and reactive answer
set programming (Gebser et al. 2011), resulting in systems iclingo and oclingo.
The module theorem was stated for normal logic programs and smodels programs
in (Oikarinen and Janhunen 2008) and for disjunctive logic programs in (Janhunen
et al. 2009), but both papers considered ground programs only. In this paper we
extend the module theorem to non-ground programs, or more generally, to ﬁrst-order
formulas under the stable model semantics proposed by Ferraris et al. (2011). We
derive the generalization by relating the module theorem to the symmetric splitting
theorem by Ferraris et al. (2009). This is expected in some sense as the symmetric
splitting theorem looks close to the module theorem and is already applicable to
ﬁrst-order formulas under the stable model semantics (Ferraris et al. 2011). Since
non-ground logic programs can be understood as a special class of ﬁrst-order

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

720

J. Babb and J. Lee

formulas under the stable model semantics, the theorem can be applied to split these
programs. In addition, as the semantics of choice rules and the count aggregate in
answer set programming is understood as shorthand for some ﬁrst-order formulas
(Lee et al. 2008), the splitting theorem can also be applied to non-ground programs
containing such constructs.
The precise relationship between the module theorem and the splitting theorem
has not been established, partly because there is some technical gap that needs to be
closed. While the splitting theorem is applicable to more general classes of programs
in most cases, there are some cases where the module theorem allows us to split, but
the splitting theorem does not.
In order to handle this issue, we ﬁrst extend the splitting theorem to allow this
kind of generality. We then add modular structures to the splitting theorem, and
provide a mechanism of composing partial interpretations for each module. This
new theorem serves as the module theorem for the general theory of stable models.
The paper is organized as follows. In the next section, we review the stable model
semantics from (Ferraris et al. 2011), the splitting theorem, and the module theorem.
In Section 3 we provide a generalization of the splitting theorem, which closes the
gap between the module theorem and the splitting theorem. In Section 4 we present
the module theorem for the general theory of stable models, which extends both the
previous splitting theorem and the previous module theorem. We give an example of
the generalized module theorem in Section 5 and show how it serves as a foundation
for extending the theory of incremental answer set computation in Section 6.

2 Preliminaries
2.1 Review: general theory of stable models
This review follows the deﬁnition by Ferraris et al. (2011). There, stable models are
deﬁned in terms of the SM operator, which is similar to the circumscription operator
CIRC (Lifschitz 1994).
Let p be a list of distinct predicate constants p1 , . . . , pn , and let u be a list of
distinct predicate variables u1 , . . . , un . By u 6 p we denote the conjunction of the
formulas ∀x(ui (x) → pi (x)) for all i = 1, . . . , n, where x is a list of distinct object
variables whose length is the same as the arity of pi . Expression u < p stands
for (u 6 p) ∧ ¬(p 6 u). For instance, if p and q are unary predicate constants then
(u, v) < (p, q) is
∀x(u(x) → p(x)) ∧ ∀x(v(x) → q(x)) ∧ ¬(∀x(p(x) → u(x)) ∧ ∀x(q(x) → v(x))).
For any ﬁrst-order formula F, SM[F; p] is deﬁned as
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where F ∗ (u) is deﬁned recursively as follows:1

1

We understand ¬F as shorthand for F → ⊥.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Module theorem for the general theory of stable models

721

• pi (t)∗ = ui (t) for any list t of terms;
• F ∗ = F for any atomic formula F (including ⊥ and equality) that does not
contain members of p;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF)∗ = ∀xF ∗ ;
• (∃xF)∗ = ∃xF ∗ .
When F is a sentence, the models of SM[F; p] are called the p-stable models of F.
Intuitively, they are the models of F that are “stable” on p. We will often simply write
SM[F] in place of SM[F; p] when p is the list of all predicate constants occurring
in F, and often identify p with the corresponding set if there is no confusion.
By an answer set of F that contains at least one object constant we understand
an Herbrand interpretation of σ(F) that satisﬁes SM[F], where σ(F) is the signature
consisting of the object, function and predicate constants occurring in F.
The answer sets of a logic program Π are deﬁned as the answer sets of the FOLrepresentation of Π (i.e., the conjunction of the universal closures of implications
corresponding to the rules). For example, the FOL-representation F of the program
p(a)
q(b)
r(x) ← p(x), not q(x)
is
p(a) ∧ q(b) ∧ ∀x(p(x) ∧ ¬q(x) → r(x))

(1)

and SM[F] is
p(a) ∧ q(b) ∧ ∀x(p(x) ∧ ¬q(x) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x((u(x) ∧ (¬v(x) ∧ ¬q(x)) → w(x)) ∧ (p(x) ∧ ¬q(x) → r(x)))),
which is equivalent to the ﬁrst-order sentence
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b) ∧ ∀x(r(x) ↔ (p(x) ∧ ¬q(x)))

(2)

(Ferraris et al. 2007, Example 3). The stable models of F are any ﬁrst-order models
of (2). The only answer set of F is the Herbrand model {p(a), q(b), r(a)}.
Ferraris et al. (2011) show that this deﬁnition of an answer set, when applied to
the syntax of logic programs, is equivalent to the traditional deﬁnition of an answer
set that is based on grounding and ﬁxpoints (Gelfond and Lifschitz 1988).
2.2 Review: symmetric splitting theorem
We say that an occurrence of a predicate constant, or any other subexpression, in
a formula F is positive if the number of implications containing that occurrence in
the antecedent is even (recall that we treat ¬G as shorthand for G → ⊥). We say
that the occurrence is strictly positive if the number of implications in F containing

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

722

J. Babb and J. Lee

that occurrence in the antecedent is 0. For example, in (1), both occurrences of q
are positive, but only the ﬁrst one is strictly positive. A rule of F is an implication
that occurs strictly positively in F.
A formula F is called negative on a list p of predicate constants if members of p
have no strictly positive occurrences in F. For example, formula (1) is negative on
{s}, but is not negative on {p, q}. A formula of the form ¬F (shorthand for F → ⊥)
is negative on any list of predicate constants.
The following deﬁnition of a dependency graph is from (Lee and Palla 2012),
which is similar to the one from (Ferraris et al. 2009), but may contain less edges.
Deﬁnition 1 (Predicate Dependency Graph)
The predicate dependency graph of a ﬁrst-order formula F relative to p, denoted by
DG[F; p], is the directed graph that
• has all members of p as its vertices, and
• has an edge from p to q if, for some rule G → H of F,
— p has a strictly positive occurrence in H, and
— q has a positive occurrence in G that does not belong to any subformula
of G that is negative on p.
For example, DG[(1); p, q, r] has the vertices p, q, and r, and a single edge from r
to p.
Theorem 1 (Splitting Theorem, (Ferraris et al. 2009))
Let F, G be ﬁrst-order sentences, and let p, q be ﬁnite disjoint lists of distinct
predicate constants. If
(a) each strongly connected component of the predicate dependency graph of
F ∧ G relative to p, q is a subset of p or a subset of q,
(b) F is negative on q, and
(c) G is negative on p
then
SM[F ∧ G; pq] ↔ SM[F; p] ∧ SM[G; q]
is logically valid.
Theorem 1 is slightly more generally applicable than the version of the splitting
theorem from (Ferraris et al. 2009) as it refers to the reﬁned deﬁnition of a
dependency graph above instead of the one considered in (Ferraris et al. 2009).
Example 1
Theorem 1 tells us that SM[(1)] is equivalent to
SM[p(a) ∧ q(b); p, q] ∧ SM[∀x(p(x) ∧ ¬q(x) → r(x)); r].

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Module theorem for the general theory of stable models

723

2.3 Review: DLP-Modules and module theorem
Janhunen et al. (2009) considered rules of the form
a1 ; . . . ; an ← b1 , . . . , bm , not c1 , . . . , not ck

(3)

where n, m, k > 0 and a1 , . . . , an , b1 , . . . bm , c1 , . . . , ck are propositional atoms. They
deﬁne a DLP-module as a quadruple (Π, I, O, H), where Π is a ﬁnite propositional
disjunctive logic program consisting of rules of the form (3), and I, O, and H are
ﬁnite sets of propositional atoms denoting the input, output, and hidden atoms,
respectively, such that (i) the sets of input, output, and hidden atoms are disjoint;
(ii) every atom occurring in Π is either an input, output, or hidden atom; (iii) every
rule in Π with a nonempty head contains at least one output or hidden atom.
A module’s hidden atoms can be viewed as a special case of its output atoms
which occur in no other modules. For simplicity, we consider only DLP-modules
with no hidden atoms (H = ∅), which we denote by a triple (Π, I, O).
Deﬁnition 2 (Module Answer Set, (Janhunen et al. 2009))
We say that a set X of atoms is a (module) answer set of a DLP-module (Π, I, O)
if X is an answer set of Π ∪ {p | p ∈ (I ∩ X)}.
The role of input atoms can be simulated using choice rules. A choice rule
{p} ← Body is understood as shorthand for p; not p ← Body (Lee et al. 2008). The
following lemma shows how module answer sets can be alternatively characterized
in terms of choice rules.
Lemma 1
X is a module answer set of (Π, I, O) iﬀ X is an answer set of Π ∪ {{p} ← | p ∈ I}.
Deﬁnition 3 (Dependency Graph of a DLP-Module)
The dependency graph of a DLP-module Π = (Π, I, O), denoted by DG[Π; O], is
the directed graph that
• has all members of O as its vertices, and
• has edges from each ai (1 6 i 6 n) to each bj (1 6 j 6 m) for each rule (3)
in Π.
It is clear that this deﬁnition is a special case of Deﬁnition 1.
Deﬁnition 4 (Joinability of DLP-modules)
Two DLP-modules Π1 = (Π1 , I1 , O1 ) and Π2 = (Π2 , I2 , O2 ) are called joinable if
• O1 ∩ O2 = ∅,
• each strongly connected component of DG[Π1 ∪ Π2 ; O1 O2 ] is either a subset
of O1 or a subset of O2 ,
• each rule in Π1 (Π2 , respectively) whose head is not disjoint with O2 (O1 ,
respectively) occurs in Π2 (Π1 , respectively).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

724

J. Babb and J. Lee

Deﬁnition 5 (Join of DLP-modules)
For any modules Π1 = (Π1 , I1 , O1 ) and Π2 = (Π2 , I2 , O2 ) that are joinable, the join
of Π1 and Π2 , denoted by Π1  Π2 , is deﬁned to be the DLP-module
(Π1 ∪ Π2 , (I1 ∪ I2 ) \ (O1 ∪ O2 ), O1 ∪ O2 ) .

Informally, the join of two DLP-modules corresponds to the union of their
programs, and deﬁnes all atoms that are deﬁned by either module.
Given sets of atoms X1 , X2 , and A, we say that X1 and X2 are A-compatible
if X1 ∩ A = X2 ∩ A. As demonstrated by Janhunen et al. (2009), given a program
composed of a series of joinable DLP-modules, it is possible to consider each DLPmodule contained in a program separately, evaluate them, and compose the resulting
compatible answer sets in order to obtain the answer sets of the complete program.
This notion is presented in Theorem 2, which is a reformulation of the main theorem
(Theorem 5.7) from (Janhunen et al. 2009).
Theorem 2 (Module Theorem for DLPs)
Let Π1 = (Π1 , I1 , O1 ) and Π2 = (Π2 , I2 , O2 ) be DLP-modules that are joinable, and
let X1 and X2 be ((I1 ∪ O1 ) ∩ (I2 ∪ O2 ))-compatible sets of atoms. The set X1 ∪ X2
is a module answer set of Π1  Π2 iﬀ X1 is a module answer set of Π1 and X2 is a
module answer set of Π2 .

3 A Generalization of the Splitting Theorem by Ferraris et al.
The module theorem (Theorem 2) and the splitting theorem (Theorem 1) resemble
each other. When we restrict attention to propositional logic program F, the
intensional predicates p in SM[F; p] correspond to output atoms in the corresponding
module. Though not explicit in the notation SM[F; p], the predicates that are not
in p behave like input atoms in the corresponding module. Also, the joinability
condition in Deﬁnition 4 appears similar to the splitting condition in Theorem 1,
but with one exception: the last clause in the deﬁnition of joinability (Deﬁnition 4)
does not have a counterpart in the splitting theorem. The module theorem allows
us to join two DLP-modules Π1 = (Π1 , I1 , O1 ) and Π2 = (Π2 , I2 , O2 ) even when
Π1 has a rule whose head contains an output atom in O2 as long as that rule is also
in Π2 .
Indeed, this diﬀerence yields the splitting theorem less generally applicable than
the module theorem in some cases. For example, the module theorem (Theorem 2)
allows us to join
Π1

=

({p ∨ q ← r. s ← .}, {q, r}, {p, s}) and

Π2

=

({p ∨ q ← r. t ← .}, {p, r}, {q, t})

(4)

into
Π = ({p ∨ q ← r. s ← . t ← .}, {r}, {p, q, s, t}).

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Module theorem for the general theory of stable models

725

On the other hand, the splitting theorem (Theorem 1), as presented in Section 2.2,
is not as general in this regard. It does not allow us to justify that
SM[(r → p ∨ q) ∧ s; p, s] ∧ SM[(r → p ∨ q) ∧ t; q, t]

(5)

SM[(r → p ∨ q) ∧ s ∧ t; p, q, s, t].

(6)

is equivalent to
because, for instance, r → p ∨ q in the ﬁrst conjunctive term of (5) is not negative
on {q, t}.
In order to close the gap, we next extend the splitting theorem to allow a partial
split, which allows an overlapping sentence, such as r → p ∨ q in the above example,
in both component formulas.
Theorem 3 (Extension of the Splitting Theorem)
Let F, G, H be ﬁrst-order sentences, and let p, q be ﬁnite lists of distinct predicate
constants. If
(a) each strongly connected component of DG[F ∧ G ∧ H; pq] is a subset of p or
a subset of q,
(b) F is negative on q, and
(c) G is negative on p
then
SM[F ∧ G ∧ H; pq] ↔ SM[F ∧ H; p] ∧ SM[G ∧ H; q]
is logically valid.
It is clear that Theorem 1 is a special case of Theorem 3 (take H to be ). Unlike
in (Ferraris et al. 2009) we do not require p and q to be disjoint from each other.
Getting back to the example above, according to the extended splitting theorem,
(6) is equivalent to (5) (Take H to be r → p ∨ q).

4 Module theorem for general theory of stable models
4.1 Statement of the theorem
In this section, we present a new formulation of the module theorem that is applicable
to ﬁrst-order formulas under the stable model semantics.
As a step towards this end, we ﬁrst deﬁne the notion of a partial interpretation.
Given a signature σ and its subset c, by a c-partial interpretation of σ, we mean an
interpretation of σ restricted to c. Clearly, a σ-partial interpretation of σ is simply
an interpretation of σ. By an Herbrand c-partial interpretation of σ, we mean an
Herbrand interpretation of σ restricted to c.
We say that a c1 -partial interpretation I1 and a c2 -partial interpretation I2 of the
same signature σ are compatible if their universes are the same, and cI1 = cI2 for
every common constant c in c1 ∩ c2 . For such compatible partial interpretations I1
and I2 , we deﬁne the union of I1 and I2 , denoted by I1 ∪ I2 , to be the (c1 ∪ c2 )-partial

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

726

J. Babb and J. Lee

interpretation of σ such that (i) |I1 ∪ I2 | = |I1 | = |I2 |,2 (ii) cI1 ∪I2 = cI1 for every
constant c in c1 , and (iii) cI1 ∪I2 = cI2 for every constant c in c2 .
Next we introduce a ﬁrst-order analog to DLP-modules, which we refer to as
ﬁrst-order modules, and deﬁne a method of composing multiple such constructs
similar to the join operation for DLP-modules. By pr(F) we denote the set of all
predicate constants occurring in F. A (ﬁrst-order) module F of a signature σ is a
triple (F, I, O), where F is a ﬁrst-order sentence of σ, and I and O are disjoint lists
of distinct predicate constants of σ such that pr(F) ⊆ (I ∪ O). Intuitively, I and
O denote, respectively, the sets of non-intensional (input) and intensional (output)
predicates considered by F.
Deﬁnition 6 (Module Stable Model )
We say that an interpretation I is a (module) stable model of a module F = (F, I, O)
if I |= SM[F; O]. We understand SM[F] as shorthand for SM[F; O].
Deﬁnition 7 (Joinability of First-Order Modules)
Two ﬁrst-order modules F1 = (F1 ∧ H, I1 , O1 ) and F2 = (F2 ∧ H, I2 , O2 ) are
called joinable if
• O1 ∩ O2 = ∅,
• each strongly connected component of DG[F1 ∧ F2 ∧ H; O1 ∪ O2 ] is either a
subset of O1 or a subset of O2 ,
• F1 is negative on O2 , and
• F2 is negative on O1 .
Deﬁnition 8 (Join of First-Order modules)
For any modules F1 = (F1 ∧ H, I1 , O1 ) and F2 = (F2 ∧ H, I2 , O2 ) that are joinable,
the join of F1 and F2 , denoted by F1  F2 , is deﬁned to be the ﬁrst-order module
(F1 ∧ F2 ∧ H, (I1 ∪ I2 ) \ (O1 ∪ O2 ), O1 ∪ O2 ) .
It is not diﬃcult to check that this deﬁnition is a proper generalization of
Deﬁnition 4.
As with DLP-modules, the join operation for ﬁrst-order modules is both commutative and associative.
Proposition 1 (Commutativity and Associativity of Join)
For any ﬁrst-order modules F1 , F2 , and F3 , the following properties hold:
•
•
•
•

F1  F2 is deﬁned iﬀ F2  F1 is deﬁned.
SM[F1  F2 ] is equivalent to SM[F2  F1 ].
(F1  F2 )  F3 is deﬁned iﬀ F1  (F2  F3 ) is deﬁned.
SM[(F1  F2 )  F3 ] is equivalent to SM[F1  (F2  F3 )].

The following theorem is an extension of Theorem 2 to the general theory of
stable models. Given a ﬁrst-order formula F, by c(F) we denote the set of all object,
function and predicate constants occurring in F.
2

|I| denotes the universe of the interpretation I.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Module theorem for the general theory of stable models



a?
?

?c
??

?? 
 	
b



727

5 e _?
 ???

?? 


/f
dj

Fig. 1. A simple graph.

Theorem 4 (Module Theorem for General Theory of Stable Models)
Let F1 = (F1 , I1 , O1 ) and F2 = (F2 , I2 , O2 ) be ﬁrst-order modules of a signature σ
that are joinable, and, for i = 1, 2, let ci be a subset of σ that contains c(Fi ) ∪ Oi ,
and let Ii be a ci -partial interpretation of σ. If I1 and I2 are compatible with each
other, then
I1 ∪ I2 |= SM[F1  F2 ]

iﬀ

I1 |= SM[F1 ] and I2 |= SM[F2 ].

It is clear that when σ = c1 = c2 , Theorem 4 reduces to Theorem 3.
Also, it is not diﬃcult to check that Theorem 4 reduces to Theorem 2 when F1
and F2 represent DLP-modules, c1 is I1 ∪ O1 , and c2 is I2 ∪ O2 .
5 Example: analyzing RASPL-1 programs using module theorem
As an example of Theorem 4, consider the problem of locating non-singleton cliques
within a graph, such as the one shown in Figure 1, that are reachable from a
pre-speciﬁed node. This problem can be divided into three essential parts: (i) ﬁxing
the graph, (ii) determining the reachable subgraph, and (iii) locating cliques within
that subgraph.
We can describe the graph shown in Figure 1 in the language of RASPL-1 (Lee
et al. 2008), which is essentially a fragment of the general theory of stable models in
logic programming syntax. We assume that σ is an underling signature. The program
below lists the vertices and the edges using predicates vertex and edge, and assigns
the starting vertex using at predicate.
vertex(a). vertex(b). vertex(c). vertex(d). vertex(e). vertex(f).
edge(a, a). edge(a, b). edge(b, c). edge(c, b). edge(c, c). edge(d, e).
edge(d, f). edge(e, d). edge(e, f). edge(f, d). edge(f, e). at(a).

(7)

The ﬁrst-order module FG is (FG , ∅, {vertex, edge, at}), where FG is the FOLrepresentation of program (7), which is the conjunction of all the atoms. Let IG be
the following Herbrand c(FG )-partial interpretation of σ that satisﬁes SM[FG ].
vertexIG = {a, b, c, d, e, f},
edgeIG = {(a, a), (a, b), (b, c), (c, b),
(c, c), (d, e), (d, f), (e, d), (e, f), (f, d), (f, e)}, and
at

IG

= {a}.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

728

J. Babb and J. Lee

The following program describes the reachable vertices by the predicate reachable,
which is deﬁned using edge and at.
reachable(X) ← at(X).
reachable(Y ) ← reachable(X), edge(X, Y ).

(8)

The ﬁrst-order module FR is (FR , {edge, at}, {reachable}), where FR is the FOLrepresentation of program (8). Let IR be the following Herbrand c(FR )-partial
interpretation of σ that satisﬁes SM[FG ], which is compatible with IG .
edgeIR = {(a, a), (a, b), (b, c), (c, b),
(c, c), (d, e), (d, f), (e, d), (e, f), (f, d), (f, e)},
IR

= {a}, and

IR

= {a, b, c}.

at
reachable

Finally, the following program describes non-singleton cliques reachable from
vertex a by in clique, which is deﬁned using edge and reachable:
{in clique(X)} ← reachable(X)
← in clique(X), in clique(Y ), not edge(X, Y ), X = Y
← not 2{X : in clique(X)}.

(9)

In RASPL-1, expression b{x : F(x)}, where b is a positive integer, x is a list
of object variables, and F(x) is a conjunction of literals, stands for the ﬁrst-order
formula
⎡
⎤


F(xi ) ∧
¬(xi = xj )⎦ ,
∃x1 . . . xb ⎣
16i6b
1

16i<j6b

b

where x , . . . , x are lists of new object variables of the same length as x. For any
lists of variables x = (x1 , . . . , xn ) and y = (y1 , . . . , yn ) of the same length, x = y stands
for x1 = y1 ∧ · · · ∧ xn = yn .
The ﬁrst-order module FC is (FC , {reachable, edge}, {in clique}), where FC is
the following FOL-representation of RASPL-1 program (9):
∀X(reachable(X) → (in clique(X) ∨ ¬in clique(X)))
∧ ∀XY (in clique(X) ∧ in clique(Y ) ∧ ¬edge(X, Y ) ∧ X = Y → ⊥)
∧ (¬∃XY (in clique(X) ∧ in clique(Y ) ∧ X = Y ) → ⊥) .
Let IC be the following Herbrand c(FC )-partial interpretation of σ that satisﬁes
SM[FC ], which is compatible with IG and IR .
edgeIC = {(a, a), (a, b), (b, c), (c, b),
(c, c), (d, e), (d, f), (e, d), (e, f), (f, d), (f, e)},
reachable

IC

= {a, b, c}, and

in clique

IC

= {b, c}.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Module theorem for the general theory of stable models

729

⎫
n←t
⎪
⎪



⎬
p ← q, t
n←t
→

, {l, t}, {n, p, q}
q ← r, not s ⎪
p ← q, t
I={l,t}
⎪
⎭
r←m
Fig. 2. DLP-module instantiation of a simple program.

Clearly, FG , FR , and FC are joinable. In accordance with Theorem 4, the union of
the partial interpretations IG ∪ IR ∪ IC is a partial interpretation of σ that satisﬁes
SM[FG  FR  FC ].

6 Modules that can be incrementally assembled
6.1 Review: incremental modularity by Gebser et al.
In this section, we present a reformulation of the theory behind the system iclingo,
which was developed to allow for incremental grounding and solving of answer
set programs. We follow the enhancement given in (Gebser et al. 2011) with a
slight deviation. Most notably, we do not restrict attention to nondisjunctive logic
programs, but limit attention to oﬄine programs for simplicity.
Given a disjunctive program Π of a signature σ, by Groundσ (Π) we denote the
ground program obtained from Π by replacing object variables with ground terms
in the Herbrand Universe of σ. If Π is ground, then the projection of Π onto a set
X of ground atoms, denoted by Π|X , is deﬁned to be the program obtained from Π
by removing all rules (3) in Π that contain some bi not in X, and then removing all
occurrences of not cj such that cj is not in X from the remaining rules. By head (Π)
we denote the set of all atoms that occur in the head of a rule in Π.
Deﬁnition 9 (DLP-Module Instantiation)
Given a disjunctive program Π, and a set of ground atoms I, Gebser et al. (2011)
deﬁne the DLP-module instantiation of Π w.r.t. I, denoted
by DM (Π, I), to be the

DLP-module (Groundσ (Π)|I∪O , I, O), where O is head Groundσ (Π)|I∪head (Groundσ (Π)) .
For example, Figure 2 shows a simple program and its DLP-module instantiation
w.r.t. {l, t}.
An incrementally parameterized program Π[t] is a program which may contain
atoms of the form af(t) (x), called incrementally parameterized atoms, where t is an
incremental step counter, and f(t) is some arithmetic function involving t. Given
such a program Π[t], its incremental instantiation at some nonnegative integer i,
which we denote by Π[i], is deﬁned to be the program obtained by replacing all
occurrences of atoms af(t) (x) with an atom av (x), where v is the result of evaluating
f(i). For example, let Π = {pt+1 (x) ← pt (x), not q(x)}. The program Π[2] is then
{p3 (x) ← p2 (x), not q(x)}.
Gebser et al. (2011) deﬁne an incremental logic program to be a triple B, P [t], Q[t],
where B is a disjunctive logic program, and P [t], Q[t] are incrementally parameterized disjunctive logic programs. Informally, B is the base program component,
which describes static knowledge; P [t] is the cumulative program component, which

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

730

J. Babb and J. Lee

contains information regarding every step t that should be accumulated during
execution; Q[t] is the volatile query program component, containing constraints or
information regarding the ﬁnal step.
We assume a partial order ≺ on
{Groundσ (B),Groundσ (P [1]), Groundσ (P [2]), . . . ,
Groundσ (Q[1]), Groundσ (Q[2]), . . . }

(10)

such that
• Groundσ (B) ≺ Groundσ (P [1]) ≺ Groundσ (P [2]) ≺ . . . ;
• Groundσ (P [i]) ≺ Groundσ (Q[i]) for i > 1.
Given a DLP-module P = (Π, I, O), by Out(P) we denote O.
Deﬁnition 10 (Modular and Acyclic Logic Programs)
An incremental logic program B, P [t], Q[t] is modular if the following DLP-modules
are deﬁned for every k > 0:
P0 = DM (B, ∅),
Pi = Pi−1  DM (P [i], Out(Pi−1 )),

(1 6 i 6 k)

Rk = Pk  DM (Q[k], Out(Pk )),
and is acyclic if, for each pair of programs Π, Π in (10) such that Π ≺ Π , we have
that Π contains no head atoms of Π . 3
Gebser et al. (2011) demonstrated that given a modular and acyclic incremental
logic program B, P [t], Q[t] and some nonnegative integer k, we are able to evaluate
each component DLP-module individually, and compose the results in order to
obtain the answer sets of the complete module Rk . They deﬁne the k-expansion Rk
of the incremental logic program as
B ∪ P [1] ∪ · · · ∪ P [k] ∪ Q[k].
Proposition 2
(Gebser et al. 2011, Proposition 2) Let B, P [t], Q[t] be an incremental logic
program of a signature σ that is modular and acyclic, let k be a nonnegative integer,
and let X be a subset of the output atoms of Rk . Set X is an answer set of the
k-expansion Rk of B, P [t], Q[t] if and only if X is a (module) answer set of Rk .
Proposition 2 tells us that the results of incrementally grounding and evaluating
an incremental logic program are identical to the results of evaluating the entire
k-expansion in the usual non-incremental fashion.

3

The acyclicity condition corresponds to the special case of the “mutually revisable” condition in (Gebser
et al. 2011) when there is no online component.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Module theorem for the general theory of stable models

731

6.2 Incrementally assembled ﬁrst-order modules
In this section, we consider an extension of the theory supporting system iclingo
which allows for the consideration of ﬁrst-order sentences by utilizing Theorem 4.
This extension may be useful in analyzing non-ground RASPL-1 programs that
describe dynamic domains.
Given a ﬁrst-order sentence F, we deﬁne the projection of F onto a set p of
predicates, denoted by F|p , to be the ﬁrst-order sentence obtained by replacing all
occurrences of atoms of the form q(t1 , . . . , tn ) in F such that q ∈ pr(F) \ p with ⊥
and performing the following syntactic transformations recursively until no further
transformations are possible:
¬⊥ → 
⊥ ∧ F → ⊥
⊥ ∨ F → F
⊥ → F → 
∃x → 

¬ → ⊥
F ∧ ⊥ → ⊥
F ∨ ⊥ → F
F →  → 
∃x⊥ → ⊥

 ∧ F → F
 ∨ F → 
 → F → F
∀x → 

F ∧ →

F
F ∨ →


∀x⊥ → ⊥

For example, consider the ﬁrst-order sentence
∀x(p(x) → q(x)) ∧ (q(a) ∧ ¬p(a) → r) ∧ ∀x(¬q(x) ∧ t(x) → s(x)).

(11)

The projection of (11) onto {q, r, s, t, m} is
(q(a) → r) ∧ ∀x(¬q(x) ∧ t(x) → s(x)).
When we restrict attention to the case of propositional logic programs such that p
contains at least the predicates occurring strictly positively in F, this notion coincides
with the corresponding one in the previous section.
Similar to incrementally parameterized programs, we deﬁne an incrementally parameterized formula F[t] to be a ﬁrst-order formula which may contain incrementally
parameterized atoms. For any nonnegative integer i, we deﬁne the incremental
instantiation of F at i, denoted by F[i], to be the result of replacing all occurrences
of incrementally parameterized atoms af(t) (x) in F[t] with an atom av (x), where v is
the result of evaluating f(i).
Deﬁnition 11 (First-Order Module Instantiation)
For any ﬁrst-order sentence F and any set of (input) predicates I, formula F 0 is
deﬁned as F, and F i+1 is deﬁned as F i |I ∪ head (F i ) , where head (F i ) denotes the set
of all predicates occurring strictly positively in F i . We deﬁne the ﬁrst-order module
instantiation of F w.r.t. I, denoted by FM (F, I), to be the ﬁrst-order module
(F ω , I, pr(F)\I),
where F ω is the least ﬁxpoint of the sequence F 0 , F 1 , . . . .
The idea of the simpliﬁcation process is related to the fact that all predicates
other than the ones in I ∪ head (F i ) have empty extents under the stable model
semantics, which are equivalent to ⊥ (Ferraris et al. 2011, Theorem 4). The process
is guaranteed to lead to a ﬁxpoint in a ﬁnite number of steps since F is ﬁnite
and F i |I∪head (F i ) is shorter than F i in all cases except for the terminating case. It is

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

732

J. Babb and J. Lee

not diﬃcult to check that if F is the FOL-representation of a ground disjunctive
program Π, the ﬁrst component Groundσ (Π)|I∪O in the deﬁnition of a DLP-module
instantiation corresponds to F 2 .
Example 2
Consider the propositional formula
F = (p → q) ∧ (q → r) ∧ (t ∧ ¬r → s).
and I = {t, m}. The process of instantiation results in the following transformations
on F:
(p → q) ∧ (q → r) ∧ (t ∧ ¬r → s).

F 0 (= F)

⇒ (q → r) ∧ (t ∧ ¬r → s).

F1

⇒ t ∧ ¬r → s.

F2

⇒ t → s.

F3

⇒ t → s.

F4

The resulting ﬁrst-order module is then
FM (F, {t, m}) = (t → s, {t, m}, {p, q, r, s}).
This deﬁnition of an instantiation is diﬀerent from the one by Gebser et al. (2011)
even when we restrict attention to a ﬁnite propositional disjunctive program. First,
we maximize the simpliﬁcation done on the initial formula F by repeatedly projecting
it onto its head and input predicates, whereas Gebser et al. perform only the ﬁrst
two projections (i.e., F 2 ). Second, the list of output atoms are diﬀerent. In our case
all atoms occurring in F that are not input atoms are assumed to be output atoms.
The following example illustrates these diﬀerences.
Example 3
Recall the DLP-module instantiation in Figure 2. The ﬁrst-order instantiation of
(the FOL-representation of) the program w.r.t {l, t} is (t → n, {l, t}, {m, n, p, q, r, s}).
While the two notions of instantiation are syntactically diﬀerent, it can be shown
that, given a propositional logic program Π and sets of propositional atoms I and
X, X is a module answer set of DM (Π, I) if and only if X is a module answer set
of FM (Π, I).
An incremental ﬁrst-order theory is a triple B, P [t], Q[t] where B is a ﬁrst-order
sentence, and P [t] and Q[t] are incrementally parameterized sentences.
The k-expansion of B, P [t], Q[t] is deﬁned as
Rk = B ∧ P [1] ∧ · · · ∧ P [k] ∧ Q[k].
It is clear that this coincides with the notion of k-expansion for incremental logic
programs when we restrict attention to the common syntax.
We assume a partial order ≺ on
{B, P [1], P [2], . . . , Q[1], Q[2], . . . }

(12)

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Module theorem for the general theory of stable models

733

as follows:
• B ≺ P [1] ≺ P [2] ≺ . . . ;
• P [i] ≺ Q[i] for i > 1.
Deﬁnition 12 (Acyclic Incremental First-Order Theory)
We say that an incremental ﬁrst-order theory B, P [t], Q[t] is acyclic if, for every
pair of formulas F, G in (12) such that F ≺ G, we have that G is negative
on pr(F).
This deﬁnition of acyclicity mirrors that of Gebser et al.’s (2011) in that it
prevents predicates from occurring strictly positively in multiple sentences which are
instantiated from the incremental theory. However, as shown in Proposition 3, it is
unnecessary to check a condition similar to modularity for incremental ﬁrst-order
theories, as it is ensured by acyclicity.
Given a ﬁrst-order module F = (F, I, O), by Out(F) we denote O.
Proposition 3 (Modularity of Incremental Theory)
If an incremental ﬁrst-order theory B, P [t], Q[t] is acyclic, then the following
modules are deﬁned for all k > 0.
P0 = FM (B, ∅),
Pi = Pi−1  FM (P [i], Out(Pi−1 )),

(1 6 i 6 k)

Rk = Pk  FM (Q[k], Out(Pk )) .
By applying Theorem 4, we can evaluate each component module independently
and compose their results in order to obtain the stable models of Rk .
Proposition 4 (Compositionality for Incremental First-Order Theories)
Let B, P [t], Q[t] be an incremental ﬁrst-order theory and let Rk be the module as
deﬁned in the statement of Proposition 3. For any nonnegative integer k,
IB ∪ IP [1] ∪ · · · ∪ IP [k] ∪ IQ[k] |= SM[Rk ]
iﬀ

IB |= SM[FM (B, ∅)]
and IP [1] |= SM[FM (P [1], Out(P0 ))]
and . . .

(13)

and IP [k] |= SM[FM (P [k], Out(Pk−1 ))]
and IQ[k] |= SM[FM (Q[k], Out(Pk ))] .
where IB (IP [1] , . . . , IP [k] , IQ[k] , respectively) is a c(B)-partial interpretation (c(P [1]),
. . . , c(P [k]), c(Q[k])-partial interpretation, respectively) such that IB , IP [1] , . . . , IP [k] , IQ[k]
are pairwise compatible.
Given an acyclic incremental theory and a nonnegative integer k, the following
proposition states that evaluating the individual modules and composing their results
is equivalent to evaluating the k-expansion of the incremental theory.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

734

J. Babb and J. Lee

Proposition 5 (Correctness of Incremental Assembly)
Let B, P [t], Q[t] be an acyclic incremental theory, let k be a nonnegative integer,
let Rk be the k-expansion of the incremental theory, and let Rk be the module as
deﬁned in Proposition 3. For any c-partial interpretation I such that c ⊇ c(Rk ), we
have that
I |= SM[Rk ] iﬀ I |= SM[Rk ].

7 Conclusion
Our extension of the module theorem to the general theory of stable models
applies to non-ground logic programs containing choice rules, the count aggregate,
and nested expressions. The extension is based on the new ﬁndings about the
relationship between the module theorem and the splitting theorem. The proof of
our module theorem4 uses the splitting theorem as a building block so that a further
generalization of the splitting theorem can be applied to generalize the module
theorem as well. Indeed, the module theorem presented here can be extended to
logic programs with arbitrary (recursive) aggregates, based on the extension of the
splitting theorem to formulas with generalized quantiﬁers, recently presented in (Lee
and Meng 2012). Based on the generalized module theorem, we reformulated and
extended the theory of incremental answer set computation to the general theory
of stable models, which can be useful in analyzing non-ground RASPL-1 programs
that describe dynamic domains.
Acknowledgements
We are grateful to Martin Gebser and Tomi Janhunen for useful discussions related
to this paper. We are also grateful to the anonymous referees for their useful
comments. This work was partially supported by the National Science Foundation
under Grant IIS-0916116.
References
Ferraris, P., Lee, J. and Lifschitz, V. 2007. A new perspective on stable models. In
Proceedings of International Joint Conference on Artiﬁcial Intelligence (IJCAI). AAAI Press,
372–379.
Ferraris, P., Lee, J. and Lifschitz, V. 2011. Stable models and circumscription. Artiﬁcial
Intelligence 175, 236–263.
Ferraris, P., Lee, J., Lifschitz, V. and Palla, R. 2009. Symmetric splitting in the general
theory of stable models. In Proceedings of International Joint Conference on Artiﬁcial
Intelligence (IJCAI). AAAI Press, 797–803.
Gebser, M., Grote, T., Kaminski, R. and Schaub, T. 2011. Reactive answer set programming.
In Proceedings of International Conference on Logic Programming and Nonmonotonic
Reasoning (LPNMR). Springer, 54–66.
4

Available in the online appendix.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Module theorem for the general theory of stable models

735

Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T. and Thiele, S. 2008.
Engineering an incremental ASP solver. In Proceedings of the Twenty-fourth International
Conference on Logic Programming (ICLP’08), M. Garcia de la Banda and E. Pontelli, Eds.
Lecture Notes in Computer Science, vol. 5366. Springer-Verlag, 190–205.
Gelfond, M. and Lifschitz, V. 1988. The stable model semantics for logic programming. In
Proceedings of International Logic Programming Conference and Symposium, R. Kowalski
and K. Bowen, Eds. MIT Press, 1070–1080.
Janhunen, T., Oikarinen, E., Tompits, H. and Woltran, S. 2009. Modularity aspects of
disjunctive stable models. Journal of Artiﬁcial Intelligence Research 35, 813–857.
Lee, J., Lifschitz, V. and Palla, R. 2008. A reductive semantics for counting and choice in
answer set programming. In Proceedings of the AAAI Conference on Artiﬁcial Intelligence
(AAAI). AAAI Press, 472–479.
Lee, J. and Meng, Y. 2012. Stable models of formulas with generalized quantiﬁers.
In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR). URL:
http://peace.eas.asu.edu/joolee/papers/smgq-nmr.pdf.
Lee, J. and Palla, R. 2012. Reformulating the situation calculus and the event calculus in
the general theory of stable models and in answer set programming. Journal of Artiﬁcial
Inteligence Research (JAIR) 43, 571–620.
Lifschitz, V. 1994. Circumscription. In Handbook of Logic in AI and Logic Programming,
D. Gabbay, C. Hogger and J. Robinson, Eds. Vol. 3. Oxford University Press, 298–352.
Oikarinen, E. and Janhunen, T. 2008. Achieving compositionality of the stable model
semantics for smodels programs. TPLP 8, 5-6, 717–761.

Downloaded from https:/www.cambridge.org/core. Arizona State University Libraries, on 22 Jun 2017 at 17:29:24, subject to the Cambridge Core terms of use,
available at https:/www.cambridge.org/core/terms. https://doi.org/10.1017/S1471068412000269

Under consideration for publication in Theory and Practice of Logic Programming

1

On Elementary Loops of Logic Programs

arXiv:1012.5847v2 [cs.AI] 2 Jan 2011

Martin Gebser
Institut für Informatik
Universität Potsdam, Germany
(e-mail: gebser@cs.uni-potsdam.de)

Joohyung Lee
School of Computing, Informatics and Decision Systems Engineering
Arizona State University, USA
(e-mail: joolee@asu.edu)

Yuliya Lierler
Department of Computer Science
University of Kentucky, USA
(e-mail: yuliya@cs.uky.edu)
submitted 23 May 2010; revised ; accepted 18 August 2010

Note: To appear in Theory and Practice of Logic Programming (TPLP)
Abstract
Using the notion of an elementary loop, Gebser and Schaub refined the theorem on loop
formulas due to Lin and Zhao by considering loop formulas of elementary loops only. In
this article, we reformulate their definition of an elementary loop, extend it to disjunctive programs, and study several properties of elementary loops, including how maximal
elementary loops are related to minimal unfounded sets. The results provide useful insights into the stable model semantics in terms of elementary loops. For a nondisjunctive
program, using a graph-theoretic characterization of an elementary loop, we show that
the problem of recognizing an elementary loop is tractable. On the other hand, we show
that the corresponding problem is coNP-complete for a disjunctive program. Based on the
notion of an elementary loop, we present the class of Head-Elementary-loop-Free (HEF)
programs, which strictly generalizes the class of Head-Cycle-Free (HCF) programs due to
Ben-Eliyahu and Dechter. Like an HCF program, an HEF program can be turned into
an equivalent nondisjunctive program in polynomial time by shifting head atoms into the
body.
KEYWORDS: stable model semantics, loop formulas, unfounded sets

1 Introduction
The theorem on loop formulas due to Lin and Zhao (2004) has contributed to
understanding the relationship between the stable model semantics and classical
logic. Unlike other translations that modify the vocabulary of a logic program
(Ben-Eliyahu and Dechter 1994; Lin and Zhao 2003; Janhunen 2006), the original

2

Martin Gebser and Joohyung Lee and Yuliya Lierler

theorem on loop formulas characterizes the stable models of a nondisjunctive program in terms of the models of its completion that satisfy the loop formulas of all
loops of the program. This allows us to compute stable models using SAT solvers,
which led to the design of answer set solvers assat1 (Lin and Zhao 2004) and
cmodels2 (Giunchiglia et al. 2004). Due to its importance in semantic understanding as well as in stable model computation, the theorem on loop formulas has been
extended to more general classes of logic programs, such as disjunctive programs
(Lee and Lifschitz 2003), infinite programs and programs containing classical negation (Lee 2005), and programs containing aggregates (Liu and Truszczynski 2006;
You and Liu 2008; Lee and Meng 2009). Moreover, it has been applied to other
nonmonotonic logics, such as circumscription (Lee and Lin 2006) and nonmonotonic causal logic (Lee 2004). The stable model semantics for first-order formulas
given in (Ferraris et al. 2007; Ferraris et al. 2011) is also closely related to the idea
of loop formulas, as described in (Lee and Meng 2008).
By slightly modifying the definition of a loop, Lee (2005) showed that loop formulas can be viewed as a generalization of completion (Clark 1978). The modeltheoretic account of loop formulas give in (Lee 2005) also tells us that the idea
of loop formulas is closely related to assumption sets (Saccá and Zaniolo 1990) or
unfounded sets (Leone et al. 1997). In a sense, the theorem by Lin and Zhao is
an enhancement of the unfounded set based characterization of stable models given
in (Saccá and Zaniolo 1990; Leone et al. 1997). The unfounded set based characterization takes into account the loop formulas of all sets of atoms, while the theorem
by Lin and Zhao considers the loop formulas of loops only. Gebser and Schaub
(2005) improved this enhancement even further. They defined the notion of an elementary loop of a nondisjunctive program and showed that the theorem by Lin and
Zhao remains correct even if we consider loop formulas of elementary loops only.
In this article, we reformulate the definition of an elementary loop of a nondisjunctive program by Gebser and Schaub, extend it to disjunctive programs, and study
several properties of elementary loops, including how maximal elementary loops
are related to minimal unfounded sets. Based on the notion of an elementary loop,
we present the class of Head-Elementary-loop-Free (HEF) program, which strictly
generalizes the class of Head-Cycle-Free (HCF) programs due to Ben-Eliyahu and
Dechter (1994). Like an HCF program, an HEF program can be turned into an
equivalent nondisjunctive program in polynomial time by shifting head atoms into
the body—a simple transformation defined in (Gelfond et al. 1991). This tells us
that an HEF program is an “easy” disjunctive program, which is merely a syntactic
variant of a nondisjunctive program. We also observe that several other properties
of nondisjunctive and HCF programs can be generalized to HEF programs. The
main results from (Lin and Zhao 2003) and (You et al. 2003), characterizing stable models in terms of inherent tightness and weak tightness, respectively, can be
extended to HEF programs, and likewise the operational characterization of stable
models of HCF programs due to Leone et al. (1997) can be extended to HEF pro1
2

http://assat.cs.ust.hk/
http://www.cs.utexas.edu/users/tag/cmodels/

On Elementary Loops of Logic Programs

3

grams. The properties of elementary loops and HEF programs studied here may
be useful in improving the computation of disjunctive answer set solvers, such as
claspd3 (Drescher et al. 2008), cmodels (Lierler 2005), dlv4 (Leone et al. 2006),
and gnt5 (Janhunen et al. 2006).
The outline of this paper is as follows. In Section 2, we present our reformulated
definition of an elementary loop of a nondisjunctive program and provide a corresponding refinement of the theorem on loop formulas, as well as some properties of
elementary loops. These results are extended to disjunctive programs in Section 3.
In Section 4, we introduce the class of HEF programs and show that their shifted
variants preserve stable models. In Section 5, we generalize the notion of inherent
tightness to HEF programs. An operational characterization of stable models of
HEF programs is presented in Section 6. Finally, Section 7 concludes the paper.
This paper is an extended version of the conference papers (Gebser et al. 2006)
and (Gebser et al. 2007).6

2 Nondisjunctive Programs
After providing the relevant background on nondisjunctive programs, this section
introduces elementary loops of nondisjunctive programs. We further refine elementary loops to elementarily unfounded sets, yielding a syntactic characterization of
minimal unfounded sets. Moreover, we show that elementary loops of nondisjunctive
programs can be recognized in polynomial time. (The statements of the theorems
and the propositions in this section which apply to nondisjunctive programs will
be generalized to disjunctive programs or HEF programs in later sections and the
proofs will be given there.) Finally, we compare our reformulation of elementary
loops with the definition by Gebser and Schaub (2005).
2.1 Background
A nondisjunctive rule is an expression of the form
a1 ← a2 , . . . , am , not am+1 , . . . , not an

(1)

where n ≥ m ≥ 1 and a1 , . . . , an are propositional atoms. A nondisjunctive program
is a finite set of nondisjunctive rules.
We will identify a nondisjunctive rule (1) with the propositional formula
a2 ∧ · · · ∧ am ∧ ¬am+1 ∧ · · · ∧ ¬an → a1 ,

(2)

and will often write (1) as
a1 ← B, F
3
4
5
6

(3)

http://potassco.sourceforge.net/
http://www.dbai.tuwien.ac.at/proj/dlv/
http://www.tcs.hut.fi/Software/gnt/
In (Gebser et al. 2006; Gebser et al. 2007), the term “elementary set” was used in place of
“elementary loop.”

4

Martin Gebser and Joohyung Lee and Yuliya Lierler
qr )

pi

1q

s

Fig. 1. The dependency graph of Program Π1

where B is a2 , . . . , am and F is not am+1 , . . . , not an . We will sometimes identify B
with its corresponding set of atoms.
We will identify an interpretation with the set of atoms that are true in it. We say
that a set X of atoms satisfies a rule (1) if X satisfies (2). Moreover, X satisfies a
nondisjunctive program Π (symbolically, X |= Π) if X satisfies every rule (1) of Π.
If X satisfies Π, we also call X a model of Π.
The reduct ΠX of a nondisjunctive program Π w.r.t. a set X of atoms is obtained
from Π by deleting each rule (3) such that X 6|= F , and replacing each remaining
rule (3) with a1 ← B. A set X of atoms is a stable model, also called an answer
set, of Π if X is minimal among the sets of atoms that satisfy ΠX .
The (positive) dependency graph of a nondisjunctive program Π is the directed
graph such that its vertices are the atoms occurring in Π, and its edges go from a1
to a2 , . . . , am for all rules (1) of Π. A nonempty set Y of atoms is called a loop of Π
if, for every pair a, b of atoms in Y , there is a path (possibly of length 0) from a
to b in the dependency graph of Π such that all vertices in the path belong to Y .
In other words, a nonempty set Y of atoms that occur in Π is a loop of Π if the
subgraph of the dependency graph of Π induced by Y is strongly connected. It is
clear that every singleton whose atom occurs in Π is a loop of Π.
For illustration, consider the following program Π1 :
p ← not s
p←r
q←r
r ← p, q .
Figure 1 shows the dependency graph of Π1 . Program Π1 has seven loops: {p}, {q},
{r}, {s}, {p, r}, {q, r}, and {p, q, r}.
For any set Y of atoms, the external support formula of Y for a nondisjunctive
program Π, denoted by ES Π (Y ), is the disjunction of conjunctions B ∧ F for all
rules (3) of Π such that a1 ∈ Y and B ∩ Y = ∅. The first condition expresses that
the atom “supported” by (3) is an element of Y . The second condition ensures that
this support is “external”: the atoms in B that it relies on do not belong to Y . Thus,
Y is called externally supported by Π w.r.t. a set X of atoms if X |= ES Π (Y ).
For any set Y of atoms, by LF Π (Y ), we denote the following formula:
^
a → ES Π (Y ) .
(4)
a∈Y

(The expression in the antecedent stands for the conjunction of all elements in Y .)
Formula (4) is called the (conjunctive) loop formula of Y for Π. Note that we still
call (4) a loop formula even when Y is not a loop of Π.
The following reformulation of the Lin-Zhao theorem, which characterizes the

On Elementary Loops of Logic Programs

5

stability of a model by loop formulas, is a part of the main theorem from (Lee 2005)
for the nondisjunctive case.
Theorem 1 ((Lee 2005))
For any nondisjunctive program Π and any set X of atoms that occur in Π, if X is
a model of Π, then the following conditions are equivalent:
(a) X is a stable model of Π;
(b) X satisfies LF Π (Y ) for all nonempty sets Y of atoms that occur in Π;
(c) X satisfies LF Π (Y ) for all loops Y of Π.
According to the equivalence between conditions (a) and (b) in Theorem 1, a
model of Π1 is stable iff it satisfies the loop formulas of all fifteen nonempty sets
of atoms formed from the atoms occurring in Π1 . On the other hand, condition (c)
tells us that it is sufficient to restrict attention to the following loop formulas of the
seven loops of Π1 :
p → ¬s ∨ r
q→r
r →p∧q
s→⊥
p ∧ r → ¬s
q∧r →⊥
p ∧ q ∧ r → ¬s .

(5)

Program Π1 has six models: {p}, {s}, {p, s}, {q, s}, {p, q, r}, and {p, q, r, s}. Among
them, {p} is the only stable model of Π1 , which is also the only model of Π1 that
satisfies all loop formulas in (5).
As noted in (Lee 2005), the equivalence between conditions (a) and (c) is a reformulation of the theorem by Lin and Zhao; the equivalence between conditions (a)
and (b) is a reformulation of Corollary 2 from (Saccá and Zaniolo 1990) and Theorem 4.6 from (Leone et al. 1997) (in the nondisjunctive case), which characterizes
the stability of a model in terms of unfounded sets. For any sets X, Y of atoms,
we say that Y is unfounded by Π w.r.t. X if Y is not externally supported by Π
w.r.t. X. Condition (b) can be stated in terms of unfounded sets as follows:
(b′ ) X contains no nonempty unfounded sets for Π w.r.t. X.

2.2 Elementary Loops of Nondisjunctive Programs
Gebser and Schaub (2005) showed that Y in LF Π (Y ) in Theorem 1 can be restricted
to “elementary” loops only. In this section, we present a reformulation of their
definition of an elementary loop and investigate its properties. We compare our
reformulation with the original definition by Gebser and Schaub in Section 2.5.
To begin with, the following proposition tells us that a loop can be defined without
mentioning a dependency graph.

6

Martin Gebser and Joohyung Lee and Yuliya Lierler

Proposition 1
For any nondisjunctive program Π and any nonempty set X of atoms that occur
in Π, X is a loop of Π iff, for every nonempty proper subset Y of X, there is a
rule (3) in Π such that a1 ∈ Y and B ∩ (X \ Y ) 6= ∅.
For any set X of atoms and any subset Y of X, we say that Y is outbound in X
for a nondisjunctive program Π if there is a rule (3) in Π such that
• a1 ∈ Y ,
• B ∩ (X \ Y ) 6= ∅, and
• B ∩ Y = ∅.
The following proposition describes the relationship between the external support
formula of a set Y of atoms and the external support formula of a subset Z of Y
that is not outbound in Y .
Proposition 2
For any nondisjunctive program Π and any sets X, Y , Z of atoms such that
Z ⊆ Y ⊆ X, if Z is not outbound in Y for Π and X |= ES Π (Z), then X |= ES Π (Y ).
Proposition 2 tells us that, in order to verify that a set Y of atoms is externally
supported by Π w.r.t. a superset X of Y , it is sufficient to identify some externally supported subset of Y that is not outbound in Y for Π. Conversely, if Y is
not externally supported by Π w.r.t. X, then every subset of Y that is externally
supported by Π w.r.t. X is outbound in Y for Π.
For any nonempty set X of atoms that occur in Π, we say that X is an elementary
loop of Π if all nonempty proper subsets of X are outbound in X for Π. As with
loops, it is clear from the definition that every singleton whose atom occurs in Π is
an elementary loop of Π. It is also clear that every elementary loop of Π is a loop
of Π: the condition for being an elementary loop implies the condition for being
a loop as stated in Proposition 1. On the other hand, a loop is not necessarily an
elementary loop. For instance, one can check that {p, q, r} is not an elementary
loop of Π1 since {p, r} (or {q, r}) is not outbound in {p, q, r} for Π1 . All other loops
of Π1 are elementary loops. Note that an elementary loop may be a proper subset
of another elementary loop (both {p} and {p, r} are elementary loops of Π1 ).
The following program replaces the last rule of Π1 with two other rules:
p ← not s
p←r
q←r
r←p
r←q .

(6)

The program has the same dependency graph as Π1 , and hence has the same loops.
However, its elementary loops are different from those of Π1 : all its loops are elementary loops as well, including {p, q, r}.
The definition of an elementary loop X given above is not affected if we check the
outboundness condition only for all loops or for all elementary loops that belong to
X instead of all nonempty proper subsets of X.

On Elementary Loops of Logic Programs

7

Proposition 3
For any nondisjunctive program Π and any nonempty set X of atoms that occur
in Π, X is an elementary loop of Π iff all proper subsets of X that are elementary
loops of Π are outbound in X for Π.
The following proposition describes an important relationship between loop formulas of elementary loops and loop formulas of arbitrary sets of atoms.
Proposition 4
For any nondisjunctive program Π and any nonempty set Y of atoms that occur
in Π, there is an elementary loop Z of Π such that Z is a subset of Y and LF Π (Z)
entails LF Π (Y ).
Proposition 4 allows us to limit attention to loop formulas of elementary loops
only. This yields the following theorem, which is a reformulation of Theorem 3
from (Gebser and Schaub 2005).
Theorem 1 (d )
The following condition is equivalent to each of conditions (a)–(c) in Theorem 1:
(d) X satisfies LF Π (Y ) for all elementary loops Y of Π.
For instance, according to Theorem 1 (d), a model of Π1 is stable iff it satisfies the
first six loop formulas in (5); the loop formula of the non-elementary loop {p, q, r}
(the last one in (5)) can be disregarded.
2.3 Elementarily Unfounded Sets for Nondisjunctive Programs
If we modify condition (c) in Theorem 1 by replacing “loops” in its statement
with “maximal loops,” the condition becomes weaker, and the modified statement
of Theorem 1 is incorrect. For instance, Π1 has only two maximal loops, {p, q, r}
and {s}, and their loop formulas are satisfied by a non-stable model {p, q, r}. In
fact, maximal loop {p, q, r} is not even an elementary loop of Π1 . Similarly, it is
not sufficient to consider maximal elementary loops only. If we replace “elementary
loops” in the statement of Theorem 1 (d) with “maximal elementary loops,” then
the modified statement is incorrect. For instance, the program
p ← q, not p
q ← p, not p
p← .
has two models, {p} and {p, q}, among which the latter is not stable. On the other
hand, the only maximal elementary loop of the program is {p, q}, and its loop
formula p ∧ q → ⊤ is satisfied by both models, so that this loop formula alone is
not sufficient to refute the stability of {p, q}. (Model {p, q} does not satisfy the loop
formula of {q}, which is q → p ∧ ¬p.)
However, in the following we show that, if we consider the “relevant” part of a
program w.r.t. a given interpretation, it is sufficient to restrict attention to maximal
elementary loops. For any nondisjunctive program Π and any set X of atoms, by

8

Martin Gebser and Joohyung Lee and Yuliya Lierler

ΠX , we denote the set of all rules (3) of Π such that X |= B, F . The following
proposition states that all nonempty proper subsets of an elementary loop of ΠX
are externally supported by Π w.r.t. X.
Proposition 5
For any nondisjunctive program Π, any set X of atoms, and any elementary loop Y
of ΠX , X satisfies ES Π (Z) for all nonempty proper subsets Z of Y .
Proposition 5 tells us that any elementary loop Y of ΠX that is unfounded by Π
w.r.t. X is maximal among the elementary loops of ΠX . From this, we obtain the
following result.
Theorem 1 (e)
The following condition is equivalent to each of conditions (a)–(c) in Theorem 1:
(e) X satisfies LF Π (Y ) for every set Y of atoms such that Y is
— a maximal elementary loop of ΠX , or
— a singleton whose atom occurs in Π.
Given a nondisjunctive program Π and a set X of atoms, we say that a set Y of
atoms that occur in Π is elementarily unfounded by Π w.r.t. X if Y is
• an elementary loop of ΠX that is unfounded by Π w.r.t. X or
• a singleton that is unfounded by Π w.r.t. X.7
Proposition 5 tells us that any non-singleton elementarily unfounded set for Π
w.r.t. X is a maximal elementary loop of ΠX .
It is clear from the definition that every elementarily unfounded set for Π w.r.t. X
is an elementary loop of Π and that it is also unfounded by Π w.r.t. X. However,
the converse does not hold in general. For instance, {p, q} is an elementary loop
that is unfounded by the program
p ← q, not r
q ← p, not r
w.r.t. {p, q, r}, but {p, q} is not an elementarily unfounded set w.r.t. {p, q, r}.
The following corollary, which follows from Proposition 5, states that all nonempty proper subsets of an elementarily unfounded set are externally supported. It
is essentially a reformulation of Theorem 5 from (Gebser and Schaub 2005).
Corollary 1
For any nondisjunctive program Π, any set X of atoms, and any elementarily unfounded set Y for Π w.r.t. X, X does not satisfy ES Π (Y ), but satisfies ES Π (Z) for
all nonempty proper subsets Z of Y .
Corollary 1 tells us that elementarily unfounded sets form an “anti-chain”: one
of them cannot be a proper subset of another. (On the other hand, an elementary
loop may contain another elementary loop as its proper subset.) Also it tells us
that elementarily unfounded sets are minimal among the nonempty unfounded sets
occurring in Π. Interestingly, the converse also holds.
7

Elementarily unfounded sets are closely related to “active elementary loops” defined
in (Gebser and Schaub 2005). We further investigate this relationship in Section 2.5.

On Elementary Loops of Logic Programs

9

Theorem 2
For any nondisjunctive program Π and any sets X, Y of atoms, Y is an elementarily
unfounded set for Π w.r.t. X iff Y is minimal among the nonempty sets of atoms
occurring in Π that are unfounded by Π w.r.t. X.
Notably, the correspondence between elementarily unfounded sets and minimal
nonempty unfounded sets has also led to an alternative characterization of UEmodels (Gebser et al. 2008), which characterizes uniform equivalence (Eiter and Fink 2003)
of nondisjunctive programs as well as disjunctive programs.
Similar to Theorem 1 (b′ ), Theorem 1 (e) can be stated in terms of elementarily
unfounded sets, thereby restricting attention to minimal nonempty unfounded sets.
Theorem 1 (e′ )
The following condition is equivalent to each of conditions (a)–(c) in Theorem 1:
(e′ ) X contains no elementarily unfounded sets for Π w.r.t. X.
The notion of an elementarily unfounded set may help improve computation
performed by SAT-based answer set solvers. Since there are exponentially many
“relevant” loops in the worst case (Lifschitz and Razborov 2006), SAT-based answer set solvers do not add all loop formulas at once. Instead, they check whether
a model returned by a SAT solver is stable. If not, a loop formula that is not satisfied by the model is added, and the SAT solver is invoked again. This process is
repeated until a stable model is found or the search space is exhausted. In view of
Theorem 1 (e′ ), it is sufficient to restrict attention to elementarily unfounded sets
during the computation. This ensures that the considered loop formulas belong to
elementary loops. Since every elementary loop is a loop, but not vice versa, the
computation may involve fewer loop formulas overall than in the case when arbitrary loops are considered. However, whether this idea will lead to more efficient
computation in practice requires further investigation.
2.4 Recognizing Elementary Loops of Nondisjunctive Programs
The definition of an elementary loop given in Section 2.2 involves considering all
its nonempty proper subsets (or at least all elementary loops that are subsets).
This may seem to imply that deciding whether a given set of atoms is an elementary loop is a computationally hard problem. However, Gebser and Schaub (2005)
showed that this is not the case for nondisjunctive programs. They also noted
that the notion of a positive dependency graph is not expressive enough to distinguish between elementary and non-elementary loops (Program Π1 and the program
in (6) have the same dependency graph, but their elementary loops are different),
and instead used the rather complicated notion of a body-head dependency graph to
identify elementary loops. In this section, we simplify their result by still referring
to a positive dependency graph. We show that removing some unnecessary edges
from a positive dependency graph is just enough to distinguish between elementary
and non-elementary loops.

10

Martin Gebser and Joohyung Lee and Yuliya Lierler
p

qr )

q

Fig. 2. The elementary subgraph of {p, q, r} for Program Π1
For any set X of atoms that occur in a nondisjunctive program Π, we define:
EC 0Π (X) =
EC i+1
Π (X)

=

EC Π (X) =

∅,
{(a1 , b) | there is a rule (3) in Π such that a1 ∈ X,
b ∈ B ∩ X, and all atoms in B ∩ X belong to the
same strongly connected component in (X, EC iΠ (X))} ,
S
i
i≥0 EC Π (X) .

This is a “bottom-up” construction based on strongly connected components, i.e.,
maximal strongly connected subgraphs of a given graph. Thus EC iΠ (X) is a subset
of EC i+1
Π (X), and the graph (X, EC Π (X)) is a subgraph of the positive dependency
graph of Π. We call the graph (X, EC Π (X)) the elementary subgraph of X for Π.
Figure 2 shows the elementary subgraph of {p, q, r} for Π1 , which is not strongly
connected.
The following theorem is similar to Theorem 10 from (Gebser and Schaub 2005),
but instead of referring to the notion of a body-head dependency graph, it refers
to the notion of an elementary subgraph.
Theorem 3
For any nondisjunctive program Π and any nonempty set X of atoms that occur
in Π, X is an elementary loop of Π iff the elementary subgraph of X for Π is strongly
connected.
Since an elementary subgraph can be constructed in polynomial time, the problem
of deciding whether a given set of atoms is an elementary loop of a nondisjunctive
program is tractable.
2.5 Comparison with Gebser-Schaub Definition
In this section, we compare our reformulation of elementary loops with the original
definition by Gebser and Schaub (2005) for nondisjunctive programs.
Let Π be a nondisjunctive program. A loop of Π is called trivial if it consists of
a single atom such that the dependency graph of Π does not contain an edge from
the atom to itself, and nontrivial otherwise.8 For a nontrivial loop L of Π, let
−
• RΠ
(L) = {(3) ∈ Π | a1 ∈ L, B ∩ L = ∅}, and
+
• RΠ (L) = {(3) ∈ Π | a1 ∈ L, B ∩ L 6= ∅}.

Definition 1 ((Gebser and Schaub 2005))
A nontrivial loop L of a nondisjunctive program Π is called a GS-elementary loop
−
+
of Π if RΠ
(L′ ) ∩ RΠ
(L) 6= ∅ for all proper subsets L′ of L that are nontrivial loops
of Π.
8

In (Lin and Zhao 2004) and (Gebser and Schaub 2005), loops were defined to be nontrivial.

On Elementary Loops of Logic Programs

11

Proposition 6
For any nondisjunctive program Π and any set L of atoms, L is a GS-elementary
loop of Π iff L is a nontrivial elementary loop of Π.
Proof. From left to right: Assume that L is a GS-elementary loop of Π. If L is
a singleton, it is a (nontrivial) elementary loop according to our definition. If L is
−
+
(L′ ) ∩ RΠ
(L) 6= ∅ for any proper subset L′ of L
not a singleton, we have that RΠ
that is a nontrivial loop of Π. In other words, there is a rule (3) in Π such that
a1 ∈ L ′ ,

(7)

B ∩ L′ = ∅,

(8)

B ∩ (L \ L′ ) 6= ∅.

(9)

and
′

We thus have that L is outbound in L for Π. Furthermore, for any trivial loop {a1 }
of Π contained in L, there must be a rule (3) in Π such that B ∩ (L \ {a1 }) 6= ∅,
as L cannot be a loop of Π otherwise. Since {a1 } is trivial, B ∩ {a1 } = ∅, so that
{a1 } is outbound in L for Π. By Proposition 3, it follows that L is a (nontrivial)
elementary loop of Π.
From right to left: Assume that L is a nontrivial elementary loop of Π. From the
definition of an elementary loop, it follows that any proper subset L′ of L that is a
nontrivial loop of Π is outbound in L for Π. That is, there is a rule (3) in Π such
that (7), (8), and (9) hold, so that L is a GS-elementary loop of Π.
For a nondisjunctive program Π and a set X of atoms, a loop L of ΠX is a
GS-elementary loop of ΠX iff L is a nontrivial elementary loop of ΠX . Thus an
active elementary loop of Π according to (Gebser and Schaub 2005) is a nontrivial
elementary loop of ΠX that is unfounded by Π w.r.t. X. Hence, any active elementary loop L of Π is an elementarily unfounded set for Π w.r.t. X, while the converse
does not hold in general if L is a singleton.
In fact, there are a few differences between Definition 1 and our definition of
an elementary loop. First, our definition of an elementary loop does not a priori
assume that its atoms form a loop. Rather, the fact that an elementary loop is a
loop follows from its definition in view of Proposition 1. Second, the two definitions
do not agree on trivial loops: a trivial loop is an elementary loop, but not a GSelementary loop. This originates from the difference between the definition of a loop
in (Lin and Zhao 2004) and its reformulation given in (Lee 2005). As shown in the
main theorem from (Lee 2005), identifying a trivial loop as a loop admits a simpler
reformulation of the Lin-Zhao theorem by allowing us to view completion formulas (Clark 1978) as a special case of loop formulas. Furthermore, the reformulated
definition of an elementary loop enables us to identify a close relationship between
maximal elementary loops (elementarily unfounded sets) and minimal nonempty
unfounded sets.
Importantly, trivial loops allow us to extend the notion of an elementary loop
to disjunctive programs without producing counterintuitive results. For instance,

12

Martin Gebser and Joohyung Lee and Yuliya Lierler

consider the following disjunctive program:
p; q←r
p; r←q
q ; r←p.

(10)

The nontrivial loops of this program are {p, q}, {p, r}, {q, r}, and {p, q, r}, but
not the singletons {p}, {q}, and {r}. If we were to extend GS-elementary loops
to disjunctive programs, a natural extension would say that {p, q, r} is a GSelementary loop since {p, q}, {p, r}, and {q, r} are “outbound” in {p, q, r}. But
note that {p, q, r} is unfounded w.r.t. {p, q, r}; moreover, every singleton is also
unfounded w.r.t {p, q, r}. This is in contrast with Proposition 5, according to which
all nonempty proper subsets of an elementary loop should be externally supported.
The next section shows that such an anomaly does not arise with our definition of
an elementary loop that is extended to disjunctive programs.
3 Disjunctive Programs
After providing the relevant background on disjunctive programs, this section generalizes the notions of an elementary loop and an elementarily unfounded set to
disjunctive programs. We also provide the proofs of the generalizations of the statements given in the previous section; such generalized results also apply to the class
of nondisjunctive programs as a fragment of disjunctive programs. Furthermore,
we show that, in contrast to nondisjunctive programs, recognizing an elementary
loop is intractable in the case of arbitrary disjunctive programs, but stays tractable
under a certain syntactic condition.
3.1 Background
A disjunctive rule is an expression of the form
a1 ; . . . ; ak ← ak+1 , . . . , al , not al+1 , . . . , not am , not not am+1 , . . . , not not an
(11)
where n ≥ m ≥ l ≥ k ≥ 0 and a1 , . . . , an are propositional atoms. A disjunctive program is a finite set of disjunctive rules. Note that any program with
nested expressions can be turned into an equivalent program whose rules are of the
form (11) (Lifschitz et al. 1999).
We will identify a disjunctive rule (11) with the propositional formula
ak+1 ∧ · · · ∧ al ∧ ¬al+1 ∧ · · · ∧ ¬am ∧ ¬¬am+1 ∧ · · · ∧ ¬¬an → a1 ∨ · · · ∨ ak
and will often write (11) as
A ← B, F
where A is a1 , . . . , ak , B is ak+1 , . . . , al , and F is
not al+1 , . . . , not am , not not am+1 , . . . , not not an .
We will sometimes identify A and B with their corresponding sets of atoms.

(12)

On Elementary Loops of Logic Programs

13

The reduct ΠX of a disjunctive program Π w.r.t. a set X of atoms is obtained
from Π by deleting each rule (12) such that X 6|= F , and replacing each remaining
rule (12) with A ← B. A set X of atoms is a stable model, also called an answer
set, of Π if X is minimal among the sets of atoms that satisfy ΠX .
The definition of a (positive) dependency graph is extended to a disjunctive
program Π in the straightforward way: the vertices of the graph are the atoms
occurring in Π, and its edges go from the elements of A to the elements of B for all
rules (12) of Π. With this extended definition of a dependency graph, the definition
of a loop for a nondisjunctive program is straightforwardly extended to a disjunctive
program.
For any set Y of atoms, the external support formula of Y for a disjunctive
program Π, denoted by ES Π (Y ), is the disjunction of conjunctions
^
¬a
B∧F ∧
a∈A\Y

for all rules (12) of Π such that A∩Y 6= ∅ and B∩Y = ∅. When Π is a nondisjunctive
program, this definition reduces to the definition of ES Π (Y ) for nondisjunctive
programs given earlier. As before, we say that Y is externally supported by Π w.r.t.
a set X of atoms if X |= ES Π (Y ); Y is unfounded Π w.r.t. X if X 6|= ES Π (Y ).
The notion of LF Π (Y ) and the term (conjunctive) loop formula similarly apply
to formulas (4) when Π is a disjunctive program.
As shown in (Lee 2005), Theorem 1 remains correct after replacing “nondisjunctive program” in its statement with “disjunctive program.”
Theoremd 1 ((Lee 2005))
For any disjunctive program Π and any set X of atoms that occur in Π, if X is a
model of Π, then the following conditions are equivalent: 9
(a)
(b)
(b′ )
(c)

X
X
X
X

is a stable model of Π;
satisfies LF Π (Y ) for all nonempty sets Y of atoms that occur in Π;
contains no nonempty unfounded sets for Π w.r.t. X;
satisfies LF Π (Y ) for all loops Y of Π.

For instance, the loop formulas of the seven loops of the program in (10) are:
p → (r ∧ ¬q) ∨ (q ∧ ¬r)
q → (r ∧ ¬p) ∨ (p ∧ ¬r)
r → (q ∧ ¬p) ∨ (p ∧ ¬q)
p∧q →r
p∧r →q
q∧r →p
p∧q∧r →⊥ .

(13)

∅ is the only model of (13) and it is the only stable model of (10) in accordance
with the equivalence between (a) and (c) in Theoremd 1.
9

Superscript

d

indicates that the statement is a generalization to disjunctive programs.

14

Martin Gebser and Joohyung Lee and Yuliya Lierler
3.2 Elementary Loops of Disjunctive Programs

In this section, we generalize the definition of an elementary loop to disjunctive
programs.
A loop of a disjunctive program can be defined without referring to a dependency
graph, as in Proposition 1.
Propositiond 1
For any disjunctive program Π and any nonempty set X of atoms that occur in Π,
X is a loop of Π iff, for every nonempty proper subset Y of X, there is a rule (12)
in Π such that A ∩ Y 6= ∅ and B ∩ (X \ Y ) 6= ∅.
Proof. From left to right: Assume that X is a loop of Π. If X is a singleton, it is
clear. If X is not a singleton, take any nonempty proper subset Y of X. Since both
Y and X \ Y are nonempty, there is a path from some atom in Y to some atom in
X \ Y in the dependency graph of Π such that all vertices in the path belong to X.
This implies that there is an edge from an atom in Y to an atom in X \ Y , i.e.,
A ∩ Y 6= ∅ and B ∩ (X \ Y ) 6= ∅ for some rule (12) in Π.
From right to left: Assume that X is not a loop of Π. Then the subgraph of the
dependency graph of Π induced by X is not strongly connected. Consequently, there
is a nonempty proper subset Y of X such that no edge connects an atom in Y to
an atom in X \ Y . This implies that there is no rule (12) in Π such that A ∩ Y 6= ∅
and B ∩ (X \ Y ) 6= ∅.
For any set X of atoms and any subset Y of X, we say that Y is outbound in X
for a disjunctive program Π if there is a rule (12) in Π such that
•
•
•
•

A ∩ Y 6= ∅,
B ∩ (X \ Y ) 6= ∅,
A ∩ (X \ Y ) = ∅, and
B ∩ Y = ∅.

As with nondisjunctive programs, for any nonempty set X of atoms that occur
in Π, we say that X is an elementary loop of Π if all nonempty proper subsets of X
are outbound in X for Π. Clearly, every singleton whose atom occurs in Π is an
elementary loop of Π, and every elementary loop of Π is a loop of Π. The definition
of an elementary loop of a disjunctive program is stronger than the alternative
characterization of a loop provided in Propositiond 1: it requires that the rule (12)
satisfy two additional conditions, A ∩ (X \ Y ) = ∅ and B ∩ Y = ∅.
To illustrate the definition of an elementary loop of a disjunctive program, consider the loop {p, q, r} of the program in (10). The loop is not an elementary loop because, for instance, {p} is not outbound in {p, q, r}: although the first two rules (12)
in (10) are such that A ∩ {p} 6= ∅, B ∩ {q, r} 6= ∅, and B ∩ {p} = ∅, we also have that
A ∩ {q, r} 6= ∅ for each of them. Similarly, {q} and {r} are not outbound in {p, q, r}.
On the other hand, the remaining loops of the program, {p}, {q}, {r}, {p, q}, {p, r},
and {q, r}, are elementary loops.
With the extended definitions given above, Propositions 2, 3, 4 and Theorem 1 (d)
remain correct after replacing “nondisjunctive program” in their statements with
“disjunctive program.” In the following, we present proofs for these generalizations.

On Elementary Loops of Logic Programs

15

Propositiond 2
For any disjunctive program Π and any sets X, Y , Z of atoms such that Z ⊆ Y ⊆ X,
if Z is not outbound in Y for Π and X |= ES Π (Z), then X |= ES Π (Y ).
Proof. Assume that Z is not outbound in Y for Π and that X |= ES Π (Z). From
the latter, it follows that there is a rule (12) in Π such that
A ∩ Z 6= ∅ ,

(14)

B∩Z =∅ ,

(15)

X |= B, F ,

(16)

X ∩ (A \ Z) = ∅ .

(17)

A ∩ Y 6= ∅ .

(18)

X ∩ (A \ Y ) = ∅

(19)

and
From (14), since Z ⊆ Y ,
From (17), since Z ⊆ Y ⊆ X,

and
Y ∩ (A \ Z) = ∅ ,
where the latter is equivalent to
A ∩ (Y \ Z) = ∅ .

(20)

Since Z is not outbound in Y for Π, from (14), (15), and (20), it follows that
B ∩ (Y \ Z) = ∅ ,
which, in combination with (15), gives us that
B∩Y =∅ .

(21)

Finally, from (16), (18), (19), and (21), we conclude that X |= ES Π (Y ).
Propositiond 3
For any disjunctive program Π and any nonempty set X of atoms that occur in Π,
X is an elementary loop of Π iff all proper subsets of X that are elementary loops
of Π are outbound in X for Π.
Proof. From left to right is clear.
From right to left: Assume that X is not an elementary loop of Π. Then there is
a nonempty proper subset Y of X that is not outbound in X for Π. If Y is an
elementary loop of Π, it is clear. Otherwise, there is a nonempty proper subset Z
of Y that is not outbound in Y for Π. For the sake of contradiction, assume that
Z is outbound in X for Π, i.e., that there is a rule (12) in Π such that
A ∩ Z 6= ∅ ,

(22)

16

Martin Gebser and Joohyung Lee and Yuliya Lierler
B ∩ (X \ Z) 6= ∅ ,

(23)

A ∩ (X \ Z) = ∅ ,

(24)

B∩Z =∅ .

(25)

and
From (22) and (24), since Z ⊆ Y ⊆ X,
A ∩ Y 6= ∅ ,

(26)

A ∩ (X \ Y ) = ∅ ,

(27)

A ∩ (Y \ Z) = ∅ .

(28)

and
Since Z is not outbound in Y for Π, from (22), (25), and (28), it follows that
B ∩ (Y \ Z) = ∅ ,
which, in combination with (23) and (25), gives us that
B∩Y =∅

(29)

B ∩ (X \ Y ) 6= ∅ .

(30)

and
However, (26), (27), (29), and (30) together contradict that Y is not outbound in X
for Π, from which we conclude that Z is not outbound in X for Π. We have thus
shown that every nonempty proper subset of X that is not outbound in X for Π
and not an elementary loop of Π contains in turn a nonempty proper subset that is
not outbound in X for Π. Since X is finite, there is some (not necessarily unique)
minimal nonempty proper subset of X that is not outbound in X for Π, and such
a subset must be an elementary loop of Π.
Propositiond 4
For any disjunctive program Π and any nonempty set Y of atoms that occur in Π,
there is an elementary loop Z of Π such that Z is a subset of Y and LF Π (Z) entails
LF Π (Y ).
Proof. If Y is an elementary loop of Π, it is clear. Otherwise, by Propositiond 3,
some proper subset Z of Y is an elementary loop of Π that is not outbound in Y
for Π. Take any set X of atoms such that X |= LF Π (Z). If Y 6⊆ X, then X 6|=
V
V
a∈Z a and X |= ES Π (Z), and, by
a∈Y a and X |= LF Π (Y ). If Y ⊆ X, X |=
d
Proposition 2, we conclude that X |= ES Π (Y ) and X |= LF Π (Y ).
Theoremd 1 (d )
The following condition is equivalent to each of conditions (a)–(c) in Theoremd 1:
(d) X satisfies LF Π (Y ) for all elementary loops Y of Π.

On Elementary Loops of Logic Programs

17

Proof. We show the equivalence between (b) and (d). From (b) to (d) is clear,
and from (d) to (b) follows immediately from Propositiond 4.
For instance, for the program in (10), the loop formula of non-elementary loop
{p, q, r} (the last one in (13)) can be disregarded in view of Theoremd 1 (d).
3.3 Elementarily Unfounded Sets for Disjunctive Programs
Let Π be a disjunctive program. For any sets X, Y of atoms, by ΠX,Y we denote
the set of all rules (12) of Π such that X |= B, F and X ∩ (A \ Y ) = ∅. That is,
the program ΠX,Y contains all rules of Π that can provide supports for Y w.r.t. X.
If Y = X, we also denote ΠX,Y by ΠX . When Π is a nondisjunctive program,
this definition reduces to the definition of ΠX for nondisjunctive programs given
earlier. Furthermore, when Π is nondisjunctive and Y is not a singleton, then Y is
an elementary loop of ΠX,Y iff Y is an elementary loop of ΠX .
We extend the definition of an elementarily unfounded set to disjunctive programs
by replacing “ΠX ” with “ΠX,Y ”: for a disjunctive program Π and a set X of atoms,
we say that a set Y of atoms that occur in Π is elementarily unfounded by Π w.r.t. X
if Y is
• an elementary loop of ΠX,Y that is unfounded by Π w.r.t. X or
• a singleton that is unfounded by Π w.r.t. X.
It is clear from the definition that every elementarily unfounded set for Π w.r.t. X
is an elementary loop of Π and that it is also unfounded by Π w.r.t. X.
For instance, let Π be the program (10). The program Π{p,q,r},{p,q} consists of
the first rule in (10), so that {p, q} is not an elementary loop of Π{p,q,r},{p,q} . On
the other hand, Π{p,q},{p,q} consists of the last two rules in (10), and {p, q} is an
elementary loop of Π{p,q},{p,q} . Since {p, q} is also unfounded by Π w.r.t. {p, q}, it
is an elementarily unfounded set for Π w.r.t. {p, q}.
Proposition 5, Corollary 1, and Theorem 2 remain correct after replacing “nondisjunctive program” in their statements with “disjunctive program,” and “ΠX ” with
“ΠX,Y .”
Propositiond 5
For any disjunctive program Π, any set X of atoms, and any elementary loop Y of
ΠX,Y , X satisfies ES Π (Z) for all nonempty proper subsets Z of Y .
Proof. From the fact that Y is an elementary loop of ΠX,Y , it follows that any
nonempty proper subset Z of Y is outbound in Y for ΠX,Y . If Y is not a singleton,
this implies that Y is a subset of X and that, for each nonempty proper subset Z
of Y , there is a rule (12) in Π such that
A ∩ Z 6= ∅ ,

(31)

A ∩ (Y \ Z) = ∅ ,

(32)

B∩Z =∅ ,

(33)

X |= B, F ,

(34)

18

Martin Gebser and Joohyung Lee and Yuliya Lierler

and
X ∩ (A \ Y ) = ∅ .

(35)

From (32) and (35), it follows that
X ∩ (A \ Z) = ∅ .

(36)

Finally, from (31), (33), (34), and (36), we conclude that X |= ES Π (Z).
Corollaryd 1
For any disjunctive program Π, any set X of atoms, and any elementarily unfounded
set Y for Π w.r.t. X, X does not satisfy ES Π (Y ), but satisfies ES Π (Z) for all
nonempty proper subsets Z of Y .
Proof. From the definition of an elementarily unfounded set, X 6|= ES Π (Y ), and,
by Propositiond 5, X |= ES Π (Z) for all nonempty proper subsets Z of Y .
Theoremd 2
For any disjunctive program Π and any sets X, Y of atoms, Y is an elementarily
unfounded set for Π w.r.t. X iff Y is minimal among the nonempty sets of atoms
occurring in Π that are unfounded by Π w.r.t. X.
Proof. From left to right follows immediately from Corollaryd 1.
From right to left: Assume that Y is minimal among the nonempty unfounded
sets for Π w.r.t. X whose atoms occur in Π. If Y is a singleton, it is elementarily
unfounded by Π w.r.t. X. Otherwise, if Y 6⊆ X, there is an atom a ∈ (Y \ X), and
one can check that (Y \{a}) is also unfounded by Π w.r.t. X, which contradicts that
Y is a minimal nonempty unfounded set for Π w.r.t. X. Hence, from the minimality
assumption on Y , it follows that Y is a subset of X. It also holds that X |= ES Π (Z)
for every nonempty proper subset Z of Y , so that there is a rule (12) in Π such
that
A ∩ Z 6= ∅ ,

(37)

B∩Z =∅ ,

(38)

X |= B, F ,

(39)

X ∩ (A \ Z) = ∅ .

(40)

A ∩ (Y \ Z) = ∅

(41)

X ∩ (A \ Y ) = ∅ .

(42)

and
From (40), since Z ⊆ Y ⊆ X,

and
Since Y is unfounded by Π w.r.t. X, from (37), (39), and (42), it follows that
B ∩ Y 6= ∅ ,

On Elementary Loops of Logic Programs

19

which, in combination with (38), gives us that
B ∩ (Y \ Z) 6= ∅ .

(43)

In view of (39) and (42), we have that the rule (12) is contained in ΠX,Y . From (37),
(38), (41), and (43), we further conclude that Z is outbound in Y for ΠX,Y . Consequently, Y is an elementary loop of ΠX,Y and elementarily unfounded by Π w.r.t. X.
Theorem 1 (e) and (e′ ) can now be extended to disjunctive programs as follows.
Theoremd 1 (e′ )
The following conditions are equivalent to each of conditions (a)–(c) in Theoremd 1:
(e) X satisfies LF Π (Y ) for every set Y of atoms such that Y is
— maximal among all sets Z of atoms that are elementary loops of ΠX,Z
or
— a singleton whose atom occurs in Π;
(e′ ) X contains no elementarily unfounded sets for Π w.r.t. X.
Proof. We first show the equivalence between (b′ ) and (e′ ): from (b′ ) to (e′ ) is
clear, and from (e′ ) to (b′ ) follows immediately from Theoremd 2. Moreover, the
equivalence between (e′ ) and (e) holds in view of Propositiond 5, which tells us that
an elementarily unfounded set Y for Π w.r.t. X cannot be a proper subset of any
set Z of atoms that is an elementary loop of ΠX,Z .

3.4 Recognizing Elementary Loops of Disjunctive Programs
Although deciding whether a given set of atoms is an elementary loop of a nondisjunctive program can be done efficiently, it turns out that the corresponding problem in the case of arbitrary disjunctive programs is intractable.
Theorem 4
For any disjunctive program Π and any set Y of atoms, deciding whether Y is an
elementary loop of Π is coNP-complete.
Proof. Containment in coNP is clear, since it is easy to check that a given nonempty proper subset of Y is not outbound in Y for Π.
For coNP-hardness, we reduce the coNP-hard problem of deciding whether a finite
set X of atoms is “unfounded-free” for a disjunctive program Π (Leone et al. 1997),
i.e., X contains no nonempty unfounded sets for Π w.r.t. X. Using a new atom e
that does not occur in Π or X, we construct a program Π′ as follows: for every
rule (12) of ΠX , include a rule A ← e, B, F in Π′ , and, for every a ∈ X ∪ {e},
include a rule e ← a in Π′ . Given the rules of the latter type, it is clear that any
proper subset Z of Y = X ∪ {e} that is not outbound in Y for Π′ cannot contain e.
For every rule (12) of Π′ such that A 6= {e}, since e ∈ B, we then have that
B ∩ (Y \ Z) 6= ∅ .

20

Martin Gebser and Joohyung Lee and Yuliya Lierler

Hence, if a nonempty proper subset Z of Y is not outbound in Y for Π′ , for every
rule (12) of Π′ such that A 6= {e}, at least one of the following conditions holds:
A∩Z = ∅ ,

(44)

A ∩ (Y \ Z) 6= ∅ ,

(45)

B ∩ Z 6= ∅ .

(46)

A ∩ (X \ Z) 6= ∅ .

(47)

or
Since e ∈
/ A, (45) implies that

We have thus shown that (44), (46), or (47) holds for every rule (12) of Π′ such
that A 6= {e}, and, similarly, for every rule (12) of ΠX . Furthermore, we have that
X 6|= B, F

(48)

for every rule (12) of Π \ ΠX . Consequently, (44), (46), (47), or (48) holds for every
rule (12) of Π, which shows that Z is unfounded by Π w.r.t. X. Conversely, if a
nonempty subset Z of X is unfounded by Π w.r.t. X, the fact that (44), (46), or
(47) holds for every rule (12) of ΠX implies that every rule (12) of Π′ satisfies (44),
(45), or (46), so that Z is not outbound in Y for Π′ . Consequently, we conclude
that X is unfounded-free for Π iff Y = X ∪ {e} is an elementary loop of Π′ .
However, for the class of disjunctive programs called “Head-Cycle-Free” (Ben-Eliyahu and Dechter 1994),
deciding whether a set of atoms is an elementary loop is tractable. We say that a
disjunctive program Π is Head-Cycle-Free (HCF) if |A ∩ Y | ≤ 1 for every rule (12)
of Π and every loop Y of Π.
The definition of an elementary subgraph for a nondisjunctive program can be
extended to disjunctive programs by modifying the equation for EC i+1
as follows:
Π
EC i+1
Π (X) =

{(a, b) | there is a rule (12) in Π such that A ∩ X = {a},
b ∈ B ∩ X, and all atoms in B ∩ X belong to the
same strongly connected component in (X, EC iΠ (X))} .

With this extended definition of an elementary subgraph, Theorem 3 remains correct after replacing “nondisjunctive program” in its statement with “HCF program.”
In the next section, we introduce “Head-Elementary-loop-Free” programs, and
show that Theorem 3 can be further generalized to such programs.
4 Head-Elementary-Loop-Free Programs
In general, computing stable models of a disjunctive program is harder than computing stable models of a nondisjunctive program (Eiter and Gottlob 1995). On the
other hand, HCF programs are “easy” disjunctive programs that can be turned into
equivalent nondisjunctive programs in polynomial time (Ben-Eliyahu and Dechter 1994).
This property plays an important role in the computation of stable models of disjunctive programs, and is used by answer set solvers claspd, cmodels, and dlv.

On Elementary Loops of Logic Programs

21

By referring to elementary loops in place of loops in the definition of an HCF
program, we define a class of programs that is more general than HCF programs: we
say that a disjunctive program Π is Head-Elementary-loop-Free (HEF) if |A∩Y | ≤ 1
for every rule (12) of Π and every elementary loop Y of Π. Since every elementary
loop is also a loop, it is clear that every HCF program is an HEF program as
well. However, not all HEF programs are HCF. For example, consider the following
program Π2 :
p←r
q←r
r ← p, q
p; q← .
This program has six loops: {p}, {q}, {r}, {p, r}, {q, r}, and {p, q, r}. Since the
head of the last rule contains two atoms from the loop {p, q, r}, Π2 is not HCF.
On the other hand, Π2 is HEF since {p, q, r} is not an elementary loop of Π2 : its
subsets {p, r} and {q, r} are not outbound in {p, q, r} for Π2 .
Let us write a rule (12) in the following form:
a1 ; . . . ; ak ← B, F .

(49)

Gelfond et al. (1991) defined a mapping from a disjunctive program Π to a nondisjunctive program Πsh , the shifted variant of Π, by replacing each rule (49) with
k > 1 in Π by k new rules:
ai ← B, F, not a1 , . . . , not ai−1 , not ai+1 , . . . , not ak .

(50)

They showed that every stable model of Πsh is also a stable model of Π. Although
the converse does not hold in general, Ben-Eliyahu and Dechter (1994) showed that
the converse holds if Π is HCF. We below extend this result to HEF programs.
The following proposition compares the elementary loops of Π with the elementary loops of Πsh .
Proposition 7
For any disjunctive program Π, if X is an elementary loop of Π, then X is an
elementary loop of Πsh .
Proof. Assume that X is an elementary loop of Π. Then every nonempty proper
subset Y of X is outbound in X for Π, so that there is a rule (49) in Π such that
{a1 , . . . , ak } ∩ Y 6= ∅ ,

(51)

B ∩ (X \ Y ) 6= ∅ ,

(52)

{a1 , . . . , ak } ∩ (X \ Y ) = ∅ ,
and
B∩Y =∅ .

(53)

For some ai ∈ {a1 , . . . , ak } ∩ Y , (51) implies that some rule (50) in Πsh satisfies
{ai } ∩ Y 6= ∅

22

Martin Gebser and Joohyung Lee and Yuliya Lierler

and
{ai } ∩ (X \ Y ) = ∅ .
Together with (52) and (53), this means that Y is outbound in X for Πsh . Consequently, X is an elementary loop of Πsh .
The converse of Proposition 7 does not hold even if Π is HEF. For example,
consider the following HEF program Π3 :
p; q←r
r←p
r←q .
Set {p, q, r} is not an elementary loop of Π3 since, for instance, {p} is not outbound
in {p, q, r} for Π3 . On the other hand, {p, q, r} is an elementary loop of (Π3 )sh :
p ← r, not q
q ← r, not p
r←p
r←q .

(54)

However, the following proposition shows that there is a certain subset of Πsh
whose elementary loops are also elementary loops of Π.
Proposition 8
For any disjunctive program Π, any set X of atoms, and any subset Y of X, if Y
is an elementary loop of (Πsh )X , then Y is an elementary loop of Π.
Proof. Assume that Y is an elementary loop of (Πsh )X , and not an elementary
loop of Π for the sake of contradiction. Consider any rule (49) in Π, and any proper
subset Z of Y . Since Y is not an elementary loop of Π, at least one of the following
conditions holds:
{a1 , . . . , ak } ∩ Z = ∅ ,
{a1 , . . . , ak } ∩ (Y \ Z) 6= ∅ ,
(55)
B ∩ Z 6= ∅ , or
B ∩ (Y \ Z) = ∅ .
We will show that any rule (50) in (Πsh )X obtained from (49) by shifting satisfies
at least one of the following conditions:
{ai } ∩ Z = ∅ ,
{ai } ∩ (Y \ Z) 6= ∅ ,
B ∩ Z 6= ∅ , or
B ∩ (Y \ Z) = ∅ .
This contradicts the assumption that Y is an elementary loop of (Πsh )X .
Case 1: The first, the third, or the fourth condition of (55) holds. The claim trivially
follows.
Case 2: {a1 , . . . , ak } ∩ (Y \ Z) 6= ∅. Recall that
X |= B, F, not a1 , . . . , not ai−1 , not ai+1 , not ak ,

On Elementary Loops of Logic Programs

23

by (Πsh )X construction. It follows that |{a1 , . . . , ak } ∩ X| ≤ 1. From the fact that
Y ⊆ X and Z ⊂ Y we conclude that |{a1 , . . . , ak }∩Y | ≤ 1 and {a1 , . . . , ak }∩Z = ∅,
so that {ai } ∩ Z = ∅.
For instance, for X = {p, q, r} and (Π3 )sh , we have that [(Π3 )sh ]X consists of the
last two rules in (54). Only the singletons {p}, {q}, and {r} are elementary loops
of [(Π3 )sh ]X , and clearly they are elementary loops of Π3 as well.
We are now ready to show the equivalence between an HEF program and its
shifted variant.
Theorem 5
For any HEF program Π and any set X of atoms, X is a stable model of Π iff X
is a stable model of Πsh .
Proof. From left to right: Assume that X is a stable model of Π. Then X is a
model of Πsh such that all its atoms occur in Πsh and also in [Πsh ]X . Furthermore,
by Theoremd 1 (d), we have that X satisfies LF Π (Y ) for all elementary loops Y
of Π. By Proposition 8, the elementary loops of Π include all elementary loops Y
of [Πsh ]X that are contained in X, and, since Π is HEF, it holds that ES Πsh (Y ) and
ES Π (Y ) as well as LF Πsh (Y ) and LF Π (Y ) are equivalent to each other. This implies
that X satisfies ES Πsh (Y ) for all elementary loops Y of [Πsh ]X that are contained
in X, so that X contains no elementarily unfounded sets for Πsh w.r.t. X. By
Theoremd 1 (e′ ), we conclude that X is a stable model of Πsh .
From right to left: Assume that X is a stable model of Πsh . Then X is a model
of Π such that all its atoms occur in Π. Furthermore, by Theoremd 1 (d), we have
that X satisfies LF Πsh (Y ) for all elementary loops Y of Πsh . By Proposition 7,
the elementary loops of Πsh include all elementary loops Y of Π, and, since Π is
HEF, it holds that ES Π (Y ) and ES Πsh (Y ) as well as LF Π (Y ) and LF Πsh (Y ) are
equivalent to each other. This implies that X satisfies LF Π (Y ) for all elementary
loops Y of Π. By Theoremd 1 (d), we conclude that X is a stable model of Π.
For instance, one can check that both Π2 and (Π2 )sh have {p} and {q} as their
stable models. It follows that HEF programs are not more expressive than nondisjunctive programs, so that one can regard the use of disjunctive rules in such programs as a syntactic variant. Furthermore, the problem of deciding whether a model
is stable for an HEF program is tractable, just as the same problem for a nondisjunctive program. (In the case of arbitrary disjunctive programs, it is coNP-complete
(Eiter and Gottlob 1995).) These properties were known for HCF programs, and
here we extended them to HEF programs.
In Section 3.4, we defined the notion of an elementary subgraph of a set X of
atoms for a disjunctive program Π. Theorem 3 still applies to HEF programs.
Theoremhef 3
For any HEF program Π and any nonempty set X of atoms that occur in Π, X is an
elementary loop of Π iff the elementary subgraph of X for Π is strongly connected.
Proof. From left to right: Assume that X is an elementary loop of Π, and, for
the sake of contradiction, that the elementary subgraph of X for Π is not strongly

24

Martin Gebser and Joohyung Lee and Yuliya Lierler

connected. Then there is a strongly connected component in (X, EC Π (X)) whose
atoms Y are not reached from any atom in X \ Y . Clearly Y is a nonempty proper
subset of X, and so is X \ Y . Furthermore, for every rule (12) in Π, at least one of
the following conditions holds:
|A ∩ X| > 1 ,

(56)

A ∩ (X \ Y ) = ∅ ,

(57)

B∩Y =∅ ,

(58)

B ∩ (X \ Y ) 6= ∅ .

(59)

or
However, (56) contradicts the assumption that Π is HEF. Also the fact that at
least one of the conditions (57), (58), and (59) holds contradicts the assumption
that X \ Y is outbound in X for Π.
From right to left: Assume that the elementary subgraph of X for Π is strongly
connected. For every nonempty proper subset Y of X, there is a minimum integer i ≥ 0 such that EC iΠ (X) does not contain any edge from an atom in Y to an
atom in X \ Y , but EC i+1
Π (X) contains such an edge. Thus some rule (12) in Π
satisfies
|A ∩ X| = 1 ,

(60)

A ∩ Y 6= ∅ ,

(61)

B ∩ (X \ Y ) 6= ∅ ,
and
B∩Y =∅ .
From (60) and (61), since Y ⊆ X,
A ∩ (X \ Y ) = ∅ .
This shows that Y is outbound in X for Π. We conclude that X is an elementary
loop of Π.
Although many properties of HCF programs still apply to HEF programs (e.g.,
equivalence between an HEF program and its shifted variant), the computational
complexities of recognizing them are different. While an HCF program can be recognized in polynomial time (by computing the strongly connected components of
its dependency graph), Fassetti and Palopoli (2010) showed that deciding whether
a disjunctive program is HEF is coNP-complete.10 Theorem 4 established a similar
complexity gap by showing that elementary loops are hard to verify in the case of
arbitrary disjunctive programs, while for loops it remains a question of reachability.

10

The problem was left open in (Gebser et al. 2007), one of our conference papers that this paper
extends.

On Elementary Loops of Logic Programs

25

Such elevated complexities may appear daunting, but the semantic similarities between HEF and HCF programs still exhibit that the syntactic concept of reachability merely gives a rough approximation of properties rendering disjunctive programs
more difficult than nondisjunctive ones. As noted in (Fassetti and Palopoli 2010),
identifying subclasses of (not necessarily HCF) disjunctive programs for which verifying the HEF property is tractable may be an interesting line of future research.

5 HEF Programs and Inherent Tightness
When we add more rules to a program, a stable model of the original program
remains to be a stable model of the extended program if it satisfies the new rules.
Proposition 9
For any disjunctive program Π and any model X of Π, X is a stable model of Π iff
there is a subset Π′ of Π such that X is a stable model of Π′ .
Proof. From left to right is clear.
From right to left: Assume that X is not a stable model of Π. Then some proper
subset Y of X is a model of ΠX . For each subset Π′ of Π, we have that (Π′ )X ⊆ ΠX ,
so that Y is a model of (Π′ )X and X is not a stable model of Π′ .
In view of Theoremd 1, Proposition 9 tells us that, provided that X is a model
of Π, in order to verify that X is a stable model of Π, it is sufficient to identify a
subset Π′ of Π such that X is a stable model of Π′ . Of course, one can trivially take
Π itself as the subset Π′ , but there are nontrivial subsets that deserve attention. In
fact, if Π is nondisjunctive, it is known that the subset Π′ can be further restricted
to a “tight” program (Fages 1994; Erdem and Lifschitz 2003)—the result known
as “inherently tight” (Lin and Zhao 2003) or “weakly tight” (You et al. 2003) program. In the following, we simplify these notions and show that they can be extended to HEF programs.
Recall that a loop of Π is called trivial if it consists of a single atom such that the
dependency graph of Π does not contain an edge from the atom to itself. In other
words, a loop {a} of Π is trivial if there is no rule (12) in Π such that a ∈ A ∩ B.
Definition 2 ((Lee 2005))
A disjunctive program Π is called tight if every loop of Π is trivial.
As defined previously (Apt et al. 1988; Baral and Gelfond 1994; Inoue and Sakama 1998;
Lee 2005), we call a set X of atoms supported by a disjunctive program Π if, for
every a ∈ X, there is a rule (12) in ΠX such that A ∩ X = {a}. Note that Definition 2 and the notion of support also apply to nondisjunctive programs as a special
case.
The property of inherent tightness, introduced by Lin and Zhao (2003) for the
case of nondisjunctive programs, can now be reformulated and generalized as follows.

26

Martin Gebser and Joohyung Lee and Yuliya Lierler

Definition 3
A disjunctive program Π is called inherently tight on a set X of atoms if there is a
subset Π′ of Π such that Π′ is tight and X is supported by Π′ .
In the case of nondisjunctive programs, this reformulation of inherent tightness
is similar to “well-supportedness” (Fages 1994). Furthermore, weak tightness, introduced in (You et al. 2003), is closely related to the notion of inherent tightness.
For nondisjunctive programs, it is known that their stable models can be characterized in terms of inherent tightness.
Proposition 10 ((Fages 1994; Lin and Zhao 2003; You et al. 2003))
For any nondisjunctive program Π and any model X of Π, X is a stable model of Π
iff Π is inherently tight on X.
One may wonder whether Proposition 10 can be extended to disjunctive programs
as well, given that Definition 3 readily applies to them. However, only one direction
of Proposition 10 holds in the case of arbitrary disjunctive programs.
Proposition 11
For any disjunctive program Π and any model X of Π, if Π is inherently tight on X,
then X is a stable model of Π.
Proof. Assume that Π is inherently tight on X. Then there is a subset Π′ of Π such
that Π′ is tight and X is supported by Π′ . By Proposition 2 from (Lee and Lifschitz 2003),
X is a stable model of Π′ , and, by Proposition 9, X is a stable model of Π.
To see that the converse of Proposition 11 does not hold, consider Π as follows:
p←q
q←p
p; q← .
Set {p, q} is a stable model of Π. On the other hand, since any tight subset Π′ of Π
must exclude the first or the second rule, it follows that {p, q} is not supported
by Π′ . But this means that Π is not inherently tight on {p, q}. It is also worthwhile
to note that {p, q} is an elementary loop of Π, so that Π is not HEF (and not HCF).
Indeed, the following theorem tells us that Proposition 10 can be extended to HEF
programs.
Theorem 6
For any HEF program Π and any model X of Π, X is a stable model of Π iff Π is
inherently tight on X.
Proof. From left to right: Assume that X is a stable model of Π. By Propositiond 3
(and the fact that every atom of X occurs in ΠX ), any nonempty subset Y of X
contains some elementary loop Z of ΠX that is not outbound in Y for ΠX .11 That
is, every rule (12) of ΠX satisfies at least one of the following conditions:
A∩Z = ∅ ,
11

If Y is an elementary loop of ΠX , take Z = Y .

On Elementary Loops of Logic Programs

27

B ∩ (Y \ Z) = ∅ ,

(62)

A ∩ (Y \ Z) 6= ∅ ,

(63)

or
B ∩ Z 6= ∅ .
From (63), since Y ⊆ X,
A ∩ (X \ Z) 6= ∅ .
On the other hand, since X is a stable model of Π and Z is a nonempty subset of
X, by Theoremd 1 (b), there is a rule (12) in ΠX such that
A ∩ Z 6= ∅ ,

(64)

A ∩ (X \ Z) = ∅ ,

(65)

B∩Z =∅ ,

(66)

and
so that (62) must hold, which, in combination with (66), gives us that
B∩Y =∅ .

(67)

Furthermore, since ΠX ⊆ Π, we have that Z is an elementary loop of Π. Given that
Π is HEF, from (64) and (65), we conclude that
A ∩ X = {a}

(68)

for some a ∈ Z, where a ∈ Y also holds because Z ⊆ Y . We have thus shown that,
for any nonempty subset Y of X, there is a rule (12) in ΠX such that (67) and (68)
for a ∈ Y hold. Starting from X 0 = ∅ and Π0 = ∅, when, for 1 ≤ i ≤ |X|, we let
• Y = (X \ X i−1 ),
• Πi is obtained from Πi−1 by adding some rule (12) in ΠX such that (67) and
(68) for a ∈ Y hold, and
• X i = X i−1 ∪ {a},
then X is supported by Π′ = Π|X| . Furthermore, since a rule (12) in (Πi \ Πi−1 )
satisfies A ∩ X i−1 = ∅ and B ⊆ X i−1 for every 1 ≤ i ≤ |X|, Π′ is tight by
construction, which shows that Π is inherently tight on X.
From right to left follows immediately from Proposition 11.
Since every HCF program is HEF, Theorem 6 applies also to HCF programs.
We demonstrated that, by turning to the notion of an elementary loop in place
of a loop, we obtain generalizations of results known for loops, such as Theorem 5.
This brings our attention to the following question. As a tight program can be
characterized in terms of loops, can the notion of a tight program be generalized by
referring to elementary loops instead? To answer it, let us first modify Definition 2
in the following way.

28

Martin Gebser and Joohyung Lee and Yuliya Lierler

Definition 4
A disjunctive program Π is called e-tight if every elementary loop of Π is trivial.
Since every elementary loop is a loop, it is clear that a tight program is e-tight
as well. But is the class of e-tight programs more general than the class of tight
programs? One reason why this is an interesting question to consider is because, if
so, it would lead to a generalization of Fages’ theorem (Fages 1994), which would
yield a more general class of programs for which the stable model semantics coincides with the completion semantics. However, it turns out that e-tight programs
are not more general than tight programs.
Proposition 12
For any disjunctive program Π, Π is e-tight iff Π is tight.
Proof. From left to right: Assume that Π is not tight. Then there is a minimal
nontrivial loop X of Π, and the subgraph of the dependency graph of Π induced
by X yields a simple directed cycle. That is, for any nonempty proper subset Y
of X, there is a rule (12) in Π such that A ∩ X = {a}, B ∩ X = {b} for atoms a ∈ Y ,
b ∈ X \ Y . This shows that Y is outbound in X for Π, so that X is a nontrivial
elementary loop of Π.
From right to left is clear.
This result also tells us that the notion of an inherently tight program does not
become more general by referring to elementary loops, i.e., by replacing the part
“Π′ is tight” in the statement of Definition 3 with “Π′ is e-tight.”
6 HEF Programs and Stability Checking
For a disjunctive program, the problem of deciding whether a given model is stable
is coNP-complete (Eiter and Gottlob 1995). On the other hand, in view of Theorem 5, the same problem is tractable for HEF programs. In order to check the
stability of a model in polynomial time, Leone et al. (1997) presented an operational framework, which, for HCF programs, allows for deciding whether a model
is stable. Given a disjunctive program Π and sets X, Y of atoms, they defined a
0
1
ω
sequence RΠ,X
(Y ), RΠ,X
(Y ), . . . , which converges to a limit RΠ,X
(Y ), in the following way:
0
• RΠ,X
(Y ) = Y and
i+1
i
• RΠ,X (Y ) is obtained by removing every atom a from RΠ,X
(Y ) such that some
i
rule (12) in ΠX satisfies A ∩ (X ∪ {a}) = {a} and B ∩ RΠ,X
(Y ) = ∅.12

The disjunctive rules considered in (Leone et al. 1997) do not admit double negations in rule bodies, but its (dis)use merely affects conditions like X |= B, F (or
X 6|= B, F ) determining ΠX , while it is inconsequential otherwise. Hence, the following results remain valid for disjunctive programs whose rules are of the form (12).
12

If Y is a subset of X, the condition “A ∩ (X ∪ {a}) = {a}” can be replaced with “A ∩ X = {a}”
without altering Rω
Π,X (Y ).

On Elementary Loops of Logic Programs

29

Proposition 13 ((Leone et al. 1997, Lemma 6.4))
For any disjunctive program Π and any sets X, Y of atoms that occur in Π, all
ω
subsets of Y that are unfounded by Π w.r.t. X are contained in RΠ,X
(Y ).
Proposition 14 ((Leone et al. 1997, Proposition 6.5))
ω
For any disjunctive program Π and any set X of atoms that occur in Π, if RΠ,X
(X) = ∅,
then X contains no nonempty unfounded sets for Π w.r.t. X.
Proposition 15 ((Leone et al. 1997, Theorem 6.9))
For any HCF program Π and any set X of atoms that occur in Π, X contains no
ω
nonempty unfounded sets for Π w.r.t. X iff RΠ,X
(X) = ∅.
For a model X of Π, in view of Theoremd 1 (b′ ), Proposition 14 tells us that X
ω
is a stable model of Π if RΠ,X
(X) = ∅. As stated in Proposition 15, the converse
also holds if Π is HCF. We below extend this result to HEF programs.
Proposition 16
For any HEF program Π, any set X of atoms, and any subset Y of X whose atoms
ω
ω
occur in Π, if RΠ,X
(Y ) 6= ∅, then RΠ,X
(Y ) contains an elementary loop Z of Π
that is unfounded by Π w.r.t. X.
ω
Proof. Assume that RΠ,X
(Y ) 6= ∅. Then, for every rule (12) of ΠX , at least one
of the following conditions holds:

|A ∩ X| > 1 ,

(69)

ω
A ∩ RΠ,X
(Y ) = ∅ ,

(70)

ω
B ∩ RΠ,X
(Y ) 6= ∅ .

(71)

or
d

ω
RΠ,X
(Y

By Proposition 3,
) contains some elementary loop Z of Π that is not
ω
outbound in RΠ,X
(Y ) for Π.13 For the sake of contradiction, assume that Z is not
unfounded by Π w.r.t. X. Then there is a rule (12) in ΠX such that
A ∩ Z 6= ∅ ,

(72)

A ∩ (X \ Z) = ∅ ,

(73)

B∩Z =∅ .

(74)

and
From (73), since

ω
RΠ,X
(Y

) ⊆ X,
ω
A ∩ (RΠ,X
(Y ) \ Z) = ∅ ,

which, in combination with (72), (74), and the fact that Z is not outbound in
ω
RΠ,X
(Y ) for Π, gives us that
ω
B ∩ (RΠ,X
(Y ) \ Z) = ∅ .

13

ω
If Rω
Π,X (Y ) is an elementary loop of Π, take Z = RΠ,X (Y ).

(75)

30

Martin Gebser and Joohyung Lee and Yuliya Lierler

From (74) and (75), we conclude that (71) does not hold. Furthermore, since
ω
Z ⊆ RΠ,X
(Y ), (72) implies that (70) does not hold. Hence, (69) must hold, which,
in combination with (73), gives us that
|A ∩ Z| > 1 .
But since Z is an elementary loop of Π, this contradicts that Π is HEF.
We are now ready to generalize Proposition 15 to HEF programs.
Theorem 7
For any HEF program Π and any set X of atoms that occur in Π, X contains no
ω
nonempty unfounded sets for Π w.r.t. X iff RΠ,X
(X) = ∅.
Proof. From left to right follows immediately from Proposition 16.
From right to left follows immediately from Proposition 14.
Regarding the models of HEF programs, we derive the following corollary.
Corollary 2
For any HEF program Π and any set X of atoms that occur in Π, X is a stable
ω
model of Π iff X is a model of Π such that RΠ,X
(X) = ∅.
Proof. Both directions follow immediately from Theoremd 1 (b′ ) and Theorem 7.
For instance, reconsider Π2 from Section 4, which is HEF, but not HCF. Hence,
ω
Corollary 2 applies, but Proposition 15 does not apply. Indeed, since RΠ
(X) = X
2 ,X
for (non-stable) model X = {p, q, r} of Π2 , Corollary 2 allows us to conclude that
X is not a stable model of Π2 . On the other hand, for model {p} of Π2 , we have
ω
that RΠ
({p}) = ∅, which implies that {p} is a stable model of Π2 .
2 ,{p}
In Section 3.3, we defined the notion of an elementarily unfounded set and showed
that it coincides with a minimal nonempty unfounded set. Thus stability checking
can be cast into the problem of ensuring the absence of elementarily unfounded sets.
Since every elementarily unfounded set is a loop, it is clearly contained in a maximal
loop, which allows us to modularize the consideration of (elementarily) unfounded
sets. The idea of using maximal loops for partitioning a program and confining
stability checking to subprograms was already exploited by Leone et al. (1997) and
Koch et al. (2003). In fact, for a disjunctive program Π and a set X of atoms, Leone
et al. (1997) showed how stability can be checked separately for maximal loops of Π,
and Koch et al. (2003) developed this idea further by considering maximal loops
of the smaller program ΠX,RωΠ,X (X) . We below describe a notion called “bounding
loops,” which go beyond such maximal loops.
For a disjunctive program Π and a set X of atoms, we say that a subset Y of X is
a bounding loop of Π w.r.t. X if Y is maximal among all subsets Z of X such that
ω
Z is a loop of ΠX,Z and RΠ,X
(Z) = Z. Note that there are two crucial differences
between bounding loops and elementarily unfounded sets. First, a bounding loop Y
of Π w.r.t. X is not necessarily an elementary loop of ΠX,Y . Next, it does not
need to be unfounded by Π w.r.t. X. To see this, observe that X = {p, q, r} is a

On Elementary Loops of Logic Programs

31

bounding loop of Π2 w.r.t. X that is not (elementarily) unfounded by Π2 w.r.t. X.
Furthermore, one can check that {p, r} and {q, r} are (elementarily) unfounded
by Π2 w.r.t. X, and thus Propositiond 5 tells us that X is not an elementary loop
of (Π2 )X,X .
The following two propositions describe properties of bounding loops that are
similar to those of maximal loops, as used in (Leone et al. 1997; Koch et al. 2003).
Proposition 17
For any disjunctive program Π and any set X of atoms, all bounding loops of Π
w.r.t. X are mutually disjoint.
Proof. Let Y1 , Y2 be subsets of X such that Y1 is a loop of ΠX,Y1 , Y2 is a loop
ω
ω
(Y1 ) = Y1 , and RΠ,X
(Y2 ) = Y2 . If Y1 ∩ Y2 6= ∅, the fact that
of ΠX,Y2 , RΠ,X
ΠX,Y1 ∪ ΠX,Y2 ⊆ ΠX,Y1 ∪Y2 implies that Y1 ∪ Y2 is a loop of ΠX,Y1 ∪Y2 . Furtherω
ω
more, since RΠ,X
(Y1 ) = Y1 and RΠ,X
(Y2 ) = Y2 , for any rule (12) of ΠX such that
A ∩ (Y1 ∪ Y2 ) 6= ∅ and B ∩ (Y1 ∪ Y2 ) = ∅, we have that |A ∩ X| > 1, from which
ω
we conclude that RΠ,X
(Y1 ∪ Y2 ) = Y1 ∪ Y2 . Since bounding loops of Π w.r.t. X are
ω
maximal among all subsets Z of X such that Z is a loop of ΠX,Z and RΠ,X
(Z) = Z,
this shows that they must be mutually disjoint.
Proposition 18
For any disjunctive program Π and any set X of atoms that occur in Π, every
elementarily unfounded set for Π w.r.t. X is a singleton or contained in some
bounding loop of Π w.r.t. X.
Proof. Assume that Y is an elementarily unfounded set for Π w.r.t. X that is not
a singleton. From the definition of an elementarily unfounded set, it follows that
Y is a loop of ΠX,Y and a subset of X. Since Y is also unfounded by Π w.r.t. X,
ω
by Proposition 13, we have that RΠ,X
(Y ) = Y . This shows that Y is contained in
ω
some maximal subset Z of X such that Z is a loop of ΠX,Z and RΠ,X
(Z) = Z.
Proposition 17 and Proposition 18 tell us that checking the absence of elementarily unfounded sets can be accomplished separately for bounding loops.
Proposition 19
For any disjunctive program Π and any model X of Π, X is a stable model of Π iff
• X is supported by Π and
• no bounding loop of Π w.r.t. X contains a nonempty unfounded set for Π
w.r.t X.
Proof. From left to right follows immediately from Theoremd 1 (b′ ) (and the fact
that every atom of X occurs in Π).
From right to left: Assume that X is not a stable model of Π but supported by Π.
Then, by Theoremd 1 (e′ ), X contains some elementarily unfounded set Y for Π
w.r.t. X. If Y is not a singleton, by Proposition 18, Y is contained in some bounding loop of Π w.r.t. X. Otherwise, if Y is a singleton, the assumption that X is
supported by Π implies that there is a rule (12) in ΠX,Y such that A ∩ X = Y , so

32

Martin Gebser and Joohyung Lee and Yuliya Lierler

that Y is a loop of ΠX,Y . Since Y is unfounded by Π w.r.t. X, by Proposition 13,
ω
we also have that RΠ,X
(Y ) = Y . This shows that Y is contained in some maximal
ω
subset Z of X such that Z is a loop of ΠX,Z and RΠ,X
(Z) = Z.
As it is easy to check that X is supported by Π, Proposition 19 tells us that the
investigation of bounding loops constitutes the hard part of stability checking. But
this is not due to the hardness of identifying them. In fact, the following method
can be used to compute all bounding loops Z of Π w.r.t. X in polynomial time:
1. Let Y = X.
ω
ω
2. Let Z = RΠ,X
(Y ).
(Note that Z = RΠ,X
(Z).)
3. If Z is a loop of ΠX,Z , then mark Z as a bounding loop of Π w.r.t. X.
Otherwise, proceed with Step 2 for every maximal loop Y of ΠX,Z that is
contained in Z.
The soundness of this approach is straightforward, given that operator R is monoω
ω
tone, i.e., RΠ,X
(Z) ⊆ RΠ,X
(Y ) if Z ⊆ Y (used in Step 2), and likewise that
ΠX,Y ⊆ ΠX,Z if Y ⊆ Z (used in Step 3).
For illustration, consider the following program Π4 :
p←r
q←r
r ← p, q

s←p
s←t
t ← s, u

p; q←u
s; t←q
r ; u←t

u; v← .

For X = {p, q, r, s, t, u}, it holds that (Π4 )X,X = Π4 and also that X is a loop
ω
of Π4 . However, Y = RΠ
(X) = {p, q, r, s, t} 6= X, so that X is not a bounding
4 ,X
loop of Π4 w.r.t. X. On the other hand, Y is not a loop of (Π4 )X,Y , which does
not include the last two rules where u occurs in the head. Rather, Z = {p, q, r} and
Z ′ = {s, t} are the maximal loops of (Π4 )X,Y that are contained in Y . In view of
ω
the rules in the second column, RΠ
(Z ′ ) = ∅, which shows that no subset of Z ′
4 ,X
ω
is a bounding loop of Π4 w.r.t. X. For Z = {p, q, r}, we obtain RΠ
(Z) = Z, and
4 ,X
Z is also a loop of (Π4 )X,Z (due to the rules in the first column). That is, Z is the
single bounding loop of Π4 w.r.t. X.
Let us compare this outcome with the ones of previous methods for modularizing
stability checking. Since the approach described in (Leone et al. 1997) considers
maximal loops of the original program and X = {p, q, r, s, t, u} is a (maximal) loop
of Π4 , it cannot be used to decompose X, and the only applicable simplification is
ω
to remove u by means of R, that is, Y = RΠ
(X) = {p, q, r, s, t}. The approach in
4 ,X
(Koch et al. 2003) considers the maximal loops of ΠX,RωΠ,X (X) , which, for (Π4 )X,Y ,
gives Z = {p, q, r} and Z ′ = {s, t}. As described in (Koch et al. 2003), since the
subprograms (Π4 )X,Z and (Π4 )X,Z ′ are not HCF, they are not simplified any further and used to separately check for a nonempty unfounded subset of Z or Z ′ ,
respectively. Unlike this, the notion of a bounding loop allowed us to eliminate all
subsets of Z ′ as potential nonempty unfounded sets.
Turning back to HEF programs, from Proposition 16, we derive the following
proposition for a subprogram ΠX,Y associated with a bounding loop Y of Π w.r.t. X.
Proposition 20

On Elementary Loops of Logic Programs

33

For any disjunctive program Π, any set X of atoms, and any bounding loop Y
of Π w.r.t. X, if ΠX,Y is HEF, then Y contains a nonempty unfounded set for Π
w.r.t. X.
Proof. Assume that ΠX,Y is HEF. From the definition of a bounding loop, it folω
ω
lows that all atoms of Y occur in ΠX,Y and that Y = RΠ,X
(Y ) = R(Π
(Y ) ⊆ X.
X,Y ),X
ω
By Proposition 16, we conclude that R(ΠX,Y ),X (Y ) contains an elementary loop Z
of ΠX,Y that is unfounded by ΠX,Y w.r.t. X. From the definition of ΠX,Y and since
Z is contained in Y , we conclude that Z is also unfounded by Π w.r.t. X.
Proposition 20 tells us that the existence of a bounding loop Y of Π w.r.t. X
whose associated subprogram ΠX,Y is HEF is already sufficient to conclude that X
is not a stable model of Π. Reconsidering the bounding loop Z = {p, q, r} of Π4
w.r.t. X = {p, q, r, s, t, u}, we have that (Π4 )X,Z , consisting of the rules in the first
column along with the disjunctive rule containing p and q in the head, is HEF
(neither {p, q} nor {p, q, r} is an elementary loop of (Π4 )X,Z ). Thus X is not a
stable model of Π4 . Indeed, Z contains two (elementarily) unfounded sets for Π4
w.r.t. X: {p, r} and {q, r}.
7 Conclusion
The notion of an elementary loop and its properties provide useful insights into
the concept of a loop and the relationship between nondisjunctive programs and
disjunctive programs. By turning to the notion of an elementary loop in place of a
loop, we could strengthen the theorem by Lin and Zhao (2004), its generalization
to disjunctive programs (Lee and Lifschitz 2003), and the main theorem (for programs in canonical form) from (Lee 2005). The semantic (e.g., Theoremd 2) and
complexity-theoretic (e.g., Theorem 4) properties of elementary loops indicate their
close relationship to unfounded sets. Compared with loops, elementary loops provide a deeper understanding of the internal structure of unfounded sets. In fact, we
have shown that loop formulas of non-elementary loops are unnecessary for checking the stability of a model. It is an interesting open question whether this result
can be used to improve computation performed by answer set solvers that calculate
loop formulas, such as assat, claspd, and cmodels.
A method to identify an elementarily unfounded set for an HEF program was
presented in (Gebser et al. 2007).14 An orthogonal approach is implemented in
claspd: it greedily adds atoms a to an unfounded set Y if Y ∪ {a} stays unfounded
and has a shorter loop formula than Y . However, the potential of unfounded set
“optimization” has not been studied in-depth so far, and the theoretical foundations
laid here may be useful for future investigations in this direction. Regarding nondisjunctive programs, elementary loops can be distinct from loops of programs called
“binary” (Janhunen 2006). Moreover, modularity aspects of disjunctive stable models (Janhunen et al. 2009), which are closely related to loop formulas (Lemma 5.4
from (Janhunen et al. 2009)), can be refined by referring to elementary loops in
14

It is omitted in this paper for brevity.

34

Martin Gebser and Joohyung Lee and Yuliya Lierler

place of loops. Lifting elementary loops to first-order programs, as already done for
loops (Chen et al. 2006; Lee and Meng 2008), may also be a direction to explore.
The notion of an HEF program is a strict generalization of the notion of an
HCF program. On the one hand, nice properties of HCF programs still apply to
HEF programs. In particular, their inherent tightness on stable models grants the
soundness of shifting head atoms into the body as well as the possibility of performing stability checks in polynomial time. This however implies that a disjunctive program encoding an instance of a ΣP
2 -hard problem is unlikely to be HEF.
On the other hand, recognizing elementary loops and verifying the HEF property
are both intractable in the case of arbitrary disjunctive programs, but tractable
for nondisjunctive and HCF programs. This parallels the complexity of stability
checking (Eiter and Gottlob 1995), and it also tells us that the inherent complexities of computational tasks dealing with elementary loops tightly correlate to the
fragment of disjunctive programs under consideration. As the latter does not apply
to recognizing loops or verifying the HCF property, the notion of an HEF program
more precisely renders what makes arbitrary disjunctive programs more difficult
than nondisjunctive programs. Whether this admits (syntactic) characterizations
of yet unknown subclasses of disjunctive programs for which verifying the HEF
property is tractable is an interesting open question.
Acknowledgments
We are grateful to Selim Erdoğan, Tomi Janhunen, Dan Lessin, Vladimir Lifschitz,
Torsten Schaub, Jicheng Zhao, and the anonymous referees of (Gebser et al. 2006;
Gebser et al. 2007) and this paper for their useful comments. Martin Gebser was
partially supported by the German Research Foundation under Grant SCHA 550/8-1.
Joohyung Lee was partially supported by the National Science Foundation under Grant IIS-0916116 and by the Office of the Director of National Intelligence
(ODNI), Intelligence Advanced Research Projects Activity (IARPA), through US
army. Yuliya Lierler was partially supported by the National Science Foundation
under Grant IIS-0712113 and by a 2010 Computing Innovation Fellowship.
References
Apt, K., Blair, H., and Walker, A. 1988. Towards a theory of declarative knowledge.
In Foundations of Deductive Databases and Logic Programming, J. Minker, Ed. Morgan
Kaufmann, 89–148.
Baral, C. and Gelfond, M. 1994. Logic programming and knowledge representation.
Journal of Logic Programming 19,20, 73–148.
Ben-Eliyahu, R. and Dechter, R. 1994. Propositional semantics for disjunctive logic
programs. Annals of Mathematics and Artificial Intelligence 12, 53–87.
Chen, Y., Lin, F., Wang, Y., and Zhang, M. 2006. First-order loop formulas for normal
logic programs. In Proceedings of the Tenth International Conference on Principles of
Knowledge Representation and Reasoning (KR’06), P. Doherty, J. Mylopoulos, and
C. Welty, Eds. AAAI Press, 298–307.
Clark, K. 1978. Negation as failure. In Logic and Data Bases, H. Gallaire and J. Minker,
Eds. Plenum Press, New York, 293–322.

On Elementary Loops of Logic Programs

35

Drescher, C., Gebser, M., Grote, T., Kaufmann, B., König, A., Ostrowski, M.,
and Schaub, T. 2008. Conflict-driven disjunctive answer set solving. In Proceedings of
the Eleventh International Conference on Principles of Knowledge Representation and
Reasoning (KR’08), G. Brewka and J. Lang, Eds. AAAI Press, 422–432.
Eiter, T. and Fink, M. 2003. Uniform equivalence of logic programs under the stable
model semantics. In Proceedings of the Nineteenth International Conference on Logic
Programming (ICLP’03), C. Palamidessi, Ed. Springer-Verlag, 224–238.
Eiter, T. and Gottlob, G. 1995. On the computational cost of disjunctive logic programming: Propositional case. Annals of Mathematics and Artificial Intelligence 15, 3-4,
289–323.
Erdem, E. and Lifschitz, V. 2003. Tight logic programs. Theory and Practice of Logic
Programming 3, 499–518.
Fages, F. 1994. Consistency of Clark’s completion and existence of stable models. Journal
of Methods of Logic in Computer Science 1, 51–60.
Fassetti, F. and Palopoli, L. 2010. On the complexity of identifying head elementary
set free programs. Theory and Practice of Logic Programming 10(1), 113–123.
Ferraris, P., Lee, J., and Lifschitz, V. 2007. A new perspective on stable models. In
Proceedings of the Twentieth International Joint Conference on Artificial Intelligence
(IJCAI’07). 372–379.
Ferraris, P., Lee, J., and Lifschitz, V. 2011. Stable models and circumscription.
Artificial Intelligence 175, 236–263.
Gebser, M., Lee, J., and Lierler, Y. 2006. Elementary sets for logic programs. In
Proceedings of the Twenty-first AAAI Conference on Artificial Intelligence (AAAI’06).
Gebser, M., Lee, J., and Lierler, Y. 2007. Head-elementary-set-free logic programs.
In Procedings of the Ninth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’07). 149–161.
Gebser, M. and Schaub, T. 2005. Loops: Relevant or redundant? In Proceedings of the
Eighth International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR’05). 53–65.
Gebser, M., Schaub, T., Tompits, H., and Woltran, S. 2008. Alternative characterizations for program equivalence under answer-set semantics based on unfounded
sets. In Proceedings of the Fifth International Symposium on Foundations of Information and Knowledge Systems (FoIKS’08), S. Hartmann and G. Kern-Isberner, Eds.
Springer-Verlag, 24–41.
Gelfond, M., Lifschitz, V., Przymusińska, H., and Truszczyński, M. 1991. Disjunctive defaults. In Proceedings of the Second International Conference on Principles
of Knowledge Representation and Reasoning (KR’91), J. Allen, R. Fikes, and E. Sandewall, Eds. 230–237.
Giunchiglia, E., Lierler, Y., and Maratea, M. 2004. SAT-based answer set programming. In Proceedings of the Nineteenth AAAI Conference on Artificial Intelligence
(AAAI). 61–66.
Inoue, K. and Sakama, C. 1998. Negation as failure in the head. Journal of Logic
Programming 35, 39–78.
Janhunen, T. 2006. Some (in)translatability results for normal logic programs and propositional theories. Journal of Applied Non-Classical Logics 16, 1-2, 35–86.
Janhunen, T., Niemelä, I., Seipel, D., Simons, P., and You, J.-H. 2006. Unfolding
partiality and disjunctions in stable model semantics. ACM Transactions on Computational Logic 7, 1, 1–37.
Janhunen, T., Oikarinen, E., Tompits, H., and Woltran, S. 2009. Modularity aspects of disjunctive stable models. Journal of Artificial Intelligence Research 35, 813–
857.

36

Martin Gebser and Joohyung Lee and Yuliya Lierler

Koch, C., Leone, N., and Pfeifer, G. 2003. Enhancing disjunctive logic programming
systems by SAT checkers. Artificial Intelligence 151, 177–212.
Lee, J. 2004. Nondefinite vs. definite causal theories. In Proceedings of the Seventh
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04). 141–153.
Lee, J. 2005. A model-theoretic counterpart of loop formulas. In Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI’05). Professional
Book Center, 503–508.
Lee, J. and Lifschitz, V. 2003. Loop formulas for disjunctive logic programs. In
Proceedings of Nineteenth International Conference on Logic Programming (ICLP’03).
451–465.
Lee, J. and Lin, F. 2006. Loop formulas for circumscription. Artificial Intelligence 170, 2,
160–185.
Lee, J. and Meng, Y. 2008. On loop formulas with variables. In Proceedings of
the Eleventh International Conference on Knowledge Representation and Reasoning
(KR’08). 444–453.
Lee, J. and Meng, Y. 2009. On reductive semantics of aggregates in answer set programming. In Procedings of the Tenth International Conference on Logic Programming
and Nonmonotonic Reasoning (LPNMR’09). 182–195.
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S., and Scarcello, F. 2006. The dlv system for knowledge representation and reasoning. ACM
Transactions on Computational Logic 7, 3.
Leone, N., Rullo, P., and Scarcello, F. 1997. Disjunctive stable models: Unfounded
sets, fixpoint semantics, and computation. Information and Computation 135(2), 69–
112.
Lierler, Y. 2005. cmodels: SAT-based disjunctive answer set solver. In Proceedings of
the Eighth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’05). 447–452.
Lifschitz, V., Tang, L. R., and Turner, H. 1999. Nested expressions in logic programs.
Annals of Mathematics and Artificial Intelligence 25, 369–389.
Lifschitz, V. and Razborov, A. 2006. Why are there so many loop formulas? ACM
Transactions on Computational Logic 7, 2, 261–268.
Lin, F. and Zhao, J. 2003. On tight logic programs and yet another translation from normal logic programs to propositional logic. In Proceedings of the Eighteenth International
Joint Conference on Artificial Intelligence (IJCAI’03). 853–858.
Lin, F. and Zhao, Y. 2004. ASSAT: Computing answer sets of a logic program by SAT
solvers. Artificial Intelligence 157, 115–137.
Liu, L. and Truszczynski, M. 2006. Properties and applications of programs with
monotone and convex constraints. Journal of Artificial Intelligence Research 27, 299–
334.
Saccá, D. and Zaniolo, C. 1990. Stable models and non-determinism in logic programs
with negation. In Proceedings of the Ninth ACM Symposium on Principles of Database
Systems (PODS). 205–217.
You, J.-H. and Liu, G. 2008. Loop formulas for logic programs with arbitrary constraint
atoms. In Proceedings of the Twenty-third AAAI Conference on Artificial Intelligence
(AAAI’08). 584–589.
You, J.-H., Yuan, L.-Y., and Zhang, M. 2003. On the equivalence between answer sets
and models of completion for nested logic programs. In Proceedings of the Eighteenth
International Joint Conference on Artificial Intelligence (IJCAI’03). 859–866.

Two New Definitions of Stable Models of Logic
Programs with Generalized Quantifiers
Joohyung Lee and Yunsong Meng

arXiv:1301.1393v1 [cs.LO] 8 Jan 2013

School of Computing, Informatics and Decision Systems Engineering
Arizona State University, Tempe, USA

Abstract. We present alternative definitions of the first-order stable model semantics and its extension to incorporate generalized quantifiers by referring to the
familiar notion of a reduct instead of referring to the SM operator in the original
definitions. Also, we extend the FLP stable model semantics to allow generalized
quantifiers by referring to an operator that is similar to the SM operator. For a
reasonable syntactic class of logic programs, we show that the two stable model
semantics of generalized quantifiers are interchangeable.

1

Introduction

Most versions of the stable model semantics involve grounding. For instance, according
to the FLP semantics from [1; 2], assuming that the domain is {−1, 1, 2}, program
p(2) ← ınot SUMhx : p(x)i < 2
p(−1) ← SUMhx : p(x)i > −1
p(1) ← p(−1)

(1)

is identified with its ground instance w.r.t the domain:
p(2) ← ınot SUMh{−1 : p(−1), 1 : p(1), 2 : p(2)}i < 2
p(−1) ← SUMh{−1 : p(−1), 1 : p(1), 2 : p(2)}i > −1
p(1) ← p(−1) .

(2)

As described in [1], it is straightforward to extend the definition of satisfaction to ground
aggregate expressions. For instance, set {p(−1), p(1)} does not satisfy the body of the
first rule of (2), but satisfies the bodies of the other rules. The FLP reduct of program (2)
relative to {p(−1), p(1)} consists of the last two rules, and {p(−1), p(1)} is its minimal
model. Indeed, {p(−1), p(1)} is the only FLP answer set of program (2).
On the other hand, according to the semantics from [3], program (2) is identified
with some complex propositional formula containing nested implications:



¬ (p(2) → p(−1)∨p(1)) ∧ (p(1)∧p(2) → p(−1)) ∧ (p(−1)∧p(1)∧p(2) → ⊥) → p(2)



∧ p(−1) → p(1)∨p(2) → p(−1)


∧ p(−1) → p(1) .

132

J. Lee and Y. Meng

Under the stable model semantics of propositional formulas [3], this formula has two
answer sets: {p(−1), p(1)} and {p(−1), p(1), p(2)}. The relationship between the FLP
and the Ferraris semantics was studied in [4; 5].
Unlike the FLP semantics, the definition from [3] is not applicable when the domain is infinite because it would require the representation of an aggregate expression
to involve “infinite” conjunctions and disjunctions. This limitation was overcome in
the semantics presented in [4; 6], which extends the first-order stable model semantics
from [7; 8] to incorporate aggregate expressions. Recently, it was further extended to
formulas involving generalized quantifiers [9], which provides a unifying framework
of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic
dl-atoms [11].
In this paper, we revisit the first-order stable model semantics and its extension to
incorporate generalized quantifiers. We provide an alternative, equivalent definition of a
stable model by referring to grounding and reduct instead of the SM operator. Our work
is inspired by the work of Truszczynski [12], who introduces infinite conjunctions and
disjunctions to account for grounding quantified sentences. Our definition of a stable
model can be viewed as a reformulation and a further generalization of his definition
to incorporate generalized quantifiers. We define grounding in the same way as done in
the FLP semantics, but define a reduct differently so that the semantics agrees with the
one by Ferraris [3]. As we explain in Section 3.3, our reduct of program (2) relative to
{p(−1), p(1)} is
⊥ ← ⊥
p(−1) ← SUMh{−1 : p(−1), 1 : p(1), 2 : ⊥)i} > −1
p(1) ← p(−1) ,

(3)

which is the program obtained from (2) by replacing each maximal subformula that
is not satisfied by {p(−1), p(1)} with ⊥. Set {p(−1), p(1)} is an answer set of program (1) as it is a minimal model of the reduct. Likewise the reduct relative to {p(−1), p(1), p(2)}
is
p(2) ← >
p(−1) ← SUM{h−1 : p(−1), 1 : p(1), 2 : p(2)i} > −1
p(1) ← p(−1)
and {p(−1), p(1), p(2)} is a minimal model of the program. The semantics is more
direct than the one from [3] as it does not involve the complex translation into a propositional formula.
While the FLP semantics in [1] was defined in the context of logic programs with aggregates, it can be straightforwardly extended to allow other “complex atoms.” Indeed,
the FLP reduct is the basis of the semantics of HEX programs [13]. In [14], the FLP
reduct was applied to provide a semantics of nonmonotonic dl-programs [11]. In [5],
the FLP semantics of logic programs with aggregates was generalized to the first-order
level. That semantics is defined in terms of the FLP operator, which is similar to the SM
operator. This paper further extends the definition to allow generalized quantifiers.
By providing an alternative definition in the way that the other semantics was defined, this paper provides a useful insight into the relationship between the first-order

Two New Definitions of Stable Models of LPs with Generalized Quantifiers

133

stable model semantics and the FLP stable model semantics for programs with generalized quantifiers. While the two semantics behave differently in the general case, we
show that they coincide on some reasonable syntactic class of logic programs. This
implies that an implementation of one of the semantics can be viewed as an implementation of the other semantics if we limit attention to that class of logic programs.
The paper is organized as follows. Section 2 reviews the first-order stable model
semantics and its equivalent definition in terms of grounding and reduct, and Section 3
extends that definition to incorporate generalized quantifiers. Section 4 provides an alternative definition of the FLP semantics with generalized quantifiers via a translation
into second-order formulas. Section 5 compares the FLP semantics and the first-order
stable model semantics in the general context of programs with generalized quantifiers.

2

First-Order Stable Model Semantics

2.1

Review of First-Order Stable Model Semantics

This review follows [8], a journal version of [7], which distinguishes between intensional and non-intensional predicates.
A formula is defined the same as in first-order logic. A signature consists of function constants and predicate constants. Function constants of arity 0 are also called
object constants. We assume the following set of primitive propositional connectives
and quantifiers:
⊥, >, ∧, ∨, →, ∀, ∃ .
¬F is an abbreviation of F → ⊥, and F ↔ G stands for (F → G) ∧ (G → F ). We
distinguish between atoms and atomic formulas as follows: an atom of a signature σ
is an n-ary predicate constant followed by a list of n terms that can be formed from
function constants in σ and object variables; atomic formulas of σ are atoms of σ,
equalities between terms of σ, and the 0-place connectives ⊥ and >.
The stable models of F relative to a list of predicates p = (p1 , . . . , pn ) are defined
via the stable model operator with the intensional predicates p, denoted by SM[F ; p].1
Let u be a list of distinct predicate variables u1 , . . . , un . By u = p we denote the
conjunction of the formulas ∀x(ui (x) ↔ pi (x)), where x is a list of distinct object
variables of the same length as the arity of pi , for all i = 1, . . . , n. By u ≤ p we denote
the conjunction of the formulas ∀x(ui (x) → pi (x)) for all i = 1, . . . , n, and u < p
stands for (u ≤ p) ∧ ¬(u = p). For any first-order sentence F , expression SM[F ; p]
stands for the second-order sentence
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where F ∗ (u) is defined recursively:
– pi (t)∗ = ui (t) for any list t of terms;
– F ∗ = F for any atomic formula F that does not contain members of p;
– (F ∧ G)∗ = F ∗ ∧ G∗ ;
1

The intensional predicates p are the predicates that we “intend to characterize” by F .

134

–
–
–
–

J. Lee and Y. Meng

(F ∨ G)∗ = F ∗ ∨ G∗ ;
(F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
(∀xF )∗ = ∀xF ∗ ;
(∃xF )∗ = ∃xF ∗ .

A model of a sentence F (in the sense of first-order logic) is called p-stable if it
satisfies SM[F ; p].
Example 1 Let F be sentence ∀x(¬p(x) → q(x)), and let I be an interpretation whose
universe is the set of all nonnegative integers N, and pI (n) = FALSE, q I (n) = TRUE
for all n ∈ N. Section 2.4 of [8] tells us that I satisfies SM[F ; pq].
2.2

Alternative Definition of First-Order Stable Models via Reduct

For any signature σ and its interpretation I, by σ I we mean the signature obtained
from σ by adding new object constants ξ  , called object names, for every element ξ in
the universe of I. We identify an interpretation I of σ with its extension to σ I defined
by I(ξ  ) = ξ.
In order to facilitate defining a reduct, we provide a reformulation of the standard
semantics of first-order logic via “a ground formula w.r.t. an interpretation.”
Definition 1. For any interpretation I of a signature σ, a ground formula w.r.t. I is
defined recursively as follows.
– p(ξ1 , . . . , ξn ), where p is a predicate constant of σ and ξi are object names of σ I ,
is a ground formula w.r.t. I;
– > and ⊥ are ground formulas w.r.t. I;
– If F and G are ground formulas w.r.t. I, then F ∧ G, F ∨ G, F → G are ground
formulas w.r.t. I;
– If S is a set of pairs of the form ξ : F where ξ  is an object name in σ I and F is a
ground formula w.r.t. I, then ∀(S) and ∃(S) are ground formulas w.r.t. I.
The following definition describes a process that turns any first-order sentence into
a ground formula w.r.t. an interpretation:
Definition 2. Let F be any first-order sentence of a signature σ, and let I be an interpretation of σ whose universe is U . By grI [F ] we denote the ground formula w.r.t. I,
which is obtained by the following process:
– grI [p(t1 , . . . , tn(
)] = p((tI1 ) , . . . , (tIn ) );
> if tI1 = tI2 , and
– grI [t1 = t2 ] =
⊥ otherwise;
– grI [>] = >; grI [⊥] = ⊥;
– grI [F  G] = grI [F ]  grI [G] ( ∈ {∧, ∨, →});
– grI [QxF (x)] = Q({ξ : grI [F (ξ  )] | ξ ∈ U }) (Q ∈ {∀, ∃}).
Definition 3. For any interpretation I and any ground formula F w.r.t. I, the truth
value of F under I, denoted by F I , is defined recursively as follows.

Two New Definitions of Stable Models of LPs with Generalized Quantifiers

135

p(ξ1 , . . . , ξn )I = pI (ξ1 , . . . , ξn );
>I = TRUE; ⊥I = FALSE;
(F ∧ G)I = TRUE iff F I = TRUE and GI = TRUE;
(F ∨ G)I = TRUE iff F I = TRUE or GI = TRUE;
(F → G)I = TRUE iff GI = TRUE whenever F I = TRUE;
∀(S)I = TRUE iff the set {ξ | ξ : F (ξ  ) ∈ S and F (ξ  )I = TRUE} is the same as
the universe of I;
– ∃(S)I = TRUE iff the set {ξ | ξ : F (ξ  ) ∈ S and F (ξ  )I = TRUE} is not empty.

–
–
–
–
–
–

We say that I satisfies F , denoted I |= F , if F I = TRUE.
Example 1 continued (I). grI [F ] is ∀({n: (¬p(n ) → q(n )) | n ∈ N}). Clearly, I
satisfies grI [F ].
An interpretation I of a signature σ can be represented as a pair hI f unc , I pred i,
where I f unc is the restriction of I to the function constants of σ, and I pred is the set of
atoms, formed using predicate constants from σ and the object names from σ I , which
are satisfied by I. For example, interpretation I in Example 1 can be represented as
hI f unc , {q(n ) | n ∈ N}i, where I f unc maps each integer to itself.
The following proposition is immediate from the definitions:
Proposition 1. Let σ be a signature that contains finitely many predicate constants, let
σ pred be the set of predicate constants in σ, let I = hI f unc , I pred i be an interpretation
of σ, and let F be a first-order sentence of σ. Then I |= F iff I pred |= grI [F ].
The introduction of the intermediate form of a ground formula w.r.t. an interpretation helps us define a reduct.
Definition 4. For any ground formula F w.r.t. I, the reduct of F relative to I, denoted
by F I , is obtained by replacing each maximal subformula that is not satisfied by I
with ⊥. It can also be defined recursively as follows.
(
p(ξ1 , . . . , ξn ) if I |= p(ξ1 , . . . , ξn ),
– (p(ξ1 , . . . , ξn ))I =
⊥
otherwise;
I
– >I = >; ⊥(
= ⊥;
F I  GI if I |= F  G ( ∈ {∧, ∨, →}),
– (F  G)I =
⊥
otherwise;
(

 I
Q({ξ : (F (ξ )) | ξ : F (ξ  ) ∈ S}) if I |= Q(S) (Q ∈ {∀, ∃}),
– Q(S)I =
⊥
otherwise.
The following theorem tells us how first-order stable models can be characterized
in terms of grounding and reduct.
Theorem 1. Let σ be a signature that contains finitely many predicate constants, let
σ pred be the set of predicate constants in σ, let I = hI f unc , I pred i be an interpretation
of σ, and let F be a first-order sentence of σ. I satisfies SM[F ; σ pred ] iff I pred is a
minimal set of atoms that satisfies (ıgrI [F ])I .

136

J. Lee and Y. Meng

Example 1 continued (II). The reduct of grI [F ] relative to I, (grI [F ])I , is
∀({n : (¬⊥ → q(n )) | n ∈ N}), which is equivalent to ∀({n : q(n ) | n ∈ N}).
Clearly, I pred = {q(n ) | n ∈ N} is a minimal set of atoms that satisfies (grI [F ])I .

2.3

Relation to Infinitary Formulas by Truszczynski

The definitions of grounding and a reduct in the previous section are inspired by the
work of Truszczynski [12], where he introduces infinite conjunctions and disjunctions
to account for the result of grounding ∀ and ∃ w.r.t. a given interpretation. Differences
between the two approaches are illustrated in the following example:
Example 2 Consider the formula F = ∀x p(x) and the interpretation I whose universe is the set of all nonnegative integers N. According to [12], grounding of F w.r.t.
I results in the infinitary propositional formula
{p(n ) | n ∈ N }∧ .
On the other hand, formula grI [F ] is
∀({n: p(n ) | n ∈ N }).
Our definition of a reduct is essentially equivalent to the one defined in [12]. In the
next section, we extend our definition to incorporate generalized quantifiers.

3

Stable Models of Formulas with Generalized Quantifiers

3.1

Review: Formulas with Generalized Quantifiers

We follow the definition of a formula with generalized quantifiers from [15, Section 5]
(that is to say, with Lindström quantifiers [16] without the isomorphism closure condition).
We assume a set Q of symbols for generalized quantifiers. Each symbol in Q is associated with a tuple of nonnegative integers hn1 , . . . , nk i (k ≥ 0, and each ni is ≥ 0),
called the type. A (GQ-)formula (with the set Q of generalized quantifiers) is defined in
a recursive way:
– an atomic formula (in the sense of first-order logic) is a GQ-formula;
– if F1 , . . . , Fk (k ≥ 0) are GQ-formulas and Q is a generalized quantifier of type
hn1 , . . . , nk i in Q, then
Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk ))

(4)

is a GQ-formula, where each xi (1 ≤ i ≤ k) is a list of distinct object variables
whose length is ni .

Two New Definitions of Stable Models of LPs with Generalized Quantifiers

137

We say that an occurrence of a variable x in a GQ-formula F is bound if it belongs
to a subformula of F that has the form Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )) such that x
is in some xi . Otherwise the occurrence is free. We say that x is free in F if F contains
a free occurrence of x. A (GQ-)sentence is a GQ-formula with no free variables.
We assume that Q contains type hi quantifiers Q⊥ and Q> , type h0, 0i quantifiers Q∧ , Q∨ , Q→ , and type h1i quantifiers Q∀ , Q∃ . Each of them corresponds to the
standard logical connectives and quantifiers — ⊥, >, ∧, ∨, →, ∀, ∃. These generalized
quantifiers will often be written in the familiar form. For example, we write F ∧ G in
place of Q∧ [][](F, G), and write ∀xF (x) in place of Q∀ [x](F (x)).
As in first-order logic, an interpretation I consists of the universe U and the evaluation of predicate constants and function constants. For each generalized quantifier Q of
type hn1 , . . . , nk i, QU is a function from P(U n1 ) × · · · × P(U nk ) to {TRUE, FALSE},
where P(U ni ) denotes the power set of U ni .
Example 3 Besides the standard connectives and quantifiers, the following are some
examples of generalized quantifiers.
2
– type h1i quantifier Q≤2 such that QU
≤2 (R) = TRUE iff |R| ≤ 2;
U
– type h1i quantifier Qmajority such that Qmajority (R) = TRUE iff |R| > |U \ R|;
– type h1, 1i quantifier Q(SUM,<) such that QU
(SUM,<) (R1 , R2 ) = TRUE iff
• SUM(R1 ) is defined,
• R2 = {b}, where b is an integer, and
• SUM(R1 ) < b.

Given a sentence F of σ I , F I is defined recursively as follows:
– p(t1 , . . . , tn )I = pI (tI1 , . . . , tIn ),
– (t1 = t2 )I = (tI1 = tI2 ),
– For a generalized quantifier Q of type hn1 , . . . , nk i,
(Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )))I = QU ((x1 : F1 (x1 ))I , . . . , (xk : Fk (xk ))I ),
where (xi : Fi (xi ))I = {ξ ∈ U ni | (Fi (ξ  ))I = TRUE}.
We assume that, for the standard logical connectives and quantifiers Q, functions
QU have the standard meaning:
– QU
∀ (R) = TRUE iff R = U ;
– QU
∃ (R) = TRUE iff R ∩ U 6= ∅;
– QU
∧ (R1 , R2 ) = TRUE iff R1 = R2 =
{};3
– QU
∨ (R1 , R2 ) = TRUE iff R1 = {} or
R2 = {};
2

3

– QU
→ (R1 , R2 ) = TRUE iff R1 is ∅ or
R2 is {};
– QU
⊥ () = FALSE ;
– QU
> () = TRUE .

It is clear from the type of the quantifier that R is any subset of U . We will skip such explanation.
 denotes the empty tuple. For any interpretation I, U 0 = {}. For I to satisfy Q∧ [][](F, G),
both ( : F )I and ( : G)I have to be {}, which means that F I = GI = TRUE.

138

J. Lee and Y. Meng

We say that an interpretation I satisfies a GQ-sentence F , or is a model of F , and
write I |= F , if F I = TRUE. A GQ-sentence F is logically valid if every interpretation
satisfies F . A GQ-formula with free variables is said to be logically valid if its universal
closure is logically valid.
Example 4 Program (1) in the introduction is identified with the following GQ-formula F1 :
(¬Q(SUM,<) [x][y](p(x), y = 2) → p(2))
∧ (Q(SUM,>) [x][y](p(x), y = −1) → p(−1))
∧ (p(−1) → p(1)) .
Consider two Herbrand interpretations of the universe U = {−1, 1, 2}: I1 = {p(−1), p(1)}
and I2 = {p(−1), p(1), p(2)}. We have (Q(SUM,<) [x][y](p(x), y = 2))I1 = TRUE
since
– (x : p(x))I1 = {−1, 1} and (y : y = 2)I1 = {2};
– QU
(SUM,<) ({−1, 1}, {2}) = TRUE .
Similarly, (Q(SUM,>) [x][y](p(x), y = −1))I2 = TRUE since
– (x : p(x))I2 = {−1, 1, 2} and (y : y = −1)I2 = {−1};
– QU
(SUM,>) ({−1, 1, 2}, {−1}) = TRUE .
Consequently, both I1 and I2 satisfy F1 .
3.2

Review: SM-Based Definition of Stable Models of GQ-Formulas

For any GQ-formula F and any list of predicates p = (p1 , . . . , pn ), formula SM[F ; p]
is defined as
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where F ∗ (u) is defined recursively:
– pi (t)∗ = ui (t) for any list t of terms;
– F ∗ = F for any atomic formula F that does not contain members of p;
–
(Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )))∗ =
Q[x1 ] . . . [xk ](F1∗ (x1 ), . . . , Fk∗ (xk )) ∧ Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )).
When F is a sentence, the models of SM[F ; p] are called the p-stable models of F :
they are the models of F that are “stable” on p. We often simply write SM[F ] in place of
SM[F ; p] when p is the list of all predicate constants occurring in F , and call p-stable
models simply stable models.
As explained in [17], this definition of a stable model is a proper generalization of
the first-order stable model semantics.
Example 4 continued (I). For GQ-sentence F1 considered earlier, SM[F1 ] is
F1 ∧ ¬∃u(u < p ∧ F1∗ (u)) ,

(5)

Two New Definitions of Stable Models of LPs with Generalized Quantifiers

139

where F1∗ (u) is equivalent to the conjunction of F1 and
(¬Q(SUM,<) [x][y](p(x), y = 2) → u(2))
∧ ((Q(SUM,>) [x][y](u(x), y = −1) ∧ Q(SUM,>) [x][y](p(x), y = −1)) → u(−1))
∧ (u(−1) → u(1)) .
The equivalence can be explained by Proposition 1 from [9], which simplifies the transformation for monotone and antimonotone GQs. I1 and I2 considered earlier satisfy (5)
and thus are stable models of F1 .

3.3

Reduct-Based Definition of Stable Models of GQ-Formulas

The reduct-based definition of stable models presented in Section 2.2 can be extended
to GQ-formulas as follows.
Let I be an interpretation of a signature σ. As before, we assume a set Q of generalized quantifiers, which contains all propositional connectives and standard quantifiers.
Definition 5. A ground GQ-formula w.r.t. I is defined recursively as follows:
– p(ξ1 , . . . , ξn ), where p is a predicate constant of σ and ξi are object names of σ I ,
is a ground GQ-formula w.r.t. I;
– for any Q ∈ Q of type hn1 , . . . , nk i, if each Si is a set of pairs of the form ξ  : F
where ξ  is a list of object names from σ I whose length is ni and F is a ground
GQ-formula w.r.t. I, then
Q(S1 , . . . , Sk )
is a ground GQ-formula w.r.t. I.
The following definition of grounding turns any GQ-sentence into a ground GQformula w.r.t. an interpretation:
Definition 6. Let F be a GQ-sentence of a signature σ, and let I be an interpretation
of σ. By grI [F ] we denote the ground GQ-formula w.r.t. I that is obtained by the process
similar to the one in Definition 2 except that the last two clauses are replaced by the
following single clause:
– grI [Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk ))] = Q(S1 , . . . , Sk )
where Si = {ξ : grI [Fi (ξ  )] | ξ  is a list of object names from σ I whose length is ni }.
For any interpretation I and any ground GQ-formula F w.r.t. I, the satisfaction
relation I |= F is defined recursively as follows.
Definition 7. For any interpretation I and any ground GQ-formula F w.r.t. I, the satisfaction relation I |= F is defined similar to Definition 3 except that the last five clauses
are replaced by the following single clause:
– Q(S1 , . . . , Sk )I = QU (S1I , . . . , SkI ) where SiI = {ξ | ξ  : F (ξ  ) ∈ Si , F (ξ  )I =
TRUE }.

140

J. Lee and Y. Meng

Example 4 continued (II). For Herbrand interpretation I1 = {p(−1), p(1)}, formula
grI1 [F1 ] is 4
(¬Q(SUM,<) ({−1 : p(−1), 1 : p(1), 2 : p(2)}, {−1 : ⊥, 1 : ⊥, 2 : >}) → p(2))
∧ (Q(SUM,>) ({−1 : p(−1), 1 : p(1), 2 : p(2)}, {−1 : >, 1 : ⊥, 2 : ⊥}) → p(−1))
∧ (p(−1) → p(1)) .

(6)

I1 satisfies Q(SUM,<) ({−1 : p(−1), 1 : p(1), 2 : p(2)}, {−1 : ⊥, 1 : ⊥, 2 : >}) because
I1 |= p(−1), I1 |= p(1), I1 6|= p(2), and
QU
(SUM,<) ({−1, 1}, {2}) = TRUE .
I1 satisfies Q(SUM,>) ({−1 : p(−1), 1 : p(1), 2 : p(2)}, {−1 : >, 1 : ⊥, 2 : ⊥}) because
QU
(SUM,>) ({−1, 1}, {−1}) = TRUE .
Consequently, I1 satisfies (6).
Proposition 2. Let σ be a signature that contains finitely many predicate constants, let
σ pred be the set of predicate constants in σ, let I = hI f unc , I pred i be an interpretation
of σ, and let F be a GQ-sentence of σ. Then I |= F iff I pred |= grI [F ].
Definition 8. For any GQ-formula F w.r.t. I, the reduct of F relative to I, denoted by
F I , is defined in the same way as in Definition 4 by replacing the last two clauses with
the following single clause:
(
I
I
Q(S1 , . . . , Sk ) if I |= Q(S1 , . . . , Sk ),
I
– (Q(S1 , . . . , Sk )) =
⊥
otherwise;
I

where Si = {ξ : (F (ξ  ))I | ξ : F (ξ  ) ∈ Si }.
Theorem 2. Let σ be a signature that contains finitely many predicate constants, let
σ pred be the set of predicate constants in σ, let I = hI f unc , I pred i be an interpretation
of σ, and let F be a GQ-sentence of σ. I |= SM[F ; σ pred ] iff I pred is a minimal set of
atoms that satisfies (ıgrI [F ])I .
Example 4 continued (III). Interpretation I1 considered earlier can be identified with
the tuple hI f unc , {p(−1), p(1)}i where I f unc maps every term to itself. The reduct
(grI1 [F1 ])I1 is
(⊥ → ⊥)
∧ (Q(SUM,>) ({−1 : p(−1), 1 : p(1), 2 : ⊥}, {−1 : >, 1 : ⊥, 2 : ⊥}) → p(−1))
∧ (p(−1) → p(1)) ,
which is the GQ-formula representation of (3). We can check that {p(−1), p(1)} is a
minimal model of the reduct.
Extending Theorem 2 to allow an arbitrary list of intensional predicates, rather than
σ pred , is straightforward in view of Proposition 1 from [18].
4

For simplicity, we write −1, 1, 2 instead of their object names (−1) , 1 , 2 .

Two New Definitions of Stable Models of LPs with Generalized Quantifiers

4

141

FLP Semantics of Programs with Generalized Quantifiers

The FLP stable model semantics [1] is an alternative way to define stable models. It is
the basis of HEX programs, an extension of the stable model semantics with higherorder and external atoms, which is implemented in system DLV- HEX. The first-order
generalization of the FLP stable model semantics for programs with aggregates was
given in [5], using the FLP operator that is similar to the SM operator. In this section
we show how it can be extended to allow generalized quantifiers.
4.1

FLP Semantics of Programs with Generalized Quantifiers

A (general) rule is of the form
H←B

(7)

where H and B are arbitrary GQ-formulas. A (general) program is a finite set of rules.
Let p be a list of distinct predicate constants p1 , . . . , pn , and let u be a list of distinct
predicate variables u1 , . . . , un . For any formula G, formula G(u) is obtained from G
by replacing all occurrences of predicates from p with the corresponding predicate
variables from u.
Let Π be a finite program whose rules have the form (7). The GQ-representation
Π GQ of Π is the conjunction of the universal closures of B → H for all rules (7) in
Π. By FLP[Π; p] we denote the second-order formula
Π GQ ∧ ¬∃u(u < p ∧ Π 4 (u))
where Π 4 (u) is defined as the conjunction of the universal closures of
B ∧ B(u) → H(u)
for all rules H ← B in Π.
We will often simply write FLP[Π] instead of FLP[Π; p] when p is the list of all
predicate constants occurring in Π, and call a model of FLP[Π] an FLP-stable model
of Π.
Example 4 continued (IV). For formula F1 considered earlier, FLP[F1 ] is
F1 ∧ ¬∃u(u < p ∧ F14 (u)) ,
where F14 (u) is
(¬Q(SUM,<) [x][y](p(x), y = 2) ∧ ¬Q(SUM,<) [x][y](u(x), y = 2) → u(2))
∧ (Q(SUM,>) [x][y](p(x), y = −1) ∧ (Q(SUM,>) [x][y](u(x), y = −1) → u(−1))
∧ (p(−1) ∧ u(−1) → u(1)) .
I1 considered earlier satisfies (8) but I2 does not.

(8)

142

5

J. Lee and Y. Meng

Comparing the FLP Semantics and the First-Order Stable
Model Semantics

In this section, we show a class of programs with GQs for which the FLP semantics and
the first-order stable model semantics coincide.
The following definition is from [17]. We say that a generalized quantifier Q is
monote in the i-th argument position if the following holds for any universe U : if
QU (R1 , . . . , Rk ) = TRUE and Ri ⊆ Ri0 ⊆ U ni , then
QU (R1 , . . . , Ri−1 , Ri0 , Ri+1 , . . . , Rk ) = TRUE.
Consider a program Π consisting of rules of the form
A1 ; . . . ; Al ← E1 , . . . , Em , ınot Em+1 , . . . , ınot En
(l ≥ 0; n ≥ m ≥ 0), where each Ai is an atomic formula and each Ei is an atomic
formula or a GQ-formula (4) such that all F1 (x1 ), . . . , Fk (xk ) are atomic formulas.
Furthermore we require that, for every GQ-formula (4) in one of Em+1 , . . . , En , Q is
monotone in all its argument positions.
Proposition 3. Let Π be a program whose syntax is described as above, and let F be
the GQ-representation of Π. Then FLP[Π; p] is equivalent to SM[F ; p].
Example 5 Consider the following one-rule program:
p(a) ← ınot Q≤0 [x] p(x) .

(9)

This program does not belong to the syntactic class of programs stated in Proposition 3
since Q≤0 [x] p(x) is not monotone in {1}. Indeed, both ∅ and {p(a)} satisfy SM[Π; p],
but only ∅ satisfies FLP[Π; p].
Conditions under which the FLP semantics coincides with the first-order stable
model semantics has been studied in [4; 5] in the context of logic programs with aggregates.

6

Conclusion

We introduced two definitions of a stable model. One is a reformulation of the first-order
stable model semantics and its extension to allow generalized quantifiers by referring
to grounding and reduct, and the other is a reformulation of the FLP semantics and
its extension to allow generalized quantifiers by referring to a translation into secondorder logic. These new definitions help us understand the relationship between the FLP
semantics and the first-order stable model semantics, and their extensions. For the class
of programs where the two semantics coincide, system DLV- HEX can be viewed as an
implementation of the stable model semantics of GQ-formulas; A recent extension of
system F 2 LP [19] to allow “complex” atoms may be considered as a front-end to DLVHEX to implement the generalized FLP semantics.

Two New Definitions of Stable Models of LPs with Generalized Quantifiers

143

Acknowledgements
We are grateful to Vladimir Lifschitz for useful discussions related to this paper. We
are also grateful to Joseph Babb and the anonymous referees for their useful comments.
This work was partially supported by the National Science Foundation under Grant IIS0916116 and by the South Korea IT R&D program MKE/KIAT 2010-TD-300404-001.

References
1. Faber, W., Leone, N., Pfeifer, G.: Recursive aggregates in disjunctive logic programs: Semantics and complexity. In: Proceedings of European Conference on Logics in Artificial
Intelligence (JELIA). (2004)
2. Faber, W., Pfeifer, G., Leone, N.: Semantics and complexity of recursive aggregates in answer set programming. Artificial Intelligence 175(1) (2011) 278–298
3. Ferraris, P.: Answer sets for propositional theories. In: Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). (2005) 119–131
4. Lee, J., Meng, Y.: On reductive semantics of aggregates in answer set programming. In: Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR). (2009) 182–195
5. Bartholomew, M., Lee, J., Meng, Y.: First-order extension of the flp stable model semantics
via modified circumscription. In: Proceedings of International Joint Conference on Artificial
Intelligence (IJCAI). (2011) 724–730
6. Ferraris, P., Lifschitz, V.: On the stable model semantics of first-order formulas with aggregates. In: Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).
(2010)
7. Ferraris, P., Lee, J., Lifschitz, V.: A new perspective on stable models. In: Proceedings of
International Joint Conference on Artificial Intelligence (IJCAI), AAAI Press (2007) 372–
379
8. Ferraris, P., Lee, J., Lifschitz, V.: Stable models and circumscription. Artificial Intelligence
175 (2011) 236–263
9. Lee, J., Meng, Y.: Stable models of formulas with generalized quantifiers (preliminary report). In: Technical Communications of the 28th International Conference on Logic Programming. (2012)
10. Marek, V.W., Truszczynski, M.: Logic programs with abstract constraint atoms. In: Proceedings of the AAAI Conference on Artificial Intelligence (AAAI). (2004) 86–91
11. Eiter, T., Ianni, G., Lukasiewicz, T., Schindlauer, R., Tompits, H.: Combining answer set
programming with description logics for the semantic web. Artificial Intelligence 172(1213) (2008) 1495–1539
12. Truszczynski, M.: Connecting first-order ASP and the logic FO(ID) through reducts. In:
Correct Reasoning: Essays on Logic-Based AI in Honor of Vladimir Lifschitz. (2012) 543–
559
13. Eiter, T., Ianni, G., Schindlauer, R., Tompits, H.: A uniform integration of higher-order reasoning and external evaluations in answer-set programming. In: Proceedings of International
Joint Conference on Artificial Intelligence (IJCAI). (2005) 90–96
14. Fink, M., Pearce, D.: A logical semantics for description logic programs. In: Proceedings of
European Conference on Logics in Artificial Intelligence (JELIA). (2010) 156–168
15. Westerståhl, D.:
Generalized quantifiers.
In: The Stanford Encyclopedia of Philosophy (Winter 2008 Edition).
(2008) URL =
<http://plato.stanford.edu/archives/win2008/entries/generalized-quantifiers/>.

144

J. Lee and Y. Meng

16. Lindström, P.: First-order predicate logic with generalized quantifiers. Theoria 32 (1966)
186–195
17. Lee, J., Meng, Y.:
Stable models of formulas with generalized quantifiers.
In:
Proceedings of International Workshop on Nonmonotonic Reasoning (NMR). (2012)
http://peace.eas.asu.edu/joolee/papers/smgq-nmr.pdf.
18. Lee, J., Palla, R.: Reformulating the situation calculus and the event calculus in the general
theory of stable models and in answer set programming. Journal of Artificial Intelligence
Research (JAIR) 43 (2012) 571–620
19. Lee, J., Palla, R.: System F2LP — computing answer sets of first-order formulas. In: Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR). (2009) 515–521

arXiv:1103.4558v1 [cs.AI] 23 Mar 2011

Under consideration for publication in Theory and Practice of Logic Programming

1

Representing First-Order Causal Theories by
Logic Programs
Paolo Ferraris
Google, Inc.
(e-mail: otto@cs.utexas.edu)

Joohyung Lee
School of Computing, Informatics and Decision Systems Engineering,
Arizona State University
(e-mail: joolee@asu.edu)

Yuliya Lierler
Computer Science Department, University of Kentucky
(e-mail: yuliya@cs.utexas.edu)

Vladimir Lifschitz and Fangkai Yang
Department of Computer Science, University of Texas at Austin
(e-mail: {vl,fkyang}@cs.utexas.edu)

submitted Aug, 16, 2010; revised Feb, 21, 2011; accepted Mar, 16, 2011

Abstract
Nonmonotonic causal logic, introduced by Norman McCain and Hudson Turner, became
a basis for the semantics of several expressive action languages. McCain’s embedding of
definite propositional causal theories into logic programming paved the way to the use of
answer set solvers for answering queries about actions described in such languages. In this
paper we extend this embedding to nondefinite theories and to first-order causal logic.
KEYWORDS: reasoning about actions, nonmonotonic causal logic, answer set programming

1 Introduction
Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages
(Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006;
Lifschitz and Ren 2007; Ren 2009). The Causal Calculator (CCalc)1 is a partial
1

http://www.cs.utexas.edu/users/tag/ccalc/

2

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

implementation of this logic that allows us to automate some kinds of reasoning
and planning in action domains described in such languages. It has been used to
solve several challenging commonsense reasoning problems, including problems of
nontrivial size (Akman et al. 2004), to provide a group of robots with high-level
reasoning (Caldiran et al. 2009), to give executable specifications of norm-governed
computational societies (Artikis et al. 2009), and to automate the analysis of business processes under authorization constraints (Armando et al. 2009).
An important theorem due to Norman McCain (McCain 1997, Proposition 6.7)
shows how to embed a fragment of propositional causal logic into the language of
logic programming under the answer set semantics (Gelfond and Lifschitz 1991).
This result, reviewed below, paved the way to the development of an attractive
alternative to CCalc—the software system coala (Gebser et al. 2010) that uses
answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz
2008) for answering queries about actions described in causal logic.
A causal theory in the sense of (McCain and Turner 1997) is a set of “causal
rules” of the form F ⇐ G, where F and G are propositional formulas (the head
and the body of the rule). The rule reads “F is caused if G is true.” Distinguishing
between being true and having a cause turned out to be essential for the study of
commonsense reasoning. The assertion “if the light is on at time 0 and you toggle
the switch then the light will be off at time 1” can be written as an implication:
on 0 ∧ toggle → ¬on 1 ·
In causal logic, on the other hand, we can express that under the same assumption
there is a cause for the light to be off at time 1:
¬on 1 ⇐ on 0 ∧ toggle·
(Performing the toggle action is the cause.) McCain and Turner showed that distinctions like this help us solve the frame problem (see Example 5 in Section 5.2)
and overcome other difficulties arising in the theory of reasoning about actions.
The semantics of theories of this kind defines when a propositional interpretation (truth assignment) is a model of the given theory (is “causally explained” by
the theory, in the terminology of McCain and Turner). We do not reproduce the
definition here, because a more general semantics is described below in Section 3.
But here is an example: the causal theory
p ⇐ ¬q
¬q ⇐ p

(1)

has one model, according to the semantics from (McCain and Turner 1997). In this
model, p is true and q is false. (Since the bodies of both rules are true in this model,
both rules “fire”; consequently the heads of the rules are “caused”; consequently
the truth values of both atoms are “causally explained.” This will be discussed
formally in Section 3.)
McCain’s translation is applicable to a propositional causal theory T if the head
of each rule of T is a literal, and the body is a conjunction of literals:
L ⇐ A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ · · · ¬An ·

(2)

Representing First-Order Causal Theories by Logic Programs

3

The corresponding logic program consists of the logic programming rules
L ← not ¬A1 , . . . , not ¬Am , not Am+1 , . . . , not An

(3)

for all rules (2) of T . This program involves two kinds of negation: negation as
failure (not ) and strong, or classical, negation (¬). According to Proposition 6.7
from (McCain 1997), complete answer sets of this logic program are identical to
the models of T . (A set of literals is complete if it contains exactly one member
of each complementary pair of literals A, ¬A. We identify a complete set of literals
with the corresponding truth assignment.)
For instance, McCain’s translation turns causal theory (1) into
p
¬q

← not q
← not ¬p·

(4)

The only answer set of this program is {p, ¬q}. It is complete, and it corresponds
to the model of causal theory (1).
In this paper we generalize McCain’s translation in several ways. First, we discard
the requirement that the bodies of the given causal rules be conjunctions of literals.
Second, instead of requiring that the head of each causal rule be a literal, we
allow the heads to be disjunctions of literals. In this more general setting, the logic
program corresponding to the given causal theory becomes disjunctive as well.
Third, we study causal rules with heads of the form L1 ↔ L2 , where L1 and
L2 are literals. Such a rule says that there is a cause for L1 and L2 to be equivalent (“synonymous”) under some condition, expressed by the body of the rule.
Synonymity rules play an important role in the theory of commonsense reasoning
in view of the fact that humans often explain the meaning of words by referring to
their synonyms. A synonymity rule
L1 ↔ L2 ⇐ G

(5)

can be translated into logic programming by rewriting it as the pair of rules
L1 ∨ L2 ⇐ G
L1 ∨ L2 ⇐ G
(L stands for the literal complementary to L) and then using our extension of
McCain’s translation to rules with disjunctive heads. It turns out, however, that
there is no need to use disjunctive logic programs in the case of synonymity rules.
If, for instance, G in (5) is a literal then the following group of nondisjunctive rules
will do:
L1 ← L2 , not G
L2 ← L1 , not G
L1 ← L2 , not G
L2 ← L1 , not G·
Finally, we extend the translation from propositional causal rules to first-order
causal rules in the sense of (Lifschitz 1997). This version of causal logic is useful for
defining the semantics of variables in action descriptions (Lifschitz and Ren 2007).
As part of motivation for our approach to transforming causal theories into logic

4

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

programs, we start with a few additional comments on McCain’s translation (Section 2). After reviewing the semantics of causal theories and logic programs in
Sections 3 and 4, we describe four kinds of causal rules that we are interested in
and show how to turn a theory consisting of such rules into a logic program (Section 5). This translation is related to answer set programming in Section 6, and its
soundness is proved in Section 7.
Preliminary reports on this work are published in (Ferraris 2006; Ferraris 2007;
Lee et al. 2010; Lifschitz and Yang 2010). Some results appear here for the first time,
including the soundness of a representation of a synonymity rule with variables by
a nondisjunctive logic program.
2 McCain’s Translation Revisited
2.1 Incorporating Constraints
In causal logic, a constraint is a rule with the head ⊥ (falsity). McCain’s translation
can be easily extended to constraints with a conjunction of literals in the body—
causal rules of the form
⊥ ⇐ A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ · · · ∧ ¬An ·

(6)

In the language of logic programming, (6) can be represented by a rule similar
to (3):
⊥ ← not ¬A1 , . . . , not ¬Am , not Am+1 , . . . , not An ·

(7)

Furthermore, each of the combinations not ¬ in (7) can be dropped without destroying the validity of the translation; that is to say, the rule
⊥ ← A1 , . . . , Am , not Am+1 , . . . , not An

(8)

can be used instead of (7).
2.2 Eliminating Strong Negation
As observed in (Gelfond and Lifschitz 1991), strong negation can be eliminated from
a logic program in favor of additional atoms. Denote the new atom representing a
b Then (3) will become
negative literal ¬A by A.
c1 , . . . , not A
d
A0 ← not A
m , not Am+1 , . . . , not An

(9)

c0 ← not A
c1 , . . . , not A
d
A
m , not Am+1 , . . . , not An

(10)

if L is a positive literal A0 , and

if L is a negative literal ¬A0 . The modified McCain translation of a causal theory T
consisting of rules of the forms (2) and (6) includes
• rules (8) corresponding to the constraints (6) of T ,
• rules (9), (10) corresponding to the other rules of T , and

Representing First-Order Causal Theories by Logic Programs

5

• the completeness constraints
b
← A, A
b
← not A, not A

(11)

for all atoms A.

For instance, the modified McCain translation of (1) is
p ← not q
q ← not b
b
p
← p, pb
← not p, not pb
← q, b
q
← not q, not b
q·

(12)

The only answer set (stable model2 ) of this program is {p, b
q }.
This modification is useful to us in view of the fact that eliminating strong
negation in favor of aditional atoms is part of the definition of a stable model
proposed in (Ferraris et al. 2011, Section 8).
2.3 Rules as Formulas
The definition of a stable model for propositional formulas given in (Ferraris 2005)
and the definition of a stable model for first-order sentences proposed in (Ferraris
et al. 2011) become generalizations of the original definition (Gelfond and Lifschitz
1988) when we rewrite rules as logical formulas. For instance, rules (9) and (10),
rewritten as propositional formulas, become

and

c1 ∧ · · · ∧ ¬A
d
¬A
m ∧ ¬Am+1 ∧ · · · ∧ ¬An → A0

(13)

c1 ∧ · · · ∧ ¬A
d
c
¬A
m ∧ ¬Am+1 ∧ · · · ∧ ¬An → A0 ·

(14)

A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ . . . ∧ ¬An → ⊥

(15)

Rule (8) can be identified with the formula

or, alternatively, with
¬(A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ . . . ∧ ¬An )·

(16)

The completeness constraints for an atom A turn into the formulas
b
¬(A ∧ A)
b
¬(¬A ∧ ¬A)·
2

(17)

The term “stable model” was introduced in (Gelfond and Lifschitz 1988) to describe the meaning
of logic programs with negation as failure but without strong negation. When the stable model
semantics was extended to programs with strong negation in (Gelfond and Lifschitz 1991), the
term “answer set” was proposed as a replacement.

6

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

Here is program (12) rewritten in the syntax of propositional logic:
¬q → p
¬b
p→b
q
¬(p ∧ pb)
¬(¬p ∧ ¬b
p)
¬(q ∧ b
q)
¬(¬q ∧ ¬b
q )·

(18)

Note that the process of rewriting a rule as a formula is applicable only when
the rule does not contain strong negation; the symbol ¬ in the resulting formula
corresponds to the negation as failure symbol (not ) in the rule.
One of the advantages of writing rules as formulas is that it allows us to relate
properties of stable models to subsystems of classical logic. We know, for instance,
that if the equivalence of two sentences can be proved in intuitionistic logic (or even
in the stronger logic of here-and-there) then these sentences have the same stable
models (Ferraris et al. 2011, Theorem 5). This fact will be used here many times.
2.4 Translating Arbitrary Definite Theories
The requirement, in the definition of McCain’s translation, that the bodies of all
causal rules should be conjunctions of literals can be lifted by slightly modifying
the translation process. Take any set T of causal rules of the forms
A ⇐ G,

(19)

¬A ⇐ G,

(20)

⊥ ⇐ G,

(21)

where A is an atom and G is an arbitrary propositional formula (rules of these
forms are called definite). For each rule (19), take the formula ¬¬G → A; for
b for each rule (21), the formula ¬G. Then
each rule (20), the formula ¬¬G → A;
add completeness constraints (17) for all atoms A. Answer sets of this collection of
propositional formulas correspond to the models of T .
In application to example (1), this modification of McCain’s translation gives
¬¬¬q → p
¬¬p → b
q
¬(p ∧ pb)
¬(¬p ∧ ¬b
p)
¬(q ∧ b
q)
¬(¬q ∧ ¬b
q )·

(22)

It is not surprising that (22) has the same answer set as (18): the two collections
of formulas are intuitionistically equivalent to each other.3
3

Indeed, ¬¬¬q is intuitionistically equivalent to ¬q; the equivalence between ¬¬p and ¬b
p is
intuitionistically entailed by the formulas ¬(p ∧ p
b) and ¬(¬p ∧ ¬b
p ), which belong both to (18)
and to (22).

Representing First-Order Causal Theories by Logic Programs

7

3 Review: First-Order Causal Theories
According to (Lifschitz 1997), a first-order causal theory T is defined by
• a list p of distinct predicate constants,4 called the explainable symbols of T ,5
and
• a finite set of causal rules of the form F ⇐ G, where F and G are first-order
formulas.
The semantics of first-order causal theories can be described as follows. For each
p ∈ p, choose a new predicate variable υp of the same arity, and let υp stand for
the list of all these variables. By T † (υp) we denote the conjunction of the formulas
p
∀x(G → Fυp
)

(23)

for all rules F ⇐ G of T , where x is the list of all free variables of F , G. (The expresp
sion Fυp
denotes the result of substituting the variables υp for the corresponding
constants p in F .)
We view T as shorthand for the sentence
∀υp(T † (υp) ↔ (υp = p))·

(24)

(By υp = p we denote the conjunction of the formulas ∀x(υp(x) ↔ p(x)) for all
p ∈ p, where x is a tuple of distinct object variables.) Accordingly, by a model
of T we understand a model of (24) in the sense of classical logic. The models of T
are characterized, informally speaking, by the fact that the interpretation of the
explainable symbols p in the model is the only interpretation of these symbols that
is “causally explained” by the rules of T .
In the definite case (see Section 2.4) second-order formula (24) can be replaced
by an equivalent first-order formula using a process similar to Clark’s completion
(Clark 1978), called literal completion (McCain and Turner 1997), (Lifschitz 1997,
Section 5). This process is used in the operation of CCalc.
Example 1. Let T be causal theory (1) with both p and q explainable. Then
T † (υp, υq) is
(¬q → υp) ∧ (p → ¬υq)
(υp, υq are propositional variables), so that T is understood as shorthand for the
second-order propositional formula (“QBF”)
∀(υp)(υq)((¬q → υp) ∧ (p → ¬υq) ↔ (υp ↔ p) ∧ (υq ↔ q))·

(25)

This formula is equivalent to p ∧ ¬q.6
4
5
6

We view propositional symbols as predicate constants of arity 0, so that they are allowed in p.
Equality, on the other hand, may not be declared explainable.
To be precise, the definition in (Lifschitz 1997) is more general: object and function constants
can be treated as explainable as well.
This fact can be verified by replacing the universal quantifier in (25) with the conjunction of
the four propositional formulas obtained by substituting all possible combinations of values for
the variables υp, υq, and simplifying the result. Alternatively, one can apply literal completion
to rules (1) and simplify the result.

8

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

Example 2. Let T be the causal theory consisting of two rules:
p(a) ⇐ ⊤
(here ⊤ is the logical constant true) and
¬p(x ) ⇐ ¬p(x ),
with the explainable symbol p. The first rule says that there is a cause for a to have
property p. The second rule says that if an object does not have property p then
there is a cause for that; including this rule in a causal theory has, informally speaking, the same effect as saying that p is false by default (Lifschitz 1997, Section 3).
In this case, T † (υp) is
υp(a) ∧ ∀x (¬p(x ) → ¬υp(x )),
so that T is understood as shorthand for the sentence
∀υp(υp(a) ∧ ∀x (¬p(x ) → ¬υp(x )) ↔ ∀x (υp(x ) ↔ p(x )))·
This sentence is equivalent to the first-order formula
∀x (p(x ) ↔ x = a),

(26)

as can be verified by applying literal completion to the rules of T .

4 Review: Stable Models
Some details of the definition of a stable model proposed in (Ferraris et al. 2011)
depend on which propositional connectives are treated as primitives, and which are
viewed as abbreviations. The convention there is to take the 0-place connective ⊥
and the binary connectives ∧, ∨, → as primitives; ¬F is shorthand for F → ⊥.
In this paper we adopt the view that first-order formulas are formed using a
slightly larger set of propositional connectives:
⊤, ⊥, ¬, ∧, ∨, →
(as well as the quantifiers ∀, ∃). On the other hand, stable models are only defined
here for sentences of a special syntactic form. A first-order sentence is a rule7 if it
has the form e
∀(F → G) and has no occurrences of → other than the one explicitly
8
shown. If a sentence F does not contain implication then we will identify it with
the rule ⊤ → F . For instance, propositional formulas (13)–(18) are rules. A logic
program is a conjunction of rules. The definition of a stable model below is more
limited than the definition from (Ferraris et al. 2011) because it is only applicable
to programs, not to arbitrary sentences. For instance, it does not cover the formulas
(p → q) → r and (p → q) ∨ r . On the other hand, it is simpler than the general
definition, and it is sufficient for our present purposes.
7
8

Or program rule, to distinguish it from causal rules in the sense of Section 3.
e
∀F stands for the universal closure of F .

Representing First-Order Causal Theories by Logic Programs

9

We need the following notation from (Lifschitz 1994). If p and q are predicate
constants of the same arity then p ≤ q stands for the formula
∀x(p(x) → q(x)),
where x is a tuple of distinct object variables. If p and q are tuples p1 , . . . , pn and
q1 , . . . , qn of predicate constants then p ≤ q stands for the conjunction
(p1 ≤ q1 ) ∧ · · · ∧ (pn ≤ qn ),
and p < q stands for (p ≤ q) ∧ ¬(q ≤ p). In second-order logic, we apply the same
notation to tuples of predicate variables.
Let p be a list of distinct predicate constants; members of p will be called intensional predicates.9 For each p ∈ p, choose a predicate variable υp of the same
arity, and let υp stand for the list of all these variables. For any logic program F ,
by SMp [F ] we denote the second-order sentence
F ∧ ¬∃υp((υp < p) ∧ F ⋄ (υp)),

(27)

where F ⋄ (υp) is the formula obtained from F by replacing, for every p ∈ p, each
occurrence of p that is not in the scope of negation with υp. A model of F is stable
(relative to the set p of intensional predicates) if it satisfies SMp [F ].10
Example 3. Let F be the propositional formula ¬p → q (the one-rule program
q ← not p, in traditional notation). If both p and q are intensional then F ⋄ (υp, υq)
is
¬p → υq,
so that SMpq [F ] is
(¬p → q) ∧ ¬∃(υp)(υq)(((υp, υq) < (p, q)) ∧ (¬p → υq))·
This formula is equivalent to ¬p ∧ q.11 Consequently F has one stable model: p is
false and q is true.
Example 4. Let F be the formula
∀x (¬p(x ) → (q(x ) ∨ ¬q(x )))

(28)

(it can be thought of as a formula representation of the lparse choice rule
9

10

11

This list usually consists of all predicate symbols occurring in the heads of rules; those are the
predicates that we “intend to characterize” by the rules of the program. The original definition
of a stable model (Gelfond and Lifschitz 1988) treats all predicates as intensional.
We can make two comments about the relation of this treatment of stable models to earlier work.
First, if we drop from the definition of SM the words “that is not in the scope of negation” then
it will turn into the definition of parallel circumscription (McCarthy 1986; Lifschitz 1985). It
follows that if a logic program does not contain negation then the class of its stable models is
identical to the class of its minimal models. The stipulation in the description of F ⋄ (υp) that
intensional predicates in the scope of negation are not replaced by variables is a reflection of
the idea of negation as failure. Second, the operator of SM as defined in (Ferraris et al. 2011)
produces, in application to a logic program, a second-order formula that is usually more complex
than (27) but is equivalent to it.
Methods for simplifying the result of applying the operator SM are discussed in (Ferraris et al.
2011).

10

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

{q(X)} :- not p(X)).12 If we take q to be the only intensional predicate then F ⋄ (υq)
is
∀x (¬p(x ) → (υq(x ) ∨ ¬q(x )))·
Consequently SMq [F ] is
∀x (¬p(x ) → (q(x ) ∨ ¬q(x ))) ∧ ¬∃υq((υq < q) ∧ ∀x (¬p(x ) → (υq(x ) ∨ ¬q(x ))))·
The first conjunctive term here is logically valid and can be dropped. The second is
equivalent to the first-order formula ¬∃x (p(x ) ∧ q(x )), which reflects the intuitive
meaning of the choice rule above: q is an arbitrary set disjoint from p.
The relationship between the definition of a stable model given above and the
operation of answer set solvers is discussed in Section 6.
If programs F and G are intuitionistically equivalent then SMp [F ] is equivalent to SMp [G], that is to say, F and G have the same stable models. Moreover,
for establishing that F and G have the same stable models we only need to derive F ↔ G intuitionistically from the excluded middle formulas e
∀(H ∨ ¬H ) for
some formulas H that do not contain intensional predicates. This fact follows from
(Ferraris et al. 2011, Theorem 5).

5 Turning a Causal Theory into a Logic Program
5.1 Four Types of Causal Rules
In the rest of the paper, we assume that the bodies of causal rules do not contain
implication. This is not an essential limitation, because in classical logic → can be
expressed in terms of other connectives, and the meaning of a causal rule does not
change if we replace its body (or head) by a classically equivalent formula.
Here are four types of rules that we are going to consider, in the order of increasing
complexity of their heads:
• The head is ⊥, that is, the rule is a constraint. Such causal rules will be also
called C-rules.
• The head is a literal containing an explainable predicate symbol. These are
L-rules.
• The head has the form L1 ↔ L2 , where each Li is a literal containing an
explainable predicate symbol. These are synonymity rules, or S-rules.
• The head has the form L1 ∨ · · · ∨ Ln (n ≥ 0), where each Li is a literal
containing an explainable predicate symbol. These are D-rules.
All C-rules and L-rules can be viewed also as D-rules, and any S-rule can be
replaced with an equivalent pair of D-rules (see Lemma 11 in Section 7.2). Nevertheless, we give special attention here to rules of the first three types, and the
reason is that our translation handles such rules in special ways. It appears that
12

This rule would not be accepted by lparse, however, because it is “nonrestricted.” For a description of the language of lparse see http://www.tcs.hut.fi/Software/ smodels/lparse.ps.

Representing First-Order Causal Theories by Logic Programs

11

causal rules of types C, L, and S will be more important than general D-rules in
applications of this work to the automation of reasoning about actions.
On the other hand, the possibility of reducing types C, L, and S to type D plays
an important role in the proof of the soundness of our translation (Section 7). This
is one of the reasons why we are interested in general D-rules.
The requirement, in the definitions of types L, S and D, that the literals in the
head of the rule contain explainable predicate symbols is not an essential limitation.
If, for instance, the predicate symbol in the head of L ⇐ G is not explainable then
this rule can be equivalently replaced by the C-rule ⊥ ⇐ G ∧ L. If a rule has the
form
L1 ↔ L2 ⇐ G
and the predicate symbol in L1 is not explainable then the rule can be replaced by
L2 ⇐ G ∧ L1 ,
L2 ⇐ G ∧ L1 ·
If a rule has the form
L1 ∨ · · · ∨ Ln ⇐ G
and the predicate symbol in L1 is not explainable then the rule can be replaced by
L2 ∨ · · · ∨ Ln ⇐ G ∧ L1 ·
5.2 Translating C-Rules and L-Rules
The transformation described in this section generalizes McCain’s translation, in
the form described in Section 2.4, to first-order causal theories.
The operator Trc , which transforms any C-rule into a program rule, is defined
by the formula
e
Trc [⊥ ⇐ G] = ∀¬G·

The operator Trl , which transforms any L-rule into a program rule, is defined by
the formulas
Trl [p(t) ⇐ G] = e
∀(¬¬G → p(t)),
Trl [¬p(t) ⇐ G] = e
∀(¬¬G → pb(t))

(t is a tuple of terms).
If T is a causal theory consisting of C-rules and L-rules then its translation Tr[T ]
is the logic program obtained by conjoining
• the rules obtained by applying Trc to the C-rules of T ,
• the rules obtained by applying Trl to the L-rules of T , and
• the completeness constraints
∀x¬(p(x) ∧ pb(x)),
∀x¬(¬p(x) ∧ ¬b
p (x))

(29)

(x is a tuple of distinct object variables) for all explainable predicate symbols p
of T .

12

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

b be the list
Let p be the list of explainable predicate symbols p of T , and let p
b to be the set
of the corresponding predicate symbols pb. Take the union of p and p
of intensional predicates. Then the stable models of the logic program Tr[T ] are
“almost identical” to the models of T ; the difference is due to the fact that the
b . Let CC be the conjunction of all
language of T does not contain the symbols p
completeness constraints (29). Then the relationship between T and Tr[T ] can be
described as follows:
SMpbp [Tr[T ]] is equivalent to T ∧ CC ·

(30)

This claim, expressing the soundness of our translation, is extended in Sections 5.3
and 5.4 to causal theories containing S-rules and D-rules, and its proof is given in
Section 7.
Since the conjunction of formulas (29) is classically equivalent to
∀x(b
p (x) ↔ ¬p(x)),

(31)

sentence CC can be viewed as the conjunction of explicit definitions of the predb in terms of the predicates p. Consequently the relationship (30) shows
icates p
that SMpbp [Tr[T ]] is a definitional extension of T . The models of Tr[T ] that are
stable relative to pb
p can be characterized as the models of T extended by the
b that are provided by definitions (31).
interpretations of the predicates p

Example 1, continued. If T is causal theory (1) with both p and q explainable
then Tr[T ] is the conjunction of formulas (22). The result of applying the operator
SMpqbpbq to this conjunction is equivalent to
p ∧ ¬q ∧ ¬b
p∧b
q·

Recall that T is equivalent to the first half of this conjunction (Section 3). The
second half tells us that the truth values of b
p, b
q are opposite to the truth values
of p, q. In the only stable model of (22), p and b
q are true, and pb and q are false; if
we “forget” the truth values of pb and b
q then we will arrive at the model of (1).
Example 2, continued. Our translation turns the causal theory from Example 2
into the conjunction of the rules
¬¬⊤ → p(a),
∀x (¬¬¬p(x ) → pb(x )),
∀x ¬(p(x ) ∧ pb(x )),
∀x ¬(¬p(x ) ∧ ¬b
p (x )),
or, after intuitionistically equivalent transformations,
p(a),
∀x (¬p(x ) → pb(x )),
∀x ¬(p(x ) ∧ pb(x )),
∀x ¬(¬p(x ) ∧ ¬b
p (x ))·
The result of applying SMpbp to the conjunction of these formulas is equivalent to
the conjunction of (26) with the formula ∀x (b
p (x ) ↔ ¬p(x )), which says that pb is
the complement of p.

Representing First-Order Causal Theories by Logic Programs

13

Example 5. Consider the following causal rules:
on 1 (x )
¬on 1 (x )
on 1 (x )
¬on 1 (x )

⇐ toggle(x ) ∧ ¬on 0 (x ),
⇐ toggle(x ) ∧ on 0 (x ),
⇐ on 0 (x ) ∧ on 1 (x ),
⇐ ¬on 0 (x ) ∧ ¬on 1 (x )·

(32)

The first pair of rules describes the effect of toggling a switch x : this action causes
the fluent on(x ) at time 1 to take the value opposite to its value at time 0. The
second pair solves the frame problem (Shanahan 1997) for the fluent on(x ) by
postulating that if the value of that fluent at time 1 is equal to its previous value
then there is a cause for this. (Inertia, in the sense of commonsense reasoning, is
the cause.) Let T be the causal theory with rules (32) and with on 1 as the only
explainable symbol. Using literal completion, we can check that T is equivalent to
∀x (on 1 (x ) ↔ ((on 0 (x ) ∧ ¬toggle(x )) ∨ (¬on 0 (x ) ∧ toggle(x ))))·

(33)

Our translation turns T into the conjunction of the rules
∀x (¬¬(toggle(x ) ∧ ¬on 0 (x )) → on 1 (x )),
∀x (¬¬(toggle(x ) ∧ on 0 (x )) → od
n 1 (x )),
∀x (¬¬(on 0 (x ) ∧ on 1 (x )) → on 1 (x )),
∀x (¬¬(¬on 0 (x ) ∧ ¬on 1 (x )) → od
n 1 (x )),
∀x ¬(on 1 (x ) ∧ od
n 1 (x )),
∀x ¬(¬on 1 (x ) ∧ ¬d
on 1 (x )),

(34)

or, equivalently,13
∀x (toggle(x ) ∧ ¬on 0 (x ) → on 1 (x )),
∀x (toggle(x ) ∧ on 0 (x ) → od
n 1 (x )),
∀x (on 0 (x ) ∧ ¬d
on 1 (x ) → on 1 (x )),
∀x (¬on 0 (x ) ∧ ¬on 1 (x ) → od
n 1 (x )),
∀x ¬(on 1 (x ) ∧ od
n 1 (x )),
∀x ¬(¬on 1 (x ) ∧ ¬d
on 1 (x ))·

(35)

The result of applying SMon 1 on
d1 to this program is equivalent to the conjunction
of (33) with the formula ∀x (d
on 1 (x ) ↔ ¬on 1 (x )), which says that od
n 1 is the complement of on 1 .
Example 6. The constraint
⊥ ⇐ toggle(badswitch )
expresses that badswitch is stuck: the action of toggling it is not executable. If we
add this constraint to the causal theory from Example 5 then the rule
¬toggle(badswitch )
13

Removing the double negations in the first two lines of (34) is possible because neither toggle nor
on 0 is intensional (see the comment on equivalent transformations of logic programs at the end
of Section 4). In a similar way, the antecedent of the third impication in (34) can be replaced
by on 0 (x ) ∧ ¬¬on 1 (x ); the equivalence between ¬¬on 1 (x ) and ¬on
d1 (x ) is intuitionistically
entailed by the last two lines of (34). The fourth line of (34) is simplified in a similar way.

14

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

will be added to its translation (35).
The bodies of causal rules in Examples 5 and 6 are syntactically simple: they
are conjunctions of literals. The general definitions of a C-rule and an L-rule do
not impose any restrictions on the form of the body, and in applications of causal
logic to formalizing commonsense knowledge this generality is often essential. For
instance, the statement “each position must have at least one neighbor” in the
landscape structure of the Zoo World14 would be represented in causal logic by a
C-rule with a quantifier in the body.
5.3 Translating S-Rules
We will turn now to translating synonymity rules (Section 5.1). The operator Trs ,
transforming any such rule into a logic program, is defined by the formulas
Trs [p1 (t1 ) ↔ p2 (t2 ) ⇐ G] = Trs [¬p1 (t1 ) ↔ ¬p2 (t2 ) ⇐ G]
=e
∀(¬¬G ∧ p1 (t1 ) → p2 (t2 )) ∧ e
∀(¬¬G ∧ p2 (t2 ) → p1 (t1 )) ∧
e
∀(¬¬G ∧ pb1 (t1 ) → pb2 (t2 )) ∧ e
∀(¬¬G ∧ pb2 (t2 ) → pb1 (t1 )),

Trs [¬p1 (t1 ) ↔ p2 (t2 ) ⇐ G] = Trs [p1 (t1 ) ↔ ¬p2 (t2 ) ⇐ G]
∀(¬¬G ∧ p2 (t2 ) → pb1 (t1 )) ∧
∀(¬¬G ∧ pb1 (t1 ) → p2 (t2 )) ∧ e
=e
1
2
e
∀(¬¬G ∧ b
p2 (t2 ) → p1 (t1 ))
∀(¬¬G ∧ p1 (t ) → b
p2 (t )) ∧ e

(t1 , t2 are tuples of terms). The definition of program Tr[T ] from Section 5.2 is
extended to causal theories that may contain S-rules, besides C-rules and L-rules,
by adding that Tr[T ] includes also
• the rules obtained by applying Trs to the S-rules of T .
Example 7. Extend the theory from Example 5 by the rule
dark ↔ ¬on 1 (myswitch) ⇐ ⊤,

(36)

where dark is explainable. The corresponding logic program is obtained from (35)
by adding the rules
[ → on 1 (myswitch),
dark
[,
on 1 (myswitch) → dark
dark → od
n 1 (myswitch),
od
n 1 (myswitch) → dark ,
[ ),
¬(dark ∧ dark
[ )·
¬(¬dark ∧ ¬dark

(37)

We will see that the soundness property (30) holds for arbitary causal theories
consisting of rules of types C, L, and S.
14

The challenge of formalizing the Zoo World was proposed as part of the Logic Modelling Workshop (http:/www/ida.liu.se/ext/etai/lmw/). The possibility of addressing this challenge using
CCalc is discussed in (Akman et al. 2004, Section 4).

Representing First-Order Causal Theories by Logic Programs

15

5.4 Translating D-Rules
A D-rule (Section 5.1) has the form
_

A∈Pos

A∨

_

¬A ⇐ G

(38)

A∈Neg

for some sets Pos, Neg of atomic formulas.
b
If A is an atomic formula p(t), where p ∈ p and t is a tuple of terms, then by A
we will denote the formula pb(t). The operator Trd transforms D-rule (38) into the
program rule


^
^
_
_
e
b ∨ ¬A)
b ∧
b  · (39)
∀  ¬¬G ∧
(A
(A ∨ ¬A) →
A∨
A
A∈Pos

A∈Neg

A∈Pos

A∈Neg

Example 8. The result of applying Trd to the D-rule
p ∨ ¬q ∨ ¬r ⇐ s
is
¬¬s ∧ (b
p ∨ ¬b
p ) ∧ (q ∨ ¬q) ∧ (r ∨ ¬r ) → p ∨ b
q ∨b
r·
The number of “excluded middle formulas” conjoined with ¬¬G in (39) equals
the number of disjunctive terms in the head of D-rule (38). In particular, if (38) is
an L-rule then the antecedent of (39) contains one such formula. For instance, in
application to the first rule of (1) Trd produces the program rule
¬¬¬q ∧ (b
p ∨ ¬b
p ) → p,
which is more complex than the first rule of (22).
For a fixed collection p of explainable symbols, let C , L, S , and D be finite sets
of causal rules of types C, L, S, and D respectively. By Tr[C , L, S , D ] we denote the
logic program obtained by conjoining
•
•
•
•
•

the
the
the
the
the

rules obtained by applying Trc to all rules from C ,
rules obtained by applying Trl to all rules from L,
programs obtained by applying Trs to all rules from S ,
rules obtained by applying Trd to all rules from D ,
completeness constraints (29) for all explainable symbols p.

Our most general form of the soundness theorem, proved in Section 7, asserts that
SMpbp [Tr[C , L, S , D ]] is equivalent to T ∧ CC

(40)

for the causal theory T with the set of rules C ∪L∪S ∪D . In the special case when D
is empty this theorem turns into the assertion stated at the end of Section 5.3.

16

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

6 Using Answer Set Solvers to Generate Models of a Causal Theory
The discussion of answer set solvers in this section, as almost any discussion of
software, is somewhat informal. We assume here that the first-order language under
consideration does not contain function constants of nonzero arity.
An answer set solver can be viewed as a system for generating stable models in
the sense of Section 4, with three caveats. First, currently available solvers require
that the input program have a syntactic form that is much more restrictive than
the syntax of first-order logic.15 Preprocessing based on intuitionistically equivalent
transformations often helps us alleviate this difficulty. There exists a tool, called
f2lp (Lee and Palla 2009), that converts first-order formulas of a rather general
kind into logic programs accepted by lparse. The rules produced by the process
described in the previous section have no existential quantifiers in their heads, and
all quantifiers in their bodies are in the scope of negation. Consequently, these
rules satisfy a syntactic condition that guarantees the correctness of the translation
implemented in f2lp.
Second, answer set solvers represent stable models by sets of ground atoms. To
introduce such a representation, we usually choose a finite set of object constants
that includes all object constants occurring in the program, and restrict attention
to Herbrand interpretations of the extended language. The #domain construct of
lparse16 can be used to specify the object constants constituting the domain of
the variables in the program.
Third, most existing answer set solvers are unaware of the possibility of nonintensional (or extensional) predicates. Treating a predicate constant as extensional
can be simulated using a choice rule (Ferraris et al. 2011, Theorem 2). There is also
another approach to overcoming this limitation. Take a conjunction E of some
ground atoms containing extensional predicates, and assume that we are interested
in the Herbrand stable models of a program F that interpret the extensional predicates in accordance with E (every atom from E is true; all other atoms containing
extensional predicates are false). Under some syntactic conditions,17 these stable
models are identical to the Herbrand stable models of F ∧ E with all predicate
constants treated as intensional. This can be proved using the splitting theorem
from (Ferraris et al. 2009).
Example 4, continued. We would like to find the stable models of (28), with q
intensional, that have the universe {a, b, c, d } and make p true on a, b and false
on c, d . This is the same as to look for the Herbrand stable models of the formula
∀x (¬p(x ) → (q(x ) ∨ ¬q(x ))) ∧ p(a) ∧ p(b),
with c and d viewed as object constants of the language along with a and b, and
with both p and q taken to be intensional.
15
16
17

They also require that the input satisfy some safety conditions. See, for instance, Chapter 3 of
the dlv manual, http://www.dbai.tuwien.ac.at/proj/dlv/man/.
See Footnote (12 ).
Specifically, under the assumption that every occurrence of every extensional predicate in F is
in the scope of negation or in the antecedent of an implication.

Representing First-Order Causal Theories by Logic Programs

17

u(a;b;c;d).
#domain u(X).
{q(X)} :- not p(X).
p(a;b).
Fig. 1. Example 4 with a 4-element universe in the language of lparse

A representation of this example in the language of lparse is shown in Figure 1.
The auxiliary predicate u describes the universe of the interpretations that we are
interested in. The first line is shorthand for
u(a). u(b). u(c). u(d).
and the last line is understood by lparse in a similar way.
Given this input, the answer set solver smodels generates 4 stable models, representing the subsets of {a, b, c, d } that are disjoint from {a, b}:
Answer: 1
Stable Model:
Answer: 2
Stable Model:
Answer: 3
Stable Model:
Answer: 4
Stable Model:

p(b) p(a) u(d) u(c) u(b) u(a)
p(b) p(a) q(d) u(d) u(c) u(b) u(a)
p(b) p(a) q(c) u(d) u(c) u(b) u(a)
p(b) p(a) q(d) q(c) u(d) u(c) u(b) u(a)

In application to the logic program obtained from a causal theory T as described
in Section 5, this process often allows us to find the models of T with a given
universe and given extents of extensional predicates.
Example 7, continued. There are two switches, myswitch and hisswitch. It is
dark in my room at time 1 if and only if myswitch is not on at time 1. At time 0,
both switches are on; then hisswitch is toggled, and myswitch is not. Is it dark
in my room at time 1? We would like to answer this question using answer set
programming.
This example of commonsense reasoning involves inertia (the value of the fluent
on(myswitch) does not change because this fluent is not affected by the action that
is executed) and indirect effects of actions: whether or not it is dark in the room
at time 1 after performing some actions is determined by the effect of these actions
on the fluent on(myswitch).
Mathematically, we are talking here about the causal theory T with rules (32)
and (36), with the object constant hisswitch added to the language, and with the
explainable symbols on 1 and dark . We are interested in the Herbrand models of T
in which the extents of the extensional predicates are described by the atoms
on 0 (myswitch), on 0 (hisswitch), toggle(hisswitch)·
As we have seen, the logic program Tr[T ] is equivalent to the conjunction of

18

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

u(myswitch;hisswitch).
#domain u(X).
on1(X) :- toggle(X), not on0(X).
-on1(X) :- toggle(X), on0(X).
on1(X) :- on0(X), not -on1(X).
-on1(X) :- not on0(X), not on1(X).
:- not on1(X), not -on1(X).
on1(myswitch) :- -dark.
-dark :- on1(myswitch).
-on1(myswitch) :- dark.
dark :- -on1(myswitch).
:- not dark, not -dark.
on0(myswitch;hisswitch).
toggle(hisswitch).
Fig. 2. Example 7 with two switches in the language of lparse

rules (35) and (37). The corresponding lparse input file is shown in Figure 2. In
this file, the “true negation” symbol - is used in the ASCII representations of the
[ ; the lparse counterparts of the rules
symbols od
n 1 and dark
∀x ¬(on 1 (x ) ∧ od
n 1 (x )),
[
¬(dark ∧ dark )

are dropped, because such “coherence” conditions are verified by the system automatically.
Given this input, smodels generates the only model of T satisfying the given
conditions:
Answer: 1
Stable Model: -on1(hisswitch) on1(myswitch) -dark toggle(hisswitch)
on0(hisswitch) on0(myswitch) u(hisswitch) u(myswitch)
The presence of -dark in this model tells us that it is not dark in the room at
time 1.
The example above is an example of “one-step temporal projection”—predicting
the value of a fluent after performing a single action in a given state. Some other
kinds of temporal reasoning and planning can be performed by generating models of
simple modifications of the given causal theory (Giunchiglia et al. 2004, Section 3.3);
this is one of the ideas behind the design of CCalc and coala. McCain’s translation reviewed in the introduction and its generalization presented in Section 5 allow
us to solve such problems automatically using an answer set solver.

Representing First-Order Causal Theories by Logic Programs

19

7 Proof of Soundness
To prove claim (40), which expresses the soundness of our translation, we will first
establish it for the case when C = L = S = ∅ (Section 7.1). In this “leading special
case” all rules of the given causal theory are D-rules, and they are converted to
program rules using the translation Trd . Then we will derive the soundness theorem
in full generality (Section 7.2).
7.1 Leading Special Case
Let T be a finite set of causal rules of the form (38). Let Π be the conjunction of the
corresponding program rules (39), and let CC , as before, stand for the conjunction
of the completeness constraints (29) for all explainable symbols p of T . We want
to show that
SMpbp [Π ∧ CC ] is equivalent to T ∧ CC ·

(41)

The key steps in the proof below are Lemma 5 (one half of the equivalence) and
Lemma 8 (the other half).
In the statement of the following lemma, ¬p stands for the list of predicate
expressions18 λx¬p(x), where x is a list of distinct object variables, for all p from p.
By υp, υb
p we denote the lists of predicate variables used in the second-order formula
SMpbp [Π ∧ CC ] (see Section 4).
Lemma 1
Formula (υp, υb
p) < (p, ¬p) is equivalent to
_
(((υp, υb
p) ≤ (p, ¬p)) ∧ ∃x(¬υp(x) ∧ ¬υb
p (x)))·
p∈p

Proof
Note first that
(υp, υb
p) < (p, ¬p)
⇔ ((υp, υb
p) ≤ (p, ¬p)) ∧ ¬ ((p, ¬p) ≤ (υp, υb
p))
W
p (x)))
⇔ ((υp, υb
p) ≤ (p, ¬p)) ∧ p∈p ∃x((p(x) ∧ ¬υp(x)) ∨ (¬p(x) ∧ ¬υb
W
⇔ p∈p (((υp, υb
p) ≤ (p, ¬p)) ∧ ∃x((p(x) ∧ ¬υp(x)) ∨ (¬p(x) ∧ ¬υb
p (x))))·
The disjunction after ∃x is equivalent to
(p(x) ∨ ¬υb
p (x)) ∧ (¬υp(x) ∨ ¬p(x)) ∧ (¬υp(x) ∨ ¬υb
p (x))·

(42)

Since (υp, υb
p) ≤ (p, ¬p) entails
υp(x) → p(x) and υb
p (x) → ¬p(x),
the first conjunctive term of (42) can be rewritten as ¬υb
p (x), and the second term
as ¬υp(x), so that (42) will turn into ¬υp(x) ∧ ¬υb
p (x).
18

See (Lifschitz 1994, Section 3.1).

20

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

For any formula F , by FΣ1 we denote the formula
(υp)(υb
p)

F(υp∧p)(¬υp∧¬p)
where υp ∧ p is understood as the list of predicate expressions
λx(υp(x) ∧ p(x))
for all p ∈ p, and ¬υp ∧ ¬p is understood in a similar way.19
Lemma 2
Formula
((υp, υb
p) < (p, ¬p))Σ1
is equivalent to υp 6= p.
Proof
In view of Lemma 1, ((υp, υb
p) < (p, ¬p))Σ1 is equivalent to the disjunction of the
formulas


V
V
∧
p (x) → ¬p(x))Σ1
p∈p ∀x(υb
p∈p ∀x(υp(x) → p(x))Σ1
(43)
∧ ∃x(¬υp(x) ∧ ¬υb
p (x))Σ1
for all p ∈ p. It is easy to verify that
(υp(x) → p(x))Σ1
(υb
p (x) → ¬p(x))Σ1
(¬υp(x) ∧ ¬υb
p (x))Σ1

= (υp(x) ∧ p(x) → p(x)) ⇔ ⊤ ,
= (¬υp(x) ∧ ¬p(x) → ¬p(x)) ⇔ ⊤,
⇔ ((¬υp(x) ∨ ¬p(x)) ∧ ¬(¬υp(x) ∧ ¬p(x)))
⇔ (υp(x) ↔ ¬p(x))
⇔ ¬(υp(x) ↔ p(x))·

Therefore (43) is equivalent to ∃x¬(υp(x) ↔ p(x)), so that the disjunction of all
formulas (43) is equivalent to υp 6= p.
If A is an atomic formula p(t), where p ∈ p and t is a tuple of terms, then we
b for υb
will write υA for υp(t), and A
p (t). By e
∀obj F we denote the formula ∀xF ,
where x is list of all free object variables of F (“object-level universal closure”).
Define H (υp, υb
p) to be the conjunction of the implications


_
_
e
b ∨ A) → υA) ∨
b 
((υ A
((υA ∨ ¬A) → υ A)
∀obj G →
(44)
A∈Pos

A∈Neg

for all rules (38) in T .
Lemma 3
Formula SMpbp [Π ∧ CC ] is equivalent to
Π ∧ CC ∧ ∀(υp)(υb
p)(((υp, υb
p) < (p, ¬p)) → ¬H (υp, υb
p))·

19

p

For the definition of Fυp see Section 3.

(45)

Representing First-Order Causal Theories by Logic Programs

21

Proof
Every occurrence of every intensional predicate in CC is in the scope of a negation.
Consequently SMpbp [Π ∧ CC ] is
b )) ∧ Π⋄ (υp, υb
Π ∧ CC ∧ ¬∃(υp)(υb
p)(((υp, υb
p) < (p, p
p) ∧ CC ),

which is equivalent to

Π ∧ CC ∧ ∀(υp)(υb
p)(((υp, υb
p) < (p, ¬p)) → ¬Π⋄ (υp, υb
p))·
We will conclude the proof by showing that CC entails
Π⋄ (υp, υb
p) ↔ H (υp, υb
p)·
The left-hand side of this equivalence is the conjunction of the formulas


^
^
_
_
e
b ∨ ¬A)
b ∧
b
∀obj ¬¬G ∧
(υ A
(υA ∨ ¬A) →
υA ∨
υA
A∈Pos

A∈Neg

A∈Pos

A∈Neg

for all rules (38) in T . Under the assumption CC this formula can be rewritten as


_
_
_
_
e
b ∨ A) ∨
b ·
∀obj G →
¬(υ A
¬(υA ∨ ¬A) ∨
υA ∨
υA
A∈Pos

A∈Neg

A∈Pos

A∈Neg

The last formula is equivalent to


_
_
e
b ∨ A) ∨ υA) ∨
b ·
∀obj G →
(¬(υ A
(¬(υA ∨ ¬A) ∨ υ A)
A∈Pos

A∈Neg

and consequently to (44).
Lemma 4
T † (υp) is equivalent to H (υp, υb
p)Σ1 .
Proof
Formula T † (υp) is the conjunction of the formulas


_
_
e
∀obj G →
υA ∨
¬υA
A∈Pos

(46)

A∈Neg

for all rules (38) in T . On the other hand, H (υp, υb
p)Σ1 is the conjunction of the
formulas


_
_
e
b Σ1 
b ∨ A) → υA)Σ1 ∨
((υA ∨ ¬A) → υ A)
(47)
((υ A
∀obj G →
A∈Neg

A∈Pos

for all rules (38) in T . It remains to observe that
b ∨ A) → υA)Σ1
((υ A

=
⇔
⇔
⇔

(¬υA ∧ ¬A) ∨ A → υA ∧ A
¬υA ∨ A → υA ∧ A
(υA ∧ ¬A) ∨ (υA ∧ A)
υA,

22

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

b Σ1 is equivalent to ¬υA.
and that, similarly, ((υA ∨ ¬A) → υ A)
Lemma 5
SMpbp [Π ∧ CC ] |= T ∧ CC .

Proof
Recall that, according to Lemma 3, SMpbp [Π∧CC ] is equivalent to (45). The second
conjunctive term of (45) is CC . The first conjunctive term is equivalent to T † (p).
From the other two terms we conclude:
b ))Σ1 → ¬H (υp, υb
∀υp(((υp, υb
p) < (p, p
p)Σ1 )·

By Lemma 2 and Lemma 4, this formula is equivalent to
∀υp((υp 6= p) → ¬T † (υp)),
and consequently to
∀υp(T † (υp) → (υp = p))·

The conjunction of the last formula with T † (p) is equivalent to (24).
For any formula F , by FΣ2 we denote the formula
υp
F(((υp,υb
p)≤(p,¬p))∧¬υp∧¬υb
p)↔¬p

where the subscript
(((υp, υb
p) ≤ (p, ¬p)) ∧ ¬υp ∧ ¬υb
p) ↔ ¬p
is understood as the list of predicate expressions
λx((((υp, υb
p) ≤ (p, ¬p)) ∧ ¬υp(x) ∧ ¬υb
p (x)) ↔ ¬p(x))
for all p ∈ p.
Lemma 6
Formula
(υp 6= p)Σ2
is equivalent to (υp, υb
p) < (p, ¬p).
Proof
Formula (υp 6= p)Σ2 is equivalent to
_
∃x(υp(x) ↔ ¬p(x))Σ2
p∈p

that is,
_

∃x((((υp, υb
p) ≤ (p, ¬p)) ∧ ¬υp(x) ∧ ¬υb
p (x) ↔ ¬p(x)) ↔ ¬p(x))·

p∈p

This formula can be equivalently rewritten as
_
(((υp, υb
p) ≤ (p, ¬p)) ∧ ∃x(¬υp(x) ∧ ¬υb
p (x))),
p∈p

which is equivalent to (υp, υb
p) < (p, ¬p) by Lemma 1.

Representing First-Order Causal Theories by Logic Programs

23

Lemma 7
The implication
(υp, υb
p) ≤ (p, ¬p) → (T † (υp)Σ2 ↔ H (υp, υb
p))
is logically valid.
Proof
Recall that T † (υp) is the conjunction of implications (46) for all rules (38) in T .
Consequently T † (υp)Σ2 is the conjunction of the formulas


_
_
e
∀obj G →
(υA)Σ2 ∨
¬(υA)Σ2  ,
A∈Pos

A∈Neg

that is to say,
W
e
b ↔ ¬A) ∨
((((υp, υb
p) ≤ (p, ¬p)) ∧ ¬υA ∧ ¬υ A)
∀obj (G →
WA∈Pos
b ↔ ¬A)·
p) ≤ (p, ¬p)) ∧ ¬υA ∧ ¬υ A)
A∈Neg ¬((((υp, υb

Under the assumption

(υp, υb
p) ≤ (p, ¬p)

(48)

the last formula can be equivalently rewritten as


_
_
e
b ↔ A) ∨
b ↔ ¬A) ·
((υA ∨ υ A)
∀obj G →
((υA ∨ υ A)
A∈Pos

A∈Neg

It remains to check that, under assumption (48),
b ↔A
(υA ∨ υ A)

(49)

b ∨ A → υA,
υA

(50)

b ↔ ¬A
υA ∨ υ A

(51)

b
υA ∨ ¬A → υ A·

(52)

b → A) ∧ (A → υA ∨ υA)·
b
(υA → A) ∧ (υ A

(53)

b ∧ (A → υA)·
¬υ A

(54)

can be equivalently rewritten as

and

can be rewritten as

Formula (49) is equivalent to

b → ¬A, formula (53) can be rewritten
Since assumption (48) entails υA → A and υ A
as

On the other hand, formula (50) is equivalent to
b → υA) ∧ (A → υA),
(υ A

24

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

which, under assumption (48), can be rewritten as (54) as well. In a similar way,
each of the formulas (51), (52) can be transformed into
b ·
¬υA ∧ (¬A → υ A)
Lemma 8
T ∧ CC |= SMpbp [Π ∧ CC ].
Proof
Recall that T is equivalent to
T † (p) ∧ ∀υp(T † (υp) → (υp = p))·

(55)

Since the first conjunctive term is equivalent to Π, T ∧ CC entails
Π ∧ CC ·

(56)

From the second conjunctive term of (55) we conclude
T † (υp)Σ2 → (υp = p)Σ2
and consequently
∀(υp)(υb
p)((υp 6= p)Σ2 → ¬T † (υp)Σ2 )·
By Lemma 6, this is equivalent to
∀(υp)(υb
p)(((υp, υb
p) < (p, ¬p)) → ¬T † (υp)Σ2 )
and, by Lemma 7, to
∀(υp)(υb
p)(((υp, υb
p) < (p, ¬p)) → ¬H (υp, υb
p))·
By Lemma 3, the conjunction of this formula with (56) is equivalent to sentence
SMpbp [Π ∧ CC ].
Assertion (41) follows from Lemmas 5 and 8.
7.2 General Case
Lemma 9
For any C-rule R, Trc [R] is intuitionistically equivalent to Trd [R].
Proof
If R is ⊥ ⇐ G then Trc [R] is e
∀¬G, and Trd [R] is e
∀(¬¬G → ⊥).
Lemma 10
For any L-rule R, the conjunction CC of completeness constraints intuitionistically
entails
Trl [R] ↔ Trd [R]·

Representing First-Order Causal Theories by Logic Programs

25

Proof
If R is p(t) ⇐ G then Trl [R] is
e
∀(¬¬G → p(t)),

and Trd [R] is

e
∀(¬¬G ∧ (b
p (t) ∨ ¬b
p (t)) → p(t))·

Since CC intuitionistically entails
¬(p(t) ↔ pb(t)),

(57)

pb(t) ∨ ¬b
p (t) → p(t)

(58)

it is sufficient to check that p(t) can be derived from (57) and

by the deductive means of intuitionistic propositional logic. Since (58) is equivalent
to p(t) in classical propositional logic, it is easy to see that ¬b
p (t) can be derived
from (57) and (58) in classical propositional logic. By Glivenko’s theorem,20 it follows that it can be derived intuitionistically as well. Since p(t) is intuitionistically
derivable from (58) and ¬b
p (t), we can conclude that p(t) is intuitionistically derivable from (57) and (58).
The case when R is ¬p(t) ⇐ G is similar.
Lemma 11
If R is an S-rule
L1 ↔ L2 ⇐ G

(59)

and R1 , R2 are the D-rules
L1 ∨ L2 ⇐ G and L1 ∨ L2 ⇐ G

(60)

then the conjunction CC of completeness constraints intuitionistically entails
Trs [R] ↔ Trd [R1 ] ∧ Trd [R2 ]·
Proof
If each of the literals Li is an atom Ai then Trs [R] is the conjunction of the formulas
e
∀(¬¬G
e
∀(¬¬G
e
∀(¬¬G
e
∀(¬¬G

Trd [R1 ] is

∧ A1
∧ A2
c1
∧A
c2
∧A

→ A2 ),
→ A1 ),
c2 ),
→A
c1 ),
→A

e
c1 ∨ ¬A
c1 ) ∧ (A2 ∨ ¬A2 ) → A1 ∨ A
c2 ),
∀(¬¬G ∧ (A
20

(61)

(62)

This theorem (Glivenko 1929), (Mints 2000, Theorem 3.1) asserts that if a formula beginning
with negation can be derived from a set Γ of formulas in classical propositional logic then it can
be derived from Γ in intuitionistic propositional logic as well.

26

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang

and Trd [R2 ] is
e
c2 ∨ ¬A
c2 ) → A
c1 ∨ A2 )·
∀(¬¬G ∧ (A1 ∨ ¬A1 ) ∧ (A

(63)

c1 )
¬(A1 ↔ A

(64)

c2 ),
¬(A2 ↔ A

(65)

A1 ↔ A2

(66)

c1 ↔ A
c2
A

(67)

c1 ∨ ¬A
c1 ) ∧ (A2 ∨ ¬A2 ) → A1 ∨ A
c2
(A

(68)

c2 ∨ ¬A
c2 ) → A
c1 ∨ A2 ·
(A1 ∨ ¬A1 ) ∧ (A

(69)

c1 ∨ ¬A
c1 ) ∧ (A2 ∨ ¬A2 );
(A

(70)

We need to show that CC intuitionistically entails the equivalence between the
conjunction of formulas (61) and the conjunction of formulas (62), (63). Since CC
intuitionistically entails

and

it is sufficient to check that the conjunction of formulas (64), (65),

and

is equivalent in intuitionistic propositional logic to the conjunction of formulas (64), (65),

and

Left-to-right: Assume (64)–(67) and

c2 . Consider two cases, in accordance
our goal is to derive intuitionistically A1 ∨ A
c
c2 , and consequently
with the first disjunction in (70). Case 1: A1 . Then, by (67), A
c
c
A1 ∨ A2 . Case 2: ¬A1 . Consider two cases, in accordance with the second disjunction
c2 . Case 2.2: ¬A2 .
in (70). Case 2.1: A2 . Then, by (66), A1 , and consequently A1 ∨ A
Then, by (66), ¬A1 , which contradicts (64).
Thus we proved that (68) is intuitionistically derivable from (64)–(67). The proof
for (69) is similar.
Right-to-left: Let Γ be the set consisting of formulas (64), (65), (68), (69) and A1 .
We claim that A2 can be derived from Γ in intuitionistic propositional logic. Note
that, classically,
c1 ,
• Formula (64) is equivalent to A1 ↔ ¬A
c2 , and
• Formula (65) is equivalent to A2 ↔ ¬A
c
• Formula (69) is equivalent to A1 ∨ A2 .

c2 is derivable from Γ in classical propositional logic. By Glivenko’s
It follows that ¬A
c2 is derivable from Γ intuitionistically as well. Hence the
theorem, it follows that ¬A
antecedent of (69) is an intuitionistic consequence of Γ, and so is the consequent
c1 ∨ A2 . In combination with A1 and (64), this gives us A2 .
A
We conclude that A1 → A2 is intuitionsistically derivable from (64), (65), (68)

Representing First-Order Causal Theories by Logic Programs

27

and (69). The derivability of the implication A2 → A1 from these formulas can be
proved in a similar way. Thus (66) is an intuitionistic consequence of (64), (65),
(68), and (69).
The derivability of (67) from these formulas in propositional intuitionistic logic
is proved in a similar way.
The cases when the literals Li are negative, or when one of them is positive and
the other is negative, are similar.
Proof of the soundness property (40). Let C , L, S , and D be sets of causal rules of
types C, L, S, and D respectively, and let T be the causal theory with the set of
rules C ∪ L ∪ S ∪ D . Consider the causal theory T ′ obtained from T by replacing
each rule (59) from S with the corresponding rules (60). According to the result (41)
of Section 7.1,
SMpbp [Π ∧ CC ] is equivalent to T ′ ∧ CC ,
where Π is the conjunction of the program rules Trd [R] for all rules R of T ′ . It is
clear that Π ∧ CC is Tr[T ′ ], and that T ′ is equivalent to T . Consequently
SMpbp [Tr[T ′ ]] is equivalent to T ∧ CC ·

(71)

On the other hand, Lemmas 9, 10 and 11 show that the formulas Tr[T ′ ] and
Tr[C , L, S , D ] are intuitionistically equivalent to each other, because each of them
contains CC as a conjunctive term. It follows that
SMpbp [Tr[T ′ ]] is equivalent to SMpbp [Tr[C , L, S , D ]]·

(72)

Assertion (40) follows from (71) and (72).

8 Conclusion
In this paper we generalized McCain’s embedding of definite causal theories into
logic programming. We expect that this work will provide a theoretical basis for
extending the system coala to more expressive action languages, including the
modular action language MAD (Ren 2009). It is essential, from this perspective,
that our translation is applicable to synonymity rules, because such rules are closely
related to the main new feature of MAD, its import construct.
Our translation is not applicable to causal rules with quantifiers in the head. It
may be possible to extend it to positive occurrences of existential quantifiers, since
an existentially quantified formula can be thought of as an infinite disjunction.
But the translation would be a formula with positive occurrences of existential
quantifiers as well, and it is not clear how to turn such a formula into executable
code.
In the future, we would like to extend the translation described above to causal
theories with explainable function symbols, which correspond to non-Boolean fluents in action languages. Since the definition of a stable model does not allow
function symbols to be intensional, such a generalization would have to involve
extending the language by auxiliary predicate symbols.

28

P. Ferraris, J. Lee, Y. Lierler, V. Lifschitz, and F. Yang
Acknowledgements

We are grateful to the anonymous referees for useful comments. Joohyung Lee was
partially supported by the National Science Foundation under grant IIS-0916116
and by the Office of the Director of National Intelligence (ODNI), Intelligence
Advanced Research Projects Activity (IARPA), through US Army. Yuliya Lierler
was supported by a 2010 Computing Innovation Fellowship. Vladimir Lifschitz and
Fangkai Yang were supported by the National Science Foundation under grant IIS0712113. All statements of fact, opinion or conclusions contained herein are those
of the authors and should not be construed as representing the official views or
policies of IARPA, the ODNI or the U.S. Government.

References
Akman, V., Erdoğan, S., Lee, J., Lifschitz, V., and Turner, H. 2004. Representing
the Zoo World and the Traffic World in the language of the Causal Calculator. Artificial
Intelligence 153(1–2), 105–140.
Armando, A., Giunchiglia, E., and Ponta, S. E. 2009. Formal specification and
automatic analysis of business processes under authorization constraints: an actionbased approach. In Proceedings of the 6th International Conference on Trust, Privacy
and Security in Digital Business (TrustBus’09).
Artikis, A., Sergot, M., and Pitt, J. 2009. Specifying norm-governed computational
societies. ACM Transactions on Computational Logic 9, 1.
Caldiran, O., Haspalamutgil, K., Ok, A., Palaz, C., Erdem, E., and Patoglu, V.
2009. Bridging the gap between high-level reasoning and low-level control. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning
(LPNMR). 242–354.
Clark, K. 1978. Negation as failure. In Logic and Data Bases, H. Gallaire and J. Minker,
Eds. Plenum Press, New York, 293–322.
Ferraris, P. 2005. Answer sets for propositional theories. In Proceedings of International
Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 119–131.
Ferraris, P. 2006. Causal theories as logic programs. In Proceedings of Workshop on
Logic Programming (WLP). 35–44.
Ferraris, P. 2007. A logic program characterization of causal theories. In Proceedings
of International Joint Conference on Artificial Intelligence (IJCAI). 366–371.
Ferraris, P., Lee, J., and Lifschitz, V. 2011. Stable models and circumscription.
Artificial Intelligence 175, 236–263.
Ferraris, P., Lee, J., Lifschitz, V., and Palla, R. 2009. Symmetric splitting in the
general theory of stable models. In Proceedings of International Joint Conference on
Artificial Intelligence (IJCAI). 797–803.
Gebser, M., Grote, T., and Schaub, T. 2010. Coala: a compiler from action languages
to ASP. In Proceedings of European Conference on Logics in Artificial Intelligence
(JELIA). 169–181.
Gelfond, M. and Lifschitz, V. 1988. The stable model semantics for logic programming. In Proceedings of International Logic Programming Conference and Symposium,
R. Kowalski and K. Bowen, Eds. MIT Press, 1070–1080.
Gelfond, M. and Lifschitz, V. 1991. Classical negation in logic programs and disjunctive databases. New Generation Computing 9, 365–385.

Representing First-Order Causal Theories by Logic Programs

29

Giunchiglia, E., Lee, J., Lifschitz, V., McCain, N., and Turner, H. 2004. Nonmonotonic causal theories. Artificial Intelligence 153(1–2), 49–104.
Giunchiglia, E. and Lifschitz, V. 1998. An action language based on causal explanation: Preliminary report. In Proceedings of National Conference on Artificial Intelligence
(AAAI). AAAI Press, 623–630.
Glivenko, V. 1929. Sur quelques points de la logique de M. Brouwer. Académie Royale
de Belgique. Bulletins de la Classe des Sciences, se’rie 5 15, 183–188.
Lee, J., Lierler, Y., Lifschitz, V., and Yang, F. 2010. Representing synonymity in
causal logic and in logic programming21 . In Proceedings of International Workshop on
Nonmonotonic Reasoning (NMR).
Lee, J. and Palla, R. 2009. System F2LP — computing answer sets of first-order
formulas. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 515–521.
Lifschitz, V. 1985. Computing circumscription. In Proceedings of International Joint
Conference on Artificial Intelligence (IJCAI). 121–127.
Lifschitz, V. 1994. Circumscription. In Handbook of Logic in AI and Logic Programming, D. Gabbay, C. Hogger, and J. Robinson, Eds. Vol. 3. Oxford University Press,
298–352.
Lifschitz, V. 1997. On the logic of causal explanation. Artificial Intelligence 96, 451–465.
Lifschitz, V. 2008. What is answer set programming? In Proceedings of the AAAI
Conference on Artificial Intelligence. MIT Press, 1594–1597.
Lifschitz, V. and Ren, W. 2006. A modular action description language. In Proceedings
of National Conference on Artificial Intelligence (AAAI). 853–859.
Lifschitz, V. and Ren, W. 2007. The semantics of variables in action descriptions. In
Proceedings of National Conference on Artificial Intelligence (AAAI). 1025–1030.
Lifschitz, V. and Yang, F. 2010. Translating first-order causal theories into answer
set programming. In Proceedings of the European Conference on Logics in Artificial
Intelligence (JELIA). 247–259.
Marek, V. and Truszczyński, M. 1999. Stable models and an alternative logic programming paradigm. In The Logic Programming Paradigm: a 25-Year Perspective.
Springer Verlag, 375–398.
McCain, N. 1997. Causality in commonsense reasoning about actions22 . Ph.D. thesis,
University of Texas at Austin.
McCain, N. and Turner, H. 1997. Causal theories of action and change. In Proceedings
of National Conference on Artificial Intelligence (AAAI). 460–465.
McCarthy, J. 1986. Applications of circumscription to formalizing common sense knowledge. Artificial Intelligence 26, 3, 89–116.
Mints, G. 2000. A Short Introduction to Intuitionistic Logic. Kluwer.
Niemelä, I. 1999. Logic programs with stable model semantics as a constraint programming paradigm. Annals of Mathematics and Artificial Intelligence 25, 241–273.
Ren, W. 2009. A modular language for describing actions23 . Ph.D. thesis, University of
Texas at Austin.
Shanahan, M. 1997. Solving the Frame Problem: A Mathematical Investigation of the
Common Sense Law of Inertia. MIT Press.

21
22
23

http://userweb.cs.utexas.edu/users/vl/papers/syn.pdf
ftp://ftp.cs.utexas.edu/pub/techreports/tr97-25.ps.gz
http://www.cs.utexas.edu/users/rww6/dissertation.pdf

Yet Another Proof of the Strong Equivalence Between
Propositional Theories and Logic Programs
Joohyung Lee and Ravi Palla
School of Computing and Informatics
Arizona State University, Tempe, AZ, USA
{joolee, Ravi.Palla}@asu.edu

Abstract. Recently, the stable model semantics was extended to the syntax of
arbitrary propositional formulas, which are beyond the traditional rule form. Cabalar and Ferraris, as well as Cabalar, Pearce, and Valverde, showed that any
propositional theory under the stable model semantics can be turned into a logic
program. In this note, we present yet another proof of this result. Unlike the other
approaches that are based on the logic of here-and-there, our proof uses familiar
properties of classical logic. Based on this idea, we present a prototype implementation for computing stable models of propositional theories using the answer set
solver DLV. We also note that every first-order formula under the stable model
semantics is strongly equivalent to a prenex normal form whose matrix has the
form of a logic program.

1 Introduction
Recently, the stable model semantics was extended to the syntax of arbitrary propositional formulas, which are beyond the traditional rule form [1, 2]. Ferraris [2] showed
that nonmonotone aggregates can be naturally expressed in the extended syntax. On the
other hand, Cabalar and Ferraris [3] showed that every propositional theory under the
stable model semantics is strongly equivalent [4] to a logic program. They provided
two proofs based on the logic of here-and-there, one by syntactic transformation, and
the other by constructing a logic program using countermodels of the theory. An approach similar to the first proof was taken in [5], where the authors presented a set of
rules for rewriting a propositional theory into a disjunctive logic program. These rules
are an extension of the rules for turning a program with nested expressions into a logic
program [6], which led to an implementation NLP [7]. The system is essentially a preprocessor to the answer set solver DLV 1 for handling programs with nested expressions.
In this note, we present yet another proof of the theorem on strong equivalence between propositional theories and logic programs. Unlike the other approaches that are
based on the logic of here-and-there, our proof is based on an operator that characterizes strong equivalence in terms of classical logic, using an extended signature with two
groups of atoms, the original one corresponding to the “there” world, and a group of
newly introduced atoms referring to the “here” world. This not only shows that the reduction is possible, but also tells us how to generate strongly equivalent logic programs
based on equivalence in classical logic.
1

http://www.dbai.tuwien.ac.at/proj/dlv/ .

2

Joohyung Lee and Ravi Palla

The reduction idea has led us to develop a prototype implementation, which we call
that computes the stable models of an arbitrary propositional theory. Similar to
NLP , the system turns a propositional theory into a disjunctive logic program and calls
DLV .
We also apply the reduction idea to first-order formulas under the new definition
of stable model semantics, recently proposed in [8]. We show that any first-order theory under the stable model semantics is strongly equivalent to a prenex normal form
whose matrix has the form of a logic program. Thus the syntactic difference of arbitrarily nested connectives and quantifiers is not essential between the language proposed
in [8] and logic programs. On the other hand, since the prenex normal form may contain existential quantifiers, it is different from a logic program, where all variables are
assumed to be universally quantified.
In the next section, we review the definition of stable models for arbitrary propositional formulas as well as the definition of strong equivalence between propositional
formulas, and present how to find a logic program that is strongly equivalent to a given
formula. In Section 3, we present a simpler transformation, and in Section 4, we extend
the reduction idea to arbitrary first-order formulas and note that every first-order theory
is strongly equivalent to a prenex normal form. In Section 5, we present a prototype
implementation of computing the stable models of propositional theories.
F 2 LP ,2

2 Reducing propositional formulas to logic programs
We first review the definition of a stable model proposed in [8], by restricting attention to the propositional case. This definition is essentially the same as the encoding
of formulas of equilibrium logic by quantified Boolean formulas given in [9], and is
equivalent to the fixpoint definition of a stable model proposed in [2].
Let F be a propositional formula and σ a signature consisting of all atoms p1 , . . . , pn
occurring in F . By SM[F ] we denote the second-order propositional sentence
F ∧ ∀u((u < p) → ¬F ∗ (u)),
where p stands for the tuple p1 , . . . , pn , u is a tuple of n distinct propositional variables
u1 , . . . , un , equation u < p stands for
(u1 → p1 ) ∧ · · · ∧ (un → pn ) ∧ ¬((p1 → u1 ) ∧ · · · ∧ (pn → un ))
as in the definition of circumscription, and F ∗ (u) is defined recursively, as follows:
–
–
–
–

p∗i = ui ;
⊥∗ = ⊥;
(F ⊙ G)∗ = F ∗ ⊙ G∗ , where ⊙ ∈ {∧, ∨};
(F → G)∗ = (F ∗ → G∗ ) ∧ (F → G).

We regard ¬F as shorthand for F → ⊥. Note that ¬ corresponds to not in the logic
program syntax. For instance, the rule
p ← not q
2

http://peace.eas.asu.edu/f2lp .

Strong Equivalence Between Propositional Theories and Logic Programs

3

is identified with the formula
¬q → p .
∗

The operator F 7→ F (u) replaces each atom with the corresponding propositional
variable, and commutes with all propositional connectives except implication. If, in
the definition of this operator, we drop the second conjunctive term in the clause for
implication, then F ∗ (u) will turn into the formula F (u) referred to in the definition of
circumscription [10, 11]. A model of F is stable if it satisfies SM[F ].
According to [12, Section 2.6], a (propositional) formula F is said to be strongly
equivalent to a formula G if any formula F ′ that contains an occurrence of F has the
same stable models as the formula G′ obtained from F ′ by replacing that occurrence
with G. This condition is more general than the original definition from [4] not only
because it is applicable to arbitrary formulas, but also because F is allowed here to be
any subformula of F ′ , not necessarily a “subconjunction.”
Our reduction idea is based on the following proposition from [8], which generalizes
the main theorem from [13], stating that the strong equivalence between two formulas
F and G can be characterized in terms of equivalence (in classical logic) between F ∗
and G∗ . Let σ ′ be a signature consisting of distinct atoms {p′1 , . . . , p′n } that are disjoint
from σ, and let p′ stand for the tuple p′1 , . . . , p′n . Formula F ∗ (p′ ) is obtained from
F ∗ (u) by substituting the atoms p′ for propositional variables u. Thus F ∗ (p′ ) is a
transformation of F in signature σ ∪ σ ′ . Equation p′ ≤ p stands for
(p′1 → p1 ) ∧ · · · ∧ (p′n → pn )
as in the definition of circumscription.
Proposition 1 [8, Proposition 5] Formulas F and G of signature σ are strongly equivalent iff
p′ ≤ p → (F ∗ (p′ ) ↔ G∗ (p′ ))
(1)
is a tautology.
As usual, a formula F is in negation normal form if, for every subformula G → H
of F , formula G is an atom, and H is ⊥. An occurrence of a formula G in a formula F
is positive if the number of implications in F containing the occurrence of G in the
antecedent is even, and negative otherwise.
Definition 1. An implication F → G of signature σ ∪ σ ′ is called a canonical implication if F and G are formulas in negation normal form such that every occurrence of
atoms from σ ′ is positive, and every occurrence of atoms from σ is negative.
For example,
p′ ∧ q → r
is not canonical, while
(p′ ∨ (¬q ∧ r′ )) → (s′ ∧ ¬p)

(2)

is canonical.
Given a formula F of signature σ ∪ σ ′ , by R(F ) we denote the formula of signature σ that is obtained from F by dropping all occurrences of ′ in F . Note that R(F ),

4

Joohyung Lee and Ravi Palla

where F is a canonical implication, can be identified with a logic program with nested
expressions [6], by identifying ‘¬’ with not, ‘∧’ with ‘,’, and ‘∨’ with ‘;’. For instance,
in logic programming notation, when F is (2), R(F ) can be written as
s, not p ← p ; (not q, r) .
The following proposition tells us how to obtain a logic program that is strongly
equivalent to a given formula.
Proposition 2 Given a formula F , if G is a conjunction of canonical implications that
is equivalent to F ∗ , then F and R(G) are strongly equivalent.3
The proof of Proposition 2 uses the observation that
p′ ≤ p → (F ∗ ↔ (R(G))∗ )

(3)

is a tautology. In view of Proposition 1, it follows that F and R(G) are strongly equivalent. The fact that every propositional theory is strongly equivalent to a logic program
follows from the fact that every formula F ∗ can be equivalently rewritten as a conjunction of canonical implications. One way to do this is by forming a conjunctive normal
form (CNF) of F ∗ (p′ ), and then converting each of its clauses into a canonical implication as follows. Given a clause C of signature σ∪σ ′ , by Tr(C) we denote an implication
whose antecedent is the conjunction of
– all p′ where ¬p′ ∈ C, and
– all ¬p where p ∈ C,
and whose consequent is the disjunction of
– all p′ where p′ ∈ C, and
– all ¬p where ¬p ∈ C.
For instance, if C is (p′ ∨¬q ′ ∨r∨¬s), then Tr(C) is (q ′ ∧¬r → p′ ∨¬s). We can take G
in the statement of Proposition 2 to be the conjunction of Tr(C) for all clauses C in a
conjunctive normal form of F ∗ . In view of Proposition 1, it follows that every formula
is strongly equivalent to a logic program whose rules have the form
a1 ; . . . ; ak ; not ak+1 ; . . . ; not al ← al+1 , . . . , am , not am+1 , . . . , not an
(0 ≤ k ≤ l ≤ m ≤ n) where all ai are atoms.
Example 1 F = (p → q) → r.
((p → q) → r)∗ = (((p′ → q ′ ) ∧ (p → q)) → r′ ) ∧ ((p → q) → r)
↔ (p′ ∨ p ∨ r′ ) ∧ (¬q ′ ∨ p ∨ r′ ) ∧ (p′ ∨ ¬q ∨ r′ ) ∧ (¬q ′ ∨ ¬q ∨ r′ )
∧ (p ∨ r) ∧ (¬q ∨ r) .
3

For convenience, we will often drop “(p′ )” from F ∗ (p′ ) when there is no confusion.

Strong Equivalence Between Propositional Theories and Logic Programs

5

Under the assumption that (p′ , q ′ , r′ ) ≤ (p, q, r), the formula can be simplified to
(p ∨ r′ ) ∧ (p′ ∨ ¬q ∨ r′ ) ∧ (¬q ′ ∨ r′ ) ∧ (¬q ∨ r) .
Applying Tr to each clause yields the following formula G:
(¬p → r′ ) ∧ (p′ ∨ ¬q ∨ r′ ) ∧ (q ′ → r′ ) ∧ (¬r → ¬q).

(4)

(¬p → r) ∧ (p ∨ ¬q ∨ r) ∧ (q → r) ∧ (¬r → ¬q) .

(5)

Thus R(G) is

In logic programming notation, (5) can be written as follows:
r ← not p
p ; not q ; r
r ← q
not q ← not r .

(6)

Proposition 2 tells us that logic program (6) is strongly equivalent to (p → q) → r.
Example 2 F = p → ((q → r) ∨ s).
(p → ((q → r) ∨ s))∗ = (p′ → (((q ′ → r′ ) ∧ (q → r)) ∨ s′ )) ∧ (p → (q → r) ∨ s)
↔ (¬p′ ∨ (((¬q ′ ∨ r′ ) ∧ (¬q ∨ r)) ∨ s′ )) ∧ (¬p ∨ (¬q ∨ r) ∨ s)
↔ (¬p′ ∨ ¬q ′ ∨ r′ ∨ s′ ) ∧ (¬p′ ∨ ¬q ∨ r ∨ s′ ) ∧ (¬p ∨ ¬q ∨ r ∨ s) .
Applying Tr to each clause yields the following formula G:
(p′ ∧ q ′ → r′ ∨ s′ ) ∧ (p′ ∧ ¬r → ¬q ∨ s′ ) ∧ (¬r ∧ ¬s → ¬p ∨ ¬q) .

(7)

Thus R(G) is
(p ∧ q → r ∨ s) ∧ (p ∧ ¬r → ¬q ∨ s) ∧ (¬r ∧ ¬s → ¬p ∨ ¬q) .

(8)

In logic programming notation, (8) can be written as follows:
r ; s ← p, q
not q ; s ← p, not r
not p ; not q ← not r, not s .

(9)

Proposition 2 tells us that logic program (9) is strongly equivalent to formula p → ((q → r) ∨ s).

3 Simpler Transformation
The following observation shows how to disregard some redundancies with the translation introduced in the previous section.

6

Joohyung Lee and Ravi Palla

Proposition 3 Let F be a propositional formula of signature σ. Under the assumption
p′ ≤ p, if F ∗ is equivalent to G∧H where G is a conjunction of canonical implications
and H is a formula of signature σ that is entailed by R(G), then F ∗ is equivalent to
(R(G))∗ .
Example 1′ . F = (p → q) → r as in Example 1. Note that in (4), the last implication
(¬r → ¬q) is entailed by
R((¬p → r′ ) ∧ (p′ ∨ ¬q ∨ r′ ) ∧ (q ′ → r′ )).
Therefore, by Proposition 3, F ∗ is equivalent to
((¬p → r) ∧ (p ∨ ¬q ∨ r) ∧ (q → r))∗ .
In other words, in view of Proposition 1, F is strongly equivalent to the first three rules
of (6).
Example 2′ . F = p → ((q → r) ∨ s) as in Example 2. Note that in (7), the last
implication is entailed by
R((p′ ∧ q ′ → r′ ∨ s′ ) ∧ (p′ ∧ ¬r → ¬q ∨ s′ )) .
Therefore in view of Proposition 3, F ∗ is equivalent to
((p ∧ q → r ∨ s) ∧ (p ∧ ¬r → ¬q ∨ s))∗ .
In other words, in view of Proposition 1, F is strongly equivalent to the first two rules
of (9).
Based on Proposition 3, we consider the following definition which leads to a simpler transformation than the one given in Proposition 2.
Definition 2. For any formula F of signature σ, F ⋄ (u) is defined as follows:
–
–
–
–
–

p⋄i = ui ;
⊥⋄ = ⊥;
(F ∨ G)⋄ = F ∗ ∨ G∗ ;
(F ∧ G)⋄ = F ⋄ ∧ G⋄ ;
(F → G)⋄ = (F ∗ → G∗ ).

Note that F ⋄ is different from F ∗ when we identify F with a conjunction F1 ∧ · · · ∧ Fn (n ≥ 1),
F is
F1⋄ ∧ · · · ∧ Fn⋄
⋄

where
Fi⋄

=

(

G∗ → H ∗
Fi∗

if Fi is G → H,
otherwise.

The following proposition tells us that, in Proposition 2, F ⋄ can be considered in
place of F ∗ .

Strong Equivalence Between Propositional Theories and Logic Programs

7

Proposition 4 Given a formula F , if G is a conjunction of canonical implications that
is equivalent to F ⋄ , then F and R(G) are strongly equivalent.
Example 1′′ F = (p → q) → r as in Example 1. Under the assumption that
(p′ , q ′ , r′ ) ≤ (p, q, r),
F ⋄ (p′ , q ′ , r′ ) = ((p′ → q ′ ) ∧ (p → q)) → r′
↔ (p ∨ r′ ) ∧ (p′ ∨ ¬q ∨ r′ ) ∧ (¬q ′ ∨ r′ )
↔ (¬p → r′ ) ∧ (p′ ∨ ¬q ∨ r′ ) ∧ (q ′ → r′ ) .
Thus F is strongly equivalent to
(¬p → r) ∧ (p ∨ ¬q ∨ r) ∧ (q → r) ,
which is the same as in Example 1′ .
Example 2′′ F = p → ((q → r) ∨ s) as in Example 2. Under the assumption that
(p′ , q ′ , r′ , s′ ) ≤ (p, q, r, s),
F ⋄ (p′ , q ′ , r′ , s) = p′ → (((q ′ → r′ ) ∧ (q → r)) ∨ s′ )
↔ (¬p′ ∨ ¬q ′ ∨ r′ ∨ s′ ) ∧ (¬p′ ∨ ¬q ∨ r ∨ s′ )
↔ (p′ ∧ q ′ → r′ ∨ s′ ) ∧ (p′ ∧ ¬r → ¬q ∨ s′ ) .
Thus F is strongly equivalent to
(p ∧ q → r ∨ s) ∧ (p ∧ ¬r → ¬q ∨ s) ,
which is the same as in Example 2′ .
Due to lack of space, we do not provide a detailed comparison between our translation method and the others. However, we note that Proposition 2 not only shows that
the reduction is possible, but also tells us how to generate strongly equivalent logic programs of preferably smaller size, based on the notion of equivalence in classical logic.
This is in contrast with the other approaches that are based on syntactic rewriting rules
under the logic of here-and-there. For instance, given a formula
((p → q) → r) → r
our translation yields the following program:
q ; r ; not r ← p
not p ← not q .
On the other hand, the following program is obtained according to Section 3 of [5].
not p ; r
r
q ; r ; not r
not p ; r ; not r

← not q
←r
←p
← not q .

8

Joohyung Lee and Ravi Palla

However, clearly, any translation according to Proposition 4 (or Proposition 2) involves an exponential blowup in size in the worst case. Indeed, it is shown in [5] that
there is no polynomial translation from propositional theories to logic programs if we
do not introduce new atoms, and that there is one if we allow them.

4 Prenex Normal Form of First-Order Formulas
The translation from an arbitrary propositional theory into a logic program shows that
their syntactic difference is not essential, which allows existing answer set solvers to
compute the stable models of arbitrary propositional formulas. Can the result be extended to first-order formulas, of which the stable model semantics is presented in [8]?
We begin with a review of the stable model semantics presented in [8], which extends the definition of a stable model reviewed in Section 2 to first-order sentences.
Given a first-order sentence F , by SM[F ] we denote the second-order sentence
F ∧ ∀u((u < p) → ¬F ∗ (u)),
where p stands for the tuple of all predicate constants p1 , . . . , pn occurring in F , u is
a tuple of n distinct predicate variables u1 , . . . , un , equation u < p is defined as in
circumscription [11], and F ∗ (u) is defined recursively, as follows:
–
–
–
–
–
–

pi (t1 , . . . , tm )∗ = ui (t1 , . . . , tm );
(t1 = t2 )∗ = (t1 = t2 );
⊥∗ = ⊥;
(F ⊙ G)∗ = F ∗ ⊙ G∗ , where ⊙ ∈ {∧, ∨};
(F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
(QxF )∗ = QxF ∗ , where Q ∈ {∀, ∃}.

A model of F is stable if it satisfies SM[F ]. For the definition of strong equivalence
extended to first-order formulas, we refer the reader to Section 4 of [8].
Proposition 1 can be extended to the case where F and G are first-order formulas [8,
Proposition 5]. Using the proposition, one can prove that every first-order formula is
strongly equivalent to a prenex normal form. The following proposition is essentially
Theorem 6.4 of [14].
Proposition 5 Every first-order formula is strongly equivalent to a prenex normal form.
The proposition follows from the fact that usual prenex normal form conversion
rules for first-order logic (e.g., [15, Lemma 2.29]) preserves strong equivalence. Alternative to the proof in [14], this fact can be proved using [8, Proposition 5]. For instance,
∀xF (x) → G is strongly equivalent to ∃x(F (x) → G), where x is not free in G.
Consider
(∀xF (x) → G)∗ = (∀xF (x) → G) ∧ (∀xF ∗ (x) → G∗ )
⇔ ∃x(F (x) → G) ∧ ∃x(F ∗ (x) → G∗ )

(10)

(∃x(F (x) → G))∗ = ∃x((F (x) → G) ∧ (F ∗ (x) → G∗ )) .

(11)

and

Strong Equivalence Between Propositional Theories and Logic Programs

9

Note that (10) and (11) are not (classically) equivalent in general, but they are equivalent
under the assumption p′ ≤ p, where p is the tuple of all predicate constants occurring
in F (x) and G, and p′ is the tuple of new, pairwise distinct predicate constants of the
same length as p. Therefore, by [8, Proposition 5], we conclude that ∀xF (x) → G is
strongly equivalent to ∃x(F (x) → G).
Also, Proposition 2 can be straightforwardly extended to quantifier-free first-order
formulas as follows. A first-order formula F is in negation normal form if, for every
subformula G → H of F ,
– formula G is an atomic formula, and
– formula H is ⊥.
For any clause C in a CNF of a quantifier-free first order formula, Tr(C) from
Section 2 can be extended in a straightforward way. The equality can be placed either
in the consequent or the antecedent (properly negated).
Corollary 1 Any first-order formula is strongly equivalent to a prenex normal form
whose matrix is a conjunction of implications F → G where F and G are formulas in
negation normal form.
The matrix of a prenex normal form indicated in Corollary 1 is in the form of a
logic program. Thus, similar to the propositional case, the syntactic difference of arbitrarily nested connectives and quantifiers is not essential between the new language
proposed in [8] and logic programs. On the other hand, since the prenex normal form
may contain existential quantifiers, it is different from a logic program, where all variables are assumed to be universally quantified. For instance, according to [8], the stable
models of formula ∃x p(x) represent that p is a singleton, as in circumscription. This
has no counterpart in logic programs, since their stable models are limited to Herbrand
interpretations. For a related discussion, see [16].

5 Implementation
Our implementation, which we call F 2 LP, turns an arbitrary propositional theory into a
logic program and calls DLV to compute its stable models. When the input is already in
the syntax of DLV input language, its operation is just as what DLV does. The system is
available at
http://peace.eas.asu.edu/f2lp .
The ASCII representations of propositional connectives used in the syntax of F 2 LP
are summarized in the following chart:
Symbol
ASCII representation

¬
∧
not &

∨
|

→
->

⊥
false

Example 1 is written in the syntax of F 2 LP as follows:

⊤
true

10

Joohyung Lee and Ravi Palla

(p->q)->r.
F 2 LP

turns this formula into the following DLV input:

r :- not p.
p | r | q_bar :-.
r :- q.
q_bar :- not q.
:- q, q_bar.
Note that this program is slightly different from the logic program shown in Example 1′
(the first three rules of (6)). This is because DLV, like most other answer set solvers,
does not allow negation as failure in the head of a rule. However, it can be simulated
by introducing new atoms (Section 4 of [17]). The method replaces the occurrence of
not p in the head of a rule with a new atom p, and adds rules p ← not p and ← p, p. The
stable models of the program correspond to the stable models of the original program
by disregarding the presence of the new atoms. In the example above, q bar is a new
atom, and the last two rules are added. After F 2 LP calls DLV to compute the stable
models, it removes all occurrences of the new atoms (“ bar”) from the stable models
returned by DLV.
Example 2 is written in our syntax as follows:
p -> ((q->r) | s).
This is turned into the following DLV input by F 2 LP:
r | s
q_bar
q_bar
:- q,

:- p, q.
| s :- p, not r.
:- not q.
q_bar.

6 Conclusion
Our contributions in this note are as follows. First, we presented a new proof of the theorem on strong equivalence between propositional theories and logic programs. Unlike
the other approaches that are based on the logic of here-and-there, our proof relies on
familiar properties of classical logic. Due to this fact, our proof indicates how corresponding logic programs can be generated using equivalent transformations in classical
logic. Second, using the same reduction idea, we showed that arbitrary first-order formulas under the stable model semantics, recently proposed in [8], can be turned into a
prenex normal form whose matrix has the form of a logic program. Third, we presented
a prototype implementation for computing the stable models of arbitrary propositional
formulas based on the reduction method.
For future work, we plan to investigate how the methods of obtaining minimally
equivalent theories in classical logic can be applied to finding minimally equivalent
logic programs. Recently, Cabalar et al. [18] proposed two notions of minimal logic
programs. It would be interesting to see how these approaches are related.

Strong Equivalence Between Propositional Theories and Logic Programs

11

Acknowledgements
We are grateful to Paolo Ferraris, Vladimir Lifschitz and the anonymous referees for
useful comments on this paper. The authors were partially supported by DTO AQUAINT.

A

Appendix: Proof of Proposition 2

Due to lack of space, we present the proof of Proposition 2 only, which follows immediately from Proposition 1 and the following proposition.
Proposition 6 Let F be a formula of signature σ and G a conjunction of canonical
implications that is equivalent to F ∗ . Then
p′ ≤ p → (F ∗ ↔ (R(G))∗ )
is a tautology.
The proof of Proposition 6 uses the following lemmas, most of which can be proven
by induction.
Lemma 1. For any formula F of signature σ, the formula
p′ ≤ p → (F ∗ (p′ ) → F )
is logically valid.
Lemma 2. Every formula F is equivalent to R(F ∗ ).
Lemma 3. For any two formulas F and G of signature σ ∪ σ ′ ,
(F ↔ G) → (R(F ) ↔ R(G))
is a tautology.
Proof. Assume that F ↔ G holds for all interpretations of σ ∪ σ ′ , which includes the
interpretations I such that pI = (p′ )I for all p ∈ p. It is clear that F I = R(F )I and
GI = R(G)I , from which R(F )I = R(G)I follows. Since I range over all interpretations of σ, it follows that R(F ) ↔ R(G).
Lemma 4. For any canonical implication F of signature σ ∪ σ ′ ,
(p′ ≤ p) → ((F ∧ R(F )) ↔ (R(F ))∗ )
is a tautology.
Proof of Proposition 6. Assume p′ ≤ p and F ∗ ↔ G. By Lemma 1, F ∗ → F
holds, so that F ∗ is equivalent to G ∧ F . Since F is equivalent to R(F ∗ ) according to
Lemma 2, G ∧ F is equivalent to G ∧ R(F ∗ ), which, in turn, is equivalent to G ∧ R(G)
according to Lemma 3. By Lemma 4, it follows that G∧R(G) is equivalent to (R(G))∗ .

12

Joohyung Lee and Ravi Palla

References
1. Pearce, D.: A new logical characterization of stable models and answer sets. In Dix, J.,
Pereira, L., Przymusinski, T., eds.: Non-Monotonic Extensions of Logic Programming (Lecture Notes in Artificial Intelligence 1216), Springer-Verlag (1997) 57–70
2. Ferraris, P.: Answer sets for propositional theories. In: Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). (2005) 119–131
3. Cabalar, P., Ferraris, P.: Propositional theories are strongly equivalent to logic programs.
Submitted for publication (2005)
4. Lifschitz, V., Pearce, D., Valverde, A.n.: Strongly equivalent logic programs. ACM Transactions on Computational Logic 2 (2001) 526–541
5. Cabalar, P., Pearce, D., Valverde, A.n.: Reducing propositional theoreis in equilibrium logic
to logic programs. In: Proceedings of 12th Portuguese Conference on Artificial Intelligence
(EPIA 2005). (2005) 4–17
6. Lifschitz, V., Tang, L.R., Turner, H.: Nested expressions in logic programs. Annals of
Mathematics and Artificial Intelligence 25 (1999) 369–389
7. Sarsakov, V., Schaub, T., Tompits, H., Woltran, S.: nlp: A compiler for nested logic programming. In Lifschitz, V., Niemelä, I., eds.: Proceedings of the Seventh International Conference
on Logic Programming and Nonmonotonic Reasoning (LPNMR’04). Volume 2923 of Lecture Notes in Computer Science., Springer-Verlag Heidelberg (2003) 361 – 364
8. Ferraris, P., Lee, J., Lifschitz, V.: A new perspective on stable models. In: Proceedings of
International Joint Conference on Artificial Intelligence (IJCAI). (2007)
9. Pearce, D., Tompits, H., Woltran, S.: Encodings for equilibrium logic and logic programs
with nested expressions. In: Proceedings of Portuguese Conference on Artificial Intelligence
(EPIA). (2001) 306–320
10. McCarthy, J.: Circumscription—a form of non-monotonic reasoning. Artificial Intelligence
13 (1980) 27–39,171–172
11. Lifschitz, V.: Circumscription. In Gabbay, D., Hogger, C., Robinson, J., eds.: The Handbook
of Logic in AI and Logic Programming. Volume 3. Oxford University Press (1994) 298–352
12. Ferraris, P., Lifschitz, V.: Mathematical foundations of answer set programming. In: We
Will Show Them! Essays in Honour of Dov Gabbay. King’s College Publications (2005)
615–664
13. Lin, F.: Reducing strong equivalence of logic programs to entailment in classical propositional logic. In: Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR). (2002) 170–176
14. Pearce, D., n Valverde, A.: A first order nonmonotonic extension of constructive logic. Studia
Logica 80 (2005) 323–348
15. Mendelson, E.: Introduction to Mathematical Logic. Wadsworth & Brooks (1987) Third
edition.
16. Texas Action Group: Technical discussions: Do we need existential quantifiers in logic
programming? (2007)
http://www.cs.utexas.edu/users/vl/tag/discussions.html .
17. Janhunen, T.: On the effect of default negation on the expressiveness of disjunctive rules. In:
Proc. LPNMR 2001. (2001) 93–106
18. Cabalar, P., Pearce, D., Valverde, A.n.: Minimal logic programs. Unpublished draft (2007)

Stable Models of Formulas with Generalized
Quantifiers (Preliminary Report)
Joohyung Lee and Yunsong Meng
School of Computing, Informatics, and Decision Systems Engineering
Arizona State University, Tempe, AZ, USA
joolee@asu.edu, Yunsong.Meng@asu.edu

Abstract
Applications of answer set programming motivated various extensions of the stable model semantics, for instance, to allow aggregates or to facilitate interface with external ontology descriptions.
We present a uniform, reductive view on these extensions by viewing them as special cases of
formulas with generalized quantifiers. This is done by extending the first-order stable model semantics by Ferraris, Lee and Lifschitz to account for generalized quantifiers and then by reducing
the individual extensions to this formalism.
1998 ACM Subject Classification I.2.4 Knowledge Representation Formalisms and Methods
Keywords and phrases answer set programming, stable model semantics, generalized quantifiers
Digital Object Identifier 10.4230/LIPIcs.ICLP.2012.61

1

Introduction

Applications of answer set programming motivated various recent extensions of the stable
model semantics, for instance, to allow aggregates [4, 8, 15], or to facilitate interface with
external ontology descriptions [3]. While the extensions were driven by different motivations
and applications, a common underlying issue is how to extend the stable model semantics
to incorporate “complex atoms,” such as “aggregate atoms” and “dl-atoms.”
Most extensions involve grounding. For instance, assuming that the domain is {1, 2, . . . }
the rule
q(y) ← #count{x.p(x, y)} ≥ 2

(1)

can be understood as a schema for ground instances
q(1) ← #count{1.p(1, 1), 2.p(2, 1), . . . } ≥ 2
q(2) ← #count{1.p(1, 2), 2.p(2, 2), . . . } ≥ 2
...
Here y is called a “global” variable, and x is called a “local” variable. Replacing a global
variable by ground terms increases the number of rules; replacing a local variable by ground
terms increases the size of each rule.
Instead of involving grounding, in [10], a simple approach to understanding the meaning
of the count aggregate in answer set programming was provided by reduction to first-order
formulas under the stable model semantics [6, 7]. For instance, rule (1) can be understood
as the first-order formula
∀y(∃x1 x2 (p(x1 ) ∧ p(x2 ) ∧ ¬(x1 = x2 )) → q(y)) ,
in which quantifiers are introduced to account for local variables in aggregates.
© Joohyung Lee and Yunsong Meng;
licensed under Creative Commons License ND
Technical Communications of the 28th International Conference on Logic Programming (ICLP’12).
Editors: A. Dovier and V. Santos Costa; pp. 61–71
Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

62

Stable Models of Formulas with Generalized Quantifiers (Preliminary Report)

An attempt to extend this approach to handle arbitrary nonmonotone aggregates encounters some difficulty, as the quantifiers ∀ and ∃, like its propositional counterpart ∧ and
∨, are “monotone.”
It is hinted in [5] that aggregates may be viewed in terms of generalized quantifiers—a
generalization of the standard quantifiers, ∀ and ∃, introduced by Mostowski [13]. We follow
up on that suggestion, and extend the stable model semantics by [7] to allow generalized
quantifiers.
It turns out that generalized quantifiers are not only useful in explaining the meaning
of arbitrary aggregates, but also useful in explaining other recent extensions of the stable
model semantics, such as nonmonotonic dl-programs [3]. This allows us to combine the
individual extensions in a single language as in the following example.
I Example 1. We consider an extension of nonmonotonic dl-programs (T , Π) that allows
aggregates. For instance, the ontology description T specifies that every married man has
a spouse who is a woman, and similarly for a married woman:
Man u Married v ∃Spouse.Woman.
Woman u Married v ∃Spouse.Man.
The following program Π counts the number of people who are eligible for an insurance
discount:
discount(x) ← not accident(x),
#dl[Man ] mm, Married ] mm, Woman ] mw, Married ] mw; ∃Spouse.>](x).
discount(x) ← discount(y), family(y, x), not accident(x).
numOfDiscount(z) ← counthx.discount(x)i = z.
The first rule asserts that everybody who has a spouse and has no accident is eligible for
a discount. The second rule asserts that everybody who has no accident and has a family
member with a discount is eligible for a discount.
The paper is organized as follows. We first review the syntax and the semantics of
formulas with generalized quantifiers (GQ-formulas). Next we define stable models of GQformulas, and then show the individual extensions of the stable model semantics, such as
logic programs with aggregates and/or nonmonotonic dl-atoms, can be viewed as special
cases of GQ-formulas.

2
2.1

Preliminaries
Syntax of Formulas with Generalized Quantifiers

We follow the definition of a GQ-formula from [16, Section 5] (that is to say, with Lindström
quantifiers [12] without the isomorphism closure condition).
As in first-order logic, a signature σ is a set of symbols consisting of function constants
and predicate constants. Each symbol is assigned a nonnegative integer, called the arity.
Function constants with arity 0 are called object constants, and predicate constants with
arity 0 are called propositional constants. A term is an object variable or f (t1 , . . . , tn ), where
f is a function constant in σ of arity n, and ti are terms. An atomic formula is an expression
of the form p(t1 , . . . , tn ) or t1 = t2 , where p is a predicate constant in σ of arity n.
We assume a set Q of symbols for generalized quantifiers. Each symbol in Q is associated
with a tuple of nonnegative integers hn1 , . . . , nk i (k ≥ 0, and each ni is ≥ 0), called the type.
A GQ-formula (with the set Q of generalized quantifiers) is defined in a recursive way:

J. Lee and Y. Meng

63

an atomic formula is a GQ-formula;
if F1 , . . . , Fk (k ≥ 0) are GQ-formulas and Q is a generalized quantifier of type hn1 , . . . , nk i
in Q, then
Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk ))

(2)

is a GQ-formula, where each xi (1 ≤ i ≤ k) is a list of distinct object variables whose
length is ni .
We say that an occurrence of a variable x in a GQ-formula F is bound if it belongs
to a subformula of F that has the form Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )) such that x is in
some xi . Otherwise the occurrence is free. We say that x is free in F if F contains a free
occurrence of x. A GQ-sentence is a GQ-formula with no free variables. Notice that the
distinction between free and bound variables is similar to that of global and local variables
informally described in the introduction.
We assume that Q contains a type hi quantifier Q⊥ , a type h0i quantifier Q¬ , type h0, 0i
quantifiers Q∧ , Q∨ , Q→ , and type h1i quantifiers Q∀ , Q∃ . Each of them corresponds to the
standard propositional connectives and quantifiers, ⊥, ¬, ∧, ∨, →, ∀, ∃. These generalized
quantifiers will often be written in the familiar form. For example, we write F ∧ G in place
of Q∧ [][](F, G), and write ∀xF (x) in place of Q∀ [x](F (x)).

2.2

Models of GQ-Formulas

As in first-order logic, an interpretation I of a signature σ consists of a nonempty set U ,
called the universe of I, and a mapping cI for each constant c in σ. For each function
constant f of σ whose arity is n, f I is an element of U if n is 0, and is a function from U n to
U otherwise. For each predicate constant p of σ whose arity is n, pI is an element of {t, f}
if n is 0, and is a function from U n to {t, f} otherwise. For each generalized quantifier Q
of type hn1 , . . . , nk i, QU is a function from P(U n1 ) × · · · × P(U nk ) to {t, f}, where P(U ni )
denotes the power set of U ni .
I Example 2. Besides the standard propositional connectives and quantifiers, the following
are other examples of generalized quantifiers.
1
type h1i quantifier Q≤2 such that QU
≤2 (R) = t iff the cardinality of R is ≤ 2;
U
type h1i quantifier Qmajority such that Qmajority (R) = t iff the cardinality of R is greater
than the cardinality of U \ R;
type h2, 1, 1i reachability quantifier Qreach such that QU
reach (R1 , R2 , R3 ) = t iff there are
some u, v ∈ U such that R2 = {u}, R3 = {v}, and (u, v) belongs to the transitive closure
of R1 .

By σ I we mean the signature obtained from σ by adding new object constants ξ ∗ , called
names, for every element ξ in the universe of I. We identify an interpretation I of σ with its
extension to σ I defined by I(ξ ∗ ) = ξ. For any term t of σ I that does not contain variables,
we define recursively the element tI of the universe that is assigned to t by I. If t is an
object constant then tI is an element of U . For other terms, tI is defined by the equation
f (t1 , . . . , tn )I = f I (tI1 , . . . , tIn )
for all function constants f of arity n > 0.
Given a GQ-sentence F of σ I , F I is defined recursively as follows:
1

It is clear from the type that R is any subset of U . We will skip such explanation.

ICLP’12

64

Stable Models of Formulas with Generalized Quantifiers (Preliminary Report)

p(t1 , . . . , tn )I = pI (tI1 , . . . , tIn ),
(t1 = t2 )I = (tI1 = tI2 ),
For a generalized quantifier Q of type hn1 , . . . , nk i,
(Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )))I = QU ((x1 .F1 (x1 ))I , . . . , (xk .Fk (xk ))I ),
where (xi .Fi (xi ))I = {ξ ∈ U ni | (Fi (ξ ∗ ))I = t}.
We assume that, for the standard propositional connectives and quantifiers Q, functions
QU have the standard meaning:
QU
QU
∀ (R) = t iff R = U ;
∃ (R) = t iff R ∩ U 6= ∅;
U
Q∧ (R1 , R2 ) = t iff R1 = R2 = {};2
QU
∨ (R1 , R2 ) = t iff R1 = {} or R2 = {};
U
Q→ (R1 , R2 ) = t iff R1 = ∅ or R2 = {};
QU
¬ (R) = t iff R = ∅;
QU
⊥ () = f.
We say that an interpretation I satisfies a GQ-sentence F , or is a model of F , and write
I |= F , if F I = t. A GQ-sentence F is logically valid if every interpretation satisfies F . A
GQ-formula with free variables is said to be logically valid if its universal closure is logically
valid.
I Example 3. Let I1 be an interpretation whose universe is {1, 2, 3, 4} and let p be a
unary predicate constant such that p(ξ ∗ )I1 = t iff ξ ∈ {1, 2, 3}. We check that I1 satisfies
GQ-sentence F = ¬Q≤2 [x] p(x) → Qmajority [y] p(y) (“if p does not contain at most two
elements in the universe, then p contains a majority”). Let I2 be another interpretation
with the same universe such that p(ξ ∗ )I2 = t iff ξ ∈ {1}. It is clear that I2 also satisfies F .
We say that a generalized quantifier Q is monotone in the i-th argument position if
the following holds for any universe U : if QU (R1 , . . . , Rk ) = t and Ri ⊆ Ri0 ⊆ U ni , then
QU (R1 , . . . , Ri−1 , Ri0 , Ri+1 , . . . , Rk ) = t. Similarly, we say that Q is anti-monotone in the
i-th argument position if the following holds for any universe U : if QU (R1 , . . . , Rk ) = t
and Ri0 ⊆ Ri ⊆ U ni , then QU (R1 , . . . , Ri−1 , Ri0 , Ri+1 , . . . , Rk ) = t. We call an argument
position of Q monotone (anti-monotone) if Q is monotone (anti-monotone) in that argument
position.
Let M be a subset of {1, . . . , k}. We say that Q is monotone in M if Q is monotone
in the i-th argument position for all i in M . It is easy to check that both Q∧ and Q∨ are
monotone in {1, 2}. Q→ is anti-monotone in {1} and monotone in {2}; Q¬ is anti-monotone
in {1}. In Example 2, Q≤2 is anti-monotone in {1} and Qmajority is monotone in {1}.
Predicate variables can be added to the language in the usual way as we define the
standard second-order logic. Syntactically, n-ary predicate variables are used to form atomic
formulas in the same way as n-ary predicate constants. Semantically, these variables range
over arbitrary truth-valued functions on U n .

3

Stable Models of GQ-Formulas

We now define the stable model operator SM with a list of intensional predicates. Let p
be a list of distinct predicate constants p1 , . . . , pn , and let u be a list of distinct predicate
2

 denotes the empty tuple. For any interpretation I, U 0 = {}. For I to satisfy Q∧ [][](F, G), both
(.F )I and (.G)I have to be {}, which means that F I = GI = t.

J. Lee and Y. Meng

65

variables u1 , . . . , un . By u ≤ p we denote the conjunction of the formulas ∀x(ui (x) → pi (x))
for all i = 1, . . . , n, where x is a list of distinct object variables of the same length as the
arity of pi , and by u < p we denote (u ≤ p) ∧ ¬(p ≤ u). For instance, if p and q are unary
predicate constants then (u, v) < (p, q) is


∀x(u(x) → p(x)) ∧ ∀x(v(x) → q(x)) ∧ ¬ ∀x(p(x) → u(x)) ∧ ∀x(q(x) → v(x)) .
For any GQ-formula F and any list of predicates p = (p1 , . . . , pn ), expression SM[F ; p]
is defined as
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),

(3)

where F ∗ (u) is defined recursively:
pi (t)∗ = ui (t) for any list t of terms;
F ∗ = F for any atomic formula F that does not contain members of p;
(Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )))∗ =
Q[x1 ] . . . [xk ](F1∗ (x1 ), . . . , Fk∗ (xk )) ∧ Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )).

(4)

When F is a GQ-sentence, the models of SM[F ; p] are called the p-stable models of F :
they are the models of F that are “stable” on p. We often simply write SM[F ] in place
of SM[F ; p] when p is the list of all predicate constants occurring in F , and call p-stable
models simply stable models.
I Proposition 1. Let Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )) be a GQ-formula and let M be a
subset of {1, . . . , k} such that every predicate constant from p occurs in some Fj where
j ∈ M.
(a) If Q is monotone in M , then
u ≤ p → ((Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )))∗ ↔ Q[x1 ] . . . [xk ](F1∗ (x1 ), . . . , Fk∗ (xk )))
is logically valid.
(b) If Q is anti-monotone in M , then
u ≤ p → ((Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )))∗ ↔ Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )))
is logically valid.
Proposition 1 allows us to simplify the formula F ∗ (u) in (3) without affecting the models
of (3). In formula (4), if Q is monotone in all argument positions, we can drop the second
conjunctive term in view of Proposition 1 (a). If Q is anti-monotone in all argument positions, we can drop the first conjunctive term in view of Proposition 1 (b). For instance,
recall that each of Q∧ , Q∨ , Q∀ , Q∃ is monotone in all its argument positions, and Q¬ is
anti-monotone in {1}. If F is a standard first-order formula, then (4) can be equivalently
rewritten as
(¬F )∗ = ¬F ;
(F ∧ G)∗ = F ∗ ∧ G∗ ; (F ∨ G)∗ = F ∗ ∨ G∗ ;
(F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
(∀xF )∗ = ∀xF ∗ ; (∃xF )∗ = ∃xF ∗ .

ICLP’12

66

Stable Models of Formulas with Generalized Quantifiers (Preliminary Report)

This is almost the same as the definition of F ∗ given in [7], except for the case (¬F )∗ , which
is a bit more concise.3 The only propositional connective which is neither monotone nor
anti-monotone in all argument positions is Q→ , for which the simplification does not apply.
Example 3 continued. For the GQ-sentence F considered earlier, SM[F ] is
F ∧ ¬∃u(u < p ∧ F ∗ (u)) ,

(5)

where F ∗ (u) is equivalent to the conjunction of F and
¬Q≤2 [x] p(x) → Qmajority [y] u(y).

(6)

I1 considered earlier satisfies (5): it satisfies F , and, for any proper “subset” u of p, it
satisfies the antecedent of (6) but not the consequent. Thus it is a stable model of F . On
the other hand, we can check that I2 does not satisfy (5), and is not a stable model.

4

Aggregates as GQ-Formulas

4.1

Formulas with Aggregates

The following definition of a formula with aggregates is from [5], which extends the one
from [9] to allow nested aggregates. By a number we understand an element of some fixed
set Num. For example, Num is Z ∪ {+∞, −∞}, where Z is the set of integers. A multiset
is usually defined as a set of elements along with a function assigning a positive integer,
called the multiplicity, to each of its elements. An aggregate function is a partial function
from the class of multisets to Num. We assume the presence of some fixed background
signature σbg that contains all numbers. Furthermore, we assume that the interpretation
Ibg of the background signature is fixed, and interpretes each number as itself.
We consider a signature σ as a superset of σbg . An expansion I of Ibg to σ is an
interpretation of σ such that
the universe of I is the same as the universe of Ibg , and
I agrees with Ibg on all the constants in σbg .
First-order formulas with aggregates are defined as an extension of standard first-order
formulas by adding the following clause:

ophx1 .F1 , . . . , xn .Fn i  b

(7)

is a first-order formula with aggregates, where
op is a symbol for an aggregate function (not from σ);
x1 , . . . , xn are nonempty lists of distinct object variables;
F1 , . . . , Fn are arbitrary first-order formulas with aggregates of signature σ;
 is a symbol for a comparison operator (may not necessarily be from σ);
b is a term of σ.
3

¬F is understood as F → ⊥ in [7], but this difference does not affect stable models. When ¬ is a
primitive propositional connective as above,
u ≤ p → ((F → ⊥)∗ (u) ↔ (¬F )∗ (u))
is logically valid.

J. Lee and Y. Meng

4.2

67

Aggregates as GQ-Formulas

Due to the space limit, we refer the reader to [5] for the stable model semantics of formulas
with aggregates. We can explain their semantics by viewing it as a special case of the
stable model semantics presented here. Following [5], for any set X of n-tuples (n ≥ 1),
let msp(X) (“the multiset projection of X”) be the multiset consisting of all ξ1 such that
(ξ1 , . . . , ξn ) ∈ X for at least one (n − 1)-tuple (ξ2 , . . . , ξn ), with the multiplicity equal to
the number of such (n − 1)-tuples (and to +∞ if there are infinitely many of them). For
example, msp({(a, a), (a, b), (b, a)}) = {{a, a, b}}.
We identify expression (7) with the GQ-formula
Q(op,) [x1 ] . . . [xn ][y](F1 (x1 ), . . . , Fn (xn ), y = b) ,

(8)

|x1 |
where, for any interpretation I, QU
) × · · · × P(U |xn | ) ×
(op,) is a function that maps P(U
P(U ) to {t, f} such that QU
(op,) (R1 , . . . , Rn , Rn+1 ) = t iff
op(α) is defined, where α is the join of the multisets msp(R1 ), . . . , msp(Rn ),
Rn+1 = {n}, where n is an element of Num, and
op(α)  n.

I Example 4. {discount(alice), discount(carol), numOfDiscounts(2)} is an Herbrand stable
model of the formula
discount(alice) ∧ discount(carol)
∧ ∀z(counthx.discount(x)i = z → numOfDiscounts(z)).
The following proposition states that this definition is equivalent to the definition from [5].
I Proposition 2. Let F be a first-order sentence with aggregates whose signature is σ, and
let p be a list of predicate constants. For any expansion I of σbg to σ, I is a p-stable model
of F in the sense of [5] iff I is a p-stable model of F in our sense.

5

Nonmonotonic dl-Programs as GQ-Formulas

5.1

Review of Nonmonotonic dl-Programs

Let C be a set of object constants, and let PT and PΠ be disjoint sets of predicate constants.
A nonmonotonic dl-program [3] is a pair (T , Π), where T is a theory in description logic
of signature hC, PT i and Π is a generalized normal logic program of signature hC, PΠ i such
that PT ∩ PΠ = ∅. We assume that Π contains no variables by applying grounding w.r.t. C.
A generalized normal logic program is a set of nondisjunctive rules that can contain queries
to T using “dl-atoms.” A dl-atom is of the form
DL[S1 op1 p1 , . . . , Sk opk pk ; Query](t)

(k ≥ 0),

(9)

− ∩}.
−
where Si ∈ PT , pi ∈ PΠ , and opi ∈ {], ∪,
Query(t) is a dl-query as defined in [3]. A
dl-rule is of the form

a ← b1 , . . . , bm , not bm+1 , . . . , not bn ,

(10)

where a is an atom and each bi is either an atom or a dl-atom. We identify rule (10) with
a ← B, N ,

(11)

where B is b1 , . . . , bm and N is not bm+1 , . . . , not bn . An Herbrand interpretation I satisfies
a ground atom A relative to T if I satisfies A. An Herbrand interpretation I satisfies a
Sk
ground dl-atom (9) relative to T if T ∪ i=1 Ai (I) entails Query(t), where Ai (I) is

ICLP’12

68

Stable Models of Formulas with Generalized Quantifiers (Preliminary Report)

{Si (e) | pi (e) ∈ I} if opi is ],
−
{¬Si (e) | pi (e) ∈ I} if opi is ∪,
−
{¬Si (e) | pi (e) 6∈ I} if opi is ∩.
A ground dl-atom A is monotonic relative to T if, for any two Herbrand interpretations
I and I 0 such that I ⊆ I 0 and I |=T A, we have that I 0 |=T A. Similarly, A is anti-monotonic
relative to T if, for any two Herbrand interpretations I and I 0 such that I 0 ⊆ I and I |=T A,
we have that I 0 |=T A.
Given a dl-program (T , Π) and an Herbrand interpretation I of hC, PΠ i, the weak dltransform of Π relative to T , denoted by wΠIT , is the set of rules
a ← B0

(12)

where a ← B, N is in Π, I |=T B ∧ N , and B 0 is obtained from B by removing all dl-atoms
in it. Similarly, the strong dl-transform of Π relative to T , denoted by sΠIT , is the set of
rules (12), where a ← B, N is in Π, I |=T B ∧ N , and B 0 is obtained from B by removing all
nonmonotonic dl-atoms in it. The only difference between these two transforms is whether
monotonic dl-atoms remain in the positive body or not. Both transforms do not retain
nonmonotonic dl-atoms.
An Herbrand interpretation I is a weak (strong, respectively) answer set of (T , Π) if I
is minimal among the sets of atoms that satisfy wΠIT (sΠIT , respectively).

5.2

Nonmonotonic dl-program as GQ-Formulas

We can view dl-programs as a special case of GQ-formulas. Consider a dl-program (T , Π)
such that Π is ground. Under the strong answer set semantics we identify every dl-atom (9)
in Π with
Q(9) [x1 ] . . . [xk ](p1 (x1 ), . . . , pk (xk ))

(13)

if it is monotonic relative to T , and
¬¬Q(9) [x1 ] . . . [xk ](p1 (x1 ), . . . , pk (xk ))

(14)

otherwise. Since ¬ is an anti-monotone GQ, prepending ¬¬ in front of the quantified formula
in (14) means that, under the strong answer set semantics, every nonmonotonic dl-atom is
understood in terms of an anti-monotone GQ.
|x1 |
) × · · · × P(U |xk | ) to {t, f}
Given an interpretation I, QU
(9) is a function that maps P(U
S
k
such that, QU
i=1 Ai (Ri ) entails Query(t), where Ai (Ri ) is
(9) (R1 , . . . , Rk ) = t iff T ∪
{Si (ξ i ) | ξ i ∈ Ri } if opi is ],
−
{¬Si (ξ i ) | ξ i ∈ Ri } if opi is ∪,
|xi |
−
{¬Si (ξ i ) | ξ i ∈ U
\ Ri } if opi is ∩.
We say that I is a strong answer set of (T , Π) if I satisfies SM[Π; PΠ ].
Similarly, a weak answer set of (T , Π) is defined by identifying every dl-atom (9) in Π
with (14) regardless of A being monotonic or not. This means that, under the weak answer
set semantics, every dl-atom is understood in terms of an anti-monotone GQ.
Example 1 continued.

The dl-atom

#dl[Man ] mm, Married ] mm, Woman ] mw, Married ] mw; ∃Spouse.>](alice)

(15)

J. Lee and Y. Meng

69

is identified with the generalized quantified formula
Q(15) [x1 ][x2 ][x3 ][x4 ](mm(x1 ), mm(x2 ), mw(x3 ), mw(x4 ))

(16)

where, for any interpretation I, QU
(15) is a function that maps P(U )×P(U )×P(U )×P(U ) to
{t, f} such that QU
(R
,
R
,
R
,
R
1
2
3
4 ) = t iff T ∪ {Man(c) | c ∈ R1 } ∪ {Woman(c) | c ∈ R3 }∪
(15)
{Married(c) | c ∈ R2 ∪ R4 } entails ∃xSpouse(alice, x).
Consider an Herbrand interpretation I = {mw(alice)}, which satisfies (15). I also
satisfies (16) since (x.mw(x))I = {alice} and T ∪ {W oman(alice), M arried(alice)} entails
∃xSpouse(alice, x).
The following proposition tells us that the definitions of a strong answer set and a weak
answer set given here are reformulations of the original definitions from [3].
I Proposition 3. For any dl-program (T , Π), an Herbrand interpretation is a strong (weak,
respectively) answer set of (T , Π) in the sense of [3] iff it is a strong (weak, respectively)
answer set of (T , Π) in our sense.

5.3

Another Semantics of Nonmonotonic dl-programs

Shen [14] notes that both strong and weak answer set semantics suffer from circular justifications.
I Example 5. [14] Consider (T , Π), where T = ∅ and Π is the program
− q; c u ¬b](a) ,
p(a) ← #dl[c ] p, b ∩

(17)

in which the dl-atom is neither monotonic nor anti-monotonic. This dl-program has two
strong (weak, respectively) answer sets: ∅ and {p(a)}. According to [14], the second answer
set is circularly justified:
− q; c u ¬b](a) ⇐ p(a) ∧ ¬q(a).
p(a) ⇐ #dl[c ] p, b ∩

{p(a)}

Indeed, sΠT

{p(a)}

(wΠT

, respectively) is p(a) ←, and {p(a)} is its minimal model.

As we hinted in the previous section, this kind of circular justifications is related to the
treatment that understands every nonmonotonic dl-atom in terms of an anti-monotone GQ,
regardless of the nonmonotonic dl-atom’s being anti-monotonic or not. In this case, in view
of Proposition 1, predicates in a nonmonotonic dl-atom are exempt from the minimality
checking. This is different from how we treat nonmonotone aggregates, where we simply
identify them with nonmonotone GQs. This observation suggests the following alternative
semantics of dl-programs, in which we understand only anti-monotonic dl-atoms in terms of
anti-monotone GQs, unlike in the strong and the weak answer set semantics. We say that
an Herbrand interpretation I is an answer set of (T , Π) if I satisfies SM[Π; PΠ ], where we
simply identify every dl-atom (9) in Π with (13).
This definition of an answer set has a reduct-based characterization as well. Just like
we form a strong dl-transform, we first remove the negative body, but instead of removing
all nonmonotonic dl-atoms in the positive body, we remove only anti-monotonic dl-atoms
from the positive body. In other words, the reduct of Π relative to T and an Herbrand
interpretation I of hC, PΠ i, denoted by ΠIT , is the set of rules (12), where a ← B, N is in Π,
I |=T B ∧ N , and B 0 is obtained from B by removing all anti-monotonic dl-atoms in it. The
following proposition shows that this modified definition of a reduct can capture the new
answer set semantics of dl-programs.

ICLP’12

70

Stable Models of Formulas with Generalized Quantifiers (Preliminary Report)

I Proposition 4. For any dl-program (T , Π) and any Herbrand interpretation I of hC, PΠ i,
I is an answer set of (T , Π) according to the new definition iff I is minimal among the sets
of atoms that satisfy ΠIT .
The new semantics does not have the circular justification problem described in Example 5.
Example 5 continued.
{p(a)} is not an answer set of (T , Π) according to the new
{p(a)}
definition. The reduct ΠT
is (17) itself retaining the dl-atom unlike under the strong
and the weak answer set semantics. We check that ∅, a proper subset of {p(a)}, satisfies it,
which means that {p(a)} is not an answer set.

6

Related Work

We refer the reader to [2] for the semantics of HEX programs. It is not difficult to see that
an external atom in a HEX program can be represented in terms of a generalized quantifier.
Eiter et al. show how dl-atoms can be simulated by external atoms #dl[](x). The treatment
is similar to ours in terms of generalized quantifiers. For another example, rule
reached(x) ← #reach[edge, a](x)
defines all the vertices that are reachable from the vertex a in the graph with edge. The
external atom #reach[edge, a](x) can be represented by a generalized quantified formula
Qreach [x1 x2 ][x3 ][x4 ](edge(x1 , x2 ), x3 = a, x4 = x),
where Qreach is as defined in Example 2.
In fact, incorporation of generalized quantifiers in logic programming was considered
earlier in [1], but the treatment there was not satisfactory because they understood generalized quantifiers simply as anti-monotone GQs in our sense. Without going into detail, this
amounts to modifying our definition of F ∗ as
(Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )))∗ = Q[x1 ] . . . [xk ](F1 (x1 ), . . . , Fk (xk )) .
This approach does not allow recursion through generalized quantified formulas, and
often yields an unintuitive result. According to [1], program p(a) ← ∀x p(x) has two answer
sets, ∅ and {p(a)}. The latter is “unfounded.” This is not the case with the semantics
that we introduced in this note. According to our semantics, which properly extends the
semantics from [7], {p(a)} is not an answer set.

7

Conclusion

We presented the stable model semantics for formulas containing generalized quantifiers, and
showed that some recent extensions of the stable model semantics with “complex atoms”
can be viewed as special cases of this formalism. We expect that the generality of the
formalism will be useful in providing a principled way to study and compare the different
extensions of the stable model semantics. As we observed, distinguishing among monotone,
anti-monotone, and neither monotone nor anti-monotone GQs is essential in defining the
semantics of such extensions, whereas the last group of GQs was not considered in the
traditional stable model semantics.
Acknowledgements. We are grateful to Michael Bartholomew, Vladimir Lifschitz, and the
anonymous referees for their useful comments. This work was partially supported by the
National Science Foundation under Grant IIS-0916116.

J. Lee and Y. Meng

71

References
1

2

3

4
5

6

7
8

9

10

11
12
13
14
15

16

Thomas Eiter, Georg Gottlob, and Helmut Veith. Modular logic programming and generalized quantifiers. In Proceedings of International Conference on Logic Programming and
Nonmonotonic Reasoning (LPNMR), pages 290–309, 1997.
Thomas Eiter, Giovambattista Ianni, Roman Schindlauer, and Hans Tompits. A uniform
integration of higher-order reasoning and external evaluations in answer-set programming.
In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pages
90–96, 2005.
Thomas Eiter, Giovambattista Ianni, Thomas Lukasiewicz, Roman Schindlauer, and Hans
Tompits. Combining answer set programming with description logics for the semantic web.
Artificial Intelligence, 172(12-13):1495–1539, 2008.
Wolfgang Faber, Gerald Pfeifer, and Nicola Leone. Semantics and complexity of recursive
aggregates in answer set programming. Artificial Intelligence, 175(1):278–298, 2011.
Paolo Ferraris and Vladimir Lifschitz. On the stable model semantics of firsr-order formulas
with aggregates. In Proceedings of International Workshop on Nonmonotonic Reasoning
(NMR), 2010.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. A new perspective on stable models.
In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pages
372–379, 2007.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. Stable models and circumscription.
Artificial Intelligence, 175:236–263, 2011.
Paolo Ferraris. Answer sets for propositional theories. In Proceedings of International
Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 119–
131, 2005.
Joohyung Lee and Yunsong Meng. On reductive semantics of aggregates in answer set
programming. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 182–195, 2009.
Joohyung Lee, Vladimir Lifschitz, and Ravi Palla. A reductive semantics for counting and
choice in answer set programming. In Proceedings of the AAAI Conference on Artificial
Intelligence (AAAI), pages 472–479, 2008.
Fangzhen Lin and Yi Zhou. From answer set logic programming to circumscription via
logic of GK. Artificial Intelligence, 175:264–277, 2011.
Per Lindström. First-order predicate logic with generalized quantifiers. Theoria, 32:186–
195, 1966.
A. Mostowski. On a Generalization of Quantifiers. Fundamenta Mathematicae, 44:12–35,
1957.
Yi-Dong Shen. Well-supported semantics for description logic programs. In Proceedings of
International Joint Conference on Artificial Intelligence, pages 1081–1086, 2011.
Tran Cao Son and Enrico Pontelli. A constructive semantic characterization of aggregates
in answer set programming. Theory and Practice of Logic Programming, 7(3):355–375,
2007.
Dag Westerståhl. Generalized quantifiers. In The Stanford Encyclopedia of Philosophy (Winter 2008 Edition). 2008. http://plato.stanford.edu/archives/win2008/
entries/generalized-quantifiers/.

ICLP’12

3524

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 62, NO. 6, JUNE 2015

Distributed Energy Trading in Microgrids: A
Game-Theoretic Model and
Its Equilibrium Analysis
Joohyung Lee, Member, IEEE, Jun Guo, Member, IEEE, Jun Kyun Choi, Senior Member, IEEE,
and Moshe Zukerman, Fellow, IEEE

Abstract—This paper proposes a distributed mechanism
for energy trading among microgrids in a competitive market. We consider multiple interconnected microgrids in a
region where, at a given time, some microgrids have superﬂuous energy for sale or to keep in storage facilities,
whereas some other microgrids wish to buy additional
energy to meet local demands and/or storage requirements.
Under our approach, sellers lead the competition by independently deciding the amount of energy for sale subject
to a tradeoff between the attained satisfaction from the
received revenue and that from the stored energy. Buyers
follow the sellers’ actions by independently submitting a
unit price bid to the sellers. Correspondingly, the energy is
allocated to the buyers in proportion to their bids, whereas
the revenue is allocated to the sellers in proportion to their
sales. We study the economic beneﬁts of such an energy
trading mechanism by analyzing its hierarchical decisionmaking scheme as a multileader–multifollower Stackelberg
game. We show that distributing the energy based on a
well-deﬁned utility function converges to a unique equilibrium solution for maximizing the payoff of all participating
microgrids. This game-theoretic study provides an incentive for energy trading among microgrids in future power
grids.
Index Terms—Energy trading, equilibrium analysis, microgrids, Stackelberg game.

Manuscript received November 13, 2013; revised July 9, 2014 and
October 29, 2014; accepted November 27, 2014. Date of publication
January 1, 2015; date of current version May 8, 2015. This work was
supported in part by a grant from the City University of Hong Kong
under Project 9380044, in part by a grant from the Research Grants
Council of the Hong Kong Special Administrative Region of China
under Grant CityU 123012, and in part by a grant from the Energy,
Environment, Water, and Sustainability (EEWS) Research Center of
the Korea Advanced Institute of Science and Technology through
the Climate Change Research Hub Project under Grant EEWS-2014N01140044.
J. Lee was with the Department of Electronic Engineering,
Korea Advanced Institute of Science and Technology, Daejeon 305-701,
Korea. He is now with the Digital Media and Communications Research
and Development Center, Samsung Electronics Company Ltd., Suwon
443-742, Korea (e-mail: joohyung08@kaist.ac.kr).
J. Guo and M. Zukerman are with the Department of Electronic
Engineering, College of Science and Engineering, City University of
Hong Kong, Kowloon, Hong Kong (e-mail: j.guo@cityu.edu.hk; m.zu@
cityu.edu.hk).
J. K. Choi is with the Department of Electrical Engineering, Korea
Advanced Institute of Science and Technology, Daejeon 305-701, Korea
(e-mail: jkchoi59@kaist.edu).
Digital Object Identifier 10.1109/TIE.2014.2387340

I. I NTRODUCTION

N

EXT-GENERATION power grids are envisioned to be a
smart-grid architecture driven by a growing demand for
higher energy efficiency, reduced greenhouse gas emissions,
and improved power quality and reliability [1]–[4]. This evolution is enabled by innovations and continuing developments
in distributed generation and energy storage [5]–[7], advanced
power electronics [8], [9], and modern communication technologies [10], [11]. To manage and operate such a critical and
complex infrastructure efficiently and reliably, an important
building block, which is known as a microgrid [12]–[14], has
emerged as a promising platform for a smart grid to integrate
and coordinate a potentially huge number of distributed energy
resources (DERs) in a decentralized way [15]–[19].
Microgrids are small-scale power systems that can distribute
energy in small geographic areas more flexibly and reliably.
They typically utilize DERs, including distributed generation
units [20] and energy storage facilities [21], for meeting local
demands. Thus, they can reduce reliance on the conventional
centralized power grid (also called a macrogrid or a main
grid in the literature of power systems) that typically uses
large central station generation. In addition to environmental
benefits in terms of utilizing locally available renewable energy
sources such as photovoltaic panels, fuel cells, or wind turbines,
microgrids can reduce the transmission and distribution loss
because of the physical proximity of DERs and loads.
Various forms of demand and supply problems have been
studied in literature, aiming for the optimal operation of a microgrid taking into account load demand forecasting, prediction
for power generation, and/or energy storage capacities [22]–
[28]. One important feature of renewable energy sources such
as wind and solar power is that their supply is, by nature, intermittent and highly variable. Distributed generation using such
unpredictable energy sources is, in general, hard to control.
With the ongoing large-scale deployment of renewable energy
sources, it is challenging to balance between the energy demand
and supply while fully utilizing the capacity of renewable
energy sources.
This concern has recently motivated studies of market-based
energy trading mechanisms among microgrids that enable a
more effective utilization of DERs across a distribution network
[29]–[33]. Consider a situation where, at a given time, several
microgrids have superfluous energy that they wish to sell to the
market, whereas some other microgrids do not have sufficient

0278-0046 © 2015 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

LEE et al.: DISTRIBUTED ENERGY TRADING IN MICROGRIDS

energy to support their local loads and need to buy the shortfall
from the market. One way to deal with this situation is for
microgrids to exclusively trade with a macrogrid. Specifically,
microgrids as sellers feed the excess into the macrogrid, and
those as buyers purchase the shortfall from the macrogrid. Another way is to encourage energy trading among interconnected
microgrids within a vicinity. The latter option is more cost
effective because it is more reliable and can reduce the energy
loss incurred in long-distance transmission. It may also yield
savings for microgrids by avoiding the selling/buying spread of
the macrogrid [34].
Several game-theoretic approaches were proposed in [30]–
[33] for energy trading among microgrids. Saad et al. [30]
applied the coalitional game theory and developed a cooperative strategy for trading energy among microgrids with the aim
of minimizing the average power loss over distribution lines.
The cooperative strategy proposed by Matamoros et al. [31]
aims to minimize the total cost resulting from energy generation and transportation subject to each microgrid satisfying
its local demands. The leader–follower strategy presented by
Asimakopoulou et al. [32] considers the competitive situations
of hierarchical decision-making between an energy service
provider representing several cooperative microgrids and a
large central production unit. The work of Nunna and Doolla
[33] is the closest to this paper where the focus is to study
noncooperative strategies for trading energy among microgrids
in a competitive market. Their approach is to formulate a
matching game using an auction algorithm. As discussed in
[33], such an auction-based trading mechanism only works for
the case where there is an equal number of buyers and sellers in
a market. In addition, it is a centralized approach that requires
a centralized auctioneer.
In this paper, we propose a fully distributed energy trading
mechanism. Under our approach, sellers lead the competition
by independently deciding the amount of energy for sale subject
to a tradeoff between the attained satisfaction from the received
revenue and that from the stored energy. Buyers follow the
sellers’ actions by independently submitting a unit price bid
to the sellers. Proportional sharing applies to both sides of the
competition, where the energy is allocated to the buyers in
proportion to their bids and where the revenue is allocated to the
sellers in proportion to their sales. For the purpose of studying
the economic benefits of such a distributed energy trading
mechanism with a hierarchical decision-making structure, we
analyze it using the framework of Stackelberg games [35].
Through rigorous game-theoretic analysis, we prove that the
proposed approach converges to a unique equilibrium solution,
and we show that distributing the energy based on a welldefined utility function can maximize the payoff for all participating microgrids at the equilibrium of the game. This provides
an incentive for energy trading among microgrids in future
power grids.
The rest of this paper is organized as follows. In Section II,
we describe the model, and we provide the details of the
proposed energy trading mechanism and the design of utility
functions for microgrids. In Section III, we formulate the problem as a Stackelberg game, and we provide a rigorous analysis
of the existence and uniqueness of the equilibrium solution for

3525

TABLE I
S UMMARY OF M AJOR S YMBOLS

Fig. 1. Distributed energy trading among multiple interconnected
microgrids.

such a game. Numerical results are presented in Section IV.
Finally, we conclude this paper in Section V.
II. M ODEL
For the reader’s convenience, we provide in Table I a list of
major symbols that we shall define and use in this paper.
We consider multiple microgrids that are deployed in a
region. Each microgrid consists of DERs that are capable of
generating and storing energy and loads that have demands for
power. As illustrated in Fig. 1, the microgrids are connected
to each other and can exchange energy with each other using a possible architecture such as the architecture discussed
in [3] that interconnects microgrids through dedicated power
exchange highways. The microgrids are also connected to the
macrogrid and thus can exchange energy with the macrogrid.
Let the time be divided into consecutive fixed-length intervals. In each time interval, some microgrids have superfluous
energy that they wish to sell to the market, whereas some other
microgrids do not have sufficient energy to support their local
demands and need to buy the shortfall from the market. To
model this, we define I as the set of buyers and J as the set of
sellers, where I and J are two disjoint sets. Let k = |I| denote
the total number of buyers.
In a market with fluctuating energy prices [36], one can
expect that microgrids have motivations and benefits to store
energy. In such a context, those microgrids as sellers may

3526

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 62, NO. 6, JUNE 2015

choose to keep part of the superfluous energy. Likewise, those
microgrids as buyers may wish to buy and store extra energy
if available because they can use or resell it at a later time.
In our model, we only consider storage costs in terms of
investment costs for energy storage systems, and we treat the
investment costs as sunk costs. Studies of financial incentives
for investments in energy storage systems can be found in, e.g.,
[37] and [38].
j as the amount of superfluous
For each j ∈ J , we define E
j
energy generated by seller j. Let wj be the proportion of E
that seller j decides to sell to the market. The set of available
strategies for seller j, which is denoted as Wj , is a continuum
given by Wj = [0, 1]. Thus, the amount of energy available for
j wj , and the amount of energy that is kept
sale from seller j is E
j (1 − wj ). Let w = (wj )j∈J be
in seller j’s storage facility is E
a profile of strategies for the sellers. Let w−j denote the profile
of strategies for the sellers except j, i.e., w−j = (wl )l∈J \{j} .
By definition, we have w = (wj , w−j ).
For each i ∈ I, we define ci as the unit price bid submitted
by buyer i. Let cS > 0 and cB > 0 be the selling price and
the buying price, respectively, set by the macrogrid. The set
of available strategies for buyer i, which is denoted as Ci ,
is a continuum given by Ci = [cB , cS ]. Note that we expect
ci ≥ cB to hold for all i ∈ I in this context because otherwise
the sellers would achieve a higher revenue if they directly trade
the energy with the macrogrid. On the other hand, we require
ci ≤ cS to hold for all i ∈ I since otherwise the buyers would
pay less by directly obtaining the same amount of energy from
the macrogrid. Let c = (ci )i∈I be a profile of strategies for
the buyers. Let c−i denote the profile of strategies for the
buyers except i, i.e., c−i = (cl )l∈I\{i} . By definition, we have
c = (ci , c−i ).
Following the principle of proportional sharing, for each j ∈
j wj from seller j is allocated to the
J , the amount of energy E
buyers in proportion to their bids. For convenience, let
=
E



j wj .
E

j∈J


j∈J

j wj  ci
E

l∈I cl

i∈I

Thus, the total revenue Rj received by seller j from the
buyers is
Rj =



Ei c i

i∈I

j wj
j wj
E
E
=R
.


E
E

(3)

A. Utility Function of Seller
Our design of the utility function for seller j, j ∈ J , considers two terms. The first term represents the satisfaction attained
j (1 − wj ). The second term
by seller j from the stored energy E
represents the satisfaction attained by seller j from the received
revenue Rj . The utility function designed in this way aims for
a balance between the attained satisfaction from storing the
energy and that from selling the energy since the two terms are
conflicting with each other.
In this context, one can expect that the satisfaction attained
from storing the energy obeys the law of diminishing returns
[39]. Correspondingly, a concave, strictly increasing, and continuously differentiable function may represent this term. In
this paper, we will use a logarithmic utility function for this
purpose because it is widely used in literature for quantifying
user satisfaction with diminishing returns (see, e.g., [40] and
[41] and the references therein).
Thus, for each j ∈ J , the utility function of seller j is
defined as


j (1 − wj ) + γj Rj
j (wj , w−j , c) = ln 1 + E
(4)
U
where γj ≥ 0 is the weighting factor of the second term. For
a given profile of strategies w and c, the social welfare of the
sellers is defined as

j (wj , w−j , c).
 (w, c) =
U
U
j∈J

Thus, the total amount of energy Ei allocated to buyer i by the
sellers is
Ei =

the sellers in proportion to their sales. For convenience, let

Ei c i .
(2)
R=


=E

ci
l∈I cl

.

(1)

Note that, in our model, if Ei is not sufficient for buyer i to
support its local demands in the current time interval, buyer i
would make up the shortfall with energy from the macrogrid.
On the other hand, if Ei is larger than the local demands, we
assume that buyer i has sufficient capacity to store the excess.
Since the amount of superfluous energy generated by the sellers
during each trading interval in our model depends on the length
of the trading interval, this latter assumption is reasonable if the
length of the trading interval is set to be sufficiently small.
Following the principle of proportional sharing, for each i ∈
I, a payment in the amount of Ei ci from buyer i is allocated to

B. Utility Function of Buyer
For each i ∈ I, we consider the following utility function:
Ui (ci , c−i , w) = Ei cS − Ei ci

(5)

to quantify the satisfaction of buyer i attained from the energy
trading in the current time interval. For a given profile of
strategies c and w, the social welfare of the buyers is defined as

Ui (ci , c−i , w).
(6)
U (c, w) =
i∈I

Note in the right-hand side of (5) that the first term Ei cS
represents the amount of money that buyer i needs to pay if it
directly obtains the amount of energy Ei from the macrogrid.
The second term Ei ci is the amount of money that buyer i is
willing to pay for buying Ei from the sellers. Thus, the utility

LEE et al.: DISTRIBUTED ENERGY TRADING IN MICROGRIDS

function defined in (5) quantifies the satisfaction of each buyer
in terms of the amount of money it would save in the current
time interval by obtaining Ei from the sellers with a cheaper
unit price than cS .
III. G AME -T HEORETIC A NALYSIS
Distributed energy trading among microgrids in each particular time interval using our proposed mechanism is a hierarchical
noncooperative decision problem that can be analyzed as a twolevel continuous-kernel Stackelberg game [35].
A. Preliminaries
Stackelberg games are a special class of noncooperative
games in which there exists a hierarchy among players. In a
two-level game, players are classified as leaders and followers.
In the original work of H. von Stackelberg, the Stackelberg
model applies to monopolistic conditions where a number
of small firms follow the behavior of a large dominant
firm, which is the case with one single leader and multiple followers. For examples of the applications of singleleader–multifollower Stackelberg solutions to hierarchical
decision problems in a smart grid, see [42]–[44]. Note that, in
the literature of game theory, the Stackelberg model has been
also extended to the case with multiple leaders and multiple
followers [45]. The work in [46] is an example of applying a
multileader–multifollower Stackelberg solution to the demand
response management in a smart grid.
In general, each player in a Stackelberg game is rational
and selfish, and each aims to maximize its utility. In addition,
the leaders are in a position to enforce their strategies on the
followers. Therefore, in this leader–follower competition, the
leaders choose their strategies before the followers decide their
strategies so that the followers can observe the strategies of the
leaders and adapt their own strategies accordingly. In particular,
since each follower has the information of the strategy adopted
by each leader, it will choose its best strategy, which is also
known as the best response, given the strategies of the leaders.
On the other hand, the leaders are aware of the fact that each
follower will choose its best response to the leaders’ strategies.
Therefore, the leaders are able to maximize their utilities based
on the best responses of the followers. The solution of the game
is known as the Stackelberg equilibrium.
In our problem, we consider the sellers taking the role of
the leaders and the buyers taking the role of the followers.
In the buyer-level game, each buyer independently chooses its
own strategy. In particular, buyer i submits its unit price bid
ci to the sellers. Knowing the strategies of each seller, i.e., the
value of wj for all j ∈ J , it aims to maximize utility function
Ui (ci , c−i , w) defined in (5). Since the buyers do not know
the strategies of each other, a Nash equilibrium gives the set
of strategies with the property that none of the buyers can
increase its own utility by choosing a different strategy given
the strategies of the other buyers and those of the sellers.
On the other hand, in the seller-level game of our problem,
each seller also independently chooses its own strategy. In
particular, seller j decides the value of wj , aiming to maximize

3527

its utility. We will show in Section III-D that, based on utility
j (wj , w−j , c) defined in (4), we can obtain an alterfunction U
j (wj , w−j , c) that depends on the strategy of
native form of U
seller j and those of the buyers only. In this way, the sellerlevel game reduces to a game where the utility of seller j can
be maximized by simply finding the optimal strategy of seller
j that maximizes its utility for a given profile of strategies for
the buyers. As a result, to solve for the Stackelberg equilibrium
in our problem, we can use the backward induction technique
[47]. According to the backward induction principle, we first
find the best response of each buyer from the buyer-level game,
and then, we plug it into the utility function of each seller and
optimize it correspondingly.
B. Noncooperative Game Among Buyers
Deﬁnition 1: The best response function Bi (c−i , w) of
buyer i as a follower is the best strategy for buyer i given the
other buyers’ strategies c−i and the sellers’ strategies w. By
definition, we have
Bi (c−i , w) = arg max Ui (ci , c−i , w)
ci

∀i ∈ I.

(7)

Deﬁnition 2: A Nash equilibrium of the noncooperative
game among the buyers is a profile of strategies c∗ = (c∗i )i∈I
with the property that, given the sellers’ strategies w, we have


∀i ∈ I
(8)
c∗i = Bi c∗−i , w
where c∗−i = (c∗l )l∈I\{i} .
Lemma 1: The utility function Ui (ci , c−i , w) of buyer i is
strictly concave on Ci .
Proof: Given (1) and (5), we have
S ci − ci
 c
Ui (ci , c−i , w) = E
.
l∈I cl
2

Taking the first and second derivatives of Ui (ci , c−i , w) with
respect to ci , we have
∂Ui (ci , c−i , w)
∂ci


cS l∈I\{i} cl − 2ci l∈I cl + c2i

=E

2
l∈I cl

(9)

∂ 2 Ui (ci , c−i , w)
∂c2i

= −2E

cS



l∈I\{i} cl +

l∈I

	
cl


2
l∈I\{i} cl

3

.

(10)

The right-hand side of (10) is negative. Therefore, the utility
function Ui (ci , c−i , w) of buyer i is strictly concave on Ci . 
Proposition 1: There exists a Nash equilibrium in the noncooperative game among the buyers.
Proof: By definition, for all i ∈ I, the set Ci of the
payment strategies for buyer i is a closed, bounded, and

3528

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 62, NO. 6, JUNE 2015

convex subset of a finite-dimensional Euclidean space. The
utility function Ui (ci , c−i , w) of buyer i is continuous and, by
Lemma 1, is strictly concave on Ci . Thus, by [35, Th. 1, p. 173]
for a maximization problem in our context, the noncooperative
game among the buyers has a Nash equilibrium.

Now, we will prove that the buyer-level game has indeed
a unique Nash equilibrium. The key aspect of the uniqueness
proof is to show that the best response function of each buyer
defined in (7) is a standard function [48].
Deﬁnition 3: A function f (p) = (f1 (p), . . . , fN (p)),
where p = (p1 , . . . , pN ), is said to be standard if the following
properties are satisfied for all p ≥ 0.
• Positivity: f (p) > 0.
• Monotonicity: For all p and p , if p ≥ p , then f (p) ≥
f (p ).
• Scalability: For all μ > 1, μf (p) > f (μp).
Proposition 2: The best response function Bi (c−i , w) of
buyer i is a standard function of c−i .
Proof: Since the utility function Ui (ci , c−i , w) of buyer i
is strictly concave on Ci , based on Definition 1 and by (7), the
best response function Bi (c−i , w) of buyer i can be obtained
by setting the right-hand side of (9) to zero for maximization.
Solving
cS




− 2ci l∈I cl + c2i
=0

2
l∈I cl

l∈I\{i} cl

we obtain

⎛
⎞

 



cl ⎝cS +
cl ⎠ −
cl .
Bi (c−i , w) = 
l∈I\{i}

l∈I\{i}

Next, we show that Bi (c−i , w) as a function of c−i in the
form of (11) satisfies the three properties of a standard function
described in Definition 3 as follows.
• Positivity: Given cS > 0, we have
 

cl ·

l∈I\{i}





cl −

l∈I\{i}

cl = 0.

l∈I\{i}

• Monotonicity: Taking the first derivative of Bi (c−i , w)
with respect to cl , l ∈ I \ {i}, we have
∂Bi (c−i , w)
=

∂cj

>

= 0.






l∈I\{i} cl

	

l∈I\{i} cl

+ 12 cS

cS +

μBi (c−i , w)

⎛
⎞

 



c l ⎝c S +
cl ⎠ − μ
cl
= μ
l∈I\{i}

l∈I\{i}




 −1

l∈I\{i} cl

	



l∈I\{i} cl cS +
l∈I\{i} cl

	

 −1

c
c
+
c
S
l∈I\{i} l
l∈I\{i} l

l∈I\{i}


⎛
⎞

 



=
c l ⎝μ 2 c S + μ 2
cl ⎠ − μ
cl
l∈I\{i}

l∈I\{i}

l∈I\{i}

Bi (μc−i , w)

⎛
⎞

 



=
μcl ⎝cS +
μcl ⎠ −
μcl
l∈I\{i}

l∈I\{i}

l∈I\{i}


⎛
⎞

 



=
cl ⎝μcS + μ2
cl ⎠ − μ
cl .
l∈I\{i}

l∈I\{i}

l∈I\{i}

Thus, for all μ > 1, μBi (c−i , w) > Bi (μc−i , w).


Proposition 3: The noncooperative game among the buyers
has a unique Nash equilibrium.
Proof: By Proposition 1, we know that there exists a
Nash equilibrium in the noncooperative game among the buyers. Since Bi (c∗−i , w) = Bi (c∗ , w) for all i ∈ I and letting
B(c∗ , w) = (Bi (c∗ , w))i∈I , by Definition 2, the Nash equilibrium must be a fixed point c∗ that satisfies c∗ = B(c∗ , w). By
Proposition 2, we know that B(c∗ , w) is a standard function.

Therefore, by [48, Th. 1], fixed point c∗ must be unique.
Proposition 4: For the noncooperative game among the
buyers, the unique Nash equilibrium has a closed-form expression given by

l∈I\{i}

(11)

Bi (c−i , w) >

• Scalability: Based on (11), we obtain

c∗i = cS

k−1
2k − 1

∀i ∈ I.

(12)

Proof: We observe from (11) that the best response function Bi (ω, c−i ) of buyer i is of the same form for all i ∈ I.
This symmetry implies a Nash equilibrium where c∗i = c∗j for
all j ∈ I \ {i}. Based on Definition 2 and by (8) and (11),
we have

c∗i = (k − 1)c∗i [cS +(k − 1)c∗i ] − (k − 1)c∗i ∀i ∈ I. (13)
Solving (13) yields (12). We know from Proposition 3 that
the noncooperative game among the buyers has a unique Nash
equilibrium. Thus, the Nash equilibrium derived in (12) is the
unique Nash equilibrium of this game.

Clearly, since k − 1 < 2k − 1 for all k ≥ 1, c∗i in the form
of (12) is guaranteed to satisfy c∗i ≤ cS . On the other hand, for
c∗i ≥ cB to hold, it requires
cS

k−1
≥ cB .
2k − 1

(14)

We observe in (14) that the value of (k − 1)/(2k − 1) monotonically increases as k increases. Therefore, in the worst case
where k = 2, we need to ensure cS ≥ 3cB . On the other hand,
as k tends to infinity, we only require cS ≥ 2cB .

LEE et al.: DISTRIBUTED ENERGY TRADING IN MICROGRIDS

3529

Corollary 1: At the Nash equilibrium given by (12), the
 available for sale from the sellers is equally
amount of energy E
distributed among the buyers, and we have
Ei∗ =


E
k

1 ≤ η < 2.

∀i ∈ I.

As a result of Proposition 4 and Corollary 1, for a given
profile of strategies w for the sellers, the Nash equilibrium
solution to the utility of buyer i, i ∈ I, is obtained as
 S


Ec
Ui c∗i , c∗−i , ω = Ei∗ cS − Ei∗ c∗i =
.
2k − 1
The social welfare of the buyers at Nash equilibrium c∗ is
obtained as
U (c∗ , w) =





 S
Ui c∗i , c∗−i , w = Ec

i∈I

k
.
2k − 1

(15)

C. Efﬁciency of Nash Equilibrium
It is well known that the efficiency of a noncooperative game
degrades due to the selfish behavior of its players [49]. The
price of anarchy [49] is a widely used notion for measuring the
inefficiency of equilibrium in noncooperative games. In its general form, the price of anarchy is defined as the ratio between
the optimal centralized solution and the worst equilibrium for
a game where there exist multiple equilibrium solutions. A
related notion is that of the price of stability [49], which
measures the ratio between the optimal centralized solution and
the best equilibrium. Since our problem has a unique Nash
equilibrium, the two concepts are equivalent in our context.
In the case where the buyers cooperate with each other
aiming to maximize their social welfare U (c, w) defined in (6),
we obtain from (1), (2), (5), and (6) that


 S − R.
Ei −
Ei ci = Ec
U (c, w) = cS
i∈I

 B.
R ≥ Ec

(16)

 S − cB ).
U (c, w) ≤ E(c

(17)

which can be achieved by letting ci = cB for all i ∈ I.
Let η denote the price of anarchy, which is defined as
maxc U (c, w)
.
U (c∗ , w)

Thus, using (15) and (17), we have



2k − 1
cB
(cS − cB )(2k − 1)
= 1−
η=
.
cS k
cS
k

This is the point where the distributed trading is equivalent to
the centralized solution.
D. Utility Maximization for Sellers
We recall that, for each j ∈ J , the utility function of seller
j defined in (4) involves a tradeoff between the attained satisj (1 − wj ) and that from the
faction from the stored energy E
received revenue Rj .
From (1)–(3), we have

2

j wj
E
j wj i∈I ci .
=E
Ei c i
Rj =

E
i∈I ci
For convenience, we define
cN


c2
= i∈I i
i∈I ci

j wj cN .
Rj = E

Thus, for a given profile of strategies w for the sellers, we have
c

Proof: Because of (14) and by definition cB > 0, we have
cB
k−1
≥
>0
2k − 1
cS
k
cB
⇒
≤1−
<1
2k − 1
cS
2k − 1
⇒ 1≤η<
.
k
For all k > 1, we have
1
2k − 1
= 2 − < 2.
k
k
Therefore, we obtain (19).

Proposition 5 suggests that, when (14) is satisfied, the maximal social welfare of the buyers in such a cooperative game
is always larger than or equal to but at most twice of the Nash
equilibrium solution to the social welfare of the buyers in the
noncooperative game. The equivalence, i.e., η = 1, holds when
cB
k−1
.
=
cS
2k − 1

(20)

as the normalized unit price offered by the buyers. Then, we
obtain

Then, using (16), we have

 S − cB )
max U (c, w) = E(c

(19)

i∈I

i∈I

Given that ci ≥ cB for all i ∈ I, we further obtain from (2) that

η=

Proposition 5: For all k > 1 and for an arbitrary value of
cB /cS that satisfies (14), the price of anarchy defined in (18) is
bounded as

(18)

(21)

We observe in (21) that Rj in this alternative form is completely
j wj that seller j sells
determined by the amount of energy E
to the market and the normalized unit price cN offered by the
j (wj , w−j , c) defined
buyers. Consequently, utility function U
in (4) depends on wj and c only. In the remaining analysis of
j (wj , c)
the two-level game, we will drop w−j and simply use U
to denote the utility function of seller j, which is given by


j wj cN .
j (wj , c) = ln 1 + E
j (1 − wj ) + γj E
U
(22)
By definition, the social welfare of the sellers is obtained by

j (wj , c).
 (w, c) =
U
U
j∈J

3530

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 62, NO. 6, JUNE 2015

Clearly, with the utility function of each seller being in the form
of (22), the game among the sellers reduces to a game where the
utility of seller j, for each j ∈ J , can be maximized by simply
j (wj , c) for a
finding the optimal strategy wj that maximizes U
given profile of strategies c for the buyers.
j (c) of seller j
Deﬁnition 4: The best response function B
as a leader is the best strategy for seller j given the buyers’
strategies c. By definition, we have
j (wj , c)
j (c) = arg max U
B
wj

∀j ∈ J .

(23)

Deﬁnition 5: A Stackelberg equilibrium of the two-level
game is a profile of strategies c∗ = (c∗i )i∈I for the buyers and
a profile of strategies w∗ = (wj∗ )j∈J for the sellers with the
property that


c∗i = Bi c∗−i , w∗
∀i ∈ I
j (c∗ ) ∀j ∈ J .
wj∗ = B
(24)

Fig. 2. Nash equilibrium solution of the normalized unit price c∗N with
respect to the number of buyers k.

Based on Definitions 4 and 5, and by (23) and (24), we have
j (wj , c∗ ).
wj∗ = arg max U

Corollary 2: A unique Stackelberg equilibrium exists in the
proposed two-level energy trading game.

wj

At the Nash equilibrium given by (12), we derive the normalized unit price offered by the buyers from (20) as

∗ 2
k−1
i∈I (ci )
c∗N = 
.
(25)
= cS
∗
c
2k
−1
i∈I i
Given (22), replacing c with c∗ , and hence replacing cN with
c∗N of the form in (25), we obtain


j wj c∗N .
j (wj , c∗ ) = ln 1 + E
j (1 − wj ) + γj E
U
j (wj , c∗ ) with
Taking the first and second derivatives of U
respect to wj , we have
j
j (wj , c∗ )
E
∂U
j c∗ −
= γj E
N
j (1 − wj )
∂wj
1+E
2

2
∗
Ej
∂ Uj (wj , c )
=−
2 .
∂wj2
j (1 − wj )
1+E

(26)
(27)

The right-hand side of (27) is negative. Therefore, the utility
j (wj , c∗ ) of seller j is strictly concave on Wj .
function U
Setting the right-hand side of (26) to zero for maximization,
we obtain


1
1
∗
wj = 1 +
1−
.
(28)
j
γj c∗N
E
We recall that, by definition, wj∗ must satisfy 0 ≤ wj∗ ≤ 1.
Therefore, if wj∗ obtained from (28) turns out to be smaller than
0 or larger than 1, we set wj∗ = 0 or wj∗ = 1, respectively.
Since the noncooperative game among the buyers has a
unique Nash equilibrium c∗ , as shown in Proposition 3, and
since, for each j ∈ J , seller j can always find its optimal
j (wj , c∗ ), we have the
strategy wj∗ due to the concavity of U
following corollary.

IV. N UMERICAL R ESULTS
In this section, we provide the detailed numerical results that
we have obtained for illustrating the equilibrium behavior of
the system. We are interested in the effect of the various system
parameters on the utility of microgrids and their strategies using
our proposed distributed energy trading mechanism.
Fig. 2 illustrates the Nash equilibrium solution of the normalized unit price c∗N with respect to the number of buyers k. For
this example, we set cS = 2.4/kWh. The results are calculated
from (25), where we see that the Nash equilibrium of the
normalized unit price monotonically increases as the number
of buyers in the system increases. In particular, when k = 2,
we have c∗N = 0.8, which is (1/3)cS . As k tends to infinity, we
observe that c∗N approaches 1.2, which is (1/2)cS . Thus, as a
result of our proposed trading mechanism, we have c∗N < cS
for all k ≥ 2. We know from (12) and (25) that, in our problem,
c∗i = c∗N for all i ∈ I. Therefore, trading with the sellers using
our proposed approach ensures that each buyer pays a unit price
not more than half of cS at the Nash equilibrium.
We recall that the Nash equilibrium in our context is the set
of strategies where none of the buyers can increase its own
utility by choosing a different strategy given the strategies of
the other buyers. This effect can be demonstrated by the results
plotted in Fig. 3. For this example, we set cB = 0.8/kWh
and cS = 2.4/kWh. We consider three buyers and four sellers,
j = {38, 20, 10, 25} kWh, and γj = 0.2 for all j. We
where E
fix c2 = c3 = c∗N , which is 0.96/kWh in this case, and vary
the value of the c1 of buyer 1 from cB to cS . The results in
Fig. 3 confirm that buyer 1 cannot increase its own utility at the
Stackelberg equilibrium by choosing a different strategy.
For the same example setting in Fig. 3, we demonstrate in
Fig. 4 the strategy of each seller at the Stackelberg equilibrium
with respect to the number of buyers k. We observe that, for

LEE et al.: DISTRIBUTED ENERGY TRADING IN MICROGRIDS

Fig. 3. Utility of buyer 1 with respect to its strategy c1 , given that each
of the two other buyers offers c∗N .

Fig. 4. Strategy of each seller wj∗ with respect to the number of buyers
k at the Stackelberg equilibrium.

all j, the value of wj∗ monotonically increases as k increases.
This is because as the number of buyers in the system increases,
the competition among the buyers becomes more severe so
that the unit price offered by each buyer at the equilibrium
also increases. As a result, the sellers tend to sell more energy
that can increase their utilities. We note that similar results
can be also observed in Figs. 5 and 6, where we illustrate
the social welfare of the buyers and that of the sellers at
the Stackelberg equilibrium, respectively. As the number of
buyers in the system increases, the social welfare of the buyers
monotonically decreases because of the increasing competition
among the buyers. On the other hand, the sellers as the leaders
have the advantage by choosing their strategies first and hence
can achieve higher utilities.
Finally, in Figs. 7 and 8, we demonstrate the efficiency of
the Nash equilibrium by illustrating the price of anarchy with
respect to the number of buyers k and that with respect to ratio

3531

Fig. 5. Social welfare of the buyers U (c∗ , w∗ ) with respect to the
number of buyers k at the Stackelberg equilibrium.

(w∗ , c∗ ) with respect to the
Fig. 6. Social welfare of the sellers U
number of buyers k at the Stackelberg equilibrium.
cB /cS , respectively. For the example in Fig. 7, we set cB =
0.8/kWh and cS = 2.4/kWh. For the example in Fig. 8, we fix
k = 16. The results confirm that the Nash equilibrium solution
of the noncooperative game is always lower bounded by half of
the optimal centralized solution of the cooperative game, and it
is equivalent to the optimal centralized solution when η = 1.
V. C ONCLUSION
We have proposed a fully distributed mechanism for energy
trading among microgrids. We have presented a rigorous gametheoretic analysis for deriving the equilibrium solution of the
system. The results have demonstrated that our proposed approach is guaranteed to have a unique equilibrium solution
that has comparable performance to the optimal centralized
solution and thus can maximize the payoff for all participating
microgrids. This paper has provided an incentive for energy
trading among microgrids in future power grids.

3532

IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS, VOL. 62, NO. 6, JUNE 2015

Fig. 7. Price of anarchy η with respect to the number of buyers k for
the noncooperative game among the buyers.

Fig. 8. Price of anarchy η with respect to ratio cB /cS for the noncooperative game among the buyers.

ACKNOWLEDGMENT
The authors would like to thank the anonymous reviewers
for their valuable comments that contributed to the improved
quality of this paper.
R EFERENCES
[1] S. M. Amin and B. F. Wollenberg, “Toward a smart grid: Power delivery
for the 21st century,” IEEE Power Energy Mag., vol. 3, no. 5, pp. 34–41,
Sep./Oct. 2005.
[2] A. Ipakchi and F. Albuyeh, “Grid of the future,” IEEE Power Energy
Mag., vol. 7, no. 2, pp. 52–62, Mar./Apr. 2009.
[3] H. Farhangi, “The path of the smart grid,” IEEE Power Energy Mag.,
vol. 8, no. 1, pp. 18–28, Jan./Feb. 2010.
[4] V. C. Gungor et al., “A survey on smart grid potential applications and
communication requirements,” IEEE Trans. Ind. Informat., vol. 9, no. 1,
pp. 28–42, Feb. 2013.
[5] D. Lindley, “Smart grids: The energy storage problem,” Nature, vol. 463,
no. 7277, pp. 18–20, Jan. 2010.
[6] S. Vazquez, S. M. Lukic, E. Galvan, L. G. Franquelo, and J. M. Carrasco,
“Energy storage systems for transport and grid applications,” IEEE Trans.
Ind. Electron., vol. 57, no. 12, pp. 3881–3895, Dec. 2010.

[7] C. Cecati, C. Citro, A. Piccolo, and P. Siano, “Smart operation of wind
turbines and diesel generators according to economic criteria,” IEEE
Trans. Ind. Electron., vol. 58, no. 10, pp. 4514–4525, Oct. 2011.
[8] J. M. Carrasco et al., “Power-electronic systems for the grid integration of
renewable energy sources: A survey,” IEEE Trans. Ind. Electron., vol. 53,
no. 4, pp. 1002–1016, Aug. 2006.
[9] B. K. Bose, “Global energy scenario and impact of power electronics in
21st century,” IEEE Trans. Ind. Electron., vol. 60, no. 7, pp. 2638–2651,
Jul. 2013.
[10] T. Sauter and M. Lobashov, “End-to-end communication architecture for
smart grids,” IEEE Trans. Ind. Electron., vol. 58, no. 4, pp. 1218–1228,
Apr. 2011.
[11] V. C. Güngör et al., “Smart grid technologies: Communication technologies and standards,” IEEE Trans. Ind. Informat., vol. 7, no. 4, pp. 529–539,
Nov. 2011.
[12] N. Hatziargyriou, H. Asano, R. Iravani, and C. Marnay, “Microgrids,”
IEEE Power Energy Mag., vol. 5, no. 4, pp. 78–94, Jul./Aug. 2007.
[13] B. Kroposki et al., “Making microgrids work,” IEEE Power Energy Mag.,
vol. 6, no. 3, pp. 40–53, May/Jun. 2008.
[14] F. Katiraei, R. Iravani, N. Hatziargyriou, and A. Dimeas, “Microgrids
management,” IEEE Power Energy Mag., vol. 6, no. 3, pp. 54–65,
May/Jun. 2008.
[15] W. W. Weaver and P. Krein, “Game-theoretic control of small-scale
power systems,” IEEE Trans. Power Del., vol. 24, no. 3, pp. 1560–1567,
Jul. 2009.
[16] N. C. Ekneligoda and W. W. Weaver, “Game-theoretic communication structures in microgrids,” IEEE Trans. Power Del., vol. 27, no. 4,
pp. 2334–2341, Oct. 2012.
[17] J. M. Guerrero, M. Chandorkar, T.-L. Lee, and P. C. Loh, “Advanced
control architectures for intelligent microgrids—Part I: Decentralized and
hierarchical control,” IEEE Trans. Ind. Electron., vol. 60, no. 4, pp. 1254–
1262, Apr. 2013.
[18] J. M. Guerrero, P. C. Loh, T.-L. Lee, and M. Chandorkar, “Advanced
control architectures for intelligent microgrids—Part II: Power quality,
energy storage, and AC/DC microgrids,” IEEE Trans. Ind. Electron.,
vol. 60, no. 4, pp. 1263–1270, Apr. 2013.
[19] N. C. Ekneligoda and W. W. Weaver, “Game theoretic cold-start transient
optimization in DC micro-grids,” IEEE Trans. Ind. Electron., vol. 61,
no. 12, pp. 6681–6690, Dec. 2014.
[20] N. Jain, S. N. Singh, and S. C. Srivastava, “A generalized approach for
DG planning and viability analysis under market scenario,” IEEE Trans.
Ind. Electron., vol. 60, no. 11, pp. 5075–5085, Nov. 2013.
[21] C. Chen, S. Duan, T. Cai, B. Liu, and G. Hu, “Optimal allocation and
economic analysis of energy storage system in microgrids,” IEEE Trans.
Power Electron., vol. 26, no. 10, pp. 2762–2773, Oct. 2011.
[22] J. Hetzer, D. C. Yu, and K. Bhattarai, “An economic dispatch model
incorporating wind power,” IEEE Trans. Energy Convers., vol. 23, no. 2,
pp. 603–611, Jun. 2008.
[23] H. Morais, P. Kádár, P. Faria, Z. A. Vale, and H. M. Khodr, “Optimal
scheduling of a renewable micro-grid in an isolated load area using mixedinteger linear programming,” Renew. Energy, vol. 35, no. 1, pp. 151–156,
Jan. 2010.
[24] I. Maity and S. Rao, “Simulation and pricing mechanism analysis of a
solar-powered electrical microgrid,” IEEE Syst. J., vol. 4, no. 3, pp. 275–
284, Sep. 2010.
[25] E. M. Constantinescu, V. M. Zavala, M. Rocklin, S. Lee, and M. Anitescu,
“A computational framework for uncertainty quantification and stochastic
optimization in unit commitment with wind power generation,” IEEE
Trans. Power Syst., vol. 26, no. 1, pp. 431–441, Feb. 2011.
[26] A. Pantoja and N. Quijano, “A population dynamics approach for the
dispatch of distributed generators,” IEEE Trans. Ind. Electron., vol. 58,
no. 10, pp. 4559–4567, Oct. 2011.
[27] H. Kanchev, D. Lu, F. Colas, V. Lazarov, and B. Francois, “Energy management and operational planning of a microgrid with a PV-based active
generator for smart grid applications,” IEEE Trans. Ind. Electron., vol. 58,
no. 10, pp. 4583–4592, Oct. 2011.
[28] A. Chaouachi, R. M. Kamel, R. Andoulsi, and K. Nagasaka, “Multiobjective intelligent energy management for a microgrid,” IEEE Trans. Ind.
Electron., vol. 60, no. 4, pp. 1688–1699, Apr. 2013.
[29] S. M. Ali, “Electricity trading among microgrids,” M.S. thesis, Dept.
Mech. Eng., Univ. Strathclyde, Glasgow, U.K., 2009.
[30] W. Saad, Z. Han, and H. V. Poor, “Coalitional game theory for cooperative
micro-grid distribution networks,” in Proc. IEEE ICC, Kyoto, Japan, Jun.
2011, pp. 1–5.
[31] J. Matamoros, D. Gregoratti, and M. Dohler, “Microgrids energy trading
in islanding mode,” in Proc. IEEE SmartGridComm, Tainan, Taiwan, Nov.
2012, pp. 49–54.

LEE et al.: DISTRIBUTED ENERGY TRADING IN MICROGRIDS

[32] G. E. Asimakopoulou, A. L. Dimeas, and N. D. Hatziargyriou, “Leaderfollower strategies for energy management of multi-microgrids,” IEEE
Trans. Smart Grid, vol. 4, no. 4, pp. 1909–1916, Dec. 2013.
[33] H. S. V. S. Kumar Nunna and S. Doolla, “Multiagent-based distributedenergy-resource management for intelligent microgrids,” IEEE Trans.
Ind. Electron., vol. 60, no. 4, pp. 1678–1687, Apr. 2013.
[34] E. McKenna and M. Thomson, “Photovoltaic metering configurations,
feed-in tariffs and the variable effective electricity prices that result,” IET
Renew. Power Gener., vol. 7, no. 3, pp. 235–245, May 2013.
[35] T. Başar and G. J. Olsder, Dynamic Noncooperative Game Theory, 2nd
ed. Philadelphia, PA, USA: SIAM, 1999.
[36] D. Keles, M. Genoese, D. Möst, S. Ortlieb, and W. Fichtner, “A combined
modeling approach for wind power feed-in and electricity spot prices,”
Energy Policy, vol. 59, pp. 213–225, Aug. 2013.
[37] N. S. Wade, P. C. Taylor, P. D. Lang, and P. R. Jones, “Evaluating the
benefits of an electrical energy storage system in a future smart grid,”
Energy Policy, vol. 38, no. 11, pp. 7180–7188, Nov. 2010.
[38] D. Zafirakis, K. J. Chalvatzis, G. Baiocchi, and G. Daskalakis, “Modeling
of financial incentives for investments in energy storage systems that promote the large-scale integration of wind energy,” Appl. Energy, vol. 105,
pp. 138–154, May 2013.
[39] P. A. Samuelson and W. D. Nordhaus, Microeconomics, 18th ed. Boston,
MA, USA: McGraw-Hill, 2005.
[40] T. Alpcan and T. Başar, “A globally stable adaptive congestion control
scheme for Internet-style networks with delay,” IEEE/ACM Trans. Netw.,
vol. 13, no. 6, pp. 1261–1274, Dec. 2005.
[41] D. Niyato, E. Hossain, and Z. Han, “Dynamics of multiple-seller and
multiple-buyer spectrum trading in cognitive radio networks: A gametheoretic modeling approach,” IEEE Trans. Mobile Comput., vol. 8, no. 8,
pp. 1009–1022, Aug. 2009.
[42] W. Tushar, W. Saad, H. V. Poor, and D. B. Smith, “Economics of electric
vehicle charging: A game theoretic approach,” IEEE Trans. Smart Grid,
vol. 3, no. 4, pp. 1767–1778, Dec. 2012.
[43] W. Tushar, J. A. Zhang, D. B. Smith, H. V. Poor, and S. Thiébaux,
“Prioritizing consumers in smart grid: A game theoretic approach,” IEEE
Trans. Smart Grid, vol. 5, no. 3, pp. 1429–1438, May 2014.
[44] W. Tushar et al., “Three-party energy management with distributed energy resources in smart grid,” IEEE Trans. Ind. Electron., vol. 62, no. 4,
pp. 2487–2498, Jul. 2014.
[45] H. D. Sherali, “A multiple leader Stackelberg model and analysis,” Oper.
Res., vol. 32, no. 2, pp. 390–404, Mar./Apr. 1984.
[46] S. Maharjan, Q. Zhu, Y. Zhang, S. Gjessing, and T. Başar, “Dependable
demand response management in the smart grid: A Stackelberg game
approach,” IEEE Trans. Smart Grid, vol. 4, no. 1, pp. 120–132, Mar. 2013.
[47] D. Fudenberg and J. Tirole, Game Theory. Cambridge, MA, USA: MIT
Press, 1991.
[48] R. D. Yates, “A framework for uplink power control in cellular radio
systems,” IEEE J. Sel. Areas Commun., vol. 13, no. 7, pp. 1341–1347,
Sep. 1995.
[49] N. Nisan, T. Roughgarden, E. Tardos, and V. V. Vazirani, Eds., Algorithmic Game Theory. Cambridge, U.K.: Cambridge Univ. Press, 2007.

Joohyung Lee (S’09–M’14) received the B.S.,
M.S., and Ph.D. degrees from the Korea Advanced Institute of Science and Technology,
Daejeon, Korea, in 2008, 2010, and 2014,
respectively.
He was with the Department of Electronic
Engineering, College of Science and Engineering, City University of Hong Kong, Kowloon,
Hong Kong, as a Visiting Researcher from 2012
to 2013. Since 2014, he has been with the
Digital Media and Communications Research
and Development Center, Samsung Electronics Company Ltd., Suwon,
Korea, as a Senior Engineer. His research interests include resource
allocation and optimization, with a focus on resource management for
5G networks, green networks, smart grids (future power grids), and
network economics.
Dr. Lee has been an active member of the GreenTouch Consortium.
Since 2010, he has contributed several articles to the International
Telecommunication Union Telecommunication Standardization Sector
Study Group 13 Questions 9 and 22. He was the recipient of the
Best Paper Award at the Integrated Communications, Navigation, and
Surveillance Conference in 2011.

3533

Jun Guo (S’01–M’06) received the B.E. degree in automatic control engineering from
the Shanghai University of Science and Technology, Shanghai, China, in 1992 and the
M.E. degree in telecommunications engineering
and the Ph.D. degree in electrical and electronic engineering from the University of Melbourne, Melbourne, Australia, in 2001 and 2006,
respectively.
From 2006 to 2008, he was with the School of
Computer Science and Engineering, Faculty of
Engineering, The University of New South Wales, Kensington, Australia,
as a Senior Research Associate. Since 2012, he has been with the
Department of Electronic Engineering, College of Science and Engineering, City University of Hong Kong, Kowloon, Hong Kong, where he
is currently a Visiting Assistant Professor. His research is focused on
survivable network topology design, teletraffic theory and its applications
in service sectors, and multicast in wired/wireless networks.
Dr. Guo was the recipient of an Australian Postdoctoral Fellowship
supported by the Australian Research Council from 2009 to 2011.

Jun Kyun Choi (M’88–SM’00) received the
M.S. (Eng.) and Ph.D. degrees in electronic
engineering from the Korea Advanced Institute
of Science and Technology (KAIST), Daejeon,
Korea, in 1985 and 1988, respectively.
From 1986 to 1997, he was with the Electronics and Telecommunication Research Institute,
Daejeon, Korea. Since 1998, he has been with
the Department of Electronic Engineering, Korea Advanced Institute of Science and Technology, as a Professor. His research interests include broadband network architecture and technologies, with particular
emphasis on performance and protocol problems.
Dr. Choi has been an active member of the International Telecommunication Union Telecommunication Standardization Sector Study Group
13 as a Rapporteur/Editor on the asynchronous transfer mode (ATM),
multiprotocol label switching (MPLS), and next-generation network
(NGN) issues since 1993.

Moshe Zukerman (M’87–SM’91–F’07) received
the B.Sc. degree in industrial engineering and
management and the M.Sc. degree in operations research from the Technion–Israel Institute of Technology, Haifa, Israel, in 1976 and
1979, respectively, and the Ph.D. degree in
engineering from the University of California at
Los Angeles, Los Angeles, CA, USA, in 1985.
From 1985 to 1986, he was an Independent
Consultant with the IRI Corporation and a Postdoctoral Fellow with the University of California
at Los Angeles. He was with Telstra Research Laboratories, Melbourne,
Australia, where he first worked as a Research Engineer from 1986
to 1988 and then as a Project Leader from 1988 to 1997. From 1990
to 2001, he also taught and supervised graduate students at Monash
University, Melbourne, Australia. From 1997 to 2008, he was with the
University of Melbourne, Melbourne, Australia. Since 2008, he has been
with the Department of Electronic Engineering, College of Science and
Engineering, City University of Hong Kong, Kowloon, Hong Kong, as
Chair Professor of Information Engineering and as a Team Leader.
Dr. Zukerman has served on various editorial boards, including the
editorial board of Computer Networks, of the IEEE Communications
Magazine, of the IEEE J OURNAL OF S ELECTED A REAS IN C OMMUNI CATIONS , of the IEEE/ACM T RANSACTIONS ON N ETWORKING , and of
the International Journal of Communication Systems.

Symmetric Splitting in the General Theory of Stable Models
Paolo Ferraris1 , Joohyung Lee2 , Vladimir Lifschitz3 , and Ravi Palla2
1

Google, Inc.
1600 Amphitheatre Parkway
Mountain View, CA 94043, USA
otto@cs.utexas.edu

2

Computer Sci. and Eng.
Arizona State University
Tempe, AZ 85281, USA
{joolee, Ravi.Palla}@asu.edu

Splitting a logic program allows us to reduce the
task of computing its stable models to similar tasks
for smaller programs. This idea is extended here
to the general theory of stable models that replaces traditional logic programs by arbitrary ﬁrstorder sentences and distinguishes between intensional and extensional predicates. We discuss two
kinds of splitting: a set of intensional predicates can
be split into subsets, and a formula can be split into
its conjunctive terms.

is M1 (p is true, q is false). Intuitively, q is false in the stable
model of (3) because its deﬁnition is empty: q does not occur
in the head of any rule. But the program

Introduction

p ← not q

This paper contributes to the theory of stable models, which
is the mathematical basis of answer set programming (ASP)
[Marek and Truszczyński, 1999; Niemelä, 1999; Lifschitz,
2008].
The splitting method [Lifschitz and Turner, 1994] can be
sometimes used to reduce the task of computing the stable
models of a logic program to similar tasks for smaller programs. Consider, for instance, the program
p ← not q
q ← not p
r ← q.

(q is input)

(4)

has both M1 and M2 as its stable models, according to Oikarinen and Janhunen. Intuitively, by saying that q is an input
atom we assert that its truth value can be chosen arbitrarily; it
is not supposed to be determined by the rules of the program.1
The version of the splitting theorem established in [Oikarinen and Janhunen, 2008] allows us to split (2) into two programs: (4) and
q ← not p

(1)

(p is input).

(5)

That theorem shows that the stable models of (2) can be characterized as the common stable models of these two one-rule
programs. Since M1 is a stable model of each of the programs (4), (5), it is a stable model of (2) as well, and the same
can be said about M2 . This example illustrates the power of
“symmetric splitting” described in [Oikarinen and Janhunen,
2008] in comparison with “top-bottom splitting” proposed in
[Lifschitz and Turner, 1994]. Symmetric splitting is extended
to disjunctive programs in [Janhunen et al., 2007].
The existing work on symmetric splitting does not cover,
however, logic programs with variables, and it is not applicable to some types of rules that are frequently used in ASP,
such as choice rules and cardinality constraints [Simons et
al., 2002]. In this paper, we extend symmetric splitting to
the general theory of stable models in which traditional logic

Its stable models can be generated as follows. We concentrate
ﬁrst on the program consisting of the ﬁrst two rules of (1):
p ← not q
q ← not p.

Dept. of Computer Sciences
University of Texas at Austin
1 University Station C0500
Austin, TX 78705, USA
vl@cs.utexas.edu

and q have been determined. Program (2), on the other hand,
cannot be further split in the sense of [Lifschitz and Turner,
1994], because it deﬁnes p and q in terms of each other.
A more general version of splitting is described in [Oikarinen and Janhunen, 2008]. In the framework of that paper,
some atoms occurring in a logic program can be designated
as its “input” atoms, and that may affect the meaning of the
program. For instance, the only stable model of the one-rule
program
p ← not q
(no input atoms)
(3)

Abstract

1

3

(2)

In one of its stable models, p is true and q is false; call that
model M1 . In the other, p is false and q is true; call it M2 .
Then we look at the third rule of (1) and determine how this
rule instructs us to “update” each of the models M1 , M2 by
assigning a truth value to r. Since its body q is false in M1 ,
the head r becomes false in this model as well. Since q is true
in M2 , r becomes true in M2 . Thus the stable models of the
given program are {p} and {q, r}.
Splitting (1) into parts is possible because r does not occur in the rules that “deﬁne” p and q, so that p and q do not
“depend” on r. Accordingly, determining the truth value of r
can be postponed until the time when the truth values of p

1
Saying that q is an input atom is similar to augmenting
the program with the LPARSE choice rule {q}. (For a description of the language of LPARSE, see http://www.tcs.hut.
fi/Software/smodels/lparse.ps.)

797

programs are replaced by arbitrary ﬁrst-order sentences. This
general approach to stable models is introduced in [Ferraris
et al., 2010]2 and reviewed in Section 2 below. It covers the
programming constructs mentioned above, and other useful
constructs, by treating them as abbreviations for ﬁrst-order
formulas. For instance, the LPARSE program Π consisting of
three rules

The example of splitting program (1) above corresponds to
(¬q → p) ∧ (¬p → q)
q→r
pq
r
To split program (2), we take
¬q → p
¬p → q
p
q

{in(X)} :- vertex(X).
:- vertex(X;Y), in(X;Y),
not edge(X,Y), not edge(Y,X), X!=Y.
:- {in(X):vertex(X)} n.
corresponds to the formula
∀x(vertex(x) → (in(x) ∨ ¬in(x))
∧ ∀xy¬(vertex(x) ∧ vertex(y) ∧ in(x) ∧ in(y)
∧ ¬edge(x, y) ∧ ¬edge(y, x) ∧ x = y)
∧ ¬¬∃n+1 x(in(x) ∧ vertex(x)),
where ∃n xF (x) is shorthand for
⎛

∃x1 · · · xn ⎝
F (xi ) ∧
1≤i≤n



(6)

SMpq [F ] is equivalent to

xi = xj ⎠ .

SMp [F ] ∧ SMq [F ].

This “splitting lemma” is more general than the splitting theorem in the sense that it is applicable, in principle, to formulas
of any syntactic form, not only to conjunctions. On the other
hand, it does not split the formula itself; it only splits the list
of intensional predicates.
We will see that the assumption about F , p and q in the
statement of the splitting lemma is related to the concept of a
loop, introduced in [Lin and Zhao, 2004] for traditional logic
programs and generalized to arbitrary ﬁrst-order formulas in
[Lee and Meng, 2008].
This paper includes proofs of the splitting lemma and the
splitting theorem, and also a brief discussion of the applications of splitting that motivated this work.

1≤i<j≤n

(Program Π describes large cliques in a graph, as discussed
in Section 7.) Note that the ﬁrst conjunctive term of (6) is
logically valid, so that dropping it would not affect the class
of models of (6). But the class of stable models of this formula, as deﬁned in the next section, would be affected; in this
sense, the ﬁrst conjunctive term of (6) is essential. For the
same reason, we do not drop ¬¬ in front of ∃n+1 x.
The distinction between extensional and intensional predicates in [Ferraris et al., 2010] is similar to the distinction between input and non-input atoms in [Oikarinen and Janhunen,
2008]. As discussed below, stable models of a ﬁrst-order sentence F relative to a list p of intensional predicates are deﬁned as models of the sentence obtained from F by a certain
syntactic transformation, denoted by SMp . (This transformation, like circumscription, makes a formula stronger, so that
all stable models of F in the sense of that deﬁnition are indeed
models of F .) For instance, if F is

2

Review: Operator SM

This review follows [Ferraris et al., 2010]. Notation: if p and
q are predicate constants of the same arity then p ≤ q stands
for the formula
∀x(p(x) → q(x)),
where x is a tuple of distinct object variables. If p and q are
tuples p1 , . . . , pn and q1 , . . . , qn of predicate constants then
p ≤ q stands for the conjunction

(7)

(which is program (1) written as a formula) then SMpqr [F ]
can be equivalently rewritten as

(p1 ≤ q1 ) ∧ · · · ∧ (pn ≤ qn ),

(¬q ↔ p) ∧ (q ↔ r).3

and p < q stands for (p ≤ q) ∧ ¬(q ≤ p). In secondorder logic, we apply the same notation to tuples of predicate
variables.
We will deﬁne the stable model operator with the intensional predicates p, denoted by SMp . Some details of the definition depend on which propositional connectives and quantiﬁers are treated as primitives, and which of them are viewed
as abbreviations. We assume that

This formula has two models—the stable models of (1).
Our version of the splitting theorem asserts that under certain syntactic conditions
SMpq [F ∧ G] is equivalent to

as F,
as G,
as p,
as q.

The new splitting theorem is applicable also in many situations that are not covered by the version due to Oikarinen and
Janhunen, including, as we will see, some that are important
from the perspective of answer set programming and knowledge representation.
The splitting theorem easily follows from a lemma that
may be of interest in its own right. The lemma asserts that
under certain syntactic conditions

⎞

(¬q → p) ∧ (¬p → q) ∧ (q → r)

as F,
as G,
as p,
as q.

SMp [F ] ∧ SMq [G].

2

That article is the journal version of the IJCAI-07 paper [Ferraris et al., 2007]. In the conference paper, all predicates are implicitly assumed to be intensional.
3
This is essentially the completion of (1) in the sense of [Clark,
1978]. In this example, the stable model semantics produces the
same result as the completion semantics.

⊥ (falsity), ∧, ∨, →, ∀, ∃
are the primitives; ¬F stands for F → ⊥,  is ⊥ → ⊥, and
F ↔ G is (F → G) ∧ (G → F ).

798

Let p be a list of distinct predicate constants p1 , . . . , pn
other than equality. For any ﬁrst-order sentence F , by
SMp [F ] we denote the second-order sentence

say that an occurrence of a predicate constant in a formula
is negated if it belongs to a subformula of the form ¬F (that
is, F → ⊥), and nonnegated otherwise. For instance, in the
formula
q(x) ∧ ¬r(x) → p(x),
(11)

F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where u is a list of n distinct predicate variables u1 , . . . , un ,
and F ∗ (u) is deﬁned recursively:
• pi (t)∗ = ui (t) for any tuple t of terms;
• F ∗ = F for any atomic F that does not contain members
of p;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;
• (∃xF )∗ = ∃xF ∗ .
A model of F is stable (relative to the set p of intensional
predicates) if it satisﬁes SMp [F ].
For instance, let F be the formula
∀x(p(x) → (q(x) ∨ ¬q(x)),

corresponding to rule (10), both p and r are positive, p is
strictly positive, and r is negated.
A rule of a ﬁrst-order formula F is a strictly positive occurrence of an implication in F . For instance, the rules of (8)
are p(x) → (q(x) ∨ ¬q(x)) and ¬q(x); the only rule of (11)
is (11) itself.
For any ﬁrst-order formula F , the predicate dependency
graph of F (relative to the list p of intensional predicates) is
the directed graph that
• has all intensional predicates as its vertices, and
• has an edge from p to q if, for some rule G → H of F ,
– p has a strictly positive occurrence in H, and
– q has a positive nonnegated occurrence in G.
For instance, the predicate dependency graph of (11) relative
to pqr has one edge, from p to q. We will denote the predicate
dependency graph of F relative to p by DGp [F ].

(8)

representing the choice rule
{q(X)} :- p(X).
If we take q to be the only intensional predicate then F ∗ (u)
is
∀x((p(x) → (u(x) ∨ (¬u(x) ∧ ¬q(x))))
∧ (p(x) → (q(x) ∨ ¬q(x)))),

Splitting Lemma, Version 1 Let F be a ﬁrst-order sentence,
and let p, q be disjoint tuples of distinct predicate constants.
If each strongly connected component of DGpq [F ] is a subset
of p or a subset of q then
SMpq [F ] is equivalent to SMp [F ] ∧ SMq [F ].

so that SMq [F ] is
∀x(p(x) → (q(x) ∨ ¬q(x)))
∧ ¬∃u((u < q)
∧ ∀x((p(x) → (u(x) ∨ (¬u(x) ∧ ¬q(x))))
∧ (p(x) → (q(x) ∨ ¬q(x))))).

Note that the condition on DGpq [F ] in the statement of the
lemma holds trivially if all strongly connected components of
this graph are singletons.

(9)

Example 1: F is ¬p ∧ r → q, p is p, q is q. In this case, the
graph DGpq [F ] has two vertices p, q, and no edges, so that its
strongly connected components are singletons. The splitting
lemma asserts that

This sentence is equivalent to the ﬁrst-order formula
∀x(q(x) → p(x)),

SMpq [¬p ∧ r → q]

which reﬂects the intuitive meaning of choice: q is an arbitrary subset of p.

3

(12)

is equivalent to the conjunction of

Splitting Lemma

The statement of the splitting lemma refers to the predicate
dependency graph of a formula, deﬁned in [Ferraris et al.,
2007] and [Ferraris et al., 2010].4 This deﬁnition, reproduced
below, generalizes the idea that if a logic program contains,
say, the rule
p(x) ← q(x), not r(x)
(10)
then p “positively depends” on q in this program.
Recall that an occurrence of a predicate constant, or any
other subexpression, in a formula is called positive if the
number of implications containing that occurrence in the antecedent is even, and strictly positive if that number is 0. We

and

SMp [¬p ∧ r → q]

(13)

SMq [¬p ∧ r → q].

(14)

Each of these three expressions can be rewritten as a propositional formula using the methods described in [Ferraris et al.,
2010]. Formula (12) becomes
(p ↔ ⊥) ∧ (q ↔ ¬p ∧ r),

(15)

(¬p ∧ r → q) ∧ ¬p,

(16)

q ↔ ¬p ∧ r.

(17)

(13) becomes
and (14) turns into

4

We follow here the version given in the second paper, which
is simpler but can introduce some unnecessary dependencies when
applied to deeply nested implications.

It is clear that (15) is indeed equivalent to the conjunction
of (16) and (17).

799

Example 2: F is r → p ∨ q, p is p, q is q. The graph
DGpq [F ] is the same as in Example 1, and the splitting
lemma asserts that

Splitting Lemma, Version 3 Let F be a ﬁrst-order sentence, and let p be a tuple of distinct predicate constants.
If l1 , . . . , ln are all the loops of F relative to p then

SMpq [r → p ∨ q]

SMp [F ] is equivalent to SMl1 [F ] ∧ · · · ∧ SMln [F ].

(18)

is equivalent to the conjunction of

and

SMp [r → p ∨ q]

(19)

SMq [r → p ∨ q].

(20)

The last two versions of the splitting lemma are equivalent
to each other in view of the fact that the operator SMp is
monotone with respect to p: if p contains q then SMp [F ]
entails SMq [F ].

The methods for simplifying SMp [F ] described in [Ferraris et
al., 2010] are not directly applicable to (18), but they allow us
to simplify (19) and (20). The version of program completion
presented in that paper turns the former into p ↔ ¬q ∧ r and
the latter into q ↔ ¬p ∧ r. Consequently (18) is equivalent to
the conjunction of these two formulas.

4

Lemmas 1 and 2 below can be easily proved by induction [Ferraris et al., 2010].
Lemma 1 Formula
(u ≤ p) ∧ F ∗ (u) → F

Example 2 shows that the splitting lemma allows us to expand the power of completion, as a method for describing
stable models, to some disjunctive programs. This is similar
to the generalization of completion to disjunctive programs
described in [Lee and Lifschitz, 2003]; the advantage of the
splitting lemma is that it is applicable to programs with variables. For instance, using the same argument as in Example 2
we can check that

is logically valid.
About a formula F we say that it is negative on a tuple p of
predicate constants if members of p have no strictly positive
occurrences in F .
Lemma 2 If F is negative on p then
(u ≤ p) → (F ∗ (u) ↔ F )

SMpq [∀xy(r(x, y) → p(x) ∨ q(y))]

is logically valid.

is equivalent to the conjunction of

The following lemma extends Lemma 3 from [Ferraris et
al., 2006] to ﬁrst-order formulas.
Lemma 3 Let p1 , p2 be disjoint lists of distinct predicate
constants, and let u1 , u2 be disjoint lists of distinct predicate
variables of the same length as p1 , p2 respectively.
(a) If every positive occurrence of every predicate constant
from p2 in F is negated then

∀x(p(x) ↔ ∃y(¬q(y) ∧ r(x, y)))
and

Proof of the Splitting Lemma

∀y(q(y) ↔ ∃x(¬p(x) ∧ r(x, y))).

To illustrate the role of the condition on the predicate
dependency graph in the statement of the splitting lemma,
take F to be p ↔ q, with p as p and q as q. The graph
DGpq [F ] in this case has two edges, from p to q and from q
to p. The strongly connected component {p, q} of this graph
has a common element with p and a common element with
q, so that the splitting lemma is not applicable. Accordingly,
the formulas SMpq [p ↔ q] and SMp [p ↔ q] ∧ SMq [p ↔ q]
are not equivalent to each other. Indeed, the former can be
rewritten as ¬p ∧ ¬q, and each conjunctive term of the latter
is equivalent to p ↔ q.
The splitting lemma as stated above can be equivalently
reformulated as follows:

((u1 , u2 ) ≤ (p1 , p2 )) ∧ F ∗ (u1 , p2 ) → F ∗ (u1 , u2 )
is logically valid.
(b) If every nonpositive occurrence of every predicate constant from p2 in F is negated then
((u1 , u2 ) ≤ (p1 , p2 )) ∧ F ∗ (u1 , u2 ) → F ∗ (u1 , p2 )
is logically valid.
Proof. Both parts are proved simultaneously by induction
on F . Consider the case when F is G → H; the other cases
are straightforward. Then F ∗ (u1 , u2 ) is

Splitting Lemma, Version 2 Let F be a ﬁrst-order sentence, and let p be a tuple of distinct predicate constants.
If c1 , . . . , cn are all the strongly connected components
of DGp [F ] then

(G∗ (u1 , u2 ) → H ∗ (u1 , u2 )) ∧ (G → H).

(21)

(a) Every nonpositive occurrence of every predicate constant
from p2 in G is negated, and so is every positive occurrence
of every predicate constant from p2 in H. By the induction
hypothesis, it follows that the formulas

SMp [F ] is equivalent to SMc1 [F ] ∧ · · · ∧ SMcn [F ].
A loop of a ﬁrst-order formula F (relative to a list p of
intensional predicates) is a nonempty subset l of p such that
the subgraph of DGp [F ] induced by l is strongly connected.
It is clear that the strongly connected components of DGp [F ]
can be characterized as the maximal loops of F .

((u1 , u2 ) ≤ (p1 , p2 )) ∧ G∗ (u1 , u2 ) → G∗ (u1 , p2 ) (22)
and
(u1 , u2 ) ≤ (p1 , p2 ) ∧ H ∗ (u1 , p2 ) → H ∗ (u1 , u2 )

800

(23)

are logically valid. Assume (u1 , u2 ) ≤ (p1 , p2 ),
(G∗ (u1 , p2 ) → H ∗ (u1 , p2 )) ∧ (G → H)

The proof is essentially the same as the proof of Lemma 4
in [Ferraris et al., 2006].

(24)

Proof of Version 3 of the Splitting Lemma. It is sufﬁcient
to prove the logical validity of the formula

and G∗ (u1 , u2 ). By (22), we conclude G∗ (u1 , p2 ). Then, by
(24), we conclude H ∗ (u1 , p2 ). Then, by (23), we conclude
H ∗ (u1 , u2 ). (b) Similar.

∃u((u < p) ∧ F ∗ (u))
1 ))
↔ ∃u1 ((u1 < l1 ) ∧ F ∗ (u
n
n
n )),
∨ · · · ∨ ∃u ((u < ln ) ∧ F ∗ (u

The following assertion is a generalization of Lemma 5
from [Ferraris et al., 2006].

where each ui is the part of u that corresponds to the part li
of p, and ui is the list of symbols obtained from p by replacing every intensional predicate p that belongs to li with the
corresponding predicate variable u. Right to left: Clear. Left
to right: Assume ∃u((u < p) ∧ F ∗ (u)) and take u such that
(u < p)∧F ∗ (u). Consider several cases, each corresponding
to a nonempty subset Y of p. The assumption characterizing
each case is that u < p for each member p of p that belongs
to Y , and that u = p for each p that does not belong to Y .
By Lemma 5, there is a loop li of F that is contained in Y
such that the dependency graph has no edges from predicate
constants in li to predicate constants in Y \ li . Since li is contained in Y , from the fact that u < p for each p in Y we can
conclude that
(26)
ui < li .

Let u be the list of symbols obtained from p by replacing
every member p that belongs to Y with the corresponding
variable u. Under the assumption characterizing each case,
u = u , so that F ∗ (u) ↔ F ∗ (u ). Consequently, we can
derive F ∗ (u ). It follows from Lemma 4 that the formula

Lemma 4 Let p1 , p2 be disjoint lists of distinct predicate
constants such that DGp1 p2 [F ] has no edges from predicate
constants in p1 to predicate constants in p2 , and let u1 , u2 be
disjoint lists of distinct predicate variables of the same length
as p1 , p2 respectively. Formula
((u1 , u2 ) ≤ (p1 , p2 )) ∧ F ∗ (u1 , u2 ) → F ∗ (u1 , p2 )
is logically valid.
Proof. By induction on F . Consider the case when F
is G → H, so that F ∗ (u1 , u2 ) is (21); the other cases
are straightforward. Assume (u1 , u2 ) ≤ (p1 , p2 ) and
F ∗ (u1 , u2 ). Our goal is to prove
G∗ (u1 , p2 ) → H ∗ (u1 , p2 ).
Assume G∗ (u1 , p2 ). By Lemma 1, the formula
((u1 , p2 ) ≤ (p1 , p2 )) ∧ G∗ (u1 , p2 ) → G

(25)

is logically valid. Consequently, from the assumptions above
we can conclude G, and, by (21), H. Case 1: H is negative
on p1 . It follows from Lemma 2 that the formula

(u ≤ p) ∧ F ∗ (u ) → F ∗ (ui )

((u1 , p2 ) ≤ (p1 , p2 )) → (H ∗ (u1 , p2 ) ↔ H)

is logically valid, so that we further conclude that F ∗ (ui ). In
view of (26), it follows that ∃ui ((ui < li ) ∧ F ∗ (ui )).

is logically valid, and we can conclude that H ∗ (u1 , p2 ).
Case 2: H is not negative on p1 , that is to say, H contains
a strictly positive occurrence of a predicate constant from p1 .
Then every positive occurrence of every predicate constant
from p2 in G is negated, because otherwise there would exist
an edge from p1 to p2 in DGp1 p2 [F ]. By Lemma 3(a), the
formula

5

Application: Dropping Double Negations

The semantics of the answer set programming language
RASPL-1 is deﬁned in [Lee et al., 2008] using a syntactic
translation that turns every RASPL-1 program into a ﬁrstorder sentence, called its FOL-representation. An answer set
of a RASPL-1 program Π is deﬁned as an arbitrary Herbrand
stable model of the FOL-representation of Π.
To relate RASPL-1 to cardinality constraint programs in
the sense of [Syrjänen, 2004], the authors deﬁned a class of
strongly regular RASPL-1 programs. The answer sets of any
program in this class are identical to its answer sets in the
sense of Syrjänen [Lee et al., 2008, Proposition 5]. This fact
is stated in the paper without proof, and the key part of the
proof involves checking that, under certain conditions, dropping a double negation from a ﬁrst-order sentence does not
affect its stable models. One such case is described in the
following proposition:

((u1 , u2 ) ≤ (p1 , p2 )) ∧ G∗ (u1 , p2 ) → G∗ (u1 , u2 )
is logically valid. Consequently from the assumptions above
we can conclude that G∗ (u1 , u2 ). By (21), it follows that
H ∗ (u1 , u2 ). Since every edge in DGp1 p2 [H] belongs to
DGp1 p2 [F ], by the induction hypothesis applied to H, the
formula
((u1 , u2 ) ≤ (p1 , p2 )) ∧ H ∗ (u1 , u2 ) → H ∗ (u1 , p2 )
is logically valid. We can thus conclude that H ∗ (u1 , p2 ).
Lemma 5 For any formula F and any nonempty set Y of
intensional predicates, there exists a subset Z of Y such that

Theorem on Double Negations Let H be a sentence, F a
subformula of H, and H − the sentence obtained from H by
inserting ¬¬ in front of F . If F is contained in a subformula G of H that is negative on p then SMp [H − ] is equivalent to SMp [H].

(a) Z is a loop of F , and
(b) the predicate dependency graph of F has no edges from
predicate constants in Z to predicate constants in Y \ Z.

801

Proof. Let G− be the formula obtained from G by inserting
¬¬ in front of F . By Lemma 2, the formulas
u ≤ p → (G∗ (u) ↔ G)
and
u ≤ p → ((G− )∗ (u) ↔ G− )
are logically valid. Consequently
u ≤ p → (G∗ (u) ↔ (G− )∗ (u))
is logically valid also, and so is
u ≤ p → (H ∗ (u) ↔ (H − )∗ (u)).
It follows that SMp [H − ] is equivalent to SMp [H].

7

The intuition behind the rules of the program Π from the introduction is easy to explain. The ﬁrst rule says that the extent
of the predicate in is an arbitrary set of vertices. The second
rule expresses the deﬁnition of a clique: a clique may not
contain a pair of distinct vertices that are not adjacent to each
other. The third rule expresses a restriction on the size of the
clique: it is not allowed to be ≤ n.
The claim that Π describes large cliques in a graph can be
made precise in two ways: by considering logic programs obtained from Π by adding descriptions of speciﬁc graphs, and
in an abstract way, as a theorem about program Π itself. In
both formulations below, σ is the signature consisting of the
predicate constants vertex, edge, and in, and Γ is an arbitrary
ﬁnite directed graph.

By itself, this theorem does not help us prove Proposition 5
from [Lee et al., 2008]: the condition
F is contained in a subformula G of H that is negative on p
turns out to be too restrictive. What we need to observe is that
this condition can be relaxed as follows:
for every strongly connected component c of
DGp [H], F is contained in a subformula G of H
that is negative on c.
The possibility of strengthening the theorem on double negations in this way is immediate from Version 2 of the splitting
lemma.

6

Application: Abstract ASP Programs

Correctness of Π, Formulation 1. Extend σ by adding the
vertices of Γ as object constants. Let I be an interpretation of
the extended signature that interprets each object constant as
itself, interprets vertex as the set of vertices of Γ, and interprets edge as the set of edges of Γ. Let X be the set of ground
atoms that contain vertex or edge and are satisﬁed by I. The
following conditions are equivalent:
• I is a stable model of the conjunction of (6) and the
atoms X, with the intensional predicates vertex, edge,
and in,
• the extent of in in I is a clique in Γ, and its cardinality is
> n.

Splitting Theorem

Recall that a formula F is said to be negative on a tuple p of
predicate constants if members of p have no strictly positive
occurrences in F (Section 4). The importance of this class of
formulas for the theory of stable models is that they are analogous to constraints in traditional answer set programming:
SMp [F ∧ G] is equivalent to SMp [F ] ∧ G whenever G is
negative on p [Ferraris et al., 2010].

Correctness of Π, Formulation 2. Let I be an interpretation of σ that interprets vertex as the set of vertices of Γ,
and interprets edge as the set of edges of Γ. The following
conditions are equivalent:
• I is a stable model of (6) with the intensional predicate in,
• the extent of in in I is a clique in Γ, and its cardinality is
> n.

Splitting Theorem Let F , G be ﬁrst-order sentences, and
let p, q be disjoint tuples of distinct predicate constants. If
• each strongly connected component of DGpq [F ∧ G] is
a subset of p or a subset of q,
• F is negative on q, and
• G is negative on p
then
SMpq [F ∧ G] is equivalent to SMp [F ] ∧ SMq [G].

The correctness of Π in the sense of Formulation 2 is immediate from the fact that the result of applying the operator
SMin to (6) can be equivalently written as
∀x(in(x) → vertex(x))
∧ ∀xy¬(vertex(x) ∧ vertex(y) ∧ in(x) ∧ in(y)
∧ ¬edge(x, y) ∧ ¬edge(y, x) ∧ x = y)
∧ ∃n+1 x(in(x) ∧ vertex(x)).

Proof. By the splitting lemma, SMpq [F ∧ G] is equivalent
to
SMp [F ∧ G] ∧ SMq [F ∧ G].
Since G is negative on p, the ﬁrst conjunctive term can be
rewritten as
(27)
SMp [F ] ∧ G.
Similarly, the second conjunctive term can be rewritten as
SMq [G] ∧ F.
(28)
It remains to observe that the second conjunctive term of each
of the formulas (27), (28) is entailed by the ﬁrst conjunctive
term of the other.

This fact is easy to verify using the methods of [Ferraris et
al., 2010]. Formulation 1 follows from Formulation 2 by
the splitting theorem, with (6) as F , the conjunction of the
atoms X as G, in as p, and vertex,edge as q.
The advantage of Formulation 1 is that it describes what
happens when we actually use Π to ﬁnd a large clique in a
graph: we run an answer set solver on a program obtained
from Π by adding the deﬁnition of the graph as a set of facts.
The advantage of the “abstract” Formulation 2 is that it is
easier to state and to prove. The splitting theorem can be
used to establish a relationship between these two kinds of
correctness theorems.

802

8

Application: Relationship between Two
Formulations of the Event Calculus

[Janhunen et al., 2007] Tomi Janhunen, Emilia Oikarinen,
Hans Tompits, and Stefan Woltran. Modularity aspects
of disjunctive stable models. In Procedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 175–187, 2007.
[Kim et al., 2009] Tae-Won Kim, Joohyung Lee, and Ravi
Palla. Circumscriptive event calculus as answer set programming. 2009. This volume.
[Lee and Lifschitz, 2003] Joohyung Lee and Vladimir Lifschitz. Loop formulas for disjunctive logic programs. In
Proceedings of International Conference on Logic Programming (ICLP), pages 451–465, 2003.
[Lee and Meng, 2008] Joohyung Lee and Yunsong Meng.
On loop formulas with variables. In Proceedings of the International Conference on Knowledge Representation and
Reasoning (KR), pages 444–453, 2008.
[Lee et al., 2008] Joohyung Lee, Vladimir Lifschitz, and
Ravi Palla. A reductive semantics for counting and choice
in answer set programming. In Proceedings of the AAAI
Conference on Artiﬁcial Intelligence (AAAI), pages 472–
479, 2008.
[Lifschitz and Turner, 1994] Vladimir Lifschitz and Hudson
Turner. Splitting a logic program. In Pascal Van Hentenryck, editor, Proceedings of International Conference on
Logic Programming (ICLP), pages 23–37, 1994.
[Lifschitz, 2008] Vladimir Lifschitz. What is answer set programming? In Proceedings of the AAAI Conference on
Artiﬁcial Intelligence, pages 1594–1597, 2008.
[Lin and Zhao, 2004] Fangzhen Lin and Yuting Zhao. ASSAT: Computing answer sets of a logic program by SAT
solvers. Artiﬁcial Intelligence, 157:115–137, 2004.
[Marek and Truszczyński, 1999] Victor
Marek
and
Mirosław Truszczyński. Stable models and an alternative logic programming paradigm.
In The Logic
Programming Paradigm: a 25-Year Perspective, pages
375–398. Springer Verlag, 1999.
[Niemelä, 1999] Ilkka Niemelä. Logic programs with stable
model semantics as a constraint programming paradigm.
Annals of Mathematics and Artiﬁcial Intelligence, 25:241–
273, 1999.
[Oikarinen and Janhunen, 2008] Emilia Oikarinen and Tomi
Janhunen. Achieving compositionality of the stable model
semantics for Smodels programs. Theory and Practice of
Logic Programming, 5–6:717–761, 2008.
[Shanahan, 1997] Murray Shanahan. Solving the Frame
Problem: A Mathematical Investigation of the Common
Sense Law of Inertia. MIT Press, 1997.
[Simons et al., 2002] Patrik Simons, Ilkka Niemelä, and
Timo Soininen. Extending and implementing the stable
model semantics. Artiﬁcial Intelligence, 138:181–234,
2002.
[Syrjänen, 2004] Tommi Syrjänen. Cardinality constraint
programs. In Proceedings of European Conference on
Logics in Artiﬁcial Intelligence (JELIA), pages 187–199,
2004.

Theorem 1 from [Kim et al., 2009] shows that circumscriptive
event calculus [Shanahan, 1997] can be reformulated in terms
of the stable model semantics in the form
SMInitiates,Terminates,Releases [Σ] ∧ SMHappens [Δ] ∧ Ξ.
The splitting theorem stated above is used there to show that
this formula can be equivalently written using a single application of the operator SM:
SMInitiates,Terminates,Releases,Happens [Σ ∧ Δ ∧ Ξ].
A further transformation is shown in [Kim et al., 2009] to
turn the conjunction Σ ∧ Δ ∧ Ξ into a logic program that can
be processed by existing answer set solvers.

9

Conclusion

The splitting lemma and the splitting theorem proved in this
note appear to be valuable mathematical tools. The former
helped us extend program completion to some disjunctive
programs, including programs with variables, and to compare
two approaches to the semantics of aggregates in ASP. The
latter can be used to relate “abstract” ASP programs to programs containing speciﬁc facts and to turn one of the formulations of the event calculus into an executable ASP program.
We hope that future work will bring us new applications of
splitting to answer set programming and knowledge representation.

Acknowledgements
We are grateful to Michael Gelfond, Tomi Janhunen and
Emilia Oikarinen for useful discussions related to the topic
of this paper. This work was partially supported by the National Science Foundation under Grants IIS-0712113 and IIS0839821.

References
[Clark, 1978] Keith Clark. Negation as failure. In Herve
Gallaire and Jack Minker, editors, Logic and Data Bases,
pages 293–322. Plenum Press, New York, 1978.
[Ferraris et al., 2006] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. A generalization of the Lin-Zhao theorem. Annals of Mathematics and Artiﬁcial Intelligence,
47:79–101, 2006.
[Ferraris et al., 2007] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. A new perspective on stable models.
In Proceedings of International Joint Conference on Artiﬁcial Intelligence (IJCAI), pages 372–379, 2007.
[Ferraris et al., 2010] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. Stable models and circumscription.5
Artiﬁcial Intelligence, 2010. To appear.
5

http://peace.eas.asu.edu/joolee/papers/smcirc.pdf .

803

Proceedings of the Twelfth International Conference on the Principles of Knowledge Representation and Reasoning (KR 2010)

A Decidable Class of Groundable Formulas
in the General Theory of Stable Models
Michael Bartholomew and Joohyung Lee
School of Computing, Informatics and Decision System Engineering
Arizona State University, Tempe, AZ, USA
{mjbartho, joolee}@asu.edu

However, this approach does not work in the presence of
arbitrary function constants. For instance, one cannot turn
p(a) ∧ q(b) ∧ ∀x(p(x) → q(f (x)))
(3)
into
multiple
conjunctions
over
the
Herbrand universe because the universe is inﬁnite:
{a, b, f (a), f (b), f (f (a)), f (f (b)), . . . }.
On the other hand, in answer set programming, where
rules are used instead of formulas, function constants are
allowed to some degree. In order to ensure ﬁnite grounding, answer set solvers impose syntactic conditions on
the input languages, such as ω-restricted (Syrjänen 2001;
2004), λ-restricted (Gebser et al. 2007b), or ﬁnite domain
programs (Calimeri et al. 2008). Recently Lierler and
Lifschitz [2009] deﬁned the most general decidable class
of ﬁnitely groundable programs, called argument-restricted
programs, that covers the syntactic conditions above.
In this paper, we extend the notion of an argumentrestricted program to the syntax of an arbitrary formula,
whose stable models are deﬁned in (Ferraris et al. 2007;
2010). Unlike in ﬁrst-order logic, argument-restricted formulas under the stable model semantics can be grounded
even in the presence of function constants. For instance, formula (3) is argument-restricted, and the results of this paper
tell us that the Herbrand stable models of formula (3) can be
identiﬁed with the Herbrand stable models of
p(a) ∧ q(b) ∧ (p(a) → q(f (a))) ∧ (p(b) → q(f (b))). (4)
It turns out that the notion of an argument-restricted formula
can also be viewed as an extension of semi-safety, which is
deﬁned in (Lee et al. 2009; Cabalar et al. 2009) for formulas
containing no function constants other than object constants.
Based on this new notion, we show that the notion of safety
that was generalized to arbitrary formulas (Lee et al. 2008b;
Cabalar et al. 2009) can be further generalized to allow
function constants.
We apply the results to justify ﬁnite groundability of programs that contain aggregates, whose semantics are as given
in (Lee et al. 2008a) and (Faber et al. 2004). Lee et al.
[2008a] showed that the meaning of choice rules and counting aggregates in answer set programming can be understood by identifying these constructs as shorthand for ﬁrstorder formulas under the stable model semantics. For instance, the “FOL-representation” of the RASPL-1 rule
s ← {x : p(x)} 1
(5)

Abstract
We present a decidable class of ﬁrst-order formulas in the
general theory of stable models that can be instantiated even
in the presence of function constants. The notion of an
argument-restricted formula presented here is a natural generalization of both the notion of an argument-restricted program and the notion of a semi-safe sentence that have been
studied in different contexts. Based on this new notion, we
extend the notion of safety deﬁned by Cabalar, Pearce and
Valverde to arbitrary formulas that allow function constants,
and apply the result to RASPL-1 programs and programs with
arbitrary aggregates, ensuring ﬁnite groundability of those
programs in the presence of function constants. We also show
that under a certain syntactic condition, argument-restricted
formulas can be turned into argument-restricted programs.

Introduction
Grounding is a widely used approach that allows us to identify the Herbrand models1 of a ﬁrst-order signature with the
models of the corresponding propositional signature. For instance, assuming the signature {p/1, q/1, a, b}, grounding
turns
p(a) ∧ q(b) ∧ ∀x(p(x) → q(x))
(1)
into
p(a) ∧ q(b) ∧ (p(a) → q(a)) ∧ (p(b) → q(b))

(2)

by replacing the universal quantiﬁcation with multiple conjunctions in which x ranges over the Herbrand universe
{a, b}. The Herbrand models of (1) are the same as the
Herbrand models of (2). Containing no variables, formula (2) can also be viewed as a propositional formula of
the signature {p(a), p(b), q(a), q(b)} (i.e., “p(a)” is an atom
in propositional logic). The (propositional) models of the
propositional signature can be identiﬁed with the Herbrand
models of the ﬁrst-order signature.
c 2010, Association for the Advancement of Artiﬁcial
Copyright 
Intelligence (www.aaai.org). All rights reserved.
1
Recall that an Herbrand interpretation of a signature σ (containing at least one object constant) is an interpretation of σ such
that its universe is the set of all ground terms of σ, and every ground
term represents itself. An Herbrand interpretation can be identiﬁed
with the set of ground atoms (not containing equality) to which it
assigns the value true.

477

Preliminaries

is the formula
¬∃xy(p(x) ∧ p(y) ∧ x = y) → s.

A signature consists of function constants and predicate
constants. Function constants of arity 0 are called object
constants.
We distinguish between atoms and atomic formulas as follows: an atom of a signature σ is an n-ary predicate constant
followed by a list of n terms; atomic formulas of σ are atoms
of σ, equalities between terms of σ, and the 0-place connective ⊥.

(6)

The counterpart of (5) in the language deﬁned in (Faber et
al. 2004) is
s ← #count{x : p(x)} ≤ 1.

(7)

In that language, the meaning of #count{x : p(x)} ≤ 1 is
understood by instantiating the expression {x : p(x)} over
the Herbrand universe, and then applying an interpretation
on the ground set. Obviously this process results in an inﬁnite ground set once the program contains function constants
of positive arity as in the following:
p(f (x)) ← q(x)
q(x) ← p(x), r(x)
p(a)
r(a)
r(f (a))
s ← #count{x : p(x)} ≤ 1

Review: Argument-Restricted Programs
A program considered in (Lierler and Lifschitz 2009) is a
ﬁnite list of rules of the form
A1 ; . . . ; Ak ← Ak+1 , . . . , Am , not Am+1 , . . . , not An ,
(9)
(0 ≤ k ≤ m ≤ n), where each Ai is an atom, possibly
containing function constants of positive arity. A program is
called safe if every variable occurring in a rule of Π occurs
also in the positive body of that rule.
We follow the terminology and the notations used
in (Lierler and Lifschitz 2009). Given an atom p(t1 , . . . , tn ),
expression p(t1 , . . . , tn )0 represents its predicate constant p,
and p(t1 , . . . , tn )i , where 1 ≤ i ≤ n, represents its argument term ti . As in (Calimeri et al. 2008), an argument
is an expression of the form p[i], where i is one of the argument positions 1, . . . , n. The depth of a variable x in a term t
that contains x, denoted by d(x, t), is deﬁned recursively as
follows:
d(x,
 t) =
0,
if t is x;
1 + max({d(x, ti ) | ti contains x}), if t is f (t1 , . . . , tn ).

(8)

This program cannot be handled by DLV, which implements a large subset of the language deﬁned
in (Faber et al. 2004). On the other hand, the recent system DLV- COMPLEX, an extension of DLV
with function constants, returns one answer set
{p(a), p(f (a)), p(f (f (a))), q(a), q(f (a)), r(a), r(f (a))}
for the program above. While the system is based on
the theory from (Calimeri et al. 2008) that ensures ﬁnite
groundability of an answer set program, that paper does not
consider aggregates. To the best of our knowledge, no justiﬁcation has been provided regarding ﬁnite groundability of
programs such as (8).
We also show that under a certain syntactic condition,
argument-restricted formulas can be turned into argumentrestricted programs. This may be of interest in applications
of system F 2 LP (Lee and Palla 2009), which computes answer sets of arbitrary formulas under certain conditions, by
reducing formulas to logic programs.
The rest of the paper is organized as follows. In the next
section, we review the deﬁnitions of argument-restricted
programs, answer sets of ﬁrst-order formulas, and semisafety and safety in the absence of function constants. In
Section “Argument-Restricted Formulas,” we present the
deﬁnition of argument-restricted formulas, and show that
such formulas have the small predicate property. We extend the notion of safety to allow function constants by
taking into account argument-restrictedness; we show that
safe sentences can be grounded w.r.t. a ﬁnite domain,
and their answer sets are not affected by enlarging the domain. In Section “Deciding Argument-Restricted Formulas,” we show that the class of argument-restricted formulas is decidable. In the next three sections, we apply
the concept of argument-restricted formulas and safety to
RASPL-1 programs and FLP programs, and extend the notion of argument-restrictedness and safety to allow extensional predicates. In the last two sections, we show that under a certain condition, argument-restricted formulas can be
turned into argument-restricted programs and how the similar results hold for λ-restricted formulas, an extension of
λ-restricted programs.

An argument ranking for Π is a function α from arguments to integers such that, for every rule R of Π, every
atom A occurring in the head of R, and every variable x
occurring in an argument term Ai , the positive body of R
contains an atom B such that x occurs in an argument term
B j satisfying
α(A0 [i]) − d(x, Ai ) ≥ α(B 0 [j]) − d(x, B j ).

(10)

A program is called argument-restricted if it is safe and
has an argument ranking.

Review: Answer Sets of First-Order Formulas
This review follows (Ferraris et al. 2010), a journal version
of (Ferraris et al. 2007), which is based on the stable model
operator with the intensional predicates p, denoted by SMp .
Let p be a list of distinct predicate constants p1 , . . . , pn , and
let u be a list of distinct predicate variables u1 , . . . , un of
the same length as p. By u = p we denote the conjunction
of the formulas ∀x(ui (x) ↔ pi (x)), where x is a list of
distinct object variables of the same arity as the length of pi ,
for all i = 1, . . . n. By u ≤ p we denote the conjunction
of the formulas ∀x(ui (x) → pi (x)) for all i = 1, . . . n, and
u < p stands for (u ≤ p) ∧ ¬(u = p).
For any ﬁrst-order formula F , SMp [F ] stands for the
second-order formula
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),

478

(11)

where F ∗ (u) is deﬁned recursively:2

the antecedent of any implication. For example, in (6), the
occurrences of p(x) and p(y) are positive, but not strictly
positive; the occurrence of s is strictly positive.
Consider a sentence F in prenex form:

∗

• pi (t) = ui (t) for any tuple t of terms;
• F ∗ = F for any atomic formula F that does not contain
members of p;3

Q1 x1 · · · Qn xn M

• (F ∧ G)∗ = F ∗ ∧ G∗ ;

(12)

(each Qi is ∀ or ∃; x1 , . . . , xn are distinct variables; the matrix M is quantiﬁer-free). It is shown that every ﬁrst-order
formula under the stable model semantics can be turned into
prenex form (Lee and Palla 2007, Theorem 2). We say that
F is semi-safe if every strictly positive occurrence of every variable xi belongs to a subformula G → H where xi
belongs to RV(G). If a sentence has no strictly positive occurrence of a variable, it is clearly semi-safe. The FOLrepresentation of (9) is semi-safe if every variable occurring
in the head of a rule occurs also in the positive body of that
rule. Thus the notion of semi-safety, applied to a logic program, is weaker than the notion of safety.
Proposition 1 below shows that all stable models of a
semi-safe sentence have the small predicate property: the
relation represented by any of its predicate constants pi can
hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F . To
make this idea precise, we will use the following notation:
For any ﬁnite set c of object constants, inc (x) stands for the
formula

x = c.

• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (∀xF )∗ = ∀xF ∗ ;
• (∃xF )∗ = ∃xF ∗ .
For any sentence F , a p-stable model of F is an interpretation of the underlying signature that satisﬁes SMp [F ]. In
this paper we will often omit the subscript p when it is the
list of all predicate constants occurring in F .
The answer sets are deﬁned as follows. By σ(F ) we denote the signature consisting of object, function and predicate constants occurring in F . For any sentence F that
contains at least one object constant, we deﬁne the answer
sets of F as the Herbrand interpretations of σ(F ) that satisfy
SM[F ]. Ferraris et al. [2010] shows that this deﬁnition of
an answer set coincides with the usual deﬁnition of an answer set, which is given in terms of grounding and reduct
when F can be identiﬁed with a logic program.

Review: Semi-Safety and Safety in the Absence of
Function Symbols

c∈c

The small predicate property can be expressed by the conjunction of the sentences



inc (vi )
∀v1 , . . . , vn p(v1 , . . . , vn ) →

The concept of safety was extended to ﬁrst-order formulas
in (Lee et al. 2008a) and was further generalized in (Cabalar
et al. 2009), but the work there does not consider function
constants of positive arity. This section reviews some definitions from (Cabalar et al. 2009) in a slightly modiﬁed
form.4
We assume that the signature contains no function constants of positive arity. To every quantiﬁer-free formula F ,
we assign a set RV(F ) of its restricted variables as follows:

i=1,...,n

for all predicate constants p occurring in F ,
We denote
where v1 , . . . , vn are distinct variables.
this sentence by SPPc . By c(F ) we denote the set of all
object constants occurring in F .

• For an atomic formula F ,

Proposition 1 (Lee et al. 2009) For any semi-safe sentence F , formula SM[F ] entails SPPc(F ) .

– if F is an equality between two variables, then
RV(F ) = ∅;
– otherwise, RV(F ) is the set of all variables occurring
in F ;

For instance, in application to the prenex form of (1),
which is semi-safe, this proposition asserts that SM[(1)] entails

• RV(⊥) = ∅;

∀x(p(x) → x = a ∨ x = b) ∧ ∀x(q(x) → x = a ∨ x = b).

• RV(F ∧ G) = RV(F ) ∪ RV(G);

Cabalar et al. [2009] generalized the deﬁnition of safety
from (Lee et al. 2008b) as follows. They consider the following transformations:
• ¬⊥ → , ¬ → ⊥,
• ⊥∧F → ⊥, F ∧⊥ → ⊥, ∧F → F , F ∧ → F ,
• ⊥∨F → F , F ∨⊥ → F , ∨F → , F ∨ → ,
• ⊥ → F → , F →  → ,  → F → F .
We say that a variable x is positively weakly restricted in
a formula G if the formula obtained from G by
• ﬁrst replacing every atomic formula A in it such that x
belongs to RV(A) by ⊥,

• RV(F ∨ G) = RV(F ) ∩ RV(G);
• RV(F → G) = ∅.
Recall that the occurrence of one formula in another is
called positive if the number of implications containing that
occurrence in the antecedent is even, and negative otherwise.
We say that an occurrence of a subformula or a variable in
a formula F is strictly positive if that occurrence is not in
We treat ¬F as shorthand for F → ⊥.
This includes the case when F is ⊥.
4
This reformulation is described in the unpublished draft (Lee
et al. 2009).
2
3

479

argument term Ai , the occurrence of A is in a subformula
G → H such that

• and then applying the transformations above
is . Similarly, we say that x is negatively weakly restricted
in G if the formula obtained from G by the same procedure
is ⊥.
A semi-safe sentence (12) is called safe if, for every occurrence of a variable xi in (12),

α(A0 [i]) − d(x, Ai ) ≥ lbα (x, G).

An argument ranking for a sentence in prenex form is deﬁned as an argument ranking for its matrix. We say that the
sentence (12) is argument-restricted if it has an argument
ranking.
For example, the prenex form of formula (3) is argumentrestricted. We can take α(p[1]) = 0, α(q[1]) = 1. Formula

(a) if Qi is ∀, then the occurrence belongs to
– a positive subformula of (12) in which xi is positively
weakly restricted, or
– a negative subformula of (12) in which xi is negatively
weakly restricted;

∀x(p(a) ∧ (p(f (x)) ∨ p(x) → p(f (x))))
is not argument-restricted because for any function α,

(b) if Qi is ∃, then the occurrence belongs to

α(p[1]) − d(x, f (x)) = α(p[1]) − 1
< lbα (x, p(f (x)) ∨ p(x)) = α(p[1]).

– a negative subformula of (12) in which xi is positively
weakly restricted, or
– a positive subformula of (12) in which xi is negatively
weakly restricted.

On the other hand,
∀x(p(a, f (a)) ∧ (p(x, f (x)) ∨ p(f (x), x) → p(x, f (x))))
(15)
is argument-restricted. Take α(p[1]) = α(p[2]) = 1. Formula
∀xy(p(x) ∧ y = f (x) → p(y))
(16)

This deﬁnition generalizes the deﬁnition of safety for
logic programs. The prenex form of (6)
∃xy(¬(p(x) ∧ p(y) ∧ x = y) → s)

(14)

(13)

is safe because the antecedent of the implication is a negative subformula in which both x and y are positively weakly
restricted in it. (Or p(x) ∧ p(y) ∧ x = y can be taken as a
positive subformula in which x and y are negatively weakly
restricted.) Formula ∃x∀y((p(x) → q(y)) → r) is safe because, for x, p(x) can be taken as a positive subformula, and,
for y, q(y) can be taken as a negative subformula. Formula
∃x(¬p(x) → q) is safe, while ∀x(¬p(x) → q) is semi-safe,
but not safe.

is not argument-restricted, while
∀xy(p(x) ∧ q(y, f (x)) → p(y))

(17)

is argument-restricted. Take α(p[1]) = α(q[1]) = 0,
α(q[2]) = 1.
The small predicate property can be extended to
argument-restricted sentences as follows. For any ﬁnite set
f of function constants (including object constants) and any
integer m, by gtm
f we denote the set of ground terms of
height up to m which can be constructed from function constants in f . By inm
f (x) we denote the formula

x = c.

Argument-Restricted Formulas
We extend the notion of argument-restricted programs to arbitrary formulas as follows. We visualize any term t as a
rooted tree, with object constants and variables as leaves,
and function constants of positive arity as internal nodes.
The height h(t) of a term t is the height of the corresponding
tree. Let F be a quantiﬁer-free formula (possibly containing
function constants of positive arity) and let α be a function
from arguments to integers. Function lbα (x, F ) maps a variable and a formula to an integer or ω, deﬁned as follows:

c∈gtm
f

For any formula F and any mapping α from arguments to
nonnegative integers, by SPPα
f we denote the conjunction of
the sentences



α(p[i])
inf
(vi )
∀v1 . . . vn p(v1 , . . . , vn ) →
i=1,...,n

• lbα (x, p(t1 , . . . , tn )) =
min({α(p[i]) − d(x, ti ) | ti contains x} ∪ {ω});

for all predicate constants p occurring in F . Clearly this is a
proper generalization of SPPc in the previous section.
Intuitively, the small predicate property tells that the extent of a predicate is named by a ﬁnite set of ground terms
that can be constructed from function constants in f whose
maximum height is given by α. We will show that argumentrestrictedness is a syntactic condition that ensures the small
predicate property.
We consider the following axiom set the relaxed unique
name assumption (RUNA) for signature σ.

• When F is t1 = t2 , if t1 is x and t2 is a ground term, then
lbα (x, F ) is h(t2 ); Similar if t2 is x and t1 is a ground
term; otherwise lbα (x, F ) is ω;
• lbα (x, ⊥) = ω;
• lbα (x, G ∧ H) = min({lbα (x, G), lbα (x, H)});
• lbα (x, G ∨ H) = max({lbα (x, G), lbα (x, H)});
• lbα (x, G → H) = ω.

∀x1 . . . xn y1 . . . yn (f (x1 , . . . , xn ) = f (y1 , . . . , yn )
→ (x1 = y1 ∧ . . . ∧ xn = yn ))
(18)

An argument ranking for F is a function α from arguments to integers such that, for every atom A occurring
strictly positively in F and every variable x occurring in an

480

for all function constants f of arity > 0;

However, the small predicate property alone is not enough
to ensure the domain independence of answer sets.

∀x1 . . . xm y1 . . . yn (f (x1 , . . . , xm ) = g(y1 , . . . , yn ))
(19)
for all pairs of distinct function constants f , g except for the
pair in which both f and g have arity 0. In other words,
the assumption is slightly weaker than the standard unique
name assumption in that object constants are not assumed to
be distinct from each other.
We say that an argument ranking α is strict if
α(A0 [i]) ≥ h(Ai ) for every strictly positive occurrence of
an atom A and any of its argument position i. The following
theorem tells that any argument-restricted sentence has the
small predicate property. By f (F ) we denote the set of all
function constants occurring in F .

∀x(¬q(x) → p) ∧ q(a)
is semi-safe, and thus argument-restricted. The answer set
is {q(a)} if the Herbrand universe is {a}; the answer set is
{p, q(a)} if the Herbrand universe is any proper superset of
{a} (e.g., {a, b}). It is not difﬁcult to see that, due to the
small predicate property, any semi-safe sentence has at most
two kinds of answer sets depending on the underlying signature, be it σ(F ) or any of its strict superset. In the absence
of function constants of positive arity, it is known that, if
we further require the sentence to be safe (Lee et al. 2008a;
Cabalar et al. 2009), then such distinction between the underlying signature disappears: answer sets are not affected
by the underlying signature.
The deﬁnition of safety in the previous section can be
applied in the presence of function constants. The only
changes required are
• in the deﬁnitions of positively (negatively, resp.) weakly
restricted variables, to replace “x belongs to RV(A)” by
“lbα (x, A) = ω”.
• replace “semi-safe sentence” with “argument-restricted
sentence.”
For any safe sentence F (in prenex form; possibly containing function constants of positive arity), and any strict
argument ranking α for F , the result of its grounding is
the ground formula Groundα
f [F ] deﬁned as follows. If F
is quantiﬁer-free, then Groundα
f [F ] = F . Otherwise

Groundα
Groundα
f [∀xF (x)] =
f [F (c)],

Theorem 1 For any argument-restricted sentence F and
any strict argument ranking for F , under the relaxed unique
name assumption, formula SM[F ] entails SPPfα(F ) .
For instance, under the relaxed unique name assumption
SM[(3)] entails
∀x(p(x) → (x = a ∨ x = b)),
and
∀x(q(x) → (x = a ∨ x = b ∨ x = f (a) ∨ x = f (b)).
with α(p[1]) = 0, α(q[1]) = 1.
Theorem 1 becomes incorrect if we drop the relaxed
unique name assumption. For example, take
F = p(0) ∧ ∀x(p(f (x)) → p(x)),
which is argument-restricted (take α(p[1]) = 1). However,
consider a model I of SM[F ] such that the universe is the set
of integers, f I (m) = m + 1, pI = {0, −1, −2, . . . }. The
model I satisﬁes SM[F ] but not SPPα
f .
Note that the notion of an argument-restricted program
in (Lierler and Lifschitz 2009) requires that the program
be safe, while the notion of an argument-restricted formula
above does not.

c∈gtm
f

Groundα
f [∃xF (x)] =



c∈gtm
f

Groundα
f [F (c)],

where m is
max({lbα (x, A) | A is an atomic formula occurring in F (x)
such that lbα (x, A) = ω} ∪ {0}).

Proposition 2 Let Π be a program and F a prenex form of
the FOL representation of Π. Π is argument-restricted in
the sense of (Lierler and Lifschitz 2009) iff F is argumentrestricted (in our sense) and safe.

For example, for formula (3) with α(p[1]) = 0,
α(q[1]) = 1, Groundα
{a,b,f } [(3)] is (4). For formula (15)
with α(p[1]) = α(p[2]) = 1, formula Groundα
{a,f } [(15)]
is

The notion of an argument-restricted formula is also an
extension of semi-safety with function constants.

p(a, f (a)) ∧ (p(a, f (a)) ∨ p(f (a), a) → p(a, f (a))).
In the rest of the section, we present generalizations of the
theorems from (Lee et al. 2009). We assume that F is a safe
sentence, α is a strict argument for the matrix of F and f
is a ﬁnite set of function constants that contains at least one
object constant and f (F ).
As in (Lifschitz et al. 2007), by INT= we denote intuitionistic predicate logic with equality, and DE stands for the
decidable equality axiom.

Proposition 3 For any sentence F in prenex form that contains no function constants of positive arity, F is semi-safe
according to (Lee et al. 2009) iff it is argument-restricted.
The proof of the proposition uses the following lemma
that describes the relationship between the notions RV and
lbα .
Lemma 1 For any quantiﬁer-free formula F without function constant of positive arity and any mapping α from arguments to integers,

x = y ∨ x = y

(20)

The provability of a sentence F ↔ G in this system implies
that SM[F ] is equivalent to SM[G] (Lifschitz et al. 2007).

x ∈ RV(F ) iff lbα (x, F ) = ω.

481

• Ωi+1 (0) = Ωi (0) (αmin is found), or

Proposition 4

Groundα
f [F ] ↔ F
α
is derivable from SPPf in INT= + DE + RUNA.
Using Proposition 4 we can prove that the variable-free
formula obtained by grounding a safe sentence F has the
same stable models as F .
Theorem 2 Under the relaxed unique name assumption,
SM[Groundα
f [F ]] is equivalent to SM[F ].
In general, the second-order deﬁnition of a stable model
cannot be expressed in ﬁrst-order logic. The following theorem shows, however, that in the case of a safe sentence, stable models can be characterized by a very simple ﬁrst-order
formula, almost variable-free:
Theorem 3 There exists a variable-free formula G such
that SM[F ] is equivalent to G ∧ SPPfα(F ) under the relaxed
unique name assumption.
The safety of a sentence does indeed imply that its meaning does not depend on the presence of irrelevant object constants in the signature:
Theorem 4 If F contains at least one object constant, and
σ is a signature obtained from σ(F ) by adding function constants, then an Herbrand interpretation of σ satisﬁes SM[F ]
iff it is an answer set of Groundα
f (F ) [F ].

• one of the values of Ωi (0) exceeds M (F is not argumentrestricted).

Applying to RASPL-1 programs
(Lee et al. 2008a) deﬁnes the semantics of a program with
choice and counting in terms of reduction to the general theory of stable models. That paper assumes that the signature
does not contain function constants of positive arity, but here
we remove that restriction.
A cardinality expression is an expression of the form
b {x : F (x)}

where b is a positive integer (“the bound”), x is a list of variables (possibly empty), and F (x) is a conjunction of literals
(possibly containing variables other than x). This expression
reads: there are at least b values of x such that F (x).
A RASPL-1 rule is an expression of the form
A1 ; . . . ; Al ← E1 , . . . , Em , not Em+1 , . . . , not En (22)

Deciding Argument-Restricted Formulas
The algorithm described in (Lierler and Lifschitz 2009) can
be extended to argument-restricted formulas in a straightforward way. Let F be a formula (12). Similar to (Lierler
and Lifschitz 2009), we deﬁne the operator Ω on the set U
of functions from arguments to nonnegative integers by the
formula
Ω(α)(p[i]) = max({min({d(x, Ai ) + lbα (x, G) | G → H}
∪{ω}) | A, x} ∪ {0})
where
• A and x range over atoms and variables such that A occurs
strictly positively in F , A0 = p, and x occurs in Ai ;
• given such A and x, formula G → H ranges over subformulas of F such that the occurrence of A is in G → H.
It is easy to check that α ∈ U is an argument ranking for the
matrix of F iff α ≥ Ω(α).
The operator Ω is monotone, so that the same argument
in (Lierler and Lifschitz 2009) applies to this extension. If
F is argument-restricted, then the set of nonnegative argument rankings has the least element αmin = Ωi (0) for the
smallest i such that Ωi+1 (0) = Ωi (0).5 On the other hand,
for any argument-restricted formula F , all values of αmin do
not exceed the product M of two numbers: the total number
of arguments and the largest of the numbers d(x, t) for the
terms t occurring strictly positively in F and for the variables x occurring in t.
We can use the polynomial time algorithm given in (Lierler and Lifschitz 2009) with the extended deﬁnition of Ω to
determine whether F is argument-restricted by iterating on
0 until
5

(21)

(l ≥ 0; n ≥ m ≥ 0), where each Ai is an atom, and each Ei
is a cardinality expression. A RASPL-1 program is a ﬁnite
list of rules.
The semantics of a RASPL-1 program is deﬁned by turning it into a ﬁrst-order sentence (FOL-representation) and
applying the deﬁnition of an answer set for a ﬁrst-order
sentence. The FOL-representation of cardinality expression
(21) is the formula
⎡
⎤


F (xi ) ∧
¬(xi = xj )⎦ (23)
∃x1 · · · xb ⎣
1≤i≤b

1≤i<j≤b

where x1 , . . . xb are lists of new variables of the same length
as x. An expression 1{: A}, where A is an atom, can be
identiﬁed with A.
The FOL-representation of a RASPL-1 rule
Head ← Body is the universal closure of the implication Body → Head with each cardinality expression in
Body replaced by its FOL-representation. The FOLrepresentation of a RASPL-1 program is the conjunction of
the FOL-representations of its rules.
For any RASPL-1 program Π containing at least one object constant, the answer sets of Π are deﬁned as the answer
sets of the FOL-representation of Π, as deﬁned earlier.
A variable v is free in a rule (22) if
• v occurs in the head A1 ; . . . ; Al of the rule, or
• the body E1 , . . . , not En of the rule contains a cardinality
expression b{x : F (x)} such that v occurs in F and does
not belong to x.
In the following we assume that every free variable is distinct from variables x occurring in (21) by possibly renaming the variables.
An argument ranking for Π is a function α from arguments to integers such that, for every rule R of Π, every
atom A occurring in the head of R, and every variable v

0 denotes a function that maps every argument positions to 0.

482

occurring in an argument term Ai , the positive body of R
contains a cardinality expression b{x : F (x)} such that

• each FLP-aggregate expression in its body is allowed, and
• for each of its free variables v, there is an atom Ei (i =
1, . . . , m) that contains v.

α(A0 [i]) − d(v, Ai ) ≥ lbα (v, F (x)).
A program is called argument-restricted if it has an argument ranking.
The safety condition for RASPL-1 programs deﬁned
in (Lee et al. 2008a) can be extended to allow function
constants as follows. Given an argument ranking α, we
say that a cardinality expression b{x : F (x)} is allowed
if, for every member x of x, lbα (x, F ) = ω. For instance,
2{x : p(f (x), y)} is allowed; 2{x : not p(f (x), y)} is not
allowed.
A RASPL-1 program is safe if it has an argument ranking α and, for each rule (22) in it,
• each cardinality expression in its body is allowed, and
• for each of its free variables v, there is a cardinality
expression b{x : F (x)} among E1 , . . . , Em such that
lbα (v, F ) = ω.
The following proposition follows from Theorem 4 since
RASPL-1 programs are shorthand for ﬁrst-order formulas.
Proposition 5 Let Π be a safe RASPL-1 program (allowing
function constants of positive arity) containing at least one
object constant, let F be its FOL-representation, and let α
be a strict argument ranking for F . For any signature σ
obtained by adding any function constants to σ(F ), an Herbrand interpretation of σ satisﬁes SM[F ] iff it is an answer
set of Groundα
f (F ) [F ].
For example, program (8) (assuming the last rule is written in the syntax of RASPL-1) is safe, and can be equivalently rewritten as a ground formula under the stable model
semantics.

Again we assume that every free variable is distinct from
variables x in (24) by possibly renaming the variables. For
any argument-restricted FLP-program Π, any strict argument ranking α for Π and any ﬁnite set f of function constants, ground FLP program Groundα
f [Π] is deﬁned as follows:
• replace every free occurrence of a variable x with a
ground term from gtm
f where m is
max({lbα (x, A) | A is an atomic formula occurring in Π
such that lbα (x, A) = ω} ∪ {0});
• replace every occurrence of OP {x : F (x)}  b in the
resulting program with OPS  b where S is the set of
all ground instantiations of x : F (x) w.r.t. gtm
f where m
is
max({lbα (x, A) | x is in x and A is an atomic formula
occurring in F (x) such that lbα (x, A) = ω} ∪ {0}).
In the following proposition, the deﬁnition of an answer
set refers to the one in (Faber et al. 2004). By σ(Π) we
denote the signature consisting of object, function and predicate constants occurring in Π. By f (Π) we denote the set of
all function constants occurring in Π.
Proposition 6 Let Π be a safe FLP program containing at
least one object constant, let α be a strict argument ranking for Π. For any signature σ obtained by adding function constants to σ(Π), a ground set of atoms of σ is an answer set of Π iff it is an answer set of ground FLP program
Groundα
f (Π) [Π].

Applying to FLP-Aggregates
An FLP-aggregate expression is of the form
OP {x

: F (x)}  b

(24)

For example, program (8) is safe, and grounding the last
rule of (8) yields

where
• OP is a symbol for an aggregate function, such as SUM,
COUNT ;
• x is a nonempty list of distinct object variables;
• F (x) is a quantiﬁer-free formula;
•  is a symbol for a binary relation over integers, such as
≤, ≥, <, >, =, =;
• b is an integer constant.
An FLP-rule is an expression of the form

s ← #count{a : p(a), f (a) : p(f (a)), f (f (a)) : p(f (f (a))),
a : q(a), f (a) : q(f (a)), a : r(a), f (a) : r(f (a))} ≤ 1
with α(p[1]) = 2, α(q[1]) = 1, α(r[1]) = 1.
The following is another safe program in the syntax of the
DLV- COMPLEX language.
string(cons(a, cons(b, cons(a, cons(c, nil))))).
letter(a). letter(b). letter(c). letter(d).
tail(X) :- string(X).
tail(Y) :- tail(cons(X,Y)), letter(X).
containsTwo(X):- #count{Y: tail(cons(X,Y))}>=2,
letter(X).

A1 ; . . . ; Al ← E1 , . . . , Em , not Em+1 , . . . , not En (25)
(l ≥ 0; n ≥ m ≥ 0), where each Ai is an atom and each
Ei is an atom or an FLP-aggregate expression. An FLPprogram is a ﬁnite list of rules.
The deﬁnition of an argument ranking for an FLP program is the same as that for a program whose rules have the
form (9). The deﬁnitions of “allowed expressions” and “free
variables” for FLP programs are deﬁned similar to those for
RASPL-1 programs.
According to (Faber et al. 2004), a rule (25) is safe if

The program has only one answer set. For the string
“[a,b,a,c]”, tail(X) belongs to the answer set if X is
the tail of the string. containsTwo(X) belongs to
the answer set if letter X occurs at least twice in the
string. The answer set returned by DLV- COMPLEX contains
containsTwo(a).

483

Allowing Extensional Predicates

A reduction that preserves argument-restrictedness is possible under a certain syntactic condition. We call a formula
singular if every subformula G → H that occurs in the antecedent of another implication is contained in a formula that
has no strictly positive occurrence of predicate constants.
Formula (27) is not singular because of p(x) → q(x).

We deﬁned the notion of an argument-restricted formula
only in the case when the intensional predicates p in
SMp [F ] are all the predicates occurring in F . The notion
can be extended to the general case, in which intensional
predicates p are any subset of the predicates in the signature, by only modifying the ﬁrst clause of the deﬁnition of
lbα (x, F ) as

Proposition 7 Every
singular
argument-restricted
quantiﬁer-free formula is strongly equivalent to an
argument-restricted program.

lbα (x, p(t1 , . . . , tn )) =
⎧
⎨min({α(p[i]) − d(x, ti ) | ti contains x} ∪ {ω})
if p is intensional;
⎩
ω
otherwise.

It remains an open question if the restriction that formula
be singular can be removed from the statement.

Extending λ-restricted Programs to Formulas

For example, similar to (16), formula (17) becomes nonargument-restricted if q is regarded as extensional.
The deﬁnition of safety in the general case remains the
same as in the case when all predicate constants are regarded
intensional.
Theorems 1–4 can be extended to allow extensional predicates by allowing p to be any subset of the predicate constants in the signature, and by replacing SM[F ] in the statements with SMp [F ].

Currently, there is no implementation of argument-restricted
programs. On the other hand, the input language of GRINGO
is assumed to be λ-restricted, which is a stronger notion
than argument-restrictedness. Similar to the generalization
of argument-restricted programs to argument-restricted formulas, we generalize the notion of λ-restricted programs to
λ-restricted formulas, and show that the latter can be reduced to the former under some condition. This justiﬁes
the use of F 2 LP for computing answer sets of λ-restricted
formulas.
According to (Gebser et al. 2007b), a λ-ranking for a
program Π is a function α from predicate constants of σ(Π)
to integers such that for every rule r of Π and every variable
x occurring in r, there is an atom B in the positive body of
r such that B contains x and

Reducing Argument-Restricted Formulas to
Argument-Restricted Programs
System F 2 LP (Lee and Palla 2009) turns a ﬁrst-order formula
into a program whose rules have the form
A1 ; . . . ; Ak ← Ak+1 , . . . , Am , not Am+1 , . . . , not An ,
not not An+1 , . . . , not not Ap
(26)
(0 ≤ k ≤ m ≤ n ≤ p), where each Ai is an atomic
formula. The deﬁnition of an argument-restricted program from (Lierler and Lifschitz 2009) can be extended
to this syntax as follows: A program whose rules have
the form (26) is called argument-restricted if its FOLrepresentation is argument-restricted.
Is it possible to turn argument-restricted formulas into
such argument-restricted programs? This is an important
question in applications of system F 2 LP. A part of the
transformation that is implemented in F 2 LP follows the one
from (Cabalar et al. 2005) in order to turn a quantiﬁer-free
formula into a set of rules. However, this transformation
does not preserve argument-restrictedness: among the transformation rules deﬁned in (Cabalar et al. 2005), only one
rule (L5) does not preserve it. For instance, given
∀x((p(x) → r(f (x)))
∧((p(x) → q(x)) ∧ r(x) → s(x))),
F 2 LP

α(A0 ) > α(B 0 ).
We say that a program is λ-restricted if the program has a
λ-ranking.
This concept can be extended to formulas similar to the
deﬁnition of argument-restricted formulas as follows. Let
α be a function from predicate constants of σ(Π) to integers. For a quantiﬁer-free formula F , function lbα (x, F ) is
deﬁned recursively:
• lbα (x, p(t1 , . . . , tn )) = α(p);
• lbα (x, t1 = t2 ) = ω;
• lbα (x, ⊥) = ω;
• lbα (x, G ∧ H) = min({lbα (x, G), lbα (x, H)});
• lbα (x, G ∨ H) = max({lbα (x, G), lbα (x, H)});
• lbα (x, G → H) = ω.
α is called a λ ranking for F if every strictly positive occurrence of every variable x in an atom A is contained in a
subformula G → H such that

(27)

α(A0 ) > lbα (x, G).

applies the rule (L5) to turn it into the following pro-

gram
r(f (x))
s(x)
s(x)
p(x) ; s(x)

←
←
←
←

We say that prenex formula (12) is λ-restricted if G has a
λ-ranking. This deﬁnition is similar to argument-restricted
formulas, but does not take into account the depth of a variable in a predicate. It is easy to check that every λ-restricted
formula is argument-restricted. Also this deﬁnition reduces
to the deﬁnition from (Gebser et al. 2007b) when it is applied to logic programs.

p(x)
not p(x), r(x)
q(x), r(x)
r(x), not not q(x),

which is ﬁnitely groundable, but not argument-restricted.

484

Proposition 8 Let Π be a program and F a prenex form of
the FOL representation of Π. Π is λ-restricted in the sense
of (Gebser et al. 2007b) iff F is λ-restricted (in our sense).

Wolfgang Faber, Nicola Leone, and Gerald Pfeifer. Recursive aggregates in disjunctive logic programs: Semantics
and complexity. In Proceedings of European Conference
on Logics in Artiﬁcial Intelligence (JELIA), 2004.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. A
new perspective on stable models. In Proceedings of International Joint Conference on Artiﬁcial Intelligence (IJCAI),
pages 372–379, 2007.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. Stable models and circumscription. Artiﬁcial Intelligence,
2010. To appear.
Martin Gebser, Torsten Schaub, and Sven Thiele. Gringo: A
new grounder for answer set programming. In Chitta Baral,
Gerhard Brewka, and John S. Schlipf, editors, LPNMR, volume 4483 of Lecture Notes in Computer Science, pages 266–
271. Springer, 2007.
Joohyung Lee and Ravi Palla. Yet another proof of the strong
equivalence between propositional theories and logic programs. In Working Notes of the Workshop on Correspondence and Equivalence for Nonmonotonic Theories, 2007.
Joohyung Lee and Ravi Palla. System F 2 LP – computing
answer sets of ﬁrst-order formulas. In Procedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 515–521, 2009.
Joohyung Lee, Vladimir Lifschitz, and Ravi Palla. A reductive semantics for counting and choice in answer set programming. In Proceedings of the AAAI Conference on Artiﬁcial Intelligence (AAAI), pages 472–479, 2008.
Joohyung Lee, Vladimir Lifschitz, and Ravi Palla. Safe formulas in the general theory of stable models (preliminary report). In Proceedings of International Conference on Logic
Programming (ICLP), pages 672–676, 2008.
Joohyung Lee, Vladimir Lifschitz, and Ravi Palla. Safe formulas in the general theory of stable models.6 Unpublished
Draft, 2009.
Yuliya Lierler and Vladimir Lifschitz. One more decidable
class of ﬁnitely ground programs. In Patricia M. Hill and
David Scott Warren, editors, ICLP, volume 5649 of Lecture
Notes in Computer Science, pages 489–493. Springer, 2009.
Vladimir Lifschitz, David Pearce, and Agustin Valverde. A
characterization of strong equivalence for logic programs
with variables. In Procedings of International Conference
on Logic Programming and Nonmonotonic Reasoning (LPNMR), 2007.
Tommi Syrjänen. Omega-restricted logic programs. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning, pages 267–279, 2001.
Tommi Syrjänen. Cardinality constraint programs. In Proceedings of European Conference on Logics in Artiﬁcial Intelligence (JELIA), pages 187–199, 2004.

It is clear from the deﬁnitions that every λ-restricted formula is argument-restricted. Similar to Proposition 7, the
following holds.
Proposition 9 Every singular λ-restricted quantiﬁer-free
formula is strongly equivalent to a λ-restricted program.

Conclusion
We have presented a decidable class of the general language
of stable models that can be instantiated even in the presence of function constants. The notion naturally extends
the notion of an argument-restricted program and the notion of a semi-safe sentence that have been studied in different contexts. We view argument-restrictedness, as well
as λ-restrictedness and other similar deﬁnitions as syntactic conditions to ensure the small predicate property, which
says that the extent of a predicate can be represented by a ﬁnite set of ground terms. Under the small predicate property,
safety condition can be imposed to ensure that grounding
relative to any domain does not affect the answer sets. This
deﬁnition of safety is a generalization of the deﬁnition of
safety from (Cabalar et al. 2009).
Based on this, we presented a syntactic condition under
which RASPL-1 programs and FLP programs can be ﬁnitely
instantiated. We expect that the notions introduced in the
paper will be useful for clarifying other important constructs
in ASP.

Acknowledgements
We are grateful to Yuliya Lierler, Vladimir Lifschitz, Yunsong Meng, Ravi Palla and anonymous referees for their useful comments and discussions related to this paper. Some
theorems in this paper are natural generalizations of the theorems reported in (Lee et al. 2009), the joint work by the
second author, Vladimir Lifschiz and Ravi Palla. Ravi also
contributed to Proposition 7. This work was partially supported by the National Science Foundation under Grant IIS0916116 and by the IARPA SCIL program.

References
Pedro Cabalar, David Pearce, and Agustin Valverde. Reducing propositional theories in equilibrium logic to logic
programs. In Proceedings of Portuguese Conference on Artiﬁcial Intelligence (EPIA), pages 4–17, 2005.
Pedro Cabalar, David Pearce, and Agustin Valverde. A revised concept of safety for general answer set programs. In
Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 58–
70, 2009.
Francesco Calimeri, Susanna Cozza, Giovambattista Ianni,
and Nicola Leone. Computable functions in ASP: theory and
implementation. In Proceedings of International Conference
on Logic Programming (ICLP), pages 407–424, 2008.

6

485

http://peace.eas.asu.edu/joolee/papers/safety.pdf .

On the Semantic Relationship between Probabilistic Soft Logic and Markov Logic
Joohyung Lee and Yi Wang

arXiv:1606.08896v1 [cs.AI] 28 Jun 2016

School of Computing, Informatics, and Decision Systems Engineering
Arizona State University
Tempe, AZ, 85287, USA
{joolee,ywang485}@asu.edu

Abstract
Markov Logic Networks (MLN) and Probabilistic Soft Logic
(PSL) are widely applied formalisms in Statistical Relational
Learning, an emerging area in Artificial Intelligence that is
concerned with combining logical and statistical AI. Despite
their resemblance, the relationship has not been formally
stated. In this paper, we describe the precise semantic relationship between them from a logical perspective. This is
facilitated by first extending fuzzy logic to allow weights,
which can be also viewed as a generalization of PSL, and then
relate that generalization to MLN. We observe that the relationship between PSL and MLN is analogous to the known
relationship between fuzzy logic and Boolean logic, and furthermore the weight scheme of PSL is essentially a generalization of the weight scheme of MLN for the many-valued
setting.1

Introduction
Statistical relational learning (SRL) is an emerging area
in Artificial Intelligence that is concerned with combining logical and statistical AI. Markov Logic Networks
(MLN) (Richardson and Domingos 2006) and Probabilistic
Soft Logic (PSL) (Kimmig et al. 2012; Bach et al. 2015) are
well-known formalisms in statistical relational learning, and
have been successfully applied to a wide range of AI applications, such as natural language processing, entity resolution, collective classification, and social network modeling. Both of them combine logic and probabilistic graphical
model in a single representation, where each formula is associated with a weight, and the probability distribution over
possible worlds is derived from the weights of the formulas
that are satisfied by the possible worlds. However, despite
their resemblance to each other, the precise relationship between their semantics is not obvious. PSL is based on fuzzy
interpretations that range over reals in [0, 1], and in this sense
is more general than MLN. On the other hand, its syntax is
restricted to formulas in clausal form, unlike MLN that allows any complex formulas. It is also not obvious how their
models’ weights are related to each other due to the different
ways that the weights are associated with models. Originating from the machine learning research, these formalisms
1
In Working Notes of the 6th International Workshop on Statistical Relational AI (StarAI 2016)

are equipped with several efficient inference and learning
algorithms, and some paper compares the suitability of one
formalism over the other by experiments on specific applications (Beltagy, Erk, and Mooney 2014). On the other hand,
the precise relationship between the two formalisms has not
been formally stated.
In this paper, we present a precise semantic relationship
between them. We observe that the relationship is analogous to the well-known relationship between fuzzy logic
and classical logic. Moreover, despite the different ways that
weights of models are defined in each formalism, it turns out
that they are essentially of the same kind. Towards this end,
we introduce a weighted fuzzy logic as a proper generalization of PSL, which is also interesting on its own as an extension of the standard fuzzy logic to incorporate weighted
models. The weighted fuzzy logic uses the same weight
scheme as PSL, but associates weights to arbitrary fuzzy
formulas. This intermediate formalism facilitates the comparison between PSL and MLN. We observe that the same
analogy between fuzzy logic and Boolean logic carries over
to between PSL and MLN. Analogous to that fuzzy logic
agrees with Boolean logic on crisp interpretations, PSL and
MLN agree on crisp interpretations, where their weights are
proportional to each other. However, their maximum a posteriori (MAP) estimates do not necessarily coincide due to
the differences between many-valued vs. Boolean models.
The paper is organized as follows. We first review each of
MLN, fuzzy propositional logic, and PSL. Then we define a
weighted fuzzy logic as a generalization of PSL. Using this
we study the semantic relationship between PSL and MLN.

Preliminaries
Although both PSL and MLN allow atoms to contain variables, those variables are understood in terms of grounding
over finite domains where a universally quantified sentence
is turned into multiple conjunctions and an existentially
quantified sentence is turned into multiple disjunctions, essentially resulting in propositional theories. For example,
the ground atoms of the first-order signature σ = {p, a, b},
where p is a unary predicate constant and a, b are object constants, can be identified with the propositional atoms of the
propositional signature {p(a), p(b)}. Thus for simplicity but
without losing generality, we assume that the programs are

propositional.2

Review: Markov Logic Networks
The following is a review of Markov Logic
from (Richardson and Domingos 2006).
A Markov
Logic Network (MLN) L of a propositional signature σ is
a finite set of pairs hw : F i, where F is a propositional
formula of σ and w is a real number.
For any MLN L of signature σ, we define LI to be the
set of weighted formulas w : F in L such that I |= F .
The unnormalized weight of an interpretation I under L is
defined as
!
X
WL (I) = exp
w ,

Symbol
⊗l
⊕l
⊗m
⊕m
⊗p
⊕p
¬s

Name
Lukasiewicz t-norm
Lukasiewicz t-conorm
Gödel t-norm
Gödel t-conorm
product t-norm
product t-conorm
standard negator

→r

R-implicator induced by ⊗m

→s
→l

S-implicator induced by ⊗m
Implicator induced by ⊗l

Definition
⊗l (x, y) = max(x + y − 1, 0)
⊕l (x, y) = min(x + y, 1)
⊗m (x, y) = min(x, y)
⊕m (x, y) = max(x, y)
⊗p (x, y) = x · y
⊕p (x, y) = x + y − x · y
¬s (x) = 1 −
x
1 if x ≤ y
→r(x, y) =
y otherwise

→s(x, y) = max(1 − x, y)
→l(x, y) = min(1 − x + y, 1)

Figure 1: Some t-norms, t-conorms, negator, and implicators

w:F ∈LI

and the normalized weight (a.k.a. probability) of I under L
is defined as
PL (I) = P

WL (I)
,
J∈P W WL (J)

where P W (“Possible Worlds”) is the set of all interpretations of σ.
The basic idea of Markov Logic is to allow formulas to be
soft constrained, where a model does not have to satisfy all
formulas, but is associated with the weight that is obtained
from the satisfied formulas. An interpretation that does not
satisfy certain formulas receives an “(indirect) penalty” because such formulas do not contribute to the weight of that
interpretation.

Review: Fuzzy Propositional Formula
The following is a review of fuzzy propositional formulas
from (Hajek 1998). A fuzzy propositional signature σ is a
set of symbols called fuzzy atoms. In addition, we assume
the presence of a set CONJ of fuzzy conjunction symbols, a
set DISJ of fuzzy disjunction symbols, a set NEG of fuzzy
negation symbols, and a set IMPL of fuzzy implication symbols.
A fuzzy (propositional) formula of σ is defined recursively
as follows.
• every fuzzy atom p ∈ σ is a fuzzy formula;
• every numeric constant c, where c is a real number in
[0, 1], is a fuzzy formula;
• if F is a fuzzy formula, then ¬F is a fuzzy formula, where
¬ ∈ NEG;
• if F and G are fuzzy formulas, then F ⊗ G, F ⊕ G, and
F → G are fuzzy formulas, where ⊗ ∈ CONJ, ⊕ ∈
DISJ, and → ∈ IMPL.
The models of a fuzzy formula are defined as follows. The
fuzzy truth values are the real numbers in the range [0, 1]. A
fuzzy interpretation I of σ is a mapping from σ into [0, 1].
2
Inference and learning algorithms in these languages indeed
utilize the relational structure, but in terms of defining the semantics, the assumption simplifies the presentation without the need to
refer to fuzzy predicate logic.

The fuzzy operators are functions mapping one or a pair
of truth values into a truth value. Among the operators, ¬ denotes a function from [0, 1] into [0, 1]; ⊗, ⊕, and → denote
functions from [0, 1] × [0, 1] into [0, 1]. The actual mapping
performed by each operator can be defined in many different ways, but all of them satisfy the properties that they are
generalizations of the corresponding Boolean connectives.
Figure 1 lists some examples of fuzzy operators.
The truth value of a fuzzy propositional formula F under I, denoted υI (F ), is defined recursively as follows:
• for any atom p ∈ σ, υI (p) = I(p);
• for any numeric constant c, υI (c) = c;
• υI (¬F ) = ¬(υI (F ));
• υI (F ⊙ G) = ⊙(υI (F ), υI (G)) (⊙ ∈ {⊗, ⊕, →}).
(For simplicity, we identify the symbols for the fuzzy operators with the truth value functions represented by them.)
Definition 1 We say that a fuzzy interpretation I satisfies a
fuzzy formula F if υI (F ) = 1, and denote it by I |= F . We
call such I a fuzzy model of F .
We say that a fuzzy interpretation I is Boolean if I(p)
is either 0 or 1 for each fuzzy atom p. Clearly, we may
identify a Boolean fuzzy interpretation I with the classical
propositional interpretation by identifying 1 with TRUE and
0 with FALSE.
Any fuzzy propositional formula whose numeric constants are restricted to 0 and 1 can be identified with a classical propositional formula. For such a formula F , due to the
fact that fuzzy operators are generalizations of their Boolean
counterparts, it is clear that Boolean fuzzy models of F are
precisely the Boolean models of F when F is viewed as a
classical propositional formula.

Review: Probabilistic Soft Logic
The following is a review of PSL from (Kimmig et al. 2012),
but is stated using the terminology from fuzzy logic. A PSL
program Π is a set of weighted formulas hw : R ˆki where
• w is a nonnegative real number,
• R is a fuzzy propositional formula of the form 3
a ←l b1 ⊗l . . . ⊗l bn
(1)
3

We understand G ← F as an alternative notation for F → G.

where n ≥ 0, each of a, b1 , . . . , bn is a fuzzy atom possibly preceded by the standard negator, and
• k ∈ {1, 2}.4
For each rule R of the form (1), the distance to satisfaction
under interpretation I is defined as
dR (I) = max{0, υI (b1 ⊗l · · · ⊗l bn ) − υI (a)}.

hw:F ˆki∈Π

(2)

Given an interpretation I of Π, the unnormalized density
function over I under Π is defined as
!
X
k
ˆ
w · dR (I) ,
fΠ (I) = exp −
hw:Rˆki∈Π

and the probability density function over I under Π is defined as
fˆΠ (I)
fΠ (I) =
,
ZΠ
where ZΠ is the normalization factor
Z
fˆΠ (I).
I

The probability density function fΠ (I) is defined similar
to the weight WL (I) in MLN. Different from MLN where
the weight of an interpretation comes from the sum over the
weights of all formulas that are satisfied (thus the penalty
is implicit), in PSL, the probability density function of an
interpretation is obtained from the sum over the “penalty”
(i.e., the weight times the distance to satisfaction) from each
formula, where the penalty is 0 when the formula is satisfied, and becomes bigger as the formula gets unsatisfied
more (i.e., the fuzzy truth value of the body gets bigger than
the fuzzy truth value of the head). When the formula is most
unsatisfied (i.e., the body evaluates to 1 and the head evaluates to 0), the penalty is w, the maximum. A novel idea here
is that each formula contributes to the penalty to a certain
graded truth degree (including 0). Along with the restriction imposed on the syntax of fuzzy formulas (using the rule
form (1)), MAP inference in PSL can be reduced to a convex
optimization problem in continuous space, thereby enabling
efficient computation.

Weighted Fuzzy Logic as a Generalization of
PSL
Weighted Fuzzy Logic
Here we define a weighted fuzzy logic as a generalization of
PSL. The idea is simple. We take the standard fuzzy logic
and extend it by applying the log-linear weight scheme of
PSL.
A weighted propositional fuzzy logic theory Π is a set of
weighted formulashw : F ˆki, where
• w is a real number,
• F is a fuzzy propositional formula, and
4

• k ∈ {1, 2}.
The unnormalized density function of a fuzzy interpretation I under Π is defined as
!
X
w · (1 − υI (F ))k ,
fˆΠ (I) = exp −

PSL also allows linear equality and inequality constraints,
which is outside logical theories, and we omit here for simplicity.
Interpretation I that violates any of them gets fΠ (I) = 0.

and the probability density function of I under Π is defined
as
fˆΠ (I)
fΠ (I) =
,
ZΠ
where ZΠ is the normalization factor
Z
fˆΠ (I).
I

Notice that 1 − υI (F ) represents the distance to satisfaction in the general case. It is 0 when I satisfies F , and becomes bigger as υI (F ) gets farther from
1. This notion of distance to satisfaction for an arbitrary formula is also used in Probabilistic Similarity Logic
(Bröcheler, Mihalkova, and Getoor 2010), and indeed, the
weighted fuzzy logic is very similar to Probabilistic Similarity Logic. Both of them employ arbitrary fuzzy operators,
not restricted to the Lukasiewicz fuzzy operators. However,
the languages are not the same. In Probabilistic Similarity Logic, atomic sentences are of the form called similarity
s
statements, A = B, where s is some similarity measure, and
A, B are entities or sets that can even be represented in an
object-oriented syntax. On the other hand, atomic sentences
of the weighted logic is a fuzzy atom, same as in PSL. As
we show below it is easy to view the weighted fuzzy logic
as a generalization of PSL, and it serves as a convenient intermediate language to relate PSL and MLN.5

Relation to PSL
The following lemma tells us how the notions of distance
to satisfaction in PSL and in the weighted fuzzy logic are
related.
Lemma 1 For any rule R of the form (1) and any interpretation I,
dR (I) = 1 − υI (R).
Proof.
1 − υI (R)
= max{0,
= max{0,
= max{0,
= max{0,

1 − υI (R)}
1 − υI (a ←l b1 ⊗l . . . ⊗l bn )}
1 − min{1 − υI (b1 ⊗l · · · ⊗l bn ) + υI (a), 1}}
υI (b1 ⊗l · · · ⊗l bn ) − υI (a)})

= dR (I).

In Lemma 1, it is essential that rules (1) use Lukasiewicz
fuzzy operators. The lemma does not hold with an arbitrary
selection of fuzzy operators as the following example indicates.
5

Although PSL and Probabilistic Similarity Logic seem to be
closely related, the formal relationship between them has not been
discussed in the literature to the best of our knowledge.

Example 1 Consider Gödel t-norm ⊗m and its residual implicator →r . Let R be q ←r p and I an interpretation
{(p, 0.6), (q, 0.4)}. dR (I) is 0.2, while 1 − υI (p →r q)
is 1 − 0.4 = 0.6.
It follows from Lemma 1 that PSL can be easily viewed
as a special case of the weighted fuzzy logic.
Theorem 1 Given any PSL program Π and any fuzzy interpretation I, the definition of fΠ (I) when Π is viewed as the
weighted fuzzy logic coincides with the definition of fΠ (I)
when Π is viewed as a PSL program.
Proof.

Immediate from Lemma 1.

Due to this theorem, we will call the weighted fuzzy logic
also as generalized PSL (GPSL).
Viewing PSL as a special case of the weighted fuzzy logic
allows us to apply the mathematical results known from
fuzzy logic to the context of PSL. Here is one example,
which tells us that the different versions of PSL defined in
(Kimmig et al. 2012) and (Bach et al. 2015) are equivalent
despite the different syntax adopted in each of them. To be
precise, PSL in (Bach et al. 2015) is defined for clausal form
only, such as (3) below, while in (Kimmig et al. 2012) it is
defined for rule form (1) only.
When L is either an atom A or ¬s A, by øL we denote a
literal complementary to L, i.e., øL = ¬s A if L is A, and
øL = A if L = ¬s A. The following equivalences are known
from fuzzy logic.
Lemma 2 For any formulas F and G, and any literals Li
(1 ≤ i ≤ n),
(a) F →l G is equivalent to ¬s F ⊕l G.
(b) ¬s (L1 ⊗l · · · ⊗l Ln ) is equivalent to (øL1 ⊕l · · · ⊕l øLn ).
The following lemma tells us that the clausal form using Lukasiewicz t-conorm can be written in many different
forms.
Lemma 3 For any literals Li (1 ≤ i ≤ n),
L1 ⊕l · · · ⊕l Lm ⊕l Lm+1 ⊕l · · · ⊕l Ln

(3)

is equivalent to
øL1 ⊗l · · · ⊗l øLm →l Lm+1 ⊕l · · · ⊕l Ln
where n ≥ m ≥ 0.
Proof.

By Lemma 2 (a), formula (3) is equivalent to
¬s (L1 ⊕l · · · ⊕l Lm ) →l Lm+1 ⊕l · · · ⊕l Ln

and by Lemma 2 (b), the latter is equivalent to
øL1 ⊗l · · · ⊗l øLm →l Lm+1 ⊕l · · · ⊕l Ln .
It follows from Lemma 1 that the probability density of an
interpretation does not change when the formula is replaced
with another equivalent formula. This tells us that PSL rules
of the form (1) can be rewritten as any other equivalent formulas. For instance, PSL rule
w:

a

←l

b ⊗l c

ˆ1

(4)

can be equivalently rewritten as any of the following ones.
w
w
w
w
w
w
w

:
:
:
:
:
:
:

¬s b
¬s c
a ⊕l ¬s b
a ⊕l ¬s c
¬s b ⊕l ¬s c
a ⊕l ¬s b ⊕l ¬s c
0

←l
←l
←l
←l
←l

¬s a ⊗l c
¬s a ⊗l b
c
b
¬s a

←l

¬s a ⊗l b ⊗l c

ˆ1,
ˆ1,
ˆ1,
ˆ1,
ˆ1,
ˆ1,
ˆ1.

(5)
As noted above, the syntax of PSL in (Bach et al. 2015)
is clausal form only, such as the second to the last formula in (5), while the syntax of PSL in (Kimmig et al. 2012)
is rule form such as (4). The result above tells us that
the definitions of PSL defined in (Kimmig et al. 2012) and
(Bach et al. 2015) are equivalent despite the different syntax
adopted there.
On the other hand, similar rewriting using other t-norms
and their derived operators may not necessarily yield an
equivalent formula because not every selection of fuzzy operators satisfy Lemma 2 even if they are generalizations of
the corresponding Boolean connectives.
Example 2 Consider again Gödel t-norm ⊗m and its residual implicator →r . The negation ¬m induced from ¬m x =
x →r 0 is

1 if x = 0
¬m x =
0 if x > 0.
For the interpretation I = {(p, 0.4), (q, 0.5)}, we have
υI (¬m p ⊕m q) = 0 ⊕m 0.5 = 0.5, but υI (p →r q) = 1. In
other words, ¬m p ⊕m q is not equivalent to p →r q.
In the literature on PSL (Kimmig et al. 2012;
Bach et al. 2015), the selection of Lukasiewicz t-norm
is motivated by the computational efficiency gained by
reducing MAP inferences to convex optimization problems. This section presents yet another justification of
Lukasiewicz t-norm in PSL from the logical perspective.

GPSL : MLN = Fuzzy Logic : Boolean Logic
Like fuzzy logic is a many-valued extension of Boolean
logic, we may view GPSL as a many-valued extension of
MLN.
For any classical propositional formula F , let F fuzzy be
the fuzzy formula obtained from F by replacing ⊥ with 0, ⊤
with 1, ¬ with any fuzzy negation symbol, ∧ with any fuzzy
conjunction symbol, ∨ with any fuzzy disjunction symbol,
and → with any fuzzy implication symbol.
For any GPSL program Π, by T WΠ (“total weight”) we
denote


X
w .
exp 
hw:F ˆki∈Π

For any MLN L, let ΠL be the GPSL program obtained
from L by replacing each weighted formula w : F in L
with w : F fuzzy ˆk, where k is either 1 or 2. The following
theorem tells us that, for any Boolean interpretation I, its
weight under MLN L is proportional to the unnormalized
probability density under the GPSL program ΠL .

Theorem 2 For any MLN L and any Boolean interpretation I,
WL (I) = T WΠL · fˆΠL (I).

However, MAP states in MLN and PSL can be different
because most probable interpretations in PSL may be nonBoolean.
Example 4 Consider the PSL program:

Proof.
X

WL (I) = exp

w

hw,F i∈LI

= exp

X

w

X

w

hw,F i∈L

= exp

hw,F i∈L



× exp −

!

!

= exp

X

w−

hw,F i∈L

· exp

−

X

X

(w · 1) +

hw,F i∈L\LI

w

hw,F i∈L\LI

w

hw,F i∈L\LI

!

X

X

!

hw,F i∈LI

!
(w · 0)  .
(6)

hw:F fuzzy ˆki∈ΠL

· fˆΠL (I).

This theorem tells us that the problem of computing the
weight of an interpretation in MLN can be reduced to computing the probability density of an interpretation in GPSL.
By Theorem 1, since PSL is a special case of GPSL, the
following relation between PSL and MLN follows easily.
Corollary 1 For any PSL program Π and any fuzzy Boolean
interpretation I, let L be the MLN obtained from Π by replacing each fuzzy operator with its Boolean counterpart.
We have
WL (I)
fˆΠ (I) =
.
T WΠ
Example 3 Let Π be the following PSL program
1:
2:

p
q

←l
←l

q
p

ˆ1
ˆ1

and let L be the corresponding MLN as described in Corollary 1.
The following table shows, for each Boolean interpretation I, its weight according to the MLN semantics (WL (I))
is T WΠ , which is e3 , multiplied by its unnormalized probability density function (fˆΠ (I)) according to the PSL semantics. (We identify a Boolean interpretation with the set of
atoms that are true in it.)
Interpretation (I)
∅
{p}
{q}
{p, q}

WL (I)
e3
e1
e2
e3

fˆΠ (I)
e0
e−2
e−1
e0

1:
1:

p
¬s p

←l

¬s p

ˆ1
ˆ1

(7)

and the corresponding MLN:
1:
p
1 : ¬s p

Note that when I is Boolean, 1 − υI (F ) = 1 if I 6|= F ,
and 1 − υI (F ) = 0 if I |= F . So (6) is equal to
!
X
fuzzy k
T WΠL · exp −
w · (1 − υI (F
))
= T WΠL

!

←

¬s p

(8)

The most probable Boolean interpretations for MLN (8)
are I1 = ∅ and I2 = {p}, each with weight e1 . Their
unnormalized probability density for PSL program (7) is
e−1 . However, they are not the most probable interpretations according to the PSL semantics: I3 = {(p, 0.5)} has
the largest unnormalized probability density e−0.5 .
The difference can be closed by adding to the weighted
propositional fuzzy logic theory a “crispifying” rule for each
atom. For any atom p ∈ σ, let CRSP(p) be the formula
defined as
CRSP(p) = p ⊕l p →l p.
It is easy to check that υI (p⊕l p →l p) = 1 iff υI (p) is either
0 or 1. Note that although this formula uses Lukasiewicz
operators, it is not expressible in PSL because ⊕l occurs in
the body of the rule.
For any MLN L of signature σ, let ΠL be the GPSL program obtained from L by replacing each weighted formula
w : F in L with w : F fuzzy ˆk where k could be either 1 or
2. Let CR be the GPSL program
{hα : CRSP (p)ˆ1i | p ∈ σi}.
The following theorem tells us that the most probable interpretations of MLN L coincides with the most probable
interpretations of GPSL program ΠL ∪ CR.
Theorem 3 For any MLN L, when α → ∞,
argmax (WL (I)) = argmax (fˆΠ ∪CR (J))
I

J

L

where I ranges over all Boolean interpretations and J
ranges over all fuzzy interpretations.
Proof. We first show that, when α → ∞, for any Boolean
interpretation I and any non-Boolean interpretation J, we
have fˆΠL ∪CR (J) < fˆΠL ∪CR (I), which implies that no nonBoolean interpretation can be the most probable interpretations.
First, for any non-Boolean interpretation J, let


X
k
w · (1 − υJ (F ))
WΠL (J) = −
hw:F ˆki∈ΠL

and
WCR (J) = −

X

hw:F ˆ1i∈CR




α · (1 − υJ (F )) .

Then
fˆΠL ∪CR (J) = exp(WΠL (J) + WCR (J))
≤ exp(WCR (J)).

Since J is not Boolean, there is at least one weighted formula α : p ⊕l p →l p ˆ1 ∈ CR that is not satisfied by J, so
that

fˆΠL ∪CR (J) ≤ exp − α · 1 − υJ (p ⊕l p →l p)
where 1 − υJ (p ⊕l p →l p) > 0. Notice that
lim fˆΠL ∪CR (J) ≤

α→∞


lim exp − α · 1 − υJ (p ⊕l p →l p) = 0.

α→∞

On the other hand, for any Boolean interpretation I,

fˆΠL ∪CR (I) = exp(WΠL (I) + WCR (I)) = exp(WΠL (I)).
Since exp(WΠL (I)) does not contain α, we have
lim fˆΠL ∪CR (I) > 0.

α→∞

Thus we have fˆΠL ∪CR (J) < fˆΠL ∪CR (I) when α → ∞.
It follows that any fuzzy interpretation K that satisfies
argmaxJ (PΠL ∪CR (J)) = K must be Boolean. By Theorem 2, for any Boolean interpretation I, we have
exp(|σ| · α)
fˆΠL ∪CR (I) =
× WL (I).
T WΠL ∪CR
exp(|σ| · α)
is constant for all interpretations,
T WΠL ∪CR
fˆΠL ∪CR (I) ∝ WL (I). It follows that argmaxI (WL (I)) =
argmaxJ (fˆΠL ∪CR (J)).
Since

Example 5 Consider the GPSL program:
1:
p
1 : ¬s p
α:
p

←l

¬s p

←l

p ⊕l p

ˆ1
ˆ1
ˆ1.

When α → ∞ the most probable fuzzy interpretations are
Boolean, and they are the same as the most probable interpretations for the MLN (8).
It is known that the MAP problem in PSL can be solved in
polynomial time (Bröcheler, Mihalkova, and Getoor 2010),
while the same problem in MLN is #P-hard. The reduction
from MLN to GPSL in Theorem 3 tells us that the MAP
problem in GPSL is #P-hard as well. This implies that
GPSL is strictly more expressive than PSL even when we
restrict attention to Lukasiewicz operators.
Related to Theorem 3, relation between discrete and soft MAP states was also studied in
(Bach, Huang, and Getoor 2015; Bach et al. 2015), but
from a different, computational perspective. There, inference on discrete MAP states is viewed as an instance of
MAX SAT problems, and then approximated by relaxation
to linear programming with rounding guarantee of solutions.
The result indirectly tells us how MAP states in PSL are
related to MAP states in MLN, but this is different from
Theorem 3, which completely closes the semantic gap
between them via crispifying rules.

Conclusion
In this note, we studied the two well-known formalisms
in statistical relational learning from a logical perspective.
Viewing PSL in terms of the weighted fuzzy logic gives us
some useful insights known from fuzzy logic. Besides the
reducibility to convex optimization problems, the restriction
to the Lukasiewicz fuzzy operators in clausal form allows
intuitive equivalent transformations resembling those from
Boolean logic. On the other hand, it prohibits us from using
some other intuitive fuzzy operators.
In
our
previous
work
(Lee and Wang 2014;
Lee and Wang 2016a) we used fuzzy answer set programs to describe temporal projection in dynamic domains,
where we had to use Gödel t-norm as well as Lukasiewicz
t-norm.6 There, Gödel t-norm is necessary in expressing the
commonsense law of inertia. For example,
Trust(a, b, t)⊗m ¬s ¬s Trust(a, b, t+1) →r Trust(a, b, t+1),
(9)
expresses that the degree that a trusts b at time t+1 is equal
to the degree at time t if it can be assumed without contradicting any of the facts that can be derived. 7 The fuzzy
conjunction ⊗ used here needs to satisfy that ⊗(x, y) is
equal to either x or y (otherwise the trust degree at next time
step would change for no reason). Obviously Lukasiewicz
t-norm does not satisfy the requirement: ⊗l (x, y) < x when
y < 1. In other words, if we replace ⊗m with ⊗l , the trust
degree at next time drops for no reason, which is unintuitive.
The restriction to Lukasiewicz t-norm in PSL accounts for
the difficulty in directly applying PSL to temporal reasoning problems like the above example. Indeed, most work on
PSL has been limited to static domains.
Since computing marginal probabilities in MLN can be
reduced to computing marginal probabilities in GPSL as indicated by Theorem 2, computing marginal probabilities in
GPSL is at least #P-hard. However, a sampling method
could be used for such an inference. A naive sampling
method is outlined below: suppose we are approximating
the probability that the truth value of formula F falls into
(l, u) for some 0 ≤ l ≤ u ≤ 1 (denoted as P (l ≤ F ≤ u)).
1. Generate N interpretations at random;
2. For each of the N interpretations, compute its probability
density;
3. Approximate P (l ≤ F ≤ u) by X
N , where X is the number of interpretations I that satisfies l ≤ υI (F ) ≤ u
among the N interpretations.
X
It can be shown that N
is the estimation of P (l ≤ F ≤ u)
that maximizes the likelihood of the N samples.
The way that MLN extends propositional logic is similar to the way that PSL extends a restricted version of fuzzy
propositional logic. GPSL is simply taking the fuzzy propositional logic in full generality and applying the log-linear
weight scheme. In our recent work (Lee and Wang 2016b),
6

The main example was how the trust degree between people
changes over time.
7
We refer the reader to (Lee and Wang 2016a) for the precise
semantics of this language.

we adopted the similar weight scheme to answer set programs in order to overcome the deterministic nature of the
stable model semantics providing ways to resolve inconsistencies in answer set programs, to rank stable models, to
associate probability to stable models, and to apply statistical inference to computing weighted stable models. Perhaps this indicates the universality of the log-linear weight
scheme first adopted in MLN, which provides a uniform
method to turn the crisp logic (be it fuzzy logic, propositional logic, or answer set programs) “soft.”
Acknowledgements
We are grateful to Michael
Bartholomew and the anonymous referees for their
useful comments. This work was partially supported by the
National Science Foundation under Grants IIS-1319794,
IIS-1526301, and a gift funding from Robert Bosch LLC.

References
[Bach et al. 2015] Bach, S. H.; Broecheler, M.; Huang, B.;
and Getoor, L. 2015. Hinge-loss markov random fields and
probabilistic soft logic. arXiv:1505.04406 [cs.LG].
[Bach, Huang, and Getoor 2015] Bach, S. H.; Huang, B.;
and Getoor, L. 2015. Unifying local consistency and MAX
SAT relaxations for scalable inference with rounding guarantees. In Artificial Intelligence and Statistics (AISTATS).
[Beltagy, Erk, and Mooney 2014] Beltagy, I.; Erk, K.; and
Mooney, R. 2014. Probabilistic soft logic for semantic
textual similarity. Proceedings of Association for Computational Linguistics (ACL-14).
[Bröcheler, Mihalkova, and Getoor 2010] Bröcheler,
M.;
Mihalkova, L.; and Getoor, L. 2010. Probabilistic similarity
logic. In UAI 2010, Proceedings of the Twenty-Sixth
Conference on Uncertainty in Artificial Intelligence, 73–82.
[Hajek 1998] Hajek, P. 1998. Mathematics of Fuzzy Logic.
Kluwer.
[Kimmig et al. 2012] Kimmig, A.; Bach, S.; Broecheler, M.;
Huang, B.; and Getoor, L. 2012. A short introduction to
probabilistic soft logic. In Proceedings of the NIPS Workshop on Probabilistic Programming: Foundations and Applications, 1–4.
[Lee and Wang 2014] Lee, J., and Wang, Y. 2014. Stable
models of fuzzy propositional formulas. In Proceedings
of European Conference on Logics in Artificial Intelligence
(JELIA), 326–339.
[Lee and Wang 2016a] Lee, J., and Wang, Y. 2016a. Fuzzy
propositional formulas under the stable model semantics.
the Special Issue on Logics for Reasoning about Preferences, Uncertainty and Vagueness of the IfCoLog Journal
of Logics and their Applications. To appear.
[Lee and Wang 2016b] Lee, J., and Wang, Y.
2016b.
Weighted rules under the stable model semantics. In
Proceedings of International Conference on Principles of
Knowledge Representation and Reasoning (KR).
[Richardson and Domingos 2006] Richardson, M., and
Domingos, P. 2006. Markov logic networks. Machine
Learning 62(1-2):107–136.

Circumscriptive Event Calculus as Answer Set Programming
Tae-Won Kim, Joohyung Lee, and Ravi Palla
Computer Science and Engineering
Arizona State University
Tempe, AZ 85281, USA
{Tae-Won.Kim, joolee, Ravi.Palla}@asu.edu
Abstract

et al., 1998], is based on classical logic, using circumscription to handle the frame problem. On the other hand, the
solution provided by answer set programming (ASP), that is
carried over to high level action language A [Gelfond and
Lifschitz, 1998] and many of its descendants that are based
on ASP, uses both default negation (not) and strong negation (¬)—the idea of which is closely related to Reiter’s default logic solution [Reiter, 1980]. Interestingly, the development of the event calculus has spanned over both classical logic and logic programming traditions. The original
version of the event calculus [Kowalski and Sergot, 1986]
was formulated as logic programs but not under the stable
model semantics (that was the time before the invention of
the stable model semantics). More extensive later developments of the event calculus have been carried out under the
classical logic setting via circumscription [Shanahan, 1995;
Miller and Shanahan, 1999].
In this paper we show how to embed circumscriptive event
calculus into the general language of stable models, and
furthermore into answer set programs under certain conditions. The reformulation of the event calculus in the stable model semantics here can be viewed as turning back the
event calculus to the logic program tradition, in the modern
form of answer set programming. In contrast to the SATbased approaches from [Shanahan and Witkowski, 2004;
Mueller, 2004a] which turn circumscription into completion
and hence cannot handle certain recursive axioms of the event
calculus, we show that the ASP approach can compute the
full version of the event calculus assuming that the domain is
given and ﬁnite. Our work shows that the new stable model
semantics is a nonmonotonic formalism as general as circumscription, with the unique advantage of having efﬁcient ASP
solvers as computational tools.
Our work is motivated by Mueller’s work that is available
on the webpage
http://decreasoner.sourceforge.net/csr/ecas/,
where a few example answer set programs are given to illustrate that event calculus like reasoning can be done using ASP
solvers. However, this is rather a “proof of concept” and no
formal justiﬁcation is provided there.

Recently, Ferraris, Lee and Lifschitz presented a
general deﬁnition of a stable model that is similar
to the deﬁnition of circumscription, and can even
be characterized in terms of circumscription. In
this paper, we show the opposite direction, which
is, how to turn circumscription into the general stable model semantics, and based on this, how to turn
circumscriptive event calculus into answer set programs. The reformulation of the event calculus in
answer set programming allows answer set solvers
to be applied to event calculus reasoning, handling
more expressive reasoning tasks than the current
SAT-based approach. Our experiments also show
clear computational advantages of the answer set
programming approach.

1

Introduction

The stable model semantics is the mathematical basis of
answer set programming [Marek and Truszczyński, 1999;
Niemelä, 1999; Lifschitz, 2008]. Recently, Ferraris, Lee and
Lifschitz [2007] presented a general deﬁnition of a stable
model that applies to the syntax of arbitrary ﬁrst-order sentences, under which logic programs are viewed as a special
class of ﬁrst-order sentences. The new semantics is similar to the deﬁnition of circumscription [McCarthy, 1980;
1986], and can even be characterized in terms of circumscription [Ferraris et al., 2007, Corollary 1]. Essentially the
same characterization was also independently given in [Lin
and Zhou, 2007].
The opposite direction, turning (parallel) circumscription
into the stable model semantics, was shown in [Lee and Lin,
2004; Janhunen and Oikarinen, 2004] limited to the propositional case. The ﬁrst contribution of this paper is a generalization of the result from [Lee and Lin, 2004]: turning
ﬁrst-order circumscription into the general stable model semantics. Such close relationship between the two formalisms
is curious since they have formed rather disparate traditions
in knowledge representation. In particular, they have provided different solutions to the frame problem. A group
of action formalisms, such as circumscriptive event calculus [Shanahan, 1995] and temporal action logics [Doherty

2

Review of the Event Calculus

Here we follow the extensive syntax of circumscriptive event
calculus described in [Mueller, 2006, Chapter 2].

823

We assume a many-sorted ﬁrst-order language, which contains an event sort, a ﬂuent sort, and a timepoint sort. A ﬂuent
term is a term whose sort is a ﬂuent; an event term and a
timepoint term are deﬁned similarly. A condition is deﬁned
recursively as follows:
• A comparison (τ1 < τ2 , τ1 ≤ τ2 , τ1 ≥ τ2 , τ1 > τ2 ,
τ1 = τ2 , τ1 = τ2 ) for terms τ1 , τ2 is a condition;
• If f is a ﬂuent term and t is a timepoint term, then
HoldsAt(f, t) and ¬HoldsAt(f, t) are conditions;
• If γ1 and γ2 are conditions, then γ1 ∧ γ2 and γ1 ∨ γ2 are
conditions;
• If v is a variable and γ is a condition, then ∃vγ is a condition.
We will use e and ei to denote event terms, f and fi to denote ﬂuent terms, t and ti to denote timepoint terms, and γ
and γi to denote conditions. We understand formula F ↔ G
as shorthand for (F → G) ∧ (G → F ); formula 
 as shorthand for ⊥ → ⊥; formula ¬F as shorthand for F → ⊥.
An event calculus domain description is deﬁned as 1
CIRC[Σ ; Initiates, Terminates, Releases]
(1)
∧ CIRC[Δ ; Happens] ∧ Ξ.
where
• Σ is the conjunction of universal closures of axioms of
the form
γ → Initiates(e, f, t)
γ → Terminates(e, f, t)
γ → Releases(e, f, t)
(“effect constraint”)
γ ∧ π1 (e, f1 , t) → π2 (e, f2 , t)
γ ∧ [¬]Happens(e1 , t) ∧ · · · ∧ [¬]Happens(en , t)
→ Initiates(e, f, t)
γ ∧ [¬]Happens(e1 , t) ∧ · · · ∧ [¬]Happens(en , t)
→ Terminates(e, f, t)
where each of π1 and π2 is either Initiates or Terminates;
• Δ is the conjunction of universal closures of temporal ordering formulas (comparisons between timepoint
terms) and axioms of the form
γ → Happens(e, t)
σ(e, t) ∧ π1 (e1 , t) ∧ · · · ∧ πn (en , t) → Happens(e, t)
(“causal constraints”)
Happens(e, t) → Happens(e1 , t) ∨ · · · ∨ Happens(en , t)
(“disjunctive event axiom”)
where σ is Started or Stopped and each πj (1 ≤ j ≤ n)
is either Initiated or Terminated, which are deﬁned as
follows:
def

Started(f, t) ↔ (HoldsAt(f, t)∨
∃e(Happens(e, t) ∧ Initiates(e, f, t)))

(CC1 )

def

Stopped(f, t) ↔ (¬HoldsAt(f, t)∨
∃e(Happens(e, t) ∧ Terminates(e, f, t)))

(CC2 )

def

Initiated(f, t) ↔ (Started(f, t)∧
¬∃e(Happens(e, t) ∧ Terminates(e, f, t)))

(CC3 )

def

Terminated(f, t) ↔ (Stopped(f, t)∧
¬∃e(Happens(e, t) ∧ Initiates(e, f, t)))

(CC4 )

1

The syntax from [Mueller, 2006, Chapter 2] allows
CIRC[Θ ; Ab1 , . . . , Abn ] where Θ is a conjunction of cancellation axioms, which we omit here for simplicity of presentation.

• Ξ is a conjunction of ﬁrst-order sentences (outside the
scope of circumscription) including unique name axioms, state constraints, and one of the two axiomatizations of the event calculus, EC and DEC axioms [Mueller, 2006].
As listed, circumscriptive event calculus descriptions look
different from logic programs. The former may contain existential quantiﬁers; only some parts of the description are circumscribed on selected lists of predicates. Nonetheless, we
will see that the differences are not essential.

3

Review of the General Stable Model
Semantics

Under the new deﬁnition of stable models presented in [Ferraris et al., 2007] that is applicable to arbitrary ﬁrst-order
sentences, a logic program is identiﬁed with a universal formula, called the FOL-representation. For example, the FOLrepresentation of the program
p(a)

q(b)

r(x) ← p(x), not q(x)

is

p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x)).
(2)
The review here follows [Ferraris et al., 2010], a journal
version of [Ferraris et al., 2007], in which the stable model
operator was extended to distinguish between intensional and
extensional predicates. Let p be a list of distinct predicate
constants p1 , . . . , pn , and let u be a list of distinct predicate
variables u1 , . . . , un of the same length as p. By u ≤ p we
denote the conjunction of the formulas ∀x(ui (x) → pi (x))
for all i = 1, . . . n where x is a list of distinct object variables
whose length is the same as the arity of pi . Expression u < p
stands for (u ≤ p) ∧ ¬(p ≤ u).
For any ﬁrst-order sentence F , expression SM[F ; p] stands
for the second-order sentence2
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where p is the list p1 , . . . , pn of predicate constants that are
called intensional, u is a list u1 , . . . , un of distinct predicate
variables corresponding to p, and F ∗ (u) is deﬁned recursively:
• pi (t)∗ = ui (t) for any tuple t of terms;
• F ∗ = F for any atomic formula F that does not contain
members of p;
• (F ∨ G)∗ = F ∗ ∨ G∗ ;
• (F ∧ G)∗ = F ∗ ∧ G∗ ;
∗
∗
∗
• (F → G) = (F → G ) ∧ (F → G);
• (∃xF )∗ = ∃xF ∗ .
• (∀xF )∗ = ∀xF ∗ ;
SM[F ] deﬁned in [Ferraris et al., 2007] is identical to
SM[F ; p] where intensional predicate constants p range over
all predicate constants occurring in F . Let σ(F ) be the signature consisting of the object, function and predicate constants occurring in F . According to [Ferraris et al., 2007], an
interpretation of σ(F ) that satisﬁes SM[F ; p] is called a stable model of F , where p is the list of all predicate constants
2
Here we use expression SM[F ; p] in place of SMp [F ] used in
[Ferraris et al., 2010].

824

in σ(F ). If F contains at least one object constant, an Herbrand stable model of F is called an answer set of F . The
answer sets of a logic program Π are deﬁned as the answer
sets of the FOL-representation of Π. It turns out that this definition, applied to the syntax of logic programs, is equivalent
to the traditional deﬁnition of answer sets based on grounding
and ﬁxpoint construction [Ferraris et al., 2007].
The fact that intensional predicates p in SM[F ; p] is allowed not to include some predicates occurring in the formula is not essential in view of the following proposition. By
pr(F ) we denote the list of all predicate constants occurring
in F ; by Choice(p) we denote the conjunction of “choice formulas” ∀x(p(x) ∨ ¬p(x)) for all predicate constants p in p
where x is a list of distinct object variables whose length is
the same as the arity of p.
Proposition 1 [Ferraris et al., 2010, Theorem 2] If p is a
subset of pr(F ), then

each clause as a canonical implication. An arbitrary sentence
that contains existential quantiﬁers can still be turned into a
canonical theory using Skolemization, which preserves satisﬁability.
The following proposition shows that, for any canonical
theory, circumscription coincides with the stable model semantics.
Proposition 2 For any canonical theory F relative to p,
CIRC[F ; p] ↔ SM[F ; p]
is logically valid.
For instance, for (3) that is canonical relative to {p, q}, formulas CIRC[(3); p, q] and SM[(3); p, q] are equivalent to each
other. Also any sentence F is clearly equivalent to a canonical theory relative to ∅, so that CIRC[F ; ∅] is equivalent to
SM[F ; ∅], which in turn is equivalent to F . On the other
hand, for (4) that is not canonical relative to p, CIRC[(4); p] is
not equivalent to SM[(4); p]: the only Herbrand model of the
signature {p/2, a, b} that satisﬁes CIRC[(4); p] is {p(a, a)}
while the Herbrand models of the same signature that satisfy
SM[(4); p] are {p(a, a)} and {p(a, a), p(b, a)}.
It turns out that canonical theories cover a wide range of
formalisms based on circumscription. Indeed, in the syntax of
the event calculus described in Section 2, all axioms in Σ are
already canonical relative to {Initiates,Terminates,Releases};
all axioms in Δ are already canonical relative to {Happens}.
Though not described here in detail, one can check that descriptions in temporal action logics are canonical as well.
The following theorem shows a few equivalent reformulations of circumscriptive event calculus in terms of the stable
model semantics. We assume that Ξ was already equivalently
rewritten so that it contains no strictly positive occurrences of
Initiates, Terminates, Releases, Happens (by prepending ¬¬
to such occurrences).

SM[F ; p] ↔ SM[F ∧ Choice(pr(F )\p); pr(F )]
is logically valid.
However, it will be convenient to describe our main results in
this paper by allowing p to be partial.

4

Turning Circumscription and Event
Calculus Descriptions into SM

We say that an occurrence of a predicate constant in a formula F is strictly positive if that occurrence is not in the antecedent of any implication. For instance, in (p → q) → r,
only r has a strictly positive occurrence.
For any set p of predicate constants and any formulas G
and H, we call implication G → H canonical (relative to p)
if
• every occurrence of every predicate constant from p
in G is strictly positive in G, and
• every occurrence of every predicate constant from p
in H is strictly positive in H.
For instance, p(x) → q(x) is a canonical implication relative
to {p, q}, while its contraposition ¬q(x) → ¬p(x) is not.
Also ∃x p(x) → ∃x q(x) is a canonical implication relative
to {p, q}.
By a canonical theory (relative to p) we mean the conjunction of sentences of the form

Theorem 1 Given an event calculus description (1), let p be
the set of all predicate constants (other than equality and
comparisons) occurring in it. The following theories are
equivalent to each other:3
(a)
(b)
(c)
(d)

∀x(G → H)

The equivalence between (a) and (b) is immediate from
Proposition 2; the equivalence between (b) and (c) follows
from the general splitting theorem for the stable model semantics [Ferraris et al., 2009]; the equivalence between (c)
and (d) is immediate from Proposition 1.

where x is a list of variables (possibly empty), and G → H
is a canonical implication (relative to p). For instance,
(
 → p(a)) ∧ (∃x p(x) → ∃x q(x))

(3)

is a canonical theory relative to {p, q}, while
(
 → p(a, a)) ∧ ∃x(p(x, a) → p(b, x))

CIRC[Σ; I, T, R] ∧ CIRC[Δ; H] ∧ Ξ
SM[Σ; I, T, R] ∧ SM[Δ; H] ∧ Ξ ;
SM[Σ ∧ Δ ∧ Ξ; I, T, R, H] ;
SM[Σ ∧ Δ ∧ Ξ ∧ Choice(p \ {I, T, R, H}); p].

5

(4)

is not a canonical theory relative to {p} (it becomes canonical if ∃ is replaced with ∀). Note that any quantiﬁer-free
formula (and universal formula) can be equivalently rewritten as a conjunction of canonical implications. One way is by
converting to a conjunctive normal form and then rewriting

Turning Event Calculus Descriptions into
Answer Set Programs

Like answer set programs, the intensional predicates of formula (d) in Theorem 1 are all the predicates that occur in
3
Due to lack of space, we abbreviate the names of circumscribed
predicates.

825

as ∀x(G → p(x)).
2. For each axiom that contains existential quantiﬁers, repeat the following until there are no existential quantiﬁers:
(a) Replace maximal negative occurrences of ∃yG(y)
in the axiom by G(z) where z is a new variable.
(b) Replace maximal positive occurrences of
∃yG(x, y) in the axiom where x is the list of
all free variables of ∃yG(x, y), by the formula
¬¬pG (x) where pG is a new predicate constant,
and add the axiom
∀xy(G(x, y) → pG (x)).
(6)

the event calculus description. On the other hand, the description contains formulas that may not be in the rule form,
and may contain existential quantiﬁers, which are not allowed in answer set programs. In this section we provide
a translation of the event calculus into answer set programs
so that ASP solvers can be applied for event calculus reasoning. To facilitate the discussion, we introduce the notion
of RASPL-1M programs. Syntactically similar codes are accepted by LPARSE4 —the front-end of several ASP solvers,
such as SMODELS5 , CMODELS6 , CLASP, and CLINGO7 .

5.1

RASPL-1M Programs

The deﬁnition of stable models reviewed in Section 3 can be
easily extended to many-sorted ﬁrst-order languages, similar to the extension of circumscription to many-sorted ﬁrstorder languages (Section 2.4 of [Lifschitz, 1994]). We deﬁne
RASPL-1M programs as a special class of sentences under
this extension, which are essentially a many-sorted extension
of RASPL-1 programs from [Lee et al., 2008]. We assume
that the underlying signature contains an integer sort and contains several built-in symbols, such as integer constants, builtin arithmetic functions, such as +, −, and comparison operators, such as <, ≤, >, ≥. Since we do not need counting
aggregates in this paper, for simplicity, we will assume that
every “aggregate expression” is an atom or a negated atom.
That is, a rule is an expression of the form
A1 ; . . . ; Ak ← Ak+1 , . . . , Am , not Am+1 , . . . , not An ,
not not An+1 , . . . , not not Ap
(0 ≤ k ≤ m ≤ n ≤ p), where each Ai is an atom, possibly
equality or comparison. A program is a ﬁnite list of rules.
The “choice rule” of the form {A} ← Body where A is an
atom, stands for A ← Body, not not A.
The semantics of a RASPL-1M program is understood
by turning it into its corresponding many-sorted FOLrepresentation, as in RASPL-1. The integer constants and
built-in symbols are evaluated in the standard way, and we
consider only those “standard” interpretations. The answer
sets of a RASPL-1M program are the Herbrand interpretations of the signature consisting of the object, function and
predicate constants occurring in the program, that satisfy
SM[F ; p], where F is the FOL-representation of the program
and p is the list of predicate constants occurring in F .

5.2

3. Add choice formulas ∀x(p(x) ∨ ¬p(x)) for all
the predicate constants p except for those in
{Initiates, Terminates, Releases, Happens} ∪ p1 ∪ p2
where
• p1 is the set of all predicate constants p considered
in Step 1.
• p2 is the set of all new predicate constants pG introduced in Step 2.
4. Identifying the formulas with programs with nested expressions [Lifschitz et al., 1999], apply the conversion
from [Lifschitz et al., 1999] that turns programs with
nested expressions into disjunctive logic programs.
For example, consider DEC5 axiom:
(HoldsAt(f, t) ∧ ¬ReleasedAt(f, t+1)∧
¬∃e(Happens(e, t) ∧ Terminates(e, f, t)))
(7)
→ HoldsAt(f, t+1).
In order to eliminate the positive occurrence of the existential
quantiﬁer in the formula, we apply Step 2(b), introducing the
formula
Happens(e, t) ∧ Terminates(e, f, t) → q(f, t),
and replacing (7) with 8
(HoldsAt(f, t) ∧ ¬ReleasedAt(f, t+1) ∧ ¬¬¬q(f, t))
→ HoldsAt(f, t+1).
Step 4 turns these formulas into rules
q(f, t) ← Happens(e, t), Terminates(e, f, t)
HoldsAt(f, t+1) ← HoldsAt(f, t),
not ReleasedAt(f, t+1), not q(f, t).
Due to lack of space, instead of presenting a formal proof,
we attempt to give the idea of the translation. Step 1 can
be dropped without affecting the correctness, but keeping it
yields a simpler program. Step 2 eliminates existential quantiﬁers. Step 2(a) is one of the steps in prenex normal form
conversion. Eliminating positive occurrences of existential
quantiﬁers using new predicates as in Step 2(b) works only
if G contains no strictly positive occurrences of predicates to
minimize, which is the case with the syntax of the event calculus (Section 2). The following proposition justiﬁes this step
of eliminating existential quantiﬁers.

Turning Event Calculus Descriptions to
RASPL-1M Programs

The following procedure turns an event calculus description into a RASPL-1M program. As before, we assume
that Ξ was already equivalently rewritten so that it contains no strictly positive occurrences of Initiates, Terminates,
Releases, Happens (by prepending ¬¬ to such occurrences).
Deﬁnition 1 (Translation EC 2 ASP) 1. Rewrite all the definitional axioms of the form
def

∀x(p(x) ↔ G)

(5)

4

http://www.tcs.hut.ﬁ/Software/smodels
http://www.tcs.hut.ﬁ/Software/smodels .
6
http://www.cs.utexas.edu/users/tag/cmodels.html .
7
http://potassco.sourceforge.net .
5

The proof of Theorem 2 uses the fact that ¬¬ is put in front of
pG (x) in Step 2(b). Indeed, the translation would be incorrect if ¬¬
was simply dropped.
8

826

Proposition 3 Let F be a sentence, let p be a list of distinct
predicate constants and let q be a predicate constant that does
not belong to the signature of F . For any occurrence of a subformula ∃xG(x, y) of F where y is the list of all free variables in ∃xG(x, y), let F  be the formula obtained from F by
replacing that occurrence with ¬¬q(y). If G(x, y) contains
no strictly positive occurrences of predicate constants from p,
then the models of

http://reasoning.eas.asu.edu/ecasp .
The system turns an event calculus description into the input
language of LPARSE.

6.1

SM[F  ∧ ∀xy(G(x, y) → q(y)); p, q]
restricted to the signature of F are precisely the models of
SM[F ; p].
Alternatively, if the domain is known and ﬁnite, existential
quantiﬁers can be replaced with multiple disjunctions. But
this translation is not modular, and such multiple disjunctions need to be updated when the domain changes. Also one
would imagine Skolemization, but there is a problem since
answer sets are Herbrand models. Consider
p(a) ∧ ∃x p(x) ∧ ∀xy(p(x) ∧ p(y) ∧ x = y → ⊥),
which asserts that p is a singleton. If Step 2 was replaced with Skolemization, the translation would yield
RASPL-1M program
p(a)

p(b)

← p(x), p(y), x = y

p(x) ; not p(x)

(b is a Skolem constant), which has no answer sets. Step 3
is to expand the list of intensional predicates to cover all the
predicates occurring in the description, as in Proposition 1.
The transformation until Step 3 yields a set of implications
where each antecedent and consequent is formed from atoms
by allowing ¬, ∧, and ∨ nested arbitrarily, similar to the syntax of a program with nested expressions from [Lifschitz et
al., 1999]. The well-known transformation that turns a program with nested expressions into a disjunctive logic program
from [Lifschitz et al., 1999] can be applied to turn these set
of implications into a RASPL-1M program.

HoldsAt(Holding(a, o), t) ∧ Initiates(e, InRoom(a, r), t)
→ Initiates(e, InRoom(o, r), t)
On the other hand, the rule corresponding to this formula can
be directly handled by answer set solvers. Indeed, our implementation can handle all event calculus axioms reviewed in
Section 2, and solved all 14 benchmark problems.
We compared the performance of (i) the DEC reasoner
(v 1.0) running RELSAT (v 2.0) with (ii) ECASP with LPARSE
(v 1.1.1)+CMODELS (v 3.75) running RELSAT (v 2.0), (iii)
ECASP with GRINGO (v 2.0.2) + CLASP (v 1.1.3) ( CLASP D
(v 1.1) used for disjunctive programs), and (iv) ECASP with
CLINGO (v 2.0.2). ECASP turns the input in the language of
the DEC reasoner into the language of LPARSE. Both LPARSE
and GRINGO turn the result into a ground ASP program.
CMODELS turns this ground program into a set of clauses
and then invokes a SAT solver to compute answer sets, while
CLASP computes answer sets using the techniques similar to
those used in SAT solvers but without generating clauses.
CLINGO is a system that combines GRINGO and CLASP in
a monolithic way. We have tested many examples and some
notable differences are reported in the table. The ﬁrst ﬁve examples are part of the benchmark problems from [Shanahan,
1997; 1999]. The next four are from [Mueller, 2006]. (We
increased timepoints to see more notable differences.) All
experiments were done on a Pentium machine with 3.00 GHz
CPU and 2GB RAM running 64 bit Linux. The reported run
times were obtained using the Linux time command, except for the DEC reasoner for which we recorded the times
reported by the system. This was to avoid including the time

Theorem 2 Let T be an event calculus domain description, let σ be the signature consisting of the object, function and predicate constants occurring in T , and let Π be
a RASPL-1M program obtained by applying the translation
EC 2 ASP to T . The stable models of Π restricted to σ (disregarding all new predicate constants pG introduced in Step
2 (b)) are precisely the models of T of signature σ.
Turning the resulting RASPL-1M program further into the
input language of LPARSE requires minor rewriting, such
as moving equality or negated atoms to the body (e.g.,
not p(t) ← . . . into ← . . . , p(t)), and adding domain predicates in the body for all variables occurring in the rule. 9

6

Comparison with SAT-based Approach

The Discrete Event Calculus (DEC) reasoner10 is an
implementation of the event calculus written by Erik
Mueller [2004b]. The system reduces event calculus reasoning into satisﬁability checking by turning circumscription
into predicate completion ([Lifschitz, 1994, Proposition 2])
and then ﬁnds the models using SAT solvers. Thanks to the
availability of efﬁcient SAT solvers, the system outperforms
traditional abductive event calculus planners. Compared
to another similar approach in [Shanahan and Witkowski,
2004], the system handles a wider range of reasoning tasks.
Out of the 14 benchmark problems from [Shanahan, 1997;
1999], the DEC reasoner was shown to be able to handle 11 of
them, while the other approach can handle only one [Mueller,
2004a].
However, since circumscription is not always reducible to
completion, the DEC reasoner is unable to handle effect constraints, disjunctive event axioms and compound events. For
example, it is well known that the following effect constraints
that describe the indirect effects of the agent’s walking on
the objects that he is holding cannot be handled by predicate
completion.

Experiments

We have implemented a prototype of an ASP-based event calculus reasoner called ECASP, based on the translation in Section 5.2. The implementation, along with the results of our
experiments are available at the ECASP homepage:
9

If we are only interested in answer sets, rather than (nonHerbrand) stable models (recall the distinction described in Section 3), UNA axioms can be dropped.

10

827

http://decreasoner.sourceforge.net .

Problem
(max. step)

DEC

reasoner

BusRide
(15)

—

Commuter
(15)

—

Kitchen
Sink (25)

71.10
(70.70+0.40)
A:1014/C:12109

Thielscher
Circuit (20)

13.9
(13.6+0.3)
A:5138/C:16122

Walking
Turkey (15)

—

Falling w/
AntiTraj (15)

270.2
(269.3+0.9)
A:416/C:3056

ECASP w/
LPA + CMO

ECASP w/
GRI + CLA

0.48
(0.42+0.06)
A:156/R:7899
C:188
498.11
(447.50+50.61)
A:4913/R:7383943
C:4952
43.17
(37.17+6.00)
A:123452/R:482018
C:0
0.53
(0.48+0.05)
A:4336/R:11399
C:0
0.05
(0.04+0.01)
A:556/R:701
C:0

0.04
(0.03+0.01)
A:733/R:3428

—

44.42
(37.86 + 6.56)
A:24698/R:5381620

28.79

2.47
(1.72+0.75)
A:114968/R:179195

2.03

0.07
(0.05+0.02)
A:1743/R:5669

0.05

0.04
(0.01+0.03)
A:364/R:503

0.01

Though no general method was given in Mueller’s ASP approach on the webpage cited in the introduction, we observe
a few notable differences. One difference is that no choice
rules were used in Mueller’s examples so that all predicates
are to be minimized, which resulted in considering prediction
problems only. On the other hand, our approach can handle
planning and postdiction problems as well. To solve a planning problem, Happens should be exempt from minimization
in logic programs, which can be achieved by adding choice
rules for it. More examples can be found from the ECASP
homepage.

0.08

7

0.74
0.10
(0.66+0.08)
(0.08+0.02)
A:5757/R:10480
A:4121/R:7820
C:0
Falling w/
107.70
34.77
2.90
Events (25)
(107.50+0.20)
(30.99+3.78)
(2.01+0.89)
A:1092/C:12351
A:1197/R:390319
A:139995/R:208282
C:1393
HotAir
61.10
0.19
0.04
Baloon (15)
(61.10+0.00)
(0.16+0.03)
(0.03+0.01)
A:288/C:1163
A:489/R:2958
A:1137/R:1909
C:678
Telephone1
18.20
1.70
0.31
(40)
(17.70+0.50)
(1.51+0.19)
(0.26+0.05)
A:5419/C:41590
A:23978/R:29841
A:21333/R:27037
C:0
A: number of atoms, C: number of clauses, R: number of ground rules

ECASP

6.2

w/ CLI

Comparison with Mueller’s ASP Approach

Conclusion

The possibility of embedding circumscriptive theories into
the new language of stable models indicates that the latter
is as general as the former, and that ASP is a viable approach
to computing circumscriptive theories. We observe that the
ASP approach can compute the full version of the event calculus, assuming that the domain is known and ﬁnite. Thanks
to remarkable progress of ASP solvers in computing stable
models, together with efﬁcient grounding methods, our experiments showed promising results.
More synergies are expected from the relationship between
the event calculus and ASP. In addition to action languages,
circumscriptive event calculus can now be regarded as another useful high level action formalism for ASP, addressing
some issues that are not well regarded in the context of action languages, such as describing continuous change and hierarchical planning. Embedding both the event calculus and
action languages into ASP may be useful in comparing these
high level formalisms and even merging the descriptions written in each of them.

2.32

0.03

0.25

spent by the DEC reasoner in producing output in a neat format. For the DEC reasoner, the times in parentheses are “(encoding time + SAT solving time).” For the others, they are the
times spent by each of the grounder and the solver. CMOD ELS time includes the time spent in converting the ground
program generated by LPARSE into a set of clauses, and calling the SAT solver. The time spent by ECASP in translating
an event calculus description into a logic program (with variables) is negligible for these problems. ’—’ denotes that the
system cannot solve the example due to the limited expressivity. For instance, BusRide includes disjunctive event axioms, which results in a disjunctive program that cannot be
handled by CLINGO.
Overall, ECASP with CLINGO was the clear winner, followed by ECASP with GRINGO+CLASP. Though the DEC
reasoner and CMODELS call the same SAT solver RELSAT,
the number of atoms produced by the DEC reasoner is in
general much smaller. This is because the DEC reasoner
adopts an encoding method (that is based on predicate completion) which avoids a large number of ground instances
of atoms such as Initiates(e, f, t), Terminates(e, f, t), and
Releases(e, f, t). On the other hand, in several examples,
the number of clauses generated by CMODELS is 0, which
means that the answer sets were found without calling the
SAT solver. This is because for these examples the unique answer set coincides with the well-founded model, which is efﬁciently computed by CMODELS without calling SAT solvers.
Out of the 14 benchmark examples from [Shanahan, 1997;
1999], eight of them belong to this case. Another reason for
the good performance of the ASP approach is the efﬁcient
grounding methods implemented in LPARSE and GRINGO,
which are drastically faster than that of the DEC reasoner.

Acknowledgements
We are grateful to Vladimir Lifschitz and Erik Mueller for
useful comments on the idea of this paper and several pointers to earlier work. We are also grateful to anonymous referees for their useful comments. The authors were partially
supported by the National Science Foundation under Grant
IIS-0839821.

References
[Doherty et al., 1998] Patrick Doherty, Joakim Gustafsson,
Lars Karlsson, and Jonas Kvarnström. TAL: Temporal action logics language speciﬁcation and tutorial. Linköping
Electronic Articles in Computer and Information Science
ISSN 1401-9841, 3(015), 1998.
[Ferraris et al., 2007] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. A new perspective on stable models.
In Proceedings of International Joint Conference on Artiﬁcial Intelligence (IJCAI), pages 372–379, 2007.
[Ferraris et al., 2009] Paolo Ferraris,
Joohyung Lee,
Vladimir Lifschitz, and Ravi Palla. Symmetric splitting in
the general theory of stable models. 2009. This volume.

828

[Ferraris et al., 2010] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. Stable models and circumscription.11
Artiﬁcial Intelligence, 2010. To appear.
[Gelfond and Lifschitz, 1998] Michael
Gelfond
and
Vladimir Lifschitz.
Action languages.
Electronic
Transactions on Artiﬁcial Intelligence, 3:195–210, 1998.
[Janhunen and Oikarinen, 2004] Tomi Janhunen and Emilia
Oikarinen. Capturing parallel circumscription with disjunctive logic programs. In Proceedings of European Conference on Logics in Artiﬁcial Intelligence (JELIA), pages
134–146, 2004.
[Kowalski and Sergot, 1986] Robert Kowalski and Marek
Sergot. A logic-based calculus of events. New Generation Computing, 4:67–95, 1986.
[Lee and Lin, 2004] Joohyung Lee and Fangzhen Lin. Loop
formulas for circumscription. In Proceedings of National
Conference on Artiﬁcial Intelligence (AAAI), pages 281–
286, 2004.
[Lee et al., 2008] Joohyung Lee, Vladimir Lifschitz, and
Ravi Palla. A reductive semantics for counting and choice
in answer set programming. In Proceedings of the AAAI
Conference on Artiﬁcial Intelligence (AAAI), pages 472–
479, 2008.
[Lifschitz et al., 1999] Vladimir Lifschitz, Lappoon R. Tang,
and Hudson Turner. Nested expressions in logic programs.
Annals of Mathematics and Artiﬁcial Intelligence, 25:369–
389, 1999.
[Lifschitz, 1994] Vladimir Lifschitz. Circumscription. In
D.M. Gabbay, C.J. Hogger, and J.A. Robinson, editors,
Handbook of Logic in AI and Logic Programming, volume 3, pages 298–352. Oxford University Press, 1994.
[Lifschitz, 2008] Vladimir Lifschitz. What is answer set programming? In Proceedings of the AAAI Conference on
Artiﬁcial Intelligence, pages 1594–1597, 2008.
[Lin and Zhou, 2007] Fangzhen Lin and Yi Zhou. From answer set logic programming to circumscription via logic of
GK. In Proceedings of International Joint Conference on
Artiﬁcial Intelligence (IJCAI), 2007.
[Marek and Truszczyński, 1999] Victor
Marek
and
Mirosław Truszczyński. Stable models and an alternative logic programming paradigm.
In The Logic
Programming Paradigm: a 25-Year Perspective, pages
375–398. Springer Verlag, 1999.
[McCarthy, 1980] John McCarthy. Circumscription—a form
of non-monotonic reasoning.
Artiﬁcial Intelligence,
13:27–39,171–172, 1980.
[McCarthy, 1986] John McCarthy. Applications of circumscription to formalizing common sense knowledge. Artiﬁcial Intelligence, 26(3):89–116, 1986.
[Miller and Shanahan, 1999] Rob Miller and Murray Shanahan. The event calculus in classical logic - alternative axiomatisations. Electron. Trans. Artif. Intell., 3(A):77–105,
1999.
11

[Mueller, 2004a] Erik T. Mueller. Event calculus reasoning
through satisﬁability. J. Log. Comput., 14(5):703–730,
2004.
[Mueller, 2004b] Erik T. Mueller. A tool for satisﬁabilitybased commonsense reasoning in the event calculus. In
Valerie Barr and Zdravko Markov, editors, FLAIRS Conference. AAAI Press, 2004.
[Mueller, 2006] Erik Mueller. Commonsense reasoning. Elsevier, 2006.
[Niemelä, 1999] Ilkka Niemelä. Logic programs with stable
model semantics as a constraint programming paradigm.
Annals of Mathematics and Artiﬁcial Intelligence, 25:241–
273, 1999.
[Reiter, 1980] Raymond Reiter. A logic for default reasoning. Artiﬁcial Intelligence, 13:81–132, 1980.
[Shanahan and Witkowski, 2004] Murray Shanahan and
Mark Witkowski.
Event calculus planning through
satisﬁability. J. Log. Comput., 14(5):731–745, 2004.
[Shanahan, 1995] Murray Shanahan. A circumscriptive calculus of events. Artif. Intell., 77(2):249–284, 1995.
[Shanahan, 1997] Murray Shanahan. Solving the Frame
Problem: A Mathematical Investigation of the Common
Sense Law of Inertia. MIT Press, 1997.
[Shanahan, 1999] Murray Shanahan. The event calculus explained. In Artiﬁcial Intelligence Today, LNCS 1600,
pages 409–430. Springer, 1999.

http://peace.eas.asu.edu/joolee/papers/smcirc.pdf .

829

Recognizing Social Constructs from Textual Conversation
Somak Aditya and Chitta Baral and Nguyen H. Vo and Joohyung Lee and Jieping Ye,
Zaw Naung and Barry Lumpkin and Jenny Hastings
Dept. of Computer Science, Arizona State University
Richard Scherl
Dept. of Computer Science,
Monmouth University

Dawn M. Sweet
Dept. of Psychology,
Iowa State University

Abstract

chat corpuses (Shaikh et al., 2010), and developing
a socio-cultural phenomena model from discourse
with a small-scale implementation (Strzalkowski et
al., 2010). Other researchers have focused on automatically annotating social behavior in conversation
using statistical approaches (Mayfield et al., 2013).
The discourse structure of a conversation is modeled
as a Hidden Markov Model in (Stolcke, 2000) to determine dialogue acts such as Statement, Question
and Agreement. In (Prabhakaran et al., 2012) annotated email threads are presented for facilitating
detection of social relations.

In this paper we present our work on recognizing high level social constructs such as
Leadership and Status from textual conversation using an approach that makes use of the
background knowledge about social hierarchy
and integrates statistical methods and symbolic logic based methods. We use a stratified
approach in which we first detect lower level
language constructs such as politeness, command and agreement that help us to infer intermediate constructs such as deference, closeness and authority that are observed between
the parties engaged in conversation. These intermediate constructs in turn are used to determine the social constructs Leadership and
Status. We have implemented this system
successfully in both English and Korean languages and achieved considerable accuracy.

1

Daniela Inclezan
Dept. of Computer Science,
Miami University

Introduction and Related Works

The traditional information extraction paradigm has
seen success in extracting simplistic behaviors or
emotions from text. However, to detect high-level
social constructs such as leadership or status, we require robustly defined notions about language constructs that cannot always be directly inferred from
text. Hence, in this paper we focus on extracting
information from text that requires additional background knowledge and inference. There are a few
works in this direction, such as (Tari et al., 2010),
however our focus in this paper is to extract information pertaining to different social constructs from
textual conversation. The earlier research in analyzing conversations includes developing annotated

Among recent works, (Gilbert, 2012) uses linguistic cues to discover workplace hierarchy from
emails. The use of phrases to detect language use
such as “commands” is motivating. However, due
to the lack of logical explanation and robust definition, the effectiveness of this method decreases in
the semi-formally moderated Wikipedia community,
which has interplay of several different LUs such
as command, politeness and informal language. In
(Danescu-Niculescu-Mizil et al., 2012), the authors
explain how reflection of linguistic styles can shed
light on power differentials; though, a social community like Wikipedia might not always conform to
the lingustic style coordination assumption. For example, two friends who are coordinating on writing
an article may have the same status socially, but difference in their expertise will drive the conversation.
Other works such as (Gupte et al., 2011) have concentrated more on other features of the persons involved in social network, than linguistic cues. Also,
we feel that, the hierarchy depends on the task or
the context. In other words, one person could as-

1293
Human Language Technologies: The 2015 Annual Conference of the North American Chapter of the ACL, pages 1293–1298,
c
Denver, Colorado, May 31 – June 5, 2015. 
2015
Association for Computational Linguistics

sume different roles in different context. The above
works do not seem to address this. (Prabhakaran et
al., 2012) achieves a commendable accuracy in detecting overt display of “power”. However, by our
definitions, this is a lower level attribute and is similar to authoritative behavior which is a lower level
concept than Leadership or Status. Hence, their results are not directly comparable to ours.
In this paper, we use a mixture of logic-based and
statistical approaches which better encodes the domain knowledge and infers higher-level constructs
from indirect textual cues. The aim of this paper is
to formalize the theory behind our work, highlight
the advantages of integration of statistical and logicbased approaches and present results from an empirical study.

fiers (basically rules) and probabilistic generative models
(Medhat et al., 2014), (Hutto and Gilbert, 2014), (Vanzo
et al., 2014) and (Saif et al., 2012). While their accuracy
on some datasets is quite satisfactory, it is not clear how
well they do on completely unseen data.
From our experience on such classifiers, we believe
that a higher level of accuracy with explainability can
be achieved by imposing a structure that encodes background knowledge about the social hierarchy that is observed in nature. With this motivation, we built a system
whose hierarchical architecture robustly defines the social constructs, the “hidden” concepts that induce them
and their inter-connections. We define notions of intermediate Language Use (LU) and lower level Language
Indicator (LI) categories1 . With the help of these robust definitions, our system properly explains how different emotions and behaviors interact to express status
and leadership among individuals.

2

3

Motivation by a use-case

We start our discussion by presenting a use-case and
explain how results of other traditional methods inspired us to come up with an integrated approach.
Consider the following conversation from
Wikipedia where the participants discuss about a
misleading animation that is used under the topic
Convolution.

{D: Put a message on the talk page of the guy who
made it. You’re right; g(t) should be g(tau - t), and
(f*g)(t) should be (f*g)(tau).
T: I don’t think he has a talk page. He’s provided the
code so I can reproduce it. I think he’s right with (f*g)(t),
though?
D: Actually, I think we’re both wrong. You need a variable of integration running opposite directions ....
T: I’ve updated ... I guess it’s not important, but would
be kind of cool. Feel free to suggest improvements to the
animations.}
As we understand, these conversations suggest that
participant D is supposed to hold a higher rank/status
than T . If we analyze manually, we understand that
phrases like Put a message, You’re right, I think we’re
both wrong together supports our conclusion. Considered separately, the above phrases might be misleading.
To conclude the example, our system outputs :
D has a higher status than T because D demonstrates
more language uses associated with status than T. Confidence: high.
The above example illustrates the degree of contextsensitivity of our problem. The current statistical literature suggests methods such as Decision Trees, Boosting methods comprising of a collection of Weak classi-

1294

Social Constructs

Our framework supports determination of various important Social Constructs such as Leadership, Status, Group
Cohesion and Sub-Group Formation. However, due to
the length constraints of the paper, we will only discuss
Leadership and Status.

3.1

Definitions and Architecture

We begin by first formally defining the two Social Constructs and the different Language Use categories.
Leadership: A leader is someone who guides a group
toward outcomes, controls the group actions, manages interactions between members and members usually recognize the leader.
Status: Status is defined as the social position of one
person with respect to another in a group.
The principal Language Use categories that we detect
are: Deference, Closeness, Authoritative Behavior and
Motivational Behavior. The following intuitions are used
to infer such LUs from text:
Deference is understood when one uses language that
shows respect to another conversational participant or defers to another’s expertise or knowledge or authority.
Closeness is understood when one uses language that
shows familiarity with another conversationalist. It is also
indicated by dialogues where conversationalists refer to
similar events, experiences etc.
Authoritative Behavior is understood when one uses
language that shows power, dominance and control over
a situation.
Motivational Behavior is understood when one uses
language that moves conversational participants toward
1

These definitions were proposed as part of the IARPA
Socio-Cultural Content In Language(SCIL) program.

B

Explanation:

A

Social
Constructs

Means that either the
presence or absence of A
contributes to B

B
A

Leader

Status

Language
Uses
Deference

• The signed LUs that contribute towards the SC Status are ordered based on their importance. We assume the following ordering exists: authoritative
behavior > motivational behavior > negative deference > positive deference in the opposite direction
> closeness. However, we do not assume such an
ordering for the SC Leadership.

Means that only the
presence of A indicates B

Closeness

Authority
Behavior

Motivational
Behavior

Language
Indicators
Respectful
Appellation

Politeness

Impoliteness

Seeking
Support

Apologetic
Behavior

Informal
Language

Informal
Address

Indexical
Statements

Command

Expertise

Agreement

Criticism

Negative
Expertise

Resource
Allocation

Disagreement

Praise

Agenda
Setting

Our extensive research and successful implementation of
our system for different natural languages leads us to believe that these notions are universal in application.

Encouragement

5
Figure 1: Social Construct-Language Use-Language Indicator hierarchy for English Language
sharing a common goal, collaboration, problem solving
and solidarity.
In Figure 1, we present the entire hierarchy and how the
categories are connected among each other. The arrows
in the figure show which of the LI categories are used to
infer a particular type of LU. It also demonstrates how
each of the LU contributes to the Social Constructs.

4

Behind the Curtain: Our Intuitions

One of the fundamental contributions in this paper is formally describing the hierarchy to determine the Social
Constructs, as shown in Figure 1. To come up with these
interconnections and each of the different pieces of the
puzzle, we went through an iterative process of discussions with many social scientists and linguists to analyze
a large number of example conversations. In this process,
we came up with the aforementioned hierarchy, definitions of SC, LU and LIs and most importantly, the following understanding:
• The Language Indicators as shown in the Figure 1,
suffice for the detection of Leadership and Status.
• Each detected LI is associated with an Intensity
Level that helps us to encode the dissimilar effects
of different words in inferring LIs.
• Each LI is associated with a Signed Language Use.
For example, the LI politeness is associated with the
signed LU positive deference.
• Indicators of an LU with a certain sign are counterindicators of the same LU with the opposite sign.
• A signed LU may contribute either favorably or
unfavorably towards its associated SC. For example, positive authoritative behavior contributes favorably towards higher status.

1295

Fundamentals of the implementation

After we parse each sentence using Stanford Dependency
parser to get the POS tags and mutual dependencies, the
detection of individual LIs and the mapping of LIs, LUs
to SCs are achieved using a combination of statistical and
logic based approach. Many of the ideas and insights
about the detection of LIs and their relations with the LUs
are motivated from (Simon, 1946), (Pennebaker et al.,
2003) , (Bernstein, 2010) , (Brown and Levinson, 1988)
and a few others. Some of our ideas for textual inference
have been inspired by (Scherl et al., 2010).

5.1

Determining the Language Indicators

The process of detection of language indicators from sentences uses a huge ensemble of complex rules. To create
these rules, we borrowed ideas from the researchers of social science and psychology (Simon, 1946; Pennebaker et
al., 2003).
With the help of POS tags, mutual dependencies and
regular expressions, we create a framework where we detect individual events, verbs, other sentence constituents
and their positive and negative sense. On top of this
framework, we use two different methods to detect language indicators. The ideas are similar for all the LIs. We
will only present a few examples for the LI “Command”.

5.1.1

Using Regular Expressions Alone

We
use
regular
expressions
of
the
form
“.*\b[wW]hy
don’?t
(you|YOU)
(start|read|submit|make|write|get)\s*\b.*” to detect
LIs such as “Command”. We employ a collection of such
expressions to cover several different linguistic styles
which indicates “Command” by an individual.
We achieved a very high recall (close to 1.0) for most
indicators with these rules on test data. However, in few
cases, the frequency of such indicators (such as politeness) were very low deeming the set of regular expressions as incomplete. This observation led us to refine the
regular expressions with Logical rules so that we can incorporate our domain knowledge and remove such bias
to the training set.

5.1.2

Using Logical rules on Regular
Expression output and Sentence
constituents

One example of the rules we use to detect “Command”
is: if the subject of the verb is second person and the verb
is associated with a modal verb which indicates a question that suggests command, then the LI “Command” is
detected.
Examples of such verbs are “Would you” and “Could
you” etc. It is to be noted that such a verb will denote
both politeness and command depending on the rest of
the sentence. This fascinating inter-dependency is one
reason why we have to collect all such Language Indicators before we infer the higher level Language Uses.

5.2

Mapping of LIs to LUs and LUs to Social
Constructs

Input: To encode one conversation we use a collection
of facts of the form participant(X) and addresses(X, Y,
LI, Level).
These facts essentially encode the identity of the participants and the Language Indicators observed in the
overall conversation among a pair of participants.
Output: The module outputs a collection of claim, evidence and confidence mappings.
For example one such mapping is: claim_mapping(X,
"is the leader", "because", X, "demonstrates <language
use>","(Confidence: <confidence level>)"). Here <language use> is one of the language uses, <confidence
level> is either low, medium, or high.
Algorithm: We employ statistical and logic-based
procedure in parallel to get the above output. On the
statistical side, we adopt a regression technique to learn
a function that can map the scores associated with LIs
to individual LUs based on annotated training data and
this function is then applied to test data to get confidence
score on LUs. The same procedure is adopted for mapping LUs to SCs.
In parallel to this procedure, we also employ a rulebased technique that uses quantized confidence scores
and outputs confidence levels along with explanations.
As we are able to get the explanation from logical reasoning, we use the output confidence scores as votes from
statistical learning to output the final confidence level.
The rules for logical reasoning are explained as definitions and intuitions in the following paragraphs.
Mapping LIs into LUs: A signed LU is said to be
exhibited by participant X towards participant Y with a
certain degree of confidence based on the number of indicators(LI) and counter-indicators(LI) of the signed LU
used by X when addressing Y. The confidence in LU is
directly proportional to the difference between the number of indicators and counter-indicators.

1296

We categorize LUs according to the number of indicators and apply slight variation to the above rules for
each such category. Also, there are a few LIs that, when
used, automatically override the computed confidence
level for an LU and increase it to high. For example,
“criticism” increases confidence level of positive “motivational behavior” to high.
Mapping LUs to SCs: The relative status of two participants is determined based on i) the number of relevant signed LUs exhibited by each participant towards
the other, ii) the ordering of relevant signed LUs and iii)
the confidence level in each exhibited signed LU.
The leader is determined based on the number of exhibited relevant LUs (both favorable and unfavorable).
Mapping LIs to SCs: As shown in Figure 1, we directly associate some of the LIs to Social Constructs. For
such an association, we again adopt the regression technique mentioned previously. In this case, the confidence
scores from LIs are directly mapped to the confidence
scores of SCs. We combine this confidence with the
above confidence levels using simplistic rules to output
final social constructs.
It should be noted that the constants used in the rules
are obtained from statistics on annotated conversations.
The annotation process involves labels about SCs, LUs
and LIs for each conversation data.

5.3

Brief Details and Results of the Regression
Technique

In this sub-section, we provide few details of the Sparse
Logistic Regression technique we have used alongside
the logical formulation and present few results from our
experiments with relevant statistical methods. We have
used a similar formulations for mapping LIs to LUs and
LUs to SCs. Here, we provide the example of formulating the entire problem of detection of Social Constructs
directly in the Classification paradigm.
Status and Leadership can be formulated as a threeclass and two-class problem respectively. For Status,
we had 102 samples with the 38(higher), 26(equal) and
38(lower) samples each for three classes. For Leadership, we had 149 samples with 108(not-leader) and
41(leader) samples for the two classes. For both the tasks,
we extracted 28 textual features. We used the one-vs-rest
scheme for multi-class problem. For each task, we evaluated the framework as follows: i. First, we randomly
separate the dataset into training set(p) and test set(1-p).
ii. In the training set, we use 10-fold cross validation to
select proper parameters. iii. We iterate the above procedure for 100 times, and accuracy is evaluated on the predictions in all iterations. iv. We select different p (from
0.25 to 0.9) and observe the change of accuracy.
We compared the accuracy achieved using Sparse Logistic Regression with SVM(with RBF Kernel) among

is perhaps unique in determining such social constructs
and evaluating on familiar and unfamiliar datasets. Table
Table 1: Results

(a)

SC
Task Leader
Task Leader
Status
Status
Task Leader
Status

(b)

Figure 2: (a) Training set percentage vs Accuracy graph
for Leadership problem, (b) Training set percentage vs
Accuracy graph for Status classification problem.
others. The accuracy comparison of the SVM(with RBF
kernel) and sparse Logistic Regression is provided in Figure 2. As we can observe, though the two methods are
comparable, in most cases Sparse Logistic regression performs better.

5.4

Advantages from the integrated approach

The primary advantages are the following:
In general, statistical approaches need a “lot of data”
to attain a certain level of accuracy. As the rules we use
are quite universal and compact, we can achieve a comparable(or higher) accuracy with much less training data.
Using the evidence and claim mappings, we give an
“explanation” as to why we detected such a particular SC
in the dialogue. Knowldege of such depth is very hard to
achieve with only statistical approaches.
Explicit representation of “context” specific information via rules results in improved accuracy in detection of
LIs such as criticism, praise, command etc.
Statistical modules complement the rule-based approach where our domain knowledge is “incomplete”.
We use ASP as the Logic Programming language of
our choice as its ability to represent defaults and exceptions eases the implementation procedure.

6

Results

We have implemented this system using ASP(Gelfond
and Lifschitz, 1988) and Java. The Wikipedia conversations are obtained by parsing the wiki dump from
http://dumps.wikimedia.org/. We also evaluated on the NWTRB (US Nuclear Waste Technical Review Board) dataset. The accuracy and F1 measure are
summarized in Table 1 for approximately two thousand
English and one thousand Korean Wikipedia conversations. We evaluated two types of questions - i. Yes-No
indicates questions like Is John the leader? and ii. List
indicates questions such as List all the leaders.. Our work

1297

Q-Type
Y-N
List
Y-N
List
Y-N
Y-N

Language
EN
EN
EN
EN
KO
KO

Accuracy
0.8900
0.6700
0.4700
0.6923
0.5667
0.4074

F1
0.6700
0.9900
0.3457
0.5200
0.4338
0.3900

1 reports evaluations on wikipedia dump. These values
are computed by comparing the results of our systems
with annotated data. Note, in our experiments, we have
performed strict evaluations. For example, the results
are only marked positive if the complete list of leaders
matches with a human-annotated list. Also, we consider
the “explanation” too while performing the evaluation.
The results are true positive only when the detected construct is correct alongwith the explanation provided by
the reasoning module. In general, the previous research
achieves an accuracy of 0.45 in comparable tasks such as
dialog act tagging (Stolcke, 2000).

7

Conclusion

In this paper, we have proposed a novel approach for logically recognizing social constructs from textual conversations. We have used both statistical classification and
logical reasoning to robustly detect status and leadership
as observed in virtual social networks. From our experiments, we show empirically how our approach achieves
a significant accuracy and provides logical explanation of
construct detection.
This research shows the merits of using logical rules
along with statistical techniques to determine Social Constructs. As per our understanding, this level of accuracy
and explainability needs integration of both statistical and
logic based methods. Our observations suggest that there
is an increasing need for such integration in various domains. We believe that this work is one of the early steps
in that direction.

8

Acknowledgement

We thank the IARPA SCIL program for supporting this
research. We also thank NSF for the DataNet Federation
Consortium grant OCI-0940841 and ONR for their grant
N00014-13-1-0334 for partially supporting this research.

References
[Bernstein2010] Basil Bernstein. 2010. A public language: some sociological implications of a linguistic
form. British Journal of Sociology, pages 53–69.
[Brown and Levinson1988] Penelope
Brown
and
STEPHEN C. Levinson. 1988. Politeness: Some Universals in Language Usage (Studies in Interactional
Sociolinguistics 4). Cambridge University Press.
[Danescu-Niculescu-Mizil et al.2012] Cristian DanescuNiculescu-Mizil, Lillian Lee, Bo Pang, and Jon Kleinberg. 2012. Echoes of power: Language effects and
power differences in social interaction. In Proceedings of the 21st International Conference on World
Wide Web, WWW ’12, pages 699–708, New York, NY,
USA. ACM.
[Gelfond and Lifschitz1988] Michael
Gelfond
and
Vladimir Lifschitz. 1988. The stable model semantics
for logic programming. pages 1070–1080. MIT Press.
[Gilbert2012] Eric Gilbert. 2012. Phrases that signal
workplace hierarchy. In Proceedings of the ACM
2012 Conference on Computer Supported Cooperative
Work, CSCW ’12, pages 1037–1046, New York, NY,
USA. ACM.
[Gupte et al.2011] Mangesh Gupte, Pravin Shankar, Jing
Li, S. Muthukrishnan, and Liviu Iftode. 2011. Finding hierarchy in directed online social networks. In
Proceedings of the 20th International Conference on
World Wide Web, WWW ’11, pages 557–566, New
York, NY, USA. ACM.
[Hutto and Gilbert2014] C. J. Hutto and Eric Gilbert.
2014. Vader: A parsimonious rule-based model for
sentiment analysis of social media text. In ICWSM.
[Mayfield et al.2013] Elijah Mayfield, David Adamson,
and Carolyn Penstein Rosé. 2013. Recognizing rare
social phenomena in conversation: Empowerment detection in support group chatrooms. pages 104–113.
[Medhat et al.2014] W. Medhat, A. Hassan, and H. Korashy. 2014. Sentiment analysis algorithms and applications: A survey. Ain Shams Engineering Journal,
5(4):1093 – 1113.
[Pennebaker et al.2003] James
W.
Pennebaker,
Matthias R. Mehl, and Kate G. Niederhoffer.
2003. Psychological aspects of natural language use:
Our words, our selves. Annual Review of Psychology,
54(1):547.
[Prabhakaran et al.2012] Vinodkumar
Prabhakaran,
Huzaifa Neralwala, Owen Rambow, and Mona Diab.
2012. Annotations for power relations on email
threads. In Proceedings of the Eight International
Conference on Language Resources and Evaluation (LREC’12), Istanbul, Turkey, may. European
Language Resources Association (ELRA).

1298

[Saif et al.2012] Hassan Saif, Yulan He, and Harith Alani.
2012. Semantic sentiment analysis of twitter. In Proceedings of the 11th International Conference on The
Semantic Web - Volume Part I, ISWC’12, pages 508–
524, Berlin, Heidelberg. Springer-Verlag.
[Scherl et al.2010] R. Scherl, D. Inclezan, and M. Gelfond. 2010. Automated inference of socio-cultural
information from natural language conversations. In
IEEE International Conference on Social Computing,
pages 480–487, Aug.
[Shaikh et al.2010] Samira Shaikh, Tomek Strzalkowski,
Aaron Broadwell, Jennifer Stromer-Galley, Sarah Taylor, and Nick Webb. 2010. Mpc: A multi-party chat
corpus for modeling social phenomena in discourse.
In Proceedings of the Seventh International Conference on LREC, may.
[Simon1946] Herbert A. Simon. 1946. The proverbs
of administration. Public Administration Review,
6(1):53–67.
[Stolcke2000] Andreas Stolcke. 2000. Dialogue act modeling for automatic tagging and recognition of conversational speech.
[Strzalkowski et al.2010] Tomek
Strzalkowski,
George Aaron Broadwell, Jennifer Stromer-Galley,
Samira Shaikh, Sarah M. Taylor, and Nick Webb.
2010.
Modeling socio-cultural phenomena in
discourse. In COLING 2010, 23rd International
Conference on Computational Linguistics, pages
1038–1046.
[Tari et al.2010] Luis Tari, Saadat Anwar, Shanshan
Liang, James Cai, and Chitta Baral. 2010. Discovering drug-drug interactions: a text-mining and reasoning approach based on properties of drug metabolism.
Bioinformatics, 26(18).
[Vanzo et al.2014] Andrea Vanzo, Danilo Croce, and
Roberto Basili. 2014. A context based model for sentiment analysis in twitter. In Proceedings of COLING
2014, pages 2345–2354, Dublin, Ireland. Dublin City
University and Association for Computational Linguistics.

386

IEEE COMMUNICATIONS LETTERS, VOL. 16, NO. 3, MARCH 2012

Energy Efficient Cooperative Multicast Scheme Based on Selective Relay
Joohyung Lee, Young Mi Lim, Kwihoon Kim, Seong Gon Choi Member, IEEE,
and Jun Kyun Choi, Senior, IEEE

Abstract—Multicast communication has been researched for
many years in efforts to simultaneously achieve high throughput
and good fairness, which have a trade-off relationship. Recently, a
cooperative multicast scheduling scheme was proposed. It is considered a promising solution owing to its trade-off characteristics
realized by promoting user cooperation among group members.
However, it requires significant relay power consumption for user
cooperation, since all group members in a good channel condition
should relay without checking whether there is at least one user
requesting a relay in the transmission boundary. Therefore, in
order to resolve this inefficiency, we proposed an energy efficient
cooperative multicast scheme (EECM) based on selective relay.
We can achieve reduced unnecessary relay power expenditure
by selecting relay users with consideration of the condition of
nearby users. The performance results derived from a numerical
analysis reveal that the proposed scheme requires less energy
consumption than the existing solution with almost the same
throughput performance.
Index Terms—Cooperative communications, multicast scheduling, energy consumption.

I. I NTRODUCTION
S THE demand for broadband multimedia service over
wireless networks grows around the world, multicast
communication, where the same content is transmitted to
multiple receivers simultaneously, has emerged as a key technology in next generation cellular networks [1]. At the same
time, with much attention directed towards energy efficient
communication, energy efficiency is an important consideration in multicast design along with bandwidth efficiency.
To date, most research issues for multicast communication
have focused on enhancing fairness between group members
and overall throughput. However, these two metrics (fairness,
throughput) have a trade-off relationship. For example, to
guarantee user fairness, a Base Station (BS) should select
the minimal supported rate of all Multicast Group (MGroup)
members, even if it underutilizes wireless resources. If the
BS wants to enhance throughput, it should pay for fairness
performance to improve wireless resource utilization and provide quality of service (QoS) [2]. Recently, to simultaneously

A

Manuscript received November 22, 2011. The associate editor coordinating
the review of this letter and approving it for publication was Z. Z. Lei.
This work was supported by the IT R&D program of
MKE/KEIT(KI001822) and (10039160).
J. Lee, Y. M. Lim, and J. K. Choi are with the Dept. of Electrical
Engineering, KAIST, Daejeon, 305-701 Rep. of Korea (e-mail: {joohyung08,
ymlim86, jkchoi59}@kaist.ac.kr).
K. Kim is with the Broadcasting & Telecommunications Convergence
Future Technology Research Department, ETRI, South Korea (e-mail: kwihooi@etri.re.kr).
S. G. Choi is with the Department of Electrical Engineering, Chungbuk National University, Cheongju, 361-763 Rep. of Korea (e-mail: sgchoi@cbnu.ac.kr).
Digital Object Identifier 10.1109/LCOMM.2012.011312.112375

improve both fairness and throughput, one approach to the
problem is to use a cooperative multicast scheduling scheme
by conducting user cooperation among MGroup members [2].
Research on cooperative multicast scheduling scheme consists of network-coding-based cooperation and space-time
coded cooperation [2]–[4]. Note that, our research focuses on
the multicast of one packet, which is delay sensitive. In the
delay-sensitive nature of the traffic, network-coding may not
be appropriate because the waiting time for a batch of packets
may not be tolerable [3]. Thus, we stay within the spacetime coded coopeartion based on a two-phase cooperative
transmission model.
A previous cooperative multicast scheduling scheme [2]
attempted to efficiently exploit spatial diversity among multiple users. Although it offers good performance in terms
of throughput and fairness, there is a lack of consideration
of energy consumption. Notably, it requires significant relay
power consumption for user cooperation. All group members
in a good channel condition should relay the received data,
even if there is no group member in a bad channel condition
who requests a relay. Thus, we propose the Energy Efficient
Cooperative Multicast (EECM) scheme based on selective
relay. The proposed scheme considers that a relay user can
recognize the nearby user condition (e.g., check whether there
is at least one user requesting a relay in the transmission
boundary). Therefore, we can reduce unnecessary relay power
consumption by selecting relay users.
In this letter, on the basis of results of a numerical analysis,
it is shown that the proposed scheme offers less energy
consumption (about 10-18%) than the existing solution with
almost the same throughput performance.
II. S YSTEM M ODEL AND E NERGY E FFICIENT
C OOPERATIVE M ULTICAST (EECM) S CHEME
The overall system model for the EECM scheme is shown
in Fig. 1. To explain the proposed scheme, we define a set of
users by
Definition 1. Ug is the set of users with a good channel
condition who can successfully receive the data in phase I.
In addition, these users can be possible to be relay users.
Definition 2. Ub is the set of users with a bad channel
condition who cannot successfully receive the data in phase
I.
We consider that our scheme follows a two-phase cooperative communication: a transmission burst assigned for
multicast transmission in same channel is divided into two
phases; in phase I, the BS transmits the data to the users; in

c 2012 IEEE
1089-7798/12$31.00 

LEE et al.: ENERGY EFFICIENT COOPERATIVE MULTICAST SCHEME BASED ON SELECTIVE RELAY

Target SNR
boundary

relay

relay

x

BS
BS

T

BS
BS

r0

relay

rrelay


CEQPXGPVKQPCN%/5
%/5%QQRGTCVKXG/WNVKECUV5EJGOG

Fig. 1.


DRTQRQUGF''%/5EJGOG
''%/'PGTI['HHKEKGPV%QQRGTCVKXG/WNVKECUV

System model for energy efficient cooperative multicast scheme.

Phase II, the users who successfully received the data in phase
I forward the received data to the other users [1], [2].
As shown in Fig.1 (a), in the conventional scheme, because
all users in Ug pacticipate in relaying, there is unnecessary
relay power consumption. As seen in Fig. 1 (b), unlike this
inefficiency of the conventional scheme, the proposed scheme
selects relay users if there is at least one user requesting a relay
in the transmission boundary in order to reduce unnecessary
relay power consumption. Especially, if one user in Ub locates
simultaneously within the range of two or more users in Ug
(e.g., overlapped range), simply all those users in Ug should
transmit the data in the proposed scheme. For future work, we
will extend our proposed scheme by selecting an optimal user
in Ug for this case.
In order to address implementation concerns for EECM,
we could apply Location Based Service (LBS) technology
in 802.16m for searching nearby Ub who experienced a bad
channel condition. In particular, among the various technologies for LBS, there are techniques to use a beacon frame and
signaling such as Uplink - Time Difference Of Arrival (UTDOA) [5]. The proposed EECM scheme is based on method
to use a beacon frame to search nearby Ub . In this case, we
add the beacon frame between phase I and phase II in order
to achieve a selective relay. In addition, a beacon frame is
divided into two stages. In the first stage of the beacon frame,
the BS multicasts the beacon frame to search Ub . In other
words, the BS wants to check which users do not receive the
data in phase I due to a bad channel condition. After that, in
the second stage, Ub broadcasts the beacon frame to nearby
users in Ug . Therefore, in phase II, users in Ug that obtain
the beacon frame from nearby users in Ub should relay the
received traffic to nearby users in Ub .
Notably, adding the beacon frame in the downlink burst
to sense nearby users in Ub imposes some overhead in the
time slot. This often causes degraded throughput depending on
the beacon frame size. However, the overhead for the beacon
frame is generally small. Based on [5], the overhead for the
beacon frame in the downlink is almost 3.23 %. Furthermore,
through a numerical analysis, we can express that this problem
has a much smaller effect on performance than does reducing
relay power consumption. Finally, we can reduce unnecessary
relay power expenditure by selecting relay users.
III. P ERFORMANCE A NALYSIS
We consider a cellular system with a cell radius rc . The
total L active users are uniformly distributed with a probability

387

density function (pdf) of distance r from the BS, which is
expressed as
2r
0 < r ≤ rc .
(1)
fr (r) = 2 ,
rc
The transmitted signals experience both path loss and
Rayleigh fading. In addition, we assumed that users in
MGroup received thermal noise. The probability density function (pdf) of the received Signal to Noise Ratio (SNR) value
z of the users at a given distance r is derived in [6] and is
expressed as
rn
rn z
exp(−
),
(2)
fz|r (z|r) =
ρ0
ρ0
where n is the path loss exponent and ρ0 is the ratio of
transmission power to received noise power.
We can ensure that the pdf of users in Ub with the given r
is the same as the probability that users with the given r will
not satisfy the target SNR (SN RT H ). Therefore, equation (2)
is expressed as a cumulative distribution function (cdf),
rn
(3)
Fz|r (SN RT H |r) = 1 − exp(−SN RT H ( )).
ρ0
A. Relay power consumption for proposed EECM scheme
Here, we address the selection probability (Psel ) for relaying the received data to the nearby users in Ub . To obtain
Psel , we first mention the conditional probability (Psel |x) for
relaying data with given Ug . In detail, Psel |x means that a
certain user in Ub exists with the given user’s transmission
boundary in Ug . The method to calculate this probability
is described in Fig. 1. (b). We estimated that the probability
that users in Ub would be located in the gray circle is similar
to the probability that users in Ub would be located in the
approximated area. The probability that a user in Ub exists
within a given user’s transmission boundary in Ug is expressed
as
 x+β
θ
fr (r) · Fz|r (SN RT H |r)dr,
(4)
Pf =
2π x−β
where x is the distance from the BS to certain users in Ug ,
r0 is the relay transmission coverage of users, θ=arcsin(r0 /x)
and β=r02 π 2 /4.
Among L users, there exist at least one user in Ub with a
given user’s transmission boundary in Ug as follows as
Psel|x = 1 − (1 − Pf )L−1 .

(5)

Therefore, from (5), Psel is expressed as
 rc
Psel|x · fr (x) · (1 − Fz|x (SN RT H |x))dx.
Psel =

(6)

0

Because Psel is the integration of selection probability for
relay through whole place with uniform distribution, from (6),
the overall transmission power of users for relay (P owerusum )
in MGroup (by getting the expected number of relay user in
BS coverage) is expressed as
P owerusum = Psel · L · P oweru ,

(7)

where, P oweru is transmission power of one user in MGroup.
Finally, we can determine the total power consumption in
the EECM scheme which includes the BS power consumption
(P owerBS ) with varying target coverage and P owerusum .

388

IEEE COMMUNICATIONS LETTERS, VOL. 16, NO. 3, MARCH 2012

EECM
CMS

0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
10

15

20

25

30

35

40

0.8

0.7

1

EECM
CMS
Conserve

0.6

0.5

0.4

0.3

0.2

0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1

0.1
10

Number of Users in a MGroup

15

20

25

30

35

Number of Users in a MGroup

(a)
Fig. 2.

EECM
CMS
Conserve

0.9

Normalized Throughput

Normalized Power Consumption

Selection Probability for Relay

1
0.9

(b)

40

0
10

15

20

25

30

35

40

Number of Users in a MGroup

(c)

(a) Selection probability for relay; (b) total transmit power consumption; (c) normalized throughput versus the total number of group members.

TABLE I
S YSTEM PARAMTERS
System Paramters

Value/Assumption

Channel bandwidth

10 MHz

Frequency band

3.5 GHz

Transmission power of BS

43 dBm

Transmission power of users in MGroup

34.8 dBm

Pass loss exponent n

2

Noise power

-128 dBm

Coverage ratio

50%

BS coverage

8 km

the condition of nearby users. Based on selection probability,
we show the total power consumption (the relay and BS power
consumption) versus the total number of group members in
Fig. 2 (b). The proposed EECM scheme can achieve at least
a 10% power consumption reduction by reducing unnecessary
relay power expenditure. In Fig. 2 (c), we compare the
proposed scheme with the conventional scheme in terms of
throughput. Although there are some minor negative effects of
EECM (e.g., beacon overhead, relay failure probability), the
comparison shows that our scheme does not need to sacrifice
throughput in order to reduce power consumption.
V. C ONCLUSION

B. Throughput for proposed EECM scheme
For a throughput analysis of the proposed EECM scheme,
the total throughput of MGroup for the proposed scheme
consists of summation between throughput in phase I and
phase II, following the throughput analysis in [2]. Thus,
because adding the beacon frame between phase I and phase
II in the downlink burst necessitates some minor modification
for the throughput analysis, we omit the detailed procedure of
the throughput analysis.
IV. N UMERICAL R ESULTS
We compare the performance of the proposed EECM
scheme with that of the conventional Cooperative Multicast
Scheme (CMS) and the scheme specified in 3GPP (denoted
as Conserve ) by Matlab. A numerical analysis is set up with
the parameters shown in Table I [2].
We assumed that every user is uniformly distributed in the
coverage area of the BS and the probability of relay failure
is almost 0.01 [7]. The vertical axis is the achieved energy
consumpiton normalized by the maximum value. In Fig. 2 (a),
selection probability for relay of EECM is smaller than that of
CMS which is static value 0.5 (we set the BS coverage ratio as
50%), because EECM selects effective relay users by sensing

In this letter, we have proposed a novel energy efficient
cooperative multicast scheme based on selective relay control.
Using the proposed scheme, we can achieve reduced unnecessary relay power expenditure by selecting relay users with
consideration of the condition of nearby users.
R EFERENCES
[1] T. Han and N. Ansari, “Energy efficient wireless multicasting,” IEEE
Commun. Lett., vol. 15, no. 6, pp. 620–622, June 2011.
[2] F. Hou, L. X. Cai, P. H. Ho, X. Shen and J. Zhang, “A cooperative
multicast scheduling scheme for multimedia services in IEEE 802.16
networks,” IEEE Trans. Wireless Commun., vol. 8, no. 3, pp. 1508–1519,
Mar. 2009.
[3] B. Niu, H. Jiang, H. V. Zhao, “A cooperative multicast strategy in wireless
networks,” IEEE Trans. Veh. Technol., vol. 59, no. 6, pp. 3136–3143, July
2010.
[4] H. V. Zhao, S. Weifeng, “Cooperative wirelss multicast: performance
analysis and power/location optimization,” IEEE Trans. Wireless Commun., vol. 9, no. 6, pp. 2088–2100, June 2010.
[5] IEEE 802.16m, “WirelessMAN - Advanced Air Interface for Broadband
Wireless Access Systems,” www.ieee802.org, Aug. 2011.
[6] S. Y. Baek, Y. J. Hong, and D. K. Sung, “Adaptive transmission scheme
for mixed multicast and unicast traffic in cellular systems,” IEEE Trans.
Veh. Technol., vol. 58, no. 6, pp. 2899–2908, July 2009.
[7] J. Luo, R. S. Blum, L. J. Cimini, L. J. Greenstein, and A. M. Haimovich,
“Link-failure probabilities for practical cooperative relay networks,” 2005
IEEE VTC.

IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY, VOL. 63, NO. 4, MAY 2014

1843

Power-Efficient Load Distribution for Multihomed
Services With Sleep Mode Over Heterogeneous
Wireless Access Networks
Joohyung Lee, Nga T. Dinh, Ganguk Hwang, Member, IEEE, Jun Kyun Choi, Senior Member, IEEE, and
Chimoon Han, Member, IEEE

Abstract— The use of multi-interfaced devices has been steadily
increasing due to the popularity of multihomed streaming services in heterogeneous wireless access networks. However, running
multiple interfaces simultaneously in a mobile terminal (MT)
may cause serious battery drain even when interfaces employ
sleep modes. In addition, sleep modes may result in significant
degradation of the quality of service (QoS) in terms of packet delay
or jitter. This paper examines multihomed MTs and the use of data
stripping load distribution across the multiple wireless interfaces
of the MTs to minimize their power consumption. This paper then
develops a theoretical framework for a power-efficient multipath
load distribution that encompasses a dynamic load distribution
to each interface employed with sleep mode. For this purpose,
the paper first presents analytical models for power consumption and the delay of each interface by considering a medium
access control (MAC) operation. Using these models, two simple
greedy distribution algorithms are proposed to optimize the load
distribution. Extensive simulations in an ns-2 simulator under
various practical configurations demonstrate that the proposed algorithms significantly reduce power consumption while satisfying
QoS constraints.
Index Terms—Heterogeneous wireless access networks, load
distribution, packet reordering (PR), power consumption.

Manuscript received June 23, 2012; revised June 14, 2013, August 4,
2013, and October 7, 2013; accepted October 27, 2013. Date of publication
November 6, 2013; date of current version May 8, 2014. This work was
supported in part by the Korea Evaluation Institute of Industrial Technology
of the Ministry of Knowledge and Economy of Korea through the Information
and Technology Research and Development Program under Grant 10039160
(Research on Core Technologies for Self-Management of Energy Consumption
in Wired and Wireless Networks) and in part by the Seoul Metropolitan
Government through the Research and Business Development Program under
Grant WR080951. An earlier version of this paper was presented at the
IEEE Global Communications Conference (Selected Areas in Communications
Symposium—Green Communication Systems and Network Track), Houston,
TX, USA, December 2011. The review of this paper was coordinated by
Prof. F. R. Yu.
J. Lee and J. K. Choi are with the Department of Electrical Engineering,
Korea Advanced Institute of Science and Technology, Daejeon 305-701, Korea
(e-mail: joohyung08@kaist.ac.kr; jkchoi@ee.kaist.ac.kr).
N. T. Dinh is with Bell Labs Seoul, Seoul 120-270, Korea (e-mail:
dinh.nga@alcatel-lucent.com).
G. Hwang is with the Department of Mathematical Sciences, Korea Advanced Institute of Science and Technology, Daejeon 305-701, Korea (e-mail:
guhwang@kaist.edu).
C. Han is with the Department of Electronics and Information Engineering, Hankuk University of Foreign Studies, Daejeon 305-701, Korea (e-mail:
cmhan@hufs.ac.kr).
Color versions of one or more of the figures in this paper are available online
at http://ieeexplore.ieee.org.
Digital Object Identifier 10.1109/TVT.2013.2289390

I. I NTRODUCTION

T

HE DEMAND for broadband multimedia services (e.g.,
Internet Protocol and Smart TVs) over wireless access
networks is dramatically increasing with the widespread adoption of multi-interfaced devices such as smartphones and PC
tablets. Users can easily access multimedia content anytime
and anywhere through such multi-interfaced handheld devices
by securing the required bandwidth from all available wireless
access networks using multihoming capabilities. Multihoming
is a promising solution for heterogeneous wireless access networks due to its many benefits, including load balancing and
reliability [1].
There are various approaches to realizing efficient load distribution solutions that address the QoS in multi-interfaced
devices with multihoming capability by taking advantage of
heterogeneity and a high degree of network connectivity. The
major problems with these approaches are load imbalance and
packet reordering (PR) [2], [3]. Additionally, running multiple
interfaces simultaneously can significantly reduce the battery
life of a mobile terminal (MT). To the best of our knowledge,
there has been no significant research on load distribution
over heterogeneous wireless access networks to simultaneously
meet QoS requirements and improve power efficiency. Load
distribution in multihoming thus remains an open issue, and this
is the inspiration for this paper.
To reduce the power consumption of MTs, a sleep mode
is employed on the medium access control (MAC) layer in
wireless access networks [4]. Existing solutions have considered the optimization problem of the sleep duration with a
given load for different wireless access networks (e.g., 802.16,
802.11, etc., [5]–[8]). However, these solutions consider only a
single interface. Hence, they are not applicable to multihoming
situations. In addition, there have been no studies on load distribution on those devices where sleep mode is employed for each
interface.
In this paper, we propose novel load distribution algorithms
for multihomed services. To overcome the limitations of conventional solutions, the proposed scenario includes a multiinterfaced device with multihoming capability, and each of the
interfaces employs a sleep-mode mechanism to reduce power
consumption. Here, a multi-interfaced device decides how to
distribute the load from all available wireless access networks
to minimize its power consumption while guaranteeing the

0018-9545 © 2013 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

1844

IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY, VOL. 63, NO. 4, MAY 2014

required QoS. The contributions of this paper are summarized
as follows:
• This paper presents analytical models for power consumption and delay for different kinds of interfaces of an MT
and describes their performance.
• Two novel power-efficient load distribution (PELD) algorithms for multihomed services are proposed. In particular,
the paper first formulates the optimization problem for
minimizing power under the delay requirement. The algorithm is then extended to alleviate the reordering problem
with delay difference boundary condition.
• Basically, the proposed optimization problem is nonconvex. Thus, effective greedy distribution algorithms to find
an optimal solution are considered.
• NS-2 based simulation results are provided to demonstrate
the effectiveness of the proposed greedy algorithms by
presenting how much the power consumption is reduced,
whereas other important performances such as packet loss
rate and delay are reasonably guaranteed.
The remainder of this paper is organized as follows.
Section II summarizes previous works on load distribution for
multihoming and sleep mode for an MT. Section III presents
models for power consumption and delay, and explains their
performance under different scenarios. Based on these models, the load distribution algorithms are then described in
Section IV. A simulation evaluation is provided in Section V.
Finally, Section VI concludes this paper.
II. R ELATED W ORK
A. Load Distribution Techniques in Multihoming
An introduction to load distribution techniques in multipath
networks and related challenges and issues can be found in [3].
Notably, because load distribution techniques can affect various
system performances such as throughput, load balancing, and
PR, it has attracted a tremendous amount of research. Early
studies on load distribution over multipath networks focused
on designing a stripping mechanism in different layers such as
transport or network layers [9], [10]. However, these studies did
not consider QoS, cost, latency, etc., in various applications.
Thus, to address these shortcomings, various approaches to
load distribution over multipath networks have been suggested.
The most well-known approach is the round robin (RR)-based
scheme [2], which focuses on the load balancing problem by a
fair load distribution. However, such approaches are not able
to maintain per-flow packet ordering. Furthermore, although
the least-loaded-based scheme [11] is one of the most wellknown algorithms, it does not consider the order of packets.
In the load distribution over multipath networks, a large delay
difference among different paths results in a high risk of PR,
leading to large latency, buffer size, and PR processing power.
To resolve the reordering problem, Prabhavat et al. [3] proposed
the effective delay-controlled load distribution (E-DCLD) algorithm, which minimizes the reordering risk by minimizing
the difference of delay in multipath networks. Recently, novel
performance analyses of probabilistic multipath transmission of
video streaming traffic were proposed in terms of the average

delay, delay jitter, and delay outage probability in [12]. In other
studies [1], a novel distributed multiservice resource-allocation
algorithm in multihoming services was proposed. Here, both
constant and variable bit-rate services were considered, as
well as different resource access priorities; however, the power
efficiency of load distribution over multiple interfaces was ignored. In this sense, in homogeneous wireless access networks,
Zhao and Xie [13], [14] proposed a power-efficient design on
the upper network layers by considering power consumption
caused by the location update procedure where an MT’s sleep
and active mode are employed. Moreover, in heterogeneous
wireless access networks, a power-minimized rate-allocation
scheme was proposed in [15]; although this work suggests the
possibility of reducing power consumption of multi-interfaced
devices, detailed MAC operations (e.g., sleep mode) and PR
were not considered.
B. Sleep Mode in the MAC Layer
Sleep mode has been extensively studied in World Interoperability for Microwave Access (WiMAX) and wireless local area
networks (WLANs). In WiMAX, sleep mode is specified differently for different power saving classes, which vary by parameter sets, procedures of sleep-mode activation/deactivation, and
policies for data transmission of an MT [16]. Xiao evaluated
sleep-mode performance in WiMAX [17] in terms of average
energy consumption and response delay. In [18], the sleep-state
duration is adjusted by considering the previous sleep-state
duration under light traffic conditions. Unfortunately, these
approaches result in worse delay than the original sleep mode
when traffic is high, although power efficiency is improved.
Han and Choi [19] numerically analyze the sleep mode using
a Markov chain and derive the packet delay and power consumption for sleep, listening, and waking-up states. Analytical
studies have been carried out to find the optimal sleep duration to minimize the power consumption while guaranteeing
required QoS [5]–[7]. Unlike in WiMAX where sleep-state
duration can be changed [17], in WLANs, sleep-state duration
is basically fixed. A WLAN is a shared medium communication, requiring the sending of a polling message to retrieve the
buffered traffic. This results in competition among MTs that
have pending packets [8], [20]. This competition affects the
delay in accessing the medium and the power consumption.
In [8], Lei and Nilson describe two models for WLAN power
management to achieve good energy efficiency with minimal
QoS degradation: the M/G/1 queue with a bulk service model
and the D/G/1 queue model. Baek and Choi extended the study
of power saving mode in [8] to include a simple derivation of
the mean and the variance of packet delay [20].
To the authors’ knowledge, no previous studies have addressed the power efficiency and sleep mode in MAC in relation
to load distribution for multihoming. The existing research
activities on load distribution have been confined to the scope of
the throughput or QoS optimization problem, although multiple
interfaces may have different MAC operations and thus affect
the power efficiency. This paper investigates both the load
distribution problem and detailed sleep mode at each interface
for multihoming conditions. In this paper, we stay within the

LEE et al.: PELD FOR MULTIHOMED SERVICES WITH SLEEP MODE OVER WIRELESS ACCESS NETWORKS

TABLE I
N OTATION FOR F ORMULATION

1845

the proposed algorithms. Basically, our system design follows
[22], [23], where the load distribution scheduler is located in
an MT. The main difference is that the proposed algorithms
additionally collect the estimated power consumption at each
interface for a power-efficient load distribution. The detailed
procedures entail four steps. First, to check the required QoS
and load λ, an application interface recognizes an application
type currently running on the MT. Second, a load information λ
of the application is passed on to the load distribution scheduler.
Third, the load distribution scheduler calculates the optimal
splitting vector ψi according to the estimated power consumption and delay. Finally, the application service is requested from
the server by splitting the load over each interface i using ψi . A
more detailed discussion of the system design can be found in
[22] and [23].
Fig. 2(a) and (b) shows the sleep modes in WiMAX and
WLAN, respectively, where an MT repeatedly alternates between sleep and wake modes to reduce power. In WiMAX,
a sleep mode includes a number of sleep cycles, where each
sleep cycle is composed of a sleep-state duration Tl (l = 1,
2, . . .) that is adjusted on a binary-exponentially basis [16]
and a listening-state duration TL . In WLAN, a sleep cycle is
basically fixed as listen interval L, which is a multiple of beacon
intervals B. In sleep mode, an MT alternately enters between a
sleep state, where it powers down most of its functions, and a
listening state, where it powers up the receiver to check whether
there were packets addressed to it while in the sleep state. If
there is a packet for that MT, the packet is put into the MT’s
base station (BS) queue. The MT then transits into wake mode;
otherwise, the MT sleeps again. Specifically, in WLAN, due to
the competitive nature on a shared medium, to retrieve packets,
an MT stays awake and sends a polling message [8], [20].
A. Models for WiMAX Interface

Fig. 1.

Description of PELD.

optimization framework for a power-efficient load distribution
with varying constraints and compare the performance of the
proposed algorithms to that of previous approaches.
III. S YSTEM M ODELS
Here, we present our scenarios and analytical models for
power consumption and delay for each interface in a multihomed MT. In this paper, the analysis is restricted to downlink
traffic. The notation is summarized in Table I. Two sets of interfaces are considered: I = {I1 , I2 }. Note that this interface set
I can be classified into two categories, i.e., I1 (WiMAX) and
I2 (WLAN). It is assumed that the holding rate μi at interface i
is exponentially distributed and that packets arriving at an MT
follow a Poisson distribution with rate λ [3], [21]. The arrival
rate λ is then partitioned as rate λi over each interface i by
a splitting vector ψi (λi = λψi ), where an MT computes the
optimal splitting vector ψi over each interface i to minimize
the total power consumption of all interfaces while satisfying
delay requirements. Fig. 1 shows a functional block diagram of

1) Power Consumption: We consider the case where interface i (i ∈ I1 ) transitions from sleep mode to wake mode
after k sleep cycles. This happens when there are no downlink
packets arriving at interface i during the first (k − 1) sleep
cycles and at least one packet arrives during the kth sleep cycle.
Let Tl,i and TL,i be the sleep-state duration and listening-state
duration of the l th sleep cycle in sleep mode at interface
i, respectively. In WiMAX, Tl,i varies from the initial sleepstate duration Tmin,i to the final sleep-state duration Tmax,i
on a binary-exponentially basis [16]. Let P rk,i (λi ) be the
probability of the sleep-to-wake transition with a given rate λi ;
then, P rk,i (λi ) is determined such that

with k = 1
1−e−λi (TC1,i ) ,

P rk,i (λi ) = −λi k−1 (TCl,i ) 
−λi (TCk,i )
l=1
1−e
, otherwise
e
(1)
where notation TCk,i is the duration of the kth sleep cycle
and equal to Tk,i + TL,i . Note that e−λt is the probability that
there is no packet arriving during t according to a Poisson
distribution [24].
When interface i transitions from the kth sleep cycle to wake
mode, it must spend an average amount of time T Nk,i in wake

1846

IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY, VOL. 63, NO. 4, MAY 2014

Fig. 2. Description of sleep operation of (a) WiMAX and (b) WLAN interfaces.

mode to process all packets in its BS queue. Let Nk,i denote
the average number of packets arriving during interface i’s kth
sleep cycle. Note that these packets include: 1) packets arriving
during interface i’s sleep time, and 2) packets that newly arrive
while the interface i is processing packets in the queue. prm (t)
denotes the probability that there are m packets arriving during
time t; then, according to a Poisson distribution, prm (t) is
determined such that [24]
prm (t) = e−λi t (λi t)m /m!.

Nk,i = E[nk,i |nk,i ≥ 1]
∞


T Nk,i =

E[nk,i |nk,i = m, nk,i ≥ 1]

1
(Nk,i + N Ek,i ).
μi

T Nk,i (λi ) =

=

∞


E[nk,i |nk,i

m=1

=

∞

m=1

m·

ξiI1 (λi )

P {nk,i = m, nk,i ≥ 1}
= m]
P {nk,i ≥ 1}

prm (T Ck,i )
1 − P r0 (T Ck,i )

Nk,i
.
μi − λi

(5)

Let PS,i and PL,i be the consumed power at interface i
during sleep and listening states, respectively. In addition,
assume that the power needed for an interface to transition
from one state to another can be negligible; the average power
consumption of interface i (ξiI1 ) (i ∈ I1 ) can be then calculated
as follows:
k


m=1

× P {nk,i = m|nk,i ≥ 1}

(4)

By Little’s law [24], N Ek,i = λi · T Nk,i ; we obtain

(2)

Let nk,i be the number of packets arriving during the interface
i’s kth sleep cycle. Then, Nk,i is

=

Let N Ek,i be the average total number of newly arrived
packets while interface i is in wake mode after the kth sleep
cycle in sleep mode. Since the average processing rate is μi ,
T Nk,i is given by

=

∞

k=1

P rk,i (λi )

(P Cl,i ) + T Nk,i (λi )PL,i

l=1
k


(6)
(T Cl,i ) + T Nk,i (λi )

l=1

(3)

where, m is the number of packets in the queue, and
prm (T Ck,i ) is the probability that there are m packets during
the interface i’s kth sleep cycle.
In (3), the MT wakes up after kth sleep cycle only if there
is at least one packet in the queue. Therefore, it is necessary
to take the conditional probability as in (3). Accordingly, the
denominator in (3) is used to guarantee that there is at least one
packet in the queue.

where, Tl,i PS,i + TL,i PL,i = P Cl,i is the energy consumption
during the l th sleep cycle at interface i. In the kth term in (6),
P rk,i (λi ) is the probability that interface i is in sleep mode
for k cycles, the numerator is the energy consumption in sleep
mode including k cycles and in wake mode for duration T Nk,i
to transmit all downlink packets, and the denominator is the
total duration that interface i is in sleep and wake modes.
2) Delay: The mean service delay at interface i caused by
sleep mode includes two kinds of delay: 1) mean delay TD1,i
for interface i to transition from sleep mode to wake mode and
2) mean queuing delay TD2,i that a given packet needs to wait
to process all its previous packets in the BS queue.

LEE et al.: PELD FOR MULTIHOMED SERVICES WITH SLEEP MODE OVER WIRELESS ACCESS NETWORKS

Fig. 3.

arriving packets, forcing the MT to more frequently transition
from sleep mode to wake mode. Furthermore, the MT requires
more time in wake mode to process those packets. Since power
in wake mode is higher than that in the sleep state or the
listening state, the power consumption increases. It is also
shown in Fig. 3 that delay decreases with the increase in
network load (packet arrival rate increases). It is due to that,
as the packet arrival rate increases, TD1,i becomes smaller due
to shorter sleep-cycle duration. In addition, because the sleepcycle duration becomes smaller, the required time to process
the arrived packets during the sleep-cycle duration is negligible
in a moderate arrival region. Consequently, TD2,i can be also
negligible. In a high arrival rate, the processing time could not
be negligible. However, this is outside the scope of this paper.

Average power consumption and delay of WiMAX.

Suppose that the MT spends k sleep cycles in sleep mode,
which happens with probability P rk,i (λi ). We divide the k
sleep-state duration T Ck,i into K small equal subintervals,
where K is sufficiently large. Then, the duration that a packet
arriving during the lth subinterval has to wait for an MT
to transition from sleep mode to wake mode is (T Ck,i −
l(T Ck,i /K)). In this case, the mean transition delay is

K 
T Ck,i
1 
T Ck,i
T Ck,i
−
.
T Ck,i − l
=
K
K
2
2K

(7)

l=1

Since limK→∞ (T Ck,i /(2K)) = 0, (7) becomes T Ck,i /2, and
TD1,i is determined as follows:
TD1,i (λi ) =

∞


P rk,i (λi )

k=1

T Ck,i
.
2

(8)

Now, we assume that there are l packets in the 
queue;
this event happens with probability (prl (T Ck,i ))/( ∞
m=1
prm (T Ck,i )). For the jth packet (1 ≤ j ≤ l), the time needed
to process (j − 1) previous packets is ((j − 1)/μi ). The mean

time that each packet needs to wait is li=1 (j − 1/2μi ). Therefore, TD2,i is given by
TD2,i (λi ) =

∞

k=1

P rk,i (λi )

∞

l−1
l=1

prl (T Ck,i )
. (9)
∞
2μi 
prm (T Ck,i )
m=1

Let ϕIi 1 be the total mean delay of a packet at interface i
caused by sleep mode; then, it is determined such that
ϕIi 1 (λi ) = TD1,i (λi ) + TD2,i (λi ).

1847

(10)

3) Numerical Results: We evaluate the average power consumption and delay for the WiMAX interface using our analytical model. Fig. 3 shows the average power consumption
and delay in the WiMAX interface as a function of network
loading (λi /μi , where i ∈ I1 ), which is defined as the ratio
of the packet arrival rate divided by the packet departure rate
(or the MT processing rate) at the WiMAX interface. The
figure shows that power consumption at interface i increases
as loading increases. This is because, when the processing
rate is fixed, an increase in loading means that there are more

B. Models for WLAN Interface
We consider beacon interval Bi in access point (AP) i (note
that index i for the AP is same as for the interface); then,
the listen interval of an MT in AP i is Li = kBi , where k =
1, 2, 3. The following clarifies the differences between WLAN
and WiMAX sleep modes.
• The sleep window (listen interval L in the case of WLAN)
is of fixed duration. (In case of WiMAX, it changes on a
binary-exponentially basis.)
• An MT with shared medium communications (e.g.,
WLANs) has to send a polling message to retrieve the
buffered traffic using carrier sense multiple access with
collision avoidance. This means that the MTs that have
pending packets are competitors [8], [20], [25], thus affecting the average delay and the power consumption.
Assumptions of power consumption and delay models related to WLAN basically follow those in [8] and [20]. Thus, we
assume that there are mtotal,i MTs downloading traffic through
interface i (i ∈ I2 ). All MTs employ sleep mode and have the
same priority and packet arrival rates. Let mi be the number
of MTs sharing the same beacon interval in AP i; then, mi
is obtained by mi = mtotali · Bi /Li . Since packets arrive to
a certain interface i of the MT with rate λi , the total number
of packet arrivals in the AP i toward the MT sharing the same
beacon interval also follows a Poisson process with rate mi λi .
1) Power Consumption: The upper and lower bounds of the
average sleep ratio of interface i are obtained by [25]

i λi
qi (λi )upper = 1 − mkμ
i
(11)
qi (λi ) =
λi
i λi
qi (λi )lower = 1 − m
2kμi − 2μi .
Based on the given equations, the user can decide the average
sleep ratio of an interface for the power efficiency metric according to two different cases: 1) low battery power, and 2) high
battery power. In case 1, the user prefers to use the lower bound
to save more power consumption. On the other hand, in case 2,
the user prefers to use the upper bound. The average power
consumption of WLAN at interface i (i ∈ I2 ) of an MT is
determined as follows:
ξiI2 (λi ) = PS,i · qi (λi ) + PL,i (1 − qi (λi ))
= PL,i − (PL,i − PS,i ) · qi (λi ).

(12)

1848

IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY, VOL. 63, NO. 4, MAY 2014

A. PELD Without PR
We investigate the load distribution (in packets/s) that minimizes the summation of the average power consumption (in
watts) at each interface in a multihomed device. As the first
step to formulating the optimization problem, we assumed that
there is only a single stream over interface i. The optimization
problem of minimizing the summation of power consumption
at each interface (total power consumption) is then formulated
as follows:
min
ψi

Fig. 4. Average power consumption and delay of WLAN.

s.t.
2) Delay: To obtain the mean delay of a packet caused by
sleep mode, the total waiting time of a packet includes four
kinds of delay: 1) the time between the arrival of the packet
(kBi /2); 2) the waiting time caused by other packets in the
same batch ((λi Bi )/(2μi )); 3) packet processing time (1/μi );
and 4) the waiting time experienced by a batch in the queue.
However, the fourth type of delay can be negligible because
it is very small [8]. Therefore, the mean delay of a packet at
interface i (i ∈ I2 ) is determined as
ϕIi 2 (λi ) =

λi B i
kBi
1
+
+ .
2
2μi
μi

(13)

3) Numerical Results: Fig. 4 shows the average power consumption and delay with respect to network loading (λi /μi ,
where i ∈ I2 ) in the WLAN interface where sleep mode is
employed. The actual power consumption is bounded by the
upper and lower limits of power consumption. Furthermore,
the power does not dramatically increase as the arrival rate λi
increases due to the constant sleep interval (beacon interval). In
addition, the delay increases as network loading increases. This
is because when μi is fixed, network loading can be considered
the arrival rate λi . Here, delay increases with λi because the
waiting time caused by other packets coming during Bi /2 (the
time between the arrival instant of the packet and the beginning
of the next listen interval) increases.
IV. P OWER -E FFICIENT L OAD D ISTRIBUTION A LGORITHMS
FOR M ULTIHOMED S ERVICES W ITH S LEEP M ODE
Using analytical models for power consumption and delay
for different interface types on an MT given earlier, we address
the problem of load distribution over multiple access networks
from several perspectives. We first introduce the optimization
problem for solving the power minimization with delay constraints. This is a basic approach to minimizing power consumption at an MT with a minimal constraint. Based on the
formulation, we can also gain insight into the rate-allocation
behavior at multiple networks with a simple condition. In
Section IV-B, the reordering effect is considered an important
constraint. This problem can be used as an efficient tool to
minimize power consumption while satisfying the required
reordering delay. In Section IV-C, we briefly discuss the convergence of the proposed algorithms.



ξitype (ψi · λ)

(14)

i∈I

ψi ≥ 0

for ∀ i ∈ I

(15)

ψi · λ ≤ μ i

ψi = 1

for

∀i ∈ I

(16)

for

∀i ∈ I

(17)

i∈I

ϕtype
(ψi · λ) ≤ δi
i

for ∀ i ∈ I.

(18)

where type refers to I1 or I2 (WiMAX or WLAN), and
ψi · λ = λ i .
In (14), the objective function is considered the summation of
the power consumption at each interface i (i ∈ I) according to
the distributed allocated load (ψi · λ), where the average power
consumption metric at interface i (ξitype ) can be decided by
each interface i’s type from (6) and (12). Thus, for the given
optimization problem, we seek an optimal splitting vector ψi
that minimizes the objective function with given constraints
(15)–(18) and other system parameters (e.g., μi , Tmin,i , Tmax,i ,
PS,i , PL,i , etc). Specifically, the constraints in (15) and (17)
represent the feasible region of splitting vectors. This means
that the splitting vector at interface i (i ∈ I) should be greater
than or equal to zero to guarantee a nonnegative load distribution. Note that the summation of the splitting vector equals 1.
In addition, allocated load to a certain interface i cannot exceed
the service rate of interface i (i ∈ I), as expressed in (16).
The constraint in (18) expresses the delay requirement δi for
each interface i (i ∈ I) where the mean delay of a packet at
) can be decided by each interface i’s type
interface i (ϕtype
i
from (10) and (13).
For the analysis, we first deal with a simple multihomed
homogeneous case. In particular, a multihomed MT has a set of
WLAN interfaces. We then extend our analysis to a multihomed
heterogeneous case where the MT has two types of interfaces
(WiMAX and WLAN). In the first case, the optimization problem can be classified as a hard or soft optimization problem
based on the upper and lower bounds of the average sleep
ratio (qi (λi )).
• Hard optimization problem. An MT is very sensitive to
power consumption due to limited battery. We can directly
choose the lower bound of the average sleep ratio metric
in the case of WLAN.
• Soft optimization problem. An MT chooses the upper
bound of the average sleep ratio metric in the case of
WLAN.

LEE et al.: PELD FOR MULTIHOMED SERVICES WITH SLEEP MODE OVER WIRELESS ACCESS NETWORKS

Because the objective and inequality constraint functions are
convex and the equality constraint functions are linear (or more
generally, affine), the problem is a convex optimization problem
(or convex program) [26]. The basic idea in Lagrange duality
is to relax the original problem (14)–(18) by transferring the
constraints to the objective in the form of a weighted sum. We
then define a Lagrangian associated with the given problem
to be

 type
ξi (ψi · λ) −
χ i ψi
L(ψ, χ, γ, σ, 
) =
i∈I

+

i∈I


i∈I

+



	

γi (ψi · λ − μi ) + σ





ψi − 1




i ϕtype
(ψi · λ) − δi
i

(19)

where type is restricted at I2 , and (χ, γ, σ, 
) is the set of dual
variables.
We use one of the distributed algorithms to solve (14)–(18),
which is a Lagrangian algorithm based on a dual decomposition
[27]. The Lagrangian algorithm for this problem is given by

(h+1)
(h)
I ,(h)
(h)
(h)
= ψi − α ∇i ξi 2
− χ i + γi λ
ψi

(h)
(20)
+ σ (h) + 
i


(h+1)
(h)
(i)
χi
= χ i − β · ψi
(21)
(h+1)

γi

+

(h)

= γi

+ θ(ψi · λ − μi )


σ

(h+1)

= σ

	
(h)

+ν




(22)

+



ψi − 1

+

(23)

i∈I

(h+1)


i

various system parameters should be defined. The algorithm
starts with an initial splitting vector and power consumption
(steps 1–6) and then iteratively finds the optimal PELD point
for an MT (steps 7–23). We have two main constraints for
finding the optimal point: packet delay and power consumption.
Before checking the power consumption, we check the average
packet delay (step 10). To minimize the total average power
consumption, Algorithm 1 should satisfy ξ (t) ≤ ξ (t−1) . After
checking the delay and power consumption conditions, we set a
new splitting vector for distribution of the load to each interface
i (steps 19–22). This algorithm will stop after reaching the
optimal load distribution point |ξ (t) − ξ (t−1) | ≤ ; otherwise,
it keeps searching for the optimal point.

i∈I

i∈I



1849




(h)
= 
i + o ϕIi 2 (ψi · λ) − δi

+

(24)

where [·]+ = max{0, ·}, h is the time index, and α, β, θ, ν, and
o are fixed step sizes.
The update equation for dual variables is a projected gradient
algorithm for maximizing the Lagrangian with respect to its
dual variable argument. The reason for the projection is that
the Karush–Kuhn–Tucker (KKT) multiplier vector is required
to be nonnegative to satisfy the KKT condition [28].
In the next step for the optimization problem, an MT has
two types of interfaces (WiMAX or WLAN) and is thus a
multihomed heterogeneous case. Due to the nonconvexity of
the average power metric of WiMAX in (6), this optimization
can be solved by an exhaustive search algorithm. However, the
complexity is considered very low due to the limited number
of interfaces. Specifically, the computational complexity of the
optimization problem linearly increases with the number of
available access networks K on the order of O(K). The PELD
without PR is shown as Algorithm 1. Let ξ (t) be the total power
consumption at the t th iteration and λ be the total packet arrival
rate. In addition, we define  as the bound of optimal points. For
the first step of the proposed algorithm, we input the interface
type (e.g., WiMAX or WLAN). According to the interface type,

Algorithm 1 Greedy PELD without PR for a multiinterface
mobile node
Input: type at interface i, ∀ i ∈ I
Ensure: type ∈ {I1 , I2 }
Ensure: If type = I1 then
system parameters: μi , Tmin,i , Tmax,i , PS,i , PL,i
Ensure: If type = I2 then
system parameters: qi (λi ), PS,i , PL,i , Bi
1:Initialize ψi = 1/|I|∀ i ∈ I
2:Initialize Δψ = constant
3:Initialize t = 0
4:Initialize kbest = arg mini∈I ξitype (ψi ∗ λ)
5:Initialize kworst = arg maxi∈I ξitype (ψi ∗ λ)
6:Initialize ξ (t) = ∞
7:repeat
8: t = t + 1
9: Send
 stream traffic.
> δi ) then,
10: if i∈I (ϕtype
i
11: ibest = arg mini∈I (ϕtype
− δi )
i
− δi )
12: iworst = arg maxi∈I (ϕtype
i
13: Δψ = Δψ/2
14: else if ξ (t) > ξ (t−1) then,
15: ibest = arg mini∈I ξitype (ψi ∗ λ)
16: iworst = arg maxi∈I ξitype (ψi ∗ λ)
17: Δψ = Δψ/2
18: end if
19: Δψ 
 = min(Δψ, μk /λ − ψibest )
20: Δψ 
 = min(Δψ 
 , ψiworst )
21: ψibest = ψibest + Δψ 

22: ψiworst = ψiworst − Δψ 

23:until |ξ (t) − ξ (t−1) | ≤ 

B. PELD With PR
To develop the first-step optimization problem, we consider
delay difference with multiple paths tightly connected with the
PR performance. PR is important for a multipath load distribution because PR due to delay difference can induce additional
delay, processing buffer, and processing power consumption.
To simplify the problem, we assume that, if the difference
between maximum and minimum delays of the interfaces is

1850

IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY, VOL. 63, NO. 4, MAY 2014

bounded by threshold values, the effects of PR can be negligible
[3]. The optimization problem of minimizing the total power
consumption is then formulated as follows:
min
ψi



ξitype (ψi · λ)

(25)

i∈I

s.t. ψi ≥ 0
ψi · λ ≤ μ i

ψi = 1

for ∀ i ∈ I

(26)

for

∀i ∈ I

(27)

for

∀i ∈ I

(26)

for

∀i ∈ I

(28)

i∈I

R(ψi · λ) ≤ Rth

(ψi · λ)) − min(ϕtype
(ψi · λ)).
where R(ψi · λ) = max(ϕtype
i
i
Equation (29) is considered an important constraint to guaranteeing that there is no PR risk. The detailed procedure for
obtaining the optimal solution of (25)–(29) is described in
Algorithm 2. In this algorithm, we consider PR due to delay
difference at multiple paths. Note that Algorithm 2 checks the
difference between maximum delay and minimum delay over
multiple paths bounded in the threshold value Rth (step 5). The
algorithm will converge to the optimal point of minimum power
consumption without PR risk.
Algorithm 2 Greedy PELD with PR for a multiinterface
mobile node
1:Same procedure of Algorithm 1 until line 6
2:repeat
3: t = t + 1
4: Send
 traffic.
 stream
)−min(ϕtype
) > Rth ) then,
5: if i∈I ( i ∈I\{i} (max(ϕtype
i
i
type
6: ibest = arg mini∈I (ϕi )
)
7: iworst = arg maxi∈I (ϕtype
i
8: Δψ = Δψ/2
9: else if ξ (t) > ξ (t−1) then,
10: ibest = arg mini∈I ξitype (ψi ∗ λ)
11: iworst = arg maxi∈I ξitype (ψi ∗ λ)
12: Δψ = Δψ/2
13: end if
14: Δψ 
 = min(Δψ, μi /λ − ψibest )
15: Δψ 
 = min(Δψ 
 , ψiworst )
16: ψibest = ψibest + Δψ 

17: ψiworst = ψiworst − Δψ 

18:until |ξ (t) − ξ (t−1) | ≤ 

C. Proposed Algorithms Complexity
The convergence time of Algorithms 1 and 2 increases with
the number of: 1) available access networks I, and 2) iteration t
decided by the step size Δψ. Since we reduce the Δψ value by
half for each iteration, we need log(Δψ) iterations. The computational complexity of this algorithm is then O(K log(Δψ)).
Moreover, the proposed greedy algorithms will regardless converge because of the fixed criteria and reduction of the step size

Fig. 5.

NS-2 simulation model for the proposed PELD.

for each iteration. (The size of fixed criteria may influence the
quality of the solution.)
In real communication systems, the power consumption behavior cannot be easily modeled as a convex or linear function. It is therefore difficult to search the optimal distribution
point mathematically from an exact power consumption model.
Our proposed heuristic algorithms can be easily adopted and
deployed to find the optimal point with low complexity and
convergence time, although various nonlinear or nonconvex
performance functions are considered. Thus, the algorithms
can be considered a promising solution with load distribution
over heterogeneous wireless access networks and wired access
networks.
V. P ERFORMANCE E VALUATION
Here, we evaluate how much the proposed load distribution
algorithms reduce the power consumption while other important performances such as packet loss rate and delay (e.g.,
maximum delay and minimum delay, and delay difference) are
reasonably guaranteed. Specifically, we compare the performance of the proposed algorithms to other existing schemes
using an NS-2 simulation of practical configurations as follows:
• Proposed PELD algorithm with/without PR;
• RR-based load distribution scheme [2];
• Least-loaded-first (LLF) scheme [11];
• E-DCLD scheme [3].
A. Simulation Methodology
1) Simulation Scenario and Setup Description: Fig. 5 shows
our new wireless node architecture where we changed the structure of the MAC, the interface queue, the link layer, the network
interface, Address Resolution Protocol (ARP), and the routing
agent to support NS-2 mobile nodes with multiple interfaces.

LEE et al.: PELD FOR MULTIHOMED SERVICES WITH SLEEP MODE OVER WIRELESS ACCESS NETWORKS

1851

TABLE II
802.16 (W I MAX) S YSTEM PARAMETERS

Fig. 6.

Optimal point convergence time of the PELD algorithm.

The MT is equipped with both WLAN and WiMAX interfaces,
where each interface employs sleep mode. The current MAC
modules for NS-2 include 802.11, Ethernet, time-division multiple access, and satellite; however, no 802.16 MAC module is
available. Thus, we use WiMAX extensions from [29] for our
study. In the simulations, a single WiMAX BS and two WLAN
APs are placed in the center of an area of 300 ∗ 300 m2 . The
source of the streaming service is a so-called mobile network
operator (MNO) placed in the fixed Internet portion of the
network. The MNO is connected to WiMAX and IEEE 802.11
APs via error-free wired links. User data are transmitted over
the downlink direction (APs to MT). For the uplink direction
(MT to APs), a probing packet is transmitted every 2 s, and
standard communication packets (e.g., AP association, ARP,
etc.) use both uplink and downlink channels. The simulation
time is 600 s. Our simulation design is simple and has low
complexity. Fig. 6 shows how fast the proposed algorithm
converges to the optimal point. Here, with an initial step size of
50 kb/s, the proposed algorithm converged to the optimal load
distribution point within eight iterations. However, to check the
delay and the holding rate for optimal distribution, the MT has
to send the probing packet (if the MT sends the probing packet
more frequently, the distribution vector will converge to a more
accurate optimal vector), and this causes additional delay and
power consumption.
2) Simulation Parameters: The system parameters used in
the simulation are configured based on the IEEE 802.11 and
802.16 recommendations, respectively [16], [30], [31]. Detailed
parameters are presented in Tables II and III. For the transport
layer protocol, we use the Transmission Control Protocol Reno
model. In addition, for power consumption measurement, each
access network is assigned different power consumption parameters for each state (e.g., sleep, listening, or active states).
Then, focusing on interface power consumption, we measure
and calculate the average power consumption in the receiving
mode from the interface state corresponding to the traffic
arrival rate.
3) Simulation Assumptions: For the simulation, we basically assume that there is no barrier between the BS (or AP)

TABLE III
802.11 (WLAN) S YSTEM PARAMETERS

and an MT. An MT has no mobility as a static user. We also
assume that the queue size of the BS (or AP) is large enough
to accommodate the maximum packet arrival rate. Therefore,
packet loss is only caused by late packets. For the channel
model, we use two ray ground propagation models [32]. The
packet arrival is modeled as a Poisson process, and a packet
length of 3040 bits is used in the simulation [15].
B. Simulation Results
In Fig. 7, the normalized power consumption of the proposed
algorithms, which is defined as the actual power consumption
per maximum power consumption, is less than that of other
conventional schemes, particularly for higher data rates. Here,
at 300 kb/s, PELD can achieve 7% power consumption reduction compared with E-DCLD. In the case of PELD with
PR, although it consumes more power than that without PR, it
compensates the risk of PR by tightly controlling the allowable
delay difference between each interface. In Fig. 8, at 300 kb/s,
we checked the power consumption behavior with a varying
number of WLAN devices. As the number of WLAN users
increases, there is greater power consumption due to severe
competition to retrieve the buffered traffic.

1852

IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY, VOL. 63, NO. 4, MAY 2014

Fig. 7. Power consumption dependence on data rate (200 and 300 kb/s).

Fig. 9.

Packet loss rate with varying deadline constraints.

Fig. 8. Power consumption with a varying number of WLAN devices.

In Fig. 9, we changed the value of the deadline constraint
(from 250 to 500 ms), and compared the packet loss ratio. Since
the short deadline constraint means the tight delay requirement,
the packet loss ratio decreased with the deadline constraint.
Here, we can check that PELD with PR has less packet loss
rate than PELD by controlling the load distribution to satisfy the
delay requirement. Then, we can also observe that the proposed
algorithms (PELD and PELD with PR) have similar packet
loss rate to others at 500-ms deadline constraint. In a multipath
load distribution, PR is very important since it causes additional
reordering recovery delay and power consumption. In addition,
the possibility of PR could be indirectly predicted by the delay
difference between the maximum delay and minimum delay
[3]. In this case, if the difference is lower than the packet
interarrival time, the risk of PR could be negligible. Hence,
to illustrate the risk of PR, we first present in Fig. 10(a) the
maximum delay of the proposed algorithms in comparison to
others. Note that the minimum delay of various schemes has
a very small value (less than 10−5 s) and a minor impact on

Fig. 10.

(a) Maximum delay and (b) minimum delay with varying data rate.

LEE et al.: PELD FOR MULTIHOMED SERVICES WITH SLEEP MODE OVER WIRELESS ACCESS NETWORKS

1853

R EFERENCES

Fig. 11. Delay difference with varying data rate.

the delay difference for the risk of PR, as shown in Fig. 10(b).
Here, we observe that the maximum delay of the proposed algorithms (PELD and PELD with PR) has similar behavior to RR
and E-DCLD. This observation is also related to delay difference. Hence, with regard to delay difference, the conventional
E-DCLD has the lowest delay difference because it focuses on
minimizing this parameter, as shown in Fig. 11. Thus, E-DCLD
is suitable for eliminating the risk of PR. On the other hand,
the LLF scheme causes a high delay difference due to lack of
consideration of the significant variation in the packet delay
of different paths. In comparison with E-DCLD, the proposed
algorithms also achieve reasonable delay difference.

VI. C ONCLUSION
This paper has dealt with the problem of data stripping load
distribution across multiple interfaces, where each interface
employs sleep mode, of a multihomed MT over a heterogeneous
wireless access network to minimize its power consumption.
We first presented analytical models for power consumption
and delay for different types of interfaces i.e., WiMAX and
WLAN in the MT. Based on these models, we proposed a
power-efficient load distribution algorithm without PR, which
minimizes the overall MT power consumption under delay
constraint. The algorithm was then extended by taking into
account the delay and PR risk. The analytical and simulation
results under various practical configurations (e.g., WLAN and
WiMAX standards) demonstrate that the proposed algorithm
can significantly reduce power consumption while guaranteeing
QoS requirements.

ACKNOWLEDGMENT
The authors would like to thank H. Oh for his helpful support
of the simulation, Dr. C. Randy Giles at Bell Labs for his review
and proofreading, and Dr. S. H. Shah Newaz at KAIST for his
technical discussion of this paper.

[1] M. Ismail and W. Zhuang, “Decentralized radio resource allocation for
single-network and multi-homing services in cooperative heterogeneous
wireless access medium,” IEEE Trans. Wireless Commun., vol. 11, no. 11,
pp. 4085–4095, Nov. 2012.
[2] M. Shreedhar and G. Varghese, “Efficient fair queuing using deficit roundrobin,” IEEE/ACM Trans. Netw., vol. 4, no. 3, pp. 375–385, Jun. 1996.
[3] S. Prabhavat, H. Nishiyama, N. Ansari, and N. Kato, “Effective delaycontrolled load distribution over multipath networks,” IEEE Trans. Parallel Distrib. Syst., vol. 22, no. 10, pp. 1730–1741, Oct. 2011.
[4] F. Wang, Z. Liu, and X. Song, “Power-saving mechanisms for mobile devices in wireless communications,” IET Commun., vol. 3, no. 2, pp. 257–
267, Feb. 2009.
[5] D. T. T. Nga and H. Lim, “Performance evaluation and optimisation guidelines for the type II ower-saving class of mobile world interoperability
for microwave access,” IET Commun., vol. 6, no. 14, pp. 2250–2257,
Sep. 2012.
[6] D. T. T. Nga and H. Lim, “Power saving mechanism with delay bound for
mobile WiMAX systems,” IET Commun., vol. 5, no. 13, pp. 1854–1859,
Sep. 2011.
[7] A. P. Azad, S. Alouf, and E. Altman, “Analysis and optimization of sleeping mode in WiMAX via stochastic decomposition techniques,” IEEE J.
Sel. Areas Commun., vol. 29, no. 8, pp. 1630–1640, Sep. 2011.
[8] H. Lei and A. A. Nilsson, “Queuing analysis of power management in
the IEEE 802.11 based wireless LANs,” IEEE Trans. Wireless Commun.,
vol. 6, no. 4, pp. 1286–1294, Apr. 2007.
[9] A. Argyriou and V. Madisetti, “Bandwidth aggregation with SCTP,” in
Proc. IEEE GLOBECOM, Dec. 2003, pp. 3716–3721.
[10] H. Hsieh and R. Sivakumar, “A transport layer approach for achieving
aggregate bandwidths on multi-homed mobile hosts,” Wireless Netw.,
vol. 11, no. 1/2, pp. 99–114, Jan. 2005. [Online]. Available: http://dx.doi.
org/10.1007/s11276-004-4749-6
[11] C. C. Hui and S. T. Chanson, “Hydrodynamic load balancing,” IEEE
Trans. Parallel Distrib. Syst., vol. 10, no. 11, pp. 1118–1137, Nov. 1999.
[12] W. Song and W. Zhuang, “Performance analysis of probabilistic multipath transmission of video streaming traffic over multi-radio wireless
devices,” IEEE Trans. Wireless Commun., vol. 11, no. 4, pp. 1554–1564,
Apr. 2012.
[13] W. Zhao and J. Xie, “Reload: Resilient location area design for
Internet-based infrastructure wireless mesh networks,” in Proc. IEEE
GLOBECOM, 2011, pp. 1–5.
[14] W. Zhao and J. Xie, “Domain: A novel dynamic location management solution for Internet-based infrastructure wireless mesh networks,”
IEEE Trans. Parallel Distrib. Syst., vol. 24, no. 8, pp. 1514–1524,
Aug. 2013.
[15] J. H. Lee, Y. Lim, J. H. Kim, S. G. Choi, and J. K. Choi, “Energy-efficient
rate allocation for multi-homed streaming service over heterogeneous
access networks,” in Proc. IEEE GLOBECOM, Dec. 2011, pp. 1–6.
[16] IEEE Standard for Local and Metropolitan Area Network Part 16: Air
Interface for Fixed Broadband Wireless Access Systems, IEEE I.S. Std.
802.16/Cor1/D3-2005, May 2005.
[17] Y. Xiao, “Energy saving mechanism in the IEEE 802.16e wireless man,”
IEEE Commun. Lett., vol. 9, no. 7, pp. 595–597, Jul. 2005.
[18] J. Xiao, S. Zou, B. Ren, and S. Cheng, “Wlc17-6: An enhanced energy saving mechanism in IEEE 802.16e,” in Proc. IEEE GLOBECOM,
Dec. 2006, pp. 1–5.
[19] K. Han and S. Choi, “Performance analysis of sleep mode operation in
IEEE 802.16e mobile broadband wireless access systems,” in Proc. IEEE
VTC, May 2006, pp. 1141–1145.
[20] S. Baek and B. D. Choi, “Performance analysis of power save mode
in IEEE 802.11 infrastructure WLAN,” in Proc. IEEE ICT, Jun. 2008,
pp. 1–4.
[21] X. Gelabert, J. P. rez Romero, O. Sallent, and R. Agusti, “A Markovian approach to radio access technology selection in heterogeneous multiaccess/
multiservice wireless networks,” IEEE Trans. Mobile Comput., vol. 7,
no. 10, pp. 1257–1270, Oct. 2008.
[22] J. P. Singh, T. Alpcan, and X. Z., “Towards heterogeneous network convergence: Policies and middleware architecture for efficient flow assignment,
rate allocation and rate control for multimedia applications,” in Proc.
Workshop MNCNA, Newport Beach, CA, USA, Nov. 2007.
[23] X. Zhu, P. Agrawal, J. P. Singh, T. Alpcan, and B. Girod, “Distributed rate
allocation policies for multihomed video streaming over heterogeneous
access networks,” IEEE Trans. Multimedia, vol. 11, no. 4, pp. 752–764,
Jun. 2009.
[24] L. Kieinrock, Queueing Systems Volume 1: Theory. Hoboken, NJ, USA:
Wiley, 1974.

1854

IEEE TRANSACTIONS ON VEHICULAR TECHNOLOGY, VOL. 63, NO. 4, MAY 2014

[25] R. Zheng, J. C. Hou, and L. Sha, “Performance analysis of power management policies in wireless networks,” IEEE Trans. Wireless Commun.,
vol. 5, no. 6, pp. 1351–1361, Jun. 2006.
[26] D. P. Palomar and M. Chiang, “A tutorial on decomposition methods
for network utility maximization,” IEEE J. Sel. Areas Commun., vol. 24,
no. 8, pp. 1439–1451, Aug. 2006.
[27] S. Boyd and L. Vandenberghe, Convex Optimization. Cambridge, U.K.:
Cambridge Univ. Press, 2004.
[28] E. K. P. Chong and S. H. Zak, An Introduction to Optimization.
Hoboken, NJ, USA: Wiley, 2011.
[29] J. Martin and J. Westall, “A simulation model of the DOCSIS protocol,”
Soc. Comput. Simul. Int. Simul., vol. 83, no. 2, pp. 139–155, Feb. 2007.
[30] IEEE 802.11: Wireless LAN Medium Access Control MAC and Physical
Layer (PHY) Specification, IEEE I.S. Std. 802.11-1999, Jun. 1999.
[31] Part 16: Air Interface for Fixed Broadband Wireless Access Systems, IEEE
I. S. Std. 802.16e 2005, Feb. 2006.
[32] A. Schmitz and M. Wenig, “The effect of the radio wave propagation
model in mobile ad hoc networks,” in Proc. ACM MSWiM, Oct. 2006,
pp. 61–67.

Joohyung Lee received the B.S. and M.S. degrees
from the Korea Advanced Institute of Science and
Technology (KAIST), Daejeon, Korea, in 2008 and
2010, respectively. He is currently working toward
the Ph.D. degree with KAIST.
From June 2012 to March 2013, he was a Visiting Researcher with the Information Engineering
Group, Department of Electronic Engineering, City
University of Hong Kong, Hong Kong. Since 2010,
he has contributed several articles to the International Telecommunication Union Telecommunication Standardization Sector Study Group 13 Questions 9 and 22. His current
research interests include resource allocation and optimization, with a focus on
resource management for broadband wireless networks, green networks, smart
grids (future power grids), and network economics.
Dr. Lee has been an active member of the GreenTouch Consortium. He
has been a Technical Reviewer for several conferences and journals, such
as the IEEE C OMMUNICATIONS L ETTERS, the IEEE T RANSACTIONS ON
V EHICULAR T ECHNOLOGY, and Elsevier Computer Communications. He
received a Best Paper Award at the Integrated Communications, Navigation,
and Surveillance Conference in 2011.

Nga T. Dinh received the M.S. and Ph.D. degrees
from the Korea Institute of Science and Technology,
Daejeon, Korea, in 2005 and 2009, respectively.
From September 2009 to June 2010, she was a
Postdoctoral Researcher with the Gwangju Institute
of Science and Technology, Gwangju, Korea. Since
then, she has been a technical staff member with Bell
Labs Seoul, Seoul, Korea. Her current research interests include energy efficiency of telecommunication
networks, dynamic bandwidth allocation, network
optimization, wired/wireless convergence networks,
and quality-of-user experience/quality of service.

Ganguk Hwang (M’03) received the B.Sc., M.Sc.,
and Ph.D. degrees in mathematics (applied probability) from the Korea Advanced Institute of Science
and Technology (KAIST), Daejeon, Korea, in 1991,
1993, and 1997, respectively.
From February 1997 to March 2000, he was with
the Electronics and Telecommunications Research
Institute, Daejeon. From March 2000 to February
2002, he was a Visiting Scholar with the School of
Interdisciplinary Computing and Engineering, University of Missouri, Kansas City, MO, USA. Since
March 2002, he has been with the Department of Mathematical Sciences,
KAIST, where he is currently a Professor. From August 2010 to July 2011, he
was a Visiting Scholar with the Department of Electrical Engineering, University of Washington, Seattle, WA, USA. His research interests include
teletraffic theory, performance analysis of communication systems, quality-ofservice provisioning for wired/wireless networks, and cross-layer design and
optimization for wireless networks.

Jun Kyun Choi (SM’00) received the M.S. (Eng.)
and Ph.D. degrees in electronic engineering from the
Korea Advanced Institute of Science and Technology (KAIST), Daejeon, Korea, in 1985 and 1988,
respectively.
From June 1986 to December 1997, he was with
the Electronics and Telecommunication Research
Institute, Daejeon. In January 1998, he joined the
Information and Communications University (now
known as, KAIST) as a Professor. His research interests include broadband network architecture and
technologies, with particular emphasis on performance and protocol problems.
Dr. Choi was an active member of the International Telecommunication
Union Telecommunication Standardization Sector Study Group 13 as either a
Rapporteur or an Editor focusing on the asynchronous transfer model, multiprotocol label switching, and next-generation network issues, in January 1993.
He has also submitted more than 30 drafts in the International Engineering Task
Force over the past few years.

Chimoon Han (M’98) received the B.S. degree in
electronic engineering from Kyungpook National
University, Daegu, Korea, in 1977; the M.S. degree
in electronic engineering from Yonsei University,
Seoul, Korea, in 1983; and the Ph.D. degree in information and communication engineering from The
University of Tokyo, Tokyo, Japan, in 1990.
From 1977 to 1983, he was with the Korea Institute of Science and Technology, Seoul. From 1983 to
1997, he was with the Electronics and Telecommunications Research Institute, Daejeon, Korea. Since
March 1997, he has been with Hankuk University of Foreign Studies, Seoul,
where he is currently a Professor with the Department of Electronic Engineering and served as the Dean for the College of Engineering from 2002 to 2003
and the Vice President in 2007. His research interests include next-generation
networks, green information technology, network security, and performance
analysis.

Technical Communications of ICLP 2015. Copyright with the Authors.

1

Markov Logic Style Weighted Rules
under the Stable Model Semantics
JOOHYUNG LEE
Arizona State University, Tempe, AZ, USA (e-mail: joolee@asu.edu)

YUNSONG MENG
Samsung Research America, Mountain View, CA, USA (e-mail: yunsong.m@samsung.com)

YI WANG
Arizona State University, Tempe, USA (e-mail: ywang485@asu.edu)
submitted 29 April 2015; accepted 5 June 2015

Abstract
MLN

We introduce the language LP
that extends logic programs under the stable model semantics to allow weighted rules similar to the way Markov Logic considers weighted formulas. LPMLN is a proper
extension of the stable model semantics to enable probabilistic reasoning, providing a way to handle inconsistency in answer set programming. We also show that the recently established logical relationship
between Pearl’s Causal Models and answer set programs can be extended to the probabilistic setting
via LPMLN .
KEYWORDS: Answer Set Programming, Markov Logic Networks, Probabilistic Causal Models, Probabilistic Logic Programming

1 Introduction
Logic programs under the stable model semantics is the language for Answer Set Programming (ASP). Many useful knowledge representation constructs are introduced into ASP, and
several efficient ASP solvers are available. However, like many “crisp” logic approaches,
adding a single rule may easily introduce inconsistency. Also, ASP is not well suited for
handling probabilistic reasoning.
Markov Logic is a successful approach to combining first-order logic and probabilistic
graphical models in a single representation. Syntactically, a Markov Logic Network (MLN)
is a set of weighted first-order logic formulas. Semantically, the probability of each possible
world is derived from the sum of the weights of the formulas that are true under the possible world. Markov Logic has shown to formally subsume many other SRL languages and
has been successfully applied to several challenging applications, such as natural language
processing and entity resolution. However, the logical component of Markov Logic is the
standard first-order logic semantics, which does not handle the concept of rules as in ASP.
We introduce a simple approach to combining the two successful formalisms, which allows
for logical reasoning originating from the stable model semantics as well as probabilistic
reasoning originating from Markov Logic. LPMLN is a proper extension of the standard stable
model semantics, and as such embraces the rich body of research in answer set programming.

2

J. Lee and Y. Meng and Y. Wang

Interestingly, the relationship between LPMLN and Markov Logic is analogous to the wellknown relationship between ASP and SAT (Lin and Zhao 2004; Lee 2005). This allows many
useful results known in the deterministic case to be carried over to the probabilistic setting.
In particular, an implementation of Markov Logic can be used to compute “tight” LPMLN
programs, similar to the way “tight” ASP programs can be computed by SAT solvers.
LPMLN provides a viable solution to inconsistency handling with ASP knowledge bases.
For example, consider ASP knowledge base KB1 that states that Man and Woman are disjoint
subclasses of Human.
Human(x) ← Man(x),
Human(x) ← Woman(x),
← Man(x), Woman(x)
One data source KB2 says that Jo is a Man:
Man(Jo)
while another data source KB3 states that Jo is a Woman:
Woman(Jo).
The data about Jo is actually inconsistent, so under the (deterministic) stable model semantics, the combined knowledge base KB = KB1 ∪ KB2 ∪ KB3 is inconsistent, and may derive
any conclusion. On the other hand, it is intuitive to view that one of the data sources may be
wrong, and we still want to conclude that Jo is a Human. The same conclusion is obtained
under the LPMLN semantics.
For another aspect of LPMLN , we consider how it is related to Pearl’s Probabilistic Causal
Models. Both answer set programs and Probabilistic Causal Models allow for representing causality, but a precise relationship between them is established only in a recent paper (Bochman and Lifschitz 2015) limited to the deterministic case.1 Generalizing this result
to the probabilistic case is straightforward once we refer to LPMLN in place of answer set
programs, which illustrates that LPMLN is a natural probabilistic extension of answer set
programs.
2 Preliminaries
Throughout this paper, we assume a first-order signature σ that contains no function constants
of positive arity. There are finitely many Herbrand interpretations of σ.
2.1 Review: Stable Model Semantics
A rule over σ is of the form
A1 ; . . . ; Ak ← Ak+1 , . . . , Am , not Am+1 , . . . , not An , not not An+1 , . . . , not not Ap
(1)
(0 ≤ k ≤ m ≤ n ≤ p) where all Ai are atoms of σ possibly containing object variables. We
write {A1 }ch ← Body to denote the rule A1 ← Body, not not A1 . This expression is called a
“choice rule” in ASP.
1

Strictly speaking, the relationship shown in that paper is between Pearl’s causal models and nonmonotonic causal
theories (McCain and Turner 1997). The close relationship between nonmonotonic causal theories and answer set
programs is shown in (Ferraris et al. 2012).

Markov Logic Style Weighted Rules under the Stable Model Semantics

3

We will often identify (1) with the implication:
A1 ∨ · · · ∨ Ak ← Ak+1 ∧. . .∧Am ∧¬Am+1 ∧. . .∧¬An ∧¬¬An+1 ∧. . .∧¬¬Ap .

(2)

A logic program is a finite set of rules. A logic program is called ground if it contains no
variables.
We say that an Herbrand interpretation I is a model of a ground program Π if I satisfies
all implications (2) in Π (as in classical logic). Such models can be divided into two groups:
“stable” and “non-stable” models, which are distinguished as follows. The reduct of Π relative to I, denoted ΠI , consists of “A1 ∨ · · · ∨ Ak ← Ak+1 ∧ · · · ∧ Am ” for all rules (2) in
Π such that I |= ¬Am+1 ∧ · · · ∧ ¬An ∧ ¬¬An+1 ∧ · · · ∧ ¬¬Ap . The Herbrand interpretation I is called a (deterministic) stable model of Π if I is a minimal Herbrand model of ΠI .
(Minimality is in terms of set inclusion. We identify an Herbrand interpretation with the set
of atoms that are true in it.)
The definition is extended to any non-ground program Π by identifying it with grσ [Π], the
ground program obtained from Π by replacing every variable with every ground term of σ.
The semantics was extended in many ways, e.g., allowing some useful constructs, such
as aggregates and abstract constraints (e.g., (Niemelä and Simons 2000; Faber et al. 2004;
Ferraris 2005; Son et al. 2006; Pelov et al. 2007)). The probabilistic extension defined in this
paper is orthogonal to such extensions and can easily incorporate them as well.
3 Language LPMLN
3.1 Syntax of LPMLN
The syntax of LPMLN defines a set of weighted rules. More precisely, an LPMLN program P
is a finite set of weighted rules w : R, where R is a rule of the form (1) and w is either a real
number or the symbol α denoting the “infinite weight.” We call rule w : R soft rule if w is a
real number, and hard rule if w is α.
We say that an LPMLN program is ground if its rules contain no variables. We identify any
LPMLN program P of signature σ with a ground LPMLN program grσ [P], whose rules are
obtained from the rules of P by replacing every variable with every ground term of σ. The
weight of a ground rule in grσ [P] is the same as the weight of the rule in P from which the
ground rule is obtained.
By P we denote the logic program obtained from P by dropping the weights, i.e., P =
{R | w : R ∈ P}. By PI we denote the set of rules in P which are satisfied by I.
3.2 Semantics of LPMLN
A model of an MLN does not have to satisfy all formulas in the MLN. For each model, there
is a unique maximal subset of the formulas that are satisfied by the model, and the weights
of the formulas in that subset determine the probability of the model.
Likewise, a stable model of an LPMLN program does not have to be obtained from the
whole program. Instead, each stable model is obtained from some subset of the program, and
the weights of the rules in that subset determine the probability of the stable model. At first,
it may not seem obvious if there is a unique maximal subset that derives such a stable model.
Nevertheless, it follows from the following proposition that this is indeed the case, and that
the subset is exactly PI .

4

J. Lee and Y. Meng and Y. Wang

Proposition 1
For any logic program Π and any subset Π0 of Π, if I is a (deterministic) stable model of Π0
and I satisfies Π, then I is a (deterministic) stable model of Π as well.
The proposition tells us that if I is a stable model of a program, adding additional rules
to this program does not affect that I is a stable model of the resulting program as long as I
satisfies the rules added. On the other hand, it is clear that I is no longer a stable model if I
does not satisfy at least one of the rules added.
Thus we define the weight of an interpretation I w.r.t. P, denoted WP (I), as
!
X
WP (I) = exp
w .
w:R ∈ P
I|=R

Let SM[P] be the set {I | I is a stable model of PI }. Notice that SM[P] is never empty because it always contains the empty set. It is easy to check that the set ∅ always satisfies P ∅ ,
and it is the smallest set that satisfies the reduct (P ∅ )∅ .
Using this notion of a weight, we define the probability of an interpretation I under P,
denoted PrP [I], as follows. For any interpretation I,

PWP (I)
 lim
if I ∈ SM[P];
WP (J)
α→∞
J∈SM[P]
PrP [I] =

0
otherwise.
We omit the subscript P if the context is clear. We say that I is a (probabilistic) stable model
of P if PrP [I] 6= 0.
The intuition here is similar to that of Markov Logic. For each interpretation I, we try
to find a maximal subset (possibly empty) of P for which I is a stable model (under the
standard stable model semantics). In other words, the LPMLN semantics is similar to the MLN
semantics except that the possible worlds are the stable models of some maximal subset of P,
and the probability distribution is over these stable models.
For any proposition A, PrP [A] is defined as:
X
PrP [A] =
PrP [I].
I: I|=A

(In place of “I |= A,” one might expect “I is a stable model of P that satisfies A.” The change
does not affect the definition.)
Conditional probability under P is defined as usual. For propositions A and B,
PrP [A | B] =

PrP [A ∧ B]
.
PrP [B]

The following example illustrates how inconsistency can be handled in LPMLN .
Example 1 (handling inconsistency)
Consider the example in Section 1. Recall that there are no deterministic stable models of
KB. However, when we identify each rule as a hard rule under the LPMLN semantics (i.e.,
having α as the weight), there are 3 probabilistic stable models (with non-zero probabilities)
assuming that Jo is the only element in the domain. Let Z = 3e4α + 3e3α + e2α .
• I0 = ∅ with probability limα→∞ e3α /Z = 0.

Markov Logic Style Weighted Rules under the Stable Model Semantics
•
•
•
•
•
•
•

I1
I2
I3
I4
I5
I6
I7

5

= {Man(Jo)} with probability limα→∞ e3α /Z = 0.
= {Woman(Jo)} with probability limα→∞ e3α /Z = 0.
= {Human(Jo)} is not a stable model of KBI3 , so its probability is 0.
= {Man(Jo), Human(Jo)} with probability limα→∞ e4α /Z = 13 .
= {Woman(Jo), Human(Jo)} with probability limα→∞ e4α /Z = 31 .
= {Man(Jo), Woman(Jo)} with probability limα→∞ e2α /Z = 0.
= {Man(Jo), Woman(Jo), Human(Jo)} with probability limα→∞ e4α /Z = 13 .

Thus we can check that
• Pr[Human(Jo) = t] = Pr[I4 ] + Pr[I5 ] + Pr[I7 ] = 1: for I4 , KB3 is disregarded; for
I5 , KB2 is disregarded; for I7 , the last rule of KB1 is disregarded.
P r[I4 ]+P r[I7 ]
• Pr[Human(Jo) = t | Man(Jo) = t] = P r[I1 ]+P
r[I4 ]+P r[I6 ]+P r[I7 ] = 1.
• Pr[Man(Jo) = t | Human(Jo) = t] =

P r[I4 ]+P r[I7 ]
P r[I4 ]+P r[I5 ]+P r[I7 ]

= 23 .

Often an LPMLN program P consists of the set Ps of soft rules and the set of Ph of hard
rules together, and there exists at least one stable model that is obtained from all hard rules
plus some subset of soft rules. In this case, we may simply consider the weights of soft rules
only in computing the probabilities of stable models. Let SM0 [P] be the set
{I | I is a stable model of Ph ∪ (Ps )I },
and let
Pr0P [I]

=





PWPs (I)
WPs (J)

if I ∈ SM0 [P];

J∈SM0 [P]

0

otherwise.

Note the absence of lim in the definition of Pr0P [I]. Also unlike PrP [I], SM0 [P] may be
α→∞

empty, in which case Pr0P [I] is not defined.
Proposition 2
Let P = Ps ∪ Ph be an LPMLN program where Ps consists of soft rules and Ph consists of
hard rules. If SM0 [P] is not empty, for every interpretation I, PrP [I] coincides with Pr0P [I].
Thus the presence of at least one interpretation in SM0 [P] implies that every other stable
model of P (with non-zero probability) should also satisfy all hard rules in P. Note that
Example 1 does not satisfy the nonemptiness condition of SM0 [P], whereas the following
example does.
Example 2 (LPMLN vs. MLN)
Consider a variant of the main example from (Bauters et al. 2010). We are certain that we
booked a concert and that we have a long drive ahead of us unless the concert is cancelled.
However, there is a 20% chance that the concert is indeed cancelled. This example can be
formalized in LPMLN program P as
α : ConcertBooked
α:
LongDrive
ln 0.2 :
Cancelled
ln 0.8 :

←
← ConcertBooked, not Cancelled
←
← Cancelled.

Since SM0 [P] is not empty, in view of Proposition 2, the probability of the two stable
models are as follows:

6

J. Lee and Y. Meng and Y. Wang
eln0.2
= 0.2.
eln0.2 +eln0.8
eln0.8
PrP [I2 ] = eln0.2 +eln0.8 = 0.8.

• I1 = {ConcertBooked, Cancelled}, with PrP [I1 ] =
• I2 = {ConcertBooked, LongDrive}, with

If this program is understood under the MLN semantics, say in the syntax
α:
α:
ln 0.2 :
ln 0.8 :

ConcertBooked
ConcertBooked ∧ ¬Cancelled → LongDrive
Cancelled
¬Cancelled,

there are three MLN models with non-zero probabilities:
• I1 = {ConcertBooked, Cancelled} with Pr[I1 ] = 0.2/1.4 ' 0.1429.
• I2 = {ConcertBooked, LongDrive} with Pr[I2 ] = 0.8/1.4 ' 0.5714.
• I3 = {ConcertBooked, Cancelled, LongDrive} with Pr[I3 ] = 0.2/1.4 ' 0.1429.
The presence of I3 is not intuitive (why have a long drive when the concert is cancelled?)
Remark. In some sense, the distinction between soft rules and hard rules in LPMLN is similar to the distinction between consistency-restoring rules (CR-rules) and standard ASP rules
under CR-Prolog (Balduccini and Gelfond 2003): CR-rules are added to the standard ASP
program part until the resulting program has a stable model. CR-Prolog also allows a preference on selecting which CR-rules to be added in order to obtain consistency. In LPMLN a
similar effect can be obtained by adding soft rules with different weights. On the other hand,
CR-Prolog has little to say when there is no stable model no matter what CR-rules are added
(c.f. Example 1).
Remark. This example also illustrates a correspondence between LPMLN and probabilistic
logic programming languages based on the distribution semantics (Sato 1995). The use of
soft rules in the example simulates the probabilistic choices under the distribution semantics.
However, this correspondence is only valid when there is only one stable model per the
probabilistic choice induced by the selection of such soft rules.
Example 3
It is well known that Markov Logic does not properly handle inductive definitions,2 while
LPMLN gives an intuitive representation. For instance, consider that x may influence y if x is
a friend to y, and the influence relation is a minimal relation that is closed under transitivity.
α:
α:
1:
α:

Friend(A, B)
Friend(B, C)
Influences(x, y) ← Friend(x, y)
Influences(x, y) ← Influences(x, z), Influences(z, y).

Note that the third rule is soft: a person does not always influence his/her friend. The fourth
rule says if x influences z, and z influences y, we can say x influences y. On the other hand,
we do not want this relation to be vacuously true.
Assuming that there are only three people A, B, C in the domain (thus there are 1 +
1 + 9 + 27 ground rules), there are four stable models with non-zero probabilities. Let Z =
e9 + 2e8 + e7 .
2

“Markov Logic has the drawback that it cannot express (non-ground) inductive definitions.” (Fierens et al. 2013)

Markov Logic Style Weighted Rules under the Stable Model Semantics

7

• I1 = {Friend(A, B), Friend(B, C), Influence(A, B), Influence(B, C), Influence(A, C)}
with probability e9 /Z.
• I2 = {Friend(A, B), Friend(B, C), Influence(A, B)} with probability e8 /Z.
• I3 = {Friend(A, B), Friend(B, C), Influence(B, C)} with probability e8 /Z.
• I4 = {Friend(A, B), Friend(B, C)} with probability e7 /Z.
Thus we get
• PrP [Influence(A, B) = t] = PrP [Influence(B, C) = t] = (e9 + e8 )/Z = 0.7311.
• PrP [Influence(A, C) = t] = e9 /Z = 0.5344.
Increasing the weight of the soft rule yields higher probabilities for Influence(A, B) = t,
Influence(B, C) = t, Influence(A, C) = t. Still, the first two have the same probability, and
the third has less probability than the first two.
Note that the minimality of the influence relation is not expressible under the MLN semantics.
3.3 Relating LPMLN to ASP
Any logic program under the stable model semantics can be turned into an LPMLN program by assigning the infinite weight to every rule. That is, for any logic program Π =
{R1 , . . . , Rn }, the corresponding LPMLN program PΠ is {α : R1 , . . . , α : Rn }.
Theorem 1
For any logic program Π, the (deterministic) stable models of Π are exactly the (probabilistic)
stable models of PΠ whose weight is ekα , where k is the number of all (ground) rules in Π.
If Π has at least one stable model, then all stable models of PΠ have the same probability,
and are thus the stable models of Π as well.
The idea of softening rules in LPMLN is similar to the idea of “weak constraints” in ASP,
which is used for certain optimization problems. A weak constraint has the form “ :∼ Body [Weight :
Level].” The answer sets of a program Π plus a set of weak constraints are the answer sets
of Π which minimize the penalty calculated from Weight and Level of violated weak constraints. However, weak constraints are more restrictive than weighted rules in LPMLN , and
do not have a probabilistic semantics.
3.4 Completion: Turning LPMLN to MLN
It is known that the stable models of a tight logic program coincide with the models of
the program’s completion. This yielded a way to compute stable models using SAT solvers.
The method can be extended to LPMLN so that their stable models along with the probability distribution can be computed using existing implementations of MLNs, such as Alchemy
(http://alchemy.cs.washington.edu) and Tuffy (http://i.stanford.edu/
hazy/hazy/tuffy).
We define the completion of P, denoted Comp(P), to be the MLN which is the union of P
and the hard rules
!
^
_
0
α: A→
Body ∧
¬A
w:A1 ,...,Ak ←Body ∈ P
A∈{A1 ,...,Ak }

A0 ∈{A1 ,...,Ak }\{A}

8

J. Lee and Y. Meng and Y. Wang

for each ground atom A.
This is a straightforward extension of the completion from (Lee and Lifschitz 2003) simply
assigning the infinite weight α to the completion formulas. Likewise, we say that LPMLN
program P is tight if P is tight according to (Lee and Lifschitz 2003).
Theorem 2
For any tight LPMLN program P such that SM0 [P] is not empty, P (under the LPMLN semantics) and Comp(P) (under the MLN semantics) have the same probability distribution over
all interpretations.
4 Embedding Pearl’s Probabilistic Causal Models in LPMLN
4.1 Review: Pearl’s Causal Models
Notation: Following (Pearl 2000), we use capital letters (e.g., X, Y , Z, U , V ) for (lists of)
atoms and lower case letters (x, y, z, u, v) for generic symbols for specific (lists of) truth
values taken by the corresponding (lists of) atoms. When X is a list, we use subscripts, such
as Xi , to denote an element in X.
As usual, a propositional formula is constructed from atoms, t, f, and propositional connectives, ¬, ∧, ∨, →.
Definition 1 (structural theory)
Assume that a finite set of propositional atoms is partitioned into a set of exogenous atoms U
and a set of endogenous atoms V = {V1 , . . . , Vn }. A Boolean structural theory is hU, V, F i,
where F is a finite set of equations Vi = Fi , one for each endogenous atom Vi , and Fi is a
propositional formula.
Definition 2 (causal diagram)
The causal diagram of a Boolean structural theory hU, V, F i is the directed graph whose
vertices are the atoms in U ∪ V and an edge goes from Vj to Vi if there is an equation
Vi = Fi in the structural theory such that Vj occurs in Fi . We say that the structural theory
is acyclic if its causal diagram is acyclic.
For any interpretation I and J of U ∪ V , we say that J 6=V I if J and I agree on all atoms
in U and do not agree on some atoms in V .
Definition 3 (solution)
Given a Boolean causal theory hU, V, F i, a solution (or a causal world) I is any interpretation
of U ∪ V such that
• I satisfies the equivalences Vi ↔ Fi for all equations Vi = Fi in F , and
• no other interpretation J such that J 6=V I satisfies all such equivalences Vi ↔ Fi .
Definition 4 (causal model)
A (Boolean) causal model hU, V, F i is an acyclic Boolean structural theory that has a unique
solution for each realization (i.e., truth assignment) of U ; in other words, each truth assignment of U has a unique expansion to U ∪ V that is a solution.

Markov Logic Style Weighted Rules under the Stable Model Semantics

9

Definition 5 (probabilistic causal model)
A probabilistic (Boolean) structural theory is a pair
hhU, V, F i, P (U )i

(3)

where hU, V, F i is a Boolean structural theory, and P (U ) is a probability distribution over U .
We assume that exogenous atoms are independent of each other. A Probabilisitic (Boolean)
Causal Model (PCM) is a probabilistic structural theory (3) such that hU, V, F i is a causal
model. The solutions of PCM (3) are the solutions of hU, V, F i. The probability of a solution
I under the PCM M, denoted PM (I), is defined as P (U = I(U )).
Given a PCM M = hhU, V, F i, P (U )i, for any subset Y of V , we write YM (u) to denote
the truth assignment of Y in the solution of M induced by u. The probability of Y = y is
defined as
PM (Y = y) =

P

{u | YM (u)=y}

P (u).

For any subset Y , Z of V , PM (Y = y | Z = z) is defined as
P

PM (Y = y | Z = z) =

{u | YM (u) = y and ZM (u) = z}
P
{u | ZM (u)=z}

P (u)

P (u)

.

Consider, for example, the probabilistic causal model MF S for the Firing Squad example (Pearl 2000, Sec 7.1.2):
MF S =
F :

hh{U, W }, {C, A, B, D}, F i, P (U, W )i
C=U
A=C ∨W
B=C
D =A∨B
P (U = t) = p
P (W = t) = q

U denotes “The court orders the execution,” C denotes “The captain gives a signal,” A
denotes “Rifleman A shoots,” B denotes “Rifleman B shoots,” D denotes “The prisoner dies,”
and W denotes “Rifleman A is nervous.” There is a probability p that the court has ordered
the execution; rifleman A has a probability q of pulling the trigger out of nervousness. The
PCM has four solutions for each realization of U and W .
Solutions
{U
{U
{U
{U

= f, W
= f, W
= t, W
= t, W

= f, C
= t, C
= f, C
= t, C

= f, A = f, B
= f , A = t, B
= t, A = t, B
= t, A = t, B

Probability
= f, D = f}
= f , D = t}
= t, D = t}
= t, D = t}

(1−p)(1−q)
(1−p)q
p(1−q)
pq

4.2 Embedding PCM in LPMLN
Since causal models assume propositional formulas, it is convenient to discuss the result by
first extending the syntax of LPMLN to weighted propositional formulas, that is of the form

10

J. Lee and Y. Meng and Y. Wang

w : F where F is a propositional formula and w is either a real number or the symbol α.
We refer the reader to (Ferraris 2005) for the definition of a stable model for propositional
formulas. Extending LPMLN to this general syntax is straightforward, which we skip due to
lack of space.
Definition 6 (LPMLN representation)
For any PCM M = hhU, V, F i, P (U )i, PM is the LPMLN program consisting of
• α : Vi ← Fi for each equation Vi = Fi in M, and,
• for each exogenous atom Ui of M such that P (Ui = t) = p: (i) ln(p) : Ui and
ln(1 − p) : ← Ui if 0 < p < 1; (ii) α : Ui if p = 1; (iii) α : ← Ui if p = 0.
For the Firing Squad example, assuming 0 < p, q < 1, PMF S is as follows:
ln(p)
ln(1 − p)
ln(q)
ln(1 − q)

:
:
:
:

U
←U
W
←W

α
α
α
α

:
:
:
:

C←U
A←C ∨W
B←C
D ← A ∨ B.

Theorem 3
The solutions of a probabilistic causal model M are identical to the stable models of PM and
their probability distributions coincide.
Note that the acyclicity condition in PCM implies the tightness condition of its LPMLN
program representation. Thus, using the completion method in Section 3.4, we can automate
query answering for this domain using Alchemy.

4.3 Review: Counterfactuals in PCM
Definition 7 (submodel)
Given a Boolean causal model M = hU, V, F i, and a subset X of V , the submodel MX=x
of M is the Boolean causal model obtained from M by replacing every equation Xi = Fi
in the theory, where Xi ∈ X, with Xi = xi . Given a PCM M = hM, P (U )i, MX=x =
hMX=x , P (U )i.
For any PCM M = hhU, V, F i, P (U )i, let X, Y , Z be subsets of V . The probability of a
counterfactual statement, represented as YX=x = y, is defined as
X
PM (YX=x = y) =
P (u).
{u | YMX=x (u)=y}

The probability of a conditional counterfactual statement “Given Z is z, Y would have
been y had X been x”, represented as YX=x = y | Z = z, is defined as
P
PM (YX=x = y | Z = z) =

{u | YM

X=x

P

(u) = y and ZM (u) = z}

{u|ZM (u)=z}

P (u)

P (u)
.

For example, given that the prisoner is dead, what is the probability that the prisoner were
(1−p)q
not dead if rifleman A had not shot? This is asking: PM (DA=f = f | D = t) = 1−(1−p)(1−q)
.

Markov Logic Style Weighted Rules under the Stable Model Semantics

11

4.4 PCM Counterfactuals in LPMLN
Counterfactual reasoning in PCM can be turned into LPMLN reasoning. The program LPMLN
Ptwin
consists of
M
• all rules in PM ;
• rule
α:

Vi∗ ← Fi∗ ∧ ¬Do(Vi = t) ∧ ¬Do(Vi = f)

for each equation Vi = Fi in M, where Vi∗ is a new symbol corresponding to Vi , and
Fi∗ is a formula obtained from F by replacing every occurrence of endogenous atoms
W with W ∗ .
• rule
α:

Vi∗ ← Do(Vi = t)

(4)

for every Vi ∈ V .
(Note that Do(Vi = t) is an atom, containing “=” as a part of the string.)
Theorem 4
For any PCM M = hhU, V, F i, P (U )i and any subsets X, Y , Z of V , which are not necessarily disjoint from each other,
∗
PM (YX=x = y | Z = z) = PrPtwin
∪Do(X=x) [Y = y | Z = z],
M

where Do(X = x) is {α : Do(Xi = xi ) | i = 1, . . . , |X|}.
Readers who are familiar with the twin network method for counterfactual reasoning (Balke
and Pearl 1994) would notice that Ptwin
∪ Do(X = x) represents the twin network obtained
M
from M, where starred atoms represent the counterfactual world.
For the Firing Squad example, Ptwin
MF S is the union of PMF S and the set of rules
α
α
α
α
α

:
:
:
:
:

C ∗ ← U, not Do(C = t), not Do(C = f)
A∗ ← C ∗ , not Do(A = t), not Do(A = f)
A∗ ← W, not Do(A = t), not Do(A = f)
B ∗ ← C ∗ ∧ ¬Do(B = t) ∧ ¬Do(B = f)
D∗ ← (A∗ ∨ B ∗ ) ∧ ¬Do(D = t) ∧ ¬Do(D = f)

and rules (4) for Vi ∈ {C, A, B, D}. In accordance with Theorem 4,
∗
PrPtwin
∪{α:Do(A=f )} [D = f | D = t] =
M
FS

(1 − p)q
.
1 − (1 − p)(1 − q)

The LPMLN representation is similar to the one in (Baral and Hunsaker 2007), which turns
PCM into P-log. However, the LPMLN representation is simpler; we require neither auxiliary
predicates, such as intervene and obs, nor strong negation.
4.5 Other Related Work
In (Lee and Wang 2015) it is shown that a version of ProbLog from (Fierens et al. 2013)
can be embedded in LPMLN . This result can be extended to embed Logic Programs with
Annotated Disjunctions (LPAD) in LPMLN based on the fact that any LPAD program can be

12

J. Lee and Y. Meng and Y. Wang

further turned into a ProbLog program by eliminating disjunctions in the heads (Gutmann
2011, Section 3.3).
It is known that LPAD is related to several other languages. In (Vennekens et al. 2004), it
is shown that Poole’s ICL (Poole 1997) can be viewed as LPAD, and that acyclic LPAD programs can be turned into ICL. This indirectly tells us how ICL can be embedded in LPMLN .
CP-logic (Vennekens et al. 2009) is a probabilistic extension of FO(ID) (Denecker and
Ternovska 2007). It is shown in (Vennekens et al. 2006), that CP-logic “almost completely
coincides” with LPAD.
P-log (Baral et al. 2009) is another language whose logical foundation is answer set programs. Like LPMLN , it considers the possible worlds to be answer sets, which represent an
agent’s rational beliefs, rather than any interpretations. The difference is that P-log’s probabilistic foundation is Causal Bayesian Networks, whereas Markov Logic serves as the probabilistic foundation of LPMLN . P-log is distinct from other earlier work in that it allows for
expressing probabilistic nonmonotonicity, the ability of the reasoner to change its probabilistic model as a result of new information. However, inference in the implementation of P-log
is not scalable as it has to enumerate all stable models.
PrASP (Nickles and Mileo 2014) is a recent language similar to LPMLN in that the probability distribution is obtained from the weights of the formulas. In addition, (Ng and Subrahmanian 1994) and (Saad and Pontelli 2005) introduce other probabilistic extensions of stable
model semantics.
While the study of more precise relationships between LPMLN and the above languages is
future work, one notable distinction is that LPMLN uses Markov Logic as a monotonic basis,
similar to the way ASP uses SAT as a monotonic basis. Most of the languages are meaningful only when the knowledge base is consistent, and thus do not address the inconsistency
handling as in LPMLN .

5 Conclusion
LPMLN is a simple, intuitive approach to combine both ASP and MLNs. LPMLN provides a
simple solution to inconsistency handling in ASP, especially when ASP knowledge bases are
combined from different sources.
While MLN is an undirected approach, LPMLN is a directed approach, where the directionality comes from the stable model semantics. This makes LPMLN closer to Pearl’s causal
models and ProbLog.
The work presented here calls for more future work. Obviously, there are many existing
languages that we did not formally compare with LPMLN . While a fragment of LPMLN can be
computed by existing implementations of and MLNs, one may design a native computation
method for the general case. The close relationship between LPMLN and MLNs may tell us
how to apply machine learning methods developed for MLNs to work with LPMLN programs.
Acknowledgements We are grateful to Michael Bartholomew, Amelia Harrison, and the
anonymous referees for their useful comments. This work was partially supported by the National Science Foundation under Grant IIS-1319794, South Korea IT R&D program MKE/KIAT
2010-TD-300404-001, and ICT R&D program of MSIP/IITP 10044494 (WiseKB).

Markov Logic Style Weighted Rules under the Stable Model Semantics

13

References
BALDUCCINI , M. AND G ELFOND , M. 2003. Logic programs with consistency-restoring rules3 . In
Working Notes of the AAAI Spring Symposium on Logical Formalizations of Commonsense Reasoning.
BALKE , A. AND P EARL , J. 1994. Counterfactual probabilities: Computational methods, bounds and
applications. In Proceedings of the Tenth international conference on Uncertainty in artificial intelligence. Morgan Kaufmann Publishers Inc., 46–54.
BARAL , C., G ELFOND , M., AND RUSHTON , J. N. 2009. Probabilistic reasoning with answer sets.
TPLP 9, 1, 57–144.
BARAL , C. AND H UNSAKER , M. 2007. Using the probabilistic logic programming language P-log for
causal and counterfactual reasoning and non-naive conditioning. In IJCAI. 243–249.
BAUTERS , K., S CHOCKAERT, S., D E C OCK , M., AND V ERMEIR , D. 2010. Possibilistic answer set
programming revisited. In 26th Conference on Uncertainty in Artificial Intelligence (UAI 2010).
B OCHMAN , A. AND L IFSCHITZ , V. 2015. Pearl’s causality in a logical setting. In Proceedings of the
AAAI Conference on Artificial Intelligence (AAAI).
D ENECKER , M. AND T ERNOVSKA , E. 2007. Inductive situation calculus. Artificial Intelligence 171, 5-6, 332–360.
FABER , W., L EONE , N., AND P FEIFER , G. 2004. Recursive aggregates in disjunctive logic programs:
Semantics and complexity. In Proceedings of European Conference on Logics in Artificial Intelligence (JELIA).
F ERRARIS , P. 2005. Answer sets for propositional theories. In Proceedings of International Conference
on Logic Programming and Nonmonotonic Reasoning (LPNMR). 119–131.
F ERRARIS , P., L EE , J., L IERLER , Y., L IFSCHITZ , V., AND YANG , F. 2012. Representing first-order
causal theories by logic programs. TPLP 12, 3, 383–412.
F IERENS , D., VAN DEN B ROECK , G., R ENKENS , J., S HTERIONOV, D., G UTMANN , B., T HON , I.,
JANSSENS , G., AND D E R AEDT, L. 2013. Inference and learning in probabilistic logic programs
using weighted boolean formulas. Theory and Practice of Logic Programming, 1–44.
G UTMANN , B. 2011. On continuous distributions and parameter estimation in probabilistic logic
programs. Ph.D. thesis, KU Leuven.
L EE , J. 2005. A model-theoretic counterpart of loop formulas. In Proceedings of International Joint
Conference on Artificial Intelligence (IJCAI). Professional Book Center, 503–508.
L EE , J. AND L IFSCHITZ , V. 2003. Loop formulas for disjunctive logic programs. In Proceedings of
the 19th International Conference on Logic Programming (ICLP). 451–465.
L EE , J. AND WANG , Y. 2015. A probabilistic extension of the stable model semantics. In International
Symposium on Logical Formalization of Commonsense Reasoning, AAAI 2015 Spring Symposium
Series. To appear.
L IN , F. AND Z HAO , Y. 2004. ASSAT: Computing answer sets of a logic program by SAT solvers.
Artificial Intelligence 157, 115–137.
M C C AIN , N. AND T URNER , H. 1997. Causal theories of action and change. In Proceedings of
National Conference on Artificial Intelligence (AAAI). 460–465.
N G , R. AND S UBRAHMANIAN , V. 1994. Stable semantics for probabilistic deductive databases. Information and computation 110, 1, 42–83.
N ICKLES , M. AND M ILEO , A. 2014. Probabilistic inductive logic programming based on answer set
programming.
N IEMEL Ä , I. AND S IMONS , P. 2000. Extending the Smodels system with cardinality and weight
constraints. In Logic-Based Artificial Intelligence, J. Minker, Ed. Kluwer, 491–521.
P EARL , J. 2000. Causality: models, reasoning and inference. Vol. 29. Cambridge Univ Press.
3

http://www.krlab.cs.ttu.edu/papers/download/bg03.pdf

14

J. Lee and Y. Meng and Y. Wang

P ELOV, N., D ENECKER , M., AND B RUYNOOGHE , M. 2007. Well-founded and stable semantics of
logic programs with aggregates. TPLP 7, 3, 301–353.
P OOLE , D. 1997. The independent choice logic for modelling multiple agents under uncertainty. Artificial Intelligence 94, 7–56.
S AAD , E. AND P ONTELLI , E. 2005. Hybrid probabilistic logic programming with non-monotoic
negation. In Proceedings of the 21st International Conference on Logic Programming (ICLP).
S ATO , T. 1995. A statistical learning method for logic programs with distribution semantics. In Proceedings of the 12th International Conference on Logic Programming (ICLP). 715–729.
S ON , T. C., P ONTELLI , E., AND T U , P. H. 2006. Answer sets for logic programs with arbitrary abstract
constraint atoms. In Proceedings, The Twenty-First National Conference on Artificial Intelligence
(AAAI).
V ENNEKENS , J., D ENECKER , M., AND B RUYNOOGHE , M. 2006. Representing causal information
about a probabilistic process. In Logics In Artificial Intelligence. 452–464.
V ENNEKENS , J., D ENECKER , M., AND B RUYNOOGHE , M. 2009. CP-logic: A language of causal
probabilistic events and its relation to logic programming. TPLP 9, 3, 245–308.
V ENNEKENS , J., V ERBAETEN , S., B RUYNOOGHE , M., AND A, C. 2004. Logic programs with annotated disjunctions. In Proceedings of the 20th International Conference on Logic Programming
(ICLP). 431–445.

A New Perspective on Stable Models∗
Paolo Ferraris1 , Joohyung Lee2 and Vladimir Lifschitz1
1

2

Department of Computer Sciences
University of Texas at Austin
1 University Station C0500
Austin, TX 78705
{otto,vl}@cs.utexas.edu
Abstract

Dept. of Computer Science and Engineering
Arizona State University
South Mill Avenue 574
Tempe, AZ 85281
joolee@asu.edu
are considered “stable models”; it turns out that the only stable model of (3) is

The deﬁnition of a stable model has provided a
declarative semantics for Prolog programs with
negation as failure and has led to the development
of answer set programming. In this paper we propose a new deﬁnition of that concept, which covers
many constructs used in answer set programming
(including disjunctive rules, choice rules and conditional literals) and, unlike the original deﬁnition,
refers neither to grounding nor to ﬁxpoints. Rather,
it is based on a syntactic transformation, which
turns a logic program into a formula of secondorder logic that is similar to the formula familiar
from the deﬁnition of circumscription.

{p(a), q(b), r(a)}.

In spite of this difference between the two deﬁnitions, there
is often a close relationship between the completion of a program and its stable models. For instance, in every model
of (2) (in the sense of ﬁrst-order logic) that satisﬁes the unique
names assumption a = b, the elements of set (4) are true, and
all other ground atoms are false.
Practical needs of answer set programming (ASP) have
led to the invention of several declarative programming constructs that are not used in Prolog. Clark’s completion semantics is not applicable to these constructs, at least directly. For
instance, the last rule of the program
p(a),
p(b),
{q(x) : p(x)}

1 Introduction
Two widely used deﬁnitions of the semantics of logic
programs—in terms of program completion [Clark, 1978]
and in terms of stable models [Gelfond and Lifschitz,
1988]—look very different from each other. The former treats
a logic program as shorthand for its completion, which is a
ﬁrst-order formula. For instance, the program
p(a),
q(b),
r(x) ← p(x), not q(x)

(1)

is a “choice rule” containing a “conditional literal” [Simons
et al., 2002]. Intuitively, this rule says: for any x such that
p(x), choose arbitrarily whether or not to include q(x) in the
stable model. The semantics of programs with choice rules,
like the original stable model semantics, is deﬁned in terms of
grounding and a ﬁxpoint condition. For instance, grounding
turns the last line of (5) into the ground choice rule
{q(a), q(b)}.
{p(a),
{p(a),
{p(a),
{p(a),

(2)

On the other hand, according to the stable model semantics, (1) is shorthand for the set of the ground instances of
its rules:
p(a),
q(b),
(3)
r(a) ← p(a), not q(a),
r(b) ← p(b), not q(b).
The deﬁnition of a stable model describes a ﬁxpoint construction that determines which sets of atomic formulas from (3)
∗

(5)

As it turns out, program (5) has 4 stable models:

is shorthand for
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b)
∧∀x(r(x) ↔ (p(x) ∧ ¬q(x))).

(4)

The ﬁrst and third authors were partially supported by the National Science Foundation under Grant IIS-0412907. The second
author was partially supported by DTO AQUAINT.

p(b)},
p(b), q(a)},
p(b), q(b)},
p(b), q(a), q(b)}.

(6)

In this paper we propose a new deﬁnition of a stable model,
which covers many constructs used in ASP (including disjunctive rules, choice rules, cardinality constraints and conditional literals) and refers neither to grounding nor to ﬁxpoints.
Rather, like the deﬁnition of program completion, the new
deﬁnition of a stable model is based on a transformation that
turns the given logic program into a formula of classical logic.
To be precise, the result of this transformation is a secondorder formula, which looks similar to the formula familiar from the deﬁnition of circumscription [McCarthy, 1980;
1986] in the form adopted in [Lifschitz, 1994].

IJCAI-07
372

The new deﬁnition and examples of its use are discussed
in Section 2 below. In Section 3 we relate our deﬁnition
to a theorem from [Lin, 1991], to the encoding of propositional logic programs by quantiﬁed Boolean formulas due to
Pearce, Tompits and Woltran [2001],1 and to recent research
on ﬁrst-order equilibrium logic [Pearce and Valverde, 2004;
2005]. A theorem about strong equivalence, illustrating the
nature of the ongoing work on reformulating the theory of
stable models on the basis of the new deﬁnition, is stated in
Section 4. Finally, in Section 5 we propose a way to generalize the concept of program completion that is similar to the
new deﬁnition of a stable model.
Our treatment of stable models may be of interest for three
reasons. First, it provides a new perspective on the place
of stable models within the ﬁeld of nonmonotonic reasoning. We can distinguish between “translational” nonmonotonic formalisms, such as program completion and circumscription, and “ﬁxpoint” formalisms—default logic [Reiter,
1980]2 and autoepistemic logic [Moore, 1985]. In the past,
stable models were seen as part of the “ﬁxpoint tradition.”
In fact, the invention of stable models was an outgrowth of
earlier work on the relationship between logic programming
and autoepistemic logic [Gelfond, 1987]; the ﬁrst journal paper on answer sets [Gelfond and Lifschitz, 1991] emphasized
their relation to default logic. The remarkable similarity between the new deﬁnition of a stable model and the deﬁnition
of circumscription is rather curious from this point of view.
Second, we expect that the new deﬁnition of stable models will provide a uniﬁed framework for useful answer set
programming constructs deﬁned and implemented by several different research groups, such as choice rules, cardinality constraints and conditional literals (Helsinki University of
Technology), disjunctive rules and aggregates [Faber et al.,
2004] (Vienna University of Technology and University of
Calabria), and ASET-Prolog constructs [Gelfond, 2002, Section 5.2] (Texas Tech University).
Finally, we hope that this deﬁnition of a stable model will
serve as a basis for a new approach to proving program correctness in ASP, which will be more straightforward than
the one based on grounding and ﬁxpoint deﬁnitions [Ferraris
and Lifschitz, 2005a, Sections 3.3–3.5, 3.7]. These correctness proofs will use equivalent transformations of formulas
of classical logic as the main tool.

2 Deﬁnition and Examples
2.1

Logic Programs as First-Order Formulas

The concept of a stable model will be deﬁned here for ﬁrstorder sentences (formulas without free variables); logic programs are viewed in this paper as alternative notation for ﬁrst1

The fact that circumscription is related to program completion
has been known for a long time [Reiter, 1982; Lifschitz, 1985].
The relationship between circumscription and the Pearce-TompitsWoltran transformation is discussed in [Ferraris et al., 2006, Appendix B].
2
The translational deﬁnition of default logic, proposed in [Lifschitz, 1990], is rather complicated: it uses third-order variables.

order sentences of special kinds.3
To rewrite a “traditional” program, such as (1), as a ﬁrstorder sentence, we
• replace every comma by ∧ and every not by ¬ ,
• turn every rule Head ← Body into a formula by rewriting it as the implication Body → Head, and
• form the conjunction of the universal closures of these
formulas.
For instance, we think of (1) as alternative notation for the
sentence
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x)).

(7)

We are going to treat ¬F as shorthand for F → ⊥, so that the
last conjunctive term can be further expanded into
∀x((p(x) ∧ (q(x) → ⊥)) → r(x)).
In the spirit of [Ferraris and Lifschitz, 2005b], (5) is understood as
p(a) ∧ p(b) ∧ ∀x(p(x) → (q(x) ∨ ¬q(x))).

(8)

Since the last conjunctive term is logically valid, the class
of models of formula (8) would not change if we dropped
that term; but the class of its stable models, as deﬁned below,
would be affected. In this sense, the last conjunctive term is
essential.
Finally, here is an example of turning a cardinality constraint [Simons et al., 2002] into a ﬁrst-order formula. The
rule
p ← 10 {q(x) : r(x)} 20
corresponds to the sentence
(∃10 x(q(x) ∧ r(x)) ∧ ¬∃21 x(q(x) ∧ r(x))) → p,

(9)

where ∃n xF (x) is understood as an abbreviation for
⎛
⎞


F (xi ) ∧
xi = xj ⎠ .
∃x1 · · · xn ⎝
1≤i≤n

2.2

1≤i<j≤n

Review of Circumscription

Since the new deﬁnition of a stable model looks similar to
the deﬁnition of circumscription, we will begin with a brief
review of the latter, for the special case when all predicate
constants occurring in the formula are circumscribed in parallel [Lifschitz, 1994, Section 7.1].
Both deﬁnitions use the following notation. If p and q are
predicate constants of the same arity then p = q stands for
the formula
∀x(p(x) ↔ q(x)),
3
In the propositional case, this approach to the syntax of ASP is
not new. The possibility of interpreting choice rules and weight constraints in terms of nested conjunctions, disjunctions and negations
was demonstrated in [Ferraris and Lifschitz, 2005b, Section 4.1].
General aggregates can be described in terms of nested implications
[Ferraris, 2005, Section 4]. Including second (“strong,” “classical,”
or “true”) negation without introducing an additional connective is
discussed in [Ferraris and Lifschitz, 2005a, Section 3.9].

IJCAI-07
373

• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);

and p ≤ q stands for

• (QxF )∗ = QxF ∗ , where Q ∈ {∀, ∃}.

∀x(p(x) → q(x)),
where x is a tuple of distinct object variables. If p and q are
tuples p1 , . . . , pn and q1 , . . . , qn of predicate constants then
p = q stands for the conjunction
p1 = q1 ∧ · · · ∧ pn = qn ,
and p ≤ q for
p1 ≤ q1 ∧ · · · ∧ pn ≤ qn .
Finally, p < q is an abbreviation for p ≤ q ∧ ¬(p = q).
In second-order logic, we will apply the same notation to
tuples of predicate variables.
Given a ﬁrst-order sentence F , by CIRC[F ] we denote the
second-order sentence
where p stands for the list of all predicate constants occurring in F , u is a list of distinct predicate variables of the same
length, and F (u) is the formula obtained from F by substituting the variables u for the constants p. Intuitively, the second
conjunctive term of CIRC[F ] expresses that the extents of the
predicates p are minimal subject to condition F .
For example, if F is

p(a) ∧ ∀x(p(x) → q(x))
∧¬∃uv(((u, v) < (p, q)) ∧ u(a) ∧ ∀x(u(x) → v(x))).
(11)
Using methods for eliminating second-order quantiﬁers discussed in [Lifschitz, 1994] and [Doherty et al., 1997], we can
simplify (11) and convert it into
(12)

There are cases when CIRC[F ] is not equivalent to any
ﬁrst-order formula, as, for instance, when F is
p(a) ∧ ∀x(p(x) → p(f (x))).

u(a) ∧ ∀x((u(x) → v(x)) ∧ (p(x) → q(x)))
p(a) ∧ ∀x(p(x) → q(x))
∧¬∃uv(((u, v) < (p, q)) ∧ u(a) ∧ ∀x((u(x) → v(x))
∧(p(x) → q(x)))).
It is clear that this formula is equivalent to (11), and consequently to (12).
In logic programming notation, (10) can be written as
p(a),
q(x) ← p(x).

(10)

then CIRC[F ] is

∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = a).

Example 1 If F is (10) then F ∗ (u, v) is
and SM[F ] is

F ∧ ¬∃u((u < p) ∧ F (u)),

p(a) ∧ ∀x(p(x) → q(x))

Note that the operator F → F ∗ (u) replaces each predicate
constant with the corresponding predicate variable, and that
it commutes with all propositional connectives except implication and with both quantiﬁers. If, in the deﬁnition of this
operator, we drop the second conjunctive term in the clause
for implication, then F ∗ (u) will turn into the formula F (u)
referred to in the deﬁnition of circumscription. That conjunctive term is the only difference between the deﬁnitions
of CIRC and SM.
A model of F is stable if it satisﬁes SM[F ].

(13)

The completion of this program
∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ p(x))
is equivalent to (12) as well. In this example, all three
transformations—SM, CIRC and completion—produce essentially the same result.
Example 2 If F is (13) then, as in the previous example, it is
clear that SM[F ] is equivalent to CIRC[F ]. Consequently, the
stable models of (13) can be characterized by the condition
stated at the end of the previous section: p is represented by
the set of the values of the terms a, f (a), f (f (a)), . . ..
In logic programming notation, (13) can be written as

In this example, a model of CIRC[F ] is any interpretation that represents p as the set of the values of the terms
a, f (a), f (f (a)), . . ..

2.3

p(a),
p(f (x)) ← p(x).

(14)

The completion of this program

Stable Models

Given a ﬁrst-order sentence F , by SM[F ] we denote the
second-order sentence
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where p stands for the list of all predicate constants
p1 , . . . , pn occurring in F , u is a list of n distinct predicate
variables u1 , . . . , un , and F ∗ (u) is deﬁned recursively:
• pi (t1 , . . . , tm )∗ = ui (t1 , . . . , tm );
• (t1 = t2 )∗ = (t1 = t2 );
• ⊥∗ = ⊥;
• (F 
 G)∗ = F ∗ 
 G∗ , where 
 ∈ {∧, ∨};

∀x(p(x) ↔ (x = a ∨ ∃y(x = f (y) ∧ p(y)))
is weaker than SM[F ]: some (non-Herbrand4) models of the
completion of (14) are not stable.
It is easy to see that the operator SM produces essentially
the same result as CIRC whenever it is applied to a formula corresponding to a set of Horn rules, as in the examples
An Herbrand interpretation of a signature σ containing at least
one object constant is an interpretation such that (i) its universe is the
set of all ground terms of σ, and (ii) every ground term represents
itself. Clearly, an Herbrand interpretation can be characterized by
the set of ground atoms to which it assigns the value true.

IJCAI-07
374

4

above.5 But if negation in the bodies of rules is allowed then
this may be no longer the case, as we will see Section 2.4.
What we can say, on the other hand, about this more general case is that stable Herbrand models of the corresponding
formula exactly correspond to the stable models of the program in the sense of the original deﬁnition from [Gelfond and
Lifschitz, 1988]:
Proposition 1 Let σ be a signature containing at least one
object constant, and Π a ﬁnite set of rules of the form
A0 ← A1 , . . . , Am , not Am+1 , . . . , not An ,

Example 4 If F is formula (8), corresponding to logic program (5), then a similar calculation converts SM[F ] into
p(a) ∧ p(b) ∧ ∀x(p(x) → (q(x) ∨ ¬q(x)))
∧¬∃uv(((u, v) < (p, q)) ∧ u(a) ∧ u(b)
∧∀x(u(x) → (v(x) ∨ ¬q(x)))).

(15)

where A0 , . . . , An are atomic formulas of σ not containing
equality. For any set X of ground terms of σ, the following
conditions are equivalent:
• X is a stable model of Π in the sense of the 1988 deﬁnition;
• the Herbrand interpretation of σ that makes the elements
of X true and all other ground atoms false is a stable
model of the formula corresponding to Π.
This theorem shows that the new deﬁnition of a stable
model, restricted to the “traditional” syntax, is a generalization of the 1988 deﬁnition to non-Herbrand models. In Section 3.1 we will see that our deﬁnition generalizes also the
deﬁnition proposed in [Ferraris, 2005] and used in [Ferraris
and Lifschitz, 2005a; Ferraris et al., 2006].

2.4

convert this formula into the completion (2) of program (1).
We conclude that in this case the stable models of the program
are identical to the models of its completion.
We can further conclude that there is a unique Herbrand
stable model in this case, and that it corresponds to the set (4)
of ground atoms. This fact follows also from Proposition 1.

Further Examples

Proposition 2 below allows us to simplify the application of
the operator SM to formulas containing negation. In its statement, p is the list of predicate constants occurring in F , and u
is a list of distinct predicate variables of the same length as p.
Proposition 2 If a formula F begins with ¬ then the formula
u ≤ p → (F ∗ (u) ↔ F )
is logically valid.
Example 3 Let F be formula (7), corresponding to logic
program (1). Then SM[F ] is
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x(((u(x) ∧ (¬q(x))∗ ) → w(x))
∧((p(x) ∧ ¬q(x)) → r(x)))).

After the elimination of second-order quantiﬁers, this formula
becomes
∀x(p(x) ↔ (x = a ∨ x = b))
∧∀x(q(x) → (x = a ∨ x = b)).
The stable models of (5) can be characterized as the interpretations that (i) represent p by the set of values of a and b, and
(ii) represent q by a subset of that set. Consequently, (8) has 4
Herbrand stable models, and they correspond to sets (6).
We call a formula negative if every occurrence of every
predicate constant in this formula belongs to the antecedent
of an implication. Clearly any formula of the form ¬F is
negative, because this expression is shorthand for F → ⊥
(Section 2.1). Proposition 2 can be generalized to arbitrary
negative formulas.

3 Relation to Earlier Work
3.1

3.2

It is clear that the implication in the last line can be dropped.
Furthermore, since the subformula (u, v, w) < (p, q, r) contains the conjunctive term v ≤ q, from Proposition 2 we can
conclude that (¬q(x))∗ can be equivalently replaced here by
¬q(x). Consequently, SM[F ] can be rewritten as
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))
∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x((u(x) ∧ ¬q(x)) → w(x))).
Using the methods for eliminating second-order quantiﬁers
described at the end of [Lifschitz, 1994, Section 3.3], we can
5
This assertion remains true if we allow the heads of rules to be
disjunctions of atomic formulas.

Propositional Case

In the propositional case, the operator SM turns into the
encoding of formulas of equilibrium logic by quantiﬁed
Boolean formulas proposed in [Pearce et al., 2001] and reviewed in [Ferraris et al., 2006, Appendix B]. In view of the
Pearce-Tompits-Woltran theorem, as restated in that review, it
follows that in the propositional case our deﬁnition of a stable
model is equivalent to the deﬁnition of a stable model (answer
set) proposed in [Ferraris, 2005] and reviewed in [Ferraris et
al., 2006, Appendix A].

Lin’s Transformation

Theorem 5 from [Lin, 1991] relates stable models of “traditional programs” (as in Proposition 1 above) to circumscription. It involves a syntactic transformation that can be described as a sequence of three steps. First, each rule is turned
into a formula that may contain new predicate constants—
“doubles” p of the predicate constants p occurring in the rule.
Second, the new predicate constants are circumscribed in parallel. Third, the result is conjoined with the equivalences
p = p. We will show that this idea is applicable to arbitrary
ﬁrst-order sentences, and that the result of this transformation
is closely related to the operator SM.
To do this, we need parallel circumscription of a slightly
more general kind than deﬁned in Section 2.2. In the deﬁnition of circumscription, there is no need to assume that p
stands for the list of all predicate constants occurring in F ;
p may include only some of these constants. The result of

IJCAI-07
375

circumscribing the predicate constants p in a ﬁrst-order sentence F will be denoted by CIRC[F ; p]. For instance, if F
is (10) then CIRC[F ; q] is
p(a) ∧ ∀x(p(x) → q(x))
∧¬∃v((v < q) ∧ p(a) ∧ ∀x(p(x) → v(x))),

f

• I |= ⊥;
• I |= F ∧ G if I |= F and I |= G; similarly for ∨;
• I |= F → G if
(i) I |= F or I |= G, and
(ii) I, I t  |= F → G;

which is equivalent to
p(a) ∧ ∀x(p(x) ↔ q(x)).
Let F be a ﬁrst-order sentence, and let p be the list of all
predicate constants occurring in F . Take a list p of distinct
predicate constants that do not occur in F , of the same length
as p. By L[F ; p ] we denote the formula
CIRC[F ∗ (p ); p ] ∧ (p = p).

Equilibrium Logic

The deﬁnition of ﬁrst-order equilibrium logic below is similar
to the one proposed in [Pearce and Valverde, 2005, Section 7],
except that ground terms are not identiﬁed here with their values; as a result, different ground terms are allowed to have the
same value. Our deﬁnition describes essentially Kripke models with two worlds (“here” and “there”) that have the same
universe, interpret all function constants in the same way, and
satisfy the minimality condition introduced in [Pearce, 1997].
If I is an interpretation of a signature σ (in the sense of
classical logic) then by σ I we denote the extension of σ obtained by adding pairwise distinct symbols ξ ∗ , called names,
for all elements ξ of the universe of I as object constants. We
will identify I with its extension to σ I deﬁned by I(ξ ∗ ) = ξ.
The value that I assigns to a ground term t of signature σ I
will be denoted by tI .
By σf we denote the part of σ consisting of its function
constants (including object constants, which are viewed as
function constants of arity 0). We will represent an interpretation I of σ as the pair I|σf , I  , where I  is the set of
all atomic formulas, formed using predicate constants from σ
and names ξ ∗ , which are satisﬁed by I.
An HT-interpretation of σ is a triple I f , I h , I t , where
• I f is an interpretation of σf , and
• I h , I t are sets of atomic formulas formed using predicate constants from σ and object constants ξ ∗ for arbitrary elements ξ of the universe of I f , such that I h ⊆ I t .
The satisfaction relation between an HT-interpretation
f
h
I = I f , I h , I t  and a sentence F of the signature σ I ,I 
is deﬁned recursively:
f

f

• I |= p(t1 , . . . , tn ) if p((tI1 )∗ , . . . , (tIn )∗ ) ∈ I h ;

• I |= ∀xF (x) if, for each ξ from the universe of I f ,
I |= F (ξ ∗ ); similarly for ∃.
(In (ii) we understand satisfaction as in classical logic.)
An HT-interpretation of the form I, J, J is an equilibrium
model of F if
• I, J, J |= F , and

This formula turns out to be equivalent to SM[F ] conjoined
with explicit deﬁnitions of the new predicate constants p :
Proposition 3 L[F ; p ] is equivalent to SM[F ] ∧ (p = p).
This is immediate from the deﬁnitions of L and SM, using the
fact that F ∗ (p) is equivalent to F .
It follows that SM[F ] is equivalent to L[F ; p ] with the
predicate constants p replaced by existentially quantiﬁed
predicate variables:
Corollary 1 SM[F ] is equivalent to ∃u L[F ; u].

3.3

f

• I |= t1 = t2 if tI1 = tI2 ;

• for any proper subset J  of J, I, J  , J |= F .
This deﬁnition provides a precise model-theoretic counterpart of the operator SM:
Proposition 4 An interpretation I, J is a stable model of a
sentence F iff I, J, J is an equilibrium model of F .

4 Strong Equivalence
To turn the deﬁnition of a stable model proposed in this paper into a tool that can help us in the design of provably
correct ASP programs, we need to ﬁnd appropriate counterparts of the theorems that are used in correctness proofs today.6 The “traditional” theorems about stable models will
roughly correspond to the special cases of these new theorems in which the formulas involved are propositional combinations of ground atoms, perhaps of a special syntactic form,
and our attention is restricted to Herbrand models.
To give an example illustrating this general point, we state
here a counterpart of the characterization of strong equivalence [Lifschitz et al., 2001] due to Fangzhen Lin [2002].
About ﬁrst-order sentences F and G we say that F is
strongly equivalent to G if, for every sentence H (possibly
of a larger signature), F ∧ H has the same stable models
as G ∧ H (or, to put it differently, if, for every H, SM[F ∧ H]
is equivalent to SM[G ∧ H]). In the following theorem, p
is the list of predicate constants occurring in at least one of
the sentences F , G, and p is a list of new, distinct predicate
constants of the same length as p.
Proposition 5 F is strongly equivalent to G iff the formula
p ≤ p → (F ∗ (p ) ↔ G∗ (p ))
is logically valid.
Using this theorem we can show, for instance, that
¬∀xF (x) is strongly equivalent to ∃x¬F (x). (This is a predicate logic counterpart of the fact that ¬(F ∧ G) is strongly
equivalent to ¬F ∨ ¬G.) Indeed, in view of Proposition 2, the
implications
p ≤ p → ((¬∀xF (x))∗ ↔ ¬∀xF (x)),
p ≤ p → ((∃x¬F (x))∗ ↔ ∃x¬F (x));
6
See, for instance, [Ferraris and Lifschitz, 2005a, Sections 2.1–
2.4, 2.6–3.1].

IJCAI-07
376

are logically valid; the right-hand sides of the two equivalences are classically equivalent to each other.
For our proof of the “only if” part of Proposition 5 it is not
essential that the deﬁnition of strong equivalence allows the
signature of H to be larger than the signature of F and G. It
follows that F is strongly equivalent to G whenever F ∧ H
has the same stable models as G ∧ H for all sentences H of
the same signature as F and G.
Relations between logic programs with variables, somewhat similar to strong equivalence as deﬁned above but more
limited in scope, are discussed in [Pearce and Valverde, 2005,
Section 7] and [Eiter et al., 2006].

5 A New Perspective on Program Completion
5.1

Pointwise Stable Models

As observed in [Lee and Lin, 2006], program completion is similar in some ways to the concept of pointwise
circumscription—the modiﬁcation of McCarthy’s original
deﬁnition that was proposed in [Lifschitz, 1987]. According to either deﬁnition, circumscribing a predicate constant p
makes the extent of p “minimal,” but minimality is understood in different versions differently. According to the original deﬁnition of circumscription, to make the extent of a predicate smaller means to replace it by a proper subset. In the
pointwise version, to make the extent of a predicate smaller
means to decrement it by a single point. The pointwise minimality condition is, generally, weaker than minimality according to McCarthy; similarly, program completion is generally weaker than the stability condition.
In this section, we deﬁne a weakened, “pointwise” version
of the operator SM that can be viewed as a generalization of
program completion to arbitrary ﬁrst-order formulas.
If p and q are predicate constants of the same arity k then
1

p < q stands for the formula
∃x(q(x) ∧ ∀y(p(y) ↔ (q(y) ∧ x = y))),
where x, y are disjoint tuples of distinct object variables
x1 , . . . , xk , y1 , . . . , yk , and x = y is shorthand for
¬(x1 = y1 ∧ · · · ∧ xk = yk ).
This formula expresses that the extent of p can be obtained
from the extent of q by removing one element. If p and q are
tuples p1 , . . . , pn and q1 , . . . , qn of predicate constants then
1

p < q stands for the disjunction
⎛


1
⎝(pi < qi ) ∧
1≤i≤n

⎞
(pj = qj )⎠ ,

1≤j≤n, j=i

and similarly for tuples of predicate variables.
Given a ﬁrst-order sentence F , by PSM[F ] we denote the
second-order sentence
1

F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where p, u and F ∗ (u) are as in the deﬁnition of SM (Section 2.3). A model of F is pointwise stable if it satisﬁes
PSM[F ]. Clearly, every stable model is pointwise stable.
Unlike SM[F ], the weaker formula PSM[F ] can be always
rewritten without second-order quantiﬁers:

Proposition 6 Formula PSM[F ] is equivalent to

¬∃xi (pi (xi ) ∧ Gi (xi )),
F∧
1≤i≤n

where Gi (xi ) stands for
F ∗ (p1 , . . . , pi−1 , λyi (pi (yi ) ∧ yi = xi ), pi+1 , . . . , pn )
and xi , yi are disjoint tuples of distinct variables.7
For instance, if F is p(a) ∧ p(b) then F ∗ (u) is u(a) ∧ u(b),
so that F ∗ (λy(p(y) ∧ y = x)) is
p(a) ∧ a = x ∧ p(b) ∧ b = x,
and PSM[F ] is
p(a) ∧ p(b) ∧ ¬∃x(p(x) ∧ p(a) ∧ a = x ∧ p(b) ∧ b = x).
This formula can be simpliﬁed:
p(a) ∧ p(b) ∧ ¬∃x(p(x) ∧ a = x ∧ b = x).
In this example, PSM[F ] is obviously equivalent to the
completion of F :
∀x(p(x) ↔ (x = a ∨ x = b)).
This fact is an instance of the general theorem stated below.

5.2

Relation to Program Completion

Lloyd and Topor [1984] noted that the process of completing
a program can be extended in an obvious way to rules of a
more general form than allowed in [Clark, 1978]. It is essential that the head of a rule be an atom, but the body can be an
arbitrary ﬁrst-order formula.
Proposition 7 below refers to completion in this more general sense, but it does introduce a restriction on the syntactic
form of the bodies of rules. The rules we consider in this
section have the form
(16)
p0 (t0 ) ← p1 (t1 ) ∧ · · · ∧ pm (tm ) ∧ N,
where ti are tuples of terms and N is a negative formula (see
Section 2.4). For instance, every rule of form (15) has also
form (16): take N to be ¬Am+1 ∧ · · · ∧ ¬An .
A rule of form (16) is acyclic if for each i = 1, . . . , m such
that pi is p0 , the formula
N → t0 = ti
is logically valid. For instance, each of the rules (1) is obviously acyclic—its body doesn’t contain the predicate constant
occurring in the head. Any rule of form (16) can be made
acyclic by a strongly equivalent transformation: conjoin the
body with the formulas t0 = ti for all i = 1, . . . , m such that
pi is p0 . For instance, the second rule of (14) can be rewritten
as the acyclic rule
p(f (x)) ← p(x), f (x) = x.
For this reason, the requirement in the statement of the theorem below that each of the given rules be acyclic is not an
essential limitation.
Proposition 7 For any ﬁnite set F of acyclic rules, the completion of F is equivalent to PSM[F ].
In view of this fact, PSM[F ] can be viewed as an extension
of the concept of program completion to arbitrary ﬁrst-order
formulas.
7
On the use of λ-notation in ﬁrst-order logic, see [Lifschitz,
1994, Section 3.1].

IJCAI-07
377

5.3

6 Conclusion

Tight Formulas

François Fages [1991] showed that if a logic program satisﬁes
a certain syntactic condition, which is now called “tightness,”
then its stable models can be characterized as the models of
its completion. This theorem and its generalizations (see [Erdem and Lifschitz, 2003]) play an important role in answer
set programming.
Consider, for instance, logic programs consisting of rules
of form (16). According to the deﬁnition of a tight program,
to decide whether such a program is tight we should look at
its “predicate dependency graph.” The vertices of this graph
are the predicate constants occurring in the program, and its
edges lead from p0 to p1 , . . . , pm for the rules (16) that the
program consists of. The program is called tight if its predicate dependency graph is acyclic.
Proposition 8 below extends Fages’s theorem to the general
framework introduced in this note. To deﬁne the predicate dependency graph for an arbitrary ﬁrst-order sentence, we need
a few auxiliary deﬁnitions.
Recall that an occurrence of a subformula or a predicate
constant in a formula F is positive if the number of implications in F containing that occurrence in the antecedent is
even; it is strictly positive if that number is 0.8 In (7), for instance, both occurrences of q are positive, but only the ﬁrst is
strictly positive. The key idea of our deﬁnition of the predicate dependency graph for an arbitrary formula F is to concentrate on the implications G → H that have strictly positive
occurrences in F ; such implications generalize the concept of
a rule in traditional logic programs.
We say that a predicate constant p depends on a predicate
constant q in an implication G → H if
• p has a strictly positive occurrence in H, and
• q has a positive occurrence in G that does not belong to
any occurrence of a negative formula in G.
The predicate dependency graph of a formula F is the directed graph such that
• its vertices are the predicate constants occurring in F ,
and
• it has an edge from a vertex p to a vertex q if p depends
on q in an implication that has a strictly positive occurrence in F .
For instance, the predicate dependency graph of formula (7)
has three vertices p, q, r and one edge, from r to q. This is
the same graph as the one given by the more special deﬁnition
reviewed above applied to the “logic programming representation” (1) of formula (7).
Just as in the special case above, we say that a formula F
is tight if its predicate dependency graph is acyclic. For instance, formulas (7)–(10) are tight; formula (13) is not tight,
because its predicate dependency graph is a self-loop.
Proposition 8 For any tight sentence F , PSM[F ] is equivalent to SM[F ].
8

Note that we apply the term “negative” to formulas, and the
terms “positive” and “strictly positive” to occurrences of subformulas and predicate constants in a formula.

The deﬁnition of a stable model proposed in this paper is applicable both to rules covered by the original 1988 deﬁnition
and to rules of several more general kinds used in answer set
programming. Instead of grounding and ﬁxpoints, it refers to
a translation into classical logic, and is in this sense close to
the deﬁnitions of program completion and circumscription.
The relationship between the original deﬁnition of a stable
model and the deﬁnition proposed here can be compared with
the relationship between two deﬁnitions of a causal theory—
the original deﬁnition introduced in [McCain and Turner,
1997] and its generalization proposed in [Lifschitz, 1997].
The original deﬁnition uses a ﬁxpoint construction; the generalization is based on a translation into classical logic.
Another deﬁnition of a stable model for ﬁrst-order order
sentences is given independently by Lin and Zhou [2007]. It
refers to grounding, but in other ways it is similar to ours.
Extending main results of the theory of stable models to the
general framework described above is a topic of future work.

Acknowledgements
We are grateful to Pedro Cabalar, Martin Gebser and Hudson
Turner for useful comments on this paper.

References
[Clark, 1978] Keith Clark. Negation as failure. In Herve
Gallaire and Jack Minker, editors, Logic and Data Bases,
pages 293–322. Plenum Press, New York, 1978.
[Doherty et al., 1997] Patrick Doherty, Witold Łukaszewicz,
and Andrzey Szałas. Computing circumscription revisited:
A reduction algorithm. Journal of Automated Reasoning,
18(3):297–336, 1997.
[Eiter et al., 2006] Thomas Eiter, Michael Fink, Hans Tompits, Patrick Traxler, and Stefan Woltran. Replacements
in non-ground answer-set programming. In Proceedings
of International Conference on Principles of Knowledge
Representation and Reasoning (KR), 2006.
[Erdem and Lifschitz, 2003] Esra Erdem and Vladimir Lifschitz. Tight logic programs. Theory and Practice of Logic
Programming, 3:499–518, 2003.
[Faber et al., 2004] Wolfgang Faber, Nicola Leone, and
Gerard Pfeifer.
Recursive aggregates in disjunctive
logic programs: Semantics and complexity. In Proceedings of European Conference on Logics in Artiﬁcial Intelligence (JELIA), 2004.
Revised version:
http://www.wfaber.com/research/papers/
jelia2004.pdf.
[Fages, 1991] François Fages. A ﬁxpoint semantics for general logic programs compared with the well–supported
and stable model semantics. New Generation Computing,
9:425–443, 1991.
[Ferraris and Lifschitz, 2005a] Paolo Ferraris and Vladimir
Lifschitz. Mathematical foundations of answer set programming. In We Will Show Them! Essays in Honour of
Dov Gabbay, pages 615–664. King’s College Publications,
2005.

IJCAI-07
378

[Ferraris and Lifschitz, 2005b] Paolo Ferraris and Vladimir
Lifschitz. Weight constraints as nested expressions. Theory and Practice of Logic Programming, 5:45–74, 2005.
[Ferraris et al., 2006] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. A generalization of the Lin-Zhao theorem. Annals of Mathematics and Artiﬁcial Intelligence,
2006. To appear.
[Ferraris, 2005] Paolo Ferraris. Answer sets for propositional theories. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 119–131, 2005.
[Gelfond and Lifschitz, 1988] Michael
Gelfond
and
Vladimir Lifschitz. The stable model semantics for
logic programming. In Robert Kowalski and Kenneth
Bowen, editors, Proceedings of International Logic Programming Conference and Symposium, pages 1070–1080,
1988.
[Gelfond and Lifschitz, 1991] Michael
Gelfond
and
Vladimir Lifschitz. Classical negation in logic programs and disjunctive databases.
New Generation
Computing, 9:365–385, 1991.
[Gelfond, 1987] Michael Gelfond. On stratiﬁed autoepistemic theories. In Proceedings of National Conference on
Artiﬁcial Intelligence (AAAI), pages 207–211, 1987.
[Gelfond, 2002] Michael Gelfond. Representing knowledge in A-Prolog. Lecture Notes in Computer Science,
2408:413–451, 2002.
[Lee and Lin, 2006] Joohyung Lee and Fangzhen Lin. Loop
formulas for circumscription.
Artiﬁcial Intelligence,
170(2):160–185, 2006.
[Lifschitz et al., 2001] Vladimir Lifschitz, David Pearce,
and Agustin Valverde. Strongly equivalent logic programs.
ACM Transactions on Computational Logic, 2:526–541,
2001.
[Lifschitz, 1985] Vladimir Lifschitz. Computing circumscription. In Proceedings of International Joint Conference on Artiﬁcial Intelligence (IJCAI), pages 121–127,
1985.
[Lifschitz, 1987] Vladimir Lifschitz. Pointwise circumscription. In Matthew Ginsberg, editor, Readings in nonmonotonic reasoning, pages 179–193. Morgan Kaufmann, San
Mateo, CA, 1987.
[Lifschitz, 1990] Vladimir Lifschitz. On open defaults. In
John Lloyd, editor, Computational Logic: Symposium
Proceedings, pages 80–95. Springer, 1990.
[Lifschitz, 1994] Vladimir Lifschitz. Circumscription. In
D.M. Gabbay, C.J. Hogger, and J.A. Robinson, editors,
The Handbook of Logic in AI and Logic Programming,
volume 3, pages 298–352. Oxford University Press, 1994.
[Lifschitz, 1997] Vladimir Lifschitz. On the logic of causal
explanation. Artiﬁcial Intelligence, 96:451–465, 1997.
[Lin and Zhou, 2007] Fangzhen Lin and Yi Zhou. From answer set logic programming to circumscription via logic of
GK. In Proceedings of International Joint Conference on
Artiﬁcial Intelligence (IJCAI), 2007. This volume.

[Lin, 1991] Fangzhen Lin. A Study of Nonmonotonic Reasoning. PhD thesis, Stanford University, 1991.
[Lin, 2002] Fangzhen Lin. Reducing strong equivalence of
logic programs to entailment in classical propositional
logic. In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),
pages 170–176, 2002.
[Lloyd, 1984] John Lloyd. Foundations of Logic Programming. Springer-Verlag, 1984.
[McCain and Turner, 1997] Norman McCain and Hudson
Turner. Causal theories of action and change. In Proceedings of National Conference on Artiﬁcial Intelligence
(AAAI), pages 460–465, 1997.
[McCarthy, 1980] John McCarthy. Circumscription—a form
of non-monotonic reasoning.
Artiﬁcial Intelligence,
13:27–39,171–172, 1980.
[McCarthy, 1986] John McCarthy. Applications of circumscription to formalizing common sense knowledge. Artiﬁcial Intelligence, 26(3):89–116, 1986.
[Moore, 1985] Robert Moore. Semantical considerations on
nonmonotonic logic. Artiﬁcial Intelligence, 25(1):75–94,
1985.
[Pearce and Valverde, 2004] David Pearce and Agustin
Valverde. Towards a ﬁrst order equilibrium logic for
nonmonotonic reasoning. In Proceedings of European
Conference on Logics in Artiﬁcial Intelligence (JELIA),
pages 147–160, 2004.
[Pearce and Valverde, 2005] David Pearce and Agustin
Valverde.
A ﬁrst order nonmonotonic extension of
constructive logic. Studia Logica, 80:323–348, 2005.
[Pearce et al., 2001] David Pearce, Hans Tompits, and Stefan Woltran. Encodings for equilibrium logic and logic
programs with nested expressions. In Proceedings of
Portuguese Conference on Artiﬁcial Intelligence (EPIA),
pages 306–320, 2001.
[Pearce, 1997] David Pearce. A new logical characterization of stable models and answer sets. In Jürgen
Dix, Luis Pereira, and Teodor Przymusinski, editors,
Non-Monotonic Extensions of Logic Programming (Lecture Notes in Artiﬁcial Intelligence 1216), pages 57–70.
Springer-Verlag, 1997.
[Reiter, 1980] Raymond Reiter. A logic for default reasoning. Artiﬁcial Intelligence, 13:81–132, 1980.
[Reiter, 1982] Raymond Reiter. Circumscription implies
predicate completion (sometimes). In Proceedings of
International Joint Conference on Artiﬁcial Intelligence
(IJCAI), pages 418–420, 1982.
[Simons et al., 2002] Patrik Simons, Ilkka Niemelä, and
Timo Soininen. Extending and implementing the stable
model semantics. Artiﬁcial Intelligence, 138:181–234,
2002.

IJCAI-07
379

Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence

Action Language BC: Preliminary Report
Joohyung Lee1 , Vladimir Lifschitz2 and Fangkai Yang2
1
School of Computing, Informatics and Decision Systems Engineering,
Arizona State University joolee@asu.edu
2
Department of Computer Science, Univeristy of Texas at Austin
{vl,fkyang}@cs.utexas.edu
Abstract

solves the frame problem by incorporating the commonsense
law of inertia in its semantics, which makes it difficult to talk
about fluents whose behavior is described by defaults other
than inertia. The position of a moving pendulum, for instance, is a non-inertial fluent: it changes by itself, and an
action is required to prevent the pendulum from moving. The
amount of liquid in a leaking container changes by itself, and
an action is required to prevent it from decreasing. A springloaded door closes by itself, and an action is required to keep
it open. Work on the action language C and its extension C+
was partly motivated by examples of this kind. In these languages, the inertia assumption is expressed by axioms that the
user is free to include or not to include. Other default assumptions about the relationship between the values of a fluent at
different time instants can be postulated as well. On the other
hand, some recursive definitions cannot be easily expressed
in C and C+.
In this paper we define a new action description language,
called BC, that combines the attractive features of B and C+.
This language, like B, can be implemented using computational methods of answer set programming [Marek and
Truszczynski, 1999; Niemelä, 1999; Lifschitz, 2008].
The main difference between B and BC is similar to the
difference between inference rules and default rules. Informally speaking, a default rule allows us to derive its conclusion from its premise if its justification can be consistently
assumed; default logic [Reiter, 1980] makes this idea precise.
In the language B, a static law has the form
< conclusion > if < premise > .
In BC, a static law may include a justification:
< conclusion > if < premise > if cons < justification >
(if cons is an acronym for “if consistent”). Dynamic laws may
include justifications also.
The semantics of BC is defined by transforming action descriptions into logic programs under the stable model semantics. When static and dynamic laws of the language B are
translated into the language of logic programming, as in [Balduccini and Gelfond, 2003], the rules that we get do not contain negation as failure. Logic programs corresponding to Bdescriptions do contain negation as failure, but this is because
inertia rules are automatically included in them. In the case
of BC, on the other hand, negation as failure is used for translating justifications in both static and dynamic laws.

The action description languages B and C have significant common core. Nevertheless, some expressive possibilities of B are difficult or impossible to
simulate in C, and the other way around. The main
advantage of B is that it allows the user to give
Prolog-style recursive definitions, which is important in applications. On the other hand, B solves
the frame problem by incorporating the commonsense law of inertia in its semantics, which makes
it difficult to talk about fluents whose behavior is
described by defaults other than inertia. In C and
in its extension C+, the inertia assumption is expressed by axioms that the user is free to include or
not to include, and other defaults can be postulated
as well. This paper defines a new action description language, called BC, that combines the attractive features of B and C+. Examples of formalizing
commonsense domains discussed in the paper illustrate the expressive capabilities of BC and the use
of answer set solvers for the automation of reasoning about actions described in this language.

1

Introduction

Action description languages are formal languages for describing the effects and executability of actions. “Second
generation” action description languages, such as B [Gelfond
and Lifschitz, 1998, Section 5], C [Giunchiglia and Lifschitz,
1998], and C+ [Giunchiglia et al., 2004, Section 4], differ
from the older languages STRIPS [Fikes and Nilsson, 1971]
and ADL [Pednault, 1989] in that they allow us to describe
indirect effects of an action—effects explained by interaction
between fluents.
The languages B and C have significant common core [Gelfond and Lifschitz, 2012]. Nevertheless, some expressive
possibilities of B are difficult or impossible to simulate in C,
and the other way around. The main advantage of B is that it
allows the user to give Prolog-style recursive definitions. Recursively defined concepts, such as the reachability of a node
in a graph, play important role in applications of automated
reasoning about actions, including the design of the decision
support system for the Space Shuttle [Nogueira et al., 2001].
On the other hand, the language B, like STRIPS and ADL,

983

We define here three translations from BC into logic programming. Their target languages use slightly different versions of the stable model semantics, but we show that all three
translations give the same meaning to BC-descriptions. The
first version uses nested occurrences of negation as failure
[Lifschitz et al., 1999]; the second involves strong (classical)
negation [Gelfond and Lifschitz, 1991] but does not require
nesting; the third produces multi-valued formulas under the
stable model semantics [Bartholomew and Lee, 2012]. The
third translation is particularly simple, because BC and multivalued formulas have much in common: both languages are
designed for talking about non-Boolean fluents. But we start
with defining the other two translations, because their target
languages are more widely known.
Examples of formalizing commonsense domains discussed
in this paper illustrate the expressive capabilities of BC and
the use of answer set solvers for the automation of reasoning
about actions described in this language. We state also two
theorems relating BC to B and to C+.

2

stands for
A0 after a, A1 , . . . , Am .
An action description in the language BC is a finite set consisting of static and dynamic laws.

3

Static laws of the form
A0 if A1 , . . . , Am if cons A0
A0 after A1 , . . . , Am if cons A0

(4)

will be particularly useful. They are similar to normal defaults in the sense of [Reiter, 1980]. We will write (3) as
default A0 if A1 , . . . , Am ,
and we will drop if when m = 0. We will write (4) as
default A0 after A1 , . . . , Am .
For any regular fluent constant f , the set of the dynamic
laws
default f = v after f = v
for all v in the domain of f expresses the commonsense law
of inertia for f . We will denote this set by

Syntax

inertial f.

4

(5)

Semantics

For every action description D, we will define a
sequence of logic programs with nested expressions
PN0 (D), PN1 (D), . . . so that the stable models of PNl (D)
represent paths of length l in the transition system corresponding to D. The signature σD,l of PNl (D) consists of
• expressions i : A for nonnegative integers i ≤ l and all
atoms A, and
• expressions i : a for nonnegative integers i < l and all
action constants a.
Thus every element of the signature σD,l is a “time stamp” i
followed by an atom in the sense of Section 2 or by an action
constant. The program consists of the following rules:
• the translations
i : A0 ← i : A1 , . . . , i : Am ,
not not i : Am+1 , . . . , not not i : An

(1)

(n ≥ m ≥ 0), where each Ai is an atom. It expresses,
informally speaking, that every state satisfies A0 if it satisfies A1 , . . . , Am , and Am+1 , . . . , An can be consistently assumed. If m = 0 then we will drop if; if m = n then we will
drop if cons.
A dynamic law is an expression of the form
A0 after A1 , . . . , Am if cons Am+1 , . . . , An

(3)

and dynamic laws of the form

An action description in the language BC includes a finite
set of symbols of two kinds, fluent constants and action constants. Fluent constants are further divided into regular and
statically determined. A finite set of cardinality ≥ 2, called
the domain, is assigned to every fluent constant.
An atom is an expression of the form f = v, where f is
a fluent constant, and v is an element of its domain. If the
domain of f is {f, t} then we say that f is Boolean.
A static law is an expression of the form
A0 if A1 , . . . , Am if cons Am+1 , . . . , An

Defaults and Inertia

(2)

(n ≥ m ≥ 0), where
• A0 is an atom containing a regular fluent constant,
• each of A1 , . . . , Am is an atom or an action constant,
and
• Am+1 , . . . , An are atoms.
It expresses, informally speaking, that the end state of any
transition satisfies A0 if its beginning state and its action satisfy A1 , . . . , Am , and Am+1 , . . . , An can be consistently assumed about the end state. If m = n then we will drop if cons.
For any action constant a and atom A,

(i ≤ l) of all static laws (1) from D,
• the translations
(i + 1) : A0 ← i : A1 , . . . , i : Am ,
not not (i + 1) : Am+1 , . . . , not not (i + 1) : An
(i < l) of all dynamic laws (2) from D,
• the choice rule1 {0 : A} for every atom A containing a
regular fluent constant,

a causes A

1
A choice rule {E} can be viewed as shorthand for the disjunctive nested expression E; not E [Ferraris and Lifschitz, 2005], or,
equivalently, for the rule

stands for
A after a.
For any action constant a and atoms A0 , . . . , Am (m > 0),

E ← not not E.

a causes A0 if A1 , . . . , Am

984

5

• the choice rule {i : a} for every action constant a and
every i < l,
• the existence of value constraint

Other Abbreviations

In BC-descriptions that involve Boolean fluent constants we
will use abbreviations similar to those established for multivalued formulas in [Giunchiglia et al., 2004, Section 2.1]:
if f is Boolean then we will write the atom f = t as f , and the
atom f = f as ∼f .
A static constraint is a pair of static laws of the form

← not i : (f = v1 ), . . . , not i : (f = vk )
for every fluent constant f and every i ≤ l, where
v1 , . . . , vk are all elements of the domain of f ,
• the uniqueness of value constraint

f = v if A1 , . . . , Am
f = w if A1 , . . . , Am

← i : (f = v), i : (f = w)

(6)

where v 6= w and m > 0. We will write (6) as

for every fluent constant f , every pair of distinct elements v, w of its domain, and every i ≤ l.
The transition system T (D) represented by an action description D is defined as follows. For every stable model X
of PN0 (D), the set of atoms A such that 0 : A belongs to X
is a state of T (D). In view of the existence of value and
uniqueness of value constraints, for every state s and every
fluent constant f there exists exactly one v such that f = v
belongs to s; this v is considered the value of f in state s. For
every stable model X of PN1 (D), T (D) includes the transition hs0 , α, s1 i, where si (i = 0, 1) is the set of atoms A such
that i : A belongs to X, and α is the set of action constants a
such that 0 : a belongs to X.
The soundness of this definition is guaranteed by the following fact:

impossible A1 , . . . , Am .
The use of this abbreviation depends on the fact that the
choice of f , v, and w in (6) is inessential, in the sense of
Theorem 3 below. About action descriptions D1 and D2
we say that they are strongly equivalent to each other if,
for any action description D (possibly of a larger signature),
T (D ∪ D1 ) = T (D ∪ D2 ). This is similar to the definition of
strong equivalence for logic programs [Lifschitz et al., 2001].
Theorem 3 Any two static constraints (6) with the same
atoms A1 , . . . , Am are strongly equivalent to each other.
The rules contributed to PNl (D) by (6) can be equivalently
written as
⊥ ← i : A1 , . . . , i : Am .
A dynamic constraint is a pair of dynamic laws of the form

Theorem 1 For every transition hs0 , α, s1 i, s0 and s1 are
states.

f = v after a1 , . . . , ak , A1 , . . . , Am
f = w after a1 , . . . , ak , A1 , . . . , Am

We promised that stable models of PNl (D) would represent paths of length l in the transition system corresponding
to D. For l = 0 and l = 1, this is clear from the definition
of T (D); for l > 1 this needs to be verified. For every set X
of elements of the signature σD,l , let X i (i < l) be the triple
consisting of
• the set of atoms A such that i : A belongs to X,
• the set of action constants a such that i : a belongs to X,
and
• the set of atoms A such that (i + 1) : A belongs to X.

(7)

where v 6= w, a1 , . . . , ak (k > 0) are action constants, and
A1 , . . . , Am are atoms. We will write (7) as
nonexecutable a1 , . . . , ak if A1 , . . . , Am ,
and we will drop if in this abbreviation when m = 0. The use
of this abbreviation depends on the following fact:
Theorem 4 Any two dynamic constraints (7) with the same
action constants a1 , . . . , ak and the same atoms A1 , . . . , Am
are strongly equivalent to each other.

Theorem 2 For every l ≥ 1, X is a stable model of PNl (D)
iff X 0 , . . . , X l−1 are transitions.

The rules contributed to PNl (D) by (7) can be equivalently
written as

The rules contributed to PNl (D) by static law (3) have the
form
i : A0 ← i : A1 , . . . , i : Am , not not i : A0 .
They can be equivalently rewritten as

⊥ ← i : a1 , . . . , i : ak , i : A1 , . . . , i : Am .

6

Example: The Blocks World

The description of the blocks world below ensures that every
block belongs to a tower that rests on the table; there are no
blocks or groups of blocks “floating in the air.”
Let Blocks be a finite non-empty set of symbols (block
names) that does not include the symbol Table. The action
description below uses the following fluent and action constants:
• for each B ∈ Blocks, regular fluent constant Loc(B)
with domain Blocks ∪ {Table}, and statically determined Boolean fluent constant InTower(B);
• for each B ∈ Blocks and each L ∈ Blocks ∪ {Table},
action constant Move(B, L).

{i : A0 } ← i : A1 , . . . , i : Am
(see [Lifschitz et al., 2001]). Similarly, the rules contributed
to PNl (D) by dynamic law (4) have the form
(i + 1) : A0 ← i : A1 , . . . , i : Am , not not (i + 1) : A0 .
They can be equivalently rewritten as
{(i + 1) : A0 } ← i : A1 , . . . , i : Am .
In particular, the rules contributed by the commonsense law
of inertia (5) can be rewritten as
{(i + 1) : f = v} ← i : f = v.

985

In the list of static and dynamic laws, B, B1 and B2 are arbitrary elements of Blocks, and L is an arbitrary element of
Blocks ∪ {Table}. Two different blocks cannot rest on the
same block:
impossible Loc(B1 ) = B, Loc(B2 ) = B

The values of the symbolic constants l (the number of
steps) and n (the number of blocks) are supposed to be specified in command line. The stable models generated by an
answer set solver for this input file will represent all trajectories of length l in the transition system corresponding to
the blocks world with n blocks. For instance, if we ground
this program with the GRINGO options -c l=0 -c n=3
then the resulting program will have 13 stable models, corresponding to to all possible configurations of 3 blocks.
The rules involving intower can be written more economically if we use strong (classical) negation and replace

(B1 6= B2 ).

The definition of InTower(B):
InTower(B) if Loc(B) = Table,
InTower(B) if Loc(B) = B1 , InTower(B1 ),
default ∼InTower(B).
Blocks don’t float in the air:

intower(B,true,I), intower(B,false,I)

impossible ∼InTower(B).

with

The commonsense law of inertia:

intower(B,I), -intower(B,I).

inertial Loc(B).

That would make the uniqueness of value constraint for
intower redundant.

The effect of moving a block:
Move(B, L) causes Loc(B) = L.
A block cannot be moved unless it is clear:

7

nonexecutable Move(B, L) if Loc(B1 ) = B.

The example above includes the inertiality assumption for all
regular fluents. In some cases, the commonsense law of inertia for a regular fluent is not acceptable and needs to be
replaced by a different default.
Consider, for instance, a container of capacity n that has a
leak, so that it loses k units of liquid per unit of time, unless
more liquid is added. This domain can be described using
the regular fluent constants Amt with domain {0, . . . , n}, for
the amount of liquid in the container, and the action constant
FillUp. There are two dynamic laws:

Here is a representation of logic programs PNl (D) (Section 4), for this action description D, in the input language of
the grounder GRINGO:2
% declarations of variables for steps,
% blocks, and locations
step(0..l).
#domain step(I).
block(b(1..n)).
#domain block(B).
#domain block(B1).
#domain block(B2).
location(X) :- block(X).
location(table).
#domain location(L).

default Amt = max(a − k, 0) after Amt = a (a = 0, . . . , n),
FillUp causes Amt = n.
(When k = 0, the first of them turns into inertial Amt.)
Consider the following temporal projection problem involving this domain, with n = 10 and k = 3: initially the
container is full, and it is filled up at time 3; we would like to
know how the amount of liquid in the container will change
with time. The program below consists of the rules of PNl (D)
and rules encoding the temporal projection problem.

% translations of static laws
:- loc(B1,B,I), loc(B2,B,I), B1!=B2.
intower(B,true,I) :- loc(B,table,I).
intower(B,true,I) :- loc(B,B1,I),
intower(B1,true,I).
{intower(B,false,I)}.
:- intower(B,false,I).

% declarations of variables for steps
% and amounts
step(0..l).
#domain step(I).
amount(0..n).
#domain amount(A).

% translations of dynamic laws
{loc(B,L,I+1)} :- loc(B,L,I), I<l.
loc(B,L,I+1) :- move(B,L,I), I<l.
:- move(B,L,I), loc(B1,B,I), I<l.

% translations of dynamic laws
{amt(AA,I+1)} :- amt(A,I),
AA=(|A-k|+(A-k))/2, I<l.
amt(n,I+1) :- fillup(I), I<l.

% standard choice rules
{loc(B,L,0)}.
{move(B,L,I)} :- I<l.

% standard choice rules
{amt(A,0)}.
{fillup(I)} :- I<l.

% uniqueness and existence of value
:- not 1{loc(B,LL,I) : location(LL)}1.
:- not 1{intower(B,false,I),
intower(B,true,I)}1.
2

Example: A Leaking Container

% uniqueness and existence of value
:- not 1 {amt(AA,I) : amount(AA)} 1.

http://potassco.sourceforge.net/

986

% temporal projection
amt(n,0).
fillup(3). -fillup(0..2;4..l).
#hide. #show amt/2.
The solver CLINGO produces the following output:
amt(10,0) amt(10,4) amt(7,5) amt(7,1)
amt(4,2) amt(4,6) amt(1,7) amt(1,3)
amt(0,9) amt(0,8)

8

Translation into the Language of Programs
with Strong Negation

In the definition of the semantics of BC in Section 4 the programs PNl (D) can be replaced by the programs with strong
negation PSl (D) that consist of the following rules:
• the translations
i : A0 ← i : A1 , . . . , i : Am , not ¬ i : Am+1 , . . . , not ¬ i : An
(i ≤ l) of all static laws (1) from D,
• the translations

A multi-valued signature is a set σ of symbols, called constants, along with a nonempty finite set Dom(c) of symbols,
disjoint from σ, assigned to each constant c, called the domain of c. An atom of the signature σ is an expression of
the form c = v (“the value of c is v”), where c ∈ σ and
v ∈ Dom(c). If Dom(c) is {f, t} then we say that the constant c is Boolean. A multi-valued formula is a propositional
combination of atoms. (Note that the symbol ¬ in multivalued formulas corresponds to negation as failure in logic
programs.)
A multi-valued interpretation of σ is a function that maps
every element of σ to an element of its domain. An interpretation I satisfies an atom c = v if I(c) = v. The satisfaction
relation is extended from atoms to arbitrary formulas according to the usual truth tables for the propositional connectives.
The reduct F I of a multi-valued formula F relative to a
multi-valued interpretation I is the formula obtained from F
by replacing each maximal subformula that is not satisfied by
I with ⊥. We say that I is a stable model of F if I is the only
interpretation satisfying F I .3
Consider the multi-valued signature consisting of
• the constants i : f for nonnegative integers i ≤ l and all
fluent constants f , with the same domain as f , and

(i + 1) : A0 ← i : A1 , . . . , i : Am ,
not ¬ (i + 1) : Am+1 , . . . , not ¬ (i + 1) : An

• the Boolean constants i : a for nonnegative integers i < l
and all action constants a.

(i < l) of all dynamic laws (2) from D,
• the disjunctive rules 0 : A ∨ ¬ 0 : A for every atom A
containing a regular fluent constant,
• the disjunctive rules i : a ∨ ¬ i : a for every action constant a and every i < l,
• the existence of value constraint

If F is a propositional combination of atoms f = v and action
constants then i : F stands for the formula of this signature
obtained from F by prepending i : to every fluent constant
and to every action constant.
For any action description D, by MVl (D) we denote the
conjunction of the following multi-valued formulas:
• the translations

← not i : (f = v1 ), . . . , not i : (f = vk )

i : (A1 ∧ · · · ∧ Am ∧ ¬¬Am+1 ∧ · · · ∧ ¬¬An → A0 )

for every fluent constant f and every i ≤ l, where
v1 , . . . , vk are all elements of the domain of f ,
• the uniqueness of value rule

(i ≤ l) of all static laws (1) from D,
• the translations
i : (A1 ∧ · · · ∧ Am ) ∧ (i+1) : (¬¬Am+1 ∧
· · · ∧ ¬¬An ) → (i + 1) : A0

¬ i : (f = v) ← i : (f = w)
for every fluent constant f , every pair of distinct elements v, w of its domain, and every i ≤ l.
The stable models of the program PNl (D) from Section 4
can be obtained from the (complete) answer sets of PSl (D)
by removing all negative literals:

(i < l) of all dynamic laws (2) from D,
• the formula 0 : (f = v ∨ f 6= v) for every regular fluent
constant f and every element v of its domain,
• the formula i : (a = t ∨ a = f) for every action constant a
and every i < l.

Theorem 5 A set X of atoms of the signature σD,l is a stable
model of PNl (D) iff X ∪ {¬A | A ∈ σD,l \ X} is an answer
set of PSl (D).

By σ A we denote the set of all action constants.
Theorem 6 A set X of atoms of the signature σD,l is a stable
model of PNl (D) iff X ∪ {i : a = f | a ∈ σ A , i < l, i : a 6∈ X}
is a stable model of MVl (D).

It follows that the translation PN in the definition of T (D)
can be replaced with the translation PS.

9

Translation into the Language of
Multi-Valued Formulas

It follows that the translation PN in the definition of T (D)
can be replaced with the translation MV.

Multi-valued formulas are defined in [Giunchiglia et al.,
2004, Section 2.1], and the stable model semantics is extended to such formulas in [Bartholomew and Lee, 2012].

3

This formulation is based on the characterization of the stable
model semantics of multi-valued formulas given by [Bartholomew
and Lee, 2012, Theorem 5].

987

10

Relation to B

“simple” in C+; they correspond to regular fluents in our terminology.) Fluent symbols in C+ may be non-exogenous; in
our first version of BC such fluents are not allowed. Action
symbols in C+ may be non-Boolean; in this respect, that language is more general than the version of BC defined above.
Consider a BC-description such that, in each of its static
laws (1), m = 0. In other words, we assume that every static
law has the form

The version of the action language B referred to in this section
is defined in [Gelfond and Lifschitz, 2012]. For any action
¬
description D in the language B, by D∼
we denote the result
of replacing each negative literal ¬f in D with the atom ∼f
(that is, f = f). The abbreviations introduced in Sections 2
¬
and 5 above allow us to view D∼
as an action description in
the sense of BC, provided that all fluent constants are treated
as regular Boolean. We define the translation of D into BC as
¬
the result of extending D∼
by adding the inertiality assumptions (5) for all fluent constants f .
We will loosely refer to states and transitions of the transition system represented by D as states and transitions of D.
To state the claim that this translation preserves the meaning of D, we need to relate states and transitions in the sense
of the semantics of B to states and transitions in the sense of
Section 4. In B, a state is a consistent and complete set of
literals f , ¬f for fluent constants f . For any set s of atoms
f , ∼ f , by s∼
¬ we denote the set of literals obtained from s
by replacing each atom ∼f with the negative literal ¬f . Furthermore, an action in B is a consistent and complete set of
literals a, ¬a for action constants a.

A0 if cons A1 , . . . , An .
Such a description can be translated into C+ as follows:
• all action constants are treated as Boolean;
• every static law (8) is replaced with
caused A0 if A1 ∧ · · · ∧ An ;
• every dynamic law (2) is replaced with

caused A0 if Am+1 ∧ · · · ∧ An after A1 ∧ · · · ∧ Am ;
• for every action constant a,
exogenous a
is added.

Theorem 7 For any action description D in the language B,

Theorem 8 For any action description D in the language BC
such that in each of its static laws (1) m = 0,
(a) the states of the translation of D into the language C+
are identical to the states of D;
(b) the transitions of the translation of D into the language
C+ can be characterized as the triples

(a) a set s of atoms is a state of the translation of D into the
language BC iff s∼
¬ is a state of D;
(b) for any sets s0 , s1 of atoms and any set α of action constants, hs0 , α, s1 i is a transition of the translation of D
into the language BC iff
h(s0 )∼
/ α}, (s1 )∼
¬ , α ∪ {¬0 : a | a ∈
¬i

h s0 , {a = t | a ∈ α} ∪ {a = f | a ∈ σ A \ α}, s1 i

is a transition of D.

for all transitions hs0 , α, s1 i of D.

The description of the blocks world from Section 6 does
not correspond to any B-description, in the sense of this translation, for two reasons. First, some fluent constants in it are
not regular: it uses statically determined fluents InTower(B),
defined recursively in terms of Loc(B). They are similar to
“defined fluents” allowed in the extension of B introduced in
[Gelfond and Inclezan, 2009]. Second, some fluent constants
in it are not Boolean: the values of Loc(B) are locations.
The leaking container example (Section 7) does not correspond to any B-description either: the regular fluent Amt
is not Boolean, and the default describing how the value of
this fluent changes is different from the commonsense law
of inertia. An alternative approach to describing the leaking
container is based on an extension of B by “process fluents,”
called H [Chintabathina et al., 2005].

11

(8)

This translation is applicable, for instance, to the leaking
container example. The description of the blocks world from
Section 6 cannot be translated into C+ in this way, because
the static laws in the recursive definition of InTower(B) violate the condition m = 0.

12

Future Work

The version of BC described in this preliminary report is
propositional; expressions with variables, as in the examples
from Sections 6 and 7, need to be grounded before they become syntactically correct in the sense of BC. We plan to
define the syntax and semantics of BC with variables, in the
sprit of [Lifschitz and Ren, 2007], using the generalization of
stable models proposed in [Ferraris et al., 2011].
The version of the Causal Calculator described in [Casolary and Lee, 2011] will be extended to cover the expressive
capabilities of BC.

Relation to C+

The semantics of C+ is based on the idea of universal causation [McCain and Turner, 1997]. Formal relationships between universal causation and stable models are investigated
in [McCain, 1997; Ferraris et al., 2012], and it is not surprising that a large fragment of BC is equivalent to a large
fragment of C+.
In C+, just as in BC, some fluent symbols can be designated as “statically determined.” (Other fluents are called

Acknowledgements
Joohyung Lee was partially supported by the National Science Foundation under Grant IIS-0916116 and by the South
Korea IT R&D program MKE/KIAT 2010-TD-300404-001.
Many thanks to Michael Gelfond and to the anonymous referees for valuable advice.

988

References

explanation: Preliminary report. In Proceedings of National Conference on Artificial Intelligence (AAAI), pages
623–630. AAAI Press, 1998.
[Giunchiglia et al., 2004] Enrico Giunchiglia, Joohyung
Lee, Vladimir Lifschitz, Norman McCain, and Hudson Turner. Nonmonotonic causal theories. Artificial
Intelligence, 153(1–2):49–104, 2004.
[Lifschitz and Ren, 2007] Vladimir Lifschitz and Wanwan
Ren. The semantics of variables in action descriptions.
In Proceedings of National Conference on Artificial Intelligence (AAAI), pages 1025–1030, 2007.
[Lifschitz et al., 1999] Vladimir Lifschitz, Lappoon R. Tang,
and Hudson Turner. Nested expressions in logic programs.
Annals of Mathematics and Artificial Intelligence, 25:369–
389, 1999.
[Lifschitz et al., 2001] Vladimir Lifschitz, David Pearce,
and Agustin Valverde. Strongly equivalent logic programs.
ACM Transactions on Computational Logic, 2:526–541,
2001.
[Lifschitz, 2008] Vladimir Lifschitz. What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence, pages 1594–1597. MIT Press, 2008.
[Marek and Truszczynski, 1999] Victor
Marek
and
Miroslaw Truszczynski. Stable models and an alternative logic programming paradigm.
In The Logic
Programming Paradigm: a 25-Year Perspective, pages
375–398. Springer Verlag, 1999.
[McCain and Turner, 1997] Norman McCain and Hudson
Turner. Causal theories of action and change. In Proceedings of National Conference on Artificial Intelligence
(AAAI), pages 460–465, 1997.
[McCain, 1997] Norman McCain. Causality in Commonsense Reasoning about Actions. PhD thesis, University
of Texas at Austin, 1997.
[Niemelä, 1999] Ilkka Niemelä. Logic programs with stable
model semantics as a constraint programming paradigm.
Annals of Mathematics and Artificial Intelligence, 25:241–
273, 1999.
[Nogueira et al., 2001] Monica Nogueira, Marcello Balduccini, Michael Gelfond, Richard Watson, and Matthew
Barry. An A-Prolog decision support system for the
Space Shuttle. In Proceedings of International Symposium
on Practical Aspects of Declarative Languages (PADL),
pages 169–183, 2001.
[Pednault, 1989] Edwin Pednault. ADL: Exploring the middle ground between STRIPS and the situation calculus. In
Ronald Brachman, Hector Levesque, and Raymond Reiter,
editors, Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),
pages 324–332, 1989.
[Reiter, 1980] Raymond Reiter. A logic for default reasoning. Artificial Intelligence, 13:81–132, 1980.

[Balduccini and Gelfond, 2003] Marcello Balduccini and
Michael Gelfond. Diagnostic reasoning with A-Prolog.
Theory and Practice of Logic Programming, 3(4-5):425–
461, 2003.
[Bartholomew and Lee, 2012] Michael Bartholomew and
Joohyung Lee. Stable models of formulas with intensional
functions. In Proceedings of International Conference on
Principles of Knowledge Representation and Reasoning
(KR), 2012.
[Casolary and Lee, 2011] Michael Casolary and Joohyung
Lee. Representing the language of the Causal Calculator in
Answer Set Programming. In Technical Communications
of the 27th International Conference on Logic Programming (ICLP), pages 51–61, 2011.
[Chintabathina et al., 2005] Sandeep
Chintabathina,
Michael Gelfond, and Richard Watson.
Modeling
hybrid domains using process description language. In
Proceedings of Workshop on Answer Set Programming:
Advances in Theory and Implementation (ASP’05), 2005.
[Ferraris and Lifschitz, 2005] Paolo Ferraris and Vladimir
Lifschitz. Weight constraints as nested expressions. Theory and Practice of Logic Programming, 5:45–74, 2005.
[Ferraris et al., 2011] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. Stable models and circumscription.
Artificial Intelligence, 175:236–263, 2011.
[Ferraris et al., 2012] Paolo Ferraris, Joohyung Lee, Yuliya
Lierler, Vladimir Lifschitz, and Fangkai Yang. Representing first-order causal theories by logic programs. Theory and Practice of Logic Programming, 12(3):383–412,
2012.
[Fikes and Nilsson, 1971] Richard Fikes and Nils Nilsson.
STRIPS: A new approach to the application of theorem
proving to problem solving. Artificial Intelligence, 2(3–
4):189–208, 1971.
[Gelfond and Inclezan, 2009] Michael Gelfond and Daniela
Inclezan. Yet another modular action language. In Proceedings of the Second International Workshop on Software Engineering for Answer Set Programming, pages 64–
78, 2009.
[Gelfond and Lifschitz, 1991] Michael
Gelfond
and
Vladimir Lifschitz. Classical negation in logic programs and disjunctive databases.
New Generation
Computing, 9:365–385, 1991.
[Gelfond and Lifschitz, 1998] Michael
Gelfond
and
Vladimir Lifschitz.
Action languages.
Electronic
Transactions on Artificial Intelligence, 3:195–210, 1998.
[Gelfond and Lifschitz, 2012] Michael
Gelfond
and
Vladimir Lifschitz. The common core of action languages B and C. In Working Notes of the International
Workshop on Nonmonotonic Reasoning (NMR). 2012.
[Giunchiglia and Lifschitz, 1998] Enrico Giunchiglia and
Vladimir Lifschitz. An action language based on causal

989

Logical Formalizations of Commonsense Reasoning — Papers from the AAAI 2011 Spring Symposium (SS-11-06)

Integrating Rules and Ontologies in the First-Order
Stable Model Semantics (Preliminary Report)
Joohyung Lee and Ravi Palla
School of Computing, Informatics and Decision Systems Engineering
Arizona State University
Tempe, AZ, 85287, USA
{joolee, Ravi.Palla}@asu.edu
information ﬂow is bi-directional. On the other hand, computational complexity is high.
In this paper, we investigate whether the ﬁrst-order stable
model semantics [Ferraris, Lee, & Lifschitz, 2011], which
naturally extends both ﬁrst-order logic and logic programs,
can serve as a unifying logic for the integration of rules and
ontologies. As the ﬁrst step, we show how some of the existing integration proposals can be reformulated in terms of
the ﬁrst-order stable model semantics. Our reformulations
are simpler than the original proposals in the sense that they
do not refer to grounding.
We begin with a review of the ﬁrst-order stable model semantics, and the notion of semi-safety. Then we present a
reformulation of DL + log in the ﬁrst-order stable model
semantics, and show how the small predicate property, that
is ensured by semi-safety, can be used to strengthen some
complexity results related to DL + log. Then we relate our
approach to the approach in [de Bruijn et al., 2007b] that
uses Quantiﬁed Equilibrium Logic as a unifying logic and,
as a corollary, show a reformulation of g-hybrid knowledge
bases. Next we relate our approach to nonmonotonic dlprograms.

Abstract
We present an approach to integrating rules and ontologies on
the basis of the ﬁrst-order stable model semantics proposed
by Ferraris, Lee and Lifschitz. We show that some existing
integration proposals can be uniformly reformulated in terms
of the ﬁrst-order stable model semantics. The reformulations
are simpler than the original proposals in the sense that they
do not refer to grounding.

Introduction
Integrating nonmonotonic rules and ontologies has received
much attention, especially in the context of the Semantic
Web. A hybrid knowledge base is a pair (T , P) where T
is a FOL knowledge base (typically in a description logic)
of signature ΣT and P is a logic program of signature
ΣP . The existing integration approaches can be classiﬁed
into three categories: loose integration, tight integration with
semantic separation and tight integration under a unifying
logic [Nazarenko et al., 2010]. In the loose integration approach, T and P are viewed as separate, independent components, and they are connected through minimal safe interfaces for exchanging data (usually in the form of ground
atoms). Examples in this category include nonmonotonic dlprograms [Eiter et al., 2008] and the combination of description logics and defeasible logic [Wang et al., 2004]. In the
tight integration with semantic separation approach, T and
P are more tightly integrated, but the predicates in ΣT and
ΣP are kept separate. It builds an integrated model I as the
union of a model IT of T and a model IP of P with the
same domain. Examples are r-hybrid KB [Rosati, 2005],
DL + log [Rosati, 2006], g-hybrid KB [Heymans et al.,
2008], and f -hybrid KB [Feier & Heymans, 2009]. Finally,
in the tight integration under a unifying logic approach, T
and P are treated uniformly by translating them into a uniform logic, and there is no principled separation between ΣT
and ΣP . Examples are Hybrid MKNF KB [Motik & Rosati,
2010], the ﬁrst-order autoepistemic logic based integration
[de Bruijn et al., 2007a], and the QEL-based integration [de
Bruijn et al., 2007b]. This approach is attractive since it provides a seamless integration of DLs and logic programs, and

Background
Review: First-Order Stable Model Semantics
(FOSM)
We assume the following set of primitive propositional connectives and quantiﬁers:
⊥ (falsity), ∧, ∨, →, ∀, ∃ .
¬F is an abbreviation for F → ⊥, symbol  stands for
⊥ → ⊥, and F ↔ G stands for (F → G) ∧ (G → F ).
In [Ferraris, Lee, & Lifschitz, 2011] the stable models
are deﬁned in terms of the SM operator with intensional
predicates. For any ﬁrst-order sentence F and any list p =
(p1 , . . . , pn ) of intensional predicates, SM[F ; p] is deﬁned
as 1
F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where u is a list of distinct predicate variables u1 , . . . , un
and F ∗ (u) is deﬁned recursively:

c 2011, Association for the Advancement of Artiﬁcial
Copyright 
Intelligence (www.aaai.org). All rights reserved.

1
Here we use the expression SM[F ; p] in place of SMp [F ] used
in [Ferraris, Lee, & Lifschitz, 2011].

56

• pi (t)∗ = ui (t) for any list t of terms;
• F ∗ = F for any atomic formula F that does not contain
members of p;
• (F 
 G)∗ = F ∗ 
 G∗ , where 
 ∈ {∧, ∨};
• (F → G)∗ = (F ∗ → G∗ ) ∧ (F → G);
• (QxF )∗ = QxF ∗ , where Q ∈ {∀, ∃}.
The models of SM[F ; p] are called the p-stable models
of F . Intuitively, they are the models of F that are “stable”
on p. We often write SM[F ] instead of SM[F ; p] when p is
the list of all predicate constants occurring in F , and call a
model of SM[F ] simply a stable model of F . Answer sets
are deﬁned as a special class of stable models as follows. By
σ(F ) we denote the signature consisting of the object, function and predicate constants occurring in F . By pr(F ) we
denote the list of all predicate constants occurring in F . If F
contains at least one object constant, an Herbrand interpretation of σ(F ) that satisﬁes SM[F ; pr(F )] is called an answer
set of F . The answer sets of a logic program Π are deﬁned
as the answer sets of the FOL-representation of Π (i.e., the
conjunction of the universal closures of implications corresponding to the rules). For example, the FOL-representation
of the program

– otherwise, RVp (F ) is the set of all variables occurring
in F ;
• RVp (G ∧ H) = RVp (G) ∪ RVp (H);
• RVp (G ∨ H) = RVp (G) ∩ RVp (H);
• RVp (G → H) = ∅.
We say that a variable x is p-restricted in a quantiﬁer-free
formula F if x ∈ RVp (F ).
Recall that the occurrence of one formula in another is
called positive if the number of implications containing that
occurrence in the antecedent is even, and negative otherwise.
We say that an occurrence of a predicate constant, a variable,
or any other subexpression in a formula F is strictly positive
if that occurrence is not in the antecedent of any implication.
Consider a sentence F in prenex form:
Q1 x1 · · · Qn xn M

(2)

(each Qi is ∀ or ∃; x1 , . . . , xn are distinct variables; the matrix M is quantiﬁer-free). It is shown that every ﬁrst-order
formula under the stable model semantics can be turned into
prenex form [Lee & Palla, 2007, Theorem 2]. We say that F
is semi-safe relative to p if every strictly positive occurrence
of every variable xi in M belongs to a subformula G → H
where xi is p-restricted in G.
Proposition 2 below shows that all stable models of a
semi-safe sentence have the small predicate property: the relation represented by any of its predicate constants pi can
hold for a tuple of arguments only if each member of the
tuple is represented by an object constant occurring in F .
For any ﬁnite set c of object constants, inc (x) stands for the
formula

x = c.

p(a)
q(b)
r(x) ← p(x), not q(x)
is

p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x)).
(1)
[
]
It is shown in Ferraris, Lee, & Lifschitz, 2011 that this definition of an answer set, when applied to the syntax of logic
programs, is equivalent to the traditional deﬁnition of an answer set, which is based on grounding and ﬁxpoint construction, given in [Gelfond & Lifschitz, 1988].
The following proposition tells us that ﬁrst-order logic
formulas and logic programs can be viewed as special cases
of SM[F ; p].
Proposition 1
(a) If F is a ﬁrst-order sentence, then the models of F (in
the sense of classical logic) are precisely the models of
SM[F ; ∅].
(b) If F is the FOL representation of a logic program Π, then
the answer sets of Π in the sense of [Gelfond & Lifschitz,
1988] are precisely the Herbrand interpretations of σ(F )
that satisfy SM[F ; pr(F )].
Part (a) is easy to see; Part (b) is Theorem 1 from [Ferraris,
Lee, & Lifschitz, 2011] .

c∈c

The small predicate property relative to p, denoted by SPPp
c,
is the conjunction of the sentences



∀v1 , . . . , vn p(v1 , . . . , vn ) →
inc (vi )
i=1,...,n

for all predicate constants p in p, where v1 , . . . , vn are distinct variables.
The following proposition is an extension of Proposition 1
from [Lee, Lifschitz, & Palla, 2009], where p was limited
to the list of predicate constants occurring in F . It says that
every stable model of a semi-safe sentence satisﬁes the small
predicate property.2 By c(F ) we denote the set of all object
constants occurring in F .

Semi-Safety and Small Predicate Property

Proposition 2 For any semi-safe sentence F relative to p,
formula SM[F ; p] entails SPPp
c(F ) .

We assume that the signature contains no function constants
of positive arity. To every quantiﬁer-free formula F , we assign a set RVp (F ) of restricted variables relative to p as
follows.
• For an atomic formula F (including equality and ⊥),
– if F is an equality between two variables, or is
an atom whose predicate constant is not in p, then
RVp (F ) = ∅;

In [Lee, Lifschitz, & Palla, 2008; 2009], the deﬁnition of
safety is extended to arbitrary sentences by restricting semisafe sentences to satisfy a further condition. It is shown there
that a safe sentence and the result of its grounding have the
same stable models.
2

57

This extension is mentioned in [Bartholomew & Lee, 2010].

• (Weak safety) every variable occurring in the head
must also occur in at least one of the atoms
r1 (Y1 ), . . . , rm (Ym ).

FOSM Based Integration
DL knowledge bases can be viewed as theories in ﬁrst-order
logic. Given a DL knowledge base T of signature ΣT and a
logic program P of signature ΣP , our approach is to identify the models of the hybrid knowledge base (T , P) with
the interpretations of signature ΣT ∪ ΣP (in the sense of
classical logic) that satisfy SM[FO(T ) ∧ FO(P); p], where
FO(T ) and FO(P) are the ﬁrst-order representations of T
and P respectively, and p is a list of intensional predicates.
We assume that T and P are ﬁnite, and so are the predicate
constants in ΣP . Typically, existing integration approaches
assume that the signatures do not contain function constants
of positive arity, and ΣT and ΣP share the same set of object constants, but have disjoint sets of predicate constants;
typically p is the list of all predicate constants in ΣP .

Rosati (2006) presents two semantics of DL+log KB: the
monotonic and the nonmonotonic semantics. The monotonic
semantics of DL + log is given by simply viewing T and P
as theories in ﬁrst-order logic: given a DL + log knowledge
base (T , P) of signature C, PT ∪PP , an interpretation I is
a monotonic model of (T , P) if I satisﬁes FO(T ) ∧ FO(P).
In view of Proposition 1 (a), this semantics can be expressed
by SM[FO(T ) ∧ FO(P); ∅].
The nonmonotonic semantics of DL + log is based on the
stable model semantics for disjunctive logic programs. The
notation gr(P, C) represents the ground program obtained
by replacing every variable in every rule of P with every
object
constant in C.
Example 1 [de Bruijn et al., 2007b, Example 1] Consider
Given
gr(P, C) and an interpretation I of signature
a hybrid knowledge base consisting of a classical theory T
C,
P
,
the
projection of gr(P, C) with respect to I, deT
:
noted by Π(gr(P, C), I), is obtained as follows. For every
∀x(PERSON(x) → (AGENT(x) ∧ (∃yHAS-MOTHER(x, y)))) rule R ∈ gr(P, C),
∀x((∃yHAS-MOTHER(x, y)) → ANIMAL(x))
• delete R if I |= r(t) for some head atom r(t) such that
r ∈ PT ;
which says that every PERSON is an AGENT and has some
(unknown) mother, and everyone who has a mother is an
• delete every atom r(t) in the head such that r ∈ PT and
ANIMAL, and a nonmonotonic logic program P:
I |= r(t);
• delete R if I |= r(t) for some atom r(t) in the body such
that r ∈ PT ;

PERSON(x) ← AGENT(x), not machine(x)
AGENT(DaveB)

• delete every atom r(t) in the body such that r ∈ PT and
I |= r(t).

which says that AGENTs are by default PERSONs, unless known to be machines, and DaveB is an AGENT.
SM[FO(T ) ∧ FO(P); machine] entails Person(DaveB).
Furthermore, it entails each of ∃yHAS-Mother(DaveB, y)
and ANIMAL(DaveB).

The DL + log approach imposes the standard name assumption: every interpretation is over the same ﬁxed, countably inﬁnite, domain Δ, and in addition, the set C of object constants is such that it is in the same one-to-one correspondence with Δ in every interpretation. As a result, for
simplicity, we assume that the domain with respect to every
interpretation is C.
An interpretation I (in the sense of classical logic) of a
signature σ can be represented as a pair I f , X, where I f
is the restriction of I to function constants (including object
constants) from σ, and X is the set of atoms, formed using
predicate constants from σ and the names of elements of |I|,
which are satisﬁed by I.
Given a DL + log knowledge base (T , P) of signature
C, PT ∪ PP , an interpretation I is a nonmonotonic model
of (T , P) if

Relating to DL + log by Rosati
In DL + log, predicate constants are partitioned into DL
predicates PT and Datalog predicates PP . DL predicates
are further partitioned into concept names and role names.
Additionally, DL + log assumes a countably inﬁnite set of
object constants, denoted by C.
A DL + log knowledge base is denoted by (T , P), where
T is a DL knowledge base of signature C, PT  and P is
a Datalog program of signature C, PT ∪ PP  consisting of
rules R of the form
p1 (X1 ) ; . . . ; pn (Xn ) ←
r1 (Y1 ), . . . , rm (Ym ), s1 (Z1 ), . . . , sk (Zk ),
not u1 (W1 ), . . . , not uh (Wh )

(3)

• I|C (the restriction of I on C) is an identity function that
maps every constant in C to itself;

(n ≥ 0, m ≥ 0, k ≥ 0, h ≥ 0) where Xi , Yi , Zi , Wi are lists
of object variables and object constants, and

• I|C , I|PT  satisﬁes T ;
• I|C , I|PP , identiﬁed with a set of ground atoms, is an
answer set of Π(gr(P, C), I|C , I|PT ).

• each pi is either a DL predicate or a Datalog predicate;
• each ri , ui is a Datalog predicate;

The following proposition shows how the nonmonotonic
semantics of DL + log can be reformulated in terms of the
ﬁrst-order stable model semantics.

• each si is a DL predicate;
• (Datalog safety) every variable occurring in R
must also occur in at least one of the atoms
r1 (Y1 ), . . . , rm (Ym ), s1 (Z1 ), . . . , sk (Zk );

Proposition 3 For any DL + log knowledge base (T , P),
under the standard name assumption, the nonmonotonic

58

models of (T , P) according to [Rosati, 2006] are precisely
the interpretations of C, PT ∪ PP  that satisfy

is equivalent to
FO(T ) ∧ SM[FO(P); PP ].
Similarly

SM[FO(T ) ∧ FO(P); PP ].
Since the reformulation does not refer to grounding, arguably, it provides a simpler account of DL + log.

SM[FO(T ) ∧ FO(P  ); PP ]

is equivalent to
FO(T ) ∧ SM[FO(P  ); PP ].
So it is sufﬁcient to show that SM[FO(P); PP ] is equivalent
to SM[FO(P  ); PP ]. Since P is semi-safe relative to PP ,
P  is also semi-safe relative to PP . By Proposition 2 above
and Theorem 9 from [Ferraris, Lee, & Lifschitz, 2011], it is
P
sufﬁcient to show that under the assumption SPPP
c(P) , where
c(P) is the set of object constants occurring in P,
(q ≤ PP ) → (FO(P)∗ (q) ↔ FO(P  )∗ (q))
(4)
is logically valid. Given a rule, let F (y) be the conjunction of negative datalog literals that contain a variable occurring only in a negative datalog literal, and y is the list
of all such variables. Formula (4) is logically valid, since
(∃yF (y))∗ (q) is equivalent to ∃yF (y) under the assumption q ≤ PP , and ∃yF (y) is equivalent to  under the asP
sumption SPPP
c(P) (the extents of predicates in PP are ﬁnite)
and the standard name assumption (there are inﬁnitely many
objects in the domain).

On the Safety Conditions imposed in DL + log
Recall that DL+log imposes weak safety (every variable occurring in the head of a rule also occurs in a Datalog atom in
the positive body) and Datalog safety (every variable occurring in a rule also occurs in the positive body), which, even
when combined, yields a condition that is weaker than DLsafety [Motik, Sattler, & Studer, 2005], where every variable
occurring in a rule is also required to occur in a datalog atom
in the positive body.
Note that in Proposition 3 we identify Datalog predicates with intensional predicates, and DL predicates with
non-intensional predicates. Clearly, under this view, the definition of semi-safety presented earlier coincides with the
deﬁnition of weak-safety for programs whose rules have
the form (3). In fact, by using the property ensured by
semi-safety, below we show that weak safety is a sufﬁcient
condition for guaranteeing decidability of reasoning with
DL + log.

Relating to QEL with hybrid Rules

Proposition 4 Let K = (T , P) be a DL + log knowledge
base such that P is weakly safe but is not necessarily datalog
safe. Let P  be the program obtained from P by removing
in every rule, all the negative datalog literals that contain
a variable that occurs only in the negative body. Then K is
equivalent (under the nonmonotonic semantics) to the DL +
log knowledge base (T , P  ).

We refer the reader to Section A.5.1 from [Ferraris, Lee,
& Lifschitz, 2011] for a review of quantiﬁed equilibrium
logic (QEL). By Choice(p) we denote the conjunction of
“choice formulas” ∀x(p(x) ∨ ¬p(x)) for all predicate constants p in p where x is a list of distinct object variables
whose length is the same as the arity of p. According to the
QEL-based integration approach in [de Bruijn et al., 2007b],
an HT-interpretation I of signature C, PT ∪ PP  is a model
of the hybrid knowledge K = (T , P) iff it is an equilibrium model of FO(T ) ∧ FO(P) ∧ Choice(PT ). Formula
FO(T ) ∧ FO(P) ∧ Choice(PT ) is called the stable closure
of K. The following proposition shows the relationship between the QEL-based approach and our approach.
Proposition 5 For any hybrid knowledge base K = (T , P)
of signature C, PT ∪ PP , an HT-interpretation J, X, X
of the same signature is an equilibrium model of K in the
sense of [de Bruijn et al., 2007b] iff J, X satisﬁes
SM[FO(T ) ∧ FO(P); PP ].
The proof of the proposition is immediate from Lemma 9
from [Ferraris, Lee, & Lifschitz, 2011], which establishes
the relationship between equilibrium logic and SM[F ; p] for
the special case when p is the list of all predicate constants
in the signature, and the following proposition, which tells
us that the set of intensional predicates can be increased by
using choice formulas. Recall that by pr(F ) we denote the
list of all predicate constants occurring in F . By False(p)
we denote the conjunction of ∀x¬p(x) for all predicate constants p in p.
Proposition 6 Formula
SM[F ; p] ↔ SM[F ∧ Choice(pr(F )\p) ∧ False(p\pr(F ))]
is logically valid.

Since the complexity of the transformation required to obtain P  is polynomial in the size of P, the decidability results
(Theorems 11 and 12 from [Rosati, 2006]) and the complexity results (Theorem 13 from [Rosati, 2006]) with respect to
the nonmonotonic semantics can be straightforwardly carried over to DL + log knowledge bases (T , P) where P is
weakly safe but not necessarily datalog safe. In other words,
in terms of decidability and complexity results mentioned
above, the requirement of datalog safety can be dropped.
The proof of Proposition 4 uses the following lemma,
which is a slight extension of Theorem 3 from [Ferraris, Lee,
& Lifschitz, 2011].
Lemma 1 If G does not contain any strictly positive occurrences of predicates in p, then SM[F ∧ G; p] is equivalent
to SM[F ; p] ∧ G.
Proof of Proposition 4 If P is weakly safe and datalog
safe, then P  is the same as P. Assume that P is weakly safe
but not datalog safe. Then there is a rule that contains some
variable y that occurs only in a negative datalog literal. P 
is obtained from P by removing all negative datalog literals
that contain such a variable y. By Lemma 1, since FO(T )
contains no predicate from PP ,
SM[FO(T ) ∧ FO(P); PP ]

59

Relating to g-hybrid KBs

A dl-atom is of the form

de Bruijin et al. (2007b) relate the QEL approach to r-hybrid
[Rosati, 2005] and g-hybrid knowledge bases [Heymans et
al., 2008]. As a corollary of Proposition 5 in this paper, we
can thus relate our approach to r-hybrid and g-hybrid knowledge bases. Here we present the result only with respect to
g-hybrid knowledge bases since we already covered the relationship to DL + log, which is an extension of r-hybrid
knowledge bases.
g-hybrid knowledge bases are based on the open answer set programming [Heymans, Nieuwenborgh, & Vermeir, 2005] approach. More speciﬁcally, a g-hybrid knowledge base is a pair (T , P), where T is a DL knowledge base
of signature C, PT  and P is a guarded program of signature C, PT ∪ PP  such that PT ∩ PP = ∅. A program is
said to be guarded if, for all rules R that are not of the form
p(t) ∨ not p(t) ← ,

DL[S1 op1 p1 , . . . , Sm opm pm ; Q](t) (m ≥ 0)

(6)

where each Si is a concept, a role or a special symbol θ ∈
{=, =}, symbol pi is a unary predicate constant if Si is a
concept and a binary predicate constant otherwise and opi ∈
{⊕, 
, }; Q(t) is a dl-query [Eiter et al., 2008].
A dl-rule is of the form
a ← b1 , . . . , bk , not bk+1 , . . . , not bm

(7)

where a is an atom and each bi is either an atom, equality, or
a dl-atom. We identify rule (7) with
a ← B, N

(8)

where B is b1 , . . . , bk and N is not bk+1 , . . . , not bm .
The semantics of dl-programs is deﬁned by extending the
answer set semantics to generalized programs. In order to
do this, the deﬁnition of satisfaction is extended to ground
dl-atoms. An Herbrand interpretation I satisﬁes a ground
atom A relative to T if I satisﬁes A. An Herbrand interpretation
m I satisﬁes a ground dl-atom (6) relative to T if
T ∪ i=1 Ai (I) entails Q(t), where Ai (I) is

(5)

there exists an atom A in the positive body (known as the
guard) such that all the variables occurring in R also occur in A. This implies that, in addition to such safe rules
R, guarded programs also allow unsafe choice rules of the
form (5). Also, guarded programs allow negation in the head
but with the restriction that there can be at most one nonnegated atom in the head.
Given an interpretation I of signature C, PT ∪ PP , program PI is deﬁned as the ground program obtained from P
by ﬁrst replacing every occurrence of c from C in it with
cI and then grounding the resulting program with respect to
the universe of I. Interpretation I is a model of the g-hybrid
knowledge base (T , P) if

• {Si (e) | pi (e) ∈ I} if opi is ⊕,
• {¬Si (e) | pi (e) ∈ I} if opi is 
,
• {¬Si (e) | pi (e) ∈ I} if opi is ,
and t is any list of ground terms. The satisfaction relation is
extended to allow connectives in the usual way.
Given a dl-program (T , P), the weak dl-transform of P
relative to T and an Herbrand interpretation I of C, PP ,
denoted by wPTI , is the logic program obtained from
gr(P, C) by deleting

• the restriction of I to C, PT  is a model of T , and
• the restriction of I to C, PP , viewed as a set of ground
atoms, is an answer set of Π(PI , I).3
The following proposition is a corollary to Theorem 2
of [de Bruijn et al., 2007b] and Proposition 5.

• each rule (8) in gr(P, C) such that
– I |=T b for some dl-atom b in B, or
– I |=T b for some literal not b in N ;

Proposition 7 For any g-hybrid knowledge base K =
(T , P), an interpretation I of signature C, PT ∪ PP  is
a model of K in the sense of [de Bruijn et al., 2007b] iff I is
a model of
SM[FO(T ) ∧ FO(P); PP ].

• from each remaining dl-rule (8), all the dl-atoms in B and
all the literals in N .
I is a weak answer set of (T , P) if I is the minimal model
of wPTI .
By DL?P we denote the set of dl-atoms in gr(P, C) that
are not known to be monotonic. The strong dl-transform of
P relative to T and I, denoted by sPTI , is the logic program
obtained from gr(P, C) by deleting

Relating to Nonmonotonic dl-programs by
Eiter et al.
Review: Nonmonotonic dl-programs
We ﬁrst review the syntax and the semantics of dl-programs.
For simplicity, we do not allow strong negation. A nonmonotonic dl-program [Eiter et al., 2008] is a pair (T , P), where
T is a DL knowledge base of signature C, PT  and P is a
generalized normal logic program of signature C, PP  such
that PT ∩ PP = ∅. A generalized normal logic program is a
set of dl-rules that can contain queries to T in their bodies,
in the form of dl-atoms.

• each rule (8) in gr(P, C) such that
– I |=T b for some dl-atom b in B ∩ DL?P or
– I |=T b for some not b in N ;
• from each remaining dl-rule (8), all the dl-atoms in B ∩
DL?P and all the literals in N .
I is a strong answer set of (T , P) if I is the minimal model
of sPTI .

3
The deﬁnition of projection Π given earlier is straightforwardly extended to cover a rule like (5) that allows not in the head.

60

Case 2: s(a ← B, N )X
T is not empty. Since no dl-atom in
B mentions , B contains no dl-atoms from DL?P , and it
follows that s(a ← B, N )X
T is a ← B. Also it follows that
X |=T b for every not b in N , so that by Lemma 2, we get
X ∪ YqPP |=T N ∗ (q). Since a is an atom and B is a set of
atoms and monotonic dl-atoms, it is clear that Y |=T a ← B
iff X ∪ YqPP |=T B ∗ (q) → a∗ (q).

Relating to Nonmonotonic dl-Programs
In order to relate our approach to the semantics of dlprograms, we extend the SM operator to formulas that allow
dl-atoms. The treatment is similar to the extension of SM to
formulas that allow aggregates, as given in [Lee & Meng,
2009; Ferraris & Lifschitz, 2010].
We deﬁne dl-formulas of the signature C, PT ∪ PP  as
an extension of ﬁrst-order formulas by treating dl-atoms as
a base case in addition to standard atomic formulas formed
from C, PP . Note that any generalized normal logic program can be viewed as a dl-formula. We extend the notion FO(P) to a generalized normal logic program P in a
straightforward way. Also the SM operator is extended to dlformulas by extending the recursive deﬁnition F ∗ by adding
the clause

The syntactic condition about  in Proposition 8 ensures
that all dl-atoms in the positive bodies of the ground program are monotonic. The proposition does not hold if the
condition is dropped. For example, consider the dl-program
(T , P) where the axioms in T (written as ﬁrst-order formulas) are
Q(b),
∀x(¬S(x) → Q(x))

DL[S1 op1 p1 , . . . , Sm opm pm ; Q](t)∗ (u) =
DL[S1 op1 p1 , . . . , Sm opm pm ; Q](t)∧
DL[S1 op1 p1 , . . . , Sm opm pm ; Q](t)

and P is
p(x) ← DL[S  p; Q](x).

where symbol pi is ui if pi is intensional and pi otherwise.
The following proposition shows how strong answer sets
can be characterized by this extension of SM.

With C = {a, b}, note that DL[S  p; Q](b) is monotonic but DL[S  p; Q](a) is not; (T , P) has no strong
answer sets, but {p(a), p(b)} is an Herbrand model of
SM[F O(P); p].
In the case of weak answer set semantics, the condition
is not required, but instead we need to prepend ¬¬ to all
dl-atoms.

Proposition 8 For any dl-program (T , P) such that every
occurrence of  is in the scope of negation, the strong answer sets of (T , P) are precisely the Herbrand interpretations of C, PP  that satisfy SM[FO(P); PP ] relative to T .
The proof uses the following lemma, which extends
Lemma 6 from [Ferraris, Lee, & Lifschitz, 2011] to dlformulas. In the following, X and Y are Herbrand interpretations of C, PP  such that Y is a subset of X (we identify
an Herbrand interpretation with the set of ground atoms that
are true in it), q is a list of new predicate constants of the
same length as PP , and YqPP is obtained from Y by replacing every predicate constant in PP with the corresponding
predicate constant in q.

Proposition 9 For any dl-program (T , P), the weak answer
sets of (T , P) are precisely the Herbrand interpretations of
signature C, PP  that satisfy SM[FO(P)¬ ; PP ] relative to
T , where FO(P)¬ is obtained from FO(P) by prepending
¬¬ to all occurrences of dl-atoms.
Proof. Similar to the proof of Proposition 8, using the
fact that, by Lemma 2, for any dl-atom A, X ∪ YqPP |=T
(¬¬A)∗ (q) iff X |=T ¬¬A.

Lemma 2 For any dl-formula F , X ∪ YqPP |=T (¬F )∗ (q)
iff X |=T ¬F .

Note that our treatment of dl-programs uses the extension of F ∗ to cover dl-atoms. It is an open question whether
dl-atoms can be “unfolded” into ﬁrst-order formulas, which
would make this extension unnecessary. It is worthwhile to
note that an encoding of dl-atoms in terms of ﬁrst-order formulas similar to the one in MKNF [Motik & Rosati, 2010,
Deﬁnition 7.5] does not apply here. For example, consider
K = (T , P) such that T is empty, and P is the following:

Proof of Proposition 8 Without loss of generality, let us assume that P is a variable-free program obtained by grounding. It is clear that X |=T P iff X |=T sPTX . If X |=T P,
then X is not a strong answer set of T , P, and X does not
satisfy SM[FO(P); PP ] relative to T .
Assume X |=T P. It is sufﬁcient to prove that, for any
rule (8) in P, and any Herbrand interpretation Y that is a
subset of X,
Y |=T s(a ← B, N )X
T
iff

p(a)

← DL[Q ⊕ p; R](a)
← not p(a).

(9)

Since DL[Q ⊕ p; R](a) cannot be satisﬁed by any set of
atoms formed using a, p/1, P has neither strong nor weak
answer sets. On the other hand, without going into details,
if we represent DL[Q ⊕ p; R](a) by ∀x(p(x) → Q(x)) →
R(a)), the “FOL-representation” of (9) is


F = (∀x(p(x) → Q(x)) → R(a)) → p(a) ∧ ¬¬p(a)

X ∪ YqPP |=T (B ∧ N )∗ (q) → a∗ (q).

Case 1:
s(a
←
B, N )X
is empty. Clearly,
T
X
Y |=T s(a ← B, N )T . Since no dl-atom in B mentions , B contains no dl-atoms from DL?P , and it follows
that X |=T b for some not b in N . Consequently, by
Lemma 2, it follows that X ∪ YqPP |=T (¬b)∗ (q), so that
X ∪ YqPP |=T (B ∧ N )∗ (q) → a∗ (q).

and SM[F ; p] is satisﬁable.

61

Conclusion

Ferraris, P.; Lee, J.; and Lifschitz, V. 2011. Stable models
and circumscription. Artiﬁcial Intelligence 175:236–263.
Gelfond, M., and Lifschitz, V. 1988. The stable model
semantics for logic programming. In Kowalski, R., and
Bowen, K., eds., Proceedings of International Logic Programming Conference and Symposium, 1070–1080. MIT
Press.
Heymans, S.; de Bruijn, J.; Predoiu, L.; Feier, C.; and
Nieuwenborgh, D. V. 2008. Guarded hybrid knowledge
bases. TPLP 8(3):411–429.
Heymans, S.; Nieuwenborgh, D. V.; and Vermeir, D. 2005.
Guarded open answer set programming. In Procedings of
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 92–104.
Lee, J., and Meng, Y. 2009. On reductive semantics of aggregates in answer set programming. In Procedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 182–195.
Lee, J., and Palla, R. 2007. Yet another proof of the strong
equivalence between propositional theories and logic programs. In Working Notes of the Workshop on Correspondence and Equivalence for Nonmonotonic Theories.
Lee, J.; Lifschitz, V.; and Palla, R. 2008. Safe formulas in
the general theory of stable models (preliminary report). In
Proceedings of International Conference on Logic Programming (ICLP), 672–676.
Lee, J.; Lifschitz, V.; and Palla, R. 2009. Safe formulas in
the general theory of stable models5 . Unpublished Draft.
Motik, B., and Rosati, R. 2010. Reconciling description
logics and rules. J. ACM 57(5).
Motik, B.; Sattler, U.; and Studer, R. 2005. Query answering
for owl-dl with rules. J. Web Sem. 3(1):41–60.
Nazarenko, A.; Polo, L.; Eiter, T.; de Bruijn, J.; Schwichtenberg, A.; and Heymans, S. 2010. How to integrate ontologies and rules? Tutorial, 24th Conference on Artiﬁcial
Intelligence (AAAI 2010).
Rosati, R. 2005. On the decidability and complexity of
integrating ontologies and rules. J. Web Sem. 3(1):61–73.
Rosati, R. 2006. DL+log: Tight integration of description
logics and disjunctive datalog. In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR), 68–78.
Wang, K.; Billington, D.; Blee, J.; and Antoniou, G. 2004.
Combining description logic and defeasible logic for the semantic web. In RuleML, 170–181.

In this paper, we investigate whether the stable model semantics from [Ferraris, Lee, & Lifschitz, 2011], which distinguishes between intensional and extensional predicates, is
a natural formalism to integrate rules and ontologies. Since
the ﬁrst-order stable model semantics is a generalization of
the traditional stable model semantics [Gelfond & Lifschitz,
1988] to ﬁrst-order formulas, it enables a rather simple and
straightforward integration of ASP rules and ontologies. Recent work on the ﬁrst-order stable model semantics helps us
in studying the semantic properties and computational aspects of the hybrid knowledge bases. For example, the splitting theorem presented in [Ferraris et al., 2009] is used in
proving Proposition 3 that shows the relationship between
DL + log and our approach. Also, as already discussed, the
concept of semi-safety studied under the ﬁrst-order stable
model semantics coincides with the concept of weak safety
in DL + log and the results on semi-safety can be used to
show that weak safety is a sufﬁcient condition for ensuring the decidability of reasoning in DL + log. Further, as
discussed in [de Bruijn et al., 2007b], the notion of strong
equivalence can be applied to provide the notion of equivalence between hybrid knowledge bases.
As part of the future work, we plan to investigate the relationship between hybrid MKNF knowledge bases [Motik &
Rosati, 2010] and our approach.

References
Bartholomew, M., and Lee, J. 2010. A decidable class of
groundable formulas in the general theory of stable models.
In Proceedings of International Conference on Principles of
Knowledge Representation and Reasoning (KR), 477–485.
de Bruijn, J.; Eiter, T.; Polleres, A.; and Tompits, H. 2007a.
Embedding non-ground logic programs into autoepistemic
logic for knowledge-base combination. In Proceedings of
International Joint Conference on Artiﬁcial Intelligence (IJCAI), 304–309.
de Bruijn, J.; Pearce, D.; Polleres, A.; and Valverde, A.
2007b. Quantiﬁed equilibrium logic and hybrid rules. In
RR, 58–72.
Eiter, T.; Ianni, G.; Lukasiewicz, T.; Schindlauer, R.; and
Tompits, H. 2008. Combining answer set programming
with description logics for the semantic web. Artiﬁcial Intelligence 172(12-13):1495–1539.
Feier, C., and Heymans, S. 2009. Hybrid reasoning with
forest logic programs. In ESWC, 338–352.
Ferraris, P., and Lifschitz, V. 2010. The stable model semantics for ﬁrst-order formulas with aggregates4 . In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).
Ferraris, P.; Lee, J.; Lifschitz, V.; and Palla, R. 2009. Symmetric splitting in the general theory of stable models. In
Proceedings of International Joint Conference on Artiﬁcial
Intelligence (IJCAI), 797–803.
4

5

http://userweb.cs.utexas.edu/users/vl/papers/smaf.pdf .

62

http://peace.eas.asu.edu/joolee/papers/safety.pdf .

Logical Formalizations of Commonsense Reasoning — Papers from the AAAI 2011 Spring Symposium (SS-11-06)

First-Order Semantics of Aggregates in Answer Set
Programming Via Modiﬁed Circumscription
Michael Bartholomew, Joohyung Lee and Yunsong Meng
School of Computing, Informatics and Decision Systems Engineering
Arizona State University, Tempe, USA
{mjbartho, joolee, Yunsong.Meng}@asu.edu

the same minimality condition as in the original deﬁnition of
an answer set applies. For example, consider the following
program Π1 :
p ← not q
q ← not p
(1)
r←p
r←q.
The FLP-reduct of Π1 relative to X = {p, r} is

Abstract
We provide reformulations and generalizations of both the
semantics of logic programs by Faber, Leone and Pfeifer
and its extension to arbitrary propositional formulas by
Truszczyński. Unlike the previous deﬁnitions, our generalizations refer neither to grounding nor to ﬁxpoints, and
apply to ﬁrst-order formulas containing aggregate expressions. Similar to the ﬁrst-order stable model semantics by
Ferraris, Lee and Lifschitz, the reformulations presented here
are based on syntactic transformations that are similar to circumscription. The reformulations provide useful insights into
the FLP semantics and its relationship to circumscription and
the ﬁrst-order stable model semantics.

p ← not q
r ← p,

(2)

and X is minimal among the sets of atoms satisfying (2),
and hence is an answer set of Π1 . Theorem 3.6 from (Faber
et al. 2011) asserts that this deﬁnition of an answer set is
equivalent to the traditional deﬁnition when it is applied to
the syntax of usual disjunctive programs. For example, the
GL-reduct of Π1 relative to X (Gelfond and Lifschitz 1988)
is
p
r←p
(3)
r←q
and, again, {p, r} is minimal among the sets of atoms satisfying (3).
The FLP semantics was recently extended to arbitrary
propositional formulas by Truszczyński (2010), based on
the deﬁnition of a reduct that is similar to the one proposed
by Ferraris (2005). However, this extension is still limited;
it allows neither variables nor aggregates.
In this paper, we extend the FLP semantics and its extension by Truszczyński, both syntactically and semantically.
We consider the syntax of arbitrary ﬁrst-order formulas allowing aggregates. Instead of referring to grounding and
ﬁxpoints, our generalized semantics are given in terms of
translations into second-order classical logic, in the same
spirit as the ﬁrst-order stable model semantics by Ferraris,
Lee and Lifschitz (Ferraris et al. 2007; 2011). This allows
us to show how the FLP semantics and its extension are
related to circumscription by McCarthy (McCarthy 1980;
1986) and to the ﬁrst-order stable model semantics. Interestingly a simple modiﬁcation of the deﬁnition of circumscription yields the ﬁrst-order extension of the FLP semantics. Truszczyński’s extension resembles the FLP semantics
on the one hand, and the ﬁrst-order stable model semantics
on the other hand.

Introduction
The stable model semantics is the mathematical basis of answer set programming, and is one of the most well-studied
knowledge representation formalisms. Lifschitz (2010) surveys thirteen different deﬁnitions of a stable model presented in the literature. These deﬁnitions are equivalent to
each other when they are applied to normal logic programs,
but are not necessarily so for more general classes of programs. However, each of them deserves its own attention,
as it provides useful insights into the stable model semantics
and answer set programming.
The semantics deﬁned by Faber, Leone and Pfeifer (2011)
(called the FLP semantics) deserves special attention since
it provides a simple satisfactory solution to the semantics of
aggregates, and is implemented in the system DLV1 . It is
also a basis of some extensions of the answer set semantics
to integrate with external sources that have possibly heterogeneous semantics (e.g., HEX programs (Eiter et al. 2005)).
Dao-Tran et al. (2009) remark that the FLP semantics provides a more natural ground for their Modular Logic Programs (MLP) than the traditional Gelfond-Lifschitz semantics (Gelfond and Lifschitz 1988).
The idea of the FLP semantics is based on an interesting
modiﬁcation of the traditional deﬁnition of a reduct by Gelfond and Lifschitz (1988). The FLP-reduct of a program Π
relative to a set X of atoms is obtained from Π by simply removing all rules whose bodies are not satisﬁed by X. Then
c 2011, Association for the Advancement of Artiﬁcial
Copyright 
Intelligence (www.aaai.org). All rights reserved.
1
http://www.dlvsystem.com

16

Let Π be a ﬁnite program whose rules have the form (5).
The FOL-representation ΠFOL of Π is the conjunction of
the universal closures of B → H for all rules (5) in Π. By
FLP[Π; p] we denote the second-order formula

FLP Semantics
Review: Original FLP Semantics
A disjunctive rule is an expression of the form
A1 ; . . . ; Al ← Al+1 , . . . , Am , not Am+1 , . . . , not An
(4)
(n ≥ m ≥ l ≥ 0) where each Ai is an atomic formula
(possibly containing equality and 0-place connectives  and
⊥). A disjunctive program is a set of disjunctive rules. The
FLP semantics for a disjunctive program is deﬁned in terms
of grounding and reduct. By σ(Π) we denote the signature
consisting of the object, function and predicate constants occurring in Π. We denote by Ground(Π) the ground instance
of Π, that is the program obtained from Π by replacing every
occurrence of object variables with every ground term that
can be constructed from σ(Π), and then replacing equality
t = t with  or ⊥ depending on whether term t is the same
symbol as term t . Given a set X of ground atoms of σ(Π),
the reduct of Π relative to X, denoted by ΠX , is obtained
from Ground(Π) by removing all rules whose body is not
satisﬁed by X. Set X is called an FLP-answer set of Π if X
is minimal among the sets of atoms that satisfy ΠX (viewed
as a formula in propositional logic). For example, for Π1
X
and X = {p, r} in the introduction, Π1 is (2) and X is an
FLP-answer set of Π1 .

ΠFOL ∧ ¬∃u(u < p ∧ Π (u))
where Π (u) is deﬁned as the conjunction of
∀x(B ∧ B(u) → H(u))

(7)

for all rules H ← B in Π, where x is the list of all (free)
variables in H ← B.2
We will often simply write FLP[Π] instead of FLP[Π; p]
when p is the list of all predicate constants occurring in Π,
and call a model of FLP[Π] an FLP-stable model of Π.
Example 1 Consider the program Π1 in the introduction.
is
Its FOL-representation ΠFOL
1
(¬q → p) ∧ (¬p → q) ∧ (p → r) ∧ (q → r)
and

Π
1 (u, v, w)

is

(¬q∧¬v → u)∧(¬p∧¬u → v)∧(p∧u → w)∧(q∧v → w).
Formula
∧ ¬∃uvw((u, v, w) < (p, q, r) ∧ Π
ΠFOL
1
1 (u, v, w))
can be equivalently rewritten without second-order variables as ¬(p ↔ q) ∧ (r ↔ p ∨ q).

Extension: First-Order FLP Semantics
We present a reformulation of the FLP semantics in the ﬁrstorder case. First, we consider a program that does not contain aggregates, but that allows rules of a more general form
than (4). We assume the following set of primitive propositional connectives and quantiﬁers for forming formulas:

Though implications are allowed even in the head and
in the body, the outermost implications (the rule arrow explicitly shown in (5)) are distinguished from them due to
the presence of ’B∧’ in the deﬁnition of Π . If we drop
’B∧’ from (7), then (6) becomes exactly CIRC[ΠFOL ; p]
(McCarthy 1980; 1986). Interestingly, this small difference
accounts for many differences in the properties of the two
semantics, one leading to stable models and the other leading to minimal models. For instance, classically equivalent
transformation preserves the minimal models, but not FLPstable models. For example, p ← not q and q ← not p are
classically equivalent to each other (when we identify them
with their FOL-representations), but their FLP-stable models are different.

⊥, ∧, ∨, →, ∀, ∃ .
¬F is an abbreviation for F → ⊥, symbol  stands for
⊥ → ⊥, and F ↔ G stands for (F → G) ∧ (G → F ).
A (general) rule is of the form
H←B

(6)

(5)

where H and B are arbitrary formulas in ﬁrst-order logic.
Rule (4) is a special case of (5) when we identify not with
¬, the head H with the disjunction of atomic formulas and
the body B with the conjunction of atomic formulas, possibly preceded by negation. A (general) program is a set of
(general) rules.
Let p be a list of distinct predicate constants p1 , . . . , pn ,
and let u be a list of distinct predicate variables u1 , . . . , un .
By u ≤ p we denote the conjunction of the formulas
∀x(ui (x) → pi (x)) for all i = 1, . . . , n where x is a list of
distinct object variables of the same length as the arity of pi ,
and by u < p we denote (u ≤ p)∧¬(p ≤ u). For instance,
if p and q are unary predicate constants then (u, v) < (p, q)
is
∀x(u(x) → p(x)) ∧ ∀x(v(x) → q(x))
∧¬(∀x(p(x) → u(x)) ∧ ∀x(q(x) → v(x))).

Theorem 1 Let Π be a ﬁnite disjunctive program (consisting of rules of the form (4)) containing at least one object
constant. The FLP-answer sets of Π in the sense of (Faber
et al. 2011) are precisely the Herbrand models of FLP[Π]
whose signature is σ(Π).
It is known that the FLP semantics from (Faber et al.
2011) has the anti-chain property: no FLP-answer set is a
proper subset of another FLP-answer set. This property is
still preserved in our generalized semantics.
Proposition 1 For any ﬁnite general program Π, if I is an
Herbrand interpretation of σ(Π) that satisﬁes FLP[Π], then
I is a subset-minimal model of Π.3
Note that we assume that Π is ﬁnite in order to avoid inﬁnite
conjunctions in the FOL representation.
3
We identify an Herbrand interpretation I with the set of ground
atoms that are satisﬁed by I.
2

For any aggregate formula G, formula G(u) is obtained
from G by replacing all occurrences of predicates from p
with the corresponding predicate variables from u.

17

We say that an occurrence of a variable v in an aggregate
formula H is bound if the occurrence is in a part of H of the
form x : F (x) where v is in x, or in a part of H of the
form QvG. Otherwise it is free. We say that v is free in H if
H contains a free occurrence of v. An aggregate sentence is
an aggregate formula with no free variables.
The deﬁnition of an interpretation is the same as in ﬁrstorder logic. Consider an interpretation I of a ﬁrst-order signature σ that may contain any function constants of positive
arity. By σ |I| we mean the signature obtained from σ by
adding distinct new object constants ξ ∗ , called names, for
all ξ in the universe of I. We identify an interpretation I of
σ with its extension to σ |I| deﬁned by I(ξ ∗ ) = ξ.
The deﬁnition of satisfaction in ﬁrst-order logic is extended to aggregate sentences as follows. We consider
“standard” interpretations only, in which symbols for numbers and comparison operators are evaluated in the standard
way.5 Let I be an interpretation of signature σ. Consider
any aggregate expression (8) that has no free variables. Let
SI be the multiset consisting of all ξ ∗ [1] in the universe of I
where
• ξ ∗ is a list of object names of σ |I| whose length is the
same as the length of x, and
• I satisﬁes F (ξ ∗ ).
(For any list of object constants c, by c[1] we denote the ﬁrst
element of c.)
An interpretation I satisﬁes the aggregate expression if
SI is in the domain of OP, and OP(SI )  bI . With this extension, the recursive deﬁnition of satisfaction for an aggregate sentence is given in the same way as in ﬁrst-order logic.
We say that an aggregate sentence F is logically valid if every standard interpretation satisﬁes it. For instance, an Herbrand interpretation {p(a)} satisﬁes COUNTx : p(x) > 0
but does not satisfy SUMx : p(x) > 0 because multiset
{{a}} is not in the domain of SUM. Consider the aggregate
expression
SUM x : p(x) ≥ 0
and an Herbrand interpretation I = {p(−1), p(1)}. SI
is {{−1, 1}} and SUM(SI ) = 0 ≥ 0, so I satisﬁes
SUM x : p(x) ≥ 0.
Once we extend the deﬁnition of satisfaction to aggregate sentences, we can simply extend the FLP semantics in
the previous section to a general program with aggregates,
which allows aggregate formulas in the head and in the body
of a rule. The AF-representation (“Aggregate Formula representation”) of a ﬁnite general program Π with aggregates
is the conjunction of the universal closures of the aggregate
formulas
B→H
(9)
for all rules H ← B in Π. FLP[Π; p] is deﬁned the same
as (6) except that Π is now understood as a general program
with aggregates.

Clearly, circumscription can be viewed as a special case
of the FLP semantics.
Proposition 2 For any ﬁrst-order formula F and any list
p of predicate constants, CIRC[F ; p] is equivalent to
FLP[F ← ; p].
The FLP semantics can be represented by circumscription
in the following way.
Proposition 3 For any ﬁnite general program Π, formula
FLP[Π; p] is equivalent to
∃u(CIRC[Π (u); u] ∧ (u = p)).

Extension: First-Order FLP Semantics for
Programs with Aggregates
The semantics given in the previous section can be extended
to allow aggregates by simply extending the notion of satisfaction to cover aggregate expressions. Below we adopt the
deﬁnitions of an aggregate formula and satisfaction as given
in (Lee and Meng 2009; Ferraris and Lifschitz 2010).
Following (Ferraris and Lifschitz 2010), by a number we
understand an element of some ﬁxed set Num. For example, Num is Z ∪ {+∞, −∞}, where Z is the set of integers.
An aggregate function is a partial function from the class of
multisets to Num. The domain of an aggregate function is
deﬁned as usual. For instance, COUNT is deﬁned for any
multisets; SUM, TIMES, MIN and MAX are deﬁned for multisets of numbers; SUM is undeﬁned for multisets containing
inﬁnitely many positive integers and inﬁnitely many negative integers.
We assume that the signature σ contains symbols for all
numbers, and some collection of comparison operators that
stands for binary relations over numbers. We assume that
symbols for aggregate functions are not part of the signature.
An aggregate expression of signature σ is of the form 4
OP x

: F (x)  b

(8)

where
•

OP

is an aggregate function;

• x is a nonempty list of distinct object variables;
• F (x) is a ﬁrst-order formula;
•  is a comparison operator;
• b is a term.
We deﬁne an aggregate formula as an extension of a ﬁrstorder formula by treating aggregate expressions as a base
case like (standard) atomic formulas (including equality and
⊥). In other words, aggregate formulas are constructed from
atomic formulas and aggregate expressions using connectives and quantiﬁers as in ﬁrst-order logic. For instance,
(SUMx : p(x) ≥ 1 ∨ ∃y q(y)) → r(x)

For instance, we assume that, when both x and y are integer
constants, x ≤ y evaluates to true iff x is less than y, and x + y
is the sum of the integers. On the other hand, when x or y are not
integers, x ≤ y evaluates to false, and x + y has an arbitrary value
according to the interpretation.
5

is an aggregate formula.
4

The syntax of aggregate expression considered in Ferraris and
Lifschitz (2010) is more general. The results in this paper can be
extended to the general syntax, which we omit for simplicity.

18

Example 2 Consider the following aggregate sentence F :
(¬(SUMx : p(x) < 2) → p(2))
∧ (SUMx : p(x) ≥ 0 → p(−1))
∧ (p(−1) → p(1)) .

Truszczyński Semantics
Review: Truszczyński Semantics
Truszczyński (2010) deﬁned an extension of the FLP semantics to arbitrary propositional formulas, similar to the extension of the stable model semantics to arbitrary propositional
formulas proposed by Ferraris (2005).
For any propositional formula F , the FLPT-reduct F X
relative to a set X of atoms is deﬁned recursively:

A if X |= A,
X
• A =
⊥ otherwise;

(10)

The FLP-stable models of (10) are the models of
F ∧ ¬∃u(u < p ∧ Π (u))

(11)

where Π (u) is
(¬(SUMx : p(x) < 2) ∧ ¬(SUMx : u(x) < 2) → u(2))
∧ (SUMx : p(x) ≥ 0 ∧ SUMx : u(x) ≥ 0 → u(−1))
∧ (p(−1) ∧ u(−1) → u(1)) .
(12)

• ⊥X = ⊥;
• (G  H)

• (G → H)X

A1 ; . . . ; Al ← E1 , . . . , Em , not Em+1 , . . . , not En (13)

=

GX  H X
⊥

⎧
X
⎨G → H
= 
⎩
⊥

if X |= G  H,
otherwise;
if X |= G, and X |= H,
if X |= G,
otherwise.

Set X is an FLPT-answer set of F if X is minimal among
the sets of atoms that satisfy F X .
As noted in (Truszczyński 2010), this deﬁnition of a
reduct is similar to the deﬁnition of a reduct by Ferraris
(2005), except for the case G → H.

(l ≥ 0; n ≥ m ≥ 0), where each Ai is an atomic formula
and each Ei is an atomic formula or an aggregate expression.
For example, the following is a disjunctive program with
aggregates, whose AF-representation is (10):
← not SUMx : p(x) < 2
← SUMx : p(x) ≥ 0
← p(−1) .



( ∈ {∧, ∨});

Below we show how this semantics is related to the original semantics in (Faber et al. 2011). Faber et al. (2011)
deﬁned their semantics for disjunctive programs with aggregates, whose rules have the form

p(2)
p(−1)
p(1)

X

Extension: FLPT Semantics for First-Order
Formulas with Aggregates

(14)

We extend the FLPT semantics to arbitrary ﬁrst-order formulas that allow aggregates.
For any ﬁrst-order formula F with aggregates and any ﬁnite list p of predicate constants, FLPT[F ; p] is deﬁned as

As before, the original FLP semantics is deﬁned in terms
of grounding and ﬁxpoints. Let us assume that b in every
aggregate expression (8) is a constant. We extend the notion Ground(Π) to a disjunctive program Π with aggregates
by replacing every free occurrence of a variable with every
ground term that can be constructed from σ(Π) in all possible ways.
For any disjunctive program Π with aggregates and any
Herbrand interpretation I whose signature is σ(Π), the FLPreduct of Π relative to I is obtained from Ground(Π) by removing every rule whose body is not satisﬁed by I. Set I
is an FLP-answer set of Π if it is minimal among the sets
of atoms that satisfy the FLP-reduct of Π relative to I. For
example, in program (14) above, the FLP-reduct of (14) relative to {p(−1), p(1)} contains the last two rules only. Set
{p(−1), p(1)} is minimal among the sets of atoms that satisfy the reduct, and thus is an FLP-answer set of (14). In
fact, this is the only FLP-answer set. Also one can check
that {p(−1), p(1)} is the only Herbrand model of σ(Π) that
satisﬁes (11) in Example 2. The following theorem tells us
that our semantics is a proper generalization of the semantics
from (Faber et al. 2011).

F ∧ ¬∃u(u < p ∧ F  (u))

(15)

where F  (u) is deﬁned recursively, as follows:
• pi (t) = ui (t) for any tuple t of terms;
• F  = F for any atomic formula F that does not contain
members of p;
• (G  H) = G  H  , where  ∈ {∧, ∨};
• (G → H) = (G(u) ∧ G → H  ) ∧ (G → H);
• (QxG) = QxG , where Q ∈ {∀, ∃};
• (OPx : G(p)  t) =
(OPx : G(u)  t) ∧ (OPx : G(p)  t);
Similar to FLP[Π], we will often simply write FLPT[F ]
instead of FLPT[F ; p] when p is the list of all predicate
constants occurring in F , and call a model of FLPT[F ] an
FLPT-stable model of F .
The following theorem asserts that our semantics is
a proper generalization of the answer set semantics by
Truszczyński which covers ﬁrst-order formulas with aggregates. For any formula F , by σ(F ) we denote the signature
consisting of object, function and predicate constants occurring in F .

Theorem 2 Let Π be a ﬁnite disjunctive program with aggregates that contains at least one object constant. The FLPanswer sets of Π in the sense of (Faber et al. 2011) are precisely the Herbrand models of FLP[Π] whose signature is
σ(Π).

19

Theorem 3 For any propositional formula F , the FLPTanswer sets of F are precisely the interpretations of σ(F )
that satisfy FLPT[F ].

Comparing FLP, FLPT and the First-Order
Stable Model Semantics
In (Ferraris et al. 2011) the stable models are deﬁned in
terms of the SM operator with intensional predicates: For
any ﬁrst-order sentence F and any list p of intensional predicates, SM[F ; p] is deﬁned as

Also the semantics above coincides with our extension of
the FLP semantics in the previous section when it is applied
to disjunctive programs with aggregates.
Proposition 4 For any ﬁnite disjunctive program Π with aggregates and the AF-representation F of Π, FLP[Π; p] is
equivalent to FLPT[F ; p].

F ∧ ¬∃u((u < p) ∧ F ∗ (u)),
where F ∗ (u) is deﬁned recursively:
• pi (t)∗ = ui (t) for any list t of terms;
• F ∗ = F for any atomic formula F that does not contain
members of p;
• (G  H)∗ = G∗  H ∗ , where  ∈ {∧, ∨};
• (G → H)∗ = (G∗ → H ∗ ) ∧ (G → H);
• (QxG)∗ = QxG∗ , where Q ∈ {∀, ∃};
• (OPx : G(x)  b)∗ =
(OPx : G∗ (x)  b) ∧ (OPx : G(x)  b).
We often simply write SM[F ] instead of SM[F ; p] when
p is the list of all predicate constants occurring in F , and
call a model of SM[F ] simply a stable model of F .
Disregarding aggregate expressions, the main difference
among FLP, FLPT and SM has to do with the treatment of
an implication. It is known that they coincide for programs
whose rules have the form (4) (Faber et al. 2011, Theorem 3.6), (Truszczyński 2010, Theorem 3). However, this
is not the case for more general classes of programs (having rules of the form (5)), or for arbitrary formulas. In fact,
no one is stronger than another, as shown in the following
example.

However, the statement of the proposition does not apply
to general programs.
Example 3 For general program Π = {p ∨ ¬p ← }
and its FOL-representation F , formula FLP[Π] has only one
model, ∅, and FLPT[F ] has two models, ∅ and {p}.
In comparison with Proposition 1, this example illustrates
that, unlike the FLP semantics, the FLPT semantics does
not keep the anti-chain property. This has to do with the fact
the FLP semantics distinguishes between rule arrows and the
other implications, while the FLPT semantics does not.
The notion of strong equivalence is important. Similar
to the relationship between HT-models and strong equivalence under the stable model semantics (Ferraris et al.
2011), Truszczyński (2010) related the FLPT-reduct to
“FLP-models,” and used them to characterize the strong
equivalence between propositional formulas under the FLPT
semantics. In the following we extend the result to arbitrary
ﬁrst-order formulas with aggregates.6
Following the deﬁnition of strong equivalence in the ﬁrstorder stable model semantics in (Ferraris et al. 2011), about
ﬁrst-order formulas with aggregates F and G we say that F
is FLPT-strongly equivalent to G if, for any formula H
with aggregates, any occurrence of F in H, and any list p
of distinct predicate constants, FLPT[H; p] is equivalent to
FLPT[H  ; p], where H  is obtained from H by replacing the
occurrence of F by G.

Example 4 For propositional signature {p} and program Π1 = {p ← p ∨ ¬p}, whose FOL-representation is
F1 = p ∨ ¬p → p, each of FLP[Π1 ] and FLPT[F1 ] has {p}
as the only model, and SM[F1 ] has no models.
Formula F1 is strongly equivalent (in the sense of (Ferraris et al. 2011)), but not FLPT-strongly equivalent to
F2 = (p → p) ∧ (¬p → p). Again, SM[F2 ] has no models.
Neither does FLP[Π2 ] nor FLPT[F2 ], where Π2 is the program corresponding to F2 .
For program Π3 = {p ∨ ¬p ← }, whose FOLrepresentation is F3 =  → p ∨ ¬p, both SM[F3 ] and
FLPT[F3 ] have two models, ∅ and {p}, while FLP[Π3 ] has
only one model, ∅.
Formula F3 is strongly equivalent, but not FLPT-strongly
equivalent to F4 = ¬¬p → p. Both FLP[Π4 ] (Π4 is the
program corresponding to F4 ) and FLPT[F4 ] have only one
model, ∅, while SM[F4 ] has the same models as SM[F3 ] .

Theorem 4 Let F and G be ﬁrst-order formulas with aggregates, let pF G be the list of all predicate constants occurring
in F or G and let u be a list of distinct predicate variables.
The following conditions are equivalent to each other.
• F and G are FLPT-strongly equivalent to each other;
• Formula
u ≤ pF G → (F  (u) ↔ G (u))
is logically valid.
This theorem is a proper extension of Theorem 7
from (Truszczyński 2010), which does not consider aggregates. As a special case, Theorem 4 can be applied to checking strong equivalence under the FLP semantics between the
programs whose rules have the form (13).
Theorem 4 is similar to Theorems 9 from (Ferraris et al.
2011), which is about strong equivalence under the stable
model semantics.

Note that, in the examples above, when “choice formula”
p ∨ ¬p is in the body, FLPT yields a formula that is equivalent to the one that FLP yields, and when p ∨ ¬p is in the
head, FLPT yields a formula that is equivalent to the one that
SM yields. This is not a coincidence; below we describe the
classes of formulas for which each pair of the semantics coincide.
But before that, we remark that FLPT-strong equivalence
involves some unintuitive results. We would expect that

6

Due to lack of space, we do not present the extension of FLP
models, but instead an alternative characterization in terms of F  .

20

F ∧ G and F ∧ (F → G) have the same FLPT-stable models. Indeed, they are strongly equivalent to each other in
the sense of (Ferraris et al. 2011), but not FLPT-strongly
equivalent. The two formulas may not even have the same
FLPT-stable models.

• F is semi-positive relative to p;
• for every occurrence of every predicate constant p from p
in F , we have that k + m ≤ 1;
• if a predicate constant p from p occurs in the scope of a
strictly positive occurrence of ∃ or ∨ in F , then the occurrence of p is strictly positive in F .

Example 5 For propositional signature {p} and F = ¬¬p
and G = p ∨ ¬p, formulas SM[F ∧ G] and FLPT[F ∧ G] are
equivalent to each other, having only one model, {p}. On
the other hand, SM[F ∧ (F → G)] has only one model {p},
but FLPT[F ∧ (F → G)] has no models.

Theorem 6 Let Π be a ﬁnite general program with aggregates and let F be the AF-representation of Π. For every
rule (5) in Π, if B is canonical relative to p and every occurrence of p from p is strictly positive in H, then FLP[Π; p]
is equivalent to SM[F ; p].

We now show the relationships among the three semantics. Roughly speaking, the FLPT semantics is in between
the two others in the sense that it treats a “non-strictly positive” occurrence of a subformula same as in the FLP semantics, and treats a “strictly positive” occurrence of a subformula same as in the ﬁrst-order stable model semantics.
This is related to the fact that the deﬁnition (F → G) is
similar to the (F → G) on the one hand and is similar to
(F → G)∗ on the other hand.
The following theorem presents a class of programs for
which the FLP semantics and the FLPT semantics coincide.
Following (Ferraris and Lifschitz 2010), we say that an aggregate function OP is monotone w.r.t.  if for any multisets
α, β such that α ⊆ β,

Among the programs in Example 4, only Π2 satisﬁes the
condition of Theorem 6. For another example, in program
(14), ¬(SUMx : p(x) < 2) is not canonical relative to
{p}. In fact, {p(−1), p(1), p(2)} is an Herbrand interpretation that satisﬁes SM[(10)], but it does not satisfy FLP[(14)].
Next we show the class of formulas F for which
FLPT[F ; p] coincides with SM[F ; p].
Theorem 7 Let F be a semi-positive aggregate formula relative to p such that every subformula that has a non-strictly
positive occurrence in F is canonical relative to p. Then
FLPT[F ; p] is equivalent to SM[F ; p].
In Example 4, relative to {p}, formulas F2 and F3 satisfy
the condition of Theorem 7, but formulas F1 and F4 do not.
In Example 5, relative to {p}, formula F ∧ G satisfy the
condition, but F ∧ (F → G) does not. Also formula (10)
does not satisfy the condition. Again, {p(−1), p(1), p(2)}
is an Herbrand interpretation that satisﬁes SM[(10)], but it
does not satisfy FLPT[(14)].

• if OP(α) is deﬁned then so is OP(β), and
• for any n ∈ Num, if OP(α)  n then OP(β)  n.
For an occurrence of a predicate constant or any other
subexpression in a formula F with aggregates, we consider
two numbers, k and m.
• k: the number of implications in F that contain that occurrence in the antecedent;

Conclusion

• m: the number of aggregate expressions (8) containing
that occurrence such that OP is not monotone w.r.t. .

We presented a reformulation of the FLP semantics by a simple modiﬁcation to circumscription, and presented a reformulation of the FLPT semantics using the recursive deﬁnition similar to the one used in the ﬁrst-order stable model
semantics. Our reformulations are more general than the
original semantics, and provide useful insights into the relationships among the FLP semantics, the FLPT semantics,
circumscription and the ﬁrst-order stable model semantics.
Also they suggest that the extension of the FLP semantics
mentioned in the introduction can be generalized without the
need to refer to grounding.

We call an occurrence of a subexpression in F strictly
positive if k + m for that occurrence in F is 0.
The following theorem presents a class of programs for
which the FLP semantics and the FLPT semantics coincide.
Theorem 5 Let Π be a ﬁnite general program with aggregates, and let F be the AF-representation of Π. For every
rule (5) in Π, if every occurrence of p from p is strictly positive in H, then FLP[Π; p] is equivalent to FLPT[F ; p].
The theorem is a generalization of Proposition 4. For example, the FLP and the FLPT semantics coincide on the programs whose heads have the form of a disjunction of atoms,
regardless of the form of the formulas in the body. In Example 4, programs Π1 , Π2 and Π4 satisfy the condition of
Theorem 5. Also program (14) satisﬁes the same condition.
Next we show the class of programs for which the FLP
semantics and the stable model semantics coincide. We
ﬁrst deﬁne two notions. We call an aggregate formula
semi-positive relative to p if, for every aggregate expression OPx : G  b in it, every occurrence of every predicate p from p is strictly positive in G. We say that an aggregate formula F is canonical relative to a list p of predicate
constants if

Acknowledgements
We are grateful to anonymous referees for their useful comments on this paper. The authors were partially supported by
the National Science Foundation under Grants IIS-0916116
and by the IARPA SCIL program.

References
Minh Dao-Tran, Thomas Eiter, Michael Fink, and Thomas
Krennwallner. Modular nonmonotonic logic programming
revisited. In Proceedings of International Conference on
Logic Programming (ICLP), pages 145–159, 2009.

21

Thomas Eiter, Giovambattista Ianni, Roman Schindlauer,
and Hans Tompits. A uniform integration of higher-order
reasoning and external evaluations in answer-set programming. In IJCAI, pages 90–96, 2005.
Wolfgang Faber, Gerald Pfeifer, and Nicola Leone. Semantics and complexity of recursive aggregates in answer
set programming. Artiﬁcial Intelligence, 175(1):278–298,
2011.
Paolo Ferraris and Vladimir Lifschitz. On the stable model
semantics of ﬁrsr-oder formulas with aggregates. In NMR,
2010.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. A
new perspective on stable models. In Proceedings of International Joint Conference on Artiﬁcial Intelligence (IJCAI),
pages 372–379, 2007.
Paolo Ferraris, Joohyung Lee, and Vladimir Lifschitz. Stable models and circumscription. Artiﬁcial Intelligence,
175:236–263, 2011.
Paolo Ferraris. Answer sets for propositional theories. In
Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 119–
131, 2005.
Michael Gelfond and Vladimir Lifschitz. The stable model

semantics for logic programming. In Robert Kowalski and
Kenneth Bowen, editors, Proceedings of International Logic
Programming Conference and Symposium, pages 1070–
1080. MIT Press, 1988.
Joohyung Lee and Yunsong Meng. On reductive semantics
of aggregates in answer set programming. In Procedings of
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 182–195, 2009.
Vladimir Lifschitz. Thirteen deﬁnitions of a stable model. In
Andreas Blass, Nachum Dershowitz, and Wolfgang Reisig,
editors, Fields of Logic and Computation, volume 6300
of Lecture Notes in Computer Science, pages 488–503.
Springer, 2010.
John McCarthy. Circumscription—a form of non-monotonic reasoning. Artiﬁcial Intelligence, 13:27–39,171–172,
1980.
John McCarthy. Applications of circumscription to formalizing common sense knowledge. Artiﬁcial Intelligence,
26(3):89–116, 1986.
Miroslaw Truszczyński. Reducts of propositional theories,
satisﬁability relations, and generalizations of semantics of
logic programs. Artiﬁcial Intelligence, 174(16-17):1285–
1306, 2010.

22

Stable Models of Fuzzy Propositional Formulas
Joohyung Lee and Yi Wang
School of Computing, Informatics, and Decision Systems Engineering
Arizona State University, Tempe, USA
{joolee,ywang485}@asu.edu

Abstract. We introduce the stable model semantics for fuzzy propositional formulas, which generalizes both fuzzy propositional logic and the stable model
semantics of classical propositional formulas. Combining the advantages of both
formalisms, the introduced language allows highly configurable default reasoning
involving fuzzy truth values. We show that several properties of Boolean stable
models are naturally extended to this formalism, and discuss how it is related to
other approaches to combining fuzzy logic and the stable model semantics.

1

Introduction

Answer set programming (ASP) [1] is a widely applied declarative programming paradigm
for the design and implementation of knowledge intensive applications. One of the attractive features of ASP is its capability to model the nonmonotonic aspect of knowledge. However, as its mathematical basis, the stable model semantics, is restricted to
Boolean values, it is too rigid to represent imprecise and vague information. Fuzzy
logic [2], as a form of many-valued logic, can handle vague information by interpreting
propositions with a truth degree in the interval of real numbers [0, 1]. The availability
of various fuzzy operators gives the user great flexibility in combining truth degrees.
However, the semantics of fuzzy logic is monotonic, and is not flexible enough to handle default reasoning allowed in answer set programming.
Both the stable model semantics and fuzzy logic are generalizations of classical
propositional logic in different ways. While they do not subsume each other, it is clear
that many real-world problems require both their strengths. This led to the body of work
on combining fuzzy logic and the stable model semantics, known as fuzzy answer set
programming (e.g., [3, 4]). However, their syntax is restricted to rules, and does not
allow connectives nested arbitrarily as in fuzzy logic.
Unlike existing work on fuzzy answer set semantics, in this paper, we extend the
general stable model semantics from [5] to many-valued propositional formulas. The
syntax of this language is the same as the syntax of fuzzy propositional logic. The
semantics, on the other hand, defines stable models instead of models. The language is
a proper generalization of both fuzzy propositional logic and the stable model semantics
for Boolean propositional formulas. This generalization is not simply a pure theoretical
pursuit, but has practical use in conveniently modeling defaults involving fuzzy truth
values in dynamic domains. For example, consider modeling dynamics of trust in social
network. People trust each other in different degrees under some normal assumptions.
If person A trusts another person B, then A tends to trust person C whom B trusts

2

Joohyung Lee and Yi Wang

to a degree which is positively correlated to the degree to which A trusts B and the
degree to which B trusts C. If nothing happens, the trust degrees would not change.
But there may be less trust between two people when a conflict arises between them.
Modeling such a domain requires expressing defaults involving fuzzy truth values. We
demonstrate that such examples can be conveniently modelled in our proposed language
by taking advantage of its generality over the existing approaches to fuzzy ASP.
The paper is organized as follows. Section 2 reviews the syntax and the semantics of
fuzzy propositional logic we discuss in the paper, as well as the stable model semantics
of classical propositional formulas. Section 3 presents the stable model semantics of
fuzzy propositional formulas along with examples, followed by Section 4 that formalizes the trust example above in the proposed language. Section 5 shows how the fuzzy
stable model semantics is related to the Boolean stable model semantics, and Section 6
shows how our fuzzy stable model semantics is related to other approaches to fuzzy
ASP. Section 7 shows that several well-known properties of the Boolean stable model
semantics can be easily extended to our fuzzy stable model semantics.

2

Preliminaries

2.1

Review: Stable Models of Classical Propositional Formulas

We review the definition of a stable model from [5] by limiting attention to the syntax of
propositional formulas. Instead of defining stable models in terms of second-order logic
as in [5] , we express the same concept using auxiliary atoms that do not belong to the
original signature. This slight reformulation will simplify our efforts in extending the
stable model semantics to fuzzy propositional formulas without resorting to “secondorder fuzzy logic.”
Let σ be a classical propositional signature, p = (p1 , . . . , pn ) be a list of distinct
atoms belonging to σ, and let q = (q1 , . . . , qn ) be a list of new propositional atoms not
in σ.
For two interpretations I and J of σ, I ∪ Jqp denotes the interpretation of σ ∪ q that
agrees with I and J on all atoms not in p ∪ q, and
– for each p ∈ p, (I ∪ Jqp )(p) = I(p);
– for each q ∈ q, (I ∪ Jqp )(q) = J(p).1
For any classical propositional formula F of signature σ, F ∗ (q) is a classical propositional formula of signature σ ∪ q that is defined recursively as follows:
–
–
–
–
–
–
1

p∗i = qi for each pi ∈ p;
F ∗ = F for any atom F 6∈ p;
⊥∗ = ⊥; >∗ = >;
(¬F )∗ = ¬F ;
(F ∧ G)∗ = F ∗ ∧ G∗ ;
(F ∨ G)∗ = F ∗ ∨ G∗ ;
∗
∗
∗
(F → G) = (F → G ) ∧ (F → G).

I(p) denotes the truth value of p under I. We identify a list with a set if there is no confusion.

Stable Models of Fuzzy Propositional Formulas

3

Let I and J be two interpretations of σ, and let p be a subset of σ. We say J ≤p I
if
– J and I agree on all atoms not in p, and
– for all p ∈ p, if J |= p, then I |= p.
We say J <p I if J ≤p I and J 6= I.
Definition 1. An interpretation I is a stable model of F relative to p (denoted I |=
SM[F ; p])
– if I |= F , and
– there is no interpretation J such that J <p I and I ∪ Jqp |= F ∗ (q).
Example 1. Consider a logic program
p ← not q, q ← not p
which is understood as an alternative notation for propositional formula
F1 = (¬q → p) ∧ (¬p → q).
F1∗ (u, v) is
(¬q → u) ∧ (¬q → p) ∧ (¬p → v) ∧ (¬p → q).
We check that I1 = {p} (that is, p is TRUE and q is FALSE) 2 is a stable model of F1
(relative to {p, q}): I1 satisfies F1 , and ∅ is the only interpretation J such that J <pq I1 .
pq
= {p} does not satisfy F1∗ (u, v) because it does not satisfy the first
However, I1 ∪ Juv
conjunctive term of F1∗ (u, v).
Similarly, we can check that {q} is another stable model of F1 .
2.2

Review: Fuzzy Logic

Let σ be a fuzzy propositional signature, which is a set of symbols called fuzzy atoms.
In addition, we assume the presence of a set C of fuzzy conjunction symbols, a set D
of fuzzy disjunction symbols, a set N of fuzzy negation symbols, and a set I of fuzzy
implication symbols.
A fuzzy (propositional) formula of σ is defined recursively as follows.
–
–
–
–
2

every fuzzy atom p ∈ σ is a fuzzy formula;
every numeric constant c where c is a real number in [0, 1] is a formula;
if F is a formula, then ¬F is a formula, where ¬ ∈ N;
if F and G are formulas, then F ⊗ G, F ⊕ G and F → G are formulas, where
⊗ ∈ C, ⊕ ∈ D, and → ∈ I.

We identify a propositional interpretation with the set of atoms that are true in it.

4

Joohyung Lee and Yi Wang

The models of a fuzzy formula are defined as follows [2]. The fuzzy truth values are
the real numbers in the range [0, 1]. A fuzzy interpretation I of σ is a mapping from σ
into [0, 1].
The fuzzy operators are functions mapping one or two truth values into a truth value.
Among the operators, ¬ denotes a function from [0, 1] into [0, 1]; ⊗, ⊕, and → denote
functions from [0, 1] × [0, 1] into [0, 1]. The actual mapping performed by each operator
can be defined in many different ways, but all of them satisfy the following conditions,
which imply that they are generalizations of the corresponding classical propositional
connectives:3
– a fuzzy negation ¬ is decreasing, and satisfies ¬(0) = 1 and ¬(1) = 0;
– a fuzzy conjunction ⊗ is increasing, commutative, associative, and ⊗(1, x) = x for
all x ∈ [0, 1];
– a fuzzy disjunction ⊕ is increasing, commutative, associative, and ⊕(0, x) = x for
all x ∈ [0, 1];
– a fuzzy implication → is decreasing in its first argument and increasing in its second
argument; and → (1, x) = x and → (0, 0) = 1 for all x ∈ [0, 1].
Figure 1 lists some specific fuzzy operators that we use in this paper.
Symbol
⊗l
⊕l
⊗m
⊕m
⊗p
⊕p
¬s

Name
Łukasiewicz t-norm
Łukasiewicz t-conorm
minimum t-norm
maximum t-conorm
product t-norm
product t-conorm
standard negator

→r

the residual implicator of ⊕m

→s

the S-implicator induced by ¬s and ⊕m

Definition
⊗l (x, y) = max (x + y − 1, 0)
⊕l (x, y) = min (x + y, 1)
⊗m (x, y) = min (x, y)
⊕m (x, y) = max (x, y)
⊗p (x, y) = x · y
⊕p (x, y) = x + y − x · y
¬s (x) = 1 − x
(
1 if x ≤ y
→r (x, y) =
y otherwise
→s (x, y) = max (1 − x, y)

Fig. 1. Some t-norms, t-conorms, negator, and implicators

The truth value of a formula F under I, denoted F I , is defined recursively as follows:
–
–
–
–
3

for any atom p ∈ σ, pI = I(p);
for any numeric constant c, cI = c;
(¬F )I = ¬(F I );
(F ⊗ G)I = ⊗(F I , GI ); (F ⊕ G)I = ⊕(F I , GI ); (F → G)I = → (F I , GI ).

We say that a function f of arity n is increasing in its i-th argument (1 ≤ i ≤ n) if
f (arg1 , . . . , argi , . . . , argn ) ≤ f (arg1 , . . . , argi0 , . . . , argn ) for all arguments such that
argi ≤ argi0 ; f is said to be increasing if it is increasing in all its arguments. The definition of
decreasing is similar.

Stable Models of Fuzzy Propositional Formulas

5

(For simplicity, we identify the symbols for the fuzzy operators with the truth value
functions represented by them.)
Definition 2. We say that a fuzzy interpretation I satisfies a fuzzy formula F w.r.t. a
threshold y ∈ [0, 1] if F I ≥ y, and denote it by I |=y F . We call I a fuzzy y-model
of F .
We often omit the threshold y when it is 1.

3

Definition and Examples

We extend the notion of J <p I in Section 2.1 as follows. For any two fuzzy interpretations J and I of the same signature σ and any subset p of σ, we say J ≤p I
if
– J and I agree on all fuzzy atoms not in p, and
– for all p ∈ p, pJ ≤ pI .
We say J <p I if J ≤p I and J 6= I.
As before, we assume a list q of new, distinct fuzzy atoms, and define I ∪ Jqp in the
same way. That is, I ∪ Jqp denotes the interpretation of σ ∪ q that agrees with I and J
on all atoms not in p ∪ q, and
– for each p ∈ p, (I ∪ Jqp )(p) = I(p);
– for each q ∈ q, (I ∪ Jqp )(q) = J(p).
The definition of F ∗ is also extended in a straightforward way: For any fuzzy formula F of signature σ, F ∗ (q) is defined as follows.
–
–
–
–
–
–

p∗i = qi for each pi ∈ p;
F ∗ = F for any atom F 6∈ p;
c∗ = c for any numeric constant c;
(¬F )∗ = ¬F ;
(F ⊗ G)∗ = F ∗ ⊗ G∗ ;
(F ⊕ G)∗ = F ∗ ⊕ G∗ ;
(F → G)∗ = (F ∗ → G∗ ) ⊗m (F → G).

Definition 3. An interpretation I is a y-stable model of F relative to p (denoted I |=y
SM[F ; p]) if
– I |=y F , and
– there is no interpretation J such that J <p I and I ∪ Jqp |=y F ∗ (q).
We often omit the threshold y when it is 1, and omit p if it contains all atoms in σ.
Clearly, when p is empty, Definition 3 reduces to the definition of a fuzzy model in
Definition 2 because there is no J such that J <∅ I.
Also, Definition 3 is very similar to the definition of a stable model for classical
propositional formulas in Definition 1. The main difference is that simply in the latter,
atoms may have various degrees of truth, and accordingly the notion of J <p I is more
general. The precise relationship between the definitions is discussed in Section 5.

6

Joohyung Lee and Yi Wang

Example 2. Consider the formula F = ¬s p →r q and the interpretation I = {(p, 0), (q, 0.6)}.
F ∗ (u, v) is
((¬s p)∗ →r q ∗ ) ⊗m (¬s p →r q) = (¬s p →r v) ⊗m (¬s p →r q).
I |=0.6 SM[F ; p, q]. First, it is easy to see that I |=0.6 F , as
F I =→r ((¬s p)I , q I ) =→r (1 − pI , q I ) =→r (1, 0.6) = 0.6.
pq
Suppose there exists J <pq I such that I ∪ Juv
|=0.6 F , i.e.,


pq
pq
F ∗ (u, v)I∪Juv = min →r (¬s (pI ), v Juv ), →r (¬s (pI ), q I )
pq
= min →r (1, v Juv ), 0.6
pq
= min v Juv , 0.6 ≥ 0.6.
pq

pq

pq

So v Juv ≥ 0.6. Since v Juv ≤ q I = 0.6, we conclude that v Juv = 0.6. However, this
contradicts the assumption that J <pq I. Therefore, such J does not exist, and I is a
0.6-stable model of F .
Example 3. p and ¬s ¬s p have the same fuzzy models, but their stable models are different. This is similar to the fact that p and ¬¬p have different stable models according
to the semantics from [5].
Clearly, any interpretation I = {(p, y)}, where y is any positive real number in
[0, 1], is a y-stable model of p relative to {p}. On the other hand, I = {(p, y)} is not a
y-stable model of F = ¬s ¬s p relative to {p}. Formula F ∗ (q) is ¬s ¬s F , and although
I |=y F , we have I ∪ Jqp |=y F ∗ (q) regardless of any J.
Example 4. Let F1 = p →s p and F2 = ¬s p⊕m p. Their fuzzy models are the same, but
their stable models are not. This is similar to the relation between p → p and ¬p ∨ p in
the Boolean stable model semantics. Indeed, observe that F1∗ (q) = (p →s p) ⊗m (q →s q)
and F2∗ (q) = ¬s p ⊕m q.
The interpretation I = {(p, 1)} is not a 1-stable model of F1 relative to p, as witnessed by J = {(p, 0)}. However, I is a 1-stable model of F2 relative to p: for any Jqp ,




p
p
p
p
F2∗ (q)I∪Jq = max 1 − pI , q Jq = max 0, q Jq = q Jq .
p

So, for I ∪ Jqp to satisfy F2∗ (q) to degree 1, q Jq should be 1, or equivalently, pJ should
be 1. Consequently, it is not possible to have J <p I.
The following example illustrates how the commonsense law of inertia involving
fuzzy truth values can be represented.
Example 5. Let σ be {p, ∼p, q, ∼q} 4 and let F be F1 ⊗m F2 , where F1 represents that
p and ∼p are complementary, i.e., the sum of their truth values is 1:
F1 = ¬s (p⊗l ∼p) ⊗m ¬s ¬s (p⊕l ∼p).
4

Note that ∼ is not a connective; it is just a part of the symbol representing an atom.

Stable Models of Fuzzy Propositional Formulas

7

F2 represents that by default p has the truth value of q, and ∼p has the truth value of ∼q:
F2 = ((q ⊗m ¬s ¬s p) →r p) ⊗m ((∼q ⊗m ¬s ¬s ∼p) →r ∼p).
Let p = {p, ∼p} and u = {u, ∼u}. F ∗ (u) is
¬s (p⊗l ∼p) ⊗m ¬s ¬s (p⊕l ∼p)
⊗m ((q ⊗m ¬s ¬s p) →r u) ⊗m ((q ⊗m ¬s ¬s p) →r p)
⊗m ((∼q ⊗m ¬s ¬s ∼p) →r ∼u) ⊗m ((∼q ⊗m ¬s ¬s ∼p) →r ∼p).
One can check that the interpretation I1 = {(p, x), (∼p, 1 − x), (q, x), (∼q, 1 − x)}
(x is any value in [0, 1]) is a 1-stable model of F relative to (p, ∼p); The interpretation
I2 = {(p, y), (∼p, 1 − y), (q, x), (∼q, 1 − x)}, where y > x, is not. Similarly, if y < x,
I2 is not a 1-stable model of F relative to (p, ∼p).
On the other hand, if we conjoin F with y →r p to yield F ⊗m (y →r p), then the
default behavior is overridden, and I2 is a 1-stable model of F ⊗m (y →r p) relative to
(p, ∼p).
This behavior is useful in expressing the commonsense law of inertia involving
fuzzy values. Suppose q represents some fluent at time t, and p represents the fluent at
time t + 1. Then F states that, “by default, the fluent retains the previous value.” The
default value is overridden if there is an action that sets p to a different value.

4

Further Examples

The trust example in the introduction can be formalized in the fuzzy stable model semantics as follows. Below x, y, z are schematic variables ranging over people, and t is
a schematic variable ranging over time steps. Trust(x, y, t) is a fuzzy atom representing
that “x trusts y at time t.” Similarly, Distrust(x, y, t) is a fuzzy atom representing that
“x distrusts y at time t.”
The trust relation is reflexive:
F1 = Trust(x, x, t).
The trust and distrust degrees are complementary, i.e., their sum is 1 (similar to
Example 5):
F2 = ¬s (Trust(x, y, t) ⊗l Distrust(x, y, t)),
F3 = ¬s ¬s (Trust(x, y, t) ⊕l Distrust(x, y, t)).
Initially, if x trusts y to degree d1 and y trusts z to degree d2 , then x trusts z to
degree d1 × d2 ; further the initial distrust degree is 1 minus the initial trust degree.
F4 = Trust(x, y, 0) ⊗p Trust(y, z, 0) →r Trust(x, z, 0),
F5 = ¬s Trust(x, y, 0) →r Distrust(x, y, 0).
The inertia assumption (similar to Example 5):
F6 = Trust(x, y, t) ⊗m ¬s ¬s Trust(x, y, t+1) →r Trust(x, y, t+1),
F7 = Distrust(x, y, t) ⊗m ¬s ¬s Distrust(x, y, t+1) →r Distrust(x, y, t+1).

8

Joohyung Lee and Yi Wang

A conflict increases the distrust degree by the conflict degree:
F8 = Conflict(x, y, t) ⊕l Distrust(x, y, t) →r Distrust(x, y, t+1),
F9 = ¬s (Conflict(x, y, t) ⊕l Distrust(x, y, t)) →r Trust(x, y, t+1).
Let FT W be F1 ⊗m F2 ⊗m · · · ⊗m F9 . Suppose we have the formula FF act =
Fact1 ⊗m Fact2 that gives the initial trust degree.
Fact1 = 0.8 →r Trust(Alice, Bob, 0),
Fact2 = 0.7 →r Trust(Bob, Carol, 0).
Although there is no fact about how much Alice trusts Carol, any 1-stable model of
FT W ⊗m FF act assigns value 0.56 to the atom Trust(Alice, Carol, 0). On the other
hand, the 1-stable model assigns value 0 to Trust(Alice, David, 0) due to the closed
world assumption under the stable model semantics.
When we conjoin FT W ⊗ FF act with 0.2 → Conflict(Alice, Carol, 0), the 1-stable
model of FT W ⊗m FF act ⊗m (0.2 → Conflict(Alice, Carol, 0)), manifests that the
trust degree between Alice and Carol decreases to 0.36 at time 1. More generally, if we
have more actions that change the trust degree in various ways, by specifying the entire
history of actions, we can determine the evolution of the trust distribution among all
the participants. Useful decisions can be made based on this information. For example,
Alice may decide not to share her personal pictures to those whom she trusts less than
degree 0.48.
Note that this example, like Example 5, uses nested connectives, such as ¬s ¬s , that
are not available in previous fuzzy ASP semantics, such as [3, 4].

5

Relation to Boolean-Valued Stable Models

The Boolean stable model semantics in Section 2.1 can be embedded into the fuzzy
stable model semantics as follows:
For any classical propositional formula F , define F fuzzy to be the fuzzy propositional formula obtained from F by replacing ⊥ with 0, > with 1, ¬ with ¬s , ∧ with ⊗m ,
∨ with ⊕m , and → with →s . We identify the signature of F f uzzy with the signature
of F . Also, for any interpretation I, we define the corresponding fuzzy interpretation
I f uzzy as
– I fuzzy (p) = 1 if I(p) = TRUE;
– I fuzzy (p) = 0 otherwise.
The following theorem tells us that the Boolean-valued stable model semantics can
be viewed as a special case of the fuzzy stable model semantics.
Theorem 1 For any classical propositional formula F and any classical propositional
interpretation I, I is a stable model of F relative to p iff I fuzzy is a 1-stable model of
F f uzzy relative to p.
Example 6. Let F be the classical propositional formula ¬p → q. F has only one
stable model I = {q}. Clearly I fuzzy = {(p, 0), (q, 1)} is a 1-stable model of F fuzzy =
¬s p →s q.

Stable Models of Fuzzy Propositional Formulas

9

Theorem 1 does not hold for an arbitrary choice of operators, as illustrated by the
following example.
Example 7. Let F be the classical propositional formula p ∨ p. Classical interpretation
I = {p} is a stable model of F . However, I fuzzy = {(p, 1)} is not a stable model of
F 0 = p ⊕l p because there is J = {(p, 0.5)} such that I ∪ Jqp |=1 q ⊕l q.
However, one direction of Theorem 1 holds for arbitrary choice of fuzzy operators.
Theorem 2 For any classical propositional formula F , let F1fuzzy be the formula obtained from F by replacing ⊥ with 0, > with 1, ¬ with any fuzzy negation symbol, ∧
with any fuzzy conjunction symbol, ∨ with any fuzzy disjunction symbol, and → with
any fuzzy implication symbol. For any classical propositional interpretation I, if I fuzzy
is a 1-stable model of F1f uzzy relative to p, then I is a stable model of F relative to p.

6
6.1

Relation to Other Approaches to Fuzzy ASP
Relation to Stable Models of Normal FASP Programs

A normal FASP program is a finite set of rules of the form
a ← b1 ⊗ . . . ⊗ bm ⊗ ¬bm+1 ⊗ . . . ⊗ ¬bn ,
where n ≥ m ≥ 0, a, b1 , . . . , bn are fuzzy atoms or numeric constants in [0, 1], and ⊗
is any fuzzy conjunction. We identify the rule with the fuzzy implication
b1 ⊗ . . . ⊗ bm ⊗ ¬s bm+1 ⊗ . . . ⊗ ¬s bn →r a.
We say that a fuzzy interpretation I of signature σ satisfies a rule R if RI = 1. I
satisfies an FASP program Π if I |= R for every rule R in Π. According to [3], an
interpretation I is a fuzzy answer set of a normal FASP program Π if I satisfies Π,
and no interpretation J such that J <σ I satisfies the reduct of Π w.r.t. I, which is
the program obtained from Π by replacing each negative literal ¬b with the constant
for 1 − bI .
Theorem 3 For any normal FASP program Π = {r1 , . . . , rn }, let F be the formula
r1 ⊗m . . . ⊗m rn . An interpretation I is a fuzzy answer set of Π in the sense of [3] if
and only if I is a 1-stable model of F .
Example 8. Let Π be the following program
p ← ¬q,

q ← ¬p.

The answer sets of Π according to [3] are {(p, x), (q, 1 − x)}, where x is any value in
[0, 1]: the corresponding fuzzy formula F is (¬s q →r p) ⊗m (¬s p →r q); F ∗ (u, v) is
F ⊗m ((¬s q →r u) ⊗m (¬s p →r v)).
One can check that the 1-stable models of F are also {(p, x), (q, 1 − x)}, where x ∈
[0, 1].

10

Joohyung Lee and Yi Wang

6.2

Relation to Fuzzy Equilibrium Logic

Like our fuzzy stable model semantics, fuzzy equilibrium logic [6] generalizes fuzzy
ASP programs to arbitrary propositional formulas, but its definition is highly complex.
Nonetheless we show that if we disregard strong negation considered there, fuzzy equilibrium logic is essentially equivalent to the fuzzy stable model semantics where the
threshold is set to 1 and all atoms are subject to minimization.5
We review the definition of fuzzy equilibrium logic in the absence of strong negation. For any fuzzy propositional signature σ, a (fuzzy N5) valuation is a mapping from
{h, t} × σ to subintervals of [0, 1] such that V (t, a) ⊆ V (h, a) for each atom a ∈ σ. For
V (w, a) = [u, v], where w ∈ {h, t}, we write V − (w, a) to denote the lower bound u
and V + (w, a) to denote the upper bound v. The truth value of a formula under V is
defined as follows.
V (w, c) = [c, c] for any numeric constant c;
V (w, F ⊗ G) = [V − (w, F ) ⊗ V − (w, G), V + (w, F ) ⊗ V + (w, G)]; 6
V (w, F ⊕ G) = [V − (w, F ) ⊕ V − (w, G), V + (w, F ) ⊕ V + (w, G)];
V (h, ¬F ) = [1 − V − (t, F ), 1 − V − (h, F )];
V (t, ¬F ) = [1 − V − (t, F ), 1 − V − (t, F )];
V (h, F → G) = [min(V − (h, F ) → V − (h, G), V − (t, F ) → V − (t, G)),
V − (h, F ) → V + (h, G)];
−
−
−
– V (t, F → G) = [V (t, F ) → V (t, G), V (t, F ) → V + (t, G)].

–
–
–
–
–
–

A valuation V is a (fuzzy N5) model of a formula F if V − (h, F ) = 1, which
implies V + (h, F ) = V − (t, F ) = V + (t, F ) = 1. For two valuations V and V 0 , we say
V 0  V if V 0 (t, a) = V (t, a) and V (h, a) ⊆ V 0 (h, a) for all atoms a. We say V 0 ≺ V
if V 0  V and V 0 6= V . We say that a model V of F is h-minimal if there is no model
V 0 of F such that V 0 ≺ V . An h-minimal fuzzy N5 model V of F is a fuzzy equilibrium
model of F if V (h, a) = V (t, a) for all atoms a.
For two fuzzy interpretations I, J of signature
σ such that J ≤σ I, define the N5

fuzzy valuation VJ,I as VJ,I (h, a) = aJ , 1 , VJ,I (t, a) = aI , 1 for all atoms a in σ.
Since J ≤σ I, we have aJ ≤ aI , and VJ,I (t, a) ⊆ VJ,I (h, a) for all atoms a.
As in [6], we assume that the fuzzy negation ¬ is ¬s .
The following proposition relates the notions used in the fuzzy equilibrium models
and the fuzzy stable models.
Proposition 1 (a) I |=1 F if and only if VI,I is a model of F .
(b) For p = σ, I ∪ Jqp |=1 F ∗ (q) if and only if VJ,I is a model of F .
(c) For two interpretations I and J, we have VJ,I ≺ VI,I if and only if J < I.
The theorem below shows that the fuzzy stable model semantics can be reduced to
fuzzy equilibrium logic semantics.
Theorem 4 For any fuzzy formula F (that contains no strong negation) and any fuzzy
interpretation I, I is a 1-stable model of F if and only if VI,I is a fuzzy equilibrium
model of F .
5
6

Strong negation can be simulated in our semantics using new atoms as illustrated in Example 5.
For readability, we write the infix notation (x  y) in place of (x, y).

Stable Models of Fuzzy Propositional Formulas

11

Next we show the other direction, i.e., reducing fuzzy equilibrium logic to the fuzzy
stable model semantics. For any valuation V , define the fuzzy interpretation IV as
aIV = V − (h, a) for all atoms a.
Theorem 5 For any fuzzy formula F (that contains no strong negation) and any valuation V , we have that V is an equilibrium model of F if and only if
(i) V + (h, a) = V + (t, a) = 1 for all atoms a, and
(ii) IV is a 1-stable model of F relative to σ.
Theorem 5 tells us that in the absence of strong negation, the upper bounds of both
worlds in any equilibrium model are always 1.

7

Properties of Fuzzy Stable Models

In this section, we show that several well-known properties of the Boolean stable model
semantics can be naturally extended to the fuzzy stable model semantics.
7.1

Alternative Definition of F ∗

Proposition 2 For any fuzzy formula F and any fuzzy interpretations I, J with J ≤p I,
– I ∪ Jqp |=y ¬F ∗ (q) ⊗m ¬F iff I ∪ Jqp |=y ¬F .
– I ∪ Jqp |=y (F ∗ ⊗ G∗ )(q) ⊗m (F ⊗ G) iff I ∪ Jqp |=y (F ∗ ⊗ G∗ )(q).
– I ∪ Jqp |=y (F ∗ ⊕ G∗ )(q) ⊗m (F ⊕ G) iff I ∪ Jqp |=y (F ∗ ⊕ G∗ )(q).
This proposition tells us that F ∗ in Section 3 can be equivalently defined by treating
the fuzzy operators in the uniform way:
– (¬F )∗ = ¬F ∗ ⊗m ¬F ;
– (F  G)∗ = (F ∗  G∗ ) ⊗m (F  G) for any binary operator .
7.2

Theorem on Constraints

In answer set programming, constraints—rules with ⊥ in the head—play an important
role in view of the fact that adding a constraint eliminates the stable models that “violate” the constraint. The following theorem is the counterpart of Theorem 3 from [5]
for fuzzy propositional formulas.
Theorem 6 For any fuzzy formulas F and G, I is a 1-stable model of F ⊗ ¬G (relative
to p) if and only if I is a 1-stable model of F (relative to p) and I |=1 ¬G.
Example 9. Consider F = (¬s p →r q) ⊗m (¬s q →r p) ⊗m ¬s p. Formula F has
only one 1-stable model I = {(p, 0), (q, 1)}, which is the only 1-stable model of
(¬s p →r q) ⊗m (¬s q →r p) that satisfies ¬s p to degree 1.
If we consider a more general y-stable model, then only one direction holds.

12

Joohyung Lee and Yi Wang

Theorem 7 For any fuzzy formulas F and G, if I is a y-stable model of F ⊗ ¬G
(relative to p), then I is a y-stable model of F (relative to p) and I |=y ¬G.
Example 10. The other direction, that is, “if I is a y-stable model of F and I |=y ¬G,
then I is a y-stable model of F ⊗ ¬G,” does not hold in general. For example, consider
F = G = p and ⊗ to be ⊗l , and interpretation I = {(p, 0.4)}. Clearly I is a 0.4-stable
model of p and I |=0.4 ¬p, but I is not a 0.4-stable model of p ⊗l ¬p. In fact, I is not
even a 0.4-model of the formula.
7.3

Theorem on Choice Formulas

In the Boolean stable model semantics, formulas of the form p ∨ ¬p are called choice
formulas, and adding them to the program makes atoms p exempt from minimization. Choice formulas have been shown to be useful in composing a program in the
“Generate-and-Test” method. This section shows their counterpart in the fuzzy stable
model semantics.
For any fuzzy atom p, Choice(p) stands for p ⊕l ¬s p. For any list p = (p1 , . . . pn )
of fuzzy atoms, Choice(p) stands for
Choice(p1 ) ⊗ . . . ⊗ Choice(pn ),
where ⊗ is any fuzzy conjunction.
The following proposition tells that choice formulas are tautological.
Proposition 3 For any fuzzy interpretation I and any list p of fuzzy atoms, I |=1 Choice(p).
Theorem 8 is an extension of Theorem 2 from [5].
Theorem 8 (a) If I is a y-stable model of F relative to p ∪ q, then I is a y-stable
model of F relative to p.
(b) I is a 1-stable model of F relative to p iff I is a 1-stable model of F ⊗ Choice(q)
relative to p ∪ q.
Theorem 8 (b) does not hold for arbitrary threshold y (i.e., if “1−” is replaced with
“y−”). For example, consider F = ¬s ¬s q and I = {(q, 0.5)}. Clearly I is a 0.5-model
of F , and thus I is a 0.5-stable model of F relative to ∅. However, I is not a 0.5-stable
model of F ⊗m Choice(q) = ¬s ¬s q ⊗m (q ⊕l ¬s q) relative to ∅ ∪ {q}, as witnessed
by J = {(q, 0)}.
Since the 1-stable models of F relative to ∅ are the models of F , it follows from
Theorem 8 (b) that the 1-stable models of F ⊗ Choice(σ) relative to σ are exactly the
1-models of F .
Corollary 1 Let F be a formula of a finite signature σ. I is a 1-model of F relative
to σ iff I is a 1-stable model of F ⊗ Choice(σ).
Example 11. Consider the formula F = ¬s p →r q. Although any interpretation I that
satisfies 1 − pI ≤ q I is a 1-model of F , among them only {(p, 0), (q, 1)} is a 1-stable

Stable Models of Fuzzy Propositional Formulas

13

model of F . However, we check that all 1-models of F are exactly the 1-stable models
of G = F ⊗m Choice(p) ⊗m Choice(q): G∗ (u, v) is
(¬s p →r q) ⊗m (¬s p →r v) ⊗m (u ⊕l ¬s p) ⊗m (v ⊕l ¬s q)
pq
and for K = I ∪ Juv
,

G∗ (u, v)K = 1 ⊗m ((1 − pK ) →r v K ) ⊗m (uK ⊕l (1 − pK )) ⊗m (v K ⊕l (1 − q K )).
So, for K to satisfy G∗ (u, v) to degree 1, uK should be at least pK and v K should be at
pq
least q K . So there does not exist J <pq I such that I ∪ Juv
|=1 G∗ (u, v), from which
it follows that I is a 1-stable model of G.

8

Conclusion

We introduced a general stable model semantics for fuzzy propositional formulas, which
generalizes both the Boolean stable model semantics and fuzzy propositional logic. The
syntax is the same as the syntax of fuzzy propositional logic, but the semantics defines
stable models instead of models. The formalism allows highly configurable default reasoning involving fuzzy truth values. Our semantics, when we restrict threshold to be 1
and assume all atoms to be subject to minimization, is equivalent to fuzzy equilibrium
logic in the absence of strong negation, but is much more simpler. To the best of our
knowledge, our representation of commonsense law of inertia involving fuzzy values is
new. The representation uses nested fuzzy operators, which are not available in earlier
fuzzy ASP semantics for a restricted syntax.
We showed that several traditional results in answer set programming can be naturally extended to this formalism, and expect that more results can be carried over. Future
work includes implementing this language using mixed integer programming solvers or
bilevel programming solvers [7].
Acknowledgements We are grateful to Joseph Babb, Michael Bartholomew, Enrico
Marchioni, and the anonymous referees for their useful comments and discussions related to this paper. This work was partially supported by the National Science Foundation under Grant IIS-1319794 and by the South Korea IT R&D program MKE/KIAT
2010-TD-300404-001.

References
1. Lifschitz, V.: What is answer set programming? In: Proceedings of the AAAI Conference on
Artificial Intelligence, MIT Press (2008) 1594–1597
2. Hajek, P.: Mathematics of Fuzzy Logic. Kluwer (1998)
3. Lukasiewicz, T.: Fuzzy description logic programs under the answer set semantics for the
semantic web. In Eiter, T., Franconi, E., Hodgson, R., Stephens, S., eds.: RuleML, IEEE
Computer Society (2006) 89–96
4. Janssen, J., Vermeir, D., Schockaert, S., Cock, M.D.: Reducing fuzzy answer set programming
to model finding in fuzzy logics. TPLP 12(6) (2012) 811–842
5. Ferraris, P., Lee, J., Lifschitz, V.: Stable models and circumscription. Artificial Intelligence
175 (2011) 236–263
6. Schockaert, S., Janssen, J., Vermeir, D.: Fuzzy equilibrium logic: Declarative problem solving
in continuous domains. ACM Trans. Comput. Log. 13(4) (2012) 33
7. Alviano, M., Peñaloza, R.: Fuzzy answer sets approximations. TPLP 13(4-5) (2013) 753–767

Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence

Action Language BC+: Preliminary Report
Joseph Babb and Joohyung Lee
School of Computing, Informatics, and Decision Systems Engineering
Arizona State University
Tempe, AZ, 85287, USA
{Joseph.Babb,joolee}@asu.edu

Abstract

and the recurring pattern of ASP rules for representing transition systems. However, the existing work on action languages have two limitations. First, they do not allow many
useful ASP constructs, such as choice rules, aggregates, abstract constraint atoms, and external atoms, that have recently been introduced into ASP and have been shown to
be very useful. The inability to use these modern constructs
in action languages is what often prevents the users from
writing in action languages, and instead forces them to write
in the language of ASP directly.
Another issue is that even when we do not use such constructs, there are certain limitations that each action language has in comparison with another. For instance, in language B, the frame problem is solved by enforcing in the semantics that every fluent be governed by the commonsense
law of inertia, which makes it difficult to represent fluents
whose behavior is described by defaults other than inertia.
Languages C and C+ do not have this limitation, but instead
they do not handle Prolog-style recursive definitions, such
as transitive closure, available in B. The recently proposed
language BC (Lee, Lifschitz, and Yang 2013) combines the
attractive features of B and C+, but it is not a proper generalization. In comparison with C+, it does not allow us to
describe complex dependencies among actions, thus it is unable to describe several concepts that C+ is able to express
naturally, such as defeasible causal laws (Giunchiglia et al.
2004, Section 4.3) and action attributes (Giunchiglia et al.
2004, Section 5.6).
We present a simple solution to these problems. The main
idea is to define an action language in terms of a general
stable model semantics, which has not been considered in
the work of action languages. We present a new action language called BC+, which is defined as a high level notation
of propositional formulas under the stable model semantics
in (Ferraris 2005). It has been well studied in ASP that several useful constructs, such as aggregates, abstract constraint
atoms, and conditional literals, can be identified with abbreviations of propositional formulas (e.g.,(Ferraris 2005;
Pelov, Denecker, and Bruynooghe 2003; Son and Pontelli
2007; Harrison, Lifschitz, and Yang 2014)). Thus, BC+ employs such constructs as well. Further, it is more expressive
than the other action languages mentioned above, allowing
them to be easily embedded. The computation of BC+ is carried out by ASP solvers, which is implemented by modify-

Action languages are formal models of parts of natural language that are designed to describe effects of actions. Many
of these languages can be viewed as high level notations of
answer set programs structured to represent transition systems. However, the form of answer set programs considered
in the earlier work is quite limited in comparison with the
modern Answer Set Programming (ASP) language, which
allows several useful constructs for knowledge representation, such as choice rules, aggregates, and abstract constraint
atoms. We propose a new action language called BC+, which
closes the gap between action languages and the modern ASP
language. Language BC+ is defined as a high level notation
of propositional formulas under the stable model semantics.
Due to the generality of the underlying language, BC+ is expressive enough to encompass many modern ASP language
constructs and the best features of several other action languages, such as B, C, C+ and BC. Computational methods
available in ASP solvers are readily applicable to compute
BC+, which led us to implement the language by extending
system CPLUS 2 ASP.

Introduction
Action languages are formal models of parts of natural language that are used for describing properties of actions. The
semantics of action languages describe transition systems—
directed graphs whose vertices represent states and whose
edges represent actions that affect the states. Many action
languages, such as languages A (Gelfond and Lifschitz
1993) and B (Gelfond and Lifschitz 1998, Section 5), can
be viewed as high level notations of answer set programs
structured to represent transition systems. Languages C
(Giunchiglia and Lifschitz 1998) and C+ (Giunchiglia et
al. 2004) are originally defined in terms of nonmonotonic
causal theories, but their “definite” fragments can be equivalently turned into logic programs as well, leading to the implementation CPLUS 2 ASP, which uses ASP solvers for computation (Babb and Lee 2013).
The main advantage of using action languages over ASP
programs is their structured abstract representations for describing transition systems, which allows their users to focus
on high level descriptions and avoids the “cryptic” syntax
c 2015, Association for the Advancement of Artificial
Copyright 
Intelligence (www.aaai.org). All rights reserved.

1424

{c=2}

F1
is equivalent to >, for which the minimal model is
∅, not {c = 2}.
Let F2 be F1 conjoined with c = 2. Similarly, we can check
that the only stable model of F2 is {c = 2}. This illustrates
the nonmonotonicity of the semantics.
Note that the presence of double negations is essential
in (2). Without them, F1 would have three stable models:
{c = 1}, {c = 2}, and {c = 3}.
In ASP, formulas of the form F ∨ ¬F are called choice
formulas and denoted by {F }ch . For example, F1 above can
be written as {c = 1}ch ∧ UECσ . As shown in Example 1,
in the presence of UECσ , a formula of the form {c = v}ch
expresses that c has the value v by default, which can be
overridden in the presence of other evidence (Bartholomew
and Lee 2014).
Aggregates in ASP can be understood as shorthand for
propositional formulas as shown in (Ferraris 2005). For instance, the count aggregate expresion 2{p, q, r} is shorthand
for (p ∧ q) ∨ (q ∧ r) ∨ (p ∧ r).

ing system CPLUS 2 ASP (Babb and Lee 2013), which was
originally designed to compute C+ using ASP solvers.
The paper is organized as follows. We first review propositional formulas under the stable model semantics, and
how they express the concept of defaults in the presence
of uniqueness and existence of value constraints. Next we
present the syntax and the semantics of BC+, as well as
a useful fragment and abbreviations. We also show how
propositional formulas under the stable model semantics can
be viewed as a special case of BC+. Then we show how each
of BC and C+ can be embedded in BC+, and explain the advantages of BC+ over the two languages.

Preliminaries
According to (Ferraris 2005), stable models of a propositional formula are defined as follows. The reduct F X of a
propositional formula F relative to a set X of atoms is the
formula obtained from F by replacing every maximal subformula that is not satisfied by X with ⊥. Set X is called a
stable model of F if X is a minimal set of atoms satisfying
F X . It has been shown that logic programs can be identified
with propositional formulas under the stable model semantics in the form of conjunctions of implications.
Throughout this paper, we consider propositional formulas whose signature σ consists of atoms of the form c = v, 1
where c is called a constant and is associated with a finite
set Dom(c) of cardinality ≥ 2, called the domain, and v is
an element of its domain. If the domain of c is {f, t} then
we say that c is Boolean; we abbreviate c = t as c and c = f
as ∼c.
Bartholomew and Lee [2014] show that this form of
propositional formulas is useful to express the concept of
default values on multi-valued fluents. By UECσ (“Uniqueness and Existence Constraint”) we denote the conjunction
of
^
¬(c = v ∧ c = w),
(1)

Syntax of BC+
The syntax of language BC+ is similar to the syntax of C+.
The following description repeats the syntax description in
Section 4.2 from (Giunchiglia et al. 2004). In language BC+,
constants are divided into two groups: fluent constants and
action constants. Fluent constants are further divided into
regular and statically determined.
A fluent formula is a formula such that all constants occurring in it are fluent constants. An action formula is a formula that contains at least one action constant and no fluent
constants.
A static law is an expression of the form
caused F if G
(3)
where F and G are fluent formulas. An action dynamic law
is an expression of the form (3) in which F is an action formula and G is a formula. A fluent dynamic law is an expression of the form
caused F if G after H
(4)
where F and G are fluent formulas and H is a formula,
provided that F does not contain statically determined constants. Static laws can be used to talk about causal dependencies between fluents in the same state; action dynamic laws
can be used to express causal dependencies between concurrently executed actions; fluent dynamic laws can be used for
describing direct effects of actions.
A causal law is a static law, an action dynamic law, or a
fluent dynamic law. An action description is a finite set of
causal laws.
The formula F in each of causal laws (3) and (4) is called
the head of the causal law.

v6=w : v,w∈Dom(c)

and

¬¬

_

c=v.

(2)

v∈Dom(c)

for all constants c of σ. It is clear that an interpretation of
σ that satisfies UECσ can be identified with a function that
maps each constant c into an element in its domain.
Example 1 Consider a signature σ to be {c = 1, c = 2, c =
3}, where c is a constant and Dom(c) = {1, 2, 3}. UECσ is
¬(c = 1 ∧ c = 2) ∧ ¬(c = 2 ∧ c = 3) ∧ ¬(c = 1 ∧ c = 3)
∧ ¬¬(c = 1 ∨ c = 2 ∨ c = 3).
Let F1 be (c = 1 ∨ ¬(c = 1)) ∧ UECσ . Due to UECσ , each
of {c = 1}, {c = 2}, and {c = 3} is a model of F1 , but
{c = 1} is the only stable model of F1 .2 This is because the
{c=1}
reduct F1
is equivalent to c = 1, for which {c = 1} is the
minimal model. On the other hand, for instance, the reduct

Semantics of BC+
For any action description D, we define a sequence of propositional formulas PF0 (D), PF1 (D), . . . so that the stable
models of PFm (D) represent paths of length m in the transition system corresponding to D. The signature σD,m of
PFm (D) has the constants i : c such that

1

Note that c = v is an atom in the propositional signature, and
not an equality in first-order logic.
2
We identify an interpretation with the set of atoms that are true
in it.

1425

(0 ≤ i < m), the second and the third lines into
{i : a}ch ,

{i :∼a}ch

(10)

(0 ≤ i < m), and the fourth and the fifth lines into
{i+1 : p}ch ← i : p,

{i+1 :∼p}ch ← i :∼p
(11)

(0 ≤ i < m). In addition,

Figure 1: The transition system described by SD.

{0 : p}ch ,

• i ∈ {0, . . . , m} and c is a fluent constant of D, and
• i ∈ {0, . . . , m−1} and c is an action constant of D.
The domain of i : c is the same as the domain of c. By i : F we
denote the result of inserting i : in front of every occurrence
of every constant in formula F . The translation PFm (D) is
the conjunction of
•
i:F ← i:G
(5)
for every static law (3) in D and every i ∈ {0, . . . , m},
and (5) for every action dynamic law (3) in D and every i ∈ {0, . . . , m−1};3
•
i+1 : F ← (i+1 : G) ∧ (i : H)
(6)
for every fluent dynamic law (4) in D and every i ∈
{0, . . . , m−1};
•
{0 : c = v}ch
(7)
for every regular fluent constant c and every v ∈ Dom(c);
• UECσD,m , which can also be abbreviated using the count
aggregate as the conjunction of
← ¬ 1{i : c = v1 , . . . , i : c = vm }1

come from (7), and
← ¬ 1{i : p, i :∼p}1
← ¬ 1{i : a, i :∼a}1

(0 ≤ i ≤ m),
(0 ≤ i < m)

come from (8).
For every stable model X of PF0 (D), the set of fluent formulas c = v such that 0 : c = v belongs to X is a state of D.
In view of the uniqueness and existence of value constraints,
for every state s and every fluent constant c, there is exactly
one v such that c = v belongs to s.
For every stable model X of PF1 (D), D includes the transition hs0 , e, s1 i, where si (i = 0, 1) is the set of fluent formulas c = v such that i : c = v belongs to X, and e is the set
of action formulas c = v such that 0 : c = v belongs to X.
The soundness of this definition is guaranteed by the following fact:
Theorem 1 For every transition hs0 , e, s1 i, s0 and s1 are
states.
The stable models of PFm (D) represent the paths of
length m in the transition system corresponding to D. For
m = 0 and m = 1, this is clear from the definition of a
transition system; for m > 1 this needs to be verified as the
following theorem shows.
For every set X of elements of the signature σD,m , let X i
(i < m) be the triple consisting of
• the set consisting of atoms A such that i : A belongs to X,
and A contains fluent constants,
• the set consisting of atoms A such that i : A belongs to X,
and A contains action constants, and
• the set consisting of atoms A such that (i + 1) : A belongs
to X, and A contains fluent constants.

(8)

for every i : c in σD,m and every v1 , . . . , vm in Dom(i : c).
Note how the translation PFm (D) treats regular and statically determined fluent constants in different ways: formulas (7) are included only when c is regular. Statically determined fluents are useful for describing defined fluents,
whose value is determined by the fluents in the same state
only. We refer the reader to (Giunchiglia et al. 2004, Section 5) for more details.
As an example, the transition system shown in Figure 1
can be described by the following action description SD,
where p is a Boolean regular fluent constant and a is a
Boolean action constant.
caused p if > after a,
caused {a}ch ,
caused {∼a}ch ,
(9)
caused {p}ch if > after p,
caused {∼p}ch if > after ∼p,

Theorem 2 For every m ≥ 1, X is a stable model of
PFm (D) iff X 0 , . . . , X m−1 are transitions.
For example, {0 :∼p, 0 :∼a, 1 :∼p, 1 : a, 2 : p} is a stable
model of PF2 (SD), and each of h∼p, ∼a, ∼pi and h∼p, a, pi
is a transition of SD.

Useful Abbreviations
Like C+, several intuitive abbreviations of causal laws can
be defined for BC+. Expression “default c = v if F ” stands
for “caused {c = v}ch if F .”4 This abbreviation is intuitive
in view of the reading of choice formulas in the presence of
uniqueness and existence of value constraints we introduced
earlier (recall Example 1). Similarly,

The translation PFm (SD) turns this description into the
following propositional formulas. The first line of (9) is
turned into the formulas
i+1 : p ← i : a
3

{0 :∼p}ch

default c = v if F after G
4

We identify F ← G with G → F .

1426

Here and after, we often omit if F if F is >.

stands for “caused {c = v}ch if F after G.”
Other abbreviations of BC+ causal laws are defined similarly as in C+.

2009). We illustrate this advantage by formalizing an elaboration of the Blocks World from (Lee, Lifschitz, and Yang
2013) by a simple BC+ description.
Let Blocks be a non-empty finite set of symbols (block
names) that does not include the symbol Table. The action
description below uses the following fluent and action constants:
• for each B ∈ Blocks, regular fluent constant Loc(B)
(“Location”) with the domain Blocks ∪ {Table}, and statically determined Boolean fluent constant InTower(B);
• for each B ∈ Blocks, Boolean action constant Move(B);
• for each B ∈ Blocks, action constant Dest(B) (“Destination”) with the domain Blocks ∪ {Table} ∪ {None}, where
None is an auxiliary symbol for an “undefined” value.
In the list of static and dynamic laws below, B, B1 and B2
are arbitrary elements of Blocks, and L is an arbitrary element of Blocks ∪ {Table}.
Blocks are not on itself:
constraint Loc(B) 6= B.
The definition of InTower(B):
caused InTower(B) if Loc(B) = Table,
caused InTower(B) if Loc(B) = B1 ∧ InTower(B1 ),
default ∼InTower(B).
Blocks don’t float in the air:
constraint InTower(B).
No two blocks are on the same block:
constraint {b : Loc(b) = B}1.
Only k towers are allowed to be on the table (k is a positive
integer):
constraint {b : Loc(b) = Table}k.
The effect of moving a block:
Move(B) causes Loc(B) = L if Dest(B) = L
A block cannot be moved unless it is clear:
nonexecutable Move(B) if Loc(B1 ) = B.
Concurrent actions are limited by the number g of grippers:
always {b : Move(b)}g.
The commonsense law of inertia:
inertial Loc(B).
Actions are exogenous:
exogenous Move(B),
exogenous Dest(B).
Dest is an attribute of Move:
always Dest(B) = None ↔ ¬Move(B).
Besides the inability to represent aggregates, other action languages have difficulties in representing this example. Languages C and C+ do not allow us to represent the
recursive definition of InTower. Languages B and BC do not
allow us to represent action attributes like Dest. (The usefulness of attributes in expressing elaboration tolerance was
discussed in (Lifschitz 2000).)
In the following two sections, we compare BC+ with BC
and C+.

• If c is a Boolean action constant, we express that F is an
effect of executing c by “c causes F ,” which stands for
the fluent dynamic law “caused F if > after c.”
• If c is an action constant, the expression “exogenous c”
stands for the action dynamic laws “default c = v” for all
v ∈ Dom(c).
• If c is a regular fluent constant, the expression
“inertial c” stands for the fluent dynamic laws
“default c = v after c = v” for all v ∈ Dom(c).
• “constraint F ” where F is a fluent formula stands for the
static law “caused ⊥ if ¬F .”
• “always F ” stands for the fluent dynamic law
“caused ⊥ if > after ¬F .”
• “nonexecutable F if G” stands for the fluent dynamic
law “caused ⊥ if > after F ∧ G.”

Embedding Formulas under SM in BC+
We defined the semantics of BC+ by reducing the language
to propositional formulas under the stable model semantics.
The reduction in the opposite direction is also possible.
Any propositional formula F under the stable model semantics can be turned into an action description in BC+ by
treating every atom of F as a statically determined fluent
constant with Boolean values, rewriting F as the static law
“caused F ,” and adding “default c = f” for every constant c.
Proposition 1 The stable models of a propositional formula F are exactly the states of the transition system described by the BC+ description obtained from F by the
above translation.
It is known that the problem of determining the existence
of stable models of propositional formulas is ΣP
2 -complete
(Ferraris 2005). The same complexity applies to BC+ in
view of Proposition 1. On the other hand, from the translation PF m (D), a useful fragment in NP can be defined based
on the known results in ASP. The following is an instance.
We say that action description D is definite if the head
of every causal law is either ⊥, an atom c = v, or a choice
formula {c = v}ch . We say that a formula is a simple conjunction if it is a conjunction of atoms and count aggregates,
each of which may be preceded by negation.
A simple action description is a definite action description
such that G in every causal law (3) is a simple conjunction,
and G and H in every causal law (4) are simple conjunctions. The next section presents an example of a simple action description.

Example: Blocks World
An attractive feature of BC+ is that aggregates (or more
generally, abstract constraints) are directly usable in causal
laws because they are understood as abbreviations of propositional formulas (Ferraris 2005; Pelov, Denecker, and
Bruynooghe 2003; Son and Pontelli 2007; Lee and Meng

1427

Relation to Language BC

Embedding BC in BC+
Despite the syntactic differences, language BC can be easily embedded in BC+ as follows. For any BC description D,
we define the translation bc2bcp(D), which turns a BC description into an equivalent BC+ description as follows:
• replace every causal law (12) with

Review: BC
The signature σ for a BC description D is defined the same
as in BC+ except that every action constant is assumed to be
Boolean. The main syntactic difference between BC causal
laws and BC+ causal laws is that the former allows only the
conjunction of atoms in the body, and distinguishes between
if and if cons clauses.
A BC static law is an expression of the form
A0 if A1 , . . . , Am if cons Am+1 , . . . , An

caused A0 if A1 ∧ · · · ∧ Am ∧ ¬¬Am+1 ∧ · · · ∧ ¬¬An ;
(16)
• replace every causal law (13) with

(12)

caused A0 if ¬¬Am+1 ∧· · ·∧¬¬An after A1 ∧· · ·∧Am ;

(n ≥ m ≥ 0), where each Ai is an atom containing a fluent
constant. It expresses, informally speaking, that every state
satisfies A0 if it satisfies A1 , . . . , Am , and Am+1 , . . . , An
can be consistently assumed.
A BC dynamic law is an expression of the form
A0 after A1 , . . . , Am if cons Am+1 , . . . , An

• add the causal laws “exogenous a” for every action constant a.
Theorem 3 For any action description D in language BC,
the transition system described by D is identical to the transition system described by the description bc2bcp(D) in
language BC+.

(13)

(n ≥ m ≥ 0), where (i) A0 is an atom containing a regular
fluent constant, (ii) each of A1 , . . . , Am is an atom containing a fluent constant, or a = t where a is an action constant,
and (iii) Am+1 , . . . , An are atoms containing fluent constants. It expresses, informally speaking, that the end state of
any transition satisfies A0 if its beginning state and its action
satisfy A1 , . . . , Am , and Am+1 , . . . , An can be consistently
assumed about the end state.
An action description in language BC is a finite set consisting of BC static and BC dynamic laws.
The semantics of BC is defined by using reduction PFBC
m
to a sequence of logic programs under the stable model semantics. The signature σD,m of PFBC
m is defined the same as
that of PFm defined in Section “Semantics of BC+.”
For any BC action description D, by PFBC
m (D) we denote
the conjunction of
•

Advantages of BC+ over BC
In BC, every action is assumed to be Boolean, and action
dynamic laws are not available. This prevents us from describing defeasible causal laws (Giunchiglia et al. 2004, Section 4.3) and action attributes (Giunchiglia et al. 2004, Section 5.6), which BC+ and C+ are able to express naturally.
Also, syntactically, BC is not expressive enough to describe
dependencies among actions. For a simple example, in BC+
we can express that action a1 is not executable when a2 is
not executed at the same time by the fluent dynamic law
caused ⊥ after a1 ∧ ¬a2 ,
but this not syntactically allowed in BC.
On the other hand, the presence of choice formulas in the
head of BC+ causal laws and the different treatment of A
and ¬¬A in the bodies may look subtle to those who are not
familiar with the stable model semantics for propositional
formulas. Fortunately, in many cases one can hide these constructs by using the default proposition in BC+ as the following example illustrates.
Consider the leaking container example from (Lee, Lifschitz, and Yang 2013) in which a container loses k units of
liquid by default. This example was used in that paper to illustrate the advantages of BC over B that is able to express
defaults other than inertia. In this domain, the default decrease of Amount over time can be represented in BC+ using
the default proposition

i : A0 ← i : (A1 ∧ · · · ∧ Am ∧ ¬¬Am+1 ∧ · · · ∧ ¬¬An )
(14)
for every BC static law (12) in D and every i ∈
{0, . . . , m};
•
(i + 1) : A0 ← i : (A1 ∧ · · · ∧ Am )∧
(i+1) : (¬¬Am+1 ∧ · · · ∧ ¬¬An )
(15)
for every BC dynamic law (13) in D and every i ∈
{0, . . . , m−1};
• the formula i : (a = t ∨ a = f) for every action constant a
and every i ∈ {0, . . . , m−1};
• the formula (7) for every regular fluent constant c and every element v ∈ Dom(c);
• the formulas (1) and (2) for every constant i : c in σD,m .
Note how the translations (14) and (15) treat if and ifcons
clauses differently by either prepending double negations in
front of atoms or not. In BC+, only one if clause is enough
since the formulas are understood under the stable model
semantics.

default Amount = x after Amount = x+k,

(17)

which stands for fluent dynamic law
caused {Amount = x}ch after Amount = x+k,
which can be further turned into propositional formulas
{i+1 : Amount = x}ch ← i : Amount = x+k

(18)

(i < m). On the other hand, the abbreviation (17) in BC
stands for the causal law
caused Amount = x after Amount = x+k if cons Amount = x,

1428

Notation: s, s0 ranges over {Switch1 , Switch2 };
x, y ranges over {Up, Dn}.
Regular fluent constants:
Domains:
Status(s)
{Up, Dn}
Action constants:
Domains:
Flip(s)
Boolean

semantics does not work in C+ as defined in (Giunchiglia et
al. 2004), which is based on nonmonotonic causal theories.
The embedding of C+ in BC+ tells us that if clauses always introduce double negations, whose presence do not
necessarily lead to minimal models. This accounts for the
fact that the definite fragment of C+ does not handle the concept of transitive closure correctly. The inability to consider
minimal models in such cases introduce some unintuitive behavior of C+ in representing causal dependencies among fluents.
Consider two switches which can be flipped but cannot be
both up or down at the same time. If one of them is down and
the other is up, the direct effect of flipping only one switch
is changing the status of that switch, and the indirect effect
is changing the status of the other switch. This domain can
be represented in BC+ as shown in Figure 2.
The description in BC+ has the following four transitions possible from the initial state where Switch1 is Dn and
Switch2 is Up:

Causal laws:
Flip(s) causes Status(s) = x if Status(s) = y
(x 6= y)
caused Status(s) = x if Status(s0 ) = y
(s 6= s0 , x 6= y)
inertial Status(s)
exogenous Flip(s)
Figure 2: Two Switches
which is further turned into
i+1 : Amount = x ← i : Amount = x+k ∧ ¬¬(i+1 : Amount = x)

(i < m), which is strongly equivalent to (18).
Our experience is that, in most cases, instead of remembering the subtle difference between if and if cons clauses
in BC, it is more intuitive to use the default proposition in
BC+.

h{St(Sw1 ) = Dn, St(Sw2 ) = Up},
{∼Flip(Sw1 ), ∼Flip(Sw2 )}, {St(Sw1 ) = Dn, St(Sw2 ) = Up}i,
h{St(Sw1 ) = Dn, St(Sw2 ) = Up},
{Flip(Sw1 ), ∼Flip(Sw2 )}, {St(Sw1 ) = Up, St(Sw2 ) = Dn}i,
h{St(Sw1 ) = Dn, St(Sw2 ) = Up},
{∼Flip(Sw1 ), Flip(Sw2 )}, {St(Sw1 ) = Up, St(Sw2 ) = Dn}i,

Relation to C+

h{St(Sw1 ) = Dn, St(Sw2 ) = Up},
{Flip(Sw1 ), Flip(Sw2 )}, {St(Sw1 ) = Up, St(Sw2 ) = Dn}i.

Due to the space limitation, we refer the reader
to (Giunchiglia et al. 2004) for the review of C+. The syntax
of C+ has the same form of causal laws as BC+.

The second and the third transitions exhibit the indirect
effect of the action Flip. If this description is understood in
C+, five transitions are possible from the same initial state:
in addition to the four transitions above,

Embedding Definite C+ in BC+
We say that C+ action description D is definite if the head of
every causal law is either ⊥ or an atom c = v. For any definite
C+ description D, we define the translation cp2bcp(D),
which turns a C+ description into BC+, as follows:

h{St(Sw1 ) = Dn, St(Sw2 ) = Up},
{∼Flip(Sw1 ), ∼Flip(Sw2 )}, {St(Sw1 ) = Up, St(Sw2 ) = Dn}i

is also a transition because, according to the semantics of C+,
this is causally explained by the cyclic causality. Obviously,
this is unintuitive.

• replace every C+ causal law (3) with
caused F if ¬¬G;

Conclusion

• replace every C+ causal law (4) with

We implemented language BC+ by modifying system
CPLUS 2 ASP (Babb and Lee 2013), which was originally designed to compute the definite fragment of C+ using ASP
solvers. As the translation PFC+
m (D) for C+ is similar to the
translation PFm (D) for BC+, modifying this translation to
accept BC+ input is straightforward.
Besides the action languages considered in this paper, language K (Eiter et al. 2004) is also defined via ASP. Since K
assumes knowledge-states, it is not directly comparable to
BC+ which assumes world-states.
A further extension of BC+ is possible. It is straightforward to extend BC+ to the first-order level, by using the firstorder stable model semantics from (Ferraris, Lee, and Lifschitz 2011) or its extension with generalized quantifiers (Lee
and Meng 2012) in place of propositional formulas. This
will allow BC+ to include more general constructs, such as
constraint atoms, external atoms, nonmonotonic dl-atoms,
as they are instances of generalized quantifiers as shown
in (Lee and Meng 2012).

caused F if ¬¬G after H.
The following theorem asserts the correctness of this
translation.
Theorem 4 For any definite action description D in language C+, the transition system described by D is identical to the transition system described by the description
cp2bcp(D) in language BC+.

Advantages of BC+ over C+
Recall that the syntax of BC+ is identical to the syntax of C+,
but its semantics is given via the stable model semantics. An
advantage of this approach is that it allows the advances in
ASP directly usable in the context of action languages. We
already observed that being able to use aggregates in BC+
provides a succinct representation of the Blocks World domain. However, the expansion of choice formulas and aggregates into propositional formulas as in the stable model

1429

Acknowledgements
We are grateful to Michael
Bartholomew, Vladimir Lifschitz, and the anonymous
referees for their useful comments. This work was partially
supported by the National Science Foundation under Grant
IIS-1319794 and by the South Korea IT R&D program
MKE/KIAT 2010-TD-300404-001, and the Brain Pool
Korea program.

Lifschitz, V. 2000. Missionaries and cannibals in the
Causal Calculator. In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR), 85–96.
Pelov, N.; Denecker, M.; and Bruynooghe, M. 2003. Translation of aggregate programs to normal logic programs. In
Proceedings Answer Set Programming.
Son, T. C., and Pontelli, E. 2007. A constructive semantic
characterization of aggregates in answer set programming.
TPLP 7(3):355–375.

References
Babb, J., and Lee, J. 2013. Cplus2ASP: Computing action
language C+ in answer set programming. In Proceedings of
International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 122–134.
Bartholomew, M., and Lee, J. 2014. Stable models of multivalued formulas: partial vs. total functions. In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR), 583–586.
Eiter, T.; Faber, W.; Leone, N.; Pfeifer, G.; and Polleres, A.
2004. A logic programming approach to knowledge-state
planning: Semantics and complexity. ACM Trans. Comput.
Log. 206–263.
Ferraris, P.; Lee, J.; and Lifschitz, V. 2011. Stable models
and circumscription. Artificial Intelligence 175:236–263.
Ferraris, P. 2005. Answer sets for propositional theories. In
Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 119–131.
Gelfond, M., and Lifschitz, V. 1993. Representing action
and change by logic programs. Journal of Logic Programming 17:301–322.
Gelfond, M., and Lifschitz, V. 1998. Action languages.5
Electronic Transactions on Artificial Intelligence 3:195–
210.
Giunchiglia, E., and Lifschitz, V. 1998. An action language
based on causal explanation: Preliminary report. In Proceedings of National Conference on Artificial Intelligence
(AAAI), 623–630. AAAI Press.
Giunchiglia, E.; Lee, J.; Lifschitz, V.; McCain, N.; and
Turner, H. 2004. Nonmonotonic causal theories. Artificial
Intelligence 153(1–2):49–104.
Harrison, A. J.; Lifschitz, V.; and Yang, F. 2014. The semantics of gringo and infinitary propositional formulas. In Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference, KR.
Lee, J., and Meng, Y. 2009. On reductive semantics of aggregates in answer set programming. In Procedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), 182–195.
Lee, J., and Meng, Y. 2012. Stable models of formulas
with generalized quantifiers.6 In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).
Lee, J.; Lifschitz, V.; and Yang, F. 2013. Action language
BC: Preliminary report. In Proceedings of International
Joint Conference on Artificial Intelligence (IJCAI).
5
6

http://www.ep.liu.se/ea/cis/1998/016/
http://peace.eas.asu.edu/joolee/papers/smgq-nmr.pdf

1430

A Model-Theoretic Counterpart of Loop Formulas
Joohyung Lee
Department of Computer Sciences
The University of Texas at Austin
Austin, TX 78712, USA
appsmurf@cs.utexas.edu
Abstract
In an important recent paper, Lin and Zhao introduced the concept of a loop formula, and showed
that the answer sets for a logic program are exactly
the models of Clark’s completion of the program
that satisfy the loop formulas. Just as supported sets
are a model-theoretic account of completion, “externally supported” sets, defined in this paper, are a
model-theoretic counterpart of loop formulas. This
reformulation of loop formulas shows that they are
related to assumption sets (Saccá and Zaniolo) and
to unfounded sets (Van Gelder, Ross and Schlipf;
Leone, Rullo and Scarcello), invented many years
earlier. Other contributions of this paper includes a
simplification of the definition of a loop, extending
it to programs with classical negation and infinite
programs, and a generalization of the definition of
a loop formula.

1 Introduction
The completion semantics [Clark, 1978] and the answer set
semantics (also known as the stable model semantics) [Gelfond and Lifschitz, 1988] are two well-known proposals for
defining the meaning of negation as failure in logic programs.1 The former is attractive because it is simply a translation from logic programs to classical logic, but it sometimes
gives unintuitive results [Przymusinski, 1989, Section 4.1]. It
is well known that an answer set for a logic program is also a
model of its completion, while the converse, generally, does
not hold.
By adding so-called “loop formulas” to completion, Lin
and Zhao [2004] defined a set of formulas whose models are
exactly the answer sets. The idea comes from observing that
“loops” are related to the mismatch between the models of
the completion and the answer sets. Intuitively, every atom
in an answer set can be “derived” from a program in a finite
number of steps. The atoms in a loop that are not “supported
from outside” cannot be derived in a finite number of steps,
but they do not contradict the completion of the program.
1

As the answer set semantics is usually defined for propositional
(grounded) logic programs only, in this paper we limit our attention to such programs, and refer to the propositional case of Clark’s
completion.

The Lin/Zhao theorem allows us to compute answer sets
using SAT solvers, which has led to the implementation of
SAT-based answer set solvers ASSAT2 [Lin and Zhao, 2004]
and CMODELS3 [Giunchiglia et al., 2004]. These systems
turn a logic program into a propositional theory and then call
SAT solvers, such as CHAFF, SATO and RELSAT, to find its
models, which in turn correspond to the answer sets. Thanks
to recent progress with SAT solvers, in several benchmark
examples they found answer sets faster than other answer set
solvers such as SMODELS4 and DLV5 .
A program that has no loops is called “tight,” and for tight
programs the completion semantics and the answer set semantics are equivalent to each other. This fact was discovered earlier by Fages [1994], and then was generalized and
extended by Erdem and Lifschitz [2003] to programs with
nested expressions (in the sense of [Lifschitz et al., 1999]) in
the bodies of rules.
Lee and Lifschitz [2003] showed that program completion,
loop formulas and the Lin/Zhao theorem can be extended to
disjunctive logic programs and, more generally, to arbitrary
programs with nested expressions. As a consequence, the
concept of a tight program and Fages’ theorem are extended
to disjunctive programs as well.
Yet the previous work on loop formulas has been limited
to finite programs without classical negation. In this paper,
we lift these limitations. First, to account for programs that
allow classical negation, we propose a model-theoretic counterpart of loop formulas—the concept of an “externally supported” set. It is similar to the model-theoretic counterpart
of Clark’s completion—the concept of a supported set introduced in [Apt et al., 1988]. Interestingly, this reformulation of loop formulas shows that they are related to assumption sets [Saccá and Zaniolo, 1990] and to unfounded sets
[Van Gelder et al., 1991; Leone et al., 1997] invented many
years earlier. Second, we extend the concept of a loop formula to programs with nested expressions. Finally, we extend the notion of a loop and the theorem on loop formulas to
infinite programs.
In the next section we introduce the concept of an exter2

http://assat.cs.ust.hk/ .
http://www.cs.utexas.edu/users/tag/cmodels/ .
4
http://www.tcs.hut.fi/Software/smodels/ .
5
http://www.dbai.tuwien.ac.at/proj/dlv/ .
3

nally supported set, extend the notion of a loop to infinite
programs, state our main theorem, and discuss its relation to
Fages’ theorem about tight programs. In Section 3 we use the
main theorem to define two transformations turning a logic
program into an equivalent propositional theory. In Section 4,
we relate externally supported sets to assumption sets and to
unfounded sets, and compare our reformulation of loop formulas with the original definition by Lin and Zhao. The main
theorem is generalized to arbitrary programs with nested expressions in Section 5.

2 Externally Supported Sets
2.1

2

l ; : : : ; lm ;

not lm+1 ; : : : ; not ln

(1)

(1  m  n) where all li are literals. We will often write (1)
in the form
l1
B; F
(2)
where B is l2 ; : : : ; lm , and F is not lm+1 ; : : : ; not ln , and we
will sometimes identify B with the set fl2 ; : : : ; lm g.
A nondisjunctive (logic) program is a set of rules of the
form (1).
We say that a set X of literals satisfies the body B; F of
rule (2) (symbolically X j= B; F ) if l2 ; : : : ; lm 2 X , and
lm+1 ; : : : ; ln 2
= X . We say that X satisfies a nondisjunctive
program  (symbolically X j= ) if, for every rule (2) of
that program, l1 2 X whenever X satisfies B; F .
The reduct X of a nondisjunctive program  with respect to a set X of literals is obtained from  by deleting
each rule (2) such that X 6j= F , and replacing each remaining
rule (2) by l1
B . A consistent set X of literals is an answer set for  if X is minimal among the sets of literals that
satisfy X .
We say that a set Y of literals is supported by  w.r.t. a
set X of literals if there is a rule (2) in  such that l1 2 Y ,
and X j= B; F . Informally, such a rule (2) characterizes a
source of support for the literal l1 in Y .7
Now we make the notion of a supported set slightly
stronger. We will say that a set Y of literals is externally
supported by  w.r.t. X if there is a rule (2) in  such that
l1 2 Y , X j= B; F , and B \ Y = ;. Informally, the new,
third condition ensures that the support for the literal l1 in Y
comes from outside of Y .
6

Here we do not allow inconsistent answer sets.
One may notice that this definition is slightly different from the
usual definition of a supported set, which says that a set X of literals
is supported by  if, for every literal l1 X , there is a rule (2) in 
such that X = B; F [Apt et al., 1988]. It is clear that our definition
is more general: X is supported by  under the usual definition iff
every singleton subset of X is supported by  w.r.t. X under the
new definition.
7

j

r

Figure 1: The dependency graph of 2

For example, consider the following program 1 :
p

q

q

p

Each of the sets fpg and fq g is externally supported (hence
also supported) by 1 w.r.t. fp; q g, while fp; q g is supported
but not externally supported by 1 w.r.t. fp; q g. On the other
hand, let 2 be the following program that adds two rules
to 1 :
p

Nondisjunctive Case

1

q

q

q

p

not r
r
not p:
Then every nonempty subset of fp; q g is externally supported
by 2 w.r.t. fp; q g.
The positive dependency graph of  is the directed graph
such that
 its vertices are the literals occurring in , and
 its edges go from l1 to l2 ; : : : lm for each rule (1) of .
When  is finite, a nonempty set L of literals is called a
loop of  if, for every pair l1 , l2 of literals in L, there exists a
path from l1 to l2 in the positive dependency graph of  such
that all vertices in this path belong to L.8 In other words, a
nonempty set L of literals is a loop of  iff the subgraph of
the positive dependency graph of  induced by L is strongly
connected. Note that, for every literal l that occurs in , the
singleton set flg is a loop, according to this definition.9
The positive dependency graph of 2 , shown in Figure 1,
has four loops: fpg,fq g,frg,fp; q g.
Main Theorem for Finite Nondisjunctive Programs For
any finite nondisjunctive program  and any consistent set X
of literals, the following conditions are equivalent:
(a) X is an answer set for .
(b) X satisfies , and every set of literals that has a common
element with X is externally supported by  w.r.t. X .
(
) X satisfies , and every loop of  that is contained in X
is externally supported by  w.r.t. X .
Out of the three implications (a) to (b), (b) to (
), (
) to
(a), the second is obvious, because every loop that is contained in X has a common element with X . Program 2
above has two answer sets: fp; q g and frg. Since (a) implies
(b), it follows that every set of atoms that has a common element with fp; q g is externally supported w.r.t. fp; q g, and
every set of atoms that has a common element with frg is
externally supported w.r.t. frg. On the other hand, since (
)
implies (a), to show that fp; q g is an answer set we only need
to check that every loop which is a subset of fp; q g (that is,
each of fpg, fq g, fp; q g) is externally supported w.r.t. fp; q g.
Similarly, to show that frg is an answer set, we only need to
check that frg is externally supported w.r.t. frg.
p

We begin with a review of the answer set semantics for
nondisjunctive programs given in [Gelfond and Lifschitz,
1991, Section 2]. 6 The words atom and literal are understood here as in propositional logic; we call the negation sign
: in negative literals classical negation, to distinguish it from
the symbol for negation as failure (not).
A nondisjunctive rule is an expression of the form
l

p

2

Note that we do allow paths of length 0.
Thus our definition is slightly different from the definition by
Lin and Zhao (See Section 4 for detail). The example of a singleton
loop shows that a loop of  does not necessarily correspond to a
loop (or cycle) of the positive dependency graph of  in the sense
of graph theory.
8

9

The equivalence between (a) and (b) is a generalization of
a theorem from [Saccá and Zaniolo, 1990] as we will discuss
in Section 4.1, and the equivalence between (a) and (
) is a
model-theoretic account of loop formulas as we will discuss
in Section 3.

2.2

Extension to Programs in Canonical Form

We will extend the main theorem to finite programs with
nested expressions [Lifschitz et al., 1999]. In this section, for
simplicity, instead of arbitrary rules with nested expressions,
we consider rules of the form
l1 ; : : : ; lk
lk+1 ; : : : ; lm ; not lm+1 ; : : : ; not ln ;
(3)
not not ln+1 ; : : : ; not not lp

(0  k  m  n  p) where all li are literals.10 We will call
such rules canonical, and will often write (3) in the form
A
B; F
(4)
where A is l1 ; : : : ; lk , B is lk+1 ; : : : ; lm , and F is
not lm+1 ; : : : ; not ln ; not not ln+1 ; : : : ; not not lp :
We will sometimes identify A with the set fl1 ; : : : ; lk g and B
with the set flk+1 ; : : : ; lm g.
A canonical program is a set of rules of the form (3).
The definition of satisfaction given in Section 2.1 is extended to canonical programs as follows. We say that
a set X of literals satisfies the body B; F of rule (4) if
lk+1 ; : : : ; lm 2 X , lm+1 ; : : : ; ln 2
= X , and ln+1 ; : : : ; lp 2 X .
X satisfies a program if, for every rule (4) of that program,
at least one of the literals in A belongs to X whenever X
satisfies B; F .
The reduct X of a canonical program  with respect to a
set X of literals is obtained from  by deleting each rule (4)
such that X 6j= F , and replacing each remaining rule (4) by
A
B . A consistent set X of literals is an answer set for 
if X is minimal among the sets of literals that satisfy X .
Given a canonical program  and a set X of literals, we
will say that a set Y of literals is externally supported by 
w.r.t. X if there is a rule (4) in  such that A \ Y =
6 ;,
X j= B; F , B \ Y = ;, and X \ (A n Y ) = ;. The last
condition is suggested by the extension of the definition of a
supported set to disjunctive programs proposed in [Baral and
Gelfond, 1994] and [Inoue and Sakama, 1998].
The definition of a positive dependency graph is extended
to the general case straightforwardly: for each rule (3) in ,
the edges of the graph go from each literal li (0 < i  k )
to each literal lj (k < j  m). The definition of a loop from
Section 2.1 remains the same for arbitrary finite programs.
The theorem from Section 2.1 remains true if we replace
“nondisjunctive” in its statement with “canonical.”
For example, let 3 be the program
p ; s
q
q
p
p ; r
not s;
which has two answer sets: fp; q g and frg. The comments
about these answer sets at the end of Section 2.2 apply to
program 3 as well.
10

Any program with nested expressions can be turned into an
equivalent program whose rules have the form (3), or equivalently
l1 ; : : : ; lk ; not ln+1 ; : : : ; not lp
lk+1 ; : : : ; lm ; not lm+1 ; : : : ; not ln
[Lifschitz et al., 1999, Proposition 6 (iii)]. In Section 5, the main
theorem is extended to arbitrary rules with nested expressions.

2.3

Extension to Infinite Programs

So far we restricted our attention to finite programs only. Indeed, unless we modify the definition of a loop, the theorem
in Section 2.1 does not hold for infinite programs: conditions
(a) and (b) are equivalent to each other even for infinite programs, but condition (
) turns out weaker than the others. For
example, consider the following infinite program 4 :
pi

+1

pi

(

i >

0)

;

where each pi is an atom. The program has no loops (in the
sense of Section 2.1) other than singletons. Besides ;, which
is the only answer set for 4 , there is one more set that satisfies condition (
): fp1 ; p2 ; : : : g.
Looking at the example, we observe that condition (
) is
weaker than condition (b) in that it does not account for infinite paths in the positive dependency graph which do not
correspond to loops, while condition (b) tells us that the sets
that correspond to such infinite paths should also be externally supported. We propose to modify the definition of a
loop as follows.
Given a (possibly infinite) program  and a set L of literals, we say that L is unbounded if, for every literal l 2 L,
there exists an infinite path in L in the positive dependency
graph of  that starts from l and does not visit the same vertex more than once. A nonempty set L of literals is called a
loop of  if L is unbounded, or for every pair l1 , l2 of literals
in L, there exists a path from l1 to l2 in the positive dependency graph of  such that all vertices in this path belong
to L. When  is finite, no set of literals that occur in  is unbounded, so that this definition of a loop reduces to the earlier
definition.
In program 4 above, every set fpi ; pi+1 ; : : : g (i > 0) is
a loop according to this definition, since it is unbounded. But
it is not externally supported by 4 w.r.t. fp1 ; p2 ; : : : g.
The theorem from Section 2.1 remains true if we replace
“finite nondisjunctive” with “canonical”:

2.4

Tight Programs

The notion of a loop helps us simplify the definition of a
“tight” program [Erdem and Lifschitz, 2003]. Let  be any
canonical program. We will say that a loop of  is trivial if
the loop consists of a single literal such that the positive dependency graph of  does not contain an edge from the literal
to itself. For example, in program 4 above, every singleton
loop is trivial, while every loop fpi ; pi+1 ; : : : g (i > 0) is not.
We say that  is absolutely tight if every loop of  is trivial.
Let X be the set of rules of  whose heads and bodies are
satisfied by X . Program  is tight on a set X of literals if the
subgraph of the positive dependency graph of X induced
by X has no loops other than trivial ones. These definitions
are more general than the corresponding definitions in [Lee
and Lifschitz, 2003] in that they are applicable to infinite programs and to programs with classical negation as well. We
get the following corollaries to the main theorem, which generalizes Propositions 2 and 4 from [Lee and Lifschitz, 2003].
Corollary 1 For any absolutely tight canonical program 
and any consistent set X of literals, X is an answer set for 
iff X satisfies  and X is supported by .

Corollary 2 For any canonical program  and any consistent set X of literals such that  is tight on X , X is an answer
set for  iff X satisfies  and X is supported by .

3 Translating Logic Programs into
Propositional Logic
In application to finite programs without classical negation,
conditions (b) and (
) of the main theorem suggest ways to
turn a program into an equivalent propositional theory. This
translation is closely related to the Lin/Zhao theorem on loop
formulas, as we will see in Section 4.
Consider a finite program  whose rules have the form (4)
where all li are atoms. For any set Y of atoms, the external
support formula for Y is the disjunction of the conjunctions
B

^F ^

^

2n

p

:p

(5)

A Y

6 ;, and B \ Y = ;.
for all rules (4) of  such that A \ Y =
We will denote the external support formula by ES;Y .
Condition (b) of the main theorem suggests the propositional theory Tb () which consists of
(i) the implications 11
^F A

B

(6)

for all rules (4) in , and
W
the implications p2Y p  ES;Y for all sets Y of
atoms that occur in .
On the other hand, condition (
) of the main theorem suggests the propositional theory T
 (), which consists of
(i) the implications (6) for all rules (4) in , and
(ii) the implications

( )
ii

^

2

p

p

 ES;L

(7)

L

for all loops L of .
Formula (7) is called the conjunctive loop formula of L.
Corollary 3 For any finite program  without classical
negation and any set X of atoms, X is an answer set for  iff
X is a model of Tb () iff X is a model of T
 ().
Note that the number of loops is exponential in the worst
case. But we cannot do much about this: Lifschitz and
Razborov [2004] showed that any equivalent translation from
logic programs to propositional formulas involves a significant increase in size assuming a conjecture from the theory
of computational complexity which is widely believed to be
true.

4 Unfounded Sets and Disjunctive Loop
Formulas

Since conditions (b) and (
) in the statement of the main theorem are equivalent to each other, any intermediate condition
between the two also characterizes answer sets. In this section, we study two such conditions related to some earlier
work.
11

:

^

_

We identify ‘not’ with ‘ ’, ‘;’ with ‘ ’, and ‘;’ with ‘ ’.

4.1

Relation to Unfounded Sets

The first condition is

()
d

satisfies , and every nonempty subset of X is externally supported by  w.r.t. X .

X

Since (b) implies (d), (d) implies (
), and (a),(b),(
) are
equivalent to each other, it is clear that all these conditions
are equivalent to each other.
In fact, the equivalence between conditions (a) and (d) was
established before for the special case when the rules of the
program have the form (3) with p = n. It is related to the notion of an unfounded set originally introduced in [Van Gelder
et al., 1991] to characterize negative conclusions under the
well-founded semantics. Saccá and Zaniolo [1990] showed
that answer sets for a nondisjunctive program can be characterized in terms of unfounded sets.12 Leone et al. [1997]
extended the notion of an unfounded set and the theorem
by Saccá and Zaniolo to disjunctive programs.
Their definition can be further extended to programs with
rules of the form (4) as follows. A set Y of literals is unfounded by a program  w.r.t. a set X of literals if, for each
rule (4) in  such that A \ Y =
6 ;, at least one of the following
conditions holds: X 6j= B; F , B \ Y =
6 ;, or X \ (A n Y ) =
6 ;.
It is easy to see that Y is not unfounded w.r.t. X iff Y is
externally supported w.r.t. X in the sense of Section 2.2.
A set X of literals is called unfounded-free if it does not
have any nonempty subset that is unfounded w.r.t. X . The
equivalence between conditions (a) and (d) stated above can
be reformulated as follows: X is an answer set for  iff X
satisfies  and X is unfounded-free. This is a generalization of Corollary 2 from [Saccá and Zaniolo, 1990] and Theorem 4.6 from [Leone et al., 1997] to programs with rules of
the form (3).
For finite programs  without classical negation, condition (d) suggests the following translation Td into propositional logic, which consists of

()
( )
i

ii

the implications (6) for all rules (4) in , and

the implications (7) for all nonempty sets L of atoms that
occur in .

Note that Td () is a superset of T
 (). In (ii), L is not
empty. If it were, then the implication would be unsatisfiable.
Corollary 4 For any finite program without classical negation, a set of atoms is an answer set for  iff it is a model
of Td ().

4.2

Relation to Disjunctive Loop Formulas

Here is another condition intermediate between (b) and (
):

()
e

satisfies , and, for every loop L  X , every set of
literals that has a common element with L is externally
supported by  w.r.t. X .

X

Given a finite program  whose rules have the form (4)
where all li are atoms, the propositional theory Te () consists of
12

Their theorem refers to “assumption sets” rather than “unfounded sets.” But as the authors noted, the two notions coincide
as far as the theorem is concerned.

()
( )
i

ii

the implications (6) for all rules (4) in , and
the implications

_

2

p

 ES;L

p

5 Loop Formulas for Programs with Nested
Expressions
(8)

L

for all loops L of .
Formula (8) is called the disjunctive loop formula of L.
Corollary 5 For any finite program  without classical
negation, a set of atoms is an answer set for  iff it is a model
of Te ().
In fact, if  is nondisjunctive, (8) is essentially the loop
formula defined by Lin and Zhao [2004]. In the rest of this
section, we give a more precise description of the relationship
between this special case of Corollary 5 and the Lin/Zhao
theorem.
Note first that when  is nondisjunctive, Te () consists of
(i) the implications
B ^ F  l1
(9)
for all rules (2) in , and
(ii) the implications

_

2

p

p

_



2

l1

L

l1

\2=;

B

^ F:

(10)

B;F

L; B

L

for all loops L of .
We now review the Lin/Zhao theorem. The completion of
the same program , Comp(), consists of the equivalences

_

1

l

l1

B;F

2

B

^F

for all atoms l1 that occur in .
By LF() we denote the set of the disjunctive loop formulas (10) for all non-trivial loops L.
Theorem 1 [Lin and Zhao, 2004, Theorem 1] For any finite nondisjunctive program  without classical negation,
a set of atoms is an answer set for  iff it is a model of
Comp() [ LF ().
To see why Comp() [ LF() is equivalent to Te (), observe first that Comp() can be rewritten as the set of implications “right-to-left”



_

l1

B;F

2

B

^F

_

and “left-to-right”

1

l

l1

B;F

2



B

 l1 ;

^ F:

(11)

(12)

Implications (11) can be further broken into implications (9).
In implications (12), every singleton set fl1 g is a loop. If the
loop is non-trivial, then LF () contains the corresponding
implication (10), which is stronger than (12). Consequently,
in the presence of LF (), implications (12) for all non-trivial
loops fl1 g can be dropped. On the other hand, if fl1 g is
trivial, then l1 2
= B , so that (12) coincides with (10) (where
L = fl1 g). To sum up, Comp() [ LF () can be equivalently
rewritten as the set consisting of formulas (9), formulas (10)
for trivial loops, and formulas (10) for non-trivial loops (they
form LF ()). This set is exactly Te ().

Lifschitz et al.[1999] extended the answer set semantics to
programs with nested expressions. “Formulas” defined in that
paper allow negation as failure (not), conjunction (;) and disjunction (;) to be nested arbitrarily. A program with nested
expressions is a set of rules of which both heads and bodies
are formulas. The following program 5 , for instance, is a
program with nested expressions which is not in canonical
form because the first rule has a disjunction in its body.
p

q

; not

r

q

p

r

not p:

For the semantics of such programs, along with the definition of satisfaction, we refer the reader to Section 2
of [Erdoğan and Lifschitz, 2004]. Recall that an occurrence
of a formula F in a formula G is singular if the symbol before
this occurrence is :; otherwise, the occurrence is regular [Lifschitz et al., 1999]. For any formula G, by poslit(G) we denote the set of all literals having a regular occurrence in G
that is not in the scope of negation as failure. For instance,
poslit(p; not q; (not not r; :s)) = fp; :sg.
For a set Y of literals, by F?Y we denote the formula obtained from a formula F by replacing all regular occurrences
of literals from Y that are not in the scope of negation as failure with ?; by Y? we denote the program obtained from a
program  by the same substitution. In application to canonical programs, this operation is closely related to the concept
of external support:

Proposition 1 Let  be a canonical program, and X a set of
literals satisfying . For any set Y of literals, Y is externally
supported by  w.r.t. X iff X does not satisfy Y? .

For example, for program 2 in Section 2.1 we checked
that fp; q g is externally supported w.r.t. fp; q g. On the other
fp;qg is
hand, the program (2 )?

?

?

?

not r

r

not p;

and we can check that fp; q g does not satisfy the program, in
accordance with Proposition 1.
Proposition 1 shows that the main theorem in Section 2.3
can be stated without mentioning external support: in conditions (b) and (
), we can replace “Y is externally supported
by  w.r.t. X ” with “X does not satisfy Y? .” This fact can
be used to generalize the main theorem to arbitrary programs.
First we need to generalize the definition of a positive dependency graph to programs with nested expressions. The
positive dependency graph of a program  with nested expressions is the directed graph G such that
 its vertices are the literals occurring in , and
 its edges go from each literal in poslit(Head) to each
Body of .
literal in poslit(Body) for each rule Head
If  is canonical, this definition reduces to the earlier definition. The positive dependency graph of 5 is the same as
the positive dependency graph of 2 as shown in Figure 1.
Once we define a positive dependency graph, the definition
of a loop given in Section 2.3 remains the same for programs
with nested expressions.

Main Theorem For any program  with nested expressions
and any consistent set X of literals, the following conditions
are equivalent:

()
()
a

X

b

X

()


is an answer set for .

satisfies , and, for every set Y of literals that has a
common element with X , X does not satisfy Y? .
satisfies , and, for every loop L of
tained in X , X does not satisfy L
?.

X

 that is con-

The translations Tb through Te can be extended to finite programs  with nested expressions that do not contain classical negation. For instance, the extended theory
Tb () consists of (i) the implications Body  Head for
Body in , and (ii) the implications
all rules Head
W
Y
for
p  :
? all sets Y of atoms that occur in .
p2Y

6 Conclusion
The following are the main contributions of this paper:

 We reformulated the definition of a loop formula so that
loop formulas became a generalization of completion.
 We generalized the definition of a loop formula and the
Lin/Zhao theorem to programs with nested expressions,
not necessarily finite.
 We presented a model-theoretic account of loop
formulas—the concept of an externally supported set—
and showed that loop formulas are related to assumption
sets and to unfounded sets.
It is interesting to note that the computational methods used
in DLV and in SAT-based answer set solvers are related to
each other, in view of our main theorem: DLV uses condition (d) [Leone et al., 1997, Theorem 4.6] for finding answer
sets for disjunctive programs, and ASSAT and CMODELS use
condition (e) for nondisjunctive programs.

Acknowledgements
I am grateful to Vladimir Lifschitz and Fangzhen Lin for
many useful discussions. Vladimir helped me develop the
idea and improve the presentation significantly. I am also
grateful to anonymous referees for their comments. Wolfgang Faber suggested that there may be a relationship between loop formulas and unfounded sets. Nicola Leone gave
pointers to earlier work on unfounded sets and on assumption
sets. This work was partially supported by NSF under Grant
IIS-0412907.

References
[Apt et al., 1988] Krzysztof Apt, Howard Blair, and Adrian
Walker. Towards a theory of declarative knowledge. In
Jack Minker, editor, Foundations of Deductive Databases
and Logic Programming, pages 89–148. Morgan Kaufmann, San Mateo, CA, 1988.
[Baral and Gelfond, 1994] Chitta Baral and Michael Gelfond. Logic programming and knowledge representation.
Journal of Logic Programming, 19,20:73–148, 1994.

[Clark, 1978] Keith Clark. Negation as failure. In Herve
Gallaire and Jack Minker, editors, Logic and Data Bases,
pages 293–322. Plenum Press, New York, 1978.
[Erdem and Lifschitz, 2003] Esra Erdem and Vladimir Lifschitz. Tight logic programs. Theory and Practice of Logic
Programming, 3:499–518, 2003.
[Erdoğan and Lifschitz, 2004] Selim Erdoğan and Vladimir
Lifschitz. Definitions in answer set programming. In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), pages 114–
126, 2004.
[Fages, 1994] François Fages. Consistency of Clark’s completion and existence of stable models. Journal of Methods
of Logic in Computer Science, 1:51–60, 1994.
[Gelfond and Lifschitz, 1988] Michael
Gelfond
and
Vladimir Lifschitz. The stable model semantics for
logic programming. In Robert Kowalski and Kenneth
Bowen, editors, Proceedings of International Logic Programming Conference and Symposium, pages 1070–1080,
1988.
[Gelfond and Lifschitz, 1991] Michael
Gelfond
and
Vladimir Lifschitz. Classical negation in logic programs and disjunctive databases.
New Generation
Computing, 9:365–385, 1991.
[Giunchiglia et al., 2004] Enrico Giunchiglia, Yuliya Lierler, and Marco Maratea. SAT-based answer set programming. In Proc. AAAI-04, pages 61–66, 2004.
[Inoue and Sakama, 1998] Katsumi Inoue and Chiaki
Sakama. Negation as failure in the head. Journal of Logic
Programming, 35:39–78, 1998.
[Lee and Lifschitz, 2003] Joohyung Lee and Vladimir Lifschitz. Loop formulas for disjunctive logic programs. In
Proc. ICLP-03, pages 451–465, 2003.
[Leone et al., 1997] Nicola Leone, Pasquale Rullo, and
Francesco Scarcello. Disjunctive stable models: Unfounded sets, fixpoint semantics, and computation. Information and Computation, 135(2):69–112, 1997.
[Lifschitz and Razborov, 2004] Vladimir Lifschitz and
Alexander Razborov. Why are there so many loop
formulas? ACM Transactions on Computational Logic,
2004. To appear.
[Lifschitz et al., 1999] Vladimir Lifschitz, Lappoon R. Tang,
and Hudson Turner. Nested expressions in logic programs.
Annals of Mathematics and Artificial Intelligence, 25:369–
389, 1999.
[Lin and Zhao, 2004] Fangzhen Lin and Yuting Zhao. ASSAT: Computing answer sets of a logic program by SAT
solvers. Artificial Intelligence, 157:115–137, 2004.
[Przymusinski, 1989] Teodor Przymusinski. On the declarative and procedural semantics of logic programs. Journal
of Automated Reasoning, 5:167–205, 1989.
[Saccá and Zaniolo, 1990] Domenico Saccá and Carlo Zaniolo. Stable models and non-determinism in logic programs with negation. In Proceedings of Symposium on
Principles of Database Systems (PODS), pages 205–217,
1990.
[Van Gelder et al., 1991] Allen Van Gelder, Kenneth Ross,
and John Schlipf. The well-founded semantics for general
logic programs. Journal of ACM, 38(3):620–650, 1991.


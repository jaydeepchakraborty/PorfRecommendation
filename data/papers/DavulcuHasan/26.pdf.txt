See	discussions,	stats,	and	author	profiles	for	this	publication	at:	https://www.researchgate.net/publication/251795842

Functional	√¨AJAX√Æ	in	Secure	Synchronous
Programming
Article

CITATIONS

READS

0

17

2	authors,	including:
Ramesh	Bharadwaj
United	States	Naval	Research	Laboratory
60	PUBLICATIONS			1,058	CITATIONS			
SEE	PROFILE

All	content	following	this	page	was	uploaded	by	Ramesh	Bharadwaj	on	09	March	2014.
The	user	has	requested	enhancement	of	the	downloaded	file.	All	in-text	references	underlined	in	blue	are	added	to	the	original	document
and	are	linked	to	publications	on	ResearchGate,	letting	you	access	and	read	them	immediately.

Functional ‚ÄúAJAX‚Äù in Secure Synchronous Programming
Ramesh Bharadwaj

Center for High Assurance Computer Systems
Naval Research Laboratory
4555 Overlook Avenue
Washington, District of Columbia 20375-5337

ramesh@itd.nrl.navy.mil

Supratik Mukhopadhyay

Department of Computer Science
West Virginia University
Morgantown, West Virginia 26506-6109

supratik@csee.wvu.edu

ABSTRACT

1. INTRODUCTION

AJAX (Asynchronous Javascript and XML) is a combination of
technologies aimed at supporting an improved user/application interactivity in the context of web-based service-oriented computing.
Based on the XMLHttpRequest API, AJAX provides an engine for
handling service invocations asynchronously while interacting with
other applications/users in the foreground. The AJAX combination
of technologies have already been deployed in popular applications
like Google Maps. The adherence to XML-based format for data
exchange makes this combination of technologies and similar other
frameworks suitable for deployment in service-oriented architectures based on lightweight services (REST or Web) augmenting
existing architectures with increased capabilities of interaction.
While AJAX promises improved interaction capabilities, it is
also accompanied by its baggage of problems. The lack of formal
semantics makes it difficult to understand and validate the functionalities that an application is supposed to provide. The support for
individual component technologies of AJAX (e.g., XMLHttpRequest, Javascript etc.) are different for different infrastructures (and
browsers). The adoption of Javascript (an interpreted scripting language) makes it inefficient for running heavyweight processes. Besides, the source code must be downloaded by the client for execution which raises concerns in security and intellectual property
issues. These problems render the existing AJAX framework unsuitable for deployment in mission-critical enterprise applications.
In this paper, we present an ‚ÄúAJAX‚Äù-like framework in an eventdriven secure synchronous programming environment. More precisely, we present a synchronous programming programming language called SOL (Secure Operations Language) that has capabilities for handling service invocations asynchronously, strong typing (including dynamic) to ensure enforcement of information flow
and security policies and the ability to deal with failures (both benign and byzantine) of components. While our framework provides
‚ÄúAJAX‚Äù-like functionalities in a synchronous programming environment, unlike AJAX, it is not a combination of disparate technologies. As opposed to the AJAX framework, it is supported by
formal operational semantics. Applications written in our framework can be verified using formal static checking techniques like
theorem proving. The framework runs on the top of the SINS
(Secure Infrastructure for Networked Systems) infrastructure developed at the Naval Research Laboratory.

Service-oriented architectures (SOAs) [23] are becoming more
and more common as platforms for implementing large scale distributed applications. In an SOA, applications are built by combining services, which are platform independent components running on different hosts of a network. They are now being deployed in mission-critical applications that include space, healthcare, electronic commerce, and military. Client requests are met
by on-demand discovery of a set of suitable services which, when
appropriately composed, will satisfy the client‚Äôs service requirements. Delivery of services to clients is governed by service level
agreements (SLAs) which additionally specify the quality of service (QoS) that the service provider needs to guarantee and the
appropriate penalties for their violation. QoS constraints that a
service provider guarantees may include security, timeliness, and
availability. Such guarantees are difficult to satisfy when services
are spatially distributed over a network which is subject to active
attacks, network congestion, and link delays. Such attacks and failures, coupled with the need for migration of services and clients,
poses a formidable challenge in delivering services that meet the
SLAs.
SOA‚Äôs typically are characterized by the high level of interactivity between applications (i.e., between services, brokers, and
clients) and users. AJAX [12] (Asynchronous Javascript and XML)
is a combination of technologies aimed at supporting an improved
user/application interaction in the context of web-based serviceoriented computing (or more generally development of web applications). Based on the XMLHttpRequest API, AJAX provides
an engine for handling service invocations asynchronously while
interacting with other applications/users in the foreground. The
AJAX combination of technologies have already been deployed in
popular applications like Google Maps. The adherence to XMLbased format for data exchange makes this combination of technologies and similar other frameworks suitable for deployment in
service-oriented architectures (using a web browser as a client interface) based on lightweight services (REST [15] or Web) augmenting existing architectures with increased capabilities of interaction.
While AJAX promises improved interaction capabilities, it does
come with its baggage of problems. The lack of formal semantics makes it difficult to understand and validate the functionalities that an application is supposed to provide. The support for
individual component technologies of AJAX (e.g., XMLHttpRequest, Javascript etc: XML Namespaces are not well supported
by Internet Explorer) are different for different infrastructures (and
browsers). The adoption of Javascript (an interpreted scripting language) makes it inefficient for running heavyweight processes. Besides, the source code must be downloaded by the client for exe-

Keywords
AJAX, SOA
Copyright is held by the author/owner(s).
WWW2006, May 22‚Äì26, 2006, Edinburgh, UK.
.

cution which raises concerns in security and intellectual property
issues. These problems render the existing AJAX framework unsuitable for deployment in mission-critical enterprise applications
where formal guarantees with respect to functionalities and security
are of utmost importance.
In this paper, we present an ‚ÄúAJAX‚Äù-like framework in an eventdriven synchronous programming [4] environment (a‚Äô la‚Äô LUSTRE
[17], SCR [8], and Esterel [5]). More precisely, we present a synchronous programming language SOL (Secure Operations Language)
that has capabilities of handling service invocations asynchronously,
provides strong typing to ensure enforcement of information flow
and security policies, and has the ability to deal with failures (both
benign and byzantine) of components. In the synchronous programming paradigm, the programmer is provided with an abstraction that respects the synchrony hypothesis, i.e., one may assume
that an external event is processed completely by the system before the arrival of the next event. One might wonder how a synchronous programming paradigm can be effective for dealing with
widely distributed systems where there is inherent asynchrony. The
answer may seem surprising to some, but perfectly reasonable to
others: We have shown elsewhere [10] that under certain sufficient
conditions (which are preserved in our case) the synchronous semantics of a SOL application are preserved when it is deployed on
an asynchronous, distributed infrastructure. While our framework
provides ‚ÄúAJAX‚Äù-like functionalities in a (functional) synchronous
programming environment, unlike AJAX, it is not a combination
of disparate technologies. As opposed to the AJAX framework, it
is supported by formal operational semantics. The individual modules follow a ‚Äúpublish-subscribe‚Äù pattern of interaction while asynchronous service invocations akin to the XMLHttpRequest (API)
are provided continuation-passing-based [3] semantics. The design
of SOL was heavily influenced by the design of SAL (the SCR
Abstract Language), a specification language based on the SCR
Formal Model [18]. Applications written in our framework can
be verified using formal static checking techniques like theorem
proving. We provide both a static and a dynamic type system to
ensure respectively (1) static type soundness and (2) to ensure runtime type soundness in the presence of third party (possibly COTS)
component services that may undergo reconfigurations at runtime
due to network faults or malicious attacks. The framework runs on
the top of the SINS (Secure Infrastructure for Networked Systems)
infrastructure developed at the Naval Research Laboratory. SINS
is built on the top of the Spread toolkit [1] which provides a high
performance virtual synchrony messaging service that is resilient to
network faults. A typical SINS system comprises SINS Virtual Machines (SVMs), running on multiple disparate hosts, each of which
is responsible for managing a set of modules on that host. SVMs
on a host communicate with SVMs on other hosts using the secure
group communication infrastructure of Spread. SINS provides the
required degree of trust for the modules, in addition to ensuring
compliance of modules with a set of requirements, including security policies.
The rest of the paper is organized as follows. Section 2 presents
related work. Section 3 provides a brief description of the SOL
language along with several illuminating examples. Section 4 provides a brief description of the SINS platform. Formal semantics
of SOL as well as a static type system are provided in Section 5.
Section 6 concludes the paper.

2.

RELATED WORK

Service-based systems (some times identified with web services
even though the scope of service-based systems is much broader)
have traditionally adopted document-oriented SOAP-based [23] mes-

saging for communicating XML data across a network. SOAP, by
default, is bound to the HTTP [11] transport layer. HTTP does not
provide any means of correlating requests with responses. SOAP
over HTTP provides a basic one-way synchronous communication
framework on the top of which other protocols like request/response
type RPC [11] can be implemented. SOAP and WSDL specifications are not executable; the protocol adopted by a particular application needs to be supported by the underlying runtime infrastructure. SOAP, as it is, does not support interaction patterns like
request/callback, publish/subscribe or asynchronous store and forward messaging. The definition of SOAP can be extended to provide such interaction patterns; such extensions require providing
new semantics to an existing system.
In contrast, our framework is based on the synchronous programming language SOL. In SOL, the message passing between modules (henceforth we will use the term agent for module instances)
is based on a (push) publish-subscribe. A module listens to those
‚Äúcontrolled variables‚Äù of another module that it ‚Äúsubscribes to‚Äù by
including them as its ‚Äúmonitored variables‚Äù. A module receives the
values of its monitored variables as input and computes a function
whose output can change the values of its controlled variables. Service invocations (both synchronous and asynchronous) needed to
compute the function are dealt uniformly using continuation passing. SOL agents run on the SINS platform which is built on the
top of the Spread toolkit that provides guaranteed message delivery
and resilience to network faults.
Traditionally, BPEL4WS [14] and semantic web-based frameworks (e.g., OWL-S) corresponding to business processes have been
used for describing, modeling and executing workflows for web
service-based systems. It is difficult in such frameworks to interoperate in networks involving sensors and other physical devices
having complex dynamical behavior, for continuously accessing information, monitoring the environment and reacting to changes in
it.
Both BPEL4WS and OWL-S [2] lack satisfactory formal operational semantics - while OWL-S specifications are assigned semantics based on first order logic, such axiomatic semantics are
not helpful in building a programming model with formal operational semantics. In particular, both BPEL4WS and OWL-S lack
a satisfactory programming model with formal semantics. Lack
of a proper programming model with formal operational semantics
makes it difficult to understand, predict and debug the behavior of
service compositions described in such languages. As a result it
is risky to deploy an application based on such a framework in a
mission-critical environment.
Both BPEL4WS and OWL-S do not provide an effective framework for modeling non-functional properties/QoS goals such as
security (policies), context-aware reconfiguration, time-deadlines,
availability, physical/logical migration of processes etc. Security
policies can be expressed in the BPEL4WS framework using external plug-ins like WS-Security. Embedding external plug-ins respecting different standards creates problems in interoperability.
We believe that security should be provided as an integral component of service-based systems in order to free application developers of security concerns.
Service-based systems executing workflows specified by BPEL4WS
(or OWL-S) processes do not provide any techniques for automatically reconfiguring a workflow dynamically in response to fast
changing contexts.
In our framework, workflows are expressed as a collection of
SOL modules with ‚Äúproper plumbing‚Äù to ensure desired coordination. As already stated above, the SOL language is supported by
formal operational semantics. Besides the event-driven publish-

subscribe-based interaction between the individual modules make
SOL ideal for programming service-based systems that are deployed
in networks involving sensors and other physical devices having
complex dynamical behavior. The SINS platform provides the required degree of trust for the modules, in addition to ensuring compliance of modules with a set of requirements, including security
policies. Dynamic reconfiguration of workflows can be obtained
using a ‚Äúhierarchical plumbing‚Äù a‚Äô la‚Äô [27].
AJAX provides an engine that acts as a client-side brokerage and
orchestration point for web services and provides support for the
XMLHttpRequest API, XSLT, DOM and Javascript. Calls to the
services are handled asynchronously using the XMLHttpRequest
API. Responses from the server are handled by Javascript code
running at the client end. AJAX can utilize the XML and XSL services available in browsers to provide a highly interactive interface
for web services. AJAX libraries are available for platforms such
as .NET. In our case, the SOL agents can be directly deployed on
the SINS platform that acts as a coordination point for the different
agents and the services. We have already outlined the shortcomings
of the conventional AJAX framework in the Introduction and have
also outlined how our framework ameliorates them. In [25], the
authors use a synchronous framework for globally asynchronous
designs. However, their framework is more suited to a hardware
design environment rather than a large scale distributed computing
one.
The nesC [16] programming language at U.C. Berkeley has been
designed for programming networked embedded systems. It supports asynchronous calls to components using events to signify the
completion of a call. In the polyphonic C [22] programming language, asynchronous method calls are supported using queues. A
set of methods at the server end defines a ‚Äúchord‚Äù. A method call is
delayed until all methods in the corresponding chord are invoked.
The communicating concurrent processes, the dominant paradigm
for distributed application development, has remained unchallenged
for almost 40 years. Not only is this model difficult to use for the
average developer, but in addition it fails as a paradigm for designing applications that must satisfy critical requirements such as
real-time guarantees [21]. Therefore, applications developed using conventional programming models are vulnerable to deadlocks,
livelocks, starvation, and synchronization errors. Moreover, such
applications are vulnerable to catastrophic failures in the event of
hardware or network malfunctions. Here we present an alternative
approach. We embed an ‚ÄúAJAX‚Äù-like framework in an event-driven
synchronous programming environment (a‚Äô la‚Äô LUSTRE [17], SIGNAL [17] SCR [8], and Esterel [5]). As opposed to other synchronous programming languages like ESTEREL, LUSTRE and
SIGNAL, SOL is a synchronous programming language for distributed applications.
Preliminary versions of SOL and SINS have been introduced
in [6, 7]. The current paper extends those versions by providing
asynchronous service-invocation management functionalities, type
systems for safe information down grading and secure information
flow. Besides, it provides operational semantics for the SOL language.

3.

SOL: THE SECURE OPERATIONS LANGUAGE

A module is the unit of specification in SOL and comprises of
type definitions, flow control rules, unit declarations, unit conversion rules, variable declarations, service declarations, assumptions
and guarantees, and definitions. A module in SOL may include
one or more attributes. The attribute deterministic declares

the module as being free of nondeterminism (which is checked by
the SOL compiler). Attribute reactive declares that the module will not cause a state change or invoke a method unless its
(visible) environment initiates an event by changing state or invoking a method (service); moreover, the module‚Äôs response to an
environmental event will be immediate; i.e., in the next immediate step. The attribute continuation declares that the module
will serve as a continuation for some (external) service invocation.
Each (asynchronous) external service invocation is managed by a
continuation module that receives the response for the invocation
and informs the module that originally invoked the service of the
response as soon as it arrives. As defined previously, an agent is
a module instance. In the sequel, we use module and agent interchangeably.
C-style comments are supported ‚Äì all text between an opening
‚Äú/*‚Äù and closing ‚Äú*/‚Äù is ignored. Alternately, comments may begin with ‚Äú//‚Äù and terminate by the end of the line. Comments may
be nested. The module definition comprises a sequence of sections,
all of them optional, each beginning with one or more keywords.
‚ÄúInteger‚Äù, ‚ÄúReal‚Äù, ‚ÄúBoolean‚Äù, and ‚ÄúString‚Äù are the built-in data
types in SOL. User-defined types as well as enumerated types can
be defined in the type definitions section. Each entry in this section consists of an identifier for the type, followed by its definition,
which may be in terms of the built-in types, their subranges, or
enumerated types. Besides, this section allows the user to declare
‚Äúsecrecy‚Äù types (e.g., secret, classified, unclassified etc.) in order
to enforce information flow policies and prevent unwanted downgrading of sensitive information from ‚Äúsecret‚Äù variables to ‚Äúpublic‚Äù variables. The flow control rules section provides rules that
govern the downgrading/flow of information between variables of
different ‚Äúsecrecy‚Äù types (e.g., the rule unclassified = classified,
signifies that a variable of type unclassified can be assigned to a
variable of type classified, i.e., information flow from an unclassified to a classified variable is allowed). The flow control rules can
be used to compute the secrecy types of expressions from those of
its constituent variables. If not specified in the flow control section, information flow between variables/expressions with different
secrecy types is allowed only in the presence of explicit coercion
provided by the programmer. These policies are enforced statically
by a static type system. The unit declaration section declares units
for the physical quantities that the module monitors and manipulates (e.g., lb, kg, centigrade etc.). This section provides conversion (coercion) rules between the different units (e.g., kg=2.2 lb).
Units of expressions can be computed from the units of their constituent subexpressions. The variable declaration section for reactive/deterministic modules is subdivided into five subsections. The
continuation variable declaration subsection defines continuation
variables that will be used for service invocations. There will be
one continuation variable for each service invocation in a module.
The type ‚Äúcontinuation‚Äù before a variable designates it as a continuation variable (e.g., continuation cont;). Corresponding to each
continuation variable, there will be a continuation module handling
the service invocation associated with that variable. The other four
subsections declare the ‚Äúmonitored‚Äù variables in the environment
that an agent monitors, the ‚Äúcontrolled‚Äù variables in the environment that the agent controls, ‚Äúservice‚Äù variables that only external
service invocations can update, and, ‚Äúinternal‚Äù variables introduced
to make the description of the agent concise. The monitored variables section can include failure variables that are boolean variables indicating the failure of other modules (e.g., the declaration
failure boolean I; declares a boolean variable I that will
become true if a module named I in the environment fails). A
variable declaration can specify the unit (declared in the unit dec-



laration section) of the physical quantity that it is supposed to assume values for (e.g., int weight unit lb;). Assignment of a variable/expression with a unit to a variable with unit is allowed
only if it is specified in the unit conversion rules section. In that
case, the value of the variable/expression is converted to the unit
using the corresponding conversion rule before being assigned to a
variable with unit . The declaration of a monitored variable can
be accompanied by failure handling information that may specify it
being substituted in all computations by another monitored variable
in case the module publishing it fails (e.g., the declaration integer x on I y specifies that the monitored variable y should
replace the variable x if the failure variable I corresponding to the
module named I in the environment is true). The service declarations section declares the methods that are invoked within a module along with the services providing them. It also describes for
each method the preconditions that are to be met before invoking
the method as well as the post conditions that the return value(s)
from the method is/are supposed to respect. The preconditions and
postconditions consist of conjunctions of arithmetic constraints as
well as type expressions. A type expression is a set of atomic type
judgements of the form
where is a variable and is a
type. These conditions are enforced dynamically under a runtime
environment.
The assumptions section includes assumptions upon which
correct operation of the agent depends. Execution aborts when
any of these assumptions are violated by the environment resulting in the failure variable corresponding to that agent to be set to
true. The required safety properties of the agent are specified in the
guarantees section. Variable definitions, provided as functions
or more generally relations in the definitions section, specify
values of internal and controlled variables. A SOL module specifies the required relation between monitored variables, variables in
the environment that the agent monitors, and controlled variables,
variables in the environment that the agent controls. Additional internal variables are often introduced to make the description of the
agent concise. In this paper, we often distinguish between monitored variables, i.e., variables whose values are specified by the
environment, and dependent variables, i.e., variables whose values
are computed by a SOL module using the values of the monitored
variables as well as those returned by the external service invocations. Dependent variables of a SOL module include the controlled
variables, service variables, and internal variables. SOL provides
type constructors such as arrays and tuples. In this paper, we shall
not elaborate on the tuple and array constructs of SOL (see [24] for
details).









3.1 Events
SOL borrows from SCR the notion of events [18]. Informally,
an SCR event denotes a change of state, i.e., an event is said to
occur when a state variable changes value. SCR systems are eventdriven and the SCR model includes a special notation for denoting
them. The following are the notation for events that can trigger
reactive/deterministic modules. The notation @T(c) denotes the
event ‚Äúcondition became true‚Äù, @F(c) denotes ‚Äúcondition became false‚Äù , @Comp(cont) denotes that ‚Äúthe result of the service
invocation associated with the continuation variable cont (i.e., the
service invocation in which cont was passed) is available‚Äù, and
@C(x) the event ‚Äúthe value of expression x has changed‚Äù. These
constructs are explained below. In the sequel, PREV(x) denotes




@T(c)
@F(c)
@C(c)





	

the value of expression x in the previous state.




      !"#
    %&$ 


Events may be triggered predicated upon a condition by including a
‚Äúwhen‚Äù clause. Informally, the expression following the keyword
when is ‚Äúaged‚Äù (i.e., evaluated in the previous state) and the event
occurs only when this expression has evaluated to true. Formally,
a conditioned event, defined as

 ' # !()*+,.denotes the event ‚Äúcondition 
 became true when condition /
@T(c) when d

was true in the previous state‚Äù. Conditioned events involving
the @F and @C constructs are defined along similar lines. The event
@Comp(cont) is triggered by the environment in which the agent
is running and is received as an event by the agent whenever the
result of a service invocation is received by the continuation module
associated with the continuation variable cont that was passed as
a continuation while invoking the service. We will define the event
@Comp in terms of associated continuation modules in Section 3.3.
Each controlled and internal variable of a module has one and
only one definition which determines when and how the variable
gets updated. All definitions of a module implicitly specify a desuch that a variable depends on variable
pendency relation
(i.e.,
) if and only if appears in the definition of
. Note that variable may depend on the previous values of other
variables (including itself) which has no effect on the dependency
relation. A dependency graph may be inferred from the dependency relation by taking each variable in the module to be a node
and including an edge from to if depends on 1 . It is required
that the dependency graph of each module is acyclic.
Intuitively, the execution of a SOL program proceeds as a sequence of steps, each initiated by an event (known as the triggering
event). Each step of a SOL module comprises a set of variable
updates and service invocations that are consistent with the depenof that module. Computation of each step of a
dency relation
module proceeds as follows: the module or its environment nondeterministically initiates a triggering event; each module in the
system responds to this event by updating all its dependent (i.e.,
internal, service, and controlled) variables. In the programmer‚Äôs
view all updates and service invocations of the system are assumed
to be synchronous (similar to the Synchrony Hypothesis of languages such as Esterel, LUSTRE, etc. [17]) ‚Äì it is assumed that the
response to a triggering event is completed in one step, i.e, all updates to dependent variables and all method calls are performed by
the modules of the system before the next triggering event. Moreover, all updates are performed in an order that is consistent with
the partial order imposed by the dependency graph.

5

4

 4 - 5 76 1 132 2

5

4

4 5 4

0

4

5

132

3.2 An Automated Therapeutic Drug Monitoring System in SOL
In this subsection, we present a (part of a) skeleton in SOL of a
distributed automated therapeutic drug monitoring system in a hospital. We will use this as a running example later in this paper. A
scenario of the operation of the system is depicted in Figure 1. A
sensor (can be a nurse sitting at a terminal) at a patient‚Äôs bed in the
hospital monitors the patient‚Äôs vital data (e.g., saturation, heartbeat,
blood pressure etc.). As soon as the vital data indicate that the patient‚Äôs condition is critical, the sensor reports the vital data to the
1
The notion of a dependency relation is easily extended to the entire
system.

deterministic reactive module doctor {
type definitions
dosage = Integer;
condition={critical,not_critical};
units
lb_per_sqinch, mg, cc;
unit conversion rules
mg=cc;
services
dosage pharmserv:compute_dosage(x,y,z),
pre= x::Integer, y::Integer, z:: Integer
-- post=true;

Figure 1: Automated therapeutic drug monitoring scenario

monitored variables
Integer heartrate;
Integer pressure unit lb_per_sqinch;
Integer saturation;
condition patient_cond;
service variables
dosage c_dosage unit mg;

contination variables
central hospital server along with a report on the patient‚Äôs condition
continuation cont;
(critical). The central hospital server contacts the patient‚Äôs doctor
(e.g., by sending a message to her palmpilot) with the patient‚Äôs vicontrolled variables
tal data and the report (critical) from the sensor. The doctor can
dosage output_dosage unit cc;
look up a drug appropriate for the patient‚Äôs condition and invoke
Boolean oxygen;
a service provided by the pharmaceutical company (producing the
drug), with the vital data of the patient, that computes the correct
definitions
dosage corresponding to the patient‚Äôs current state. Further, if the
// definitions of controlled
patient‚Äôs saturation is below a certain threshold, the doctor can or//and service variables
c_dosage = initially null then
der her to be put on oxygen. The doctor communicates her response
if{
(dosage, oxygen) to the central hospital server which in turn com[] @C(patient_cond) && @C(heartrate)
municates it to the nurse (patient sensor and actuator) that attends
&& @C(pressure)
the patient by administering the required dosage of the drug or by
-> pharmserv:
putting her on oxygen. The patient sensor (or the nurse) reports
compute_dosage(
to the hospital service whenever the state of the patient changes
heartrate,pressure,
saturation)
(e.g., turns from critical to noncritical) which in turn reports to
ÀÜcont;
the doctor for appropriate action. Due to space limitations, we
}// service invocation
show here only the SOL module running on the doctor‚Äôs palmpilot in Figure 2. The complete therapeutic drug monitoring system
output_dosage= initially null then
consists of SOL modules for the ‚Äúdoctor‚Äù, the ‚Äúhospital server‚Äù
if{
and the ‚Äúnurse/patient sensor and actuator‚Äù. The modules translate
[] @Comp(cont)-> c_dosage;
} //update of controlled variable
directly into Java and runs unmodified on the SINS middleware.
oxygen= initially false then
Interested readers may refer to [17] to compare SOL with other
if{
synchronous programming languages such as Esterel, Argos, LUS[] @T(saturation<65) -> true;
TRE, and SIGNAL.
[] @T(saturation>90) -> false;
The doctor module is implemented as a deterministic reac}
tive module. We identify four monitored variables ‚Äì heartrate,
}
pressure (unit lb/sqinch), saturation and patient condition
corresponding to the vital data heart rate, blood pressure and saturation of the patient as well as the condition of the patient (critical
Figure 2: Doctor module in SOL.
or noncritical) that the module obtains from the hospital server. We
also identify a service variable c dosage (unit mg) that is defined by invoking the pharmaceutical service, a continuation variable that cont that is passed as a continuation while invoking the
service, and two controlled variables output dosage (unit cc)
and oxygen that correspond respectively to the dosage and the de-

cision whether to put the patient on oxygen or not sent back to the
name of the method invoked, var list is the list of variables
hospital server. The hospital server listens to these two controlled
passed as arguments to the method, and, cont is the passed convariables (among others). We also identify a service invocation
tinuation variable. In this case, the service variable depends on the
pharmserv:compute dosage that invokes the compute dosage variables in var list. For each service invocation in a module,
method of the pharmaceutical service named (and addressed) pharmserva distinct continuation variable is used. Internally, corresponding
with the vital data of the patient as arguments and the variable
to each continuation variable there is a continuation module hancont being passed as a continuation. The service invocation is
dling the result of the service invocation in which the variable is
used to obtain the required dosage of the patient and defines the
passed. A continuation module has the same structure as the reacservice variable c dosage. The preconditions for invoking the
tive/deterministic ones except that it can have an additional subsection in the variable declaration section: channel variables. Channel
service provided in the services section specify that the types of
all the three formal parameters x, y and z should be Integer while
variables receive values from external services. In addition, it can
have another section called triggers that lists actions in the environthe postcondition always holds true. The return value from the service invocation should be of type dosage. The unit conversion
ment that the module can trigger. Actions in the trigger section can
times a cc so that
be defined in the same way as variables. Along with the usual notarules section defines an mg to be equal to
the value of the variable c dosage is to be multiplied by
(by
tion for events as in reactive/deterministic modules, a continuation
module can have an additional event denoted by @Rec(Chan),
the runtime environment) before being assigned to the controlled
variable output dosage.
where Chan is a channel variable, which is triggered as soon as
The module doctor responds to a triggering event2 by upa value is received from an external service on the variable Chan.
dating its dependent variables in compliance with the dependency
A continuation module for a service invocation is generated inter(partial) order. One possible order is oxygen
nally automatically by the SOL compiler from the SOL definitions
saturation,
and is kept away from the view of the programmer. For example,
c dosage heartrate, c dosage pressure, c dosage
the continuation module corresponding to the service invocation in
saturation, c dosage cont, and output dosage
Figure 2, where the service variable c dosage (with type dosage)
c dosage.
defined by a two-state definition is given below.

898:

;

;

;

88:

;

;

;

3.3 SOL Definitions

The definitions section is at the heart of a SOL module.
The syntax of SOL definitions is shown in Figure 3. This section
determines how each internal, service, and controlled variable of
the module is updated in response to events (i.e., state changes)
generated either internally or by the module‚Äôs environment.
A variable definition is either a one-state or a two-state definition. A one-state definition, of the form
(where
is an expression), defines the value of variable x in terms of the
values of other variables in the same state. A two-state variable
definition, of the form
(where
is a two-state expression), requires the initial value of x to
equal expression
; the value of x in each subsequent state is
determined in terms of the values of variables in that state as well
as the previous state (specified using operator PREV or by a when
clause).
A conditional expression, consisting of a sequence of branches
‚Äú[] guard
expression‚Äù, is introduced by the keyword ‚Äúif‚Äù and
enclosed in braces ("{" and "}"). A guard is a boolean expression. The informal semantics of the conditional expression
expr
expr
is defined along the lines of Dijkstra‚Äôs
guarded commands [13] ‚Äì in a given state, its value is equivalent
to expression expr whose associated guard is true. If more than
one guard is true, the expression is nondeterministic. It is an error
if none of the guards evaluates to true, and execution aborts setting the failure variable corresponding to that module to true. The
case expression
expr
expr
is
equivalent to the conditional expression
expr
expr
. The conditional expression and the case expression may optionally have an otherwise
clause with the obvious meaning.

< =Q>

HKJHL

 <  =?>
< =?>
 '
 A@ BC@ED,@ 4FF9GIHKJHL D9MON9BP< =?>

;

Z U W[X\ ;

a

\^]]]`_

continuation module cont{
type definitions
dosage = Integer;
controlled variables
dosage c_dosage;
channel variables
dosage Chan;
triggers
Boolean @Comp(cont);
definitions
@Comp(cont) =
if{
[]@Rec(Chan)-> true;
}
c_dosage= initially null then
if{
[]@Rec(Chan)->Chan;
}

@SR3TVU WYXQZ ;

Xa


 4b N3< =?> cT U W[d,Z ; @ER3Z T7U W[dU W\K< ; ce^\ ]d ]Z ]	 _
=?>
;
Z U WfK<  =?> cgd \  ; \ ]]]`_

3.4 Service Invocation
A service variable is defined by a one-state or a two-state definition in terms of a service invocation expression (service invocation).
A service invocation expression is of the form A:B(var list)cÃÇont
where the identifier A is the name/URL of the service, B is the
2
Since doctor is reactive, all triggering events are external to
the module.

}
When the agent doctor defining the service variable c dosage
is executed, the agent environment invokes the service by sending
it a message. The preparation of this message involves marshaling the arguments as well as the continuation, which includes information about the channel Chan on which the result of the service invocation is to be returned. Once the service returns the result on the channel Chan, the guard @Rec(Chan) in the continuation module associated with the continuation variable becomes
true. This event results in the controlled variablec dosage (in
the continuation module) being set the value received on Chan as
the response for the service invocation. Also @Comp(cont) in
the environment gets set to true. In module doctor, this in turn
sets the value of the service variable c dosage to the value received as the response from the service (i.e., the value of the controlled variable c dosage of the continuation module cont) and
triggers the event @Comp(cont). The triggering of the event
@Comp(cont) in the doctor module results in the controlled

defn

:

lvalue "=" expr

lvalue

:

ID

expr

:

if expr

:

case expr

:

h

h

lvalue "=" "initially" expr "then" expr ";"

h

ID "[" index "]"

h h
h
h
h h

i

"[" lvalue [ "," lvalue ] "]"

h

h h
h
h
h
"if" "{" [ "[]" expr "->" expr ] k [ "otherwise" "->" expr ] j "}"
"case" expr "{" [ "[]" value [ "," value ] i "->" expr ] k
[ "otherwise" "->" expr ] j "}"
h

cond event

:

basic event "when" expr

basic event

:

"@ID " [ "(" expr l ")" ]
"@T" "(" expr ")"
"("cont var")" "@C" "(" expr ")"

expr l

:

expr [ "," expr ]

value

:

index

index

:

scalar value

scalar value

:

ID

bool binop

:

"&"

rel binop

:

"<"

arith binop

:

"+"

service invocation

:

ID ":"ID"(" var list ")ÀÜcont"

hj
ki

Choice
Optional
Zero or more
One or more

Legend:

[]
[]
[]

hj h h

value
"!" expr
expr bool binop expr
if expr
case expr
basic event
cond event
service invocation
"PREV" "(" expr ")"
expr rel binop expr
"+"
expr
"-" expr
expr arith binop expr
ID "[" index "]"
ID "(" [ expr l ] ")"
"[" expr l "]" "(" expr ")"

h

h

REAL

INT

h

h

h

"<="
"-"

i

h

STRING

h

"true"

h

"false"

scalar value ":" scalar value

"&&"

h

jlh

h

h

h

h

h

"|"
"=="
"*"

h

h

"||"
"!="

h
h

"=>"
">"

h

h

h
h

"@F" "(" expr ")"

h

"@Comp"

"infinity"

"<=>"
">="

"/"

Figure 3: The syntax of SOL definitions.

variable output dosage being assigned the value of c dosage
which at that point is the value returned as a response to the service invocation. Note that the invocation of the service can be
asynchronous, i.e., the response from the service may not arrive
instantaneously. Computations that do not depend on the response
received from the service invocation (i.e., definitions of dependent
variables that do not depend on the service variable receiving the response from the service invocation) are not blocked waiting for the
response from the service. For example, in Figure 2, the decision
whether to put the patient on oxygen can be made without waiting for the pharmaceutical service to return the required dosage.
Hence the definition of the variable oxygen can be executed while
waiting for the response from the pharmaceutical service, if one of
the events @T(saturation<65) or @T(saturation>90) is
triggered. Computations dependent on the result of the service invocation must be guarded by @Comp(cont), where cont is the
variable passed as continuation in the service invocation, so that
they wait until the result of the service invocation is available (signaled by the triggering of the @Comp(cont) event). The asynchronous nature of the service invocations create the effect of the
XMLHttpRequest API in AJAX-like applications.
The asynchronous nature of the service invocations can be used
to define a timer. We assume the existence of a timer method provided by a time service that when invoked with a (Integer or Real)
delay provides a response after the delay specified by the argument.
If the variable timer cont is passed as a continuation while invoking the service, the triggering of the event @Comp(timer cont)

signifies passage of the delay. The implementation of the timer is
illustrated in the example below.
deterministic reactive module delay{
...
services
String time:timer(x),
pre=x::Integer && x>0 -- post = true;
controlled variables
Integer x;
monitored variables
Boolean clock;
service variables
String t;
continuation variables
continuation timer_cont;
...
definitions
...
t=initially null then
if{
[] @T(clock)->time:timer(10)ÀÜtimer_cont;
}
x=initially null then
if{
[] @Comp(timer_cont)-> ...
}
}

mn

mn

The module delay ensures that the controlled x is output
time
units after the arrival of a clock pulse i.e., there is a delay of
time units between an input event (arrival of a clock pulse) and the
corresponding output.

Host

3.5 Failure Handling

Agents
E
n
c
SINS Virtual
r
Machine (SVM) y
p
t
Encrypt

Host
Agents
E
n
c
r
y
p
t

SINS Virtual
Machine (SVM)

Benign failures (we deal with byzantine failures elsewhere) in
the environment are handled by program transformations incorpoHost
Encrypt
E
rated in the SOL compiler that automatically transform a SOL modn
c
r
ule based on the failure handling information provided in the moniSINS Virtual
y
p
Machine (SVM)
tored variable declaration section. Given the declaration failure
t
Agents
Boolean I in the monitored variable section of a failure variable
signifying the (benign) failure of a module I in the environment
Figure 4: Architecture of SINS.
and the declaration Integer x on I y of a monitored variable
x (y is also a monitored variable), the SOL compiler transforms
5.1 Static Type Checking for Information Flow
each two-state definition z=initially null then expr, where
Let denote a typing environment,
range over the variables
z is a dependent variable and expr is an expression in which x ocof a module,
over the set of expressions in the module,
curs, to
over the set of types defined in the type definition section of the
z= initially null then
module, and
over the set of units defined in the unit definition
if{
section of the module. A typing environment is defined as
[] I -> expr[y/x];
}

o

where expr[y/x] is the expression obtained by replacing each
occurrence of the variable x by the variable y. One-state definitions
are transformed similarly.

3.6 Assumptions and Guarantees
The assumptions of a module, which are typically assumptions
about the environment of the subsystem being defined, are included
in the assumptions section. It is up to the user to make sure
that the set of assumptions is not inconsistent, i.e., a logical contradiction. Users specify the module invariants in the guarantees
section, which is automatically verified by a theorem prover such as
Salsa [9]. The syntax for specifying module assumptions and guarantees is identical to that of module definitions, in other words, we
have the expressiveness of the full language in these clauses. This
does not have a detrimental effect on the proof tools, since most
commonly encountered theorems about SOL programs are decidable.

4.

SINS

SOL agents execute on a distributed run-time infrastructure called
SINS (see Figure 4). A typical SINS implementation comprises
one or more SINS Virtual Machines (SVMs), each of which is responsible for a set of agents on a given host. SVMs on disparate
hosts communicate using the Agent Control Protocol (ACP) [26]
for exchanging agent and control information. An ancillary protocol, termed the Module Transfer Protocol (MTP) manages all
aspects of code distribution including digital signatures, authentication, and code integrity. Agents in SOL are allowed access to
local resources of each host in compliance with locally enforced
security policies. An inductive theorem prover is used to statically
verify compliance of an agent with certain local security policies.
Other safety properties and security requirements are enforced by
observer agents (termed ‚Äúsecurity agents‚Äù) that monitor the execution of application-specific agents and take remedial action when a
violation is detected.

5.

THE FORMAL SEMANTICS OF SOL

In this section, we provide the formal semantics of SOL. We
first present a static type system that enforces the information flow
policies ensuring safe downgrading of information.

 -qp

< =?>
s -td

r -L

o
w

v
T
ou h.oyx {z;|Ls?JHL!s _
where }z;~LsQJ!HLs denotes that  is of type L an unit s . Here
the unit qualifier is optional. Let us define o   y L if gz;
L`s?JHL¬Äs 6 6 o or Az;¬ÅL 6 o , and o#¬ÇE¬É aY¬Ñ   ¬Ö s if Az;
Ls?JHLs o . We will write og¬Ü¬à¬á¬â¬ã¬ä.¬å if the definition ¬á¬â¬ã¬ä.¬å is
well-typed under the typing environment o . The typing rules for

the static type system for SOL is given in Figure 5. The judgements [type] and [unit] are obvious. The judgement [expr] is infers
the secrecy type of an expression from those of its subexpressions
( is a binary operator/relation symbol). If under the typing environment , the secrecy types of the expressions
and
are and respectively, and
is a flow conversion rule (i.e.,
belongs to
), then the secrecy type of the expression
is . Informally, the rule states that, if binary operation/relation is applied on values, one of which is classified and
the other unclassified, then the secrecy type of the result is still classified. The judgements [expru1], [PREV1], [PREV2], and [if] are
straightforward. In [if],
denotes the if expression if []expr ->
otherwise ->
. The
judgement [expru2] states that if under the typing environment ,
the expressions
and
have units and respectively,
then a binary operation can be applied on the expressions if there
exists a conversion rule from the unit to the unit (or viceversa) declared in the unit conversion rules section of the module
(here
is an expression containing ). In case is defined in
terms of , the unit of the resultant expression will be . The judgements [odeft], [odefu], [tdeft], and [tdefu] provide the type and unit
checking rules for one-state definitions and two-state definitions respectively. We explain [odeft]; the others are similar. Intuitively the
rule [odeft] states that the value of an unclassified expression can be
assigned to a variable declared as classified. More formally, under
the typing environment , the value of an expression of type can
be assigned to a variable of type only if it is permitted by a rule in
the flow conversion section. Finally, the judgements [onecast] and
[twocast] state that an assignment of an expression of type to a
variable of type is allowed if explicitly coerced by the programmer. A module typechecks if
where
is the set of declarations in the module,
is the set of flow control rules and
is the set of unit
conversion rules. A module is secure if it typechecks.

¬ç¬é=

o

L L¬ê¬è
< =?> Z ¬ç.= < ¬í¬î=?¬ì> ¬ï9\ ¬ñ#¬ó¬ô¬ò,L ¬è¬ìY¬â.¬ö

LV;¬ëL¬ê¬è

< =?> \

Hq¬õ K< < =Q> -tZ < =Q> Z¬ú-¬ù< =Q> \  < \
=?>
=?>
o
<  =?> Z < =Q> \
s d
d
s
d
sd

<Od,
d

o

¬û

< =?> Z

+O< ¬ü ¬û

L

L

¬û

L¬è

tL ¬è
+O< ¬ú¬ü x¬°¬†!¬åQ¬¢¬ã¬£¬§¬óV¬òC¬ìY¬â.¬ö¬•x¬¶¬í¬î¬ì¬ïE¬ñ^¬óV¬òC¬ìY¬â.¬ö¬ô¬Ü
¬í¬î¬ì¬ï9¬ñ#¬ó¬ô¬ò,¬ìY¬â.¬ö
¬†¬ß¬åC¬¢¬ã¬£¬§¬ó¬ô¬ò,¬ìY¬â.¬ö

5.2 Formal Operational Semantics

¬®o ¬Ü"Y9L if o   ^ L
[unit]
o¬®¬Ü( s o ¬ÇE¬É aY¬Ñ    s
o¬Ö¬Ü < =Q> <Z L Z < o¬®¬Ü <\ =?> \ 9L ¬è L)¬©|L ¬è 6 ¬í¬î¬ì¬ï9¬ñ#¬ó¬ô¬ò,¬ìY¬â.¬ö
[expr]
o¬Ö¬Ü =Q> ¬ç.= =?> 9L ¬è
o¬®¬Ü < =?> Z < s Z < o¬®¬Ü \ < =Q> \ s
[expru1]
o¬®¬Ü =Q> ¬ç.= =?> s
o¬Ö¬Ü < =?> Z < s Z < o¬°¬Ü \ < =?d > \ d s &<¬™d,¬î6 ¬†!¬åQ¬¢¬ã¬£¬§¬óV¬òC¬ìY¬â.¬ö
[expru2]
o¬°¬Ü =?> ¬ç¬é= =?>
o¬Ö¬Ü < =?K<> s 
[PREV1]
o¬®¬Ü"¬´	¬óV¬¨*¬≠ =?> s
o¬®¬Ü < =?K<>cY9L 
[PREV2]
o¬®¬Ü(¬´¬î¬óV¬¨7¬≠ =?> 9L
o¬°¬Ü < =?>K< Z 9L -¬ê< o¬®Z¬ú-t< ¬Ü < =Q\  > \ L ¬è L¬©|L ¬è 6 ¬í¬î¬ì¬ï9¬ñ#¬ó¬ô¬ò,¬ìY¬â.¬ö
[if]
o¬®¬Ü{Hf¬õ =?> =?> =?> L ¬è
o¬®¬Ü"L  o¬Ö-¬ù¬Ü < < =? >¬ÆY9L ¬è L ¬è ¬©|L 6 ¬í¬î¬ì¬ï9¬ñ#¬ó¬ô¬ò,¬ìY¬â.¬ö
[odeft]
o¬°¬Ü¬Ø¬á¬™¬â¬ã¬ä¬é¬å  =?>
o¬Ö¬Ü s  o¬°-t< ¬Ü < =? > d s &<¬™d,¬î6 ¬†!¬åQ¬¢¬§¬£¬§¬ó¬ô¬ò,¬ìY¬â.¬ö
[odefu]
o¬°¬Ü¬Ø¬á¬™¬â¬ã¬ä.¬å  =?>
o¬Ö¬Ü{"9L o¬®¬Üy¬¢¬§¬åQ¬¢¬ã¬£	- Y9L ¬è ¬è-¬é- < o¬°¬Ü  < =?>¬Æ9L ¬è L ¬è ¬©¬∞L - L ¬è ¬è ¬©¬∞L 6 ¬í¬î¬ì¬ï9¬ñ#¬ó¬ô¬ò,¬ìY¬â.¬ö
[tdeft]
o¬®¬Ü¬±¬£¬ñ	¬ï ¬á¬™¬â¬ã¬ä.¬å  HKJ!HL =?>
¬¶¬≥ - o¬°¬Ü < =?> d &<¬™d,.-   ¬≥ V6
¬®
o

¬Ü

s
¬Ö
o
¬≤
¬Ü
¬ã
¬¢
Q
¬å
¬§
¬¢
¬£
s
s ¬õ
¬†¬ß¬åC¬¢¬ã¬£¬§¬ó¬ô¬ò,¬ìY¬â.¬ö
[tdefu]
o¬°¬Üy¬£¬ñ	¬ï ¬á¬™¬â¬ã¬ä.¬å   - HKJ!HL -¬é< =?> 
o¬Ö¬Ü{"9L
o¬Ö¬Ü"Y9L
[onecast]
o¬Ö¬Üy¬á¬™¬â¬ã¬ä.¬å   -¬ú L ¬ê< =?>  [twocast] o¬®¬Ü¬±¬£¬ñ	¬ï ¬á¬™¬â¬ã¬ä¬é¬å   - L  HJHL -S L ¬ê< =?> 
[type]

Figure 5: A static type system for SOL

¬¥
¬µQ¬∂.¬∑C¬â.¬ö
E
¬∏

¬π
¬ì
  6 ¬µ¬Ä¬∫¬´	¬¨¬º¬ª  ¬ê- p
¬¥
 v h¬¥x T {z; d¬™¬Ω,¬ü _ ¬úh ¬¥x T ¬´	¬ó¬ô¬¨7¬≠    z; d¬™¬Ω,¬ü _
¬¥  w
¬∞
where Iz; d¬™¬ΩC¬ü denotes that  assumes value d¬™¬Ω,¬ü . We will write
¬¥¬æ¬Ü¬ø¬àz; d¬™¬Ω,¬ü if e] z; ]] _√Éd¬™√Ç ¬Ω,¬ü(6 _ ¬¥ . We will denoteaY¬Ñ by {¬á¬ïE√Ä  ¬¥ 
¬¥ . Let us write ¬¥¬ÇE¬É  s if
the set T √Åh T ;z
s 6 ¬á¬ïE√Ä  ¬¥  and the unit of  is s . For a module ¬û , we denote
by ¬¥2 the restriction of ¬¥ to the variables in ¬û . The judgements

In this section, we provide (a part of) the formal operational sebe the set
mantics of SOL. Let be an environment. Let
of all types in a SOL program. We let
range over values of
type for
. Let
range over the variables in SOL
program. An environment is defined as

for the operational semantics of SOL are given in Figure 6. For
sake of brevity, we do not include the full operational semantics;
rather we only provide a sampling of some of the more informative rules. The first judgement [no action] states that for a module
if no monitored variable changes, then no computation is done.

¬û

√Ñ&¬≠ 2

¬û

Here
denotes the set of all monitored variables of . The
second judgement [unit conv] shows how unit conversion is done
automatically at runtime. If the unit of an expression is , under
the current environment its value is
, and a variable of unit
is assigned the value of the expression, then the value
is first
transformed to unit using the rules in the unit conversion section
of concerned module before assignment to . The third judgement
[CV] states that if is a controlled variable in the module and a
monitored variable in the module and if has value
under the
environment
then it has the same value under the environment
(here
is the set of controlled variables of the module ).
The judgement [@Comp] describes the
event. Assume
that is an internal or a controlled variable defined by an expression. Assume also that the definition is guarded by
where
is a continuation variable. If under the current environment , the expression in the definition evaluates to
and
is true, then the variable evaluates to
and
the environment turns off
. The other rules that we

¬¥¬É



¬¥2
√Öc¬≠¬Ä2

 ¬ç9J¬•L
¬¥
√Üc√á√à¬çE¬û3=  ¬ç9J¬•L 



d¬™¬Ω,¬ü

s

J





√Üc√á√à¬ç9¬û¬¶=

√Üc√á√à¬çE¬û3=  ¬ç9J¬•L 



d
 d¬™¬ΩC¬ü

d¬™¬Ω,¬ü ¬û

s

¬û

√Üc√á√à¬çE¬û3=  ¬ç9J¬•L 
d¬™¬Ω,¬ü
d¬™¬Ω,¬ü

¬¥¬±¬Ü7√â¬• 6 √Ñ√ä¬≠ 2 ¬´	¬ó¬ô¬¨7¬≠     √â  ¬çEJ¬•Lt¬¥ ¬Ü√ã$ √Üc√á√à¬çE¬û3=  ¬çEJL 
¬¥¬≤¬Ü < =?>√àz; d¬™¬Ω,¬ü ¬¥ ¬ÇE¬É aY¬Ñ K<¬™< d¬™=?¬Ω,> ¬ü# √åd?- ¬¥ ¬ÇE¬É aY¬Ñ   ^ s s √ä<¬™d,¬î6 ¬†¬ß¬åC¬¢¬ã¬£¬§¬ó¬ô¬ò,¬ìY¬â.¬ö -t+O< ¬õ   -t< =?> 6 ¬û
[unit conv]
¬¥"¬Ü(z;
¬¥ 2 ¬Ü{{z; d¬™¬Ω,¬ü d¬™¬Ω, ¬ü 6 √Öc¬≠¬•√ç  6 √Ñ&¬≠√é
[CV]
¬¥¬É*¬Ü{z;
- +O<   .- -¬ù< )6
¬¥¬≤¬Ü < =?U >√àz; d¬™¬Ω,¬ü   ¬¥¬≤ ¬Ü√ã√Üc¬Ω,√á√à¬ü ¬çE<¬û3W =  ¬ç9J¬•L  d¬™z;u

¬£
.
√è
Q
¬ò
¬â
[@Comp]
¬õ √á√à¬ç9¬û¬¶= ¬çEJ¬•L  =?> ¬û
¬¥ √Üc√á√à¬ç9¬û¬¶= ¬çEJ¬•L  ¬õ r ¬Ü({;z ¬Ω,¬ü
[no action]

Figure 6: Operational Semantics for SOL
do not present here deal with checking the preconditions of a service before a service invocation, checking the postconditions after
a service has responded and dealing with the external events. Note
that at runtime the preconditions and postconditions of a service invocation (including types) are checked to ensure soundness in the
presence of third party (possibly COTS) component services that
may undergo reconfigurations at runtime due to network faults or
malicious attacks.

6.

CONCLUDING REMARKS

[11]
[12]
[13]
[14]
[15]

SOL is based on ideas introduced in the Software Cost Reduction
(SCR) project [19, 20] of the Naval Research Laboratory which
dates back to the late seventies. The design of SOL was directly
influenced by the sound software engineering principles in the design of SAL (the SCR Abstract Language), a specification language
based on the SCR Formal Model [18]. SOL provides a functionality akin to the XMLHttpRequest framework while maintaining a
formal setting.
The goal of SINS is to provide an infrastructure for deploying and protecting time- and mission-critical applications on a distributed computing platform, especially in a hostile computing environment, such as the Internet. The criterion on which this technology should be judged is that critical information is conveyed to
principals in a manner that is secure, safe, timely, and reliable.

7.[1] E.REFERENCES
Amir and J. Stanton. The spread wide area group communication

system. Technical report, Johns Hopkins University, 1998.
[2] G. Antoniou and F. van Harmelen. A Semantic Web Primer. MIT
Press, 2004.
[3] A. W. Appel. Compiling with Continuations. Cambridge University
Press, 1992.
[4] A. Benveniste, P. Caspi, S. A. Edwards, N. Halbwachs, P. L. Guernic,
and R. de Simone. The synchronous languages 12 years later.
Proceedings of the IEEE, 91(1):64‚Äì83, 2003.
[5] G. Berry and G. Gonthier. The Esterel synchronous programming
language: Design, semantics, implementation. Sci. of Computer
Prog., 19, 1992.
[6] R. Bharadwaj. Development of dependable component-based
applications. In In Proceedings of the First International Symposium
on Leveraging Applications of Formal Methods (ISOLA). IEEE
Computer Society, 2004.
[7] R. Bharadwaj. Development of dependable component-based
distributed applications. Technical report, Naval Research
Laboratory, 2005.
[8] R. Bharadwaj and C. Heitmeyer. Model checking complete
requirements specifications using abstraction. Automated Softw.
Engg., 6(1), Jan. 1999.
[9] R. Bharadwaj and S. Sims. Salsa: Combining constraint solvers with
BDDs for automatic invariant checking. In Proc.
International

√ê ¬Ñ√ë

View publication stats

[10]

[16]
[17]

[18]

[19]
[20]
[21]
[22]
[23]
[24]

[25]
[26]
[27]

Conference on Tools and Algorithms for the Construction and
Analysis of Systems (TACAS‚Äô2000), ETAPS 2000, Berlin, Mar. 2000.
R. Bharadwaj and S.Mukhopadhyay. From synchrony to sins.
Technical report, West Virginia University, 2005.
K. P. Birman. Reliable Distributed Systems. Springer, 2005.
D. Crane, E. Pascarello, and D. James. Ajax in Action. Manning,
2005.
E. W. Dijkstra. A Discipline of Programming. Prentice-Hall, 1976.
F. C. et. al. Business Process Execution Language for Web Services.
IBM, 2002.
R. Fielding. Architectural Styles and the Design of Network-based
Software Architectures. PhD thesis, UNIVERSITY OF
CALIFORNIA, IRVINE, 2000.
D. Gay, P. Levis, J. R. von Behren, M. Welsh, E. A. Brewer, and
D. E. Culler. The nesc language: A holistic approach to networked
embedded systems. In PLDI, pages 1‚Äì11, 2003.
N. Halbwachs. Delay analysis in synchronous programs. In
C. Courcoubetis, editor, the International Conference on
Computer-Aided-Verification, volume 697 of LNCS, pages 333‚Äì346.
Springer-Verlag, 1993.
C. L. Heitmeyer, R. D. Jeffords, and B. G. Labaw. Automated
consistency checking of requirements specifications. ACM
Transactions on Software Engineering and Methodology,
5(3):231‚Äì261, April‚ÄìJune 1996.
K. Heninger, D. L. Parnas, J. E. Shore, and J. W. Kallander. Software
requirements for the A-7E aircraft. Technical Report 3876, Naval
Research Lab., Wash., DC, 1978.
K. L. Heninger. Specifying software requirements for complex
systems: New techniques and their application. IEEE TSE,
SE-6(1):2‚Äì13, Jan. 1980.
E. A. Lee. Absolutely positively on time: What would it take?
Computer, 38(7):85‚Äì87, 2005.
G. Neumann and U. Zdun. Pattern-based design and implementation
of an xml and rdf parser and interpreter: A case study. In ECOOP,
pages 392‚Äì414, 2002.
E. Newcomer. Understanding Web Services. Addison Wesley, 2002.
F. Rocheteau and N. Halbwachs. POLLUX: A Lusture based
hardware design environment. In P. Quinton and Y. Robert, editors,
Proc. Conf. on Algorithms and Parallel VLSI Arch. II, Chateau de
Bonas, June 1991.
J.-P. Talpin, P. L. Guernic, S. K. Shukla, R. K. Gupta, and F. Doucet.
Polychrony for formal refinement-checking in a system-level design
methodology. In ACSD, pages 9‚Äì19, 2003.
E. Tressler. Inter-agent protocol for distributed SOL processing.
Technical Report To Appear, Naval Research Laboratory,
Washington, DC, 2002.
S. S. Yau, S. Mukhopadhyay, and R. Bharadwaj. Specification,
analysis, and implementation of architectural patterns for dependable
software systems. In IEEE WORDS, 2005.


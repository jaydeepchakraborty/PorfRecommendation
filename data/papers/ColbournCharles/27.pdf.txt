SIAM J. DISCRETE MATH.
Vol. 27, No. 4, pp. 1844–1861

c 2013 Society for Industrial and Applied Mathematics
⃝

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

SEQUENCE COVERING ARRAYS∗
YEOW MENG CHEE† , CHARLES J. COLBOURN‡ , DANIEL HORSLEY§ , AND
JUNLING ZHOU¶
Abstract. Sequential processes can encounter faults as a result of improper ordering of subsets
of the events. In order to reveal faults caused by the relative ordering of t or fewer of v events, for
some fixed t, a test suite must provide tests so that every ordering of every set of t or fewer events
is exercised. Such a test suite is equivalent to a sequence covering array, a set of permutations on
v events for which every subsequence of t or fewer events arises in at least one of the permutations.
Equivalently it is a (diﬀerent) set of permutations, a completely t-scrambling set of permutations,
in which the images of every set of t chosen events include each of the t! possible “patterns.” In
event sequence testing, minimizing the number of permutations used is the principal objective. By
developing a connection with covering arrays, lower bounds on this minimum in terms of the minimum
number of rows in covering arrays are obtained. An existing bound on the largest v for which the
minimum can equal t! is improved. A conditional expectation algorithm is developed to generate
sequence covering arrays whose number of permutations never exceeds a specified logarithmic function
of v when t is fixed, and this method is shown to operate in polynomial time. A recursive product
construction is established when t = 3 to construct sequence covering arrays on vw events from ones
on v and w events. Finally computational results are given for t ∈ {3, 4, 5} to demonstrate the utility
of the conditional expectation algorithm and the product construction.
Key words. sequence covering array, completely scrambling set of permutations, covering array,
directed t-design
AMS subject classifications. 05B40, 05B15, 05B30, 05A05
DOI. 10.1137/120894099

1. Introduction. A set of permutations {π1 , . . . , πN } of a v-element set X is
completely t-scrambling if for every ordered t-set (x1 , . . . , xt ) with xi ∈ X for 1 ≤ i ≤ t,
there is some ρ (1 ≤ ρ ≤ N ) for which πρ (xi ) < πρ (xj ) if and only if i < j. Spencer
[32] first explored the existence of completely t-scrambling sets of permutations in
generalizing a question of Dushnik [15] on linear extensions. Recently Kuhn et al.
[23, 24] examined an equivalent combinatorial object, the sequence covering array.
For parameters N , t, and v, such an array is a set of n permutations of v letters so
that every permutation of every t of the v letters appears—in the specified order—in
at least one of the n permutations. The motivation for finding sequence covering
arrays with small values of n arises in event sequence testing. Suppose that a process
involves a sequence of v tasks or events. The operator may, unfortunately, fail to
do the tasks in the correct sequence. When this happens, errors may occur. But
we anticipate that errors can be attributed to the (improper) ordering of a small
∗ Received by the editors October 8, 2012; accepted for publication (in revised form) September
4, 2013; published electronically October 28, 2013.
http://www.siam.org/journals/sidma/27-4/89409.html
† School of Physical and Mathematical Sciences, Nanyang Technological University 637371,
Singapore (YMChee@ntu.edu.sg).
‡ School of Computing, Informatics, and Decision Systems Engineering, Arizona State University, Tempe, AZ 85257, and State Key Laboratory of Software Development Environment, Beihang
University, Beijing 100191, China (colbourn@asu.edu). This author was supported by Australian
Research Council grant DP120103067.
§ School of Mathematical Sciences, Monash University, Melbourne, Australia (danhorsley@
gmail.com). This author was supported by Australian Research Council grants DP120103067 and
DE120100040.
¶ Department of Mathematics, Beijing Jiaotong University, Beijing, China (jlzhou@bjtu.edu.cn).

1844

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

SEQUENCE COVERING ARRAYS

1845

subset of tasks. When each permutation of a sequence covering array is used in
turn to specify a task order, every potential ordering of t or fewer tasks will be
tried and hence all errors found that result solely from the improper ordering of t
or fewer tasks. Applications are discussed further in [19, 23, 39, 40]; related event
sequence testing problems in which tasks can be repeated are discussed in [42, 43, 44].
While the application of these combinatorial structures is of much practical concern,
our interest is in bounds on the size of sequence covering arrays and their explicit
construction.
We first state the problem formally. Let Σ = {0, . . . , v − 1} be symbols that
represent the v tasks or events. A t-subsequence of Σ is a t-tuple (x1 , . . . , xt ) with
xi ∈ Σ for 1 ≤ i ≤ t, and xi ̸= xj when i ̸= j. A permutation π of Σ covers the
t-subsequence (x1 , . . . , xt ) if π −1 (xi ) < π −1 (xj ) whenever i < j. For example, with
v = 5 and t = 3, (4, 0, 3) is a 3-subsequence that is covered by the permutation 4 2
0 3 1. A sequence covering array of order v and strength t, or SeqCA(N ; t, v), is a set
Π = {π1 , . . . , πN }, where πi is a permutation of Σ, and every t-subsequence of Σ is
covered by at least one of the permutations {π1 , . . . , πN }. Often the permutations are
written as an N × v array.
We use an array representation for completely t-scrambling sets of permutations
as well. An N × v array is a completely t-scrambling set of permutations of strength t
on v symbols, or CSSP(N ; t, v), when the columns are indexed by Σ and the symbols
by Σ, and for every way c1 , . . . , ct to choose t distinct columns and every permutation
φ of {1, . . . , t}, there is a row ρ for which, for every 1 ≤ a < b ≤ t, the entry in cell
(ρ, cφ(a) ) is less than the entry in cell (ρ, cφ(b) ).
Lemma 1.1. A CSSP(N ; t, v) is equivalent to a SeqCA(N ; t, v).
Proof. If π1 , . . . , πN are the N permutations of a SeqCA(N ; t, v), form an N × v
array A in which cell (i, j) contains πi−1 (j). Then A is a CSSP(N ; t, v).
In the opposite direction, if A is a CSSP(N ; t, v), define permutation πi by setting
πi (aij ) = j for 1 ≤ i ≤ N and 0 ≤ j < v. Then π1 , . . . , πN form the N permutations
of a SeqCA(N ; t, v).
In the CSSP(8;3,5) of Table 1.1, the symbols {1, 2, 3} appear as 123 once, 132
once, 213 once, 231 zero times, 312 four times, and 321 once. Hence the rows of a
completely t-scrambling set of permutations do not necessarily produce a sequence
covering array; nevertheless they are conjugates, obtained by interchanging the roles
of columns and symbols.
Permutation problems concerning the avoidance of specified patterns of subsequences have been extensively studied in algebraic and probabilistic combinatorics;
see [33] for an excellent survey. (Here two subsequences (x1 , . . . , xt ) and (y1 , . . . , yt )
have the same pattern when, for 1 ≤ i < t, xi < xi+1 if and only if yi < yi+1 .)
Table 1.1
Example: SeqCA(8;3,5) – t = 3, v = 5, N = 8.
SeqCA
4203
1430
3120
0241
2134
0341
3021
4120

1
2
4
3
0
2
4
3

CSSP
2413
3042
3120
0314
4102
0341
1320
3124

0
1
4
2
3
2
4
0

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

1846

Y. M. CHEE, C. J. COLBOURN, D. HORSLEY, AND J. ZHOU

While cosmetically similar to pattern avoidance problems, the existence problem for
sequence covering arrays requires coverage rather than avoidance and requires that
all subsequences be covered and not simply every pattern.
The question of principal concern in this paper is as follows: Given t and v, what
is the smallest N for which a CSSP(N ; t, v) (equivalently, a SeqCA(N ; t, v)) exists?
Call this number SeqCAN(t, v). In the vernacular of completely t-scrambling sets
of permutations, Spencer [32] did the foundational work, and Füredi [17], Ishigami
[20, 21], Radhakrishnan [31], and Tarui [36] made improvements.
In a sequence covering
every t symbols must appear in each of the t! possible
"
! array,
orderings, and there are vt t! t-subsequences in total, so
t! ≤ SeqCAN(t, v) ≤

# $
v
t!
t

Both bounds are trivial, but the lower bound is the correct one when t = 2.
Lemma 1.2. SeqCAN(2, v) = 2 for all v ≥ 2.
Proof. Any permutation on v symbols and its reversal form a SeqCA(2; 2, v).
When t ≥ 3, neither bound is correct as v increases. Indeed the growth as a
function of v for fixed t is logarithmic.
Theorem 1.3 (see [31, 32]). For t ≥ 3,
#
$
#
$
2
v
t log(v)
&.
%
1+
(t − 1)!
log2 (v − t + 2) ≤ SeqCAN(t, v) ≤
t!
log2 (e)
2v − t + 1
log t!−1

The question of when SeqCAN(t, v) = t! is of independent interest in yet another
setting. Let V be a finite set; an element of V is a vertex. A transitive tournament on
V is a directed graph in which (1) for all x ∈ V , (x, x) is not an arc; (2) for distinct
x, y ∈ V , (x, y) is an arc if and only if (y, x) is not an arc; and (3) whenever (x, y)
and (y, z) are arcs, so is (x, z). A transitive tournament T = (V, A) has transitive
tournament T ′ = (W, B) as a subdigraph, denoted T ′ ≺ T , whenever W ⊆ V and
B ⊆ A. Let (V, T ) be a finite set V of cardinality v and a collection T with every
T ∈ T being a transitive tournament on k of the vertices in V ; members of T are blocks.
Then (V, T ) is a (t, λ)-directed packing of blocksize k and order v, or DPλ (t, k, v), if
for every X ⊆ V with |X| = t and every transitive tournament T ′ on vertex set X,
|{T ∈ T : T ′ ≺ T }| ≤ λ.
On the other hand, (V, T ) is a (t, λ)-directed covering of blocksize k and order v, or
DCλ (t, k, v)), if for every X ⊆ V with |X| = t and every transitive tournament T ′ on
vertex set X,
|{T ∈ T : T ′ ≺ T }| ≥ λ.
When (V, T ) is a DPλ (t, k, v) and also a DCλ (t, k, v), it is a (t, λ)-directed design
of blocksize k and order v, or DDλ (t, k, v). In this notation, the subscript is often
omitted when λ = 1.
Directed designs with t = 2 have been extensively studied as generalizations of
balanced incomplete block designs. The study of (t, 1)-directed packings has also
been extensive as a result of their equivalence to “deletion-correcting codes” (see
Levenshtein [25]). The connection with our investigation follows.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

SEQUENCE COVERING ARRAYS

1847

Lemma 1.4. A CSSP(N ; t, v) is equivalent to a DC(t, v, v) with N blocks. Moreover, a DD(t, v, v) exists if and only if SeqCAN(t, v) = t!.
Proof. For each row (a0 , . . . , av−1 ) of the CSSP, form a transitive tournament on
vertex set {0, . . . , v − 1} by including, for 0 ≤ i < j < v, arc (i, j) if ai < aj and arc
(j, i) otherwise. Each transitive tournament on t of these vertices is a subdigraph of
at least one of these N tournaments. The other direction is similar. When N = t!,
every t-subsequence is covered exactly once, and every transitive tournament of order
t arises as a subdigraph exactly once.
Theorem 1.5. Suﬃcient conditions for a DD(t, v, v) to exist include
1. t ≥ 3 and t ≤ v ≤ t + 1 [25] and
2. t = 4 and v = 6 [28].
Necessary conditions for a DD(t, v, v) to exist include
1. v ≤ t + 1 for t ∈ {3, 5, 6} [28],
2. v ≤ t! + 2" for t = 4 [28], and
− 1 for t ≥ 7 [28].
3. v ≤ t+1
2
Levenshtein [25] had conjectured that v ≤ t + 1 whenever a DD(t, v, v) exists for
t ≥ 3. As stated in Theorem 1.5, this does not hold for t = 4, but this is the only
known exception to Levenshtein’s conjecture. In the next section we significantly
reduce the upper bound on the largest v for which SeqCAN(t, v) can equal t!.
2. Lower bounds. Here we extend a technique used in [17, Theorem 5.1], improving on a method of Ishigami [21]. We require a number of previous results on
covering arrays, introduced next. See [8] for a more thorough introduction to them.
Let N , k, t, and v be positive integers. Let C be an N × k array with entries from
an alphabet Σ of size v; we typically take Σ = {0, . . . , v − 1}. When (ν1 , . . . , νt )
is a t-tuple with νi ∈ Σ for 1 ≤ i ≤ t, (c1 , . . . , ct ) is a tuple of t column indices
(ci ∈ {1, . . . , k}), and ci ̸= cj whenever νi ̸= νj , the t-tuple {(ci , νi ) : 1 ≤ i ≤ t} is a
t-way interaction. The array covers the t-way interaction {(ci , νi ) : 1 ≤ i ≤ t} if, in
at least one row ρ of C, the entry in row ρ and column ci is νi for 1 ≤ i ≤ t. Array
C is a covering array CA(N ; t, k, v) of strength t if it covers every t-way interaction.
CAN(t, k, v) is the minimum N for which a CA(N ; t, k, v) exists. The basic goal is to
minimize the number of rows (tests) required and hence to determine CAN(t, k, v).
When t ≥ 2 and v ≥ 2 are both fixed, CAN(t, k, v) is Θ(log k) (see, for example, [8]).
We strengthen this standard definition somewhat. For a t-way interaction T =
{(ci , νi ) : 1 ≤ i ≤ t} with symbols chosen from Σ = {0, . . . , v − 1}, let τσ (T ) =
'
|{i : νi = σ}|. Then define µ(T ) = v−1
σ=0 τσ (T )!. The natural interpretation is that
µ(T ) is the number of ways to permute the columns (c1 , . . . , ct ) so that the symbols
appear in the same order. A covering array provides excess coverage when every tway interaction T is covered by at least µ(T ) rows; such a covering array is denoted
by CAX (N ; t, k, v). More generally, the subscript X is used to extend notation from
covering arrays to those having excess coverage.
Theorem 2.1. Let v, t, and a be integers satisfying v ≥ t ≥ 3 and t ≥ a ≥ 0.
Then SeqCAN(t, v) ≥ a!CANX (t − a, v − a, a + 1).
Proof. Let S be a CSSP(N ; t, v). Choose any a columns of S, {e1 , . . . , ea }. For
each ordering π of these columns, form a matrix Cπ that contains all rows of S in
which the entry in column π(ei ) is less than that in column π(ei+1 ) for 1 ≤ i < a.
Because there are a! orderings and every row of S appears in exactly one of the {Cπ },
it suﬃces to show that for every choice of π the number n of rows in Cπ is at least
CANX (t − a, v − a, a + 1). To do this, form an n × (v − a) array Aπ whose columns
are the columns of Cπ that are not among the a selected. To determine the content of

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

1848

Y. M. CHEE, C. J. COLBOURN, D. HORSLEY, AND J. ZHOU

cell (r, c) of Aπ , examine the symbol σ in column c and row r of Cπ . If σ is less than
the symbol in row r and column π(e1 ), the entry is set to 0. If σ is greater than the
symbol in row r and column π(ea ), the entry is set to a. Otherwise find the unique j
for which σ is greater than the symbol in row r and column π(ej ) but less than the
symbol in row r and column π(ej+1 ), and set the entry to j.
Now we claim that Aπ is a CAX (n; t − a, v − a, a + 1). The verification requires
demonstrating that every (t − a)-way interaction T is covered at least µ(T ) times. So
let T = {(fi , νi ) : 1 ≤ i ≤ t − a}, noting that νi ∈ {0, . . . , a} and fi indexes a column
of A. We form permutations of {e1 , . . . , ea } ∪ {f1 , . . . , ft−a } that are consistent with
π on {e1 , . . . , ea } in that these columns appear in the order prescribed by π. To
do this, there are τ0 (T ) columns with entry 0; place one of the τ0 (T )! orderings of
these columns so that all appear before π(e1 ). There are τa (T ) columns with entry
a; place one of the τa (T )! orderings of these columns so that all appear after π(ea ).
For 1 ≤ j < a, there are τj (T ) columns with entry j; place one of the τj (T )! orderings
of these columns so that all appear before π(ej ) and after π(ej+1 ). In this way we
can form µ(T ) permutations of {e1 , . . . , ea } ∪ {f1 , . . . , ft−a }, each consistent with π.
Because each is consistent with π, it appears in Cπ . But each such appearance in Cπ
results in a diﬀerent row of A that covers T , and hence T is indeed covered at least
µ(T ) times.
The easiest applications of Theorem 2.1 result from using CAN(t, k, v) as a lower
bound for CANX (t, k, v). Apply it with a = t − 1, noting that CAN(1, k, t) = t for
all k ≥ 1, to recover the trivial lower bound that SeqCAN(t, v) ≥ t!. Apply it with
a = t − 2 to establish that SeqCAN(t, v) ≥ (t − 2)!CAN(2, v − t + 2, t − 1).
Now we return to the question of when SeqCAN(t, v) can equal t!, or equivalently when a DD(t, v, v) can exist. Theorem 2.1 ensures that SeqCAN(t, v) ≥
(t − 2)!CANX (2, v − t + 2, t − 1), so SeqCAN(t, v) = t! can hold only when CANX (2, v −
t + 2, t − 1) ≤ t(t − 1). The 2-way interaction T = {(c1 , ν1 ), (c2 , ν2 )} has µ(T ) = 2
exactly when ν1 = ν2 (called a constant pair) and has µ(T ) = 1 otherwise (a nonconstant pair). Because, for each pair of columns, t − 1 constant pairs must be covered
twice each, and (t − 1)(t − 2) nonconstant pairs must be covered at least once each,
CANX (2, v − t + 2, t − 1) ≥ t(t − 1). So we are concerned with when equality can hold.
Lemma 2.2. For v ≥ 4, CANX (2, k, v) = v(v + 1) only if k ≤ v + 2.
Proof. Suppose that a CAX (v(v + 1); 2, k, v) exists with columns indexed by
{1, . . . , k} and symbols by {0, . . . , v − 1}. We form sets on symbols V = ({1, . . . , k} ×
{0, . . . , v − 1}) ∪ {∞}. The system of sets (blocks) B is formed as follows. For every
row (x1 , . . . , xk ) of the covering array, a set {(i, xi ) : 1 ≤ i ≤ k} is placed in B.
Then for every 1 ≤ i ≤ k, a set {(i, j) : 0 ≤ j < v} ∪ {∞} is placed in B. The set
system (V, B) has kv + 1 symbols and v(v + 1) + k blocks. By construction, every two
diﬀerent symbols appear together in exactly one block, unless the pair is of the form
{(i, j), (i′ , j)} corresponding to a constant pair and therefore occurring in exactly two
blocks.
Now form a (kv + 1) × (v(v + 1) + k) matrix A, which is the symbol-block incidence
matrix, as follows. Rows are indexed by symbols, columns by blocks. The matrix
contains the entry 1 in row r and column c when symbol r appears in block c and 0
otherwise. Now examine B = AAT , which has rows and columns indexed by V . Its
diagonal entries are k in entry (∞, ∞) and v + 2 elsewhere. Its oﬀ-diagonal entries
are 2 in cells indexed by ((i, j), (i′ , j)) with i ̸= i′ and 1 otherwise.
The rank of B cannot exceed the number of columns in A, namely, v(v + 1) + k.
So in order to bound k, we bound the rank of B.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

SEQUENCE COVERING ARRAYS

1849

Write D = B − J. The rows indexed by V \ {∞} can be partitioned into v parts;
a part is formed by including all rows and columns with indices {(i, j) : 1 ≤ i ≤ k}
for some j with 0 ≤ j < v. Then D can be written as a block diagonal matrix with v
k × k block matrices each equal to X = vI + J and a single 1 × 1 block matrix with
entry k − 1. Now det(D) = (k − 1)(det(X))v , and det(X) = v k (1 + kv ) by the matrix
determinant lemma. Hence rank(D) = kv + 1. Because B is obtained from D by a
rank one update, rank(B) ≥ kv.
Consequently, kv ≤ v(v + 1) + k, or k ≤ v(v+1)
v−1 . Thus k ≤ v + 2 when v ≥ 4,
because k is an integer.
This enables us to establish a substantial improvement on the bound of Mathon
and Tran Van Trung [28] stated in Theorem 1.5.
Theorem 2.3. If t ≥ 3 and SeqCAN(t, v) = t! (or equivalently, a DD(t, v, v)
exists), then v ≤ 2t − 1.
Proof. If 3 ≤ t ≤ 6, this follows from Theorem 1.5. By Theorem 2.1, t! =
SeqCAN(t, v) ≥ (t − 2)!CANX (2, v − t + 2, t − 1) and thus CANX (2, v − t + 2, t − 1) =
t(t − 1). By Lemma 2.2, v − t − 2 ≤ t − 1 + 2 and hence v ≤ 2t − 1 as required.
It appears plausible that the bound should be t+2 rather than 2t−1; nevertheless,
the method here gives the first bound that is linear in t.
3. Upper bounds from probabilistic methods. Spencer [32] analyzed a
method that selects a set of N permutations on v symbols uniformly at random;
we explore this first.
v!
t!
))/(log( t!−1
)).
Lemma 3.1. For fixed t ≥ 3, SeqCAN(t, v) ≤ 1 + (log( (v−t)!
Proof. A permutation of {0, . . . , v − 1} chosen uniformly at random covers any
specific t-subsequence with probability t!1 and so fails to cover it with probability
t!−1
t! . Then N permutations of {0, . . . , v − 1} chosen uniformly at random and in!
"N
dependently together fail to cover a specific t-subsequence with probability t!−1
.
t!
v!
There are (v−t)!
t-subsequences. When N permutations are chosen, each subsequence
"N
!
. Thus the expected number of uncovered
is not covered with probability t!−1
t!
!
"
! t!−1 "N
v!
t!−1 N
v!
t-subsequences is (v−t)!
.
When
< 1, a SeqCA(N ; t, v) must
t!
(v−t)!
t!
v!
t!
exist. This holds whenever N > (log( (v−t)!
))/(log( t!−1
)).

3.1. One permutation at a time. Lemma 3.1 provides a useful upper bound
on the size of completely t-scrambling sets of permutations but does not provide
an eﬀective method to find such arrays. Stein [34], Lovász [26], and Johnson [22]
develop a general strategy for finding solutions to covering problems; this algorithm
has been shown to lead to polynomial time methods in many combinatorial covering
problems [3, 4, 7, 9, 10]. We extend that strategy here to treat sequence covering
arrays.
The basic approach is greedy. Repeatedly select one permutation to add that
covers a large number of as-yet-uncovered t-subsequences, until all are covered. Stein
[34], Lovász [26], and Johnson [22] each suggest selecting to maximize the number of
newly covered elements, but their analyses require only that the next selection cover
at least the average. If after i permutations are selected there remain Ui uncovered
t-subsequences, then a permutation selected uniformly at random is expected to cover
Ui t!1 t-subsequences for the first time. Provided that we select the (i+1)st permutation
to cover at least Ui t!1 t-subsequences for the first time, we have that Ui+1 ≤ Ui t!−1
t! .
v!
v!
i
, we have that Ui ≤ (v−t)!
( t!−1
)
.
Choose
N
to
be
the
smallest
Because U0 = (v−t)!
t!

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

1850

Y. M. CHEE, C. J. COLBOURN, D. HORSLEY, AND J. ZHOU

value for which UN < 1; then there must be a sequence covering array with N
permutations.
This simply restates the argument of Lemma 3.1, but with two important improvements. It derandomizes the method by ensuring that appropriate selection of
each permutation guarantees that the bound is met, rather than asserting the existence of a set of permutations that meets it. More importantly, the time to construct
the sequence covering array is polynomial in the number of permutations and the time
to select a permutation that covers at least the average.
For fixed t the number of permutations is logarithmic in v, and so an algorithm
with running time polynomial in v will result if we can select the next permutation
in time polynomial in v. Because the details are quite similar to earlier approaches,
we merely outline how this can be done.
Suppose that U consists of the as-yet-uncovered t-subsequences. For U ∈ U,
let cov(π, U ) = 1 when π covers U , and cov(π, U ) = 0 otherwise. Let R be an rsubsequence; the r symbols in R are fixed, and the remaining v − r are free. There
is a set PR of v!
r! permutations that cover R. We focus on the expected number of
members of U that are covered by a member of PR chosen uniformly at random;
this is
r! ( (
ec(R) =
cov(π, U ).
v!
π∈PR U∈U

The strategy is to find a sequence of subsequences P0 , . . . , Pv , so that Pi is an
i-subsequence, Pi+1 covers Pi for 0 ≤ i < v, symbol i is free in Pi but fixed in Pi+1 ,
and ec(Pi+1 ) ≥ ec(Pi ) for 0 ≤ i < v. Because ec(P0 ) = t!1 |U|, it follows that Pv is a
permutation that covers at least t!1 |U| of the as-yet-uncovered t-subsequences. Given
a selection of Pi , there are precisely i + 1 candidates {C1 , . . . , Ci+1 } for Pi+1 obtained
by placing symbol i in one of the i + 1 positions of Pi . Our task is to choose one for
which ec(Cj ) ≥ ec(Pi ), in order to set Pi+1 = Cj .
A naive computation of ec(Cj ) would enumerate members of U and of PCj ,
but)the latter may have size exponential in v. Instead, for U ∈ U let ec(U, R) =
r!
π∈PR cov(π, U ), and observe that
v!
(
ec(U, R).
ec(R) =
U∈U

When t is fixed, U contains fewer than v t subsequences, which is polynomial
in v. Therefore it suﬃces to compute ec(U, R) eﬃciently, given a t-subsequence U
and an r-subsequence R. Let τ be the number of symbols appearing in both U and
R. When the τ symbols in common do not appear in the same order in U and R,
ec(U, R) = 0. Otherwise let T be the τ -subsequence that they have in common. Then
ec(U, R) = ec(U, T ) = τt!! .
)i+1
1
The key observation in selecting Pi+1 is that ec(Pi ) = i+1
j=1 ec(Cj ). Computing ec(Cj ) for 1 ≤ j ≤ i + 1, and selecting Pi+1 to be the one that maximizes ec(Cj ),
we are then sure that ec(Pi+1 ) ≥ ec(Pi ).
Combining all of these arguments, we have established the next theorem.
Theorem 3.2. For fixed t and input v, there is an algorithm to construct a
v!
t!
))/(log( t!−1
)) permutations in time that is
SeqCA(N ; t, v) having N ≤ 1 + (log( (v−t)!
polynomial in v.
This algorithm can be easily implemented, and we report results from it in
section 5. One immediate improvement results from observing that the counts of

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

SEQUENCE COVERING ARRAYS

1851

as-yet-uncovered t-subsequences (R0 , R1 , . . . , RN ) must be integers. Hence we have
that Ri+1 ≤ ⌊Ri t!−1
t! ⌋. In specific cases this improves on the bound, without the need
to construct the sequence covering array. If, however, the sequence covering array
is explicitly constructed, at each selection of Pi+1 from Pi , we can choose Pi+1 to
maximize ec() among the i + 1 candidates.
3.2. Greedy methods with reversals. The methods developed are greedy in
that they attempt to cover the largest number of as-yet-uncovered t-subsequences.
The very first permutation chosen is arbitrary; all are equally eﬀective at coverage.
Once one is selected, however, there is a genuine choice for the second. Greedy
selection indicates that we should choose one that covers no t-subsequence already
covered by the first. Indeed when t = 2, choosing the reversal of this first covers all
remaining t-subsequences.
For t ≥ 3, suppose that we have chosen 2s permutations π1 , . . . , π2s , and suppose
further that π2i is the reverse of π2i−1 for 1 ≤ i ≤ s. It follows that the number of
as-yet-uncovered t-subsequences covered by a permutation π is precisely the same as
the number covered by the reverse of π. Yet π and its reverse never cover the same
t-subsequence. Hence if the algorithm were to select π next, the reverse of π remains
an equally beneficial choice immediately thereafter. Therefore a useful variant of the
algorithm developed, after adding a permutation π to the array, always adds the
reverse of π as well. Pursuing this, we obtain the following.
Theorem 3.3. For fixed t and input v, there is an algorithm to construct a
v!
t!
))/(log( t!−2
)) permutations in time that is
SeqCA(N ; t, v) having N ≤ 2(log( (v−t)!
polynomial in v.
Naturally, we could again obtain small improvements in practice because every
count of as-yet-uncovered t-subsequences is an integer.
In principle, always including reversals improves slightly on the bound (that is,
Theorem 3.3 improves on Theorem 3.2). Whether this is a practical improvement
remains to be seen; we return to this point.
4. Product constructions. Product (or “cut-and-paste” or “Roux-type”) constructions are well studied for covering arrays; see, for example, [11, 6]. We develop
a product construction for completely 3-scrambling sets of permutations. To do this,
we first introduce an auxiliary property. A signing of a CSSP(N ; t, v) A = (aij ) is an
N × v matrix S = (sij ) with entries {↑, ↓}. A CSSP(N ; t, v) A is properly signed by
an N × v matrix S with entries {↑, ↓}. When for every set of t − 1 distinct columns
c1 , . . . , ct−1 , each sign s ∈ {↑, ↓}, and every permutation π of 1, . . . , t − 1, there exists
a row ρ of A for which, for every 1 ≤ a < b < t, the entry in cell (ρ, cπ(a) ) is less than
the entry in row (ρ, cπ(b) ), and the sign sρ,c1 = s. A properly signed CSSP(7;3,5) is
shown in Table 4.1.
We defer for the moment the question of how to sign a completely t-scrambling
set of permutations.
4.1. Products for strength three.
Theorem 4.1. If a properly signed CSSP(N ; 3, v) and a properly signed
CSSP(M ; 3, w) both exist, so does a properly signed CSSP(N + M ; 3, vw).
Proof. Let A = (aij ) be a CSSP(N ; 3, v) having sign matrix S = (sij ) with columns
indexed by {0, . . . , v − 1}. Let B = (bij ) be a CSSP(M ; 3, w) having sign matrix T =
(tij ) with columns indexed by {0, . . . , w − 1}. Form an array C = (cρ,(i,j) ) on N + M
rows and vw columns with columns indexed by {0, . . . , v − 1} × {0, . . . , w − 1}. In row
ρ for 1 ≤ ρ ≤ N , in column (i, j), place the entry aρi w + j if sρi =↑, aρi w + (w − 1 − j)

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

1852

Y. M. CHEE, C. J. COLBOURN, D. HORSLEY, AND J. ZHOU

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

Table 4.1
Properly signed CSSP(7; 3, 5) – t = 3, v = 5, N = 7. All signs not specified can be selected
arbitrarily.
0↑
1↓
2↓
2↓
2
4↑
4

4↑
2↓
0↑
1↓
3↓
1
3

2↓
3↓
4↑
0↑
0↓
2
2
(7;3,5)

3↓
0↑
3↓
3
4↑
3
0↓

1↓
4↑
1↓
4↓
1
0↑
1

if sρi =↓. In row N + ρ for 1 ≤ ρ ≤ M , in column (i, j), place the entry bρj v + i if
tρj =↑, bρj v + (v − 1 − i) if tρj =↓.
To show that C is a CSSP(N + M ; 3, vw), we must establish that every 3subsequence is covered. Consider three columns (i1 , j1 ), (i2 , j2 ), (i3 , j3 ), in this order. If i1 , i2 , and i3 are all distinct, there is a row ρ of A in which aρi1 < aρi2 < aρi3 .
Then in C row ρ has the three specified columns in the chosen order. By the same
token, if j1 , j2 , and j3 are all distinct, there is a row ρ of B in which bρj1 < bρj2 < bρj3 .
Then in C row ρ + N has the three specified columns in the chosen order. If {i1 , i2 , i3 }
contains only one element, {j1 , j2 , j3 } contains three distinct elements; symmetrically,
if {j1 , j2 , j3 } contains only one element, {i1 , i2 , i3 } contains three distinct elements.
So it remains only to treat cases in which both {i1 , i2 , i3 } and {j1 , j2 , j3 } contain two
distinct elements.
Now suppose that the three columns are {(i1 , j1 ), (i1 , j2 ), (i2 , j1 )}; we are concerned with the six orderings of the elements {c(i1 ,j1 ) , c(i1 ,j2 ) , c(i2 ,j1 ) }, which we represent by giving the indices in the sorted order for {c(i1 ,j1 ) , c(i1 ,j2 ) , c(i2 ,j1 ) }, as shown
next.
j2
j1
i1 c(i1 ,j1 ) c(i1 ,j2 )
1 2
1 3
2 1
2 3
3 1
3 2
i2 c(i2 ,j1 )
3
2
3
1
2
1
Table 4.2 gives the rows in which each of the six orderings is covered; we use
sgn(x − y) to be ↓ if x < y, ↑ if x > y. Two of the orderings are covered at least
twice.
To sign C properly, assign ↑ to each entry in each of the first N rows and ↓ to
each entry in each of the last M rows.
A small example, combining two CSSP(6;3,4)s to form a CSSP(12;3,16), is shown
in Table 4.3.
Use the strategy in the proof of Theorem 4.1, taking B and T from
⎛
⎞
0↑ 1↑
⎜ 0↓ 1↓ ⎟
⎜
⎟
⎝ 1 ↑ 0 ↑ ⎠,
1↓ 0↓

to establish the next theorem.
Theorem 4.2. If a properly signed CSSP(N ; 3, v) exists, so does a properly signed
CSSP(N + 4; 3, 2v).

4.2. Signing a completely t-scrambling set of permutations. We first give
one technique for signing that applies for all strengths.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

1853

SEQUENCE COVERING ARRAYS

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

Table 4.2
Verification for six orderings.
Row in C

Condition on ρ

Sign condition

ρ

aρi1 < aρi2

sρi1 = sgn(j2 − j1 )

ρ

aρi1 < aρi2

sρi1 = sgn(j1 − j2 )

ρ

aρi1 > aρi2

sρi1 = sgn(j2 − j1 )

ρ

aρi1 > aρi2

sρi1 = sgn(j1 − j2 )

ρ+N

bρj1 < bρj2

tρj1 = sgn(i2 − i1 )

ρ+N

bρj1 < bρj2

tρj1 = sgn(i1 − i2 )

ρ+N

bρj1 > bρj2

tρj1 = sgn(i2 − i1 )

ρ+N

bρj1 > bρj2

tρj1 = sgn(i1 − i2 )

Ordering
1
3
2
3
2
1
3
1
1
2
2
1
2
3
3
2

2
1
3
2
3
3
1
1

Table 4.3
Example: Properly signed CSSP(6; 3, 4) and its product with itself, a CSSP(12; 3, 16).

0↓
1↑
1↑
3↑
1↑
3↓

1↑
0↓
3↓
1↑
3↑
1↑

2↑
3↓
0↓
0↑
2↑
2↑

3↓
2↑
2↑
2↑
0↑
0↓

3
4
4
12
4
15
3
4
4
12
4
15

2
5
5
13
5
14
4
3
15
4
12
4

1
6
6
14
6
13
8
15
3
0
8
8

0
7
7
15
7
12
15
8
8
8
0
3

4
3
15
4
12
4
2
5
5
13
5
14

5
2
14
5
13
5
5
2
14
5
13
5

6
1
13
6
14
6
9
14
2
1
9
9

7
0
12
7
15
7
14
9
9
9
1
2

8
15
3
0
8
8
1
6
6
14
6
13

9
14
2
1
9
9
6
1
13
6
14
6

10
13
1
2
10
10
10
13
1
2
10
10

11
12
0
3
11
11
13
10
10
10
2
1

15
8
8
8
0
3
0
7
7
15
7
12

14
9
9
9
1
2
7
0
12
7
15
7

13
10
10
10
2
1
11
12
0
3
11
11

12
11
11
11
3
0
12
11
11
11
3
0

Lemma 4.3. Whenever a CSSP(N ; t, v) exists, a properly signed CSSP(N ; t, v −1)
exists.
Proof. Let A = (aij ) be a CSSP(N ; t, v). Form an N × (v − 1) array S = (sij )
with sij = sgn(aij − ai,v−1 ). Form an N × (v − 1) array B = (bij ) with bij = aij if
aij < ai,v−1 and bij = aij − 1 otherwise. Then B is a CSSP(N ; t, v − 1) that is properly
signed by S.
Let A be a CSSP(N ; t, v) and A1 , A2 be arrays that partition the rows of A. When,
for i = 1, 2, Ai is a CSSP(Ni ; t − 1, v), A is a partitionable CSSP.
Lemma 4.4. Whenever a partitionable CSSP(N ; t, v) exists, a properly signed
CSSP(N ; t, v) exists.
Proof. Let A be a CSSP(N ; t, v) with partition A1 , A2 . Assign sign ↑ to every
entry of A1 and ↓ to every entry of A2 .
Corollary 4.5. Whenever a CSSP(N ; 3, v) contains a row and its reverse, it is
partitionable and hence can be properly signed.
Proof. Place the row and its reverse in A1 and all other rows in A2 . Then A1 is a
CSSP(N ; 2, v). Moreover, A2 is a CSSP(N ; 2, v) because for every i, j ∈ {0, . . . , v − 1}
with i ̸= j, in A there are at least three rows in which the entry in column i is less
than that in column j. Then A is partitionable, so apply Lemma 4.4.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

1854

Y. M. CHEE, C. J. COLBOURN, D. HORSLEY, AND J. ZHOU

Lemma 4.4 provides a suﬃcient condition for a CSSP(N ; 3, v) to have a proper
signing but considers only signings in which all entries in each row receive the same
sign. Column c is properly signed when, for every set of t − 1 distinct columns
c1 , c2 , . . . , ct−1 with c1 = c, each sign s ∈ {+, −}, and every permutation π of
1, . . . , t − 1, there exists a row ρ of A for which, for every 1 ≤ a < b < t, the entry in cell (ρ, cπ(a) ) is less than the entry in row (ρ, cπ(b) ), and the sign sρ,c = s.
Properly signing the N × v array A is equivalent to properly signing each column of
A; the important fact is that signs assigned in one column are unrelated to signs in
any other, and so one can (hope to) proceed by signing each column separately.
Consider the case of strength t = 3. What does it mean to properly sign a
specific column c? For every column i other than c we form two sets: Ai contains
the row indices in which the entry in column i is larger than that in column c, and
Bi (= {1, . . . , N }\Ai ) contains the row indices in which the entry in column i is smaller
than that in column c. We can consider these sets as the edges of a hypergraph H on
vertex set {1, . . . , N }. Then H has 2v − 2 edges each containing at least three vertices
and a proper 2-coloring of H corresponds to a proper signing of c. Lemma 4.4 and
Corollary 4.5 give proper 2-colorings. In all examples that we have examined, each
column can be properly signed by finding a suitable 2-coloring. Hence it is plausible
that every CSSP(N ; 3, v) can be properly signed, but if this is true the proof is elusive
at the moment.
5. Computational results. In [23], a simple greedy method is used to compute
upper bounds on SeqCAN(t, v) for t ∈ {3, 4} and small values of v. These are reported
in column K in Tables 5.1 and 5.2. Results from a more sophisticated greedy method
by Erdem et al. [16] are reported in column ER. Using techniques from constraint
satisfaction, in particular answer set programming, much more sophisticated search
methods have been applied to strengths three and four [1, 2, 16]. Banbara, Tamura,
and Inoue [1] implement an answer set programming method and show bounds for
SeqCAN(3, v) for v ≤ 80 and for SeqCAN(4, v) for v ≤ 23. These bounds appear in
column BTI in Tables 5.1 and 5.2. Results by Brain et al. [2] are reported in column
BR in Tables 5.1 and 5.2. In [18], bounds for t ∈ {3, 4, 5} and v ≤ 10 are reported
from a method called the “bees algorithm”; these oﬀer modest improvements on the
greedy method in [23]. We do not report them for t ∈ {3, 4} because they are not
competitive with the results in [1]; we do report them for t = 5 in column BA, because
they are the only published computational results. When t = 3, Tarui [36] establishes
"
!
) ≤ q for all q ≥ 4; these are reported in
by direct construction that SeqCAN(3, ⌊q/2⌋
⌊q/4⌋
column TA.
The bound U is obtained by computing the number Ui of as-yet-uncovered tsubsequences using Ui+1 = ⌊ t!−1
t! Ui ⌋ and terminating with the first value N for which
UN = 0. (This does not explicitly construct the array but rather yields a number of
rows for which it can surely be produced.) In the same manner, bound UR is obtained
by including reversals, so that Ui+2 = Ui − 2⌈ t!1 Ui ⌉ when i is even. The bound D is
obtained by applying the algorithm that establishes Theorem 3.2 and that of DR by
applying the algorithm that establishes Theorem 3.3.
Table 5.1 reports results for t = 3. The theoretical results indicate that including
reversals accelerates coverage, and so the bound UR improves on the bound U. Neither
is competitive with greedy bounds from [23], given by K. In turn these are improved
upon by the greedy method from [16], given by ER. Implementing our greedy approach
nevertheless results in useful improvement to the two earlier greedy bounds, whether
reversals are included or not. It comes as no surprise that the answer set programming

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

1855

SEQUENCE COVERING ARRAYS

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

Table 5.1
Upper bounds on SeqCAN(3, v).
Events
v
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
40
50
60
70
80
90

TA
8
8
8
10
10
10
10
12
12
12
12
12
12
12
12
12
12
14
14
14
14
14
14
14
14
14
14
16
16
16
16
18
18

U
12
17
20
23
26
28
30
32
33
35
36
37
39
40
41
42
42
43
44
45
46
46
47
48
48
49
49
54
58
61
64
66
68

UR
12
16
18
22
24
26
28
30
30
32
34
34
36
36
38
38
38
40
40
40
42
42
42
44
44
44
46
50
52
56
58
60
62

t=3
K
ER
8
10
12
12
14
14
11
14
16
16
16
18
18
20
20
22
22
19
22
22
24
24
24
24
26
26
26
26
23
32
27
34
31
38
34
40
36
42
38
44

DR
8
10
10
12
12
12
14
14
14
16
16
16
16
18
18
18
18
18
20
20
20
20
20
20
20
22
22
24
26
26
28
30
30

D
6
8
8
9
10
11
12
12
13
13
14
14
15
15
16
16
16
17
17
17
17
18
18
18
18
19
19
21
23
24
25
26
27

BTI

BR

7
8
8
8
9
9
10
10
10
10
10
11
11
12
12
12
12
13
14
14
14
14
14
14
15
15
17
19
21
22
24

7
8
8
8
9
9
10
10
10
10
10
10
11
12
12
12
12
12
13
13
14
14
14
14
14
15
17
18
20
22
23

methods from [1, 2] (BTI, BR) yield consistent improvements on all the greedy methods
for strength three. However, the direct construction of Tarui [36] provides better
results at this time whenever v ≥ 30.
Perhaps the most perplexing pattern is the regularity with which D yields a better
bound than does DR . Remarkably, we consistently produce smaller sequence covering
arrays when we do not automatically include reversals! The reasons for this are quite
unclear at the present time.
Table 5.2 gives results for strengths four and five. For strength four, our improvements on the method from [23] are more dramatic than for strength three. Surprisingly, the answer set programming technique from [1] obtains a better result than our
greedy methods only when v ≤ 8. For 9 ≤ v ≤ 23, our greedy method yields much
smaller arrays. (For v = 23, we employ 98 permutations as opposed to the 112 in
BTI.) A similar comparison applies with the results from [2, 16] reported in column BR.
Of course, we expect that given enough time, the answer set programming techniques
would improve upon our greedy bounds.
However, our methods require polynomial time in theory and are eﬀective in
practice for larger problems than those considered in [2, 1]; despite these “limitations,”
our methods appear to yield better results within the time available.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

1856

Y. M. CHEE, C. J. COLBOURN, D. HORSLEY, AND J. ZHOU

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

Table 5.2
Upper bounds on SeqCAN(t, v) for t ∈ {4, 5}.
Events
v
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
40
50
60
70
80
90

U
24
54
79
98
114
128
140
151
160
169
177
184
191
197
203
209
214
219
224
228
232
236
240
244
248
251
255
283
305
322
337
350
361

UR
24
54
78
96
112
126
138
148
158
166
174
180
188
194
200
204
210
214
220
224
228
232
236
240
242
246
250
278
298
316
330
342
354

K
24
29
38
50
56
68
72
78
86
92
100
108
112
118
122
128
134
134
140
146
146
152
158
160
162
166
166
198
214
238
250
264
-

t=4
DR
24
24
32
40
44
50
56
60
64
70
74
78
80
84
86
90
92
96
98
98
102
104
106
108
110
112
114
132
146
154
166
174
180

D
24
26
34
41
47
52
57
61
66
71
73
78
81
84
86
91
92
95
97
99
101
104
105
107
110
111
113
128
141
151
160
168
176

BTI
24
24
38
44
52
58
65
69
77
81
84
89
91
97
100
105
104
111
112

BR

55

104

149
181

U

UR

120
294
437
552
648
731
803
868
926
978
1027
1072
1113
1152
1189
1223
1256
1286
1316
1344
1370
1396
1420
1444
1466
1488
1671
1811
1924
2019
2101
2173

120
294
436
550
646
728
800
864
922
976
1024
1068
1110
1148
1184
1218
1252
1282
1310
1338
1366
1390
1416
1438
1460
1482
1664
1804
1916
2012
2092
2164

t=5
DR
120
148
198
242
282
318
354
384
416
446
470
496
518
540
560
582
600
622
636
654
674
688
706
718
734
748

D
120
149
200
243
284
322
356
386
419
448
475
501
521
547
570
590
610
629
646
665
682
698
715
732
746
760

BA

159
212
271
329
383

A somewhat diﬀerent pattern with respect to reversals is evident for strength
four: The theoretical bound profits by including reversals throughout, but the implemented construction method appears first to benefit from reversals (for v ≤ 20)
but later no longer benefit (for 40 ≤ v ≤ 90). Again the reasons for this are unclear.
When v = 90, our methods track the coverage of 61,324,560 4-subsequences; thus,
while the methods scale polynomially with v, the computations are nonetheless quite
extensive. There is a CSSP(24;4,6) [28], but our methods do not yield fewer than 32
permutations.
For strength five, none of the published methods in [1, 16, 23] report computational results, so it is diﬃcult to make any comments about relative accuracy. However, the answer set programming methods do appear to require substantially more
storage, which limits to a degree their eﬀective range. To apply our methods would
require tracking the coverage of 78,960,960 5-subsequences for v = 40; despite the
eﬃciency of our methods, a straightforward implementation encounters both storage
and time limitations. The method BA [18] is not competitive with our greedy methods.
Within the range computed, including reversals improves our results. The pattern
thereafter is unknown. Again, there is a CSSP(120;5,6) [25], but our methods do not
yield fewer than 148 permutations.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

SEQUENCE COVERING ARRAYS

1857

6. Using the product construction. For strength three, Theorem 4.1 provides
substantial improvements on the computational results from the greedy methods. We
properly signed a CSSP(6;3,4) in Table 4.3 and a CSSP(7;3,5) in Table 4.1. Table 6.1
shows proper signings for further arrays from [1].
We obtain CSSP(N ; 3, v) for (v, N ) ∈ {(40, 15), (80, 17), (128, 18), (160, 19),
(256, 20), (288, 21)} by using these in Theorem 4.1. These improve upon all the computational results! For example, while in [1] it is shown that SeqCAN(3, 80) ≤ 24
and in [2] that SeqCAN(3, 80) ≤ 23, here it is shown that SeqCAN(3, 80) ≤ 17. The
examples given also provide better bounds than those of Tarui [36], but Theorem 4.1
does not outperform the direct construction asymptotically.
7. Constraints. In the testing application, it may happen that not every permutation of the events can in fact be executed; see [2, 23, 24]. It is therefore reasonable to ask how constraints on the execution order aﬀect the number of permutations needed and how they aﬀect the diﬃculty of finding a sequence covering array. We briefly consider the latter, in order to examine connections with further
problems.
Let Σ = {0, . . . , v − 1}. Let C be a set of subpermutations of Σ, called constraints.
A constrained sequence covering array SeqCA(N ; t, v, C) is a set Π = {π1 , . . . , πN }
where πi is a permutation of Σ that does not cover any subpermutation in C, and
every t-subsequence of Σ that does not cover any subpermutation in C is covered by
at least one of the permutations {π1 , . . . , πN }.
Even in the easiest case, when t = 2 and all constraints are 2-subpermutations,
the nature of the problem changes dramatically. Imposing the subpermutation constraint that b cannot precede a is the same as enforcing the precedence constraint that
a precede b. When the precedence constraints contain a cycle, it is impossible to meet
all constraints. This can be easily checked. When the constraints are acyclic, there is
a permutation that covers no constraint. However, covering all 2-subpermutations not
in C requires more. Let C r be the set of 2-subpermutations obtained by reversing each
2-subpermutation in C. Suppose that a SeqCA(N ; 2, v, C) exists. Every permutation
in the sequence covering array covers every 2-subpermutation in C r . Equivalently,
treating C r as a partial order, every permutation gives a linear extension of the partial order. When (a, b) ∈ C, (b, a) must be covered by every permutation in the
sequence covering array. When {(a, b), (b, a)} ∩ C = ∅, some but not all permutations
in the sequence covering array cover (a, b)—and the rest cover (b, a). Hence the set
of 2-subpermutations covered by every permutation in the sequence covering array
is exactly C r . This establishes a connection with the theory of partial orders. The
dimension of a partial order is the smallest number of linear extensions whose intersection is the partial order [37, 38]. Our discussion establishes that a SeqCA(N ; 2, v, C)
exists if and only if the dimension of the partial order induced by C r is at most N .
Hence we have the next lemma.
Lemma 7.1. Deciding whether a SeqCA(N ; 2, v, C) exists is NP-complete, even
when C is an acyclic set of 2-subpermutations.
Proof. Yannakakis [41] shows that determining whether a partial order has dimension at most 3 is NP-complete.
Brain et al. [2] establish the NP-completeness of a related problem in which the
subsequences to be covered, the constraints, and the permutations allowed are all
specified. Lemma 7.1 is in stark contrast with the existence of sequence covering
arrays of strength two without constraints. Nevertheless, the complexity arises in
determining whether a small sequence covering array exists in these cases, not in

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

1858

Y. M. CHEE, C. J. COLBOURN, D. HORSLEY, AND J. ZHOU

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

Table 6.1
Small properly signed CSSP(N ; 3, v)s. Signs not shown can be chosen arbitrarily.
8↑ 5↑ 6↓ 2↑ 3↓ 7↑ 1↑ 4↓
1↑ 2↑ 8↑ 4↑ 5↓ 7↑ 6↓ 3↓
6↓ 5↓ 7 8↑ 3 2↓ 4↓ 1↑
5↓ 7↑ 4↓ 3↓ 8↑ 1↑ 6 2
3↓ 7↓ 4 2↓ 1↑ 5↓ 8↑ 6↓
6 2↓ 1↑ 3 8 7↓ 4↓ 5
2 7 3↓ 6 4 5 1 8↑
5 1 3 8↓ 4↓ 2 6 7
(8;3,8)

10↑ 4↓ 5↑ 6↑ 8↓ 1↑ 3↑ 2↓ 9↑ 7↑
2↑ 10↑ 6↑ 5↑ 4↓ 8↑ 7 1↑ 9↑ 3↑
8 6 1↓ 5↑ 10↑ 3 9↑ 7↓ 4↓ 2↓
5↑ 3↓ 9↓ 10↓ 1↑ 8↑ 4↑ 6↓ 7↓ 2↓
2↓ 5 7↑ 4↓ 8 9↓ 3↓ 10↑ 1↑ 6
6 8 1 10 7 5↓ 2↓ 4 3 9
9↓ 10↓ 8↓ 3 5↓ 2 4 7 1 6↑
5↓ 1↑ 7 3↓ 2 4↓ 9 8 6↓ 10↓
3 5 1 2 9 7 10↓ 4 6 8
(9;3,10)

2↑ 14↑ 15↑ 5↑ 8↑ 3↓ 1↑ 11↑ 9↑ 7↑ 13↑ 12↑ 16↑ 6↑ 4↑ 10↑
14↑ 8↓ 3↑ 6↓ 7↓ 11 1↓ 16↑ 12↓ 13↓ 2↑ 10↓ 15↓ 5↓ 9 4↓
12↓ 16↓ 4 6↑ 3↑ 5 7 2↓ 1↑ 9 15↓ 11↓ 8 14↓ 10 13↓
12↓ 2↓ 13↓ 4↓ 3↓ 14↓ 9 6 11 1↑ 5↓ 15 10↓ 7↓ 16↑ 8↓
16 4 10↑ 5 12 9↓ 11 14↓ 1↓ 8 13 2↑ 7 15↑ 6↑ 3↑
6 4↑ 12 15 3 1↑ 11↓ 13 8 14↑ 10 5 2↓ 9 16↓ 7
2↓ 15 12↓ 11 6 8 13↓ 5 14↓ 7 3↓ 4↓ 9 16 10 1
5 9↑ 7 14↓ 16↑ 13 6 10↓ 12 1↓ 11 2 8 3↑ 4↓ 15
5 6 1↓ 15↑ 12 16↑ 10 2↑ 3 13↓ 4 11 9 8 7↓ 14
11↑ 7 8 4 15↓ 5 16↑ 6 14↑ 12 9↑ 13↑ 1↑ 2 3 10↑
(10;3,16)
1↑ 2↑ 3↑ 4↑ 5↑ 6↑ 7↑ 8↑ 9↑ 10↓ 11↑ 12↓ 13 14↑ 15↑ 16↓ 17↑ 18↑
4↓ 14↑ 11↑ 10↑ 6↑ 9↑ 13↓ 7↓ 17↑ 1↑ 18↑ 3↓ 2↑ 12↓ 16↑ 5↓ 8↓ 15↓
4↓ 17↓ 3 2 18↓ 16↓ 14↑ 7 9 13 11↓ 12 10↑ 8↓ 1↑ 6 15↓ 5↑
6 13 7↓ 8↓ 12 10 14 4↑ 16↓ 1 2↓ 18↑ 17↓ 15↑ 9 11 3↑ 5↑
7 18 6↓ 16↓ 4↓ 5 1↓ 17↑ 13 11 10 12 14 15 8↓ 2 9↑ 3
8 3↓ 15↓ 4↓ 9 17 2 16 11↓ 12 14 13 10↓ 7 6 1↑ 5 18
8 11 3 14 6↓ 15 13 5↓ 2↓ 16↓ 17↓ 1↑ 18↑ 7 10 9 4 12
10 7↓ 16 4 5 9↓ 13 15↓ 1 18↑ 3 17↓ 2 12 14 8 6 11
13 9↑ 16 14 15 11↑ 7 12 5↑ 4↓ 2↑ 1 3↓ 10↓ 6↓ 18↑ 17 8↓
18↑ 4 15↑ 17↑ 16↑ 2↓ 8↑ 1 11 13 9 12 10 3 6 14 7 5↓
18↓ 7 2 5 4 3 17↓ 10 15 11 14 12 13 1↑ 16↓ 9↓ 8↓ 6
(11;3,18)
19↑ 3↑ 5↑ 2↑ 6↑ 18↑ 9 10 14↑ 21↑ 20↑ 1↑ 15↓ 4↑ 12 22↑ 16↑ 7 13 8 11↑ 23↑ 17↑
2↓ 22↑ 13↓ 21↑ 7↑ 4↓ 1↑ 6↓ 18↓ 23↓ 15↓ 12 8 10↑ 19↑ 16↑ 17 11↑ 20↑ 3↑ 5↓ 14↑ 9↓
1↑ 21↓ 6↑ 7 4↓ 20 16↓ 18 10↓ 23 3↑ 13 17 9↓ 11↑ 14 2↑ 19↓ 8↑ 22↑ 12 15↓ 5
10 12↑ 5↓ 15 8↓ 13 23↑ 17↓ 22↑ 11 18 14 9 3↓ 4↓ 1↑ 16 2↑ 20↓ 21 19↓ 6 7↓
3 17↓ 22 4↓ 14 2↓ 7 13 1↑ 10↑ 9 16↑ 11↓ 12 23↓ 8 20↑ 19 18↓ 15 21 5 6↑
10 1↓ 19↓ 15↑ 3 14↑ 23↓ 4 12 11 8 18↓ 2 21↑ 16 6 17 20↑ 7 5↓ 9 13 22↓
20↑ 13 3 17↓ 18 7 14 10 22 9↓ 1↓ 16 11↓ 21 15 8↓ 4 6 2 5↓ 23↑ 19↓ 12↑
8 18 12 3 22↓ 11 14 1↑ 15 6 21↓ 5 10 19↓ 9 13 4↓ 2↓ 20 17 16 7 23
21↓ 2 12 15 22↑ 23↓ 3↓ 19↓ 8↓ 5↓ 16 17↑ 1↑ 20 6↑ 18 13↓ 7 9↑ 11 14↓ 4↓ 10
18 10 9 14↓ 7 17 8 6 5 15 16↑ 13 23↑ 11 4↓ 12 20↓ 21 1↓ 22↓ 3↑ 2↑ 19
16 10 14 9 21 12 7 23↑ 13 2↑ 4 19↓ 20 1 22 3↓ 8 17↓ 18 6↑ 5 15 11
15↓ 16 23↑ 21 12 3↑ 19 17 4 9 13 1↓ 18 14 5 22↓ 7 11 10 8 6 20 2
(12;3,23)

determining whether a sequence covering array exists. The situation is worse when
constraints have strength three.
Consider a collection T of ordered triples of distinct elements of Σ, and associate with (a, b, c) the constraints {(b, a, c), (b, c, a), (a, c, b), (c, a, b)}. Meeting these
constraints requires that b lie between a and c, and a collection of constraints of this
type forms an instance of the betweenness problem [5] in which one is required to

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

SEQUENCE COVERING ARRAYS

1859

order all items so that for every triple (a, b, c) ∈ T , b lies between a and c. Forming
C = {(b, a, c), (b, c, a), (a, c, b), (c, a, b) : (a, b, c) ∈ T }, even finding a single permutation that covers no 3-subpermutation in C appears hard:
Lemma 7.2 (see [30]). Determining whether an instance of the betweenness problem has a solution is NP-complete.
These complexity results suggest that constraints pose severe additional challenges
in the construction of sequence covering arrays. Checking feasibility can become diﬃcult; even when feasibility is easily checked, the minimization problem is substantially
more complicated.
8. Conclusions. The close connection between sequence covering arrays and
covering arrays has proved useful in establishing bounds on the sizes of sequence covering arrays. The eﬃcient conditional expectation algorithm for generating sequence
covering arrays and the product construction for strength three parallel analogous
results for covering arrays. Unfortunately, while sequence covering arrays lead to
covering arrays with excess coverage, additional conditions on such a covering array
would be required in order to recover a sequence covering array. Hence the parallels
between the extensive literature on covering arrays and the existence problem for
sequence covering arrays are primarily by analogy.
We have examined numerous formulations for sequence covering arrays. In closing, we indicate one more (see also [27]). A perfect hash family PHF(N ; k, w, t) is an
N × k array on w symbols in which in every N × t subarray, at least one row consists
of distinct symbols. Mehlhorn [29] introduced perfect hash families as an eﬃcient tool
for compact storage and fast retrieval of frequently used information; see also [14].
Stinson et al. [35] establish that perfect hash families can be used to construct separating systems, key distribution patterns, group testing algorithms, cover-free families,
and secure frameproof codes. They are also used extensively in product constructions
for covering arrays [8, 12, 13]. Completely t-scrambling sets of permutations can be
viewed as an ordered analogue of perfect hash families in which k = w, no element
appears twice in a row, and for every way to select t distinct columns in order there is
a row in which the elements in these columns are in increasing order. In particular, a
completely t-scrambling set of permutations provides a perfect hash family in which,
for every set of t columns, there are at least t! rows containing distinct symbols in the
chosen columns, and at least one for each of the t! symbol orderings. For this reason,
it appears reasonable to expect that constructions for perfect hash families may also
prove to be useful for sequence covering arrays.
Acknowledgments. Thanks to two anonymous referees for pointing out relevant
references. Special thanks to Mutsunori Banbara and Johannes Oetsch for providing
explicit solutions for small sequence covering arrays with t = 3.
REFERENCES
[1] M. Banbara, N. Tamura, and K. Inoue, Generating event-sequence test cases by answer
set programming with the incidence matrix, in Technical Communications of the 28th
International Conference on Logic Programming (ICLP12), 2012, pp. 86–97.
[2] M. Brain, E. Erdem, K. Inoue, J. Oetsch, J. Pührer, H. Tompits, and C. Yilmaz, Eventsequence testing using answer-set programming, Internat. J. Advances Software, 5 (2012),
pp. 237–251.
[3] R. C. Bryce and C. J. Colbourn, The density algorithm for pairwise interaction testing,
Software Testing, Verification, and Reliability, 17 (2007), pp. 159–182.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

1860

Y. M. CHEE, C. J. COLBOURN, D. HORSLEY, AND J. ZHOU

[4] R. C. Bryce and C. J. Colbourn, A density-based greedy algorithm for higher strength covering arrays, Software Testing Verification Reliability, 19 (2009), pp. 37–53.
[5] B. Chor and M. Sudan, A geometric approach to betweenness, SIAM J. Discrete Math., 11
(1998), pp. 511–523.
[6] M. B. Cohen, C. J. Colbourn, and A. C. H. Ling, Constructing strength three covering
arrays with augmented annealing, Discrete Math., 308 (2008), pp. 2709–2722.
[7] C. J. Colbourn, Constructing perfect hash families using a greedy algorithm, in Coding and
Cryptology, Y. Li, S. Zhang, S. Ling, H. Wang, C. Xing, and H. Niederreiter, eds., World
Scientific, Singapore, 2008, pp. 109–118.
[8] C. J. Colbourn, Covering arrays and hash families, in Information Security and Related
Combinatorics, NATO Peace and Information Security, IOS Press, Amsterdam, 2011,
pp. 99–136.
[9] C. J. Colbourn, Eﬃcient conditional expectation algorithms for constructing hash families, in
Combinatorial Algorithms, Lecture Notes in Comput. Sci., 7056, Springer-Verlag, Berlin,
2011, pp. 144–155.
[10] C. J. Colbourn, D. Horsley, and V. R. Syrotiuk, Strengthening hash families and compressive sensing, J. Discrete Algorithms, 16 (2012), pp. 170–186.
[11] C. J. Colbourn, S. S. Martirosyan, Tran Van Trung, and R. A. Walker II, Roux-type
constructions for covering arrays of strengths three and four, Des. Codes Cryptogr., 41
(2006), pp. 33–57.
[12] C. J. Colbourn and J. Torres-Jiménez, Heterogeneous hash families and covering arrays,
Contemp. Math., 523 (2010), pp. 3–15.
[13] C. J. Colbourn and J. Zhou, Improving two recursive constructions for covering arrays, J.
Statist. Theory Practice, 6 (2012), pp. 30–47.
[14] Z. J. Czech, G. Havas, and B. S. Majewski, Perfect hashing, Theoret. Comput. Sci., 182
(1997), pp. 1–143.
[15] B. Dushnik, Concerning a certain set of arrangements, Proc. Amer. Math. Soc., 1 (1950),
pp. 788–796.
[16] E. Erdem, K. Inoue, J. Oetsch, J. Pührer, H. Tompits, and C. Yilmaz, Answer-set programming as a new approach to event-sequence testing, in Proceedings of the 2nd International Conference on Advances in System Testing and Validation Lifecycle, Xpert
Publishing Services, 2011, pp. 25–34.
[17] Z. Füredi, Scrambling permutations and entropy of hypergraphs, Random Structures
Algorithms, 8 (1996), pp. 97–104.
[18] M. M. Z. Hazli, K. Z. Zamli, and R. R. Othman, Sequence-based interaction testing implementation using bees algorithm, in Proceedings of the IEEE Symposium on Computers
and Informatics, 2012, pp. 81–85.
[19] S. Huang, M. B. Cohen, and A. M. Memon, Repairing GUI test suites using a genetic algorithm, in Proceedings of the 3rd International Conference on Software Testing, Verification
and Validation (ICST), 2010, pp. 245–254.
[20] Y. Ishigami, Containment problems in high-dimensional spaces, Graphs Combin., 11 (1995),
pp. 327–335.
[21] Y. Ishigami, An extremal problem of d permutations containing every permutation of every t
elements, Discrete Math., 159 (1996), pp. 279–283.
[22] D. S. Johnson, Approximation algorithms for combinatorial problems, J. Comput. System Sci.,
9 (1974), pp. 256–278.
[23] D. R. Kuhn, J. M. Higdon, J. F. Lawrence, R. N. Kacker, and Y. Lei, Combinatorial methods for event sequence testing, in Proceedings of the IEEE 5th International Conference
on Software Testing, Verification and Validation (ICST), 2012, pp. 601–609.
[24] D. R. Kuhn, J. M. Higdon, J. F. Lawrence, R. N. Kacker, and Y. Lei, Combinatorial
methods for event sequence testing, CrossTalk J. Defense Software Engineering, 25 (2012),
pp. 15–18.
[25] V. I. Levenshteın, Perfect codes in the metric of deletions and insertions, Diskret. Mat., 3
(1991), pp. 3–20.
[26] L. Lovász, On the ratio of optimal integral and fractional covers, Discrete Math., 13 (1975),
pp. 383–390.
[27] O. Margalit, Better bounds for event sequence testing, in Proceedings of the 2nd International
Workshop on Combinatorial Testing, 2013.
[28] R. Mathon and Tran Van Trung, Directed t-packings and directed t-Steiner systems, Des.
Codes Cryptogr., 18 (1999), pp. 187–198.
[29] K. Mehlhorn, Data Structures and Algorithms 1: Sorting and Searching, Springer-Verlag,
Berlin, 1984.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.

Downloaded 12/11/13 to 155.69.4.4. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php

SEQUENCE COVERING ARRAYS

1861

[30] J. Opatrný, Total ordering problem, SIAM J. Comput., 8 (1979), pp. 111–114.
[31] J. Radhakrishnan, A note on scrambling permutations, Random Structures Algorithms, 22
(2003), pp. 435–439.
[32] J. Spencer, Minimal scrambling sets of simple orders, Acta Math. Acad. Sci. Hungar., 22
(1971/72), pp. 349–353.
[33] R. P. Stanley, Increasing and decreasing subsequences and their variants, in Proceedings of
the International Congress of Mathematicians, vol. I, Madrid, 2007, pp. 545–579.
[34] S. K. Stein, Two combinatorial covering theorems, J. Combin. Theory Ser. A, 16 (1974),
pp. 391–397.
[35] D. R. Stinson, Tran Van Trung, and R. Wei, Secure frameproof codes, key distribution
patterns, group testing algorithms and related structures, J. Statist. Plann. Inference, 86
(2000), pp. 595–617.
[36] J. Tarui, On the minimum number of completely 3-scrambling permutations, Discrete Math.,
308 (2008), pp. 1350–1354.
[37] W. T. Trotter, Jr., Some combinatorial problems for permutations, in Proceedings of the 8th
Southeastern Conference on Combinatorics, Graph Theory and Computing, Baton Rouge,
La., 1977, Utilitas Mathematica, Winnipeg, pp. 619–632.
[38] W. T. Trotter, Jr., Combinatorics and partially ordered sets, in Dimension Theory, Johns
Hopkins Ser. Math. Sci., Johns Hopkins University Press, Baltimore, MD, 1992.
[39] W. Wang, Y. Lei, S. Sampath, R. Kacker, D. Kuhn, and J. Lawrence, A combinatorial
approach to building navigation graphs for dynamic web applications, in Proceedings of
the 25th International Conference on Software Maintenance, 2009, pp. 211–220.
[40] W. Wang, S. Sampath, Y. Lei, and R. Kacker, An interaction-based test sequence generation
approach for testing web applications, in 11th IEEE High Assurance Systems Engineering
Symposium, 2008, pp. 209–218.
[41] M. Yannakakis, The complexity of the partial order dimension problem, SIAM J. Algebraic
Discrete Methods, 3 (1982), pp. 351–358.
[42] X. Yuan, M. B. Cohen, and A. M. Memon, Towards dynamic adaptive automated test generation for graphical user interfaces, in International Conference on Software Testing, Verification and Validation Workshops, 2009, pp. 263–266.
[43] X. Yuan, M. B. Cohen, and A. M. Memon, GUI interaction testing: Incorporating event
context, IEEE Trans. Software Engrg., 37 (2011), pp. 559–574.
[44] X. Yuan and A. M. Memon, Generating event sequence-based test cases using GUI runtime
state feedback, IEEE Trans. Software Engrg., 36 (2010), pp. 81–95.

Copyright © by SIAM. Unauthorized reproduction of this article is prohibited.


IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. X, NO. XX, MONTH YEAR

1

A Combinatorial Approach to X-Tolerant Compaction Circuits
Yuichiro Fujiwara and Charles J. Colbourn

arXiv:1508.00481v1 [cs.IT] 3 Aug 2015

Abstract--Test response compaction for integrated circuits (ICs) with scan-based design-for-testability (DFT) support in the presence of unknown logic values (Xs) is investigated from a combinatorial viewpoint. The theoretical foundations of Xcodes, employed in an X-tolerant compaction technique called X-compact, are examined. Through the formulation of a combinatorial model of X-compact, novel design techniques are developed for X-codes to detect a specified maximum number of errors in the presence of a specified maximum number of unknown logic values, while requiring only small fan-out. The special class of X-codes that results leads to an avoidance problem for configurations in combinatorial designs. General design methods and nonconstructive existence theorems to estimate the compaction ratio of an optimal X-compactor are also derived. Index Terms--Circuit testing, built-in self-test (BIST), compaction, X-compact, test compression, X-code, superimposed code, Steiner system, configuration.

I. I NTRODUCTION HIS work discusses a class of codes that arise in data volume compaction of responses from integrated circuits (ICs) under scan-based test. We first recall briefly the background of the X-tolerant compaction technique in digital circuit testing. Digital circuit testing applies test patterns to a circuit under test and monitors the circuit's responses to the applied patterns. A tester compares the observed response to a test pattern to the expected response and, if there is a mismatch, declares the circuit chip defective. Usually the expected responses are obtained through fault-free simulation of the chip. Test cost for traditional scan-based testing is dominated by test data volume and test time [1]. Therefore various test compression techniques have been developed to reduce test cost. One way to achieve this is to reduce test application time and the number of test patterns by employing automatic test pattern generation (ATPG) (see [2]­[5] and references therein). We are interested in the other kind of technique, using methods to hash responses while maintaining test quality. Signature analyzers (e.g., [6]­[10]) are vulnerable to error masking caused by unknown logic values (Xs) [11]. X-compact has been proposed in order to conduct reliable testing in the presence of Xs [12]. A response compaction circuit based
This work was supported in part by JSPS Research Fellowships for Young Scientists (YF) and by DOD grants N00014-08-1-1069 and N00014-08-11070 (CJC). Y. Fujiwara is with the Department of Mathematical Sciences, Michigan Technological University, Houghton, MI 49931 USA. yfujiwar@mtu.edu. C. J. Colbourn is with the School of Computing, Informatics, and Decision Systems Engineering, Arizona State University, Tempe, AZ 85287-8809 USA. charles.colbourn@asu.edu

T

on X-compact is an X-compactor. X-compactors have proved their high error detection ability in actual systems [11], [13]. An X-compactor can be written in matrix form as an X-code [14]. Basic properties of X-codes have been studied [14], [15]. Graph theoretic techniques have been employed to minimize fan-out of inputs [16]; in general an X-compactor tolerates the presence of Xs in exchange for large fan-out. These studies focus on particular classes of X-codes rather than the general coding theoretic aspects. The purpose of the present paper is to investigate theoretical foundations of X-codes and to provide general construction techniques. In Section II we outline the combinatorial requirements for the X-compact technique and present an equivalent definition of X-codes in order to investigate X-compactors as codes and combinatorial designs. Some basic properties of X-codes are also presented. In Section III we investigate X-codes that require only small fan-out and have good error detectability and X-tolerance. We prove the equivalence between a class of Steiner t-designs and particular X-codes having the maximum number of codewords and the minimum fan-out. This allows us to give constructions and to show existence of such X-codes. Section IV deals with existence of X-codes in the more general situation. Both constructive and nonconstructive theorems are provided. Finally we conclude in Section V. II. C OMBINATORIAL R EQUIREMENTS
AND

X-C ODES

We do not describe scan-based testing and response compaction in detail here, instead referring the reader to [11], [12]. Scan-based testing repeatedly applies vectors of test inputs to the circuit, and for each test captures a vector from {0, 1}n as the test output. Naturally it is important that the test output be the correct one. To determine this, the function of the circuit is simulated (in a fault-free manner) to produce a reference output. When the test and reference outputs agree, no fault has been detected. The first major obstacle is that fault-free simulation may be unable to determine whether a specific output is 0 or 1, and hence it is an unknown logic value X. The second is that if each output requires a separate pin on the chip, the number of tests that can be accommodated is quite restricted. We deal with these two problems in turn. We define an algebraic system to describe the behavior of Xs. The X-algebra X2 = ({0, 1, X}, +, ·) over the field F2 is the set {0, 1} of elements of F2 and a third element X, equipped with two binary operations "+" (addition) and "·" (multiplication) satisfying: 1) a + b and a · b are performed in F2 for a, b  F2 ;

2

IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. X, NO. XX, MONTH YEAR

2) a + X = X + a = X for a  F2 ; 3) 0 · X = X · 0 = 0 for the additive identity 0; 4) 1 · X = X · 1 = X. The element X is termed an unknown logic value. Now consider a test output b = (b1 , . . . , bn )  {0, 1}n and a reference output c = (c1 , . . . , cn )  {0, 1, X}n . When ci  {0, 1}, the test and reference outputs agree on the ith bit when bi = ci ; otherwise the ith bit is an error bit. When ci = X, whatever the value of bi , no error is detected. Thus the ith bit is (known to be) in error if and only if bi + ci = 1, using addition in X2 . Turning to the second problem, an X-compact matrix is an n × m matrix H with elements from {0, 1}. The compaction ratio of H is n/m. The number of 1s in the ith row is the weight, or fan-out, of row i. Output (or response) compaction is performed by computing the vector d = (d1 , . . . , dm ) = bH for output (arithmetic is in X2 ). In the same way, the reference output can be compacted using the same matrix to form r = (r1 , . . . , rm ) = cH . As before, if di = ri and ri = X (that is, if di + ri = 1), an error is detected. To be of practical value, an X-compact matrix H should detect the presence of error bits in b with respect to c given the compacted vectors d and r under `reasonable' restrictions on the number of errors and number of unknown logic values. Suppose that b + c = 1 (so that there is a fault to be detected). In principle, whenever hj = 1, the fault could be observed on output j . Let L = {j : hj = 1}. Suppose then n that j  L. If it happens that i=1 ci hij = X, the error at position  is masked for output j (that is, dj + rj = X, and no error is observed). On the other hand, if
n n n

of X-codes. In order to investigate X-codes from coding and design theoretic views, we introduce an equivalent definition. Consider two m-dimensional vectors s1 = (1) (1) (1) (2) (2) (2) (s1 , s2 , . . . , sm ) and s2 = (s1 , s2 , . . . , sm ), where (j ) si  F2 . The addition of s1 and s2 is bit-by-bit addition, denoted by s1  s2 ; that is,
(2) s1  s2 = (s1 + s1 , s2 + s2 , . . . , s(1) m + sm ). (1) (2) (1) (2)

The superimposed sum of s1 and s2 , denoted s1  s2 , is
(2) s1  s2 = (s1  s1 , s2  s2 , . . . , s(1) m  sm ), (1) (2) (1) (2) (j ) ( l) (j ) ( l)

where si  sk = 0 if si = sk = 0, otherwise 1. An m-dimensional vector s1 covers an m-dimensional vector s2 if s1  s2 = s1 . For a finite set S = {s1 , . . . , ss } of m-dimensional vectors, define S = s1  · · ·  ss and S = s1  · · ·  ss .

When S = {s1 } is a singleton, S = S = s1 . For S =  we define S = S = 0, the zero vector. Let d be a positive integer and x a nonnegative integer. An (m, n, d, x) X-code X = {s1 , s2 , . . . , sn } is a set of mdimensional vectors over F2 such that |X | = n and ( S1 )  ( S2 ) = S1 .

dj + rj =
i=1

bi hij +
i=1

ci hij =
i=1

(bi + ci )hij = 0

then no error is observed. This occurs when there are an even number of values of i for which hij = 1 and bi + ci = 1; because this holds when i =  by hypothesis, the error at position  is canceled for output j when the number of such errors is even. When an error is masked or canceled for every output j  L, it is not detected. Otherwise, it is detected by an output that is neither masked nor canceled. Treating X's as erasures and using traditional codes can increase the error detectability of an X-compactor [17]. Unfortunately, this involves postprocessing test responses and cannot be easily implemented [12]. Therefore, we focus on X-compaction in which an error is only detected by the simple comparison described here. There are numerous criteria in defining a "good" X-compact matrix. It should have a high compaction ratio and be able to detect any faulty circuit behavior anticipated in actual testing. Power requirements, compactor delay, and wireability dictate that the weight of each row in a matrix be small to meet practical limitations on fan-in and fan-out [11], [16]. The fundamental problem in X-tolerant response compaction is to design an X-compact matrix with large compaction ratio that detects faulty circuit behavior. To achieve this, X-codes (which represent X-compact matrices) were introduced [14]. In this section, we discuss basic properties

for any pair of mutually disjoint subsets S1 and S2 of X with |S1 | = x and 1  |S2 |  d. A vector si  X is a codeword. (i) (i) The weight of a codeword si is |{sj = 0 : sj  si }|. The ratio n/m is the compaction ratio of X . An X-code forming an orthonormal basis of the m-dimensional linear space over F2 is trivial. Roughly speaking, an X-code is a set of codewords such that for every positive integer d  d no superimposed sum of any x codewords covers the vector obtained by adding up any d codewords chosen from the rest of the n - x codewords. Now we present a method of designing an X-compact matrix from an X-code. Proposition 1: There exists an (m, n, d, x) X-code X if and only if there exists an n × m X-compact matrix H which detects any combination of d faults (1  d  d) in the presence of at most x unknown logic values. Proof: First we prove necessity. Assume that X is an (m, n, d, x) X-code. Write X = {s1 , s2 , . . . , sn }, where si = (i) (i) (i) (s1 , s2 , . . . , sm ) for 1  i  n. Define an n × m matrix (i) H = (hi,j ) as hi,j = sj . We show that H forms an Xcompact matrix that detects a fault if the test output b contains d error bits, 1  d  d, and up to x Xs. Let E = {k : bk + ck = 1}, the set of indices of error bits, have cardinality d . Let X = {k : ck = X}, the set of indices of unknown logic values, have cardinality x. Now comparing d and r , d + r =
k

bk · hk, +
k

ck · hk,

=
kE,X

(bk + ck ) · hk, 1 · hk, +
k E k X

=

X · hk, ,

(1)

FUJIWARA AND COLBOURN: A COMBINATORIAL APPROACH TO X-TOLERANT COMPACTION CIRCUITS

3

with operations performed in X2 . Because the set of rows of H forms the set of codewords of X , no superimposed sum of x rows covers the vector obtained by an addition of any d rows. Hence there exists a column c such that 1 · hk,c = 1 and
k E k X

X · hk,c = 0.

(2)

Then (1) and (2) imply dc + rc = 1, that is, H detects a fault. Because (2) holds if and only if the right hand side of (1) equals one for l = c, sufficiency is straightforward. By virtue of this equivalence, we can employ various known results and techniques in coding theory to design an X-compactor with good error detection ability, X-tolerance, and a high compaction ratio. For the case when x = 0, an (m, n, d, 0) X-code forms an n × m X-compact matrix which is a parity-check matrix of a binary linear code of length n and minimum distance d. In fact, since the condition that x = 0 implies the absence of Xs, this special case is reduced to traditional space compaction. Because our focus is compaction in the presence of unknown logic values, we assume that x  1 henceforth unless otherwise stated. In the absence of Xs, see [18], [19]. By definition, an (m, n, d, x) X-code, d  2, is also an (m, n, d - 1, x) X-code. Also an (m, n, d, x) X-code forms an (m, n, d, x - 1) X-code. Moreover, an (m, n, d, x) X-code is an (m, n, d + 1, x - 1) X-code [14]. It can be difficult to design an X-compactor having both the necessary error detectability and the exact number of inputs needed. One trivial solution is to discard codewords from a larger X-code with sufficient error detection ability and Xtolerance. The following is another simple way to adjust the number of inputs. Proposition 2: If an (m, n, d, x) X-code and an (m , n , d , x ) X-code exist, there exists an (m + m , n + n , min{d, d }, min{x, x }) X-code. Proof: Let X = {s1 , . . . , sn } be an (m, n, d, x) Xcode and Y = {t1 , . . . , tn } an (m , n , d , x ) X-code. (i) (i) Extend each codeword si = (s1 , . . . , sm ) of X by appending m 0's so that extended vectors have the form (i) (i) s i = (s1 , . . . , sm , 0, . . . , 0). Similarly extend each codeword (j ) (j ) tj = (t1 , . . . , tm ) of Y by appending m 0s so that extended (j ) (j ) vectors have the form t j = (0, . . . , 0, t1 , . . . , tm ). The extended (m + m )-dimensional vectors form an (m + m , n + n , min{d, d }, min{x, x }) X-code. Proposition 2 says that given an (m, n, d, x) X-code, a codeword of weight less than or equal to x does not essentially contribute to the compaction ratio (see also [14]). In fact, (i) (i) if X contains such a codeword si = (s1 , . . . , sm ), there (i) exists at least one coordinate m such that sm = 1 and (j ) sm = 0 for any other codeword sj  X . Hence we can delete si and coordinate m from X while keeping d and x. By applying Proposition 2 and combining a trivial X-code and another X-code, we can obtain an X-code having the same number of codewords with compaction ratio no smaller. For this reason, when constructing an (m, n, d, x) X-code explicitly, we assume that every codeword has weight greater than x.

Let M (m, d, x) be the maximum number n of codewords for which there exists an (m, n, d, x) X-code. More codewords means a higher compaction ratio. Hence an (m, n, d, x) Xcode satisfying n = M (m, d, x) is optimal. Determining the exact value of M (m, d, x) seems difficult except for M (m, 1, 1). As pointed out in [14], a special case of M (m, d, x) has been extensively studied in the context of superimposed codes [20]. An (1, x)-superimposed code of size m × n is an m × n matrix S with entries in F2 such that no superimposed sum of any x columns of S covers any other column of S . Superimposed codes are also called cover-free families and disjunct matrices. By definition, a (1, x)-superimposed code of size m × n is equivalent to the transpose of an X-compact matrix obtained from an (m, n, 1, x) X-code. Hence known results on the maximum ratio n/m for superimposed codes immediately give information about M (m, 1, x). For completeness, we list useful results on M (m, 1, x). By Sperner's theorem, Theorem 2.1: (see [21], [22]) For m  2 an integer, M (m, 1, 1)  m . m/2

Indeed by taking all the m-dimensional vectors of weight m/2 as codewords, we attain the bound. The same argument is also found in [14]. The following is a simple upper bound on M (m, 1, x): Theorem 2.2: [22] For any x  2, log2 M (m, 1, x)  cm log2 x x2

for some constant c. Several different proofs of Theorem 2.2 are known. Bounds on the constant c are approximately two in [23], approximately four in [24], and approximately eight in [25]. The asymptotic behavior of the maximum possible number of codewords has been also investigated for superimposed codes. Define the ratio R(x) as log2 M (m, 1, x) . m m The best lower bound R(x)  R(x) can be found in [26] and the best upper bound R(x)  R(x) in [23]. The descriptive asymptotic form of the best bounds as x   is R(x) = lim R(x)  1 2 log2 x , and R(x)  x2 log2 e x2

where e is Napier's constant. For a detailed summary of the known lower and upper bounds, see [27]. Constructions with many codewords have been studied in [28], [29]. See also [30]­[33] and references therein. III. X-C OMPACTORS
WITH

S MALL FAN -O UT

In this section we consider an X-compactor having sufficient tolerance for errors and Xs, a high compaction ratio, and small fan-out. This section is divided into four parts. Subsection III-A deals with background and known results of the fanout problem in X-compactors. Then in Subsection III-B we investigate X-codes that tolerate up to two X's and have

4

IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. X, NO. XX, MONTH YEAR

the minimum fan-out. X-Codes with further error detection ability and X-tolerance are investigated in Subsection III-C. In Subsection III-D we give a brief overview of the performance of our X-codes given in this section and compare them with other codes. A. Background: Fan-Out in X-Codes X-compact reduces the number of bits in the compacted output while keeping error detection ability by propagating each single bit to many signal lines. In fact, each output of the X-compactor in [12] connects to about half of all inputs. However, larger fan-in increases power requirements, area, and delay [16]. When these disadvantages are concerns, fan-out of inputs of a compactor should be small to reduce fan-in values. In terms of X-codes, the required fan-out of input i in an X-compactor is the weight of codeword si of the X-code. Hence, in order to address the fan-out problem, it is desirable for a codeword to have small weight. However, as mentioned in Section I, an (m, n, d, x) X-code containing a codeword with weight at most x is not essential in the sense of the compaction ratio. Hence, throughout this section, we restrict ourselves to (m, n, d, x) X-codes in which every codeword has weight precisely x + 1, namely constant weight codes. When a compactor is required to tolerate only a single unknown logic value, fan-out is minimized when every codeword of an X-code has constant weight two. This extreme case was addressed in [16] by considering a simple graph. We briefly restate their theorems in terms of X-codes. A graph G is a pair (V, E ) such that V is a finite set and E is a set of pairs of distinct elements of V . An element of V is called a vertex, and an element of E is called an edge. The girth g of G is the minimal size |C | of a subset C  E such that each vertex appearing in C is contained in exactly two edges. The edge-vertex incidence matrix H of a graph G = (V, E ) is a |E| × |V | binary matrix H = (hi,j ) such that rows and columns are indexed by edges and vertices respectively and hi,j = 1 if the ith edge contains the j th vertex, otherwise 0. By considering the edge-vertex incidence matrix of a graph and Proposition 1, we obtain: Theorem 3.1: [16] There exists a graph G = (V, E ) of girth g if and only if there exists a (|V |, |E|, g - 2, 1) X-code of constant weight two. Theorem 3.2: [16] A set X of m-dimensional vectors is an (m, n, d - 1, 1) X-code of constant weight two if and only if it is an (m, n, d, 0) X-code of weight two. These two theorems say that in order to design an Xcompactor with high error detection ability, we only need to find a graph with large girth. The same argument is also found in [14]. For existence of such graphs and more details on Xcodes of constant weight two, see [16] and references therein. B. Two X's and Fan-Out Three Multiple X's can occur; here we present X-codes that are tolerant to two X's and have the maximum compaction ratio. To accept up to two unknown logic values, we need an X-code

of constant weight three. We employ a well-known class of combinatorial designs. A set system is an ordered pair (V, B ) such that V is a finite set of points, and B is a family of subsets (blocks) of V . A Steiner t-design S (t, k, v ) is a set system (V, B ), where V is a finite set of cardinality v and B is a family of k -subsets of V such that each t-subset of V is contained in exactly one block. Parameters v and k are the order and block size of a Steiner t-design. When t = 2 and k = 3, an S (2, 3, v ) is a Steiner triple system of order v , STS(v ). An STS(v ) exists if and only if v  1, 3 (mod 6) [34]. A triple packing of order v is a set system (V, B ) such that B is a family of triples of a finite set V of cardinality v and any pair of elements of V appear in B at most once. An STS(v ) is a triple packing of order v  1, 3 (mod 6) containing the maximum number of triples. The point-block incidence matrix of a set system (V, B ) is the binary |V | × |B| matrix H = (hi,j ) such that rows are indexed by points, columns are indexed by blocks, and hi,j = 1 if the ith point is contained in the j th block, otherwise 0. The block-point incidence matrix is its transpose. When d = 1, an (m, n, 1, 2) X-code of constant weight three is equivalent to a (1, 2)-superimposed code of size m × n of constant column weight three. It is well known that the pointblock incidence matrix of an S (t, k, v ) forms an (1, k/(t - k 1) - 1)-superimposed code of size v × v t / t . Hence, by using an STS(v ), we obtain for every v  1, 3 (mod 6) a (v, v (v - 1)/6, 1, 2) X-code. An upper bound on the number of codewords of (1, 2)-superimposed codes of constant weight k is available: Theorem 3.3: [35] Let nk (m) denote the maximum number of columns of a (1, 2)-superimposed code such that and every column is of length m and has constant weight k . Then, n2t-1 (m)  n2t (m + 1) 
m t 2t-1 t

with equality if and only if there exists a Steiner t-design S (t, 2t - 1, m). The following is an immediate consequence: Theorem 3.4: For any (m, n, 1, 2) X-code of constant -1) with equality if and only if there weight three, n  m(m 6 exists an STS(m). Hence for d = 1, x = 2, and fan-out three, an X-code from any STS(v ) has the maximum compaction ratio (v - 1)/6. One may ask for larger error detectability of an (m, n, 1, 2) X-code when one (or zero) unknown logic value is assumed. An (m, n, d, x) X-code is also an (m, n, d + 1, x - 1) X-code, and hence any (m, n, 1, 2) X-code from an STS(m) is also an (m, n, 2, 1) X-code. However, a careful choice of Steiner triple systems gives higher error detectability while maintaining the compaction ratio. A configuration C in a triple packing, (V, B ), is a subset C  B . The set of points appearing in at least one block of a configuration C is denoted by V (C ). Two configurations C and C  are isomorphic, denoted C  = C  , if there exists a bijection   : V (C )  V (C ) such that for each block B  C , the image (B ) is a block in C  . When |C| = i, a configuration C is an i-configuration. A configuration C is even if for every point

FUJIWARA AND COLBOURN: A COMBINATORIAL APPROACH TO X-TOLERANT COMPACTION CIRCUITS

5

a appearing in C the number |{B : a  B  C}| of blocks containing a is even. Because every block in a triple packing has three points, no i-configuration for i odd is even. A triple packing is r-even-free if for every integer i satisfying 1  i  r it contains no even i-configurations. By definition every r-even-free triple packing, r  2, is also (r - 1)-even-free. For an even integer r, an r-even-free triple packing is also (r + 1)-even-free. Every triple packing is trivially 3-even-free. For v > 3 an STS(v ) may or may not be 4-even-free. Up to isomorphism, the only even 4-configuration is the Pasch configuration. It can be written on six points and four blocks: {{a, b, c}, {a, d, e}, {f, b, d}, {f, c, e}}. For the list of all the small configurations in a triple packing and more complete treatments, we refer the reader to [34] and [36]. Because a 4-even-free STS is 5-even-free, an STS is 5-evenfree if and only if it contains no Pasch configuration. Lemma 3.5: If there exists a 5-even-free STS(v ), there exists a (v, v (v - 1)/6, 3, 1) X-code of constant weight three. The code is a (v, v (v - 1)/6, 5, 0) X-code of constant weight three. Proof: Let (V, B ) be a 5-even-free STS(v ). For every Bi  B define a v -dimensional vector si such that each (i) coordinate sj  si is indexed by a distinct point j  V (i) and sj = 1 if j  Bi , otherwise 0. Then we obtain a (v, v (v - 1)/6, 1, 2) X-code S = {si : Bi  B} of constant weight three. We prove that S is a (v, v (v - 1)/6, 3, 1) X-code that is also a (v, v (v - 1)/6, 5, 0) X-code. By definition, for 1  i  5 no i-configuration C  B is even. Hence {si : Bi  C} = 0. This implies that S is a (v, v (v - 1)/6, 5, 0) X-code. On the other hand, since no pair of points appears twice, for any mutually distinct blocks Bi , Bj , Bk  B , si = sj and si  (sj  sk ) = si . It remains to show that no codeword in S covers addition of three others. Suppose to the contrary that there exist four distinct codewords si , sj , sk , and sl such that si  (sj  sk  sl ) = si . Because no pair of points appears twice and every block has exactly three points, the only possible case is that the 4configuration {Bi , Bj , Bk , Bl } forms a Pasch configuration, and hence it is even, a contradiction. Steiner triple systems avoiding Pasch configurations have been long studied as anti-Pasch STSs [34]. Theorem 3.6: [37] There exists a 5-even-free STS(v ) if and only if v  1, 3 (mod 6) and v  {7, 13}. By combining Theorem 3.6 and Lemma 3.5, we obtain: Theorem 3.7: For every v  1, 3 (mod 6) and v  {7, 13}, there exists a (v, v (v - 1)/6, 1, 2) X-code of constant weight three that is a (v, v (v - 1)/6, 3, 1) X-code and a (v, v (v - 1)/6, 5, 0) X-code. An X-compactor designed from these can detect any odd number of errors unless there is an unknown logic value. One may want to take advantage of the high compaction ratio of the optimal (m, n, 1, 2) X-codes arising from 4-even-free STSs

when there is only a small possibility that more than two Xs occur or multiple errors happen with multiple Xs. Our X-codes from 4-even-free STSs also have high performance in such situations: Theorem 3.8: The probability that a (v, v (v - 1)/6, 1, 2) Xcode from a 4-even-free STS(v ) fails to detect a single error 162(v -3)2 when there are exactly three Xs is (v+2)(v+3)( v -4)(v 2 -v -18) . Proof: Because there is only one error, an X-code fails to detect this error when all three points in the block that corresponds to the error are contained in at least one block corresponding to an X. The number of occurrences of each 4configuration in an STS(v ) is determined by v and the number of Pasch configurations (see [34], for example). A simple calculation proves the assertion. Theorem 3.9: The probability that a (v, v (v - 1)/6, 1, 2) X-code from a 4-even-free STS(v ) fails to detect errors when there are exactly two Xs and exactly two errors is 1296 (v +2)(v +3)(v -4)(v 2 -v -18) . Proof: A (v, v (v - 1)/6, 1, 2) X-code from a 4-evenfree STS(v ) fails to detect errors when there are exactly two Xs and exactly two errors only when corresponding four blocks form a 4-configuration isomorphic to {{a, b, c}, {d, e, f }, {a, e, g }, {c, f, g }} where the first two blocks represent Xs and the other two blocks correspond to errors. The number of occurrences of the 4-configuration in v -3) a 4-even-free STS(v ) is v(v-1)( , and the total number of 4 occurrences of all 4-configurations is
v (v -1)(v -3) 4 4 2
v(v-1) 6 v(v-1) 6

4

[34]. Divide

to obtain the probability that the by 4 X-code fails to detect the two errors. Hence when a 4-even-free STS of sufficiently large order is used, the probability that the corresponding X-code fails to detect errors when the sum of the numbers of errors and Xs is at most four is close to zero. A more complicated counting argument is necessary to calculate the performance of X-codes from STSs when the sum of the numbers of errors and Xs is greater than four. For more complete treatments and current research results on counting configurations in Steiner triple systems, we refer the reader to [36] and references therein. Useful explicit constructions for 5-even-free STS(v ) can be found in [34], [37]­[41]. The cyclic 5-sparse Steiner triple systems in [42] provide examples of 5-even-free STS(v ) for v  97, because cyclic 5-sparse systems are all anti-Pasch. Further r-even-freeness improves the error detectability of the resulting X-code: Theorem 3.10: For r  4, if there exists an r-even-free triple packing (V, B ), there exists a (|V |, |B|, 1, 2) X-code of constant weight three that is also a (|V |, |B|, 3, 1) X-code and a (|V |, |B|, r, 0) X-code. Proof: Let (V, B ) be an r-even-free triple packing of order v . For every Bi  B define a v -dimensional vector si such (i) that each coordinate sj  si is indexed by a distinct point (i) j  V and sj = 1 if j  Bi , otherwise 0. Then we obtain a (|V |, |B|, 1, 2) X-code S = {si : Bi  B} of constant weight three. It suffices to prove that S forms a (|V |, |B|, r, 0) X-code. Suppose to the contrary that S is not a (|V |, |B|, r, 0) X-code. Then for some r  r there exists a set of r codewords si ,

6

IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. X, NO. XX, MONTH YEAR

sj . . . , sk such that si  sj · · ·  sk = 0. However, the set of the corresponding blocks Bi , Bj ,. . . ,Bk forms an even r -configuration, a contradiction. One may want an r-even-free STS with large r to obtain higher error detection ability while keeping the maximum compaction ratio. Although it is known that every Steiner triple system has a configuration with seven or fewer blocks so that every element of the configuration belongs to at least two [36], it may happen that none of these are even. Nevertheless, the following gives an upper bound of even-freeness of Steiner triple systems. Theorem 3.11: For v > 3 there exists no 8-even-free STS(v ). Proof: Suppose to the contrary that there exists an STS(v ), S , that is 8-even free. Consider a 4-configuration C isomorphic to {{a, b, e}, {c, d, e}, {a, c, f }, {b, d, g}}; the points f and g are each contained in exactly one block. For any anti-Pasch STS(v ) the number of occurrences of configurations isomorphic to C is v (v - 1)(v - 3)/4 [43] (see also [44]). Because v  7, we have v (v - 1)(v - 3)/4 > v 2 . Hence there is a pair of configurations A and B such that A  = C and they share the two points contained in = B  exactly one block. In other words, there exists a pair A and B having the form {{a, b, e}, {c, d, e}, {a, c, f }, {b, d, g}} and {{a , b , e }, {c , d , e }, {a , c , f }, {b , d , g }} respectively. If there is no common block between A and B , then the merged configuration A  B forms an even configuration consisting of eight blocks, a contradiction. Otherwise, there is at least one block contained in both A and B . Removing blocks shared between A and B from their union, we obtain an even configuration on four or six blocks, a contradiction. By combining Theorems 3.4, 3.10, and 3.11, we have: Theorem 3.12: There exists no (m, n, 1, 2) X-code that achieves the maximum compaction ratio (m - 1)/6 and is also an (m, n, 3, 1) X-code and an (m, n, 8, 0) X-code. An STS is 7-even-free if and only if it is 6-evenfree. Up to isomorphism, there are two kinds of even 6configurations which may appear in an STS. One is called the grid and the other is the double triangle. Both 6configurations are described by nine points and six blocks: {{a, b, c}, {d, e, f }, {g, h, i}, {a, d, g }, {b, e, h}, {c, f, i}} and {{a, b, c}, {a, d, e}, {c, f, e}, {b, g, h}, {d, h, i}, {f, g, i}} respectively. By definition, an STS is 6-even-free if it simultaneously avoids Pasches, grids, and double triangles. We do not know whether there exists a 6-even-free STS(v ) for any v > 3. However, a moderately large number of triples can be included while keeping 6-even-freeness: Theorem 3.13: There exists a constant c > 0 such that for sufficiently large v there exists a 6-even-free triple packing of order v with cv 1.8 triples. Proof: Let C  be a set of representatives of all of the nonisomorphic even configurations on six or fewer triples and let C  be a configuration consisting of pair of distinct triples sharing a pair of elements. Let C = C   C  . Pick uniformly 6 at random triples from V with probability p = c v - 5 inde1 10   pendently, where c satisfies 0 < c < ( 41·79·83 ) 5 . Let bC be

a random variable counting the configurations isomorphic to a member of C in the resulting set of triples. Define E (bC ) as its expected value. Then v 4
9 3 4 3

E (bC )  =

6

2 4 c6 v 1.8 + f (v ), 9!

p2 +

v 6

6 3

p4 +

v 9

9 3

6

p6

where f (v ) = O(v 1.6 ). By Markov's Inequality, P (bC  2E (bC ))  Hence, P bC  2
9 3

1 . 2

6

c6 v 1.8 + 2f (v ) 9!



1 . 2

Let t be a random variable counting the triples and E (t) its expected value. Then E (t) = p v 3 = c 1.8 v - g (v ), 6

where g (v ) = O(v 0.8 ). Because t is a binomial random variable, by Chernoff's inequality, for sufficiently large v P t< E (t) 2 < e-
E (t) 8

<

1 . 2

Hence, if v is sufficiently large, then with positive probabil(t) ity we have a set B of triples with the property that |B| > E2 and the number of configurations in B isomorphic to a member of C is at most 2
9 3

6

c6 v 1.8 + 2f (v ). 9!

Let ex(v, r) be the maximum cardinality |B| such that there exists an r-even-free triple packing. By deleting a triple from each configuration isomorphic to a member of C , we obtain ex(v, 6)  E (t) -2 2
9 3

6

c6 v 1.8 + h(v ), 9!

where h(v ) = O(v 1.6 ). Then for some positive constant c and sufficiently large v , it holds that ex(v, 6)  cv 1.8 . Hence we have: Theorem 3.14: There exists a constant c > 0 such that for sufficiently large v there exists a (v, cv 1.8 , 1, 2) X-code that is also a (v, cv 1.8 , 3, 1) X-code and a (v, cv 1.8 , 6, 0) X-code. An STS(v ) has approximately v 2 /6 triples. The same technique can be used to obtain a lower bound on ex(v, r) for 12 r  8. In fact, ex(v, 8) is at least O(v 7 ), and hence for sufficiently large v there exists a constant c > 0 such that 12 12 there exists a (v, cv 7 , 1, 2) X-code that is also a (v, cv 7 , 3, 1) 12 X-code and a (v, cv 7 , 8, 0) X-code.

FUJIWARA AND COLBOURN: A COMBINATORIAL APPROACH TO X-TOLERANT COMPACTION CIRCUITS

7

C. Higher X-Tolerance with the Minimum Fan-Out In general, the probability that a defective digital circuit produces an error at a specific signal output line is quite small. In fact, several errors are unlikely happen simultaneously [11], [45]. Also, multiple Xs with errors are rare [12]. Therefore, Xcodes given in Theorems 3.7 and 3.13 are particularly useful for relatively simple scan-based testing such as built-in selftest (BIST) where the tester is only required to detect defective chips. Nonetheless, more sophisticated X-codes are also useful to improve test quality and/or to identify or narrow down the error sources by taking advantage of more detailed information about when incorrect responses are produced [12]. Hence, for use in higher quality testing and error diagnosis support, it is of theoretical and practical interest to consider (m, n, d, x) X-codes of constant weight x + 1, where x  3 or d  6. For (m, n, 1, 2) X-codes of constant weight three, we employed Theorem 3.3 to obtain an upper bound on the number of codewords. The following theorem gives a generalized upper bound: Theorem 3.15: [46] Let n(x, m, k ) denote the maximum number of columns of a (1, x)-superimposed code such that every column is of length m and has constant weight k . Then, for every x, t and i = 0, 1 or i  x/2t2 , n(x, m, x(t - 1) + 1 + i)  m-i k-i / t t

for all sufficiently large m, with equality if and only if there exists a Steiner t-design S (t, x(t - 1) + 1, m - i). By putting t = 2 and i = 0, we obtain: Corollary 3.16: For an (m, n, 1, x) X-code of constant weight x + 1, m x+1 n / 2 2 for all sufficiently large m, with equality if and only if there is an S (2, x + 1, m). Because the set of columns of the block-point incidence matrix of any S (2, x + 1, m) forms an (m, m(m - 1)/x(x + 1), 1, x) X-code of constant weight x + 1, the existence of Steiner 2-designs is our next interest. For k  {4, 5}, necessary and sufficient conditions for existence of an S (2, k, v ) are known: Theorem 3.17: [47] There exists an S (2, 4, v ) if and only if v  1, 4 (mod 12). Theorem 3.18: [48] There exists an S (2, 5, v ) if and only if v  1, 5 (mod 20). For k  6, the necessary and sufficient conditions on v for existence of an S (2, k, v ) are not known in general; the existence of a Steiner 2-design is solved only in an asymptotic sense [49], although for `small' values of k substantial results are known. For a comprehensive table of known Steiner 2designs, see [50]. As with X-codes from Steiner triple systems, the error detectability can be improved by considering avoidance of even configurations. An S (2, k, v ), (V, B ), is r-even-free if for 1  i  r it contains no subset C  B such that |C| = i and each point appearing in C is contained in exactly an even number

of blocks in C . A generalized Pasch configuration in an S (2, k, v ), (V, B ), is a subset C  B such that |C| = k + 1 and each point appearing in C is contained exactly two blocks of C . As with triple systems, an S (2, k, v ) is (k + 1)-even-free if and only if it contains no generalized Pasch configurations. Theorem 3.19: If an r-even-free S (2, k, v ) for r  k + 1 exists, there exists a (v, v (v - 1)/k (k - 1), 1, k - 1) X-code of constant weight k that is also a (v, v (v - 1)/k (k - 1), k, 1) X-code and a (v, v (v - 1)/k (k - 1), r, 0) X-code. Proof: Let (V, B ) be an r-even-free S (2, k, v ). For every Bi  B define a v -dimensional vector si such that each (i) coordinate sj  si is indexed by a distinct point j  V (i) and sj = 1 if j  Bi , otherwise 0. Then we obtain a (v, v (v - 1)/k (k - 1), 1, k - 1) X-code S = {si : Bi  B} of constant weight k . By definition of an r-even-free S (2, k, v ), it is straightforward to see that S is also a (v, v (v - 1)/k (k - 1), r, 0) X-code. It suffices to prove that S can also be used as a (v, v (v - 1)/k (k - 1), k, 1) X-code. Assume that this is not the case. Then, by following the argument in the proof of Lemma 3.5, B contains a generalized Pasch configuration, a contradiction. Existence of an r-even-free design has been investigated in the study of erasure-resilient codes for redundant array of independent disks (RAID) [51]. In fact, infinitely many r-evenfree S (2, k, v )s can be obtained from affine spaces over Fq [52]. Theorem 3.20: [52] For any odd prime power q and positive integer n  2 the points and lines of AG(n, q ) form a (2q - 1)even-free S (2, q, q n ). By combining Theorems 3.19 and 3.20, we obtain: Theorem 3.21: For any odd prime power q and positive integer n  2, there exists a (q n , q n-1 (q n - 1)/(q - 1), 1, q - 1) X-code of constant weight q that is also an (q n , q n-1 (q n - 1)/(q - 1), q, 1) X-code and a (q n , q n-1 (q n - 1)/(q - 1), 2q - 1, 0) X-code. D. Characteristics of X-Codes from Combinatorial Designs We have given tight upper bounds of compaction ratio for (m, n, 1, x) X-codes with the minimum fan-out and presented explicit construction methods for X-codes that attain the bounds. As far as the authors are aware, these are the first mathematical bounds and construction techniques for this type of optimal X-code with constant weight greater than two. Optimal X-codes given in Theorems 3.7 and 3.21 in particular have higher error detection ability when the number of Xs is smaller than x. The known construction technique using hypergraphs, briefly mentioned in [16], can not guarantee the same error detection ability. To illustrate the usefulness of our X-codes, here we compare the error detection ability of an example X-code that can be generated using Theorem 3.7 with characteristics of Xcodes proposed in [11]. The probability that the example (50, 500, 1, 1) X-code in Table 5 in [11] fails to detect a single error when there are exactly two Xs is around 4.2 × 10-6 . The fan-out of this code is 11. Our X-code from Theorem 3.7, which has the same compaction ratio, has parameters (61, 610, 1, 2). The probability that this X-code fails to detect

8

IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. X, NO. XX, MONTH YEAR

a single error in the same situation is exactly 0. Its fan-out is 3, which is significantly smaller. While the multiple error detection ability of the (50, 500, 1, 1) X-code is not specified in [11], our code can always detect up to three errors when there is only one X, and up to five errors when there is no X. By Theorem 3.9 the probability that our (61, 610, 1, 2) X-code fails to detect errors when there are exactly two Xs and two errors is 1.5 × 10-6 . Therefore, our X-code is ideal when the fan-out problem is critical and/or fault-free simulation rarely produces three or more Xs in an expected response. Very large optimal X-codes with very high error detecting ability and compaction ratio can be easily constructed by the same method. For example, Theorem 3.7 and known results on anti-Pasch STSs immediately give a (601, 60100, 1, 2) Xcode with fan-out 3 and compaction ratio 100. This code is also a (601, 60100, 3, 1) X-code and a (601, 60100, 5, 0) Xcode. Moreover, the probability that it fails to detect errors when there are exactly two Xs and two errors (or exactly three Xs and a single error) is around 1.6 × 10-11 (or 7.3-7 respectively). As far as the authors know, there have been no X-codes available that guarantee as high error detection ability and have very small fan-out. As Theorems 3.7, 3.8, and 3.9 indicate, larger X-codes designed with this method have an even higher compaction ratio and better error detection rate. Because discarding codewords does not affect error detection ability, one may use part of a large X-code to achieve very high test quality when compaction ratio can be compromised to an extent. IV. X-C ODES
OF

binary matrix H  . Taking each row of H  as a codeword, we obtain a set X of mN -dimensional vectors. It suffices to show that for any two arbitrary subsets D, X  X satisfying |D| = d  d, |X | = x  x, and D  X = , it holds that ( X)  ( D) = X. (3)

A RBITRARY W EIGHT

The restriction to low-weight codewords severely limits the compaction ratio of an X-code. Hence, when fan-in and fanout are not of concern, it is desirable to use X-codes with arbitrary weight. In this section we study the compaction ratio and construction methods of such general X-codes. For d = x = 2, a (log2 n(log2 n + 1), n, 2, 2) X-code was constructed for any integer n  2 [14]. Theorem 4.1: [14] For any optimal (m, n, 2, 2) X-code, m  log2 n(log2 n + 1). They also gave an explicit construction method of a (3log3 n, n, 1, 3) X-code. In order to give a more general construction, we employ design theoretic techniques for arrays. Let n  w  2. A perfect hash family, PHF(N ; u, n, w), is a set F of N functions f : Y  X where |Y | = u and |X | = n, such that, for any C  Y with |C | = w, there exists at least one function f  F such that f |C is one-to-one. A PHF(N ; u, n, w) can be described by a u × N matrix with entries from a set of n symbols such that for any w rows there exists at least one column in which each element is distinct. Theorem 4.2: If an (m, n, d, x) X-code and a PHF(N ; u, n, max{d, x} + 1) exist, there exists an (mN, u, d, x) X-code. Proof: Let H be a u × N n-ary matrix representing a PHF(N ; u, n, max{d, x} + 1). Assign each codeword of an (m, n, d, x) X-code to a distinct symbol of the PHF and replace each entry of H by the m-dimensional row vector representing the assigned codeword. Then we obtain a u × mN

By considering a one-to-one function in the PHF, for any max{d, x} + 1 codewords of X at least one set of m coordinates forms max{d, x} + 1 distinct codewords of the original (m, n, d, x) X-code. Hence, for any choice of D and X there exists a subset Y  X of cardinality |Y | = max{0, d + x - (max{d, x} + 1)} such that at least one set of m coordinates in D  (X \ Y ) forms distinct codewords of the original (m, n, d, x) X-code. Because |Y |  d - 1 < |D|, (3) holds for any D and X . Hence, the resulting set X forms an (mN, u, d, x) X-code. Since their introduction in [53], much progress has been made on existence and construction techniques for perfect hash families (see [54]­[58] for recent results). A concise list of known results on perfect hash families is available in [50]. We can use perfect hash families from algebraic curves over finite fields: Theorem 4.3: [59] For positive integers n  w, there exists an explicit construction for an infinite family of PHF(N ; u, n, w) such that N is O(log u). Indeed when n is fixed, a perfect hash family with O(log u) rows can be determined in polynomial time by a greedy method [60]. By combining Theorems 4.2 and 4.3, we can construct infinitely many (m, n, d, x) X-codes where m is O(log n). Theorem 4.4: For any positive integer d and nonnegative integer x, there exists an explicit construction for an infinite family of (m, n, d, x) X-codes, where m is O(log n). The following is a combinatorial recursion for X-codes. Theorem 4.5: If an (m, n, d, x) X-code and an (, n, d 2 , x) X-code exist, there exists an ( + m, 2n, d, x) X-code. Proof: Let X = {s1 , . . . , sn } be an (m, n, d, x) X-code and Y = {t1 , . . . , tn } an (, n, d 2 , x) X-code. Extend each (i) (i) codeword si = (s1 , . . . , sm ) of X by appending  0's so that (i) (i) extended vectors have the form s i = (s1 , . . . , sm , 0, . . . , 0). (i) (i) Extend each codeword ti = (t1 , . . . , tl ) of Y by combining si so that extended vectors have the form t i = (i) (i) (i) (i)   (s1 , . . . , sm , t1 , . . . , tl ). Define A = {s1 , . . . , sn }, B =  {t 1 , . . . , tn }, and C = A  B . We prove that C is an ( + m, 2n, d, x) X-code. Take two subsets D, X  C satisfying |D| = d  d, |X | = x  x, and D X = . As in the proof of Theorem 4.2, it suffices to show that for any choice of D and X the vector obtained by adding all the codewords in D is not covered by the superimposed sum of X , that is, (3) holds. Define a sur(i) (i) (i) (i) jection f of C to X as f : (c1 , . . . , c+m )  (c1 , . . . , cm ). Mapping all codewords of C under f generates two copies of X ; one is from A and the other is from B . Define a (i) (i) surjection g of C to Y  {0} as g : (c1 , . . . , c+m )  (i) (cm + 1(i) , . . . , c+m ). By definition, {g (c) : c  B } = Y and for any c  A the image g (c) is an -dimensional zero

FUJIWARA AND COLBOURN: A COMBINATORIAL APPROACH TO X-TOLERANT COMPACTION CIRCUITS

9

vector. Let a = |D  A| and b = |D  B |. Because Y is an d (, n, d 2 , x) X-code, if b  2 , g( X )  g( D) = g ( X ). (4)
d 2

If E (AX ) < 1, there exists an (m, n, d, x) X-code. Taking logarithms, m> Hence, if m  2x+1 (d + x) log n > -(d + x) log n , log (1 - 2-x-1 ) -(d + x) log n . log (1 - 2-x-1 )

Hence, we only need to consider the case when b > Suppose to the contrary that (3) does not hold. Then, f( Let a = |{c  X : f (c) = f (d), d  D  B }| and a = |{c  D  A : f (c) = f (d), d  D  B }|. X)  f( D) = f ( X ).

.

(5)

Because {f (c) : c  A} = {f (c) : c  B} = X and (5) holds, b = a + a . As a + b = d and b > d 2 , b  a + a d  + a . 2 (6)

there exists an (m, n, d, x) X-code. Hence, for any optimal (m, n, d, x) X-code with n  max{2d, d + x}, m is at most O(log n). For example, by putting d = x = 2 we know that there exists an (m, n, d, x) X-code if m  32 log n. This significantly improves the upper bound in Theorem 4.1 proved in [14]. V. C ONCLUSIONS By formulating X-tolerant space compaction of test responses combinatorially, an equivalent, alternative definition of X-codes has been introduced. This combinatorial approach gives general design methods for X-codes and bounds on the compaction ratio. Using this model with restricted fanout leads to well-studied objects, the Steiner 2-designs. These provide constructions for X-codes having sufficient error detectability, X-tolerance, maximum compaction ratio, and minimum fan-out. Constant weight X-codes with high error detectability profit from a deep connection with configurations, particularly the Pasch configuration. The combinatorial formulation of X-tolerant compaction can also be applied in conjunction with another compaction technique (such as time compaction). If a tester wants an X-compactor with additional properties, the necessary structure of the compactor may be expressed in design theoretic terms. Our formulation can also be useful for the study of higher error detectability and error diagnosis support employing the appropriate assistance from an Automatic Test Equipment (ATE) [12]. For example, the compaction technique called iCompact can be understood in terms of the model in Section II [17]. The essential idea underlying Theorem 4.6 is the stochastic coding technique for X-tolerant signature analysis [61]. We used a naive value 1/2 as the probability p in the proof of Theorem 4.6. To obtain a better constant coefficient, p should be chosen so that it minimizes the expected value E (AX ), that is, it should minimize m 
d i=1

On the other hand, |X  B|  x - a . Because Y is also an   (, n, d 2 + a , x - a ) X-code, (4) holds, a contradiction. Next, we present a simple nonconstructive existence result for (m, n, d, x) X-codes. Theorem 4.6: Let d, x be a positive integers. For n  max{2d, d + x}, if m  2x+1 (d + x) log n, there exists an (m, n, d, x) X-code. Proof: Let X = {s1 , s2 , . . . , sn } be a set of n m(i) (i) (i) dimensional vectors si = (s1 , s2 , . . . , sm , ) in which each (i) entry sj is defined to be 1 with probability p = 1/2. Let X be a set of x vectors of X and Di a set of i vectors in X \ X . Define A(Di , X ) = 0 if ( X )  ( 1 otherwise, Di ) = X,

and let E (A(Di , X )) be its expected value. Then  i -i  2  j m

E (A(Di , X )) = = Let AX =
X X |X |=x

 -x 1 - 2
d

1j i j

odd

(1 - 2-x-1 )m .

A(Di , X )
i=1
Di Di X =

and E (AX ) its expected value. Then
d

E (AX )

=
X X |X |=x

E (A(Di , X ))
i=1
Di Di X =

d

=
i=1

n x

n-x (1 - 2-x-1 )m i

< nd+x (1 - 2-x-1 )m .

While this optimization does not affect the logarithmic order in Theorem 4.6, it may help a tester determine the target compaction ratio and estimate the error cancellation and masking rate of an X-tolerant Multiple Input Signature Register (XMISR) based on stochastic coding [61]. In this paper we focused on space compaction. Nevertheless, time compaction is of great importance as well. We expect the combinatorial formulation developed here to provide a useful framework for exploring time compaction as well.

n-x  1 - i

1j i j

odd

i j  p (1 - p)i-j +x  . j

10

IEEE TRANSACTIONS ON INFORMATION THEORY, VOL. X, NO. XX, MONTH YEAR

ACKNOWLEDGMENT A substantial part of the research was done while the first author was visiting the Department of Computer Science and Engineering of Arizona State University. He thanks the department for its hospitality. The authors thank an anonymous referee and the editor for helpful comments and valuable suggestions. R EFERENCES
[1] E. J. McCluskey, D. Burek, B. Koenemann, S. Mitra, J. H. Patel, J. Rajski, and J. A. Waicukauski, "Test compression roundtable," IEEE Des. Test. Comput., vol. 20, pp. 76­87, Mar./Apr. 2003. [2] A. Lempel and M. Cohn, "Design of universal test sequences for VLSI," IEEE Trans. Inf. Theory, vol. 31, pp. 10­17, Jan. 1985. [3] G. Seroussi and N. H. Bshouty, "Vector sets for exhaustive testing of logic circuits," IEEE Trans. Inf. Theory, vol. 34, pp. 513­522, May 1988. [4] H. Hollmann, "Design of test sequences for VLSI self-testing using LFSR," IEEE Trans. Inf. Theory, vol. 36, pp. 386­392, Mar. 1990. [5] G. D. Cohen and G. Zemor, "Intersecting codes and independent families," IEEE Trans. Inf. Theory, vol. 40, pp. 1872­1881, Nov. 1994. [6] N. Benowitz, D. F. Calhoun, G. E. Alderson, J. E. Bauer, and C. T. Joeckel, "An advanced fault isolation system for digital logic," IEEE Trans. Comput., vol. C-24, pp. 489­497, May 1975. [7] E. J. McCluskey, Logic Design Principles with Emphasis on Testable Semi-Custom Circuits. Englewood Cliffs, NJ: Prentice-Hall, 1986. [8] N. R. Saxena and E. J. McCluskey, "Parallel signature analysis design with bounds on aliasing," IEEE Trans. Comput., vol. 46, pp. 425­438, Apr. 1997. [9] C. Barnhart, V. Brunkhorst, F. Distler, O. Farnsworth, B. Keller, and B. Koenemann, "OPMISR: The foundation for compressed ATPG vectors," in Proc. Int. Test Conf., 2001, pp. 748­757. [10] C. Barnhart, V. Brunkhorst, F. Distler, O. Farnsworth, A. Ferko, B. Keller, D. Scott, B. Koenemann, and T. Onodera, "Extending OPMISR beyond 10x scan test efficiency," IEEE Design Test Comput., vol. 19, pp. 65­73, Sep. 2002. [11] S. Mitra, S. S. Lumetta, M. Mitzenmacher, and N. Patil, "X-tolerant test response compaction," IEEE Des. Test. Comput., vol. 22, pp. 566­574, Nov. 2005. [12] S. Mitra and K. S. Kim, "X-compact: An efficient response compaction technique," IEEE Trans. Comput.-Aided Design Integr. Circuits Syst., vol. 23, pp. 421­432, Mar. 2004. [13] S. Mitra, S. Kallepalli, and K. S. Kim, "Analysis of X-compact for industrial designs," Intel Corp., 2003. [14] S. S. Lumetta and S. Mitra, "X-codes: Theory and applications of unknowable inputs," Center for Reliable and High-Performance Computing, Univ. of Illinois at Urbana Champaign, Tech. Rep. CRHC-03-08 (also UILU-ENG-03-2217), Aug. 2003. [15] ----, "X-codes: Error control with unknowable inputs," in Proc. IEEE Intl. Symp. Information Theory, Yokohama, Japan, June 2003, p. 102. [16] P. Wohl and L. Huisman, "Analysis and design of optimal combinational compactors," in Proc. 21st IEEE VLSI Test Symp., April/May 2003, pp. 101­106. [17] J. H. Patel, S. S. Lumetta, and S. M. Reddy, "Application of SalujaKarpovsky compactors to test responses with many unknowns," in Proc. 21st IEEE VLSI Test Symp., 2003, pp. 107­112. [18] T. R. N. Rao and E. Fujiwara, Error-Control Coding for Computer Systems. Englewood Cliffs, NJ: Prentice-Hall, 1989. [19] K. K. Saluja and M. Karpovsky, "Testing computer hardware through data compression in space and time," in Proc. Int. Test Conf., 1983, pp. 83­93. [20] W. H. Kautz and R. R. Singleton, "Nonrandom binary superimposed codes," IEEE Trans. Inf. Theory, vol. 10, pp. 363­377, Jul. 1964. [21] E. Sperner, "Ein satz u ¨ ber Untermengen einer endlichen Menge," Math. Z., vol. 27, pp. 544­548, 1928. [22] D. R. Stinson and R. Wei, "Some new upper bounds for cover-free families," J. Combin. Theory Ser. A, vol. 90, pp. 224­234, 2000. [23] A. G. D'yachkov and V. V. Rykov, "Bounds on the length of disjunctive codes," Probl. Contr. Inform. Theory, vol. 11, pp. 7­33, 1982, in Russian. [24] Z. F¨ uredi, "On r -cover-free families," J. Combin. Theory, Ser. A, vol. 73, pp. 172­173, 1996. [25] M. Ruszink´ o, "On the upper bound of the size of the r -cover-free families," J. Combin. Theory, Ser. A, vol. 66, pp. 302­310, 1994.

[26] A. G. D'yachkov, V. V. Rykov, and A. M. Rashad, "Superimposed distance codes," Probl. Contr. Inform. Theory, vol. 18, pp. 237­250, 1989. [27] D. Z. Du and F. K. Hwang, Combinatorial Group Testing and Its Applications, 2nd ed. Singapore: World Scientific, 2000. [28] H. L. Fu and F. K. Hwang, "A novel use of t-packings to construct d-disjunct matrices," Discrete Appl. Math., vol. 154, pp. 1759­1762, 2006. [29] A. G. D'yachkov, A. J. Macula, and V. V. Rykov, "New constructions of superimposed codes," IEEE Trans. Inf. Theory, vol. 46, pp. 284­290, Jan. 2000. [30] A. J. Macula, "A simple construction of d-disjunct matrices with certain constant weights," Discrete Math., vol. 162, pp. 311­312, 1996. [31] ----, "Error-correcting nonadaptive group testing with de -disjunct matrices," Discrete Appl. Math., vol. 80, pp. 217­222, 1997. [32] H. G. Yeh, "d-Disjunct matrices: bounds and Lov´ asz Local Lemma," Discrete Math., vol. 253, pp. 97­107, 2002. [33] A. De Bonis and U. Vaccaro, "Constructions of generalized superimposed codes with applications to group testing and conflict resolution in multiple access channels," Theor. Comput. Sci., vol. 306, pp. 223­243, 2003. [34] C. J. Colbourn and A. Rosa, Triple Systems. Oxford: Oxford Univ. Press, 1999. [35] P. Erd os, P. Frankl, and Z. F¨ uredi, "Families of finite sets in which no set is covered by the union of two others," J. Combin. Theory, Ser. A, vol. 33, pp. 158­166, 1982. [36] C. J. Colbourn and Y. Fujiwara, "Small stopping sets in Steiner triple systems," Cryptography and Communications, vol. 1, no. 1, pp. 31­46, 2009. [37] M. J. Grannell, T. S. Griggs, and C. A. Whitehead, "The resolution of the anti-Pasch conjecture," J. Combin. Des., vol. 8, pp. 300­309, 2000. [38] A. C. H. Ling, C. J. Colbourn, M. J. Grannell, and T. S. Griggs, "Construction techniques for anti-Pasch Steiner triple systems," J. Lond. Math. Soc. (2), vol. 61, pp. 641­657, 2000. [39] D. R. Stinson and Y. J. Wei, "Some results on quadrilaterals in Steiner triple systems," Discrete Math., vol. 105, pp. 207­219, 1992. [40] M. J. Grannell, T. S. Griggs, and J. S. Phelan, "A new look at an old construction for Steiner triple systems," Ars Combinat., vol. 25A, pp. 55­60, 1988. [41] A. E. Brouwer, "Steiner triple systems without forbidden subconfigurations," Mathematisch Centrum Amsterdam, ZW 104/77, 1977.  an [42] C. J. Colbourn, E. Mendelsohn, A. Rosa, and J. Sir´  , "Anti-Mitre Steiner triple systems," Graphs Combin., vol. 10, pp. 215­224, 1994. [43] M. J. Grannell, T. S. Griggs, and E. Mendelsohn, "A small basis for fourline configurations in Steiner triple systems," J. Combin. Des., vol. 3, pp. 51­59, 1995. [44] C. J. Colbourn, "The configuration polytope of -line configurations in Steiner triple systems," Mathematica Slovaca, vol. 59, no. 1, pp. 77­108, 2009. [45] P. Wohl, J. A. Waicukauski, and T. W. Williams, "Design of compactors for signature-analyzers in built-in-self-test," in Proc. Int. Test Conf., 2001, pp. 54­63. [46] P. Erd os, P. Frankl, and Z. F¨ uredi, "Families of finite sets in which no set is covered by the union of r others," Israel J. Math., vol. 51, pp. 75­89, 1985. [47] H. Hanani, "The existence and construction of balanced imcomplete block designs," Ann. Math. Statist., vol. 32, pp. 361­386, 1961. [48] ----, "On balanced incomplete block designs with blocks having five elements," J. Combin. Theory Ser. A, vol. 12, pp. 184­201, 1972. [49] R. M. Wilson, "An existence theory for pairwise balanced designs. III. Proof of the existence conjectures," J. Combin. Theory Ser. A, vol. 18, pp. 71­79, 1975. [50] C. J. Colbourn and J. H. Dinitz, Eds., Handbook of Combinatorial Designs. Boca Raton, FL: Chapman & Hall/CRC, 2007. [51] Y. M. Chee, C. J. Colbourn, and A. C. H. Ling, "Asymptotically optimal erasure-resilient codes for large disk arrays," Discrete Appl. Math., vol. 102, pp. 3­36, 2000. [52] M. M¨ uller and M. Jimbo, "Erasure-resilient codes from affine spaces," Discrete Appl. Math., vol. 143, pp. 292­297, 2004. [53] K. Mehlhorn, Data Structures and Algorithms 1. Berlin, Germany: Springer, 1984. [54] D. Tonien and R. Safavi-Naini, "Recursive constructions of secure codes and hash families using difference function families," J. Combin. Theory Ser. A, vol. 113, pp. 664­674, 2006. [55] Tran van Trung and S. S. Martirosyan, "New constructions for IPP codes," Des. Codes Cryptgr., vol. 32, pp. 227­239, 2005.

FUJIWARA AND COLBOURN: A COMBINATORIAL APPROACH TO X-TOLERANT COMPACTION CIRCUITS

11

[56] D. Deng, D. R. Stinson, and R. Wei, "The Lov´ asz local lemma and its applications to some combinatorial arrays," Des. Codes Cryptgr., vol. 32, pp. 121­134, 2004. [57] R. A. Walker II and C. J. Colbourn, "Perfect hash families: Construction and existence," Journal of Mathematical Cryptology, vol. 1, pp. 125­ 150, 2007. [58] S. S. Martirosyan and Tran van Trung, "Explicit constructions for perfect hash families," Des. Codes Cryptogr., vol. 46, no. 1, pp. 97­112, 2008. [59] H. Wang and C. Xing, "Explicit constructions of perfect hash families from algebraic curves over finite fields," J. Combin. Theory Ser. A, vol. 93, pp. 112­124, 2001. [60] C. J. Colbourn, "Constructing perfect hash families using a greedy algorithm," in Coding and Cryptology, Y. Li, S. Zhang, S. Ling, H. Wang, C. Xing, and H. Niederreiter, Eds. Singapore: World Scientific, 2008. [61] S. Mitra, S. S. Lumetta, and M. Mitzenmacher, "X-tolerant signature analysis," in Proc. Int. Test Conf., 2004, pp. 432­441.


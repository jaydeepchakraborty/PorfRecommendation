See	discussions,	stats,	and	author	profiles	for	this	publication	at:	https://www.researchgate.net/publication/4359251

Towards	a	General	Framework	for	Web	Service
Composition
Conference	Paper	·	August	2008
DOI:	10.1109/SCC.2008.134	·	Source:	IEEE	Xplore

CITATIONS

READS

2

27

4	authors,	including:
Ajay	Bansal

Gopal	Gupta

Arizona	State	University

University	of	Texas	at	Dallas

42	PUBLICATIONS			498	CITATIONS			

217	PUBLICATIONS			2,119	CITATIONS			

SEE	PROFILE

SEE	PROFILE

All	content	following	this	page	was	uploaded	by	Ajay	Bansal	on	04	June	2014.
The	user	has	requested	enhancement	of	the	downloaded	file.	All	in-text	references	underlined	in	blue	are	added	to	the	original	document
and	are	linked	to	publications	on	ResearchGate,	letting	you	access	and	read	them	immediately.

Towards a General Framework for Web Service Composition
Srividya Kona, Ajay Bansal, M. Brian Blake
Department of Computer Science,
Georgetown University
Washington, DC 20057

Gopal Gupta
Department of Computer Science,
The University of Texas at Dallas
Richardson, TX 75083

Abstract

S2
S5
CI’,I’

Service-oriented computing (SOC) has emerged as
the eminent market environment for sharing and reusing
service-centric capabilities. The underpinning for an organization’s use of SOC techniques is the ability to discover
and compose Web services. In this paper we present a generalized semantics-based technique for automatic service
composition that combines the rigor of process-oriented
composition with the descriptiveness of semantics. Our
generalized approach extends the common practice of linearly linked services by introducing the use of a conditional
directed acyclic graph (DAG) where complex interactions,
containing control flow, information flow and pre/post conditions, are effectively represented.

1. Introduction
Service-oriented computing is changing the way software applications are being designed, developed, delivered,
and consumed. A composite service is a collection of services combined together in some way to achieve a desired
effect. Traditionally, the task of automatic service composition has been split into four phases: (i) Planning, (ii) Discovery, (iii) Selection, and (iv) Execution [2]. Most efforts
reported in the literature focus on one or more of these four
phases. The first phase involves generating a plan, i.e., all
the services and the order in which they are to be composed
in order to obtain the composition. The plan may be generated manually, semi-automatically, or automatically. The
second phase involves discovering services as per the plan.
Depending on the approach, often planning and discovery
are combined into one step. After all the appropriate services are discovered, the selection phase involves selecting
the optimal solution from the available potential solutions
based on non-functional properties like QoS properties. The
last phase involves executing the services as per the plan and
in case any of them are not available, an alternate solution
has to be used.
In this paper we formalize the generalized composition
problem based on our conditional directed acyclic graph

CO’,O’

S3
S1

S4

Figure 1. Example of a Composite Service as
a Directed Acyclic Graph

representation. We present our approach that generates
most general compositions based on (conditional) directed
acyclic graphs (DAG). In our framework, the DAG representation of the composite service is reified as an OWL-S
description. This description document can be registered in
a repository and is thus available for future searches. The
composite service can now be discovered as a direct match
instead of having to look through the entire repository and
build the composition solution again.

2. Web service Composition
In this section we formalize the generalized composition
problem. In this generalization, we extend our previous
notion of composition [1] to handle non-sequential conditional composition (which we believe is the most general
case of composition). Informally, the Web service Composition problem can be defined as follows: given a repository of service descriptions, and a query with the requirements of the requested service, in case a matching service
is not found, the composition problem involves automatically finding a directed acyclic graph of services that can be
composed to obtain the desired service. Figure 1 shows an
example composite service made up of five services S1 to
S5 . In the figure, I 0 and CI 0 are the query input parameters
and pre-conditions respectively. O0 and CO0 are the query
output parameters and post-conditions respectively. Informally, the directed arc between nodes Si and Sj indicates
that outputs of Si constitute (some of) the inputs of Sj .
Definition (Repository of Services): Repository (R) is a
set of Web services.

Definition (Service): A service is a 6-tuple of its preconditions, inputs, side-effect, affected object, outputs and
post-conditions. S = (CI, I, A, AO, O, CO) is the representation of a service where CI is the list of pre-conditions,
I is the input list, A is the service’s side-effect, AO is the
affected object, O is the output list, and CO is the list of
post-conditions. The pre- and post-conditions are ground
logical predicates.
Definition (Query): The query service is defined as Q
= (CI 0 , I 0 , A0 , AO0 , O0 , CO0 ) where CI 0 is the list of preconditions, I 0 is the input list, A0 is the service affect, AO0
is the affected object, O0 is the output list, and CO0 is the
list of post-conditions. These are all the parameters of the
requested service.
Definition (Generalized Composition): The generalized
Composition problem can be defined as automatically finding a directed acyclic graph G = (V, E) of services from
repository R, given query Q = (CI 0 , I 0 , A0 , AO0 , O0 , CO0 ),
where V is the set of vertices and E is the set of edges of the
graph. Each vertex in the graph either represents a service
involved in the composition or post-condition of the immediate predecessor service in the graph, whose outcome can
be determined only after the execution of the service. Each
outgoing edge of a node (service) represents the outputs and
post-conditions produced by the service. Each incoming
edge of a node represents the inputs and pre-conditions of
the service. The following conditions should hold on the
nodes of the graph:
1. ∀i Si ∈ V where Si has exactly one incoming edge
that S
represents the query inputs and pre-conditions,
I 0 w i I i , CI 0 ⇒∧i CI i .
2. ∀i Si ∈ V where Si has exactly one outgoing edge
that represents
the query outputs and post-conditions,
S
O0 v i Oi , CO0 ⇐∧i COi .
3. ∀i Si ∈ V where Si represents a service and has at
least one incoming edge, let Si1 , Si2 , ..., Sim be the
nodes such that there is a directed
S edge from each
of these nodes to Si . Then Ii v k Oik ∪ I 0 , CI i ⇐
(COi1 ∧COi2 ... ∧ COim ∧ CI 0 ).
4. ∀i Si ∈ V where Si represents a condition that is
evaluated at run-time and has exactly one incoming
edge, let Sj be its immediate predecessor node such
that there is a directed edge from Sj to Si . Then the
inputs and pre-conditions at node Si are Ii = Oj ∪ I 0 ,
CI i = COj . The outgoing edges from Si represent
the outputs that are same as the inputs Ii and the postconditions that are the result of the condition evaluation at run-time.
The meaning of the v is the subsumption (subsumes) relation and ⇒ is the implication relation. In other words, a
service at any stage in the composition can potentially have
as its inputs all the outputs from its predecessors as well as
the query inputs. The services in the first stage of composi-

View publication stats

tion can only use the query inputs. The union of the outputs
produced by the services in the last stage of composition
should contain all the outputs that the query requires to be
produced. Also the post-conditions of services at any stage
in composition should imply the pre-conditions of services
in the next stage. When it cannot be determined at compile
time whether the post-conditions imply the pre-conditions
or not, a conditional node is created in the graph. The outgoing edges of the conditional node represent the possible
conditions which will be evaluated at run-time. Depending
on the condition that holds, the corresponding services are
executed. That is, if a subservice S1 is composed with subservice S2 , then the postconditions CO1 of S1 must imply
the preconditions CI 2 of S2 . The following conditions are
evaluated at run-time:
if (CO1 ⇒ CI 2 ) then execute S1 ;
else if (CO1 ⇒ ¬ CI 2 ) then no-op;
else if (CI 2 ) then execute S1 ;

3. Automatic Generation of Composite Services
In order to produce the composite service which is the
graph, we filter out services that are not useful for the composition at multiple stages. The composition routine starts
with the query input parameters. It finds all those services
from the repository which require a subset of the query input parameters. For the next stage, the inputs available are
the query input parameters and all the outputs produced by
the previous stage, i.e., I2 = O1 ∪ I. I2 is used to find services at the next stage, i.e., all those services that require
a subset of I2 . In order to make sure we do not end up in
cycles, we get only those services which require at least one
parameter from the outputs produced in the previous stage.
This filtering continues until all the query output parameters are produced. At this point we make another pass in
the reverse direction to remove redundant services which
do not directly or indirectly contribute to the query output
parameters. This is done starting with the output parameters
working our way backwards.

4. Conclusions and Future Work
To make Web services more practical we need a general framework for composition of Web services. The generalized approach presented in this paper can handle nonsequential conditional composition that can be used in automatic workflow generation in a number of applications.

References
[1] S. Kona, A. Bansal, and G. Gupta. Automatic Composition of Semantic Web Services. In ICWS, 2007.
[2] J. Cardoso, A. Sheth. Semantic Web Services, Processes and Applications. Springer, 2006.


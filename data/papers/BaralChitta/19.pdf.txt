Finitary S5-Theories
Tran Cao Son1 , Enrico Pontelli1 , Chitta Baral2 , and Gregory Gelfond2
1

2

Computer Science Department, New Mexico State University
{tson,epontell}@cs.nmsu.edu
Department of Computer Science Engineering, Arizona State University
{chitta,gelfond.greg}@asu.edu

Abstract. The objective of this paper is to identify a class of epistemic logic
theories with group knowledge operators which have the fundamental property
of being characterized by a finite number of finite models (up to equivalence). We
specifically focus on S5-theories. We call this class of epistemic logic theories as
finitary S5-theories. Models of finitary S5-theories can be shown to be canonical
in that they do not contain two worlds with the same interpretation. When the
theory is pure, these models are minimal and differ from each other only in the
actual world. The paper presents an algorithm for computing all models of a
finitary S5-theory. Finitary S5-theories find applications in several contexts—in
particular, the paper discusses their use in epistemic multi-agent planning.

1 Introduction and Motivation
Epistemic logics [2, 7, 8, 10] are a branch of modal logic that is concerned with representing and reasoning about the knowledge of collections of agents. These logics
allow us to represent and reason about the knowledge of an agent about the world, its
knowledge about other agents’ knowledge, group’s knowledge, common knowledge,
etc. The models of an epistemic theory are commonly given by pointed Kripke structures. Each pointed Kripke structure consists of a set of elements named worlds (also
known as points), a collection of binary relations between worlds (accessibility relations), a named valuation associated to each world, and an actual world—considered as
the “real state of the universe”. Models of an epistemic theory can be potentially infinite. Indeed, one can easily create an infinite model of an epistemic theory from a finite
one, by cloning its whole structure (including the accessibility relations, the worlds,
etc.). Bisimulation (e.g., [2]) can be used to reduce the size of a model. It is possible to
show that, given a theory that employs a single modal operator and has a finite signature,
there are only finitely many models with the property that (a) all of them are finite and
bisimulation-based minimal; and (b) any model of the theory is bisimilar (and, hence,
equivalent) to one of those models. This is not true, however, for multimodal theories,
i.e., theories with multiple modal operators.
In this paper, we study the questions of when a multimodal propositional epistemic
theory can be characterized by finitely many finite models (up to equivalence), and how
to compute these models. The motivation for these questions is twofold.
First, the question arises in the research on using epistemic theories in Multi-Agent
Systems (MAS), in particular, in the development of the Dynamic Epistemic Logic (DEL)
E. Fermé and J. Leite (Eds.): JELIA 2014, LNAI 8761, pp. 239–252, 2014.
c Springer International Publishing Switzerland 2014
⃝

240

T.C. Son et al.

[1, 3, 6, 11] for reasoning about effects of actions in MAS. This line of research has laid
the foundations for the study of the epistemic planning problem in multi-agent environments [5, 12, 14]. Yet, the majority of the research in epistemic planning assumes
that the set of initial pointed Kripke structures is given, and it is either finite [12, 14] or
recursively enumerable [5]. This creates a gap between the rich literature in theoretical
investigation of epistemic planning (e.g., formalization, complexity results) and the very
modest developments in automated epistemic planning systems—that can benefit from
the state-of-the-art techniques developed for planning systems in single-agent environments. In particular, there is a plethora of planners for single-agent environments, that
perform exceptionally well in terms of scalability and efficiency;1 the majority of them
are heuristic forward-search planners. On the other hand, to the best of our knowledge,
the systems described in [12, 14] are the only epistemic multi-agent planning prototypes
available, that search for solutions using breath-first search and model checking.
The second research motivation comes from the observation that the S5-logic is the
de-facto standard logic for reasoning and planning with sensing actions in presence of
incomplete information for single-agent domains. The literature is scarce on methods
for computing models of S5 multimodal epistemic theories. Works such as [15, 16]
are exceptions, and they focus on the least models of a modal theory. Several papers,
instead, assume that such models are, somehow, given. For instance, after describing
the muddy-children story, the authors of [7] present a model of the theory without detailing how should one construct such model and whether or not the theory has other
“interesting” models.
These observations show that, in order to be able to use epistemic logic as a specification language in practical MAS applications, such as epistemic multi-agent planning,
the issue of how to compute the set of models of a theory must be addressed.
In this paper, we address this question by identifying a class of finitary S5-theories
with group and common knowledge operators, that can be characterized by finitely
many finite models. We prove that each model of a finitary S5-theory is equivalent to
one of these canonical models, and propose an effective algorithm for computing such
set of canonical models. We discuss a representation of finitary S5-theories suitable for
use with the algorithm. We also discuss the impact of these results in epistemic multiagent planning.

2 Preliminary: Epistemic Logic
Let us consider the epistemic logic with a set AG = {1, 2, . . . , n} of n agents; we will
adopt the notation used in [2, 7]. The “physical” state of the world is described by a
finite set P of propositions. The knowledge of the world of agent i is described by a
modal operator Ki ; in particular, the knowledge of agents is encoded by knowledge
formulae (or formula) in a logic extended with these operators, and defined as follows.
• Atomic formulae: an atomic formula is built using the propositions in P and the
traditional propositional connectives ∨, ∧, →, ¬, etc. A literal is either an atom
f ∈ P or its negation ¬f . ⊤ (resp. ⊥) denotes true (resp. f alse).
1

E.g., http://ipc.icaps-conference.org/ lists 27 participants in the 2011 International Planning Competition.

Finitary S5-Theories

241

• Knowledge formulae: a knowledge formula is a formula in one of the following
forms: (i) An atomic formula; (ii) A formula of the form Ki ϕ, where ϕ is a knowledge formula; (iii) A formula of the form ϕ1 ∨ ϕ2 , ϕ1 ∧ ϕ2 , ϕ1 → ϕ2 , or ¬ϕ1 ,
where ϕ1 , ϕ2 are knowledge formulae; (iv) A formula of the form Eα ϕ or Cα ϕ
where ϕ is a formula and ∅ ̸= α ⊆ AG.
Formulae of the form Eα ϕ and Cα ϕ are referred to as group formulae. Whenever
α = AG, we simply write Eϕ and Cϕ to denote Eα ϕ and Cα ϕ, respectively. When no
confusion is possible, we will talk about formula instead of knowledge formula. Let us
denote with LP
AG the language of the knowledge formulae over P and AG. An epistemic
theory (or simply a theory) over the set of agents AG and propositions P is a set of
knowledge formulae in LP
AG . To illustrate the language, we will use the well-known
Muddy Children problem as a running example. For simplicity of the presentation, let
us consider the case with two children.
[Muddy Children] A father says to his two children that at least one of them
has mud on the forehead. He then repeatedly asks “do you know whether you
are dirty?” The first time the two children answer “no.” The second time both
answer “yes.” The father and the children can see and hear each other, but no
child can see his own forehead.
Let AG = {1, 2}. Let mi denote that child i is muddy. Some formulae in LP
AG are:
(i) mi (i is muddy); (ii) K1 m1 (child 1 knows he is muddy); (iii) K1 K2 m2 (child 1
knows that child 2 knows that he is muddy); and (iv) C{1,2} (m1 ∨ m2 ) (it is common
knowledge among the children that at least one is muddy).
The semantics of knowledge formulae relies on the notion of Kripke structures.
Definition 1 (Kripke Structure). A Kripke structure over AG = {1, . . . , n} and P is
a tuple ⟨S, π, K1 , . . . , Kn ⟩, where S is a set of points, π is a function that associates
an interpretation of P to each element of S (i.e., π : S,→2P ), and Ki ⊆ S × S for
1 ≤ i ≤ n. A pointed Kripke structure (or, pointed structure, for short) is a pair (M, s),
where M is a Kripke structure and s, called the actual world, belongs to the set of points
of M .
For readability, we use M [S], M [π], and M [i], to denote the components S, π, and Ki
of M , respectively. Using this notation, M [π](u) denotes the interpretation associated
to the point u.
Definition 2 (Satisfaction Relation). Given a formula ϕ and a pointed structure (M, s):
• (M, s) |= ϕ if ϕ is an atomic formula and M [π](s) |= ϕ;
• (M, s) |= Ki ϕ if for each t such that (s, t) ∈ Ki , (M, t) |= ϕ;
• (M, s) |= ¬ϕ if (M, s) ̸|= ϕ;
• (M, s) |= ϕ1 ∨ ϕ2 if (M, s) |= ϕ1 or (M, s) |= ϕ2 ;
• (M, s) |= ϕ1 ∧ ϕ2 if (M, s) |= ϕ1 and (M, s) |= ϕ2 ;
• (M, s) |= Eα ϕ if (M, s) |= Ki ϕ for every i ∈ α;
• (M, s) |= Cα ϕ if (M, s) |= Eαk ϕ for every k ≥ 0 where Eα0 ϕ = ϕ and Eαk+1 =
Eα (Eαk ϕ).
M |= ϕ denotes the fact that (M, s) |= ϕ for each s ∈ M [S], while |= ϕ denotes the
fact that M |= ϕ for all Kripke structures M . We will often depict a Kripke structure

242

T.C. Son et al.

M as a directed labeled graph, with S as the set of nodes and with edges of the form
(s, i, t) iff (s, t) ∈ Ki . We say that un is reachable from u1 if there is a sequence of
edges (u1 , i1 , u2 ), (u2 , i2 , u3 ), . . . , (un−1 , in−1 , un ) in M .
A Kripke structure denotes the possible “worlds” envisioned by the agents—and the
presence of multiple worlds denotes uncertainty and presence of different knowledge.
The relation (s1 , s2 ) ∈ Ki indicates that the knowledge of agent i about the real state
of the world is insufficient to distinguish between the state described by point s1 and
the one described by point s2 . For example, if (s1 , s2 ) ∈ Ki , M [π](s1 ) |= ϕ and
M [π](s2 ) |= ¬ϕ, everything else being the same, then this will indicate that agent i
is uncertain about the truth of ϕ. Figure 1 displays a possible pointed structure for the
1,2
s1:
m1

1,2
1

m2

m2

2
s3:
m1
¬m2

s2:
¬m1

2

1

1,2

s4:
¬m1
¬m2

1,2

Fig. 1. A possible pointed structure for the Muddy Children Domain

Muddy Children Domain. In Figure 1, a circle represents a point. The name and interpretation of the points are written in the circle. Labeled edges between points denote
the knowledge relations of the structure. A double circle identifies the actual world.
Various axioms are used to characterize epistemic logic systems. We will focus on
the S5-logic that contains the following axioms for each agent i and formulae ϕ, ψ:
(K)
|= (Ki ϕ ∧ Ki (ϕ ⇒ ψ)) ⇒ Ki ψ
(T)
|= Ki ψ ⇒ ψ
|= Ki ψ ⇒ Ki Ki ψ
(4)
|= ¬Ki ψ ⇒ Ki ¬Ki ψ
(5)
A Kripke structure is said to be an S5-structure if it satisfies the properties K, T, 4, and
5. It can be shown that the relations Ki of S5-structures are reflexive, transitive, and
symmetric. A theory plus the K, T, 4, and 5 axioms is often referred to as an S5-theory.
In the rest of this paper, we will consider only S5-theories. A theory T is said to be
satisfiable (or consistent) if there exists a Kripke structure M and a point s ∈ M [S]
such that (M, s) |= ψ for every ψ ∈ T . In this case, (M, s) is referred to as a model
of T . Two pointed structures (M, s) and (M ′ , s′ ) are equivalent if, for every formula
′ ′
ϕ∈LP
AG , (M, s) |= ϕ iff (M , s ) |= ϕ.
For simplicity of the presentation, we define
!
!
state(u) ≡
f∧
¬f
f ∈P, M[π](u)(f )=⊤

f ∈P, M[π](u)(f )=⊥

Finitary S5-Theories

243

for u ∈ M [S]. Intuitively, state(u) is the formula representing the complete interpretation associated to the point u in the structure M , i.e., M [π](u). We will often use
state(u) and M [π](u) interchangeably. We say that (M, s) is canonical if state(u) ̸≡
state(v) for every u, v ∈ M [S], u ̸= v. By M odsS5 (T ) we denote a set of S5-models
of a theory T such that: (a) there are no two equivalent models in M odsS5 (T ); and (b)
For each S5-model (M, s) of T , there exists a model (M ′ , s′ ) in M odsS5 (T ) such that
(M, s) is equivalent to (M ′ , s′ ).

3 Finitary S5-Theories: Definition and Properties
In this section, we define the notion of finitary S5-theories and show that a finitary
S5-theory can be characterized by finitely many finite models. We start with the specification of the types of formulae that we will consider. They are, in our observation,
sufficiently expressive for use in the specification of the description of the actual world
and the common knowledge among the agents. The allowed types of formulae are:
ϕ

(1)

C(Ki ϕ)
C(Ki ϕ ∨ Ki ¬ϕ)

(2)
(3)
(4)

C(¬Ki ϕ ∧ ¬Ki ¬ϕ)

where ϕ is an atomic formula. Intuitively, formulae of type (1) indicate properties that
are true in the actual world; formulae of type (2)-(3) indicate that all agents know that
agent i is aware of the truth value of ϕ; formulae of type (4) indicate that all agents
know that agent i is not aware of whether ϕ is true or false. Since our focus is on S5models of epistemic theories, it is easy to see that C(Ki ϕ) can be simplified to C(ϕ).
We say that a formula of the form (1)-(4) is in disjunctive form if its formula ϕ is a
disjunction over literals from P. A complete clause over P is a disjunction of the form
"
∗
∗
p∈P p where p is either p or ¬p.

Example 1. In the muddy children story, the knowledge of the children after the father’s
announcement but before the children look at each other can be encoded by a theory T0
consisting of the following formulae:
C(K1 (m1 ∨ m2 ))

C(¬K1 m1 ∧ ¬K1 ¬m1 )
C(¬K2 m1 ∧ ¬K2 ¬m1 )

C(K2 (m1 ∨ m2 ))

C(¬K1 m2 ∧ ¬K1 ¬m2 )
C(¬K2 m2 ∧ ¬K2 ¬m2 )

These formulae indicate that both children are aware that at least one of them is muddy
(the formulas in the first row), but they are not aware of who among them is muddy;
these items are all common knowledge.
If we take into account the fact that each child can see the other, and each child
knows if the other one is muddy, then we need to add to T0 the following formulae:
C(K1 m2 ∨ K1 ¬m2 )

C(K2 m1 ∨ K2 ¬m1 )

244

T.C. Son et al.

Definition 3 (Primitive Finitary S5-Theory). A theory T is said to be primitive finitary S5 if
• Each formula in T is of the form (1)-(4); and
• For each complete clause ϕ over P and each agent i, T contains either (i) C(Ki ϕ)
or (ii) C(Ki ϕ ∨ Ki ¬ϕ) or (iii) C(¬Ki ϕ ∧ ¬Ki ¬ϕ).
T is said to be in disjunctive form if all statements in T are in disjunctive form.
The second condition of the above definition deserves some discussion. It requires that
T contains at least |AG| × 2|P| formulae and could be unmanageable for large P. This
condition is introduced for simplicity of initial analysis of finitary S5-theories. This
condition will be relaxed at the end of this section by replacing the requirement “T
contains” with “T entails.” For example, the theory T0 is not a primitive finitary S5theory; T0 is a finitary S5-theory (defined later) as it entails a primitive finitary S5theory T1 .
Example 2. Let T1 be the theory consisting of:
C(Ki (m1 ∨ m2 ))
C(¬Ki (m1 ∨ ¬m2 ) ∧ ¬Ki (¬(m1 ∨ ¬m2 )))

C(¬Ki (¬m1 ∨ m2 ) ∧ ¬Ki (¬(¬m1 ∨ m2 )))

C(¬Ki (¬m1 ∨ ¬m2 ) ∧ ¬Ki (¬(¬m1 ∨ ¬m2 )))
where i = 1, 2. It is easy to see that T1 is a primitive finitary S5-theory—and it is
equivalent to T0 from Example 1.
Primitive finitary S5-theories can represent interesting properties.
Example 3. Consider the statement “it is common knowledge that none of the agents
knows anything.” The statement can be represented by the theory
T2 = {C(¬Ki ω ∧ ¬Ki ¬ω) | i ∈ AG, ω is a complete clause over P}.
We will show that a primitive finitary S5-theory can be characterized by finitely many
finite S5-models. The proof of this property relies on a series of lemmas. We will next
discuss these lemmas and provide proofs of the non-trivial ones. First, we observe that
points that are unreachable from the actual world in a pointed structure can be removed.
Lemma 1. Every S5-pointed structure (M, s) is equivalent to an S5-pointed structure
(M ′ , s) such that every u ∈ M ′ [S] is reachable from s.

The next lemma studies the properties of an S5-pointed structure satisfying a formula
of the form (2) or (3).
Lemma 2. Let (M, s) be an S5-pointed structure such that every u ∈ M [S] is reachable from s. Let ψ be an atomic formula. Then,
• (M, s) |= C(ψ) iff M [π](u) |= ψ for every u ∈ M [S].
• (M, s) |= C(Ki ψ∨Ki¬ψ) iff for every pair (u, v) ∈ M [i] it holds that M [π](u) |=
ψ iff M [π](v) |= ψ.

Finitary S5-Theories

245

Because C(Ki ψ) implies C(ψ) in an S5-pointed structure (M, s) the first item of
Lemma 2 shows that ψ is satisfied at every point in (M, s). The second item of Lemma 2
shows that every pair of points related by Ki either both satisfy or both do not satisfy
the formula ϕ in an S5-pointed structure (M, s) satisfying a formula of the form (3).
The next lemma shows that an S5-pointed structure satisfying a formula of the form
(4) must have at least one pair of points at which the value of the atomic formula mentioned in the formula differs. For a structure M and u, v ∈ M [S], M [π](u)(ψ) ̸=
M [π](v)(ψ) indicates that either (M [π](u) |= ψ and M [π](v) ̸|= ψ) or (M [π](u) ̸|= ψ
and M [π](v) |= ψ), i.e., the value of ψ at u is different from the value of ψ at v.
Lemma 3. Let (M, s) be an S5-pointed structure such that every u ∈ M [S] is reachable from s. Let ψ be an atomic formula. Then, (M, s) |= C(¬Ki ψ ∧ ¬Ki ¬ψ) iff
for every u ∈ M [S] there exists some v ∈ M [S] such that (u, v) ∈ M [i], and
M [π](u)(ψ) ̸= M [π](v)(ψ).
The proofs of Lemmas 1-3 follow from the definition of the satisfaction relation |= between a pointed structure and a formula and the fact that (M, s) |= C(ψ) iff (M, u) |=
ψ for every u reachable from s. For this reason, they are omitted.
We will now focus on models of primitive finitary S5-theories. Let M be a Kripke
structure. We define a relation ∼ among points of M as follows. For each u, v ∈ M [S],
u ∼ v iff state(u) ≡ state(v). Thus, u ∼ v indicates that the interpretations associated
to u and v are identical. It is easy to see that ∼ is an equivalence relation over M [S].
Let ũ denote the equivalence class of u with respect to the relation ∼ (i.e., ũ = [u]∼ ).
Lemma 4. Let (M, s) be an S5-model of a primitive finitary S5-theory such that every
u ∈ M [S] is reachable from s. Let ϕ be a complete clause and i ∈ AG. Given u ∈
M [S]:
• If (M, u) |= Ki ϕ then (M, s) |= C(Ki ϕ) or (M, s) |= C(Ki ϕ ∨ Ki ¬ϕ);
• If (M, u) |= ¬Ki ϕ then (M, s) |= C(¬Ki ϕ ∧ ¬Ki ¬ϕ).
The proof of Lemma 4 makes use of Lemmas 2-3 and the fact that (M, s) is an S5model of a primitive finitary S5-theory. The next lemma states a fundamental property
of models of primitive finitary S5-theories.
Lemma 5. Let (M, s) be an S5-model of a primitive finitary S5-theory such that every
u ∈ M [S] is reachable from s. Let u, v ∈ M [S] such that u ∼ v. Then, for every
i ∈ AG and x ∈ M [S] such that (u, x) ∈ M [i] there exists y ∈ M [S] such that
(v, y) ∈ M [i] and x ∼ y.
Proof. Let K(p, i) = {q | q ∈ M [S], (p, q) ∈ M [i]}—i.e., the set of points immediately related to p via M [i]. We consider two cases:
• Case 1: K(u, i) ∩ K(v, i) ̸= ∅. Since M [i] is an equivalent relation, we can conclude that K(u, i) = K(v, i) and the lemma is trivially proved (by taking x = y).
• Case 2: K(u, i) ∩ K(v, i) = ∅. Let us assume that there exists some x ∈ K(u, i)
such that there exists no y ∈ K(v, i) with x ∼ y. This means that (M, y) |=
¬state(x) for each y ∈ K(v, i). In other words, (M, v) |= Ki (¬state(x)). As
¬state(x) is a complete clause, this implies that (by Lemma 4):

246

T.C. Son et al.

(M, s) |= C(Ki ¬state(x)) or (M, s) |= C(Ki ¬state(x) ∨ Ki state(x)) (5)
On the other hand, (M, u) ̸|= Ki (¬state(x)), since x ∈ K(u, i) and (M, x) |=
state(x). This implies (M, s) |= C(¬Ki ¬state(x) ∧ ¬Ki state(x)) by Lemma 4.
This contradicts (5), proving the lemma.
!
Lemma 5 shows that the points with the same interpretation have the same structure in
an S5-model of a primitive finitary S5-theory, i.e., the accessibility relations associated
to these points are identical. This indicates that we can group all such points into a
single one, producing an equivalent model that is obviously finite. Let us show that this
# be the structure constructed as follows:
is indeed the case. Given a structure M , let M
#
• M [S] = {ũ | u ∈ M [S]}
#[π](ũ)(f ) = M [π](u)(f )
• For every u ∈ M [S] and f ∈ P, M
#[i] if there exists (u′ , v ′ ) ∈ M [i] such that u′ ∈ ũ and
• For each i ∈ AG, (ũ, ṽ) ∈ M
′
v ∈ ṽ.
#, s̃) the reduced pointed structure of (M, s) and prove that it is an S5-pointed
We call (M
structure equivalent to (M, s):

Lemma 6. Let (M, s) be an S5-model of a primitive finitary S5-theory T such that
#, s̃) be the reduced pointed
every u ∈ M [S] is reachable from s. Furthermore, let (M
#, s̃) is a finite S5-model of T that is equivalent to (M, s).
structure of (M, s). Then, (M

Proof. The proof of this lemma relies on Lemmas 2-3 and 5. We prove some representative properties.
#, s̃) is S5. Reflexivity and symmetry are obvious. Let us prove transitivity: as• (M
#[i] and (ṽ, w̃) ∈ M
#[i]. The former implies that there exists
sume that (ũ, ṽ) ∈ M
(u1 , v1 ) ∈ M [i] for some u1 ∈ ũ and v1 ∈ ṽ. The latter implies that there exists
(x1 , w1 ) ∈ M [i] for some x1 ∈ ṽ and w1 ∈ w̃. Since ∼ is an equivalence relation,
v1 ∼ x1 . Lemma 5 implies that there exists some w2 ∼w1 such that (v1 , w2 )∈M [i]
#[i], i.e.,
which implies that, by transitivity of M [i], (u1 , w2 )∈M [i], so (ũ, w̃)∈M
#[i] is transitive.
M
#, s̃) is a model of T . We have that
• (M
(M, s) |= C(Ki ψ ∨ Ki ¬ψ) iff
∀u, v ∈ M [S], (u, v) ∈ M [i] implies M [π](u) |= ψ iff M [π](v) |= ψ (by Lemma
2 w.r.t. (M, s)) iff
#[S], u ∈ p̃ and v ∈ q̃, (p̃, q̃) ∈ M
#[i] implies M
#[π](p̃)|=ψ iff M
#[π](q̃)|=ψ
∀p̃, q̃ ∈ M
#, s̃)) iff
(construction of (M
#
#, s̃)).
(M , s̃) |= C(Ki ψ ∨ Ki ¬ψ) (by Lemma 2 w.r.t. (M
The proof for other statements is similar.
#, s̃) is equivalent to (M, s). This is done by induction over the number of K
• (M
operators in a formula.
!
Let
$
%
#
#, s̃) | (M , s̃) is a reduced pointed structure
µM odsS5 (T ) = (M
| of a S5-model (M, s) of T
Since each S5-model of T is equivalent to its reduced pointed structure, which has at
most 2|P| points, we have the next theorem.

Finitary S5-Theories

247

Theorem 1. For a consistent primitive finitary S5-theory T , µM odsS5 (T ) is finite and
such that each (M, s) in µM odsS5 (T ) is also finite.
This theorem shows that primitive finitary S5-theories have the desired properties that
we are looking for. The next theorem proves interesting properties of models of primitive finitary S5-theories which are useful for computing µM odsS5 (T ).
Theorem 2. For a primitive finitary S5-theory T , every model (M, s) in µM odsS5 (T )
is canonical and |M [S]| is minimal among all models of T . Furthermore, for every
pair of models (M, s) and (W, w) in µM odsS5 (T ), M and W are identical, up to the
names of the points.
The first conclusion is trivial as each reduced pointed structure of a model of T is a
canonical model of T . The next lemma proves the second conclusion.
Lemma 7. Let T be a primitive finitary S5-theory, (M, s) and (V, w) in µM odsS5 (T ),
and let i ∈ AG.
• For each u ∈ M [S] there exists some v ∈ V [S] such that state(u) ≡ state(v).
• If (u, p) ∈ M [i] then there exists (v, q) ∈ V [i] such that state(u) ≡ state(v) and
state(p) ≡ state(q).
Proof. (Sketch) The proof of the first property is similar to the proof of Lemma 5, with
the minor modification that it refers to two structures and that both are models of T .
In fact, if u ∈ M [S] and there exists no v ∈ V [S] such that state(u) ≡ state(v)
then (V, w) |= C(Kk ¬state(u)) and (M, s) ̸|= C(Kk ¬state(u)) for k ∈ AG, a
contradiction. The proof of the second property uses a similar argument.
!
To prove that the set of points of a model in µM odsS5 (T ) is minimal, we use the
next lemma. We define:
F (T ) = {ϕ | ϕ appears in a formula of the form (2) of T }.
Lemma 8. Let (M, s) be a canonical model of a primitive finitary S5-theory T . Then,
the set M [S] is exactly the set of interpretations of F (T ) and each u ∈ M [S] is reachable.
Proof. (Sketch) First, it follows directly from Lemma 2 and C(Ki ψ) |= C(ψ) in an
S5-model that for each u ∈ M [S], state(u) |= ϕ for every ϕ ∈ F (T ). Second, because
T is primitive finitary, if there is some interpretation I of F (T ) such that there exists
no u ∈ M [S] and state(u) = I or there exists u ∈ M [S] with state(u) = I and
u is not reachable from s then we can conclude that (M, s) |= C(¬I), and because
T is a primitive finitary, we have that ¬I ∈ F (T ). This implies that I cannot be an
!
interpretation of F (T ), a contradiction. Both properties prove the lemma.
We are now ready to define the notion of a finitary S5-theory that allows for Theorem 1 to extend to epistemic theories consisting of arbitrary formulae.
Definition 4 (Finitary S5-Theory). An epistemic theory T is a finitary S5-theory if
T |= H and H is a primitive finitary S5-theory. T is pure if T contains only formulae
of the form (1)-(4).

248

T.C. Son et al.

We have that T0 (Example 1) is a finitary S5-theory, since T0 |= T1 and T1 is a primitive
finitary S5-theory. Since a model of T is also a model of H if T |= H, the following
theorem holds.
Theorem 3. Every finitary S5-theory T has finitely many finite canonical models, up
to equivalence. If T is pure then these models are minimal and their structures are
identical up to the name of the points.

4 Computing All Models of Finitary S5-Theories
In this section, we present an algorithm for computing µM odsS5 (T ) for a primitive
finitary S5-theory and discuss how this can be extended to arbitrary finitary S5-theories.
Lemma 8 shows that F (T ) can be used to identify the set of points of canonical models
of T . Applying this lemma to T0 (Example 1), we know that for every canonical model
(M, s) of T0 , M [S] = {s1 , s2 , s3 } where state(s1 ) = m1 ∧ m2 , state(s2 ) = m1 ∧
¬m2 , and state(s3 ) = ¬m1 ∧ m2 .
The next step is to determine the accessibility relations of i ∈ AG. We will rely on
Lemmas 2-3 and the following result:
Lemma 9. Let (M, s) be a canonical model of a consistent primitive finitary S5-theory
T and i ∈ AG. Assume that for each complete clause ϕ, if T ̸|= C(Ki ϕ) then T ̸|=
C(Ki ϕ ∨ Ki ¬ϕ). Then, (u, v) ∈ M [i] for every pair u, v ∈ M [S].
Proof. The proof of this lemma is by contradiction and uses an idea similar to that used
in the proof of Case 2 of Lemma 5. Since (M, s) is a canonical model, each u ∈ M [S] is
reachable from s. Assume that there exists a pair u, v ∈ M [S] such that (u, v) ̸∈ M [i].
We have that (M, u) |= Ki ¬state(v). As ¬state(v) is a complete clause, by Lemma 4:
(M, s) |= C(Ki ¬state(v))

or (M, s) |= C(Ki ¬state(v) ∨ Ki state(v))

(6)

On the other hand, since (u, v) ̸∈ M [i] and M is a S5-structure, we have that (M, v) ̸|=
Ki ¬state(v). This, together with the assumption of the lemma, contradicts (6).
6
⊓
Algorithm 12 computes all canonical minimal models of a primitive finitary S5-theory.
Its correctness follows from the properties of an S5-model of primitive finitary S5theories discussed in Lemmas 2-3 and 7-9. This algorithm runs in polynomial time in
the size of T , which, unfortunately, is exponential in the size of P.
Note that, for the theory T2 in Example 3, Algorithm 1 returns the set of pointed
structures (M, s) such that M [S] is the set of all interpretations of P, M [i] is a complete
graph on M [S], and s ∈ M [S].
Fig. 2 shows one model of T1 returned by Algorithm 1. Since C(Ki (l1 ∨l2 ) ∨
Ki ¬(l1 ∨l2 )) ̸∈ T1 for every complete clause over {m1 , m2 } that is different from
m1 ∨ m2 , there is a link labeled i between every pair of worlds of the model. Since
I(T1 ) is empty, µM odsS5 (T1 ) contains three models, which differ from each other
only in the actual world.
2

We assume that the theory is consistent.

Finitary S5-Theories

249

Algorithm 1. M odel(T )
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Input: A primitive finitary S5-theory T
Output: µM odsS5 (T )
Compute I(T ) = {ϕ | ϕ appears in some (1) of T }
Compute F (T ) = {ϕ | ϕ appears in some (2) of T }
Σ = {u | u is an interpretation satisfying F (T )}
Let M [S] = Σ, M [π](u) = u, and M [i] = {(u, v) | u, v ∈ Σ}
for each C(Ki ϕ ∨ Ki ¬ϕ) in T do
remove (u, v) ∈ M [i] such that M [π](u)(ϕ) ̸= M [π](v)(ϕ)
end for
return {(M, s) | s satisfies I(T )}
1,2
s1:
m1

1,2
s2:
¬m1

1,2

m2

1,2

m2

1,2

s3:
m1
¬m2

1,2

Fig. 2. A model of the theory T1 in Example 2

The application of Algorithm 1 to an arbitrary finitary S5-theory T , where T |=
H for some primitive finitary S5-theory H, can be done in two steps: (a) Compute
µM odsS5 (H); and (b) Eliminate models from µM odsS5 (H) which are not a model
of T . Step (b) is necessary, since T can contain other formulae that are not entailed by
H.3 To accomplish (a), the following tasks need to be performed: (i) Verify that T is
finitary; (ii) Compute I(T ) = {ψ | ψ is an atomic formula and T |= ψ} (Line 3) and
F (T ) = {ϕ | T |= C(ϕ)} (Line 4); (iii) Test for entailment (Line 7); (iv) Eliminate
pointed structures that are not models of T (Line 10). Since these tasks are generally
computational expensive, it it naturally to seek ways to improve performance. In the
next section, we discuss a possible way to deal with (iv). We will next show that when
T is pure and in disjunctive form then the computation required in (i)-(iii) can be done
in polynomial time in the size of T .
Given a pure theory T in disjunctive form, Task (ii) can be done as described in
Lines 3 and 4 and does not require any additional computation. Given a pair (i, ϕ) of
an agent i and a complete clause ϕ, we would like to efficiently determine whether
T |= C(Ki ϕ), T |= C(Ki ϕ ∨ Ki ¬ϕ), or T |= C(¬Ki ϕ ∧ ¬Ki ¬ϕ) hold. This task
can be accomplished via a test for coverage
"defined as follows. We say that ϕ is covered
by a set W of disjunctions over P if ϕ ≡ ψ∈W ψ. A pair (i, ϕ) is covered by T if
3

A consequence of this elimination is that canonical models of a non-pure finitary S5-theory
may not have the same structure and/or different set of worlds.

250

T.C. Son et al.

• T contains some statement C(Kk ψ) (for some k ∈ AG) such that ψ |= ϕ; or
• ϕ is covered by some consistent set of disjunctions
W ⊆ {ψ | C(Ki ψ ∨ Ki ¬ψ) ∈ T }.
Intuitively, if (i, ϕ) is covered by T then it is common knowledge that i knows the
truth value of ϕ. The first item implies that T |= C(Ki ϕ), i.e., everyone knows ϕ.
The second item states that everyone knows that i knows ϕ—because (i) ϕ is covered by a set of disjunctions that are known by i, (ii) this is common knowledge, and
(iii) the axiom |= (Kψ1 ∨K¬ψ1 ) ∧ (Kψ2 ∨ K¬ψ2 ) ⇒ K((ψ1 ∨ψ2 )∨K¬(ψ1 ∨ψ2 )).
Thus, if ϕ is a complete clause and (i, ϕ) is not covered by T then T ̸|= C(Ki ϕ) and
T ̸|=C(Ki ϕ∨Ki ¬ϕ). It is easy to see that checking whether (i, ϕ) is covered by T can
be done in polynomial time in the size of T when T is pure and in disjunctive form.
The above discussion shows that, when T is pure and in disjunctive form, Algorithm 1 can compute all models of T , if it is finitary, without significant additional cost.
For example, T0 is pure and in disjunctive form and Algorithm 1 will return the same
set of models as if T1 is used as input.

5 Discussion
The previous sections focused on the development of the notion of a finitary S5-theory
and the computation of its models. We now discuss a potential use of finitary S5-theories
as a specification language. Specifically, we consider their use in the specification of
the initial set of pointed structures for epistemic multi-agent planning. Let us consider
a simple example concerning the Muddy Children Domain: “The father sees that his
two children are muddy. The children can see each other, hear the father, and truthfully
answer questions from the father but cannot talk to each other. They also know that
none of the children knows whether he is muddy or not. How can the father inform
his children that both of them are muddy without telling them the fact?” As we have
mentioned earlier, previous works in epistemic multi-agent planning assume that the set
of initial pointed structures is given, and these are assumed to be finite or enumerable.
However, a way to specify the set of initial pointed structures is not offered. Clearly,
finitary S5-theories can fill this need. Let us discuss some considerations in the use of
finitary S5-theories as a specification language.
The definition of a finitary S5-theory, by Definitions 3-4, calls for the test of entailment (or the specification) of |AG| × 2|P| formulae. Clearly, this is not desirable. To
address this issue, let us observe that Algorithm 1 makes use of formulae of the form (4)
implicitly (Line 6), by assuming that all but those complete clauses entailed by F (T )
are unknown to agent i and that is common knowledge. This means that we could reduce the task of specifying T by assuming that its set of statements of the form (4)
is given implicitly, i.e., by representing the information that the agents do not know
implicitly. This idea is similar to the use of the Closed World Assumption to represent
incomplete information. This can be realized as follows. For a theory T and an agent
i ∈ AG, let
'
&
C(T, i) = ϕ ϕ is a complete clause,T ̸|= C(Ki ϕ), T ̸|= C(Ki ϕ ∨ Ki ¬ϕ)
(
Let neg(T ) = i∈AG {C(¬Ki ϕ ∧ ¬Ki ¬ϕ) | ϕ ∈ C(T, i)}. The completion of T is
comp(T ) = T ∪ neg(T ).

Finitary S5-Theories

251

Given an arbitrary theory T , comp(T ) is a finitary S5-theory; as such, it could be
used as the specification of a finitary S5-theory. If comp(T ) is used and T is pure and
in disjunctive form, then the specification (of T ) only requires statements of the form
(1)-(3). As such, finitary S5-theories can be used in a manner similar to how the conventional PDDL problem specification describes the initial states—for epistemic multiagent planning. We expect that this can help bridging the gap between the development
of epistemic multi-agent planning systems and the research in reasoning about the effects of actions in multi-agent domains mentioned earlier since several approaches to
reasoning about actions and changes in multi-agent domains (e.g., [1, 3, 6, 11]) facilitate
the implementation of a forward search planner in multi-agent domains.
We close the section with a brief discussion on other potential uses of finitary S5theories. Finitary S5-theories are useful in applications where knowing that a property is
true/false is insufficient, e.g., knowing that a theorem is correct is good but knowing the
proof of the theorem (its witness) is necessary; knowing that a component of a system
malfunctions is a good step in diagnosis but knowing why this is the case is better;
knowing that a plan exists does not help if the sequence of actions is missing; etc.

6 Conclusion and Future Work
In this paper, we proposed the notion of finitary S5-theories and showed that a finitary
S5-theory has finitely many finite S5-models. We proved that models of primitive finitary S5-theories share the same structure and have minimal size in terms of the number
of worlds. We presented an algorithm for computing all canonical S5-models of a finitary S5-theory. We also argued that the algorithm runs in polynomial time in the size
of a pure finitary S5-theory in disjunctive form. We proposed the use of completion of
finitary S5-theories, enabling the implicit representation of negative knowledge, as a
specification language in applications like epistemic multi-agent planning.
As future work, we plan to expand this research in four directions. First, we will
experiment with the development of an epistemic multi-agent planner. Second, we will
investigate possible ways to relax the conditions imposed on finitary S5-theories, while
still maintaining its finiteness property. Third, we intend to investigate the relationships
between the notion of completion of finitary S5-theory and the logic of only knowing
for multi-agent systems developed by others (e.g., [13, 9]). Finally, we would like to
identify situations in which the S5-requirements can be lifted.
Acknowledgments. The research has been partially supported by NSF grants HRD1345232 and DGE-0947465. The authors would like to thank Guram Bezhanishvili and
Nguyen L. A for the useful discussions and suggestions.

References
[1] Baltag, A., Moss, L.: Logics for epistemic programs. Synthese (2004)
[2] van Benthem, J.: Modal Logic for Open Minds. Center for the Study of Language and
Information (2010)

252

T.C. Son et al.

[3] van Benthem, J., van Eijck, J., Kooi, B.P.: Logics of communication and change. Inf. Comput. 204(11), 1620–1662 (2006)
[4] Blackburn, P., Van Benthem, J., Wolter, F. (eds.): Handbook of Modal Logic. Elsevier
(2007)
[5] Bolander, T., Andersen, M.: Epistemic Planning for Single and Multi-Agent Systems. Journal of Applied Non-Classical Logics 21(1) (2011)
[6] van Ditmarsch, H., van der Hoek, W., Kooi, B.: Dynamic Epistemic Logic. Springer (2007)
[7] Fagin, R., Halpern, J., Moses, Y., Vardi, M.: Reasoning about Knowledge. MIT Press
(1995)
[8] Gabbay, D., Kurucz, A., Wolter, F., Zakharyaschev, M.: Many-Dimensional Modal Logics:
Theory and Application. Elsevier (2003)
[9] Halpern, J.Y., Lakemeyer, G.: Multi-agent only knowing. In: Shoham, Y. (ed.) Proceedings
of the Sixth Conference on Theoretical Aspects of Rationality and Knowledge, De Zeeuwse
Stromen, The Netherlands, pp. 251–265. Morgan Kaufmann (1996)
[10] Halpern, J., Moses, Y.: A guide to completeness and complexity for modal logics of knowledge and belief. Artificial Intelligence 54, 319–379 (1992)
[11] Herzig, A., Lang, J., Marquis, P.: Action Progression and Revision in Multiagent Belief
Structures. In: Sixth Workshop on Nonmonotonic Reasoning, Action, and Change, NRAC
(2005)
[12] van der Hoek, W., Wooldridge, M.: Tractable multiagent planning for epistemic goals. In:
Proceedings of The First International Joint Conference on Autonomous Agents & Multiagent Systems, AAMAS 2002, Bologna, Italy, pp. 1167–1174. ACM (2002)
[13] Lakemeyer, G., Levesque, H.J.: Only-knowing meets nonmonotonic modal logic. In:
Brewka, G., Eiter, T., McIlraith, S.A. (eds.) Principles of Knowledge Representation and
Reasoning: Proceedings of the Thirteenth International Conference, KR 2012, Rome, Italy,
June 10-14. AAAI Press (2012)
[14] Löwe, B., Pacuit, E., Witzel, A.: DEL planning and some tractable cases. In: van Ditmarsch,
H., Lang, J., Ju, S. (eds.) LORI 2011. LNCS, vol. 6953, pp. 179–192. Springer, Heidelberg
(2011)
[15] Nguyen, L.A.: Constructing the least models for positive modal logic programs. Fundam.
Inform. 42(1), 29–60 (2000)
[16] Nguyen, L.A.: Constructing finite least kripke models for positive logic programs in serial
regular grammar logics. Logic Journal of the IGPL 16(2), 175–193 (2008)


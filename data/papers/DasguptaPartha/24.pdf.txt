Handling Fault Detection Latencies in Automata-based
Scheduling for Embedded Control Software
Santhosh Prabhu M, Aritra Hazra, Pallab Dasgupta and P. P. Chakrabarti
Department of Computer Science and Engineering,
Indian Institute of Technology Kharagpur, West Bengal, India - 721302.
Email: {santhosh.prabhu, aritrah, pallab, ppchak}@cse.iitkgp.ernet.in
Abstractâ€”There has been recent interest in automata-based
scheduling for dynamic adaptation of schedules for embedded
control software. Recently we have shown how automata-based
scheduling can be extended to account for the possibility of
faults in application of control. In this paper, we address
the problem of automata-based scheduling when latencies are
associated with detection of faults. We show that the gametheoretic approach that is used for handling faults under
full visibility may be suitably augmented so as to decide the
scheduling strategy in the presence of latencies in fault detection.
Index Termsâ€”Embedded Control Systems, Automata-based
Scheduling, Fault-tolerant System, Reliable Scheduling.

I. I NTRODUCTION
Typically, in any software controlled embedded system, a
control software is executed on a computational platform (often on ECUs/processors) and interacts with the plant through
its sensors and actuators. It enacts a set of periodically
scheduled control actions to perform a required activity and
achieve the desired performance of the overall embedded
system. The control components are scheduled in a way so
that it meets some performance requirement like exponential
stability.
A typical software controller in an embedded system can
have multiple software components that run on shared ECUs.
Each of these components is usually responsible for some
aspect of the control activity. Generally the task of scheduling
the components so as to satisfy the control requirement is
done by a scheduler. Every time a component gets scheduled,
it controls the system by applying some transformation,
which can be represented by a transformation matrix. Hence,
scheduling a component effectively means determining the
transformation matrix to be applied on the system.
Alur and Wiess [1], [7] have described an automata
based solution to the problem of generating schedules that
satisfy the exponential stability [2], [3], [4] requirement.
Their approach is based on the observation that the language
of admissible schedules is Ï‰-regular. It involves using a
generating automaton to dynamically generate admissible
schedules with respect to the stability criterion.
The scheduling problem gets more complicated when
there exists a possibility of a fault. A fault causes the
chosen control actions of a software component to be applied
incorrectly, or not applied at all. When this happens, a
mutated transformation matrix can be said to be applied on

the system. In a previous work [5], we have addressed the
problem of automata based scheduling in the presence of
faults, and shown that it is possible to construct an automaton
for scheduling the components, even under the possibility of
faults. The approach formulates the scheduling problem as
a game, such that a winning strategy in the game denotes a
safe scheduling strategy for the scheduler.
In [5], we have assumed that the scheduler has full
visibility of the faults, i.e, the scheduler knows about the
fault as soon as it occurs. However, in many real world
scenarios, the fault monitoring mechanism might be such,
that the occurrence of the fault is not detected immediately
by the scheduler. In this paper, we study the problem of
scheduling software components in such situations. The
primary contributions of this paper is as follows:
â€¢ We study the problem of reliable control scheduling
where the environment can introduce faults in the applied transformations scheduled by the controller and
these faults are not immediately visible to the scheduler.
â€¢ We formulate this problem as a partial observability
game between environment and scheduler.
â€¢ We derive an automaton which can generate schedules
that adheres to the exponential stability criterion under
partial observability of faults.
â€¢ We present a set of experimental results showing the
efficacy of our proposed method.
This paper is organized as follows. In Section II, we
describe the background for the problem of scheduling
software components. The problem is presented formally in
Section III. Section IV describes the mechanism for handling
latencies in fault detection. We describe the implementation
details and present the results in Section VI. Section VII
concludes this paper.
II. BACKGROUND
Formally, the dynamics of the physical plant can be
approximated by a given discrete-time linear time-invariant
system, described as:
xp (t + 1)
y(t)

=

Ap xp (t) + Bp u(t)

= Cp xp (t)

(1)
(2)

The state of the plant is defined by the set of plant variables,
xp , the output of the plant is y, and the control input of the

plant is u. The matrices Ap , Bp and Cp denotes the state
transition matrix, the input map, and the output map for the
plant model. Equation (1) defines the state transition function
of the plant, and Equation (2) defines the plant output.
The feedback control software reads the plant output, y,
and adjusts the control variables, u. The controller can be
designed as a linear time-invariant system such that the
stability [3], [4] of the whole system (the controller and the
plant together) is guaranteed when the output of the plant is
fed to the input of the controller and vice versa.
Formally, it is assumed that the controller of such an
embedded system can be represented as a discrete-time linear
time-invariant system:

AÏƒt+1 . . . AÏƒt+L of Z. We shall refer to sequences of transformations satisfying the exponential stability requirement as
admissible sequences.
It was shown in [7] that the language of admissible
sequences is Ï‰-regular. The language can be expressed as:
L(A) = Î£Ï‰ âˆ’ Î£âˆ— Î·Î£Ï‰
where Î· consists of the L-length sequences of transformations that violate the exponential stability criteria. In [1],
it was shown that it is possible to construct a finite state
automaton, such that any infinite random walk in it represents
an admissible sequence of transformations and vice versa.
III. P ROBLEM F ORMULATION

The role of the automata-based scheduler described in [1]
is
to ensure that the sequence of control components that
u(t) = Cc xc (t)
(4)
are scheduled adheres to the admissible patterns with respect
where, xc is the state of the controller and Ac , Bc and Cc are, to the stability criteria. In reality, the application of control
respectively, the state transition matrix, the input map, and the can be non-ideal due to several other factors such as delay
output map for the controller. Equation (3) and Equation (4) in receiving sensory inputs and electrical faults affecting
define the controller state transition function and the output the sensors / actuators, even when the software components
function, respectively. The dynamics of the composed system are scheduled correctly. Following the terminology of the
(the controller and the plant together) can be described by previous section, a fault at a time step is manifested as a
transformations of the form:
mutation on the transformation scheduled in that time step.
In other words, we consider scenarios where the scheduler


selected some transformation Ai , but the actual execution
Ap
Bp C c
x(t + 1) =
x(t)
(5) resulted in a transformation, AÌ‚i , which differs from Ai in
Bc C p
Ac
terms of the updation of the control variables that are affected
where x = (xTp , xTc )T is the concatenation of the states of by the fault.
the plant and the controller.
In general different types of faults may be manifested
We can represent the sequence of control actions applied as different mutations on a transformation matrix, Ai . Our
on the environment by one or more controllers, by a sequence approach is capable of handling multiple types of faults, but
of transformation matrices, AÏƒ1 , AÏƒ2 . . ., where each AÏƒi is we consider a single type of fault for ease of presentation.
chosen from an alphabet Î£ of transformation matrices. The We are given a set Î£ of transformation matrices, which
matrix in Equation 5 is one such transformation matrix.
correspond to simultaneous control actions by one or more
We denote by CÏƒi a particular combination of controllers software components. We are also given Î£f , the mutated
that may execute together. A word Ïƒ = Ïƒ1 Ïƒ2 . . ., (where versions of the transformation matrices in Î£. We assume
each Ïƒi âˆˆ [1, m]) specifies a schedule, which denotes the that within any given window of length L, a maximum
sequence of combinations CÏƒ = CÏƒ1 CÏƒ2 . . .. The sequence of k faults can occur. Also, it is assumed that the fault
of transformations corresponding to this schedule is given by is detected by the scheduler after m units of time, where
AÏƒ = AÏƒ1 AÏƒ2 . . ..
m â‰¤ L (We believe that our approach will hold even when
One of the standard control requirements is that of expo- m > L, but such scenarios are realistically not possible).
nential stability. A system (whose state is defined in terms of Such criteria indicating fault detection latencies introduces
n variables) is said to be (L, )-exponentially stable, given the a new dimension to the problem formulation and proposed
parameters L âˆˆ N and  âˆˆ (0, 1], if ||x(t + L)||/||x(t)|| <  approach in comparison to our previous work [5] where we
for every t âˆˆ N. It follows from control theory and the work provided reliable control schedules under faults with full
presented by Weiss and Alur [1], [7] that the exponential visibility.
stability requirement can be captured by the following lanHowever, in this work, our problem is to arrive at a strategy
guage:
for scheduling the transformation matrices from Î£ such that,
even in the presence of up to k faults in any window of length
ExpStab(L, ) = {Ïƒ âˆˆ I Ï‰ :
L, and the faults being detected only after m time instants,
||AÏƒt+L Â· Â· Â· AÏƒt+1 || <  f or every t âˆˆ N}
the exponential stability requirement is not violated.
This definition means that an infinite sequence, Z, of transExample 1: Consider a braking system, which reduces the
formations satisfies the exponential stability requirement iff speed of a vehicle using a combination of brakes and throttle
||AÏƒt+L Â· Â· Â· AÏƒt+1 || <  for every L length subsequence control. We are given two transformation matrices AR and
xc (t + 1)

=

Ac xc (t) + Bc u(t)

(3)

AS , corresponding to application of brakes and adjusting the
throttle. Assume that a fault may cause the apply brake action
to manifest incorrectly at most once (k = 1) in every 3 cycles
(L = 3), resulting in the transformation matrix AË†S being
applied. The fault detection latency is assumed to be 1. We
are given that the stability requirement admits the following
set of sequences:
{hAS , AR , AS i, hAS , AR , AR i, hAS , AS , AR i,
hAË†S , AR , AS i, hAS , AR , AË†S i, hAR , AS , AS i,
hAR , AS , AR i, hAR , AË†S , AR i, hAR , AR , AË†S i}
The scheduler must ensure that in every window of three
steps, the transformation applied is confined to these sequences â€“ even in the presence of faults.

IV. S CHEDULING UNDER FAULTS WITH L ATENT
V ISIBILITY
We have formulated the problem of scheduling with fault
detection latencies as a partial observation game between
the scheduler, which is the protagonist and the environment,
which is the antagonist1 . In every round of the game, the
scheduler decides on a transformation matrix to be scheduled,
and the environment chooses whether to mutate it or not,
constrained by the assumptions in the fault model. The
environmentâ€™s objective is to force an inadmissible sequence
to be scheduled, while the schedulerâ€™s is to prevent that from
happening. Due to the latency in fault detection, the scheduler
is unable to immediately determine which of the possible set
of moves the environment has opted for.
The state space for the game is defined by the set of L
length sequences over Î£ âˆª Î£f , along with the current turn.
We define the game graph as G = (V, E) as follows:
â€¢ The set V of vertices consists of two types of vertices.
Those where the scheduler makes its move (VS ), and
those where the environment makes its move (VE ). In
addition to the turn, the vertex also stores the L length
history of transformation matrices. The sequences in VS
are the ones which are actually applied on the system.
On the other hand, the last matrix in the sequences
associated with vertices in VE may get mutated by the
environment in its move.
â€¢ The set E of edges contains edges between every vertex
u to v from V such that,
1) the players getting the turn in u and v are different
2) If u âˆˆ VS , sequ [2 Â· Â· Â· L] = seqv [1 Â· Â· Â· L âˆ’ 1], and the
edge is labeled by the matrix seqv [L].
3) If u âˆˆ VE , sequ [1 Â· Â· Â· L âˆ’ 1] = seqv [1 Â· Â· Â· L âˆ’ 1], the
edge is labeled by the matrix seqv [L], and seqv [L] =
sequ [L] or seqv [L] = seqc
u [L].
Here, sequ and seqv denote the sequences associated
with u and v respectively.
1 We point out here that the adversarial modeling of the environment has
not been made after a qualitative analysis. There may exist non adversarial
models of the environment which may also be suitable.

Due to the partially visible nature of the game, the
scheduler will not be able to recognize the mutations in
the most recent window of length m. The intuitive idea for
constructing a winning strategy for the scheduler is quite
straightforward â€“ we try to come up with a strategy such that
the schedulerâ€™s response to every move of environment, will
guarantee that the scheduler can force victory irrespective of
what move the environment has chosen. The responses to
the move begin to differ only when the actual nature of the
environmentâ€™s move becomes known to the scheduler.
To obtain such a strategy for the scheduler, we first expand
the graph as a tree and using the Min-max algorithm[6], we
annotate each state with win/loss markings. In order to be
able to perform such an annotation, it is necessary to first
define the winning and losing leaf nodes. The definition of
losing leaf nodes is straightforward. Any state whose L length
sequence is present in the set of inadmissible sequences is
a loss node. For defining the winning leaf nodes for the
scheduler, we use the following lemma:
Lemma 1: If the antagonist has a winning strategy from
a node v in the game tree, and there is another occurrence
of v on the path from the root, then the antagonist has a
winning strategy from the previous occurrence of v that does
not involve the latter occurrence of v.
Proof: The antagonist wins if the state of the game reaches
a loss node. Therefore, a winning strategy for the antagonist
is a subtree, W , of the game tree, T , such that all leaf nodes
of W are loss nodes and at each intermediate node of W ,
the following condition holds: each node u âˆˆ VE in W has
a single successor from T in W and each node u âˆˆ VS has
all successors from T in W .
Consider the smallest subtree, W , which is a winning
strategy from a node v. Then W cannot contain another
occurrence of v, otherwise the subtree of W rooted at the
second occurrence will be a smaller winning strategy.
Since the subtrees rooted at each occurrence of v are
isomorphic, the winning strategies from each occurrence of v
are also isomorphic. So, the smallest winning strategy from
the first occurrence of v does not involve the subsequent
occurrences of v in the game tree.

On the basis of this lemma, we mark as a winning leaf
node any state where the protagonist(the controller) has the
turn, and has already been seen in the path to it from the
root. Once this is done, the Min-max algorithm may be
applied directly. Figure 1 illustrates a portion of the Minmax tree, for the controller described in Example 1. The
game is assumed to start from the state corresponding to
the sequence hAS , AR , AS i. If the scheduler chooses AR in
the first round, the environment will be unable to mutate
it, and it will be applied correctly. This takes the game to
the state corresponding to the sequence hAR , AS , AR i. Then,
if in the second round, the scheduler chooses AS and the
environment chooses not to mutate it, the game reaches the
state with sequence hAS , AR , AS i, which is a repetition, and
hence labeled as a winning state. That this tree gives all

possible winning strategies for the controller under the given
fault model, when the faults are immediately visible, is stated
by the following lemma.
Lemma 2: The scheduler can guarantee a schedule satisfying the exponential stability criterion if and only if the
protagonist has a winning strategy in our game formulation.
Proof (Reproduced from [5]): We recall that a schedule
satisfies the exponential stability criterion if the sequence of
transformations applied in this schedule does not contain any
inadmissible L-length subsequence.
A winning strategy for the protagonist in the game is
one that prevents the state of the game to reach any LOSS
node, which represents a state of the system where the
last L transformations constitute an inadmissible sequence.
Therefore a winning strategy for the protagonist guarantees
a schedule satisfying exponential stability.
If the protagonist has no winning strategy, then the antagonist can lead the game to a LOSS node. In other words, the
antagonist can choose a suitable sequence of mutations for
each choice of transformations by the protagonist, such that
an inadmissible sequence of transformations is guaranteed to
be applied on the system. Now, it remains to be shown that
the transformations that the scheduler can choose in order to
satisfy exponential stability is no different from the choices
available to it in the game as the protagonist, and that the
environment as the antagonist in the game is only as powerful
as it is in the real world, in terms of the mutations it can
introduce.
We make the assumption that any transformation matrix
Ai âˆˆ Î£ can be chosen by the protagonist at any instant,
irrespective of the history of the game. So, the choices of
transformation matrices available to the scheduler in the game
is same as the choices available to it for scheduling.
Given that only a maximum of k mutations are possible
within any L-length window, and that the mutations are
governed by no other constraint, whether the transformation
matrix scheduled next can be mutated, is determined entirely
by the number of mutations that have been introduced within
the last L-length window. This restriction is placed on the
antagonist of the game too. So, the antagonist is only as
powerful as the environment in the real world.

Once we obtain the game tree with win/loss markings on
each state, we define an equivalence relation R on the set
of states. Two states q and q 0 are said to be equivalent with
respect to R if they are indistinguishable for the controller.
For example, in Figure 1, the states n4 and n5 are equivalent
with respect to R, if the fault detection latency is not zero.
We now construct a modified game tree, as follows: For
every set S = {q1 , q2 . . . qn } of states which are equivalent
with respect to R, we look for isomorphic winning strategies
that are applicable from all qi âˆˆ S. All other winning
strategies are discarded, by marking the moves as losing
moves. If there does not exist such an isomorphic winning
strategy, we mark each qi âˆˆ S as a loss node.
After this step, we apply the Min-max algorithm again, and
repeat the above procedure. The iteration stops when no more

A S ,AR ,AS
n1
AR

AS

Roundâˆ’1
n3

n2
AS

AS

n5

n4

STATE
REPETITION

AR
n6

L
AR AS

AS

A R ,AS ,AS

AR
n8

n7
SCHEDULERâ€™S
TURN
ENVIRONMENTâ€™S
TURN

AS

n10
W

AR

AS

L âˆ’ LOSS NODE

W

AR

AS
n9

W âˆ’ WIN NODE

Fig. 1.

Roundâˆ’2

A S ,AR ,AS

A section of a Game tree for Example 1

n1

Winning Subtree

W

(full visibility)

AR

n1
AR

n2
AR

n2

W
AR

n3
W
AS

AS

n5

W
AS

AR

W

L

W

n6

n7

n8

W

n1

W

AS

L

n1
AR

n2
n3

L

AS

AR

L

W
n6

AS

AR
n4

n3
L

W

W

n5

n4

n2

AR

(B)

AR

W
n8

n7

?

W
AR

AR

L

n6

n5

n4
W

AR

Winning Subtree
(latent visibility)

AR

AR

n3

W
AR

W

(A)

n4

W

AR

AR

L

W

n7

n8

L
AS

AR

AS

AR

L

L

L

L

n6

n7

n8

n5

Fig. 2. A snapshot showing the re-labeling of game trees (These trees are
not necessarily subtrees of the game tree for the speed governor example).

changes are necessary to the game tree. Figure 2 illustrates
how the markings on the game trees may change in each
iteration of the above process. In the first game tree, nodes
n3 and n4 are equivalent, and there exists an isomorphic
winning strategy from both nodes, that of choosing AR .
Choosing AS , however, is not a winning strategy from n4 ,
and hence, choosing AS is marked as a losing move from n3 ,
by relabeling n5 as a loss node. In the second game tree, the
nodes n3 and n4 are again equivalent. On applying the same
strategy, n5 and n8 gets relabeled as loss nodes, which in turn
results in n3 , n4 and n2 being relabeled as loss nodes. Had
there been no latency in fault detection, these nodes would
have been winning nodes for the scheduler.

Theorem 1: The re-labeled game tree contains exactly
those strategies that do not require the scheduler to behave
differently in two states that appear similar to it due to fault
detection latencies.
Proof: Since the re-labeled subtree is obtained by dropping
strategies from the original tree, and for no two equivalent
states is the set of outgoing transitions different, it is clear
that every strategy present in the tree is correct.
We now prove that every correct strategy is present in the
new tree. Suppose that there exists a subtree for a strategy
that was present in the original game tree, but is not present
in the new tree. We prove that such a subtree cannot exist.
Consider a subtree of height zero. The root of such a tree
will be marked as a losing state, even though it may not be
among the inadmissible sequences. This is true because it
is not possible for the scheduler to distinguish between this
state and some state that is actually a losing state. Such states
should be marked as loss, since the attempts by the scheduler
to take the game to such a state might actually be leading
the game to a losing state.
Now assume that no strategy of upto h rounds is missed.
Consider a strategy of h + 1 rounds. Since the strategy
doesnâ€™t require the scheduler to behave differently in two
states that appear similar, the first move of the strategy must
be applicable in all states that are equivalent to the root of the
subtree. But if that be the case, the remainder of the strategy
would still be in the tree, by our assumption. So, no strategy
of h + 1 rounds is missed.
Thus, by induction, the re-labeled tree contains all strategies in which the scheduler behaves identically on the same
information.

V. AUTOMATON FOR GENERATING SCHEDULES
From the marked Min-max tree for the game formulation,
we construct the automaton for generating the schedules. The
automaton is defined by a tuple hQ, Î£, Î´, q0 i, where:
â€¢

â€¢
â€¢

â€¢

Q, the set of states of the automaton consists of L length
sequences from (Î£ âˆª Î£f )k , in which not more than k
symbols are from Î£f . Also, the last m symbols should
necessarily be from Î£.
Î£ is, as defined previously, the set of transformation
matrices
Î´ âŠ† Q Ã— Î£ Ã— Q is the transition relation, which is
defined as follows. (u, Ai , v) âˆˆ Î´ if Ai is part of a
winning strategy from the state with sequence u where
protagonist has the turn and, v satisfies the following
conditions:
1) v[L] = Ai or v[L] = AÌ‚i and,
2) v differs at most at one position from u, and if it
does, the difference will be that the Lâˆ’m+1th symbol
in v is the mutated version of the corresponding
symbol in u.
q0 is the predefined initial sequence

VI. I MPLEMENTATION AND E XPERIMENTAL D ETAILS
We have implemented an optimized version of the proposed approach, in which we intelligently prune subtrees
based on equivalence even as the Min-max algorithm assigns the initial markings to the nodes. For doing this, we
keep track of equivalence between the explored states, and
whenever the strategy of a state is modified, the strategies of
all states equivalent to it are also modified. Whenever a state
is found to be losing, the subtrees rooted at that node and all
other nodes equivalent to it are pruned.
Table I presents the results obtained from the implementation. The results are obtained for different values of L,
different alphabets, different sets of admissible sequences and
different values of m and k. Columns 1-3 give the window
length (L), maximum number of injected faults (k) and the
latency in fault visibility (m), respectively. The number of
transformation matrices are reported in Column 4. Column 5
presents the size of the equivalence classes and the required
time for the overall analysis (in seconds) is outlined in
Column 6. The execution time was obtained on a 1.6GHz
quad core Intel Core i5 with 4 GigaBytes of memory, running
32-bit Linux. The language used for the implementation was
Java (OpenJDK 1.6.0 24).
L
10
10
9
9
8
8
8
8
8
8
7
7
6
6
5
5

k
1
1
1
2
4
4
3
3
2
2
1
1
1
1
1
1

m
4
3
3
2
3
4
2
3
2
3
2
3
2
2
2
2

|Î£|
2
2
2
2
2
2
2
2
2
2
2
2
2
3
2
3

Number of
Equivalence Classes
4119
4637
2072
6303
3550
2346
4822
2736
2336
1501
918
395
248
2720
107
1007

Time
(in sec)
16.801
17.681
4.072
46.479
220.706
49.867
60.752
33.95
7.608
5.056
1.512
0.484
0.3
9.621
0.092
1.576

TABLE I
E XPERIMENTAL R ESULTS

The results show that the proposed method works in
reasonable time. It can be seen that the time for computing
the strategy increases with L, k and the size of Î£. A
higher value of L means that a longer history needs to be
remembered, and hence, the state space will larger. k and |Î£|
affect the execution time by determining the branching factor
of the Min-max tree. As k and |Î£| increases, the branching
factor increases, thereby increasing the execution time. On
the other hand, the execution time decreases as the latency
(m) increases. This is because more subtrees get pruned out,
and thereby, less states need to be explored.

VII. C ONCLUSION
We have described how latencies in fault detection may
be handled in the automata-based scheduling framework. We
have shown that the game theoretic approach can be used
with certain modifications, in cases where faults are not
immediately visible. Experimental results are found to be
quite encouraging.
ACKNOWLEDGEMENT
Pallab Dasgupta and P. P. Chakrabarti acknowledge the
support of IGSTC (Indo-German Science and Technology
Center) Project. Aritra Hazra is supported by Microsoft Corporation and Microsoft Research India under the Microsoft
Research India PhD Fellowship Award.
R EFERENCES
[1] R. Alur and G. Weiss. Regular Specifications of Resource Requirements
for Embedded Control Software. In the Symposium on Real-Time and
Embedded Technology and Applications (RTAS), pages 159â€“168, 2008.
[2] L. Gurvits. Stability of Discrete Linear Inclusion. Linear Algebra
Applications, 231:47â€“85, 1995.
[3] J. P. Hespanha and A. S. Morse. Stability of Switched Systems with
Average Dwell-time. In Proceedings of the 38th IEEE Conference on
Decision and Control, volume 3, pages 2655â€“2660, 1999.
[4] D. Liberzon. Switching in Systems and Control. BirkhaÌˆuser, 2003.
[5] S. P. M, A. Hazra, and P. Dasgupta. Reliability Guarantees in Automata
Based Scheduling for Embedded Control Software. To appear in IEEE
Embedded Systems Letters (An extended version of this is available at:
http://facweb.iitkgp.ernet.in/âˆ¼pallab/TechRep/ESL2013TR.pdf), 2013.
[6] S. Russell and P. Norvig. Artificial Intelligence: A Modern Approach.
Pearson Education, 2003.
[7] G. Weiss and R. Alur. Automata Based Interfaces for Control and
Scheduling. In 10th International Workshop on Hybrid Systems:
Computation and Control (HSCC), pages 601â€“613, 2007.


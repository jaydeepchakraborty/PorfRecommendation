Development of NeuronBank:
A Federation of Customizable Knowledge Bases of Neuronal Circuitry
Robert J. Calin-Jageman1, Akshaye Dhawan2, Hong Yang2,
Hsiu-Chung Wang2, Hao Tian2, Piyaphol Phoungphol2
Chad Frederick2, Janaka Balasooriya2, Yan Chen2,
Sushil K. Prasad2, Raj Sunderraman2, Ying Zhu2, and Paul S. Katz1*
1
Department of Biology 2Department of Computer Science
Georgia State University, Atlanta, GA 30303, USA
Email: pkatz@gsu.edu
Abstract
Knowledge of neuronal circuitry is foundational to the
neurosciences, but no tools have been developed for
cataloguing this knowledge. Part of the problem is that
the concepts used to describe neural circuits are rapidly
evolving and vary substantially across different species.
The NeuronBank project (http://neuronbank.org) is
developing an informatics infrastructure for managing the
dynamic, domain-specific knowledge of neural circuitry,
providing a reference source, an outlet for publishing new
knowledge, and a useful research tool. Our solution is a
federation of customizable knowledge bases, each
adaptable to store knowledge of the neural circuitry of a
single species. The federation is united by a common set
of web services and a central portal that provides core
functionality across various knowledge bases. This
service-oriented architecture provides domain-specific
representations of specialized scientific knowledge while
maintaining interoperability across a broad discipline.

1. Introduction
Neuroscientists understand the functioning of a brain
in part by mapping its neural circuitry. In many species,
it is possible to map circuits at the highest level of
precision—that of identified neurons. An identified
neuron is an individual nerve cell or a group of such cells
with defined characteristics that can be reliably located
across specimens. Much of the recent progress in
neuroscience has been built on the analysis of circuits of
identified neurons, especially in invertebrate systems.
Important examples include those that underlie swimming
in the gastropod Tritonia16, gill and siphon withdrawal in
the gastropod Aplysia5, 19, feeding in gastropods14,
heartbeat control, local bending, and swimming in the
leech2,3,6,21, visual responses in insects1, foregut
movements in lobsters and crabs28, and escape responses
in crayfish13.
Although our knowledge of identified neurons and
neural circuits is invaluable, no standard for representing

2007 IEEE Congress on Services (SERVICES 2007)
0-7695-2926-7/07 $25.00 © 2007

this knowledge has evolved and there are no resources for
storing, sharing, or analyzing this information. The
NeuronBank project seeks to fill this important gap in the
informatics infrastructure of neuroscience. Our goal is to
develop an online storage system of identified neurons
and their synaptic connections. When completed, this
system will provide neuroscientists with a reference
source for identified neurons and neural circuitry, an
outlet for publishing new knowledge of identified neurons
and synaptic connections, and a useful tool for comparing
neuron and circuit properties across species.

1.1. Problem
The representation of neural circuitry seems
straightforward—neurons and their synaptic connections
can be considered nodes and edges on a standard graph.
However, two complications arise in attempting to design
a storage system of circuitry. The first problem is the
dynamic nature of scientific knowledge. Neuroscientists
continually develop new techniques that allow neurons to
be differentiated along new dimensions. For example,
single-cell genetic sequencing has recently been used to
distinguish different neuron types27, a form of
classification that was not possible in any species five
years ago. The second is domain-specificity. Knowledge
of neural circuitry is deeply embedded in specific
information about the host species. Thus, neuroscientists
working on different species require customized ways of
representing neurons.
Taken together, these
considerations indicate that a storage system for neural
circuitry must be able to accommodate dynamic, species
specific descriptions of neurons.
The problems of managing domain-specific, dynamic
knowledge are not unique to the neurosciences. Although
some scientific knowledge is stable and of broad
applicability (e.g. gene sequences), most scientific
knowledge is more context-dependent and tentative. For
example, WormBase18 curates knowledge of the genetics,
genomics, and biology of the nematode C. elegans. This
system represents knowledge with concepts that are

Figure 1. NeuronBank will consist of a federation of knowledge bases, each
customized for the neural circuitry of different species. Each node in the federation is
run by BranchKB and provides an extensible backend, web services for retrieving
and editing both the data and data model, and functions for the branch administrator.
Various branches are united by NB-Central, a single server providing core
functionality across the federation. Together, the branches and NB-Central provide a
unified experience that can support various web-enabled clients.
specific to C. elegans (e.g., nematode anatomy, life stage,
and chromosomal structure) and provides presentation
and analysis tools that are of particular use for research on
this organism. Similarly, FlyBase12 provides a reference
source on the biology and genetics of the fruitfully, but
with a different data model than WormBase. Thus,
domain-specific knowledge bases are already becoming
important within bioinformatics. Continued proliferation
of idiosyncratic systems, however, will quickly lead to a
“Tower of Babel” problem. Clearly, a more generalized
solution is required which can provide domain-specific
management of dynamic knowledge within a framework
that will maintain broad interoperability across domains.
This
represents
a
growing
challenge
within
bioinformatics24,26, which has traditionally focused on
managing stable and broadly applicable concepts.
From a system design perspective, the need to manage
dynamic and domain-specific scientific knowledge
requires innovation in system architecture. Most current

2007 IEEE Congress on Services (SERVICES 2007)
0-7695-2926-7/07 $25.00 © 2007

bioinformatics efforts utilize a three-tier architecture: a
single relational database provides data to an application
layer which builds an invariant user interface for web
clients. In this architecture, changes in the data model are
infrequent and require developer intervention to update
both the database backend and the application layer.
Moreover, there is only a single data store, so data sharing
is not a concern. This type of architecture would not be
suitable for NeuronBank or other bioinformatics efforts
aimed at cataloguing dynamic, domain-specific
knowledge. First, different domains will require different
data models and user interfaces. Second, within each
domain updates to the data model and user interface will
be frequent and must not require developer intervention.
Finally, providing different data models and stores for
different domains introduces problem for sharing and
searching knowledge across domains.

1.2. Our solution
Our approach is to develop a service-oriented
federation of customizable knowledge bases. Individual
nodes within the federation (Branches) will be specialized
for knowledge of neural circuitry in a single species.
Branches will be united, however, by a common
framework that enables search and analysis of neural
circuits across all species. In this way, we provide the
specialization necessary to represent different neuron
typologies and the interoperability required to share and
analyze knowledge of different species. Figure 1 shows
the overall distributed architecture of NeuronBank.
Branches in the federation will be established using
BranchKB (Branch Knowledge Base), an open-source
software package that we are developing for creating and
curating an online, collaborative knowledge base of
identified neurons. BranchKB features a data model that
is customizable and extensible, enabling a community of
neuroscientists to quickly adapt the system to describe
their neuron typology and expand the system as new
techniques become available within their subfield.
To unify across multiple species, we are also
developing NB-Central (NeuronBank Central), a
centralized set of components. NB-Central serves two
roles. First, it provides a set of web services to the
BranchKBs. These services establish common core
functionality, eliminating duplication of effort and
presenting a consistent experience across all branches.
Second, NB-Central creates an environment for invoking
and collating services provided by the BranchKBs. This
enables a mechanism for searching and analyzing data
across all the species represented.
The rest of this paper is organized as follows. Section
2 discusses the design of BranchKB to provide a flexible
data store that supports dynamic user interfaces. Section
3 presents a service-oriented architecture to unify a
federation of branches. Section 4 illustrates the use of
this architecture to provide dynamic searching within and
across branches. Section 5 compares this effort with
similar projects and offers concluding remarks.

2. Branch Knowledge Bases
BranchKB is the storage system for each speciesspecific Branch within NeuronBank (see Figure 1). In this
respect, BranchKB is similar to the ‘database backend’ of
a traditional web application. However, BranchKB
differs from a traditional database in three important
respects.
First, BranchKB is designed to have a
somewhat flexible data model, so that it can be adapted
for representing knowledge within a particular species.
Second, BranchKB provides services for accessing the
current data model, exposing the meta-data required to

2007 IEEE Congress on Services (SERVICES 2007)
0-7695-2926-7/07 $25.00 © 2007

build a dynamic user interface for that branch. Finally,
BranchKB is designed to be integrated with NB-Central
so that knowledge can be shared across diverse
communities.

2.1 Flexible data model of neural circuitry
Across all domains, neurons are described by sets of
attributes (e.g. size, shape, color, and location) and
identified by delineating the subset of attributes necessary
and sufficient to reliably identify that neuron across
different specimens. There is tremendous variation,
however, in the attributes used to describe neurons in
different species. In addition, new techniques within the
neurosciences are constantly adding new attributes which
can be used to distinguish neurons.
To represent knowledge of neural circuitry, BranchKB
provides a core data model that can be extended for
species-specific needs. The core model includes neuron
and connection classes. In addition, it includes basic
annotation classes (citation, comment, figure, etc.).
Instances of these classes can be described by
attribute/value pairs, with the applicable set of attributes
constrained by the class (e.g., citations can have an
author, neurons cannot). The attributes of a class are
inherited from its super-classes, although this can be
overridden.
Attribute types include standard data types (string,
integer, etc.) and relational types which point to other
instances within the knowledgebase. In addition, we
allow both measurement and classification attributes,
which are useful for describing scientific knowledge. A
measurement requires two values, representing mean and
variance respectively, and is associated with a unit of
measure. A classification is an attribute that takes values
from a controlled vocabulary.
To accommodate species-specific knowledge, the set
of attributes applicable to neurons and connections is
extensible and modifiable. Thus, each BranchKB can be
customized to provide the attributes necessary to describe
neurons in a single species. As new techniques enable the
measurement of additional neural attributes, the data
model can be further extended. We envision that
communities of neuroscientists interested in a given
species will work together to devise the attribute set
appropriate for that species. Changes to the data model
are restricted to users designated as administrators for that
BranchKB, but facilities will be provided for users to
suggest and debate changes.

2.2 Meta-data for dynamic user interfaces
BranchKB is designed to accommodate continued
change in its underlying data model. In addition, each

instance of BranchKB will be customized for a specific
species, providing significant heterogeneity across the
federation. Both considerations indicate that NeuronBank
clients will need to build the user interface dynamically.
This is of particular concern for search interfaces, which
are closely based on the structure of the underlying data
model.
Although a dynamic interface is a client requirement,
it has significant implications for the design of
BranchKB. Specifically, BranchKB must enable clients
to retrieve not only data but also the current data model.
Thus, each BranchKB also exposes functions that enable
clients to retrieve the current class structure, the attributes
that apply to a particular class, and the attribute values
that are valid for a particular instance. These functions
are made available through a set of web services so that
each customized instance of BranchKB maintains a
consistent set of interfaces for various clients (see below).

2.3 Implementation
We are developing BranchKB using the Protégé
knowledge-management system30. Protégé is a mature,
open-source Java-based knowledge base system. It
provides a class/instance/attribute data store that can be
accessed via both a Java API and an extensible query
language. Protégé knowledge bases can be stored in a
number of formats, including MySQL database tables.
Plug-ins can be written to support additional storage
formats. Finally, Protégé knowledge bases can be
imported and exported to a variety of formats, including
RDF and XML. Import and export formats can also be
extended via a plug-in architecture.
For the NeuronBank project, Protégé provides a very
useful data store as it readily provides functionality
required for the BranchKB that would not be easy to
implement with a traditional relational database. First,
Protégé natively supports class hierarchies and attribute
inheritance. Second, Protégé features loose typing and
constraint checking. This enables continued changes in
the data model without serious disruption of the
knowledge that has already been stored. Finally, Protégé
knowledge provides standard interfaces to access not only
the data but also the data model. Thus, dynamic clients
can easily be built around Protégé’s standard interfaces.
Although, Protégé provides many of the functions
required for BranchKB, it lacks some important features,
including multi-user support, versioning, and roll-back.
BranchKB will wrap the existing Protégé framework into
a set of web services (see below) and add these additional
functions.

2007 IEEE Congress on Services (SERVICES 2007)
0-7695-2926-7/07 $25.00 © 2007

3 Service-based Architecture
We are developing NB-Central as a hub to unify the
various BranchKBs into a coherent federation. This is
challenging, given the capacity for heterogeneity designed
into BranchKB. However, we can employ a rich base of
existing work in the fields of web services and distributed
architectures that has been developed for managing
heterogeneous, dispersed resources. Specifically, we are
developing web services for hosting on both BranchKB
and NB-Central. Web services hosted on NB-Central will
be invoked by BranchKBs and will provide common
functionality across the federation (authentication,
account administration, listing of branches, etc). Web
services hosted on BranchKB will provide a common
interface for data and data model access that can be
invoked and collated on NB-Central. Through this
interrelated set of web services, NB-Central will provide a
single access point to the system for both querying and for
maintaining user information.
We choose web services over other alternatives like RPC,
CORBA, etc. for the following reasons:
1. Interoperability:
- By keeping consistent web service interfaces at all
branches, we provide a means to invoke the same services
at all branches although the logic of each service can be
highly branch specific.
- Third-party clients for querying, visualizing, editing, etc.
could be implemented using any client component
technology. Web service interfaces of BranchKB’s as
well as that of NB-Central allows them to uniformly
interoperate with them.
- Different implementations of the BranchKB using
different technologies could exist in the future.
2. Uniform interface: Web Service Description Language9
(WSDL) provides a standard XML format that enables the
NeuronBank components to describe their endpoint
formats. This allows interoperability both within the
system and with third-party components.
3. Common communication platform: Simple Object
Access Protocol25 (SOAP) is a standardized XML-based
message passing protocol that allows messages to be
exchanged between entities in a distributed system, thus
providing language- and network-independence for
components of NeuronBank11.
4. Masking network and system heterogeneity: Machine
and network protocol specific information is
abstracted through the use of the above defined
standards. This allows the system to operate seamlessly
through a variety of client and network technologies.

Thus, we see that using web services allows us to
publish the same methods at every branch – this allows
NB-Central to invoke a given method at all branches and
get back a standard result from each even though the
implementation of that method at every branch is custom
to that branch.

3..1 Dynamic search client for BranchKB
The rationale for our system architecture can be better

enables cross-branch searching despite substantial
heterogeneity in the data models at different BranchKBs.
One of the most important aspects for any knowledge
management system is an effective search interface.
BranchKB exposes a web service for querying the
knowledge base using Algernon, a specialized query
language for Protégé. This is a powerful query language
enabling path-based search (e.g., find all the 2’ inputs of
serotonergic neurons). This is a relatively complex and
low-level approach to querying, however, that would not
be suitable for most users.

Figure 2. Components of the dynamic search client. The client connects to a
BranchKB and retrieves a list of classes in the current data model (drop-down at
left). When the user selects a class to search, the client retrieves the pathways
connecting to other classes (drop-down at right). In this case, the user has
selected to search for a Neuron and the interface shows the various classes
Neurons can be related to. This enables users to build a path through the
knowledge base (e.g., find a neuron with input from a chemical synapse). In
addition, the search client retrieves the attributes and valid attribute values for the
classes in the search path. This enables users to specify the properties of the
items they are searching for (bottom list).
illustrated by describing some specific usage. First, we
describe how our system architecture allowed us to
develop a search client with an interface that is dynamic
yet intuitive. Next, we describe how the architecture

2007 IEEE Congress on Services (SERVICES 2007)
0-7695-2926-7/07 $25.00 © 2007

As a proof of concept, we have developed a web
based search client that allows users to seamlessly
construct ad-hoc queries (Figure 2). The client was
developed using Java Server Faces (JSF) technology; it
provides a form-based interface which users can easily

use to construct a path-based query. The primary novelty
of the search client is that it builds the search interface
dynamically to match the current data model on the
branch. The client retrieves the current class structure
from the BranchKB. When a class is selected as part of a
search, the client retrieves the attributes that can apply to
that class and the paths leading away from that class.
This enables the search form to be updated with all
currently available search options.
Once the user has designed their query, the search
client constructs an equivalent Algernon statement,
submits it to the BranchKB, and collects both summary
and detailed results. The summary results include the
entire query path, allowing users to easily trace the
inference chain performed on the knowledge base. Our
search client relieves end-users from the low-level
database details and the terse and error-prone text-based
query expressions. The web-based design makes the
query system accessible from any computer on the
internet. Interaction between the search client and
BranchKB currently occurs via the Protégé API.
However, we will soon utilize web services to connect
these components.

3.2 Searching across branches
Each BranchKB stores knowledge for a different
species using a slightly different data model. Normally,
this would make it difficult to efficiently conduct a search
across a multiple BranchKBs. However, each BranchKB
presents a consistent interface via web services. This
enabled us to generalize our dynamic search client—the
same query can be submitted to all BranchKBs in the
federation using the same interface. Generalizing search
across the federation, however, presents two problems.
First, how is the client to discover available BranchKBs?
Second, how should the client collate results across the
federation? These problems are overcome by NBCentral. As a hub for the federation, NB-Central provides
a directory listing of available BranchKBs. It can also
consume and collate the search web service across the
entire federation. Thus, we have been able to efficiently
adapt our dynamic search client to search across an entire
federation of BranchKBs. Currently, NB-Central directs
the client to a ‘base’ branch to formulate the search. The
Algernon query generated is then returned to NB-Central
which submits it to all branches and returns the collated
results. The use of a base branch ensures that the query
will be valid on at least one BranchKB. The number of
additional responding BranchKBs depends on the
specificity of the concepts queried—the more specific the
attribute the more likely it will be an invalid search at
other BranchKBs. This is an effective design, but
somewhat simplistic.

2007 IEEE Congress on Services (SERVICES 2007)
0-7695-2926-7/07 $25.00 © 2007

Semantic Integration: The problem of semantic
integration is one that is being studied in some detail in
various semantic web contexts specially those that deal
with biomedical knowledge bases15,34. More recent
research is focused on the broader issues of integration
beyond the simple merging issues33.
In the context of NeuronBank, as separate BranchKB
are developed, the independent extension of their data
schemas will lead to semantic conflicts. Broadly, two
types of conflicts are possible: multiple specification,
where the same term is used to mean different things in
different knowledgebases, and independent specification,
where different terms are used in different
knowledgebases to mean the same thing. The ontologies
of various branches can be preprocessed for possible
merging and alignment, thereby identifying similarities of
terms and sub-hierarchies. For example, the Prompt plugin of Protégé allows managing multiple ontologies29.
This integrated ontology could be employed to translate
query specific to one branch to others for cross-branch
querying. The query results from multiple branches can
also be collated based on post-processing using the
integrated ontology. A similar approach has been
suggested in to create mappings between a global
ontology and local ontologies7.

4. Related work
Our design of the BranchKB is similar to the EntityAttribute-Value with Classes and Relationships
(EAV/CR) approach developed by Shepard and
associates24,26. This system was also developed to allow
flexible representations of scientific knowledge.
EAV/CR has been successfully used to run knowledge
bases of cell properties26, neurological diseases8, olfactory
receptors22, and computational models26.
However,
EAV/CR was designed primarily to rapidly set up
independent knowledge bases.
Thus, there are no
facilities for searching across EAV/CR stores. Moreover,
interaction with EAV/CR does not currently use an open
protocol, so only a standard web-based client is available.
We hope to overcome both of these problems with the
NeuronBank system by designing BranchKB within a
service-oriented architecture (NB-Central). In many
ways, this environment functions as a middle layer
coordinator, joining together a diverse network of
BranchKBs. Thus, this component of our efforts is
similar to other efforts to develop collaborative
applications to unite disparate devices and data stores,
using middlewares such as SyD31,32 or Proem20 and
composite
web-services-based
applications
using
frameworks such as WS-CAF and Data-Grey-Box17.
Among other similar efforts, the National Cancer Institute
Center for Bioinformatics (NCICB) has developed the
cancer Common Ontological Research Environment

(caCORE) that provide a set of cancer Bioinformatics
Objects (caBIO) with open APIs that supply a variety of
types of bioinformatics data10. Also, the BioExtract Server
developed at South Dakota State University provides a
publicly accessible web-based federated database service
that provides researchers access to a variety of
heterogeneous biomolecular data sources through a single
entry point23. We are planning of employing SyD’s
Bondflow system for configuring workflows over web
services4 to enable users to create simple workflows such
as a cross-branch query over a selected set of branches
followed by an ontology-based collating tool which in
turn can feed into a visualization client.

5. Conclusion
NeuronBank is still early in development. However,
we have successfully developed prototypes of all the
major components and have populated BranchKBs with
both real and test data. So far, it seems that the system
architecture described here will provide a convenient and
powerful framework for managing domain-specific
scientific knowledge. Specifically, NeuronBank provides
the flexibility to produce highly customized knowledge
bases that serve a small scientific community. At the
same time, NeuronBank maintains a high level of
interoperability that should facilitate exchange of
information across a large domain.
In a sense, NeuronBank represents an attempt to
abstract the database development process into a set of
software packages that will enable end users to design,
deploy, modify, maintain, and share their own, special use
knowledge bases. Web services are ideally suited to bind
together the disparate components of a federated
architecture.
Specifically, they can allow highly
specialized data stores to remain interoperable across a
broad domain.

8. References
[1] Borst A & Haag J (2002) Neural networks in the cockpit of
the fly. Journal of Comparative Physiology A:Sensory,
Neural and Behavioral Physiology 188: 419-437.
[2] Brodfuehrer PD, Debski EA, O'Gara BA & Friesen WO
(1995) Neuronal control of leech swimming. Journal of
Neurobiology 27: 403-418.
[3] Brodfuehrer PD & Thorogood MS (2001) Identified neurons
and leech swimming behavior. Progress in Neurobiology 63:
371-381.
[4] Balasooriya J, Padye M, Prasad SK & Navathe SB (2005).
BondFlow: A Middleware Environment for Distributed
Coordination of Workflows over Web Services using Mobile
Devices, In 14th Heterogeneous Computing Workshop
(HCW-05) in conjunction with International Parallel &

2007 IEEE Congress on Services (SERVICES 2007)
0-7695-2926-7/07 $25.00 © 2007

Distributed Processing Symposium (IPDPS 2005),
IEEE/ACM,. Denver, April.
[5] Calin-Jageman RJ & Fischer TM (2003)
Synaptic
augmentation contributes to environment-driven regulation
of the Aplysia
siphon-withdrawal reflex. Journal of
Neuroscience, 23: 11611-11620
[6] Calabrese RL, Nadim F & Olsen OH (1995) Heartbeat
control in the medicinal leech: A model system for
understanding the origin, coordination, and modulation of
rhythmic motor patterns. Journal of Neurobiology 27: 390402.
[7] Calvanese D, De Giacomo G & Lenzerini M. (2001) A
Framework for Ontology Integration, In Proc. of the First
Semantic Web Working Symposium 303-316.
[8] Chen RS, Nadkami P, Marenco L, Levin F, Erdos J, &
Miller PL (2000). Exploring performance issues for a
clinical database organized using an entity-attribute-value
representation. Journal of the American Medical Informatics
Association, 7: 475-87.
[9] Christensen,E, Curbera F.,Meredith G, Weerawarana S
(2001). Web Services Description Language 1.1,
http://www.w3.org/TR/wsdl.
[10] Covitz PA, Hartel F, Schaefer C, et al, (2003) caCORE: A
common infrastructure for cancer informatics, Bioinformatics
Journal, Oxford Press, Vol. 19 no. 18.
[11] Curbera, F. Duftler, M. Khalaf, R. Nagy, W. Mukhi,
N. Weerawarana, S. (2002). Unraveling the Web services
web: an introduction to SOAP, WSDL, and UDDI. Internet
and Computing, IEEE, 6(2): 86-93.
[12] Drysdale RA, Crosby MA & the FlyBase Consortium
(2005). FlyBase: Genes and gene models. Nucleic acids
research, 33:D390-5.
[13] Edwards DH, Heitler WJ & Krasne FB (1999) Fifty years
of a command neuron: the neurobiology of escape behavior
in the crayfish. Trends in Neuroscience 22: 153-161.
[14] Elliott CJH & Susswein AJ (2002) Comparative
neuroethology of feeding control in molluscs. Journal of
Experimental Biology.Exp.Biol, 205:877-896.
[15] Fielding JM, Simon J & Smith B. Formal Ontology for
Biomedical Knowledge Systems Integration, Proceedings of
EuroMISE, Prague, April 12-15, 2004.
[16] Getting PA (1989) A network oscillator underlying
swimming in Tritonia. In: Neuronal and Cellular Oscillators
(Jacklet JW, ed), pp 215-236. New York: Marcel Dekker,
Inc.
[17] Habich D, Preissler S, Lehner W, Richly S, Assmann U,
Grasselt M & Maier A (2007) Data-grey-box web services in
data centric environments. Proceedings of the 2007
International Conference on Web Services (ICWS 2007), July
9-13, Salt Lake City, Utah, USA.,
[18] Harris TW, Lee R, Schwarz E, Bradnam K, Lawson D,
Chen W, Blasier D, Kenny E, Cunningham F, Kishore R,
Chan J, Muller H-M, Petcherski A, Thorisson G & Day A
(2003) WormBase: a cross-species database for comparative
genomics. Nucleic Acids Research 31:133-137.
[19] Hawkins RD, Kandel ER & Siegelbaum SA (1993)
Learning to modulate transmitter release: Themes and
variations in synaptic plasticity. Annual Review of
Neuroscience 16: 625-665.
[20] Kortuem G (2001). A perer-to-peer computing platform for
mobile ad-hoc networks. In Advanced Topic Workshop
Middleware for Mobile Computing, Heidelberg, Germany..

[21] Kristan WB, Lockery SR & Lewis JE (1995) Using
reflexive behaviors of the medicinal leech to study
information processing. Journal of Neurobiology 27: 380389.
[22] Liu N, Xu F, Marenco L, Hyder F, Miller P, Sheperd GM
(2004). Informatics approaches to functional MRI odor
mapping of the rodent olfactory bulb: OdorMapBuilder and
OdorMapDB. Neuroinformatics, 2: 3-18.
[23] Lushbough C, Bergman MK, Lawrence, CJ, Jennewein D
& Brendel V (2007) Creating bioinformatic workflows
within the BioExtract server. BIOCOMP'07- The 2007
International
Conference
on
Bioinformatics
&
Computational Biology, June 25-28, 2007, Las Vegas,
Nevada, U.S.A.
[24] Marenco L, Tosches N, Crasto C, Shepherd G, Miller PL &
Nadkarni PM (2003). Achieving evolvable web-database
bioscience applications using the EAV/CR framework:
Recent advances.
Journal of the American Medical
Informatics Association, 10: 444-453.
[25]
Mitra
N
(2003).
SOAP
version
1.2,
http://www.w3.org/TR/2003/REC-soap12-part0-20030624/
[26] Nadkarni PM, Marenco L, Chen R, Skoufos E, Shepherd G,
Miller P (1999). Organization of heterogeneous scientific
data using the EAV/CR representation. Journal of the
American Medical Informatics Association, 6: 478-493.
[27] Nelson SB, Sugino K & Hempel CM (2006). The problem
of neuronal cell types: a physiological genomics approach.
Trends in Neuroscience, 29: 339-45.
[28] Nusbaum MP & Beenhakker MP (2002) A small-systems
approach to motor pattern generation. Nature 417: 343-350.
[29] Noy NF & Musen MA (2000) PROMPT: Algorithm and
Tool for Automated Ontology Merging and Alignment In the
Proceedings of the Seventeenth National Conference on
Artificial Intelligence (AAAI-2000), Austin, TX.
[30] Noy NF, Crubezy M, Fergeson RW, Knublauch H, Tu SW,
Vendetti J & Mussen MA (2003). Protege-2000: An opensource ontology-development and knowledge acquisition
environment. AMIA Annual Symposium Proceedings, 2003:
953.
[31] Prasad SK, Bourgeois AG, Madiraju P, Malladi S &
Balasooriya J (2005) A methodology for engineering
collaborative applications over mobile web objects using
SyD middleware. Proc. International Conf. on Web Services
(ICWS'05), IEEE, Orlando, July. 10.1109.
[32] Prasad SK, Madisetti V, Navathe SB, Sunderraman R,
Dogdu E, Bourgeois A, Weeks M, Liu B, Balasooriya J,
Hariharan A, Xie W, Madiraju P, Malladi S, Sivakumar R,
Zelikovsky A, Zhang Y, Pan Y, Belkasim S (2004) SyD: A
middleware testbed for collaborative applications over small
heterogeneous
devices
and
data
stores.
Procs.
ACM/IFIP/USENIX
5th
International
Middleware
Conference (MW-04), Toronto, Canada, Oct., LNCS, 3232:
352-371.
[33] Pinto HS & Martins JP (2001) A methodology for
ontology integration, Proceedings of the 1st international
conference on Knowledge capture, Victoria, British
Columbia, Canada.
[34] Smith B & and Rosse C (2004) The Role of Foundational
Relations in the Alignment of Biomedical Ontologie, M.
Fieschi, et al. (eds.), Medinfo 2004, Amsterdam: IOS Press,
444–448.

2007 IEEE Congress on Services (SERVICES 2007)
0-7695-2926-7/07 $25.00 © 2007

A Two-Layered Software Architecture for Distributed Workflow
Coordination over Web Services
Janaka Balasooriya, Jaimini Joshi, and Sushil K. Prasad
Georgia State University
Atlanta, GA, USA
sprasad@gsu.edu

Abstract
The current state of the art of workflows over web
services employs a centralized composite process to
coordinate the constituent web services. Therefore, the
coordinator process is complex, less scalable, and
bulky. This paper introduces an architecture and a
technique for distributing the centralized coordination
logic of traditional workflows by (i) extending the
stateless web services into self-coordinating entities
using coordinator proxy objects, and (ii) creating a
workflow over these entities by interconnecting them
into a distributed network of objects using web bond
primitives. Previously, we have developed web bond
primitives to enforce interdependencies among
autonomous entities. We have designed and prototyped
our BondFlow system, which provides a platform to
configure such distributed workflows, producing
coordination components with footprint small enough
(around 150 KB) to be executed on a handheld.

1. Introduction
The architecture of a traditional workflow is “single
layered” where developer needs to program the
workflow logic to ensure communication, workflow
coordination, and intermediate data processing (Fig.
1a). The participating stateless web services are not
active participants in the workflow.
While
centralized coordination has total control over the
behavior of the workflow process, it is at the cost of
complex programming. Distributed coordination can
entail easier development, and also has two kinds of
advantages over centralized coordination: (i) due to
security, privacy, or licensing imperatives, some webbased objects will only allow direct pair-wise
interactions without any coordinating third-party
entity; and (ii) centralized workflows suffer from
issues such as scalability, performance, and fault
tolerance [1].
We propose a two-layered workflow software
architecture, which greatly simplifies the workflow
development task by distributing the complexity of the
centralized workflow coordination logic over stateless
web services of traditional systems such as BPEL. The
concept of the coordinator proxy object is central to
our decentralized architecture. In contrast to other
systems such as Self-Serv, the idea of the coordinator
proxy object enhances each web service facilitating

IEEE International Conference on Web Services (ICWS'06)
0-7695-2669-1/06 $20.00 © 2006

Shamkant Navathe
Georgia Institute of Technology
Atlanta, GA, USA
sham@cc.gatech.edu

more fine-grained decentralization of the coordination.
A preliminary study of implementation prototype
shows that the bond related time is ~10% of the
workflow execution time. Also, the small footprint of
coordinator proxy object (~10KB) enables them to
reside on java-enabled handheld devices. Section 2
presents our architecture and Section 3 illustrates it
using a purchase order example.

2. Workflow Coordination Architecture
First, we briefly summarize the idea of web
coordination bonds. Then we will explain our two
layered workflow software architecture.
Web Coordination Bonds: There are two types of web
bonds: subscription bonds and negotiation bonds. The
subscription bonds allow automatic flow of
information and control from a source entity to other
entities that subscribe to it. This can be employed for
synchronization as well as for more complex changes,
needing data or event flows. The negotiation bonds
enforce dependencies and constraints among entities
and trigger changes based on constraints satisfaction.
We have established that web bonds have the
modeling power of extended Petri nets. They can
express all the benchmark control flow patterns for
workflow and for inter-process communication [2].
Complex
Centralized
Workflow
Logic

High-Level Distributed
Coordination Logic

Self Coordinating
Distributed Coordinator
Proxy Objects ( State
Information)

Stateless
Web Services

Stateless
Web Services
(No State Information)

(a)
Architecture
of (b)
Architecture
workflow
using workflow using
traditional systems.
BondFlow system.
Figure 1: Two-Layered Workflow Software
Architecture

of
the

Two-Layered Workflow Software Architecture: In our
approach, first, stateless web services are empowered
by “Coordinator Proxy Objects (CPO)” into selfcoordinating stateful entities. Coordinator objects
represent participating web services in the workflow.
They encompass all the coordination capabilities of
web bond artifacts, and are automatically generated by
BondFlow system [3] (Fig. 1b). Therefore, each CPO
maintains and enforces its own dependencies during
the execution of the workflow. Thus, the workflows
we create are inherently distributed.
Developer’s responsibility then is to configure the
workflow using high level constructs by linking web
service appropriately and specifying constraints. For
this, the web bond primitives are employed to interlink
the coordinator proxy objects, capturing the workflow
logic.
Web Service Coordinator Proxy Object: Web service
method invocations of the workflow take place
through the coordinator object and the web bond
coordination layer ensures that pre and post method
invocation dependencies are satisfied. Fig. 2 illustrates
the components of the coordinator proxy object. The
coordinator object provides the same interface as the
web service provides to the outside world. As shown
in Fig. 2, each coordinator object has a bond
repository, a set of user-defined constraints (if any),
and runtime information associated with it. The bond
repository consists of all the workflow dependences
related to the coordinator object (participating web
service). It also maintains the status of method
invocations such as intermediate data and partial
results. User defined constraints represent the
additional lower-level dependencies not captured using
web bonds

3. Purchase Order Workflow Example
Here, we illustrate the workflow configuration using
high-level web coordination bond constructs using
purchase order case study workflow. Five web services
are involved in this workflow. The system generates
coordinator proxy objects for each web service. Then,
as shown in Fig. 3, a network of web bonds has been
created among methods of these coordinator objects to
enforce the workflow constraints. For example, the
“receive purchase order” web service needs to pass
control to “price calculation,” “find shipper,” and
“production and shipment” web services once it is
completed. In order to model this split-dependency,
Receive_PO() method has three subscription bonds
(dashed arrows) to each of Initiate_PC(),
Find_Shipper(), and Initiate_ Production() methods.
Similarly, Process_Invoice() enforces AND-join by
using and-negotiation bonds (solid arrows) back to
Complete_PC(), Arrange_ Logistics() and Complete_
Production() methods.
Price Calculation
Initiate_PC()
Complete_PC()

Receive
Purchase
order

Process
Invoice

Find Shipper
Find_Shipper()

Process_Invoice()

Receive_PO()
Arrange_Logistics()

Production
and Shipment

Negotiation Bond

Initiate_Production()

CPO object
kernel

Complete_Production()

Method Calls to
embedded
web service.
Runtime
data

Web bond
coordination

Figure 3: Purchase Order Workflow
Web bond
repository

User
defined
constraints

Figure 2: Web Service Coordinator Proxy Object
Bond Repository: Bond configuration is stored in a
persistent storage in XML format. The bond data store
consists of four elements. The first element is to
identify the web service (hence the coordinator
objects) the repository belongs to. The second element
identifies the workflow/application to which the
repository belongs. Source and destination methods
and associated constraints among bonds are in the
other two elements.

IEEE International Conference on Web Services (ICWS'06)
0-7695-2669-1/06 $20.00 © 2006

Subscription Bond

The configured workflow consists of five coordinator
objects representing each web service with bond
repositories associated with them.

4. References
[1] Girish Chafle, Sunil Chandra, Vijay Mann, and Mangala G.
Nanda, “Decentralized Orchestration of Composite Web Services,”
In Proc. of the Alternate Track on Web Services at the 13th Intl.
WWW Conf., New York, NY, May 2004.
[2] Sushil K. Prasad and J. Balasoorya, 2005, “Fundamental
Capabilities of Web Coordination Bonds: Modeling Petri Nets and
Expressing Workflow and Communication Patterns over Web
Services ,“ Proc. Hawaii Intl. Conf. in Syst. Sc. (HICSS-38), Jan.,
Big Island, January 4-8.
[3] Janaka Balasooriya, Mohini Padye , Sushil Prasad, and Shamkant
B. Navathe “BondFlow: A System for Distributed Coordination of
th

Workflows over Web Services,” In 14 HCW in conjunction with
IPDPS’05. Denver, Colorado, USA, Apr 4.

2008 IEEE International Conference on Services Computing

A Middleware Architecture for Enhancing Web Services Infrastructure for
Distributed Coordination of Workflows
Janaka Balasooriya
Arizona State University
Tempe, AZ, USA
janakab@asu.edu

Sushil K. Prasad
Georgia State University
Atlanta, GA, USA
sprasad@gsu.edu

Fig. 1 illustrates the purchase order workflow presented in the WSBPEL specification (Web Services Business Process Execution
Language) [13]. In Fig. 1, dark arrows depict the control flow
dependencies while dashed arrows depict data flow dependencies.
Fig. 2 illustrates the software architecture of the WS-BPEL based
implementation of the workflow. It models the composite
workflow process as a separate state-preserving web process
encapsulating all the data flow and control flow requirements. This
software architecture typically results in complex and centralized
logic for workflow coordination. This paper will address two
aspects of this model:

Abstract
This paper discusses a layered workflow software architecture for
distributed coordination of workflows over web services and
proposes fundamental enhancements to the web services
infrastructure that facilitate the layered workflow software
architecture. We verify our layered approach using a detailed
simulation and a proof-of-concept prototype implementation. Our
proposed architecture for Web Service Coordination Management
Middleware (WSCMM) is a simple but powerful enhancement to
the web service infrastructure enabling the services to locally
manage their dependencies and to handle messages resulting from
multiple workflows. We have carried out a detailed simulation to
identify key components of our middleware architecture. We also
compare and contrast our architecture with the current web
service technologies. Our experiments demonstrate that we can
develop both centralized and distributed workflows over the
architecturally enhanced web services with relative simplicity. In
addition, our lightweight coordination components with footprint
no larger than 150 KB allow these workflows to be executed even
on a handheld.

Product
Calculation
Invoke/Respond
Communication
te
xt
Receive
Purchase

A rra ng e Lo g is tic s

C o m p le te
p ro du c tio n
S c he d u lin g

Invoice

te
xt

Production
schedule

i) Centralized Coordination: There are both pros and cons of
centralized coordination: the positive point is to have total control
over the behavior of the web process at the cost of complex and
intricate programming. Distributed coordination, on the other hand,
can have two advantages over centralized coordination: (i) Due to
security, privacy, or licensing imperatives, some web-based objects
will only allow direct pair-wise interactions without any
coordinating third-party entity; and (ii) Centralized workflows
suffer from issues such as scalability, performance, and fault
tolerance [5]. In Section 7, we compare and contrast current efforts
towards distributed workflow coordination system with ours.
ii) Deployment Platforms: The current platforms consume
significant amount of resources and are difficult to deploy on
limited resource devices such as a mobile handheld. Portions of
long-running workflows can reside on handheld devices providing
monitoring and controlling capabilities. Executing and monitoring
workflows over diverse set of devices including wireless devices
can have significant benefits [9, 10, 11, 12, 22].. In Section 6, we
discuss our solution enabling this with a prototype implementation
and its preliminary evaluations.

R e cive P urc h as e
O rd e r

C om p le te P rice
C a lcu latio n

te
xt

Figure 2: Architecture of traditional WS-BPEL Implementation

2. Coordination Architectures

In itia te P ro d uc tio n
s ch e du lin g

te
xt

Shipper

Web Services (WSs) have become the building blocks based on
which new distributed applications will be created over Internet [3,
8]. Such applications span domains as diverse as enterprise ecommerce applications [3], personal applications [1, 7, 10, 11], and
scientific applications [4, 6]. Efficient technologies are required to
rapidly develop and deploy robust collaborative applications
leveraging off the existing web services [15]. Most of these
collaborative applications involve workflows [8], which is the
focus of this paper.

D e cide o n
S hip pe r

Composite web
process with all the
communication,
coordination and
workflow logic

te
xt

1. Introduction

Initiate P ric e
C a lcu latio n

Shamkant B. Navathe
Georgia Institute of Technology
Atlanta, GA, USA
sham@cc.gatech.edu

Inv oic e
P ro ce ss ing

Figure 1: Purchase order workflow

3. Our Approach and Contribution
This paper discusses a layered workflow software architecture for
distributed coordination of workflows over web services and

978-0-7695-3283-7/08 $25.00 © 2008 IEEE
DOI 10.1109/SCC.2008.127

370

proposes fundamental enhancements to the web services
infrastructure that facilitate the layered workflow software
architecture. Then we verify our layered approach using a detailed
simulation and a proof-of-concept prototype implementation [13,
14].

discuss related work. Finally, Section 8 presents our future plan of
work and conclusions.

3.1 Background of Web Bonds
Here, we briefly discuss the idea of web coordination bonds.
We have proposed the ideas of Web bonds [13] as a set of
primitives for web service coordination/choreography. There are
two types of web bonds: subscription bonds and negotiation bonds.
The subscription bonds allow automatic flow of information and
control flow dependencies from a source entity to other entities that
subscribe to it. This can be employed for synchronization as well as
for more complex changes, needing data or event flows. The
negotiation bonds enforce constraints among entities and trigger
changes based on constraints satisfaction. A negotiation bond from
A to B has two possible interpretations: pre-execution and postexecution. In case of pre-execution, in order to start the activity A,
B needs to complete its execution. In case of post-execution, in
order to start the activity A, A needs to make sure that B can be
completed afterwards. Without loss of generality, both pre- and
post-execution interpretations of negotiation bonds enforce
atomicity. In this paper, unless specified, we have employed the
pre-execution type of negotiation bonds implicitly
We have established that web bonds have the modeling power of
extended Petri nets. They can express all the benchmark patterns
for workflow and for inter-process communication; a feat that
almost all previously proposed artifacts and languages are not
capable of achieving comprehensively [13]. Section 3.2 illustrates
the modeling of Purchase order workflow using web coordination
bonds.

i) Two-Layered Workflow Software Architecture: We propose a
layered workflow software architecture, which greatly simplifies
the workflow development task by distributing the complexity of
the centralized workflow coordination logic over stateless web
services of traditional systems such as BPEL. The stateless web
services are empowered by “Coordinator Proxy Objects (CPO)”
into self-coordinating stateful entities. Next, the high-level web
bond primitives are employed to interlink the coordinator proxy
objects, capturing the workflow logic. Previously, we have
proposed the ideas of web bonds as a set of primitives for web
service coordination/choreography and proved those web bonds are
capable of modeling all the workflow control flow dependencies
[13]. Each CPO maintains and enforces its own dependencies
during the execution of the workflow. Thus, the workflows we
create are inherently distributed. Details of our layered architecture
will be presented in Section 3.
ii) Web Service Coordination Management Middleware: The
primary objective of the WSCMM system is to distribute the
workflow coordination responsibilities among participating web
services. Subsequently, it simplifies the workflow development
process. WSCMM consists of two components: Web Service
Management System (WSMS) and Web Service Coordination
Management System (WSCMM). WSCMS maintains and enforces
workflow dependencies while WSMS transforms the stateless web
service into a stateful entity through the coordinator proxy object.
Web service method invocations go through this object, which
enforces pre and post web service method invocation dependencies
using the functionality of WSCMS. The development of a
WSCMM in the web services domain is analogous to the
development of a DBMS (database management system) that
coordinates the execution of queries and transactions in the
database domain. We have carried out a detailed simulation to
identify the key components and underlying design issues of our
middleware. Our experiments demonstrate that we can develop
both centralized and distributed workflows over the architecturally
enhanced web services with relative simplicity.

4.A Two-Layered Workflow Software Architecture

Complex
Centralized
Workflow
Logic

High-Level Distributed
Coordination Logic

Self Coordinating Distributed
Coordinator
Proxy Objects ( State
Information)

Stateless
Web Services

iii) A proof-of-concept prototype: Using the principles of the
proposed middleware architecture, we have prototyped our
BondFlow system using Java as a platform to configure and
execute workflows over web services [14]. The footprint of the
BondFlow runtime system is 24KB and the additional third party
software packages, such as those of SOAP client and XML parser,
account for 115KB. The execution time workspace used by the
BondFlow system is 5.4 MB including JVM (Jeode 1.2 handheld
Java version). Therefore, we have been able to test the BondFlow
system on both wired and wireless infrastructures. For
communication among the coordinator objects, we employed
SOAP in wired devices and our SyD middleware in wireless
devices. SyD is our recently prototyped middleware platform to
develop and execute distributed applications over handheld devices
[1].
The reminder of the paper is organized as follows. Section 2
describes the background work on web coordination bonds. Section
3 presents two-layered workflow software architecture. Section 4
discusses WSCMM system architecture. Section 5 presents
simulation details of WSCMM. Section 6 presents prototype
implementation details and system evaluation. In Section 7, we

(a) Traditional workflow
architecure.

Stateless
Web Services (No
Information)

(b) Proposed workflow
architecture.

Figure 3: Two-Layer Workflow Software Architecture
As shown in Fig. 3a, the architecture of the traditional workflow
code is “single layer” where developer needs to program the
workflow from scratch (ensure communication, workflow
coordination, and intermediate data processing). In contrast, in our
proposed workflow software architecture, workflow coordination
has been encapsulated as a separate layer using web coordination
bonds. In addition, the coordinator objects represent participating
web services in the workflow. The coordinator object encompasses
all the coordination capabilities of web bond artifacts (Fig. 3b).
Coordinator proxy object communicates with the web service from
method invocations and is state preserving. Capabilities of web
coordination bonds including modeling workflow dependencies
have been encapsulated in the upper layer (Fig. 3b). Developer’s
responsibility is to configure the workflow using high level

371

constructs by linking web services appropriately and specifying
constraints (high-level configurability).

4.2 Web Bond Layer

4.1 Web Service Coordinator Proxy Object (CPO)

Price Calculation

Fig. 4 illustrates components of the coordinator proxy object. The
coordinator object provides the same interface as the web service
provides to the outer world. Web service method invocations of the
workflow take place through the coordinator object and the web
bond coordination layer ensures that pre and post method
invocation dependencies are satisfied. As shown in Fig. 4, each
coordinator object has a bond repository, a set of user-defined
constraints (if any), and runtime information associated with it. The
bond repository consists of all the workflow dependences related to
the coordinator object (participating web service).

Initiate_PC()
Complete_PC()

Receive
Purchase

Process
Invoice

Find Shipper
Find_Shipper()

Process_Invoice()

Receive_PO()
Arrange_Logistics()

WSCP object
kernel

Production
and Shipment

Method Calls to
embedded
web service.
Runtime
data

Web bond
coordination

Initiate_production()

Web bond
repository

Complete_production()

Figure 6: Purchase Order Workflow
Here, we illustrate the workflow configuration using high-level
web coordination bond constructs using the purchase order case
study workflow. Fig. 6 illustrates the modeling of purchase order
workflow using a network of web coordination bonds. Five web
services are involved in the workflow. The system generates
coordinator proxy objects for each web service. Then, a network of
web bonds has been created among methods of these coordinator
objects to enforce the workflow constraints. For example, the
“receive purchase order” web service needs to pass control to
“price calculation”, “find shipper”, and “production and shipment
web services” once it is completed. In order to model this splitdependency, Receive_PO() method has three subscription bonds to
each of Initiate_PC(), Find_Shipper(), and Initiate_production()
methods. Similarly, rest of the dependencies have been modeled
using other negotiation and subscription bonds.

User
defined
constraints

Figure 4: Web Service Coordinator Proxy Object
This indirection allows us to bring transparency to the system and
hide the necessary coordination and communication logic behind it.
It also maintains the status of method invocations such as partial
results. User defined constraints represent the additional
dependency conditions (dependencies not defined using web
bonds) needed to be satisfied while enforcing workflow
dependencies. As shown in Fig. 5, each web service method call is
encapsulated by a negotiation and a subscription bond check. The
negotiation bonds enforce pre-method invocation dependencies
while the subscription bonds enforce post method invocation
dependencies.

The configured workflow consists of five coordinator objects
representing each web service with bond repositories associated
with them.

This logic ensures that workflow dependencies are satisfied with
associated WS method invocation. The idea of Web service
coordinator proxy object together with underlying web bond
primitives encapsulates the workflow coordination layer. This
simple, but powerful idea empowers web services and makes
workflow configuration less programming intensive. We believe
this concept has enough potential to trigger a fundamental shift in
workflow development over web services.

5. WSCMM Architecture
Based on our two-layered workflow software architecture we
extract three key layers of functionality encapsulated by the
composite web process (Figure 7). The top layer encapsulates the
abstract workflow process defined using high-level constructs. The
middle layer represents the code that enforces workflow
dependencies (implements based on underline language
constructs). The last layer implements actual communication with
individual web services that are participants of the workflow. For
each workflow, all three layers need to be implemented from the
stretch. However, second and third layers represent significant
amount of generic functionalities such as enforcing basic workflow
coordination logic, Web service invocations, message handling and
storing corresponding state information. Therefore, generic
functionalities of these two layers can be extracted and provided as
a middleware layer for distributed workflow coordination. We
identify the following three categories of functionalities for a
middleware system for distributed workflow coordination over web
services.

Bond Repository: The bond data store (repository) consists of four
elements. The first element is to identify the web service (hence the
coordinator objects) the repository belongs to. The second element
identifies the workflow/application to which the repository
belongs. Source and destination methods and associated constrains
among bonds are in the next two elements [14].

372

Implications on Functionality:
i.) Enforce dependencies: Workflow activities need to satisfy
various kinds of constraints in order to accomplish the task
successfully. For example, before initiating the activity, it may
need to satisfy application specific data, control and resource
dependencies and once the activity is completed, that activity may
need to inform its results and pass control to other activities if the
workflow is based on various conditions. In a distributed
coordination environment, each web service needs to maintain its
own dependencies and enforce them locally.

of steps including enforcing dependencies and updating state
information.
Workflow
Application k

j

Communication Protocol ( eg: SOAP)

Code that defines the abstract
process
(High-level application logic)

Composite Web Process
Code

Workflow
Applic ation

Workflow
Application i

WSCMS

WSMS
Message Handler

Code to Enforce dependencies
(Coordination context, Workflow
Coordination, Transaction
management)

i

State/Instance
handler J

Coordinator objects for each
application

Code to handle Interaction with web
services
(Message Handling, Correlation,
Sequencing, Web service method
Invocations)

K

i

J

K

Coordination Context for

Stateless Web Service (WSDL Interface)

Figure 8: Web Service Coordination Middleware Overview
Stateless Web Services

Stateless Web Services

Message handling: The message handler of the WSMS handles the
inter-web service communication and keeps the state information of
interactions. Upon arrival of a message, the communication server
(SOAP server) passes it to the message handler. Message header
contains a unique identification for each message (ConvID).
ConvID consists of a reference to the application, method being
invoked, parameter set, status of tag of the invocation such as
”Ready”, “Commit” in transaction processing. Based on this
information, the message handler resolves the message and takes
appropriate actions.

Figure 7: Functional decomposition of composite web process
ii.) Preserve state information: Long-lived workflow applications
require the state of method invocations (success or failure) and
intermediate results to be stored and make global decisions. Such
state information needs to be maintained and correlated with proper
application context.
iii.) Process messages: Web services communicate exchanging
messages. Therefore, in order to become live participants in
distributed applications, web services should bear enough
capabilities to process messages and make decisions accordingly.
This entails maintaining proper communication context for each
application, message correlation and sequencing, and reliable
messaging.

Web Service Coordination Management System (WSCMS): Keeps
the coordination (dependency) information (coordination context)
for each application and enforces dependencies. Since coordination
and dependency enforcement is local to each participating web
service, WSCMS maintains coordination context for each
applications locally to reflect dependencies. Web services
coordination management system supports two types of
dependencies: pre method execution dependencies and post method
execution dependencies.

In our middleware, the functionalities pertaining to workflow
dependency are carried out by WSCMS layer. Processing messages
and maintaining state information is handled by WSMS. The next
section discusses these components in detail.

5.2 Web Service Coordination Management System:
Detailed Operation

5.1 Web Service Coordination Management
Middleware Architecture: An Overview

In web service based workflow applications, individual web service
represents a particular workflow activity. Activity performs its
operation by invoking web service method calls. Workflow
dependencies need to be associated with WS method invocations.
Typically, workflow activities enforce two types of dependencies.
Before initiating the activity (trigged by the workflow engine) it
needs to make sure that all the dependencies (including data, control
and resource) have been satisfied. If not, the activity waits until it
receives all the control and data items or it can start fulfilling these
requirements. These kinds of dependencies can be characterized as
“pre execution dependencies. “ Other type of dependency arises
once the workflow activity is completed. Upon completion of the
activity, it may require to pass control/data to other entities in the
workflow based on workflow specific constraints. These kinds of
dependencies are characterized as “post execution dependencies.”

This section starts with a generic description of our web WSCMM
architecture, its components and related issues. Then we discuss
each component in detail. The web coordination middleware
consists of two main components: Web service management system
(WSMS) and the Web service coordination management system
(WSCMS) (Fig. 8).
Web Service Management System (WSMS): WSMS handles two
functionalities; Preserve state information for long-lived interactions
and process messages locally and initiate appropriate actions.
Stateful view: The state/instance handler instantiates a coordinator
object based on WSDL description for each such application. The
coordinator object has a binding to the original web service method
calls. Moreover, each coordinator object has a corresponding status
context stored in the persistent storage. WS method invocations go
through the coordinator object. Each method invocation has series

Pre-Execution Dependencies (join dependencies): Pre execution
dependency for workflow j, defined over the method mi of web

373

service wi with parameter set k can be represented as
Jj.wi.mi(paramk)={D, constraints}, where D is the set of destination
methods, and the constraints are workflow constraints such as ANDjoin and Sync-Merge.

Figure 10: Enforcing Post Execution Dependencies

6. Simulation
Architecture

Figure 9: Enforcing Pre Execution Dependencies
WSCMS ensures that join-dependencies are met before making the
web service method call. Series of events take place in local
WSCMS as well as destination WS’s coordination management
systems while enforcing join-dependencies. Figure 9 illustrates the
interaction among WSCMM components while enforcing joindependency constraints. Message handlers maintain an inbox and
outbox for each workflow application. Both inbox and outbox has
entries for each join-dependency point. When it receives
control/data from destination entities message handler direct them
for the appropriate inbox. Once the activity receives trigger (control)
to perform the method call (step 0), it sends a message to the
WSCMS for dependency check (step 1, 2, and 3). If all the
dependencies are met, the web service method gets invoked and
state information is updated (step 5). Otherwise, WSCMS sends
messages to all the remaining destination entities for dependency
check (step 4). Dependency check performs two operations. First, it
requests state information from the state handler of the destination
web service related to this particular application join-point. If the
status information is available, a response is sent. Otherwise, it tries
to invoke the remote method and sends the response to the requester
web service. This invocation requires similar dependency check.

and

Verification

of

the

We have used the Discrete Event System Specification (DEVS)
modeling tool to simulate our WSCMM and verify various
dependency modeling scenarios. DEVS provides a formal
framework that facilitates simulation and verification of distributed
systems. DEVS is derived from mathematical dynamical system
theory [23]. It supports hierarchical modular composition and
object oriented implementation. There are two primary modules:
the atomic model and the coupled model. One can combine these
models to specify complex simulations. Atomic models have input
events, output events, state variables, state transition functions,
external transition, internal transition, time advance function,
computing function, and transitions. The current state can be
specified using state variables and input and output functions are
computed based on the current state and the computing function.
The coupled model has components, interconnections, internal
couplings, external input couplings, and external output couplings.
The main purpose of the simulation is to verify the correctness
of our middleware and to identify design issues. In order to do that,
we simulate the interactions among components of the middleware
for different incoming messages including pre and post method
invocation dependencies. Figure 11 shows our simulation model
for the middleware. It consists of several modules: message handler
(msgHandler), web service coordination management system
wsCoMys), web service management system (wsMgtSys), and a
Web service component. Here, we briefly describe each component
of the simulation model.
Message Handler: The message handler consists of three
components: two incoming ports to receive messages from remote
web services and the web service coordination management system
and three outgoing ports to send messages to send messages to
remote web services, the web service management system, and the
web service coordination management system. Message receiver
(mercy), receives messages from remote services (Figure 10).
Upon receipt of the message, it places the message in a FIFO
queue. Then, mrec passes messages to the message revolver (mres).
Message revolver’s job is to identify the type of message (Table 1).
Based on the message type, the message is directed to the
appropriate component. For our simulation, we have used the
following format of the message.
Message format:
Workflowid:fromwebservice:method:parameterset:tag

Post-Execution Dependencies (split dependency):
Split
dependency for workflow j, method mi of web service wi with
parameter set k can be represented as
Sj.wi.mi(paramk)={D, constraints}, where D is the set of destination
methods and constraints are workflow constraints such as ANDSplit, XOR Split.
Enforcing split dependencies requires a web service to trigger a set
of remote web services depending on the workflow constraints
specified for the split-point. Figure 10 illustrates the interaction
among WSCMM components while enforcing split-dependency
constraints. As shown in Figure 11, WSCMS requests the message
handler to send data/control to remote web services according to
the workflow split criteria. The message handler places remote
invocations to the outbox (dispatcher) and triggers remote web
service methods (step 6). At the same time, the coordination
management system updates state information (step 5).

The first portion is to identify the workflow because any web
service can participate in different workflows at a given time. The

374

second portion is to identify the message sender. The third and
fourth portions contain method details and parameters. Finally, the
tag is to identify the type of message. For example, suppose web
service w1 receives the message, wf1:ws2:m2:p2:0. This means that
the message belongs to workflow 1. Sender is web service 2 and the
tag is 0. Tag 0 means the message is a method invocation. In this
case, invocation of method m2 with parameter set p2. Once, the
resolver receives this type of message it resolves the message using
the tag and directs it to the appropriate output port. Table 1 shows
the relationship between tag and the outgoing message port.

Other possible functionalities of the message receiver part of the
message handler are checking appropriate security and enforcing
QoS requirements. We have not considered them in our
implementation. This simulation can be extended to accommodate
such situations. The dispatcher of the message handler sends
outgoing messages to remote web services. We have modeled it
using FIFO queue. However, the efficiency of this can be improved
using multi-threaded dispatcher.

Web Service: A web service receives messages and invokes
appropriate methods. After invoking the method, it changes the tag
from 5 to 6 and sends the result back to WSMS. Method invocation
has been implemented as a “holdIn” time in the simulator. HoldIn
method of the simulator allows us to wait for a particular time
period at a defined state. For example, when a method is being
executed, the web service changes its state from “no-invocations”
to “invoking” state.

Table 1: Message tag and the outgoing message ports at the
Message Handler
Tag
0 -Method invocation

Outgoing port
Send the message to wsms through
“outwsms” port.
1-data/control from subscription Send the message to wscms through
bonds
“outwscms” port.
2-enforce dependency (method Send the message to wsms through
invocation), negotiation bond
“outwsms” port.
6-Enforce post method execution Send the message to dispatcher
dependencies (data/control through
through “outdispatcher” port.
outgoing subscription bonds)

The Web Service Coordination Management System
(WSCMS): Similar to the message handler, WSCMS also
consists of three components: a message receiver (cmsrec), a bond
repository (cmsbr), and a message dispatcher (cmsdis) (Figure 11).
The main component of the WSCMS is the bond repository. Each
workflow, maintains its own dependencies in a file. The message
receiver receives messages and puts them in a FIFOqueue. Then it
passes messages to the “Bond Repository” to take appropriate
actions. In our system, we have employed web coordination bonds
to model dependencies. Therefore, WSCMS essentially maintains
web coordination bonds and manipulate them in order to enforce
workflow dependencies.

Figure 11: WSCMM Simulation Model

375

Dependencies are stored in the Bond Repository. Bond Repository
is a persistent storage where each workflow has a corresponding
bond store. Upon completion of the action, it sends the message to
the dispatcher and the dispatcher directs the message to the
appropriate component.

For wireless device experiments we have used HP's iPAQ models
3600 and 3700 with 32 and 64 MB storage running Windows
CE/Pocket PC OS interconnected through IEEE 802.11 adapter
cards and a 11 MB/s Wireless LAN. Jeode EVM personal Java 1.2
compatible has been employed as the Java Virtual Machine.
Workflow Configuration Module

The Web Service Management System: The web service
management system receives messages from three ports:
infrommsg, infromws, and infromwscms receive messages from
the messegae handler, participating web service, and the web
service coordination management system respectively (Figure 11).
First, WSMS receives method invocation (tag 0 or 2) messages
from the message handler. Then, it identifies the proper web
service through websericeid tag of the message. Upon
identification of the workflow, it sends the message to web service
coordination management system to check/enforce pre workflow
pre-execution dependencies. If dependencies are successfully met,
then WSCMS changes the tag of the message from 0 or 2 to 5 and
sends back to WSMS. Upon receipt of a message with tag 5,
WSMS (wsmsoh), invokes the web service method. Web service
invokes the method and sends the results back to WSMS. This
time tag is 6. Tag 6 indicates that the method invocation happens
(success or fail) and it need to update the state information with
partial date or failure message. This is done by passing this data to
the wsmsssh (state handler). It stores these data in a file. In our
simulation, this operation has been simulated by accessing a file
having the same name as the workflow. Unavailability of such a
file indicates and error. It also needs to send a message to the
WSCMS to enforce post method invocation dependencies.

W eb Service
Interface Module
W S Locatorr

Lookup for
Web services

W eb services
Registry(UDDI)

WS Parser

WSCP Generator
Module

WorkflowExecutionModule

Configured Workflow (Code/Data)
Coordinator Proxy
object invocations

Bond Manager
Workflow
Configuration
Manager

SOAP/RPC(P(PC based )
SyDMiddleware (handheld based)

WS invocations

JVM

Figure 12: BondFlow System
System performance details: We have deployed and executed case
study workflows including the purchase order workflow on both
wired and wireless infrastructure. The Web bond related time for
our case study workflows are approximately ~10% of the time
without the BondFlow system. The bond related time accounts for
times taken to check workflow dependencies in bond repository
and initiate appropriate method calls on remote web services
(coordinator objects). The footprint of the purchase order workflow
is about 32.5 KB . The coordinator objects and corresponding
bond repositories account for ~25% and ~75% respectively. The
footprint of the proxy object is small (~10KB) and typically
increases by 0.3 KB per additional operation (method) of the web
service. Intermediate system generated files are less than 100 KB
for a sufficiently large workflow. Typically the footprint of the
bond repository increases 0.3 KB per each additional bond. Thus,
we feel that with in a very small amount of additional storage for
the proxy objects, we have been able to get substantial gains in the
speed of the workflow.

Simulation Scenarios: The first set of simulations has been carried
out to verify following two scenarios.
i.)Enforcing workflow dependencies using subscription
bonds (post conditions)
ii.) Enforcing workflow dependencies using negotiation
bonds (precondition)
Here, we have simulated the message interaction shown in Figure
9 and Figure 10 using the simulation model describe above. Each
web service has been represented using separate instances of
WSCMM to simulate the distributed coordination and our
simulation results show that the web bond based realization of the
WSCMM behaves correctly while enforcing workflow control flow
dependencies.

8. Related Work and Discussion
Several approaches have been proposed toward distributed web
service coordination and peer-to-peer interaction among web
services. Among such systems, IBM symphony [5] decentralizes
the coordination by partitioning centralized workflow specification
into separate modules so that they can run in a distributed setting.
However, there are limitations to such efforts. First, it is necessary
to develop the centralized BPEL code and then partition and
distribute it among participant entities. Second, usually, there are
problems partitioning the code in complex application scenarios
such as long running transactional applications without proper
infrastructure support. The Self-Serv project presented in [15],
proposes a peer-to-peer orchestration model for web services. It
introduces a ”coordinator,” which can act as a scheduler for
participating web services. Several coordinators can control the
execution of the workflow in peer-to-peer fashion. In [17] authors
propose a distributed and decentralized process approach called
OSIRIS that allows peer-to-peer communication among
participating web services. However, their approach needs meta
information to be stored in a central location. Also, in order to
enforce fork/join dependencies they introduce a new join node
exclusive from workflow nodes. In contrast to the Self-Serv and
OSIRIS approaches, our coordinator proxy object is dynamically
generated based on the description of participating web service and
it encapsulates all the coordination capabilities. The proxy object
enforces its own dependencies. This enhances each web service
facilitating more fine-grained decentralization of the coordination.
In [19], authors propose a system to distribute the execution of

7. Prototype Implementation and System
Evaluation: The BondFlow System [14]
The BondFlow system has been developed as a platform to
configure and execute workflows over web services (Fig. 12). The
workflow configuration module consists of web service interface
module, coordinator proxy object generator module, and workflow
configuration module. The workflow execution module consists of
web bond manager, communication layer, and JVM runtime.
Implementation details can be found at [14].
Hardware software setup: We ran our experiments on a high
performance SunOS 5.8 server. We built wrappers using JDK
1.4.2. The WSDL parser has been built using WSDL4J API.
WSLD4J API is an IBM reference implementation of the JSR-110
specification (JavaAPI’s for WSDL). NanoXML 2.2.1 is used as
the XMLparser for JAVA. Various publicly available web services
including
Xmethod’s
SOAP
based
web
services
(http://www.xmethods.net/) have been used for our experiments.

376

business applications using web services by adding business rules
into the SOAP messages. Business rules encoded in the SOAP
header specify the order of execution. Messages are decoded and
processed by special processing units called SOAP intermediaries.
In [18], authors propose a service-oriented distributed business
rules system and its implementation based on WS-Coordination.
Web service Resource framework is another proposal towards
stateful web services. It provides standardization representation to
stateful resources and the web service interface provides
functionalities to access (read, update and query) state information.
This state information is used to process web service messages
[21]. Comparative study of various implementations of WSRF is
presented in [20]. In contrast to WSRF approach, in the BondFlow
system maintains state information of workflow execution and
processes messages. State is attached to the coordinator proxy
object. Web service interface need not be changed and web service
is relieved from state handling functionalities.
In [2, 22], authors describe issues related to service composition
in mobile environments and evaluate criteria for judging protocols
that enable such composition. The composition protocols are based
on distributed brokerage mechanisms and utilize a distributed
service discovery process over ad-hoc network connectivity. In [7],
authors present architecture for mobile device collaboration using
web services. In [10], authors present a rapid application
development environment for mobile web services. [11, 12] present
web service based mobile application integration framework.
However, a key limitation of most of these technologies is that they
treat handheld devices only as clients.

[6] Elias Sinderson , Vish Magapu , Ronald Mak, “:Portal of NASAs
Mars Exploration Rovers Mission-Middleware and Web Services for
the Collaborative Information,” Invited paper, In Proc.
ACM/IFIP/USENIX 5th International Middleware Conference,
Toronto, Ontario, Canada, October 18th - 22, 2004. pp 1-17
[7] Anand Ranganathan , Scott McFaddin , “Using Workflows to
Coordinate Web Services in Pervasive Computing Environments,”
Proc. of the IEEE International Conference on Web Services
(ICWS'04), June 6-9, 2004, San Diego, California, USA. IEEE
Computer Society 2004, 288-295
[8] zur Muehlen, Michael; Stohr, Edward A, “Internet-enabled
Workflow Management,” Editorial to the Special Issue of the Business
Process Management Journal 11 (2005)
[9] Schahram Dustdar, Harald Gall, Roman Schmidt, “Web Services
for Groupware in Distributed and Mobile Collaboration,” PDP 2004:
[10] Adel Ben Mnaouer, Anand Shekhar, Zhao Yi-Liang, “A Generic
Framework for Rapid Application Development of Mobile Web
Services with Dynamic Workflow Management,” IEEE SCC 2004:
165-171
[11] Steele, R. A “Web Services-based System for Ad-hoc Mobile
Application Integration,” In Proc. of IEEE Intl. Conf. on Information
Technology: Coding and Computing '03, 2003.
[12] Hawryszkiewycz, I., Steele, R. “Extending Collaboration to
Mobile Environments,” In the Proc. of the International Conference on
Web Technologies, Applications and Services, Calgary, Canada, July 46, 2005.
[13] Sushil K. Prasad and J. Balasoorya, 2005, “Fundamental
Capabilities of Web Coordination Bonds: Modeling Petri Nets and
Expressing Workflow and Communication Patterns over Web Services
,“ Proc. Hawaii Intl. Conf. in Syst. Sc. (HICSS-38), Jan., Big Island,
January 4-8.
[14] Janaka Balasooriya, Mohini Padye , Sushil Prasad, and Shamkant
B. Navathe “BondFlow: A System for Distributed Coordination of

9. Conclusions and Future Work
In this paper, we presented the decentralized workflow
coordination architecture of the BondFlow system. The concept of
the coordinator proxy object is central to our decentralized
architecture. A preliminary study of implementation prototype
shows that the bond related time is ~10% of the workflow
execution time. Also, the small footprint of coordinator proxy
object (~10KB) enables them to reside on java-enabled handheld
devices. In contrast to other systems such as Self-Serv, the idea of
the coordinator proxy object enhances each web service facilitating
more fine-grained decentralization of the coordination. Our goal is
to use this infrastructure to model and implement actual workflows
in typical biological and E-commerce applications.

th

Workflows over Web Services,” In 14 HCW in conjunction with
IPDPS’05. Denver, Colorado, USA, Apr 4.
[15] Boualem Benatallah, Marlon Dumas, Quan Z. Sheng,
“Facilitating the Rapid Development and Scalable Orchestration of
Composite Web Services,” Distributed and Parallel Databases 17(1):
5-37,2005.
[16] A. Barros, M. Dumas, and P. Oaks. “Standards for Web Service
Choreography and Orchestration: Status and Perspectives,” Proc, of
the Workshop on Web Services Choreography and Orchestration for
Business Process Management, Nancy, France, September 2005.
[17] Christoph Schuler, Rogr Weber, Heiko Schuldt, Hans-Jörg Schek,
“Scalable Peer-to-Peer Process Management - The OSIRIS Approach.”
ICWS 2004: 26-34
[18]Rosenberg, F., Dustdar, S. “Towards a Distributed ServiceOriented Business Rules System,” IEEE European Conference on Web
Services (ECOWS), 14-16 November 2005
[19] R. Schmidt. “Web services based execution of business rules.” In
Proc. of the Intl. Workshop on Rule Markup Languages for Business
Rules on the Semantic Web, 2002.
[20] M. Humphrey, G. Wasson, K. Jackson … etal. “State and Events
for Web Services: A Comparison of Five WS-Resource Framework
and WS-Notification Implementations.” 14th IEEE Intl. Symposium on
High Performance Distributed Computing (HPDC-14), Research
Triangle Park, NC, 24-27 July 2005
[21] K. Czajkowski., Ferguson, D., Foster, I …et al. The WS-Resource
Framework. http://www-106.ibm.com/developerworks /library/wsresource/ws-wsrf.pdf , 2004
[22] Jørstad, I., Dustdar, S., van Do, T. “Service-Oriented
Architectures and Mobile Services.” 3rd Intl. Workshop on Ubiquitous
Mobile Information and collaboration Systems (UMICS), co-located
with CAiSE 2005, 13 - 14 June 2005, Porto, Portugal.
[23] DEVS simulator, http://www.acims.arizona.edu/SOFTWARE

10. Bibliography
[1] Sushil K. Prasad, V. Madisetti, Shamkant B. Navathe, et al.
“System on Mobile Devices (SyD): A Middleware Testbed for
Collaborative Applications over Small Heterogeneous Devices and
Data Stores,” in Proc. ACM/IFIP/USENIX 5th International
Middleware Conference, Toronto, Ontario, Canada, October 18th - 22,
2004.
[2] Dipanjan Chakraborty, Anupam Joshi, Tim Finin, and Yelena
Yesha, “Service Composition for Mobile Environments,” Journal on
Mobile Networking and Applications, Special Issue on Mobile
Services, February, 2004
[3] In-Young Ko, Neches, R., “Composing Web Services for LargeScale Tasks,” Internet Computing, IEEE, Vol.7 No. 5, Sept.-Oct. 2003,
pp. 52 –59
[4]Indrakanti, S., Varadharajan, V. Hitchens, M,
“Authorization
Service for Web Services and its Application in a Health Care
Domain,” International Journal of Web Services Research, Vol. 2,
Issue 4, September 2005, pp. 94 – 119.
[5] Girish Chafle, Sunil Chandra, Vijay Mann and Mangala G. Nanda,
“Decentralized Orchestration of Composite Web Services,” In Proc. of
the Alternate Track on Web Services at the 13th International World
Wide Web Conference(WWW 2004), New York, NY, May 2004.

377

A Methodology for Engineering Collaborative Applications over Mobile Web
Objects using SyD Middleware
Sushil K.Prasad, Anu G. Bourgeois, Praveen Madiraju, Srilaxmi Malladi, and Janaka
Balasooriya
Department of Computer Science
Georgia State University
Atlanta, GA 30302
{sprasad, anu, cscpnmx, cscsrmx, cscjlbx}@cs.gsu.edu

Abstract
Future web applications will be more collaborative
and will use the standard and ubiquitous Internet
protocols. We have previously developed System on
Mobile Devices (SyD) middleware to rapidly develop
and
deploy
collaborative
applications
over
heterogeneous and possibly mobile devices hosting
web objects. In this paper, we present the software
engineering methodology for developing SyD-enabled
web applications and illustrate it through a case study
on a System of Calendar application, with
implementation on iPAQs and its performance metrics
study. SyD-enabled web objects allow us to create a
collaborative application rapidly with limited coding.
In this case study, the modular software architecture
allowed us to hide the inherent heterogeneity among
devices, data stores, and networks by presenting a
uniform and persistent object view of mobile calendar
objects interacting through XML/SOAP requests and
responses. The performance results we obtained show
that the application scales well as we increase the
group size and adapts well within the constraints of
mobile devices.
Keywords: Object and Web Service Coordination,
SyD Coordination Bonds, Mobile Web Objects,
Collaborative Applications

1. Introduction
Rapid development of collaborative distributed
applications by leveraging off existing web entities will
be key to bringing the Internet’s collaborative potential
to the users at large. Such collaborative applications
span domains as diverse as personal applications
(travel, calendaring and scheduling), enterprise ecommerce applications (supply chains, work flows,
and virtual organizations), and scientific biomedical

applications (biomedical data and process integration,
and experiment workflows).
The constituent
autonomous entities, the sub-applications, and the
coordinating applications themselves, are usually
hosted on heterogeneous and autonomous, possibly
mobile platforms [9]. There is an emerging need for a
comprehensive middleware technology to enable
development and deployment of these collaborative
distributed applications over a collection of mobile
(and wired) devices. This has been identified as one of
the key research challenges recently [4, 12]. Our work
is an ongoing effort to address this challenge, and in
[15], we reported the design of System on Mobile
Devices (SyD) middleware and its prototype
implementation1.
The current technology for the development of such
collaborative web applications over a set of wired or
wireless devices has several limitations. It requires
explicit and tedious programming on each kind of
device, both for data access and for inter-device and
inter-application communication.
A few existing
middlewares have addressed some of the requirements
of a comprehensive middleware [2, 6, 7, 8, 21]. For
example, Proem [8] is one such platform for
developing and deploying peer-to-peer (p2p)
collaborative applications in a mobile ad-hoc
networking environment. Commercial products such as
.NET compact framework [11] and J2ME are also
popular. In [1], authors describe issues related to
service composition in mobile environments and
evaluate criteria for judging protocols that enable such
composition. ISAM [21] supports mobile collaborative
applications using Java-based middleware. Yet another
group of services such as Chef [3], Global-MMCS
[20], and CAROUSEL [10] support collaboration
primarily among people, not applications.
The
limitations of existing middlewares include: only
1

http://www.cs.gsu.edu/~yes

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

client-side programming on mobile devices, a
restricted domain of applications, or limited in group or
transaction functionalities or mobility support, as
further elaborated in [15]. SyD supersedes the existing
technologies in terms of unique features such as
orientation on mobile-specific applications, enabling
servers on handhelds, heterogeneity of data/devices,
simple middleware API, etc. Only SyD supports a
normal database transaction model. We have a
methodology for any generic application development
and primitives to enforce constraints among web
objects.
Rapid Web Application Engineering: In this paper,
we describe SyD’s high-level programming
methodology to rapidly engineer group web
applications over a collection of heterogeneous,
autonomous, and possibly mobile data stores and subapplications. A key goal of SyD is to enable SyD
objects to coordinate in a distributed (and centralized)
fashion. Each SyD object is capable of embedding
SyD coordination bonds [5,15,16] (or ``Web bonds'' in
the context of web services [13, 14]) to other entities
enabling it to enforce dependencies and act as a
conduit for data and control flows (Section 2). The
methods provided by SyD enable developing
collaborative applications rapidly and easily.
We demonstrate this software engineering
methodology by showing how to develop and deploy a
personal system of calendars application. In this
distributed application, each user has his own database
that is stored locally or on a proxy. The application
logically bonds all members of a particular meeting
together. A meeting can be rescheduled in real-time for
all attendees by triggering the underling SyD bonds by
any one participant [16]. The performance results we
obtained for this application on iPAQs show that it
scales well as we increase group size and fits well
within the constraints of mobile devices.
SyD naturally extends to enabling collaborative
applications across web-based objects. The SyD
objects are stateful, web-based, and have interfaces like
web services for method invocations. Furthermore, all
method invocations and their responses in SyD employ
SOAP-like XML envelopes. Therefore, SyD objects,
their interactions, and the underlying techniques
discussed in this paper have a direct bearing on web
services and their compositions and coordination.
Section 2 briefly describes our background work on
SyD middleware and the logical design of calendar
application. Section 3 describes the generic SyD-based
software engineering methodology and illustrates its
steps through calendar application case study. It also
describes specific deployment details of calendar

application on iPAQs. Section 4 provides performance
metrics and Section 5 concludes our paper.

2. SyD Architecture and Coordination
Bonds - Background
In this section, we describe the design of System on
Mobile Devices (SyD) and related issues, as well as
highlight the important features of its architecture.
(Refer to [15] for more details.)

2.1. SyD Architecture Overview
SyD uses the simple yet powerful idea of separating
device management from management of groups of
users and/or data stores. The SyD framework has three
layers to accomplish this task. At the lowest layer,
individual data stores are represented by device objects
that encapsulate methods/operations for access, and
manipulation of this data (SyD Deviceware). At the
middle layer, there is SyD Groupware, a logically
coherent collection of services, APIs, and objects to
facilitate the execution of application programs. At the
highest level are the SyD Applications themselves.
They rely only on groupware and deviceware SyD
services, and are independent of device, data and
network. These applications include instantiations of
server objects that are aggregations of the device
objects and SyD middleware objects.
We have developed a prototype test bed of SyD
middleware that captures the essential features of
SyD's overall framework and several SyD-based web
applications. We have designed and implemented a
modular SyD kernel in Java as depicted in Figure 1.
The SyD Kernel includes the following five modules:
1.

2.

3.

SyDDirectory:
Provides
user/group/service
publishing, management, and lookup services to
SyD users and device objects. Also supports
intelligent proxy maintenance for users/devices.
SyDListener: Provides a uniform object view of
device services, and receives and responds to
clients’ synchronous or asynchronous XML-based
remote invocations of those services [15]. Also
allows SyD device objects to publish their services
locally to the listener and globally through the
directory service.
SyDEngine: Allows users/clients to invoke
individual or group services remotely via XMLbased messaging and aggregates responses. This
yields a basic composer of mobile web services.

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

Figure 1. Interaction among modules of SyD
Kernel [15]
4.

5.

SyDBond: Enables an application to create and
enforce interdependencies, constraints and
automatic updates among groups of SyD entities
and web Services [13, 16].
SyDEventHandler: Handles local and global
event registration, monitoring, and triggering.

2.2. SyD Coordination Bonds
A key goal of SyD is to enable SyD objects to
coordinate in a distributed fashion. Each SyD object is
capable of embedding SyD coordination bonds to other
entities enabling it to enforce dependencies and act as a
conduit for data and control flows. Over data store
objects, this provides active database like capabilities;
in general, aspect-oriented properties among various
objects are created and enforced dynamically. Its use in
rapid
configuration
of
ad-hoc
collaborative
applications, such as a set of calendars for a meeting
setup [16], or a set of inter-dependent web services in a
travel reservation application [5], has been
demonstrated. The SyD bonds have the modeling
capabilities of extended Petri nets and can be employed
as general-purpose artifacts for expressing the
benchmark workflow patterns [13, 14].
Coordination bonds enable applications to create
contracts
between
entities
and
enforce
interdependencies and constraints, and carry out atomic
transactions
spanning
over
a
group
of
entities/processes. While it is convenient to think of an
entity as a row, a column, a table, or a set of tables in a
data-store, the concept transcends these to any SyD
object or its component. There are two types of bonds:
subscription bonds and negotiation bonds. Subscription
bonds allow automatic flow of information from a
source entity to other entities that subscribe to it. This
can be employed for synchronization as well as more
complex changes, needing data or event flows.

Negotiation bonds enforce dependencies and
constraints across entities and trigger changes based on
constraint satisfaction.
A SyD bond is specified by its type
(subscription/negotiation), status (certain/tentative),
references to one or more web entities, triggers
associated with each reference (event-condition-action
rules), priority, constraint (and, or, xor), bond creation
and expiry time, and a waiting list of tentative bonds (a
priority queue). A tentative bond may become certain
if the awaited certain bond is destroyed.
Let an entity A be bonded to entities B and C, which
may in turn be bonded to other entities. A change in A
may trigger changes in B and C, or A can change only
if B and C can be successfully changed. In the
following, the phrase "Change X" is employed to refer
to an action on X (action usually is a particular method
invocation on SyD object X with specified set of
parameters); "Mark X" refers to an attempted change,
which triggers any associated bond without an actual
change on X.
• Subscription Bond: Mark A; If successful Change
A then Try: Change B, Change C. A ``try" may not
succeed.
• Negotiation-and Bond: Change A only if B and C
can be successfully changed.
Using SyD bonds, we demonstrate here how an
empty time slot is found, how a meeting is setup
(tentative and confirmed), and how voluntary and
involuntary changes are automatically handled [16]. A
simple scenario is as follows: A wants to call a meeting
involving B, C, D and himself. After the empty slots in
everybody's calendar found, a “negotiation-and bond”
is created from A's slot to the specific slot in each
calendar table shown as solid lines (Figure 2).
Choosing the desired slot attempts to write and reserve
that slot in A's calendar, triggering the negotiation-and
bond. The `action' of this bond is to:
i) Query each table for this desired slot, ensure that it is
not reserved, and reserve this slot.
ii) If all succeed, then each corresponding slot at A, B,
C and D create a negotiation bond back to A's slot.
Else, for those individuals who could not be
reserved, a tentative bond back to A is queued up at the
corresponding slots to be triggered whenever the status
of the slot changes. Assume that C could not be
reserved. Thus, C would have a tentative bond back to
A, and others have subscription bond to A. Whenever C
becomes available, if the tentative bond back to A is of
highest priority, it will get triggered, informing A of
C's availability, and will attempt to change A's slot to
be reserved. This triggers the negotiation-and bond
from A to A, B, C and D, resulting in another round of
negotiation. If all succeed, then corresponding slots are

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

reserved, and the target slots at A, B, C and D create
negotiation bonds back to A's slot (Figure 2). Thus, a
tentative meeting would be converted to permanent.
Now suppose D wants to change the schedule for this
meeting. This would trigger its back bond to A,
triggering the forward negotiation-and bond from A to
A, B, C and D. If all succeed, then a new duration is
reserved at each calendar with all forward and back
bond established. If not all can agree, then D would be
unable to change the meeting.

way of collaboration with heterogeneous peer devices
and also provide a way to enforce dependencies. SyD
bonds provide methodologies to enforce data and
control dependencies in such application scenarios.
The challenge is to associate SyD bonds in an early
stage of application design for its effective use. In fact,
one can follow standard UML design methods to
design applications [19] and then insert bond artifacts
at appropriate design phases as required. We will
explain the design process of a collaborative
application [17] with SyD middleware and SyD bonds
at hand based on UML for distributed objects to model
collaborative applications.

Figure 2. A scheduled meeting [16]

3. Designing Collaborative Applications
Collaborative SyD Applications: Collaborative group
applications leverage off multiple constituent web
entities, where each of those entities is a server
application/component or an object or a data store. A
centralized coordinator application resides on one host
and composes or configures multiple SyD objects
(which are themselves typically distributed).
Composition is by invocation of method calls of
constituent objects. Configuration employs the SyD
coordination bonds to establish flow and dependency
structure between the coordinator application and the
constituent objects. A distributed coordinator
application primarily employs SyD bonds among
constituent SyD objects and thus is co-hosted
distributively alongside them. The calendar of
meetings application illustrates a distributed
coordinator application.

3.1. Generic Design Methodology
SyD middleware provides components to aid easy
development of collaborative applications which span
from centralized to pure distributed. Collaborative
applications interact with each other and in the process
come across data dependencies or control
dependencies or both depending on the nature of
application. The SyD components provide an effective

Figure 3. Generic collaborative application
design process
The steps for designing distributed applications
using the concepts of SyD are as follows (Figure 3):
Step 1: A requirement specification is given by the
user of the application system describing the way the
system is expected to work.
Step 2: A requirement analysis is carried out to
identify actors and use cases. An actor is an external
entity (person, another system or object), which uses
the system. Use cases are either text descriptions or
flow descriptions of how actors interact with the
system in all scenarios encountered in the applications.
From use cases and actors, use case diagrams are
drawn. Use case model diagrams show interaction
between actors and all use cases.

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

Step 3: Activity diagrams are developed based on use
case diagrams, use cases and actors. UML activity
diagrams are equivalent to flow charts and data flow
diagrams in object-oriented paradigm. In activity
diagrams, the data flow spans across use cases and
allows one to identify data and method interdependency of the use cases at an abstract level. These
data and control dependencies can be analyzed and
modeled using SyD bonds.
Step 4: Next step is the identification of classes and
class diagrams. Class diagrams represent the static
behavior of the system. Class diagrams describe the
types of objects in a system and their relationships.
Class diagrams model class structure and contents
using design elements such as classes, packages and
object. The methods that have a data resource object as
an attribute might be “SyD-bondable” methods as it is
likely to enforce interdependency. The persistence or
non-persistent data objects with dependencies can be
modeled using SyD methods to automate any method
invocation needed for the application. Dynamic
behavior of the system is modeled using sequence
diagrams and collaboration diagrams. Both these
diagrams help to identify inter-service dependencies at
method level where we can apply SyD bonds to
enforce them. Such design can further be clarified
using communication diagrams that show the message
flow between objects.
Once all the objects, data, data dependencies, and
control dependencies have been identified and modeled
using SyD and other components, implementation can
begin. Server logic can be coded starting from SyDlistener skeleton which is middleware specific. Client
coding can be started using SyDBond, SyDEngine,
SyDDoc directory logic which is application specific.
Figure 3 shows our collaborative application design
process.

3.2. Designing Calendar Application – Case
Study
Here, we illustrate the design process of a distributed
calendar application. We will limit the discussion to
particular scenarios in the system wherever
appropriate.
Step 1: The requirements specification details the
view of user and addresses the aspects of the benefits
of the new system, interaction with other systems and
system functionality. Based on the specification,
several different use cases are identified for calendar
application. The use cases of interest are: get available
times, setup meeting, cancel meeting, view calendar,
reschedule meeting, create bond, and delete bond.

Step 2: For the cancel meeting, the text description
of use cases is given in Table 1. This can be
represented in a pictorial view as use case diagram.
The interaction between the actors and all use cases of
the system can be given in a use case model diagram.
Table 1: CANCEL_MEETING Use Case
CANCEL_MEETING
Use Case
Participating
Actors
Entry
Condition

Application, Initiator, System

Flow
Events

2.
3.
4.

6.

7.
Exit
Condition

8.

Cancel meeting option is
selected by the Initiator or is
invoked by system.
System
invokes
CANCEL_MEETING
Confirmation
of
cancel
meeting sent to all attendees.
System checks for any
associations waiting on the
initiator.
All the associations waiting up
on are now converted to
confirmed status.
All the associations are
informed of the change.
Return to main menu.

Step 3: The activity diagram for cancel meeting
follows these steps. For the calendar application, the
method call for cancel meeting checks for any
dependencies associated in its execution. The presence
of confirmed dependencies will result in its successful
execution. However, in case of tentative dependencies,
a reschedule is triggered resulting in an automatic
execution of the scenario “conversion of status”, in
case of no conflicts. These method dependencies
indicate place holders for SyD methods [13, 14].
Step4: The methods cancel meeting (attendeelist,
starttime,endtime), reschedule(attendeelist, starttime,
endtime), confirm meeting(attendeelist, starttime,
endtime), etc., executed in a calendar application result
in the update of dependent data objects. These data
dependencies indicate place-holders for SyD Bonds.

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

of

1.

3.3 Case Study Implementation Details
The design of the calendar application has been
implemented on HP iPAQ H3600 and H3700 series
running windows CE operating system. Here, we
describe implementation details providing insights into
the development process. These details logistics and
device-level details should help developers of similar
applications for mobile devices.
Step 1: We implemented SyD Middleware (as a java
package) and Calendar code using java JDK 1.3. The
system user interface was designed using JAVA
Applets. We used Oracle8i as the back end database
for storing SyD bond and application specific tables.
All were implemented on a PC. Calendar application
code interfaces with SyD Middleware application code
for executing method calls (SyDEngine), listening for
incoming method calls (SyDListener), and making
directory service calls (SyDDirectory).
Step 2: We installed JVM for iPAQ, Jeode EVM
Version 1.9. We ported the SyD Middleware code and
calendar application code on the iPAQ using Microsoft
ActiveSync version 3.5 [18] and set the classpath
appropriately.
Step 3: After downloading the SyD Middleware, we
installed and ran the middleware components on the
iPAQ. This involves: (i) running a directory server
(Oracle server) on a PC connected via a wireless
network with the base iPAQ and (ii) running
listener.lnk file (located in /syd/sydlistener path),
which continuously listens for incoming method calls.
Step 4: We then installed the calendar application
code itself. To do this, we executed the
CalRegistrar.lnk file, which registers the application
with SyDDirectory, followed by the application GUI to
implement the various scenarios (set up meeting,
cancel meeting and reschedule meeting).

4. Experiments and Performance Metrics
Here, we report experiments and performance
metrics we obtained on the calendar application.

4.1. Experimental Hardware/Software Setup
We ran our experiments on a high performance/low
power SA-1110 (206 MHz) Compaq iPAQ H 3600 and
3700 series, with 32 MB of SD RAM and 32MB of
Flash ROM. We had three 3600 series and seven 3700
series iPAQ running middleware and calendar
applications connected through a wireless network
using a 2.4GHz wireless router. The operating system
was Windows CE. We used JDK version 1.3 to code
our programs and JVM for iPAQ was Jeode EVM

Version 1.9. The DBMS of the directory server was
Oracle 8i.
In Section 3 we have shown that SyD middleware
enables structured, streamlined and rapid application
development on mobile devices backed with
theoretical and proven case study implementations of
the calendar application. However, in a mobile setting,
it is also significant that the applications developed
scale well in terms of bandwidth, memory storage and
response time parameters, as these resources are scarce
for mobile devices. The motivations for considering
aforementioned parameters are as follows: 1) Mobile
devices cannot afford large amounts of message
transfers, as the network bandwidth is limited; hence,
we measured message size transferred. 2) Storage size
on iPAQ is scarce and larger storage size for
applications is not desired; hence, we measured storage
requirements; 3) Response time for executing method
calls on mobile devices is critical, as higher response
times are possible when applications (a) consume more
storage space, (b) transfer larger message sizes, and (c)
require higher memory; hence we measured response
time. We carried out experiments on calendar
application for three scenarios: set up meeting, cancel
meeting, and reschedule meeting. Our experiment
results have been encouraging, as the application has
shown to scale well in terms of all the parameters.

4.2. Setup Meeting Scenario
A constant message size of 50 bytes is transferred
for each participant in a meeting consisting of meeting
details. The storage size for group sizes of 2, 3, and 4
are: 120, 146, and 170 bytes respectively. For group
sizes of more than 3, the storage size does not increase
linearly as we associated a meeting id for each
meeting, which avoids repetitive information such as
start times, end times and comments.
Response time: Response time is the time required
to execute set up meeting method call. A set up
meeting method call includes time required to execute
a get available time method returning the available
times of all the participants, time required to execute
the set up meeting for all involved meeting
participants, and time to write the meeting details of all
the participants to a file. It should also be noted that
any method call must go through SyD middleware
components. More specifically, it includes time
required for (i) SyDEngine to contact SyDDirectory to
get other user url information, (ii) SyDDoc to create a
request document, and (iii) SyDEngine to invoke
SyDListener remotely and get back the results.

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

Cancel meeting

Set Up Meeting (Component Chart)
Engine to Directory(round trip)
Engine to Remote Listener

7000
6000
5000
4000
3000
2000
1000
0
2

3

4

5

6

7

8

9

10

Group size

Response time (msec)

Response time (msec)

Set up meeting
Reschedule meeting

Create SyDDoc
Server Processing

6000
5000
4000
3000
2000
1000
0
2

3

In Figure 4, we show the response time for all three
scenarios based on varying number of group sizes. We
observe that response time scales well (does not
increase rapidly) for increasing group size through
parallelism in processing and this behavior can be
explained by analyzing different middleware
component timings that make up response time as can
be seen from Figure 5. The different components and
their timing analysis are given below:
The “Engine to Directory Service” takes around 4760 msec for group sizes of 2-10, which is less than 1%
of total time. The “Create SyDDoc” value ranges from
13-90 msec for group sizes of 2-10, which is again less
than 1% of response time. Now, we go in details on the
components that make up a large share of the total
response time.
Engine to Remote Listener: SyDEngine invokes
remote listener for executing method call on remote
devices by using the request document generated from
the above step. This involves sending the request
document to the remote listener, parsing the request
document at the remote listener end, invoking the
method call on the remote listener and writing the
meeting details of each individual participant to a file.
For increased group sizes, we achieve some
concurrency as multiple remote listener calls are made
to participant devices and results are collected. This
value ranges from 1725-2900 msec for group sizes of
2-10 (takes around 48% of total time).
Server Processing: This refers to all other
miscellaneous processing times such as, opening,
writing and closing of file at initiator side,
initializations
for
middleware
components
(SyDEngine, client side RMI registry components of
directory server), and different application specific
objects such as vectors. Here, we achieve concurrency
for increased group sizes. This value ranges from
1995-2100 msec for group sizes of 2-10 (takes around
50 % of total time).

5

6

7

8

9

10

Figure 5: Set up meeting response time for
components
Other Meeting Scenarios: In a reschedule meeting
scenario, from the initiator point of view, size of
message transferred is the message size transferred to
convey the information that meeting has been
cancelled to the other participants, and another
message to send a confirmation of the meeting set up
that has been tentative so far. The initiator does not
have to wait on any acknowledgements in either case
as one corresponds to cancel and for the tentative
meeting the timings have been already agreed as
tentative. We assume that only an initiator can cancel
the meeting as he alone knows all the participant
details and the tentative meeting participant details.
This yields in a very small amount of data to be
transferred, two messages containing initiator name,
start time, end time and date (around 20 bytes each).
Similarly, cancel meeting takes also takes around 20
bytes of data transfer.

5. Conclusions
We have described the high-level programming and
deployment methodology of
System on Mobile
Devices (SyD) middleware which is the first working
middleware prototype supporting an efficient
collaborative application development environment for
deployment on a collection of mobile devices. One of
the main advantages of SyD is a modular architecture
that hides inherent heterogeneity among devices, data
stores, and networks by presenting a uniform and
persistent object view of mobile server applications
and data-stores interacting through XML/SOAP
requests and responses.
The paper has demonstrated the systematic and
streamlined application development and deployment
capability of SyD for collaborative applications
composed over mobile web objects. We detailed this
process for the design of a system of calendars, a

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

4

Group size

Figure 4: Response time for three scenarios

representative application. We also presented
implementation details and performance metrics for
this particular application. Specifically, we measured
the bandwidth required, the storage requirements, and
the response timings. The results we obtained show
that the application scales well as we increase the
group size and fits well within the framework of
mobile devices. Therefore, SyD objects, their
interactions, and the underlying techniques discussed
in this paper provide a direct benefit to web services
and their compositions and coordination.

6. References
[1] D. Chakraborty, A. Joshi, T. Finin, and Y. Yesha.
"Service Composition for Mobile Environments", J. on
Mobile Networking and Applications, Feb., 2004.
[2] Gianpaolo Cugola, Gian Pietro Picco. "Peer-to-Peer for
Collaborative Applications", 22nd Intl. Conf. on Distributed
Computing Systems Workshops (ICDCSW), July, 2002.
[3] Chef (2004). Chef Project Website available from
http://www.chefproject.org/index.htm
[4] W. Keith Edwards, Mark W. Newman, Jana Sedivy,
Trevor Smith, Shahram Izadi, "Recombinant computing and
Speakeasy Approach," in Proceedings of MobiCom 2002,
Atlanta, GA. USA, September 23-28, pp. 279-286.
[5] Aarthi Hariharan, Sushil K. Prasad, et al. “A Framework
for
Constraint-Based
Collaborative
Web
Service
Applications and a Travel Application Case Study”, Proc.
Intl.. Symp. on Web Services and Applns., Nevada, 2004.
[6] E. Kirda, P. Fenkam, G. Reif, and H. Gall. "A service
architecture for mobile teamwork", Intl. Conf. on Software
engineering and knowledge engineering, Ischia, Italy,2002.
[7] Allan Meng Krebs, Mihail F. Ionescu, Bogdan
Dorohonceanu, Ivan Marsic: The DISCIPLE System for
Collaboration over the Heterogeneous Web. HICSS 2003.
[8] Gerd Kortuem. Proem: A Middleware Platform for
Mobile Peer-to-Peer Computing. ACM SIGMOBILE Mobile
Computing and Communications Review (MC2R), Vol. 6,
No 4, October 2002.

[11] Craig Neable."The .NET Compact Framework", IEEE
Pervasive Computing Magazine, October-December 2002.
[12] Thomas Phan, Lloyd Huang, Chirs Dulan , "Integrating
Mobile Wireless Devices Into the Computational Grid", in
Proc. of MobiCom , Atlanta, September 2002.
[13] Sushil K. Prasad and Janaka Balasoorya, “Web
Coordination Bonds: A Simple Enhancement to Web
Services Infrastructure for Effective Collaboration”, Proc.
37th HICSS, 2004.
[14] Sushil K. Prasad and J. Balasooriya, "Fundamental
Capabilities of Web Coordination Bonds: Modeling Petri
Nets and Expressing Workflow and Communication Patterns
over Web Services", 38th HICSS, 2005.
[15] Sushil K. Prasad, V. Madisetti, S. Navathe, et al.
"System on Mobile Devices (SyD): A Middleware Testbed
for collaborative Applications over Small Heterogeneous
Devices and Data Stores”, Proc. ACM/IFIP/USENIX 5th
International Middleware Conference, Toronto, Oct. 2004.
[16] Sushil K. Prasad, Anu Bourgeois, et al. "Implementation
of a Calendar Application Based on SyD Coordination
Links," Proc. 3rd Intl. Workshop Internet Computing and ECommerce in conjunction with IPDPS, April, 2003.
[17] R.S. Pressman, Software engineering: A practitioner's
approach, 4th ed., New York: McGraw-Hill, 1997.
[18] Microsoft ActiveSync Version.
www.microsoft.com/windowsmobile/downloads/pocketpc.mspx

[19] Martin Fowler, Kendall Scott, UML Distilled: A Brief
Guide to the Standard Object Modeling Language (2nd
Edition), Addison - Wisley publication
[20] Wenjun Wu, Ahmet Uyar, Hasan Bulut, Geoffrey Fox.
Integration of SIP VoIP and Messaging Systems with
AccessGrid and H.323, ICWS 2003.
[21] Adenauer Yamin, et al. "Collaborative Multilevel
Adaptation in Distributed Mobile Applications", XII
International Conference of the Chilean Computer Science
Society (SCCC'02), November 2002.

[9] Oliver Krone, Fabrice Chantemargue, Thierry Dagaeff,
Michael Schumacher, Béat Hirsbrunner, "Coordinating
autonomous entities," The Applied Computing Review,
Special issue on Coordination Models Languages and
Applications (SAC),1998.
[10] S. Lee, S. Ko, G. Fox, K. Kim, S. Oh. “A Web Service
Approach to Universal Accessibility in Collaboration
Services”, ICWS03, Las Vegas.

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

2010 IEEE 3rd International Conference on Cloud Computing

Cloud Computing Infrastructure for Biological Echo-Systems
Janaka Balasooriya
School of Computing, Informatics, and Decision Systems Eng.
Arizona State University,Tempe, AZ
janakab@asu.edu

1. Introduction
The Biological applications such as Gene and Protein
analysis integrate and analyze biological data for the
research in many bioinformatics and other bio related
fields. Such applications are used under many large scale
scientific applications and help in computing, integrating
data, execute the analysis, automate the process by using
information retrieved by different tasks and computational
procedures to assist the scientists in scientific discovery
and data distribution. Grid based and/or web based
scientific workflow tools are used for bioinformatics
related complex research to make scientists’ and
researchers’ work easier. On average, scientists spend
about 80% of their time assembling data to prepare for
analysis. This is due largely in part to the fact that many of
these resources required for data processing must be
gathered from an external source. The best of these
resources, however, are scattered across the globe. They
are hosted at universities, institutes, and laboratories
throughout the world. To bring all of these resources
together by hiding system, network, and application level
heterogeneity issues are challenging.

(a) Tools and data sources need to have uniform
interfaces for communication and data exchange.
(b) Data sources and tool providers need a platform to
which they can announce the availability of resources.
(c) Natural scientists should be able to find required data
sources and tools, and configure their applications
using high-level constructs.
(d) Find resources (such as computing, data storage) to
run their applications (if needed) and execute
applications.
(e) Should be able to perform above tasks over the Web
with no or minimum programming.

Tools

1.1 Challenges and Biological Data and Tool
Integration
Our recent comprehensive survey on this topic revealed
that biological data and tool integration is a challenging
task mainly due to
• Highly diverse data sets (numerical, natural language,
strings) and representational heterogeneity of data
(text files, data bases)
• Data sets to be analyzed can be large.
• Distributed across the globe.
• Available tools and data sources have non uniform
interfaces for communication and data exchange.
– Data sources and tools are autonomous and
have different interfaces and querying
capabilities.
• Some applications require large amount of computing
resources and can be long running.

Data

Figure 1: On-the-Fly data and tool integration in a Cloud
based Bio-Ecosystem
2. Biological Data and Tool Integration in the Cloud
2.1 Cloud Capabilities:
Cloud computing architecture provides an ideal platform
to realize our vision. Even though there is no clear
definition of Cloud computing, a good understanding of
what Cloud computing can offer is prevalent. According
to [2], Cloud computing can be seen as a “pool of easily
usable and accessible resources (hardware and software).
These resources can be dynamically re-configured. This
pool of resources is typically exploited by a pay-per-use
model.” This nicely fits into our vision and the goals
presented in section 1.1. In the Cloud, resources are
presented as services to its uses. In general, Cloud
provides three different types of services (Figure 2). Each
type of service can be provided separately and pay-per use
model if needed.

1.2. Our Vision and Goals
We envision biologists and natural scientists to find
required tools and data sources and configure then “onthe-fly” over the web (Figure 1). This requires breaking
several technological barriers.
978-0-7695-4130-3/10 $26.00 © 2010 IEEE
DOI 10.1109/CLOUD.2010.80

Computing Resources

526

Third Party Partner Dashboard: Some core infrastructure
provides may associate their resources with some third
party components such as generic input validation. Such
Third party components can be added to the ecosystem
through this interface.
Web Service Interface: Present reusable components as
web Services
Virtualization of hardware and software: Maintain
Hardware and software resources availability in dynamic,
on-demand manner.
Bio-Ecosystem Management: For tool, data source, and
other resource providers, partners, and end users to
manage their components in the echo-system.
Figure 2: Cloud Computing Resources
As explained in Section 1, Requirements for biological
computing applications can be varied from needing all
three of the above types of services to perhaps only one
type of resource. Thus, we can visualize biological data
sources and tool live in an echo-system where biologists
find required data sources and tool and integrate them as
required. The following section presents our BioEcosystem architecture on the Cloud.
2.2 Bio-Ecosystem Architecture on the Cloud
In [1], authors present a Cloud Computing Open
Architecture (CCOA). Our Bio-Ecosystem architecture is
based on CCOA. Figure 3 illustrates our Bio-Ecosystem
architecture. Usually, biological applications involve four
types of resources: data sources, tools (software
packages), application development platforms, and
computing resources. In this architecture
• Biological data sources and tools can be implemented
as software as a services in the cloud
• Application development platforms can be
implemented as platforms as a service in the cloud
• Data storage, network, and hardware requirements
such as processing can be implemented as
Infrastructure as a service in the cloud.

Figure 3: Bio-Ecosystem Architecture on the Cloud [1].
5. Conclusions and Future Work
On average, about 80% of the invested time goes into
assembling the right data to prepare for analysis and
gathering resources for data processing from various
resources due its diverse nature. Cloud computing
provides an ideal platform on which one can develop an
environment that allows biologists and natural scientists to
find required tools and data sources and configure then
“on-the-fly” over the web. In this paper we have proposed
a Bio-Ecosystem Architecture on the Cloud. Currently, we
have undertaken the task of designing and developing
each component of this architecture.

Here, we briefly explain each component of the BioEcosystem architecture
User Interface Dashboard: End users (biologists) interact
with the ecosystem through this interface to discover,
compose, and execute their applications on-the-fly.

6. References
[1] Liang-Jie Zhang; Qun Zhou. CCOA: Cloud Computing Open
Architecture. ICWS 2009. IEEE International Conference on.

Core Infrastructure Provide Dashboard: Tools, data
sources, and network and computing resource providers
make their resources available to the bio-ecosystem
through this interface possibly in a plus and play manner.

[2] Luis M. Vaquero , Luis Rodero-Merino , Juan Caceres , Maik
Lindner, A break in the clouds: towards a cloud definition, ACM
SIGCOMM Computer Communication Review, v.39 n.1, January 2009

527

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

Fundamental Capabilities of Web Coordination Bonds: Modeling Petri Nets and
Expressing Workflow and Communication Patterns over Web Services
Sushil K. Prasad and Janaka Balasooriya
Computer Science Department
Georgia State University
Atlanta, GA 30303
sprasad@gsu.edu
Abstract
Developing collaborative applications over the Web
has become increasingly important. In order to
accomplish this, Web services need to be extended beyond
the basic service architecture (invoke and respond) to
self-coordinating Web processes collaborating among
themselves (transient to long lasting). A core set of
artifacts is needed to allow these Web processes to hook
together in a desired structure to enforce automatic
information flow, group constraints, and data/control
dependencies. We have proposed Web Coordination
Bonds as such a set of artifacts with the required
theoretical underpinning for effective collaboration
among Web services. Here, we establish that Web bonds
are at least as powerful as the extended Petri nets
(modeling power). We demonstrate their expressiveness
by modeling a comprehensive set of benchmark workflow
scenarios and distributed communication patterns. Such
fundamental treatments are unique, and are essential for
further progress in the technology for distributed software
over Internet.

1. Introduction
Web Services (WSs) are increasingly promising to
become the building blocks out of which new distributed
applications are created over Internet. Such applications
span domains as diverse as enterprise e-commerce
applications (supply chains, workflows, and virtual
organizations), personal applications (travel, calendaring,
and scheduling), and scientific biomedical applications
(biomedical data and process integration, and workflows).
Many applications are long running (workflows,
transactions) and require much more beyond just
invoke/response
protocols.
Therefore,
efficient
technologies are required to rapidly develop and deploy
robust collaborative applications leveraging the existing
Web services. Currently, there are many languages and
standards for Web services composition [6]. However, as
things stand today, these languages propose different
techniques to perform WS composition and there is no
fundamental,
theoretically
sound,
WS
composition/choreography framework [3, 25]. Such a

fundamental framework should have enough expressive
power to model complex processes, clearly defined
semantics [3] to avoid ambiguity, and enough analytical
power to learn about and verify the correctness [27].
In [25], we have proposed preliminary ideas on Web
coordination bonds as one such set of core artifacts for
Web Service coordination/choreography. Web bonds have
been born out of our experience with developing several
collaborative peer-to-peer distributed Web applications
using our System on Mobile Devices (SyD) middleware
[23, 24]. A good analogy would be the molecular bonds in
chemical compounds, which are simple yet extremely
powerful to enable all sorts of basic and complex
chemical compounds to exist naturally and to be
manufactured artificially. Different atoms expose sites
with certain number of either excess or shortage of
electrons. For example, an oxygen atom has two
negatively charged sites, and hydrogen has a deficit of
one electron, giving it a positively charged site. To form a
water molecule, therefore, two hydrogen atoms bond with
an oxygen atom - each bond is just a sharing of an
electron between a donor and a recipient site. The Web
Services are simple or composite server objects situated
on the Web with well-defined interfaces and are the “Web
atoms.” Molecules are, therefore, analogous to all
collaborating processes involving individual Web Service
components. The list of such “Web molecules” spans
transient to long running collaborative processes transactions,
client-server
and
p2p
distributed
applications, workflows as well as virtual organizations.
Taking the analogy further, the challenge is to (i) define
the analogous “bonding sites” or simple “Web hooks” in
the Web Service interface needed to mesh multiple Web
entities together, and (ii) develop the analogous concept
of a few simple yet powerful types of “Web bonds”
which would be the coordination threads to bind and
produce the “Web molecules” out of multiple “Web
atoms.” These “Web bond” artifacts should allow rapid
modeling and deployment of collaborative applications of
all kinds and complexities (Fig. 1). Section 2 defines Web
bonds and operations over Web bonds.
Contributions: The key contributions of this paper
are (i) to prove that Web bond can model extended Petri

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

1

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

nets, and thus, are fundamentally capable formal artifacts,
and (ii) to demonstrate that Web bonds can express all the
Web
Bonds
Billing

Billing
Delivery

Order

Internet

Order

Delivery

Internet

Pickup

Pickup

Fig. 1. Package pickup and delivery workflow
over Web services using Web bonds
benchmark patterns for workflow and for inter-process
communication; a feat that almost all previously proposed
artifacts and languages are not capable of
comprehensively, thus proving that Web bonds are
superior despite their simplicity.
Modeling power [28] and expressive power [16] are
closely related terms. However, the subtle difference
between two terms is that the former indicates the ability
to design or model coordination (interaction) patterns
whereas the latter denotes how efficiently and easily such
patters can be modeled. In other words, modeling power
can be regarded as the theoretical limit, whereas
expressive power can be regarded as the practical limit.
Thus, it is important to assess both the modeling power
and the expressive power to evaluate capabilities of Web
bonds. Section 3 presents the formal definition of Web
bonds and establishes that Web bonds are at least as
powerful as the extended Petri net with inhibitor arcs in
terms of modeling power. Section 4 demonstrates their
expressive power by modeling a comprehensive set of
benchmark workflow scenarios and distributed
communication patterns.
Section 5 briefly discusses some relevant literature
and Section 6 contains our conclusions and future
research directions.
Note: We use terms such as
“coordination,”
“collaboration,” and “choreography” interchangeably.
The associated applications encompass all distributed
Web applications wherein multiple constituent entities
need to coordinate.

2. Coordination Bond Concepts
Web bonds enable applications to create contracts
between entities and enforce interdependencies and
constraints, and carry out atomic transactions spanning
over a group of Web entities/processes. While it is
convenient to think of an entity as a row, a column, a
table, or a set of tables in a data-store, the concept
transcends these to any object or software component, and

here we specifically consider Web Services. There are
two types of Web bonds: subscription bonds and
negotiation bonds. Subscription bonds allow automatic
flow of information and control from a source entity to
other entities that subscribe to it. This can be employed
for synchronization as well as more complex changes,
needing data or event flows. Negotiation bonds enforce
dependencies and constraints across entities, and trigger
changes based on constraint satisfaction.
A Web bond is specified by its type
(subscription/negotiation), references to one or more Web
entities, triggers associated with each reference (eventcondition-action rules [21]), a priority, a constraint (AND,
OR, XOR), a bond creation expiry time [24, 25]. Let an
entity A be bonded to entities B and C, which may in turn
be bonded to other entities. A change in A may trigger
changes in B and C, or A can change only if B and C can
be successfully changed. In the following, the phrase
"Change X" is employed to refer to an action on X (action
usually is a particular method invocation on Web Service
X with specified set of parameters); "Mark X" refers to an
attempted change, which triggers any associated bond
without an actual change on X.
Subscription Bond: Mark A; If successful, Change A then
Try: Change B, Change C. A ``try" may not succeed.
Negotiation-and Bond: Change A only if B and C can be
successfully changed. (Implements atomic transaction
with "and" logic).
Semantics (may not be implemented this way):
Mark A for change and Lock A
If successful
Mark B and C for change and Lock B and C
If successful
Change A
Change B and C
Unlock B and C
Unlock A
Similar semantics can be defined for Negotiation-or and
“xor” bonds [25, 24]. Likewise, these logical primitives
are available for subscription bonds. The “and” logic is
the default constraint, if unspecified. Formal treatment of
Web bonds and their firing rules are in Section 3. Note
that locks are only for the explanation of the semantics. A
reservation/locking mechanism to implement this usually
will have an expiry time to obviate deadlocks. In a
database, this would usually indicate a “ready to commit"
stage.

2.1 Notations for Web Bonds
A subscription bond from A to B is denoted as a
dashed directed arrow from A to B. A negotiation bond
from A to B is denoted as a solid directed arrow from A to

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

2

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

B. A negotiation bond from A to B and C is denoted by
two solid arrows, one each to B and C. AND logic is
represented with a "*" in between the arrows. Similarly,
OR and XOR are represented, respectively with a "+" and
"^" in between the arrows.
As shown in Fig. 2, if there is a subscription bond
from activity A to activity B, it implies that once A
completes its execution (or, completes some functionality
indicated by the subscription bond), B will be notified
with suitable control and data as specified by the
subscription bond.

subscription bond serves notice to “Dispatch_Goods( )”
method. Note that the Web bonds are useful within a
Web process as well. Again, before “Dispatch_Goods( )”
executes, it needs to ensure that consumers
“Accept_Delivery()” method can be completed
successfully (ensuring that enough space is available, for
example). This condition is enforced by the second
negotiation bond.

Producer Web
Process
A

B

Consumer Web
Process

B

A

Place _Order ( )

Accept_Order ( )

Fig. 2. Subscription
bond

Fig. 3. Negotiation
bond

Negotiation bonds enforce dependencies and constraints
across entities and trigger changes based on constraint
satisfaction. If there is a negotiation bond from activity B
to activity A (Fig. 3), it has two interpretations: pre
execution and post execution. In case of pre-execution, in
order to start activity B, A needs to complete its execution.
In case of post-execution, in order to start activity B, B
needs to make sure that A can be completed afterwards. In
this paper, we have primarily employed the pre-execution
type of negotiation bonds implicitly.
Methods of activities can be bonded using both types
of bonds simultaneously. This special case is denoted as
subscription-negotiation bond pair (Fig. 4).
A

B

Fig. 4: Subscription-negotiation bond pair
Subscription-negotiation bond pair enforces the following
condition. In order to execute B, the activity A must be
completed, and in addition, A can inform B of its
execution by sending control and/or data to B.

2.2 Producer-Consumer Dependencies
Fig. 5 shows how a classic relationship of producer
and consumer Web processes can be bonded using two
negotiation bonds. The “Place_Order( )” method at a
consumer process needs to ensure that the producer has
enough inventories such that the corresponding
“Accept_Order( )” method will get executed successfully.
Before guaranteeing this, the “Accept_Order( )” probably
will check the current and projected inventory. A
negotiation bond is created from consumer Web process
to producer Web process. This is the basic situation for
deploying a negotiation bond. Once order has been placed
by the consumer and accepted by the producer, a

Subscription
Bond (SB)

Negotiation
Bond (NB)

NB
Dispatch_Goods ( )

Accept_Delivery ( )

Fig. 5. Coordinating Producer-Consumer Web
processes

3. Modeling Power of Web Bonds
In this section, we establish that Web bonds have the
modeling power of extended Petri nets (A Petri net with
inhibitor arcs is called an extended Petri net [1] ). This is
important because extended Petri net is the most powerful
among different Petri net models and is equivalent to
Turing machine [29]. We prove this by simulating the
transitions that an extended Petri net can carry out by
employing a network of Web bonds.

Definition: Extended Petri net (PNE)
A PNE is defined as a four tuple (T, P, A, f) [2], where,
T = {t1, t2, …, tn} is a finite set of transitions,
P = {p1, p2,, pm} is a finite set of places,
A = {T×P} ∪ {P×T} is a finite set of directed arcs such
that
(pi, tj) ∈ A => (tj, pi) ∉ A,
(tj, pi) ∈ A => (pi, tj) ∉ A, and
f: A-> {True, False} indicates if an arc is a normal arc or
an inhibitor arc.
Two sets Ii′, Ii′′ are defined as follows for a given
transition ti:
Ii′= {j | (pj, ti) ∈ A and f(pj, ti) = T}, is the set of normal
arcs from places to transition ti.
Ii′′= {j | (pj, ti) ∈ A and f(pj, ti) = F}, is the set of
inhibitor arcs to transition ti

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

3

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

Transition firing rule:
A transition ti is enabled if for each arc (pj, ti) ∈ A, pj >0
for all j ∈ Ii′ and pj = 0 for all j ∈ Ii′′. An enabled
transition can fire. When ti fires,
i.) It atomically deletes a token from each input place
pj for all j ∈ Ii′, and
ii.) It atomically puts a token in each output place pj
where (ti,pj) ∈ A.

To prove: Web bonds have the modeling power of
Extended Petri nets.
Proof: To prove this we map a generic PNE to a network
of Web bonds as follows (Fig. 6 and Fig. 7).
pm

pk

pk-1

p1

…

…

Transition T

Definition: Web bond (WB)
A Web bond WB is defined as a two tuple (O, B), where,
O = {O1, O2, … , On} is a finite set of objects, and
B = {b1, b2, …, bm} is a finite set of bonds.
An object Oi is a two tuple (M,V), where M = {m1, m2,
…, mk} is a finite set of methods available at Oi and V =
{v1, v2, ..., vk } is a finite set of data variables.
A bond bi is a three tuple (S, D, Type) where,
S = Oi.mj(paramk) is the source method,
D = Set of destination methods Oi′.mj′(paramk′),
where mj, mj′ are methods in objects Oi, Oi′ with
parameter sets paramk, paramk′ , respectively,
and
Type = {Subscription, Negotiation}.
(Note: The Type may be dropped if the context is clear. A
more detailed specification of bonds is not required for
the purpose of the proof.)
Subscription bond: Subscription bond from method mj
with parameter set paramk of object Oi to method mi′ with
parameter set paramk′ of object Oi′ is defined as follows:
If Oi.mj(paramk) is executed then invoke Oi′.mi′(paramk′).
Negotiation bond: Negotiation bond between method mj
with parameter set paramk of object Oi and each
Oi′.mj′(paramk′) ∈ D is defined as follows:
Execute Oi.mj(paramk) only if all Oi′.mj′(paramk′) ∈ D
can be executed.
Execution Rule of Negotiation Bond:
On invocation of mj.(paramk) of object Oi, atomically
execute each method Oi′.mj′(paramk′) ∈ D and
(Without loss of any
Oi.mj.(paramk) successfully.
generality, both pre- and post-execution interpretations of
negotiation bonds enforce such atomicity’s.)
Now we prove that Web bonds are at least as capable as
Petri nets with inhibitor arcs.

…
pm+1

pn

Fig. 6. Petri Net with inhibitor arcs (PNE)
We define a WB (O, B) corresponding to a PNE (T, P, A,
f) as follows. Set O is a collection of two types of objects
corresponding to the places and the transitions of PNE
defined as follows (Fig. 7).
decrement()

op1

opk-1

Negotiation bonds

opm+1
increment()

opn
fire()

opk
opm
zero()

Fig. 7. Simulating PNE using Web bonds
O = P′∪ T′ such that P′= {opi | pi ∈ P}, T′= {oti | ti ∈
T}. Each opi ∈ P′ and oti ∈ T′ has the following methods
and properties.
opi = ({increment(), decrement(), zero()},
{int num_tokens}), and
oti = ({fire()}, {}), where,
increment():

num_tokens ++; return true;

decrement():
if (num_tokens >0)
{ num_tokens --;
return true;
}
else return false;

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

4

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

PNE is enabled and its firing atomically deletes a token
from each input place pj for all j ∈ I′i, puts a token in
each output place pj where (ti,pj) ∈ A, and makes sure that
pj = 0 for all j ∈ Ii′′.

zero():
if (num_tokens = = 0)
return true;
else
return false;

4. Expressive Power of Web Bonds

fire(): return true;
Each arc in set of arcs A of PNE is mapped to a
negotiation bond bi in B as follows:
i) (pj, ti) ∈ A and f(pj, ti) = T 
(oti.fire(),{opj.decrement()}, Negotiation) ∈ B.
ii) (pj, ti) ∈ A and f(pj, ti) = F 
(oti.fire(), {opj.zero()}, Negotiation) ∈ B.
iii) (ti, pj) ∈ A 
(oti.fire(), {opj.increment()}, Negotiation) ∈ B.
Also, based on this mapping, for transition ti we define
three sets Ji′, Ji′′, and Ji′′′ in WB as follows.
i) Ji′ = Ii′, i.e. set of negotiation bonds (oti.fire(),
{opj.decrement()}) of WB are mapped to normal arcs of
PNE.
ii) Ji′′ = Ii′′, i.e. set of negotiation bonds (oti.fire(),
{opj.zero()}) of WB are mapped to inhibitor arcs of PNE.
iii) Ji′′′ = {j | (ti, pi) in A}, i.e. Set of negotiation bonds
(oti.fire(), {opj.increment()}) of WB are mapped to arcs
from transition ti to output places of PNE.
With that we prove that when transition ti ∈ T of PNE
fires there is a corresponding execution of fire() method
of object oti ∈ T′ of WB and vise-versa.
Part I: For each firing of transition ti ∈ T of PNE there
is a corresponding execution of fire() method of object oti
∈ T′ of WB.
When transition ti ∈ T of PNE fires, it atomically deletes
a token from each input place pj for all j ∈ Ii, puts a token
in each output place pj where (ti,pj) ∈ A and makes sure
that pj = 0 for all j ∈ Ii′′. Correspondingly, according to
the above mapping, when oti.fire() method in WB is
executed, then, atomically, all opj’s for all j ∈ Ji′ execute
opj.decrement() method, all opj’s for all j ∈ Ji′′′ execute
opj.increment() method, and all opj’s for all j ∈ Ji′′
execute opj.zero () method.
Part II: For each execution of fire() method of object oti
∈ T′ of WB, there is a corresponding firing of transition ti
∈ T of PNE.
According to the above mapping, when oti.fire() method
of object oti ∈ T′ of WB is executed, it atomically
executes opj.decrement() method in opj’s for all j ∈ Ji′,
opj.increment() methods in opj’s for all j ∈ Ji′′′ , and
opj.zero() method for all j ∈ Ji′′. Correspondingly,
according to the above mapping, the transition ti ∈ T of

Table 1. Support for workflow control patterns in
different Web service composition languages
and standards [2, 3, 5]
(+ : direct support, - : No direct support , +/- :
direct support with restrictions)

Pattern
Web
Bond

Standard/Product
Petri Net
(Basic + BPEL4WS WSCI
High level)

1. Basic Control: Sequence
Parallel Split
Synchronization
Exclusive Choice
Simple Merge

+
+
+
+
+

+
+
+
+
+

+
+
+
+
+

+
+
+
+
+

2. Advanced Branching &
Synchronization: Multi Choice

+

+

+

-

Synchronizing Merge
Multi Merge
Discriminator
3. Structural: Arbitrary Cycles
Implicit Termination

+
+
+
+
+

+
+
-

+
+

+/+

4. Multiple Instances: MI without
Synchronization

+

+

+

+

MI with a Priori Design Time
Knowledge

+

+

+

+

MI with a Priori Runtime
Knowledge

+

-

-

-

MI without a Priori Runtime
Knowledge

+

-

-

-

5. State based: Deferred Choice
Interleaved Parallel Routing
Milestone
6. Cancellation: Cancel Activity
Cancel Case

+
+
+
+
+

+
+
+
+/-

+
+/+
+

+
+
+

Possibility of developing and deploying workflows
over Internet has been studied by several research groups
[12, 30]. Any possible candidate for such applications
needs to have enough capabilities to enforce control flow
and dataflow and other communication requirements. In
[5], authors have gathered a comprehensive set of control
flow patterns that occur in workflows. Different workflow
models have different expressive capabilities to enforce
these control flow patterns. However, none of them is
comprehensive enough as depicted in Table 1.
In this section, we demonstrate the expressive power
of Web coordination bonds by modeling these control
flow patterns using Web bonds. As depicted in Table 1,
Web bond artifacts have enough expressive power to
enforce these control flow patterns directly. We note that
an existing workflow modeling framework called
“YAML” [4] is also capable of handling all these control

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

5

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

flow patterns. The difference between YAML and Web
bonds is that YAML has been specifically designed to
enforce these control flow patterns (by essentially
augmenting a Petri net based system) by adding explicit
constructs for each control. In contrast, Web bonds have
been designed as a generic framework for
coordination/collaboration among distributed systems,
and our framework happens to be also capable of
handling these workflow control flow patterns.

as new sub-activities get created. . Activity “create” also
makes sure that the sub-activity “sync” creates
negotiation bond to each sub-activity instance. Having
negotiation bonds to each instance, “sync” activity
ensures that it waits for all instances to be finished before
passing the control to C.
Multiple

instances known
only at runtime

A

I1

B

C

In

4.1 Modeling Workflow Control Patterns Using
Web Bonds
In [5], authors have divided control flow patterns into
six categories (Table 1). We illustrate the implementation
of a few selected patterns using Web bonds, due to space
constraints. Interested readers can find the detailed
description of enforcing all the patterns for workflow
controls using Web bonds in [31].

Fig. 9. Multiple instances with prior runtime
knowledge [5]

A

create()

B

sync()

*

*

B

B

I1
A

A

A

XOR

C

Fig. 8a. XOR-Split

C

I2

In

^
C

Fig 8b. XOR-Split using
Web bonds

4.1.1 Exclusive Choice (XOR-Split). XOR-Split is a
point in a workflow where only one of possible paths is
selected. Almost all the workflow modeling frameworks
(except Petri net based) require considerable designer
involvement to enforce XOR-Split. Web bonds eliminate
this requirement by embedding XOR logic among
subscription bonds. If both paths get evaluated to true
only one will be selected. Negotiation bonds from B and
C to A ensure that B and C could be executed only after A
is completed.
4.1.2 Multiple instances with prior runtime
knowledge. An activity of a workflow needs to be
instantiated multiple times for a given execution of the
workflow. Number of instances may depend on runtime
parameters such as the number of resource available (Fig.
9). These activities need to be synchronized before
starting subsequent activities of the workflow. As number
of instances is not known at the design time, most of the
workflow models (including Petri net) cannot enforce this
construct [2]. Due to the dynamic creation and deletion
facility of Web bonds, this can easily be (Fig. 10).
Activity B passes the control to “create” sub-activity with
instance creation parameters. Subscription bonds from
activity “create” to each sub-activity instance are inserted

Fig. 10. Multiple instances with prior runtime
knowledge using Web bonds
4.1.3 Milestone. Milestone is a point in workflow where an
activity is enabled only if the workflow has reached a certain
state and that state is still not expired [5]. Therefore, to start an
activity that has milestone control dependency, it needs to wait
for that particular milestone (state) to happen. For example, as
shown in Fig. 11, activity C is enabled if activity A has been
completed, hence, M has the control, and B has not been
started, hence the control is still in M. In other words, control
has been released from A and has not been consumed by B
yet. This situation can easily be modeled using middle activity
M [5]. This is a difficult control to enforce because there is a
race condition among activities C and B, and the execution of
activity B disables C [16].

A

M

B

C

Fig. 11. Milestone [5]
However, milestone can easily be enforced using the
power of negotiation bonds (Fig. 12). C has a negotiation
bond to M. This means that C can only be done if M is

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

6

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

completed. In this case, M is completed if M has the
control. In addition, M has a subscription bond to inform
the arrival of control to C and B (with XOR logic, only one
of the two gets activated). C has a subscription bond to
reactivate M (thus, C can be executed repeatedly). A
problem with other technologies, including standard Petri
nets, is that an external invocation of C can interfere with
milestone workflow. However, no such interference is
possible here due to the negotiation bond from C to M.
Negotiation bonds from M to A and B to M are also
required to enforce dependencies of M to A and B to M,
respectively.
A

M

(Fig. 11) enables the sender to make requests.
Simultaneously, the “Request()” function sends control to
its own “ReceiveReply()” function. This is enforced by
having another subscription bond from the “Request ()”
function to the “ReceiveReply()” function of the sender
with AND logic. At this point the sender cannot proceed
until it receives data from the receiver. This can easily be
enforced by having a negotiation bond from the
“ReceiveReply()” function of the sender to the “Reply ()”
function of the receiver. The negotiation bond makes sure
that the “ReceiveReply()” function keeps the control until
it gets a reply from the receiver.

B

^

Sender/Client

Receiver/Server
ReceiveRequest()

Request()

*
ReceiveReply()

C

Reply()

Fig. 12. Milestone using Web bonds
Fig. 13. Reply/request

4.2. Modeling Communication Patterns
Interaction among different entities of a distributed
system is critical to its flexibility [28]. The way they
communicate defines how such interaction happens.
There are two basic models in distributed communication:
synchronous
and
asynchronous.
Synchronous
communication demands the sender to halt its current
process until it receives an acknowledgement/data from
the receiver whereas asynchronous allows current process
to be continued. Any fundamental framework that
facilitates composing applications over distributed
components/objects must support both synchronous and
asynchronous communication because efficient and
effective inter-service communication key to the success
of distributed applications. This section describes how
Web bonds can be used to enforce different types of
communication patterns. We illustrate the implementation
of a few selected communication patterns due to space
limitations. Detailed description of enforcing other
communication patterns using Web bonds is in [31].
4.2.1 Synchronous Communication. Synchronous
communication can be implemented in three different
ways: request/reply, one-way, and polling [28]. Fig. 13
shows the implementation of the request/reply
communication pattern using Web bonds. Other
implementations are in [31].
Request/Reply: The request/reply scenario needs the
sender to halt its current process until it receives data
from the receiver. Such a requirement can be modeled
using Web bonds as shown in Fig. 11. Here, a
subscription bond from the “Request()” function of the
sender to the “ReceiveRequest()” function of the receiver

4.2.2 Asynchronous Communication. Asynchronous
communication also occurs in three different ways:
message passing, publish/subscribe, and broadcast [28].
Fig. 14 shows the implementation of the message passing
communication pattern using Web bonds. Others are in
[31].
Sender/Client

Receiver/Server

Request()

ReceiveRequest()

Fig. 14. Message passing

Message Passing: Message passing is the simplest
asynchronous communication method (Fig. 14). Sender
makes the request and it does not wait for the reply;
essentially, it forgets the request. This can easily be
carried out by having a subscription bond from the
“Request()” function to the “ReceiveRequest()” function.
The subscription bond simply pass the message to the
receiver.

5. Related Work
We briefly discuss some relevant work on workflow
models, Web Service composition, and coordination
theory. More detailed discussion can be found in [31].
Service oriented computing (Software as a Service,

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

7

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

“SaaS”) has become a notable development in software
engineering. Software services could be running on
heterogeneous platforms and distributed information
networks may be providing services to other entities in
the network [37]. Each individual service is a potential
basic building block of an application (service
composition). Web services infrastructure is arguably the
most important realization of the “SaaS” concept. Each
Web service (WS) provides specialized services to others
on the network. Thus, in such service-oriented
architecture, WSs have become building blocks out of
which new applications are created. Gartner surveys show
that SaaS will be the dominant technology in information
development systems by 2007 [35]. Therefore, service
composition has become the main concern in an
application development process over Web services. In
[18], authors illustrate how existing WSs are tailored to
develop business processes over the Internet. Such
composition enables inter-organizational collaboration
and coordination. Those coordinated activities are long
running (workflows, transactions) and require much more
beyond just invoke/response protocols [17, 20]. However,
currently individual WSs are stateless and do not have
any provision to store state information for long-lived
transactions/Workflows [3, 22].In order to overcome this
Web service composition languages have been developed.
The intent of WS composition languages is to provide
required tools for modeling such long running activities
over Web services.
As pointed out in [3], many languages, including
WSFL, WSCI, WS-Coordination, WS-Conversation,
BPML, XLANG, BPSS, and BPEL4WS [28], have
emerged as WS composition languages. Some of these
technologies provide ways to link different WSs together
to form composed WSs. WSFL propose three types of
links: control links, data links, and plug links. “Control
links connect the completion of one activity to the
execution of another. Data link connection represents a
data exchange between the two Web services, and plug
link represents the inherent client/server structure of a
Web Service” [36]. BPEL4WS partner links define the
shape of a relationship with a partner. In BPEL4WS, a
partner represents both the consumer (Requester) and the
producer (Supplier) Web services. The partner link is
used to directly model peer-to-peer conversational partner
relationships. XML Linking Working Group proposed the
XLink language, which is capable of establishing
relationships between resources or portions of resources
on the Web. Currently this workgroup is not active.
However, XML’s RDF [34] proposes a similar idea. Both
XLink and RDF “provide a way of asserting relations
between resources” [34]. Such technologies have the
potential to evolve as useful tools for WS-composition.
However, as things stand today, all of these
languages provide different techniques to compose Web
services without solid theoretical underpinning. In [6],

authors have pointed out that lack of fundamental
framework to develop such collaborative applications has
resulted in plethora of products and standards. In a
nutshell, the current status is a frenzied effort by many
developing myriad of ever-richer protocols and languages
for web service collaboration, suitable only for domain
experts, without much fundamental framework. As
suggested in [15], in order to provide formal semantics
and characterization of emerging languages, possible
candidates for formal tools include Communicating Finite
Automata (CFA) [9], Petri nets [26], Category theory
[13], and Process algebra. In [8], authors have taken some
initiatives towards such analysis.
In [14], authors discuss modeling e-negotiation
activities using Petri nets. In [26], authors have proposed
a Petri-net-based model to manage interdependencies
among collaborative tasks in workflows. “HiWorD” [7] is
another Petri-net-based workflow design and simulation
tool that allows designers to model and simulate business
process before deploying the actual workflow.
Successful and efficient coordination can be done if
those standards and languages provide adequate
constructs to build complex systems easily with correct
coordination logic. Towards this goal in [5], authors have
gathered a repository of workflow patterns that are
common in workflow modeling. A PhD thesis in [16] has
studied the expressiveness and suitability of these
workflow control patterns. Also, in this thesis, Petri net
has been used as the formal modeling tool. Such studies
shows that any workflow standard should have enough
expressive power to model complex systems. Using those
workflow patterns as a benchmark Web services
composition and workflow languages such as BPEL4WS,
XLANG, WSFL, BPML, WSCI, and High-level Petri-netbased languages have been evaluated [28]. This
evaluation shows that though Petri-net-based languages
have more modeling power they do not have direct
constructs to model some patterns involved in multiple
instances and complex synchronization. In [4], authors
report design and implementation of a new language for
workflow management called “Yet Another Workflow
Language” (YAWL). YAWL has explicit constructs for
all complex controls such as synchronization, XOR-split,
and cancel activity.
Web bonds, in contrast, have a sound theoretical basis,
are at least as powerful as extended Petri nets, and are
able to express all the benchmark workflow and
communication patterns.

6. Conclusions and Future Work
Next generation of Internet applications
various kinds of collaborative applications
heterogeneous, autonomous entities. Even if
plethora of products and standards for Web

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

will be
among
there is
services

8

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

composition, there is no fundamental framework to
develop and deploy collaborative applications over Web
services. In this paper, we have demonstrated the concept
of Web coordination bonds as a capable framework to
develop and deploy such collaborative applications with
the required theoretical underpinning. We theoretically
showed its modeling power and assessed it expressive
power by modeling comprehensive set of workflow
patterns. In future, we aim to formalize the concepts of
Web coordination bonds. Also, we aim to rigorously
prove their completeness (or, to complement these or
down-size them further, if so needed) by critically
evaluating current Web service composition and
coordination technologies and extracting their essence. It
is important to investigate possible ways to incorporate
Web coordination bond concepts into Web services
infrastructure.

7. References
[1] Agerwala, T., Flynn, M., ``Comments on capabilities,
limitations and `correctness' of Petri nets''; Proc. of the 1st
Annual Symp. on Computer Architecture, 1973, pp.81-86.
[2] W.M.P. van der Aalst and A.H.M. ter Hofstede, Workflow
Patterns: On the Expressive Power of (Petri-net-based)
Workflow Languages, Proc. of the 4th Workshop on the
Practical Use of Coloured Petri Nets and CPN Tools (CPN’02),
vol. 560 of DAIMI, Aarhus, Denmark, August 2002, pp. 1–20.
[3] W.M.P. van der Aalst, M. Dumas, and A.H.M. ter Hofstede.
Web Service Composition Languages: Old Wine in New
Bottles? In G. Chroust and C. Hofer, editors, Proc. of the 29th
EUROMICRO Conf. on New Waves in System Architecture, Los
Alamitos, CA, 2003, pp. 8-305.
[4] W.M.P. van der Aalst, L. Aldred, M. Dumas, and A.H.M. ter
Hofstede. Design and Implementation of the YAWL system. To
appear in Proc. of The 16th Intel. Conf. on Advanced
Information Systems Engineering (CAiSE 04), Riga, Latvia,
June 2004.
[5] W. M. P. van der Aalst, Workflow
http://tmitwww.tm.tue.nl/research/patterns, 2003.

patterns,

[6] B. Benatallah, M. Dumas, M. C. Fauvet, F. A. Rabhi, and
Quan Z. Sheng, “Overview of Some Patterns for Architecting
and Managing Composite Web Services,” ACM SIGecom
Exchanges, ACM Press, August 2002, pp. 9-18.
[7] B. Benatallah, P. Chrzastowski-Wachtel, R. Hamadi, M.
O'Dell, and A. Susanto, ``HiWorD: A Petri Net-based
Hierarchical Workflow Designer,'' Proc. of the 3rd Intl. Conf. on
Application of Concurrency to System Design (ACSD 2003),
IEEE Society, Guimaraes, Portugal, June 2003.
[8] L. Cardelli , R. Davies, "Service Combinators for Web
Computing, "IEEE Trans. on Software Engineering, Vol. 25,
No. 3, 1999, pp. 309-316.

[9] T.L. Casavant, J.G. Kuhl, “A Communicating Finite
Automata Approach to Modeling Distributed Computation and
its Application to Distributed Decision-Making,” IEEE trans. on
computers, May 1990,Vol. 39, No. 5, pp. 628-639.
[10] Francisco Curbera, Rania Khalaf, Nirmal Mukhi, Stefan
Tai, Sanjiva Weerawarana, “Service-oriented computing: The
next step in Web services,” Communications of ACM, Vol. 46 ,
No. 10, October 2003, pp. 29 – 34.
[11] In-Young Ko, Neches, R., “Composing Web Services for
Large-Scale Tasks,” Internet Computing, IEEE , Vol.7 No. 5 ,
Sept.-Oct. 2003 , pp. 52 –59.
[12] Yang Guangxin, Shi Meilin, Xiang Yong, Wu Shangguang,
“Wowww! :managing workflow on the World Wide Web,” In
Proc. Intl. Conf. Communication Technology (ICCT '98), IEEE
Computer Society Press, Oct 22-24, 1998, pp. 1- 5.
[13] Jiang Guo, “Using Category Theory to Model Software
Component Dependencies,” Proc. 9th Annual IEEE Intl. Conf.
and Workshop on the Engineering of Computer-Based Systems
(ECBS 2002) ,Lund, Sweden, IEEE Computer Society Press,
April 08 - 11, 2002, pp. 185-194.
[14] P. C. K. Huang. and Ji-Ye Mao, “Modeling e-Negotiation
Activities with Petri Nets,” Proc. of HICSS 35. Hawaii. 2002.
[15] Richard Hull, Michael Benedikt, Vassilis Christophides,
Jianwen Su, “E-Services: A Look Behind the Curtain,” Proc.
of the twenty-second ACM SIGMOD-SIGACT-SIGART Symp. on
Principles of Database Systems, San Diego, California, June 09
- 11, 2003, pp. 1-14.
[16] B. Kiepuszewski, “Expressiveness and Suitability of
Languages for Control Flow Modeling Workflows,“ PhD thesis,
Queensland University of Technology, Brisbane, Australia,
2002.
[17] Mark Little , “Service-oriented computing,” Transactions
and Web services, ACM, Vol. 46 , No.10 October 2003, pp.
49 – 54.
[18] F. Leymann, D. Roller, and M.-T. Schmidt, “Web services
and business process management,” IBM systems Journal, Vol
41, No 2, 2002.
[19] T. W. Malone, and K. Crowston, “The interdisciplinary
study of coordination,” ACM Comput. Surv. Vol:26 Issue:1,
1994, pp. 87-120.
[20] C. Mohan, “Workflow Management in the Internet Age,”
Advances in Databases and Information Systems,” In Proc. 2nd
East-European Symp. Advances in Databases and Information
Systems (ADBIS'98), Poznan, Poland, September 1998, LNCS
vol:1475 pp. 26-34.
[21] Norman W. Paton, Oscar Diaz, “ Active Database
Systems,” ACM Computing Surveys, Vol. 31, No. 1, March
1999, pp 63 - 103.

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

9

Proceedings of the 38th Hawaii International Conference on System Sciences - 2005

[22] Chris Peltz, “Web Services Orchestration and
Choreography,” IEEE Computer, Vol. 36, No. 10, October
2003, pp. 46-52.
[23] Sushil K. Prasad, Anu G. Bourgeois, Erdogan Dogdu, et al.
“Enforcing Interdependencies and Executing Transactions
Atomically Over Autonomous Mobile Data Stores Using SyD
Link Technology,” In Proc.
Mobile Wireless Network
Workshop held in conjunction with The 23rd Intl. Conf.
Distributed Computing Systems (ICDCS'03), May 19-22 2003,
Providence, Rhode Island, IEEE Computer Society Press, pp.
803 –811.
[24] Sushil K. Prasad, V. Madisetti, Sham Navathe, et al.
System on Mobile Devices (SyD): A Middleware Testbed for
Collaborative Applications over Small Heterogeneous Devices
and Data Stores, To appear in Proc. ACM/IFIP/USENIX 5th
International Middleware Conference, Toronto, Ontario,
Canada, October 18th - 22, 2004.
[25] Sushil K. Prasad and Janaka Balasooriya ,Web
Coordination Bonds: A Simple Enhancement to Web Services
Infrastructure for Effective Collaboration , Proc. 37th Hawai'i
International Conference on System Sciences, Big Island,
Hawaii, January 5-8, 2004, pp. 70192.1
[26] A. B. Raposo, L. P. Magalhaes, I. L. M. Ricarte, “Petri
Nets Based Coordination Mechanisms for Multi-Workflow
Environments,” International Journal of Computer Systems
Science & Engineering, September 2000, vol.15, no .5, p.315 –
326.

[32] Sushil K. Prasad, Anu G. Bourgeois, Erdogan Dogdu, et al.
“Implementation of a Calendar Application Based on SyD
Coordination Links,” In Proc. 3rd Intl. Workshop Internet
Computing and E-Commerce in conjunction with the 17th
Annual Intl. Parallel & Dist. Processing Symp. (IPDPS 2003) ,
Nice, France, 22-26 April, pp. 242.
[33] XML Linking Language (XLink) Version 1.0, W3C
Recommendation, 27 June 2001, http://www.w3.org/TR/xlink/.
[34] RDF/XML Syntax Specification (Revised) W3C
Recommendation 10 February 2004, http://www.w3.org/
TR/2004/ REC-rdf-syntax-grammar-20040210/
[35] Nektarios Gioldasis, Nektarios Moumoutzis, Fotis G.
Kazasis, Nikos Pappas, Stavros Christodoulakis, “A Service
Oriented Architecture for Managing Operational Strategies,”
ICWS-Europe 2003, Erfurt, Germany, September 23-24,
Springer, pp. 11-23
[36] Frank Leymann, "Web Services Flow Language (WSFL
1.0)." IBM Software Group, May 22, 2001.
[37] Francisco Curbera, Rania Khalaf, Nirmal Mukhi, Stefan
Tai, Sanjiva Weerawarana, “Service-oriented computing: The
next step in Web services,” Communications of ACM, Vol. 46 ,
No. 10, October 2003, pp. 29 – 34.

[27] Johnson P Thomas, Mathews Thomas, George Ghinea,
“Modeling of Web Services Flow,” IEEE Intl. Conf. on ECommerce, June 24 - 27, 2003 Newport Beach, California , pp.
331-339.
[28] P. Wohed, W.M.P. van der Aalst, M. Dumas, and A.H.M.
ter Hofstede, “ Pattern based analysis of BPEL4WS”, Technical
Report FIT-TR-2002-04, QUT, Queensland University of
Technology, 2002.
[29] T. Agerwala, "Control of Access to Shared Resources,"
Hopkins Computer Research Report #36, Computer Sciences
Program, The Johns Hopkins University, Baltimore, Md., Oct.
1974.
[30] Gunter Preuner, Michael Schrefl, “Integration of Web
Services into Workflows through Multi-Level Schema
Architecture,” In Proc. 4th IEEE Intl. workshop on Advanced
issues of E-Commerce and Web-based Information Systems
(WECWIS’02), Newport Beach, CA, 26–28 June ,2002,IEEE
Computer Society Press, pp. 51-60.
[31] Sushil K. Prasad and J. Balasooriya. 2004. Web
Coordination Bonds: A Simple and Theoretically Sound
Framework for Effective Collaboration among Web Services,
Technical Report CS-TR-04-01, Department of Computer
Science, Georgia State University, June, 36 pages.
http://www.cs.gsu.edu/~cscskp/Pub/PB0401TR.pdf

0-7695-2268-8/05/$20.00 (C) 2005 IEEE

10

2010 Seventh International Conference on Information Technology

Service-Oriented Cloud Computing Architecture
Wei-Tek Tsai*, Xin Sun, Janaka Balasooriya
Department of Computer Science
Arizona State University
Tempe Arizona 85281 USA
Department of Computer Science and Technology, Tsinghua University, Beijing, China*
{wtsai, xin.sun, janaka}@asu.edu

Abstract
Cloud computing is getting popular and IT giants such as
Google, Amazon, Microsoft, IBM have started their cloud
computing
infrastructure.
However,
current
cloud
implementations are often isolated from other cloud
implementations. This paper gives an overview survey of
current cloud computing architectures, discusses issues that
current cloud computing implementations have and proposes a
Service-Oriented Cloud Computing Architecture (SOCCA) so
that clouds can interoperate with each other. Furthermore, the
SOCCA also proposes high level designs to better support
multi-tenancy feature of cloud computing.

Figure 1: Hierarchical View of Cloud Computing
Data Centers: This is the foundation of cloud computing which
provides the hardware the clouds run on. Data centers are
usually built in less populated areas with cheaper energy rate
and lower probability of natural disasters. Modern data centers
usually consist of thousands of inter-connected servers.
Infrastructure as a Service: Built on top of data centers layer,
IaaS layer virtualizes computing power, storage and network
connectivity of the data centers, and offers it as provisioned
services to consumers. Users can scale up and down these
computing resources on demand dynamically. Typically,
multiple tenants coexist on the same infrastructure resources [1].
Examples of this layer include Amazon EC2, Microsoft Azure
Platform.
Platform as a Service: PaaS, often referred as cloudware,
provides a development platform with a set of services to assist
application design, development, testing, deployment,
monitoring, hosting on the cloud. It usually requires no
software download or installation, and supports geographically
distributed teams to work on projects collaboratively. Google
App Engine, Microsoft Azure, Amazon Map Reduce/Simple
Storage Service are among examples of this layer.
Software as a Service: In SaaS, Software is presented to the
end users as services on demand, usually in a browser. It saves
the users from the troubles of software deployment and
maintenance. The software is often shared by multiple tenants,
automatically updated from the clouds, and no additional license
needs to be purchased. Features can be requested on demand,
and are rolled out more frequently. Because of its service
characteristics, SaaS can often be easily integrated with other
mashup applications. An example of SaaS is Google Maps, and

1. Introduction
Clouds have emerged as a computing infrastructure that
enables rapid delivery of computing resources as a utility in a
dynamically scalable, virtualized manner. The advantages of
cloud computing over traditional computing include: agility,
lower entry cost, device independency, location independency,
and scalability [1].
There are many cloud computing initiatives from IT giants
such as Google, Amazon, Microsoft, IBM as well as startups
such as Parascale [2], Elastra [3] and Appirio [4]. However,
there exist many different interpretations of what cloud
computing is. This paper attempts to establish the connections
between SOA and cloud computing by presenting related issues,
and proposes a Service Oriented Cloud Computing Architecture
(SOCCA).
This paper is organized as the follows: Section 2 provides a
brief survey on cloud computing hierarchy; Section 3 presents a
survey on existing cloud computing architectures and their
issues; Section 4 proposes the SOCCA; Section 5 shows an
initial prototype and experiment; Section 6 concludes this paper.

2. A Survey on Cloud Computing
2.1. A Hierarchical View of Cloud Computing
Most of the current clouds are built on top of modern data
centers. It incorporates Infrastructure as a Service (IaaS),
Platform as a Service (PaaS), and Software as a Service (SaaS),
and provides these services like utilities, so the end users are
billed by how much they used. Figure 1 shows a hierarchical
view for cloud computing.
978-0-7695-3984-3/10 $26.00 © 2010 IEEE
DOI 10.1109/ITNG.2010.214

684

its mashups across from the internet. Other examples include
Salesforce.com and Zoho productivity and collaboration suite.
The dividing lines for the four layers are not distinctive.
Components and features of one layer can also be considered to
be in another layer. For example, data storage service can be
considered to be either in as IaaS or PaaS. Figure 1 suggests a
hierarchical relationship among the different layers; however, it
does not mean the upper layer has to be built on top its
immediate lower layer. For example, a SaaS application can be
built directly over IaaS, instead of PaaS.
In the cloud computing environment, everything can be
implemented and treated as a service. Figure 1 shows a few
examples of what can be treated as a service in different layers.

supports multi-tenancy feature by utilizing single application
instance model. The isolation among tenants is taken care by the
underline design. Other services include subscription
management, federated ID management, application firewall,
etc.

3.1. Issues with Current Clouds
Current cloud computing has following characteristics:
Users are often tied with one cloud provider: Even though
up-front cost for a cloud computing deployment is reduced and
long term lease is eliminated, much effort and money is spent on
developing the application for a specific cloud platform which
makes it difficult to migrate the same application onto a
different cloud. Often, migration simply may mean
redevelopment. For example, applications deployed on Amazon
EC2 cannot be migrated easily due its particular storage
framework [9].
Computing components are tightly coupled: This can be
clearly explained using an analogy. Suppose one wants a new
computer, this person has the choices of either buying a readyto-use computer from a manufacturer (buying) or purchasing the
components separately and building the computer in a DIY style
(building). The advantages of building over buying include
wider selection of components, flexibility to customize, and
cheaper cost [10]. However, as the computing resources over
the internet, current cloud implementations do not allow this
kind of flexibility. If a customer opts to use Amazon S3 storage
service, he is then stuck with other cloud computing services
Amazon provides, such as EC2, Elastic Map Reduce.
Lack of SLA supports: Currently, SLA is an obstacle that
prevents wide adoption for cloud computing. Cloud computing
infrastructure services such as EC2 are not yet able to sign the
SLA needed by companies that want to use cloud computing for
serious business deployment [11]. Moreover, business is
dynamic. Static SLA is not able to adapt to the changes in
business needs as cloud computing promises to.
Lack of Multi-tenancy supports: Multi-tenancy can support
multiple client tenants simultaneously to achieve the goal of
cost effectiveness. Currently, one has three types of multitenancy enablement approaches: virtualization, mediation and
sharing [12]. To achieve the full potential of multi-tenancy,
three issues remain to be solved [12]:
1. Resource sharing: To reduce the hardware, software and
management cost of each tenant.
2. Security isolation: To prevent the potential invalid access,
conflict and interference among tenants.
3. Customization: To support tenant-specific UI, access control,
process, data, etc.
Lack of Flexibility for User Interface: UI is an important part
of the application, and user experience can be a major
evaluation factor for a business application. However,
cloud/SaaS users are limited with UI choices because UI
composition frameworks, such as the one proposed in [13], have
not been integrated with cloud computing.

3. Existing Cloud Computing Architectures
Both academia and industry have been active on cloud
computing research, and several cloud computing architectures
have been proposed. In [5], IBM considers current singleproviders cloud as limited resource, and the lack of
interoperability among cloud providers prevents deployment
across different clouds. A cloud computing architecture named
Reservoir was proposed to create a federation from multiple
cloud providers which acts as a global fabric of resources that
can guarantee the required SLA. In Reservoir architecture, the
computational resources within a site are partitioned by a
virtualization layer into virtual execution environments (VEEs).
A service application is decomposed into a set of software
components/services running on VEEs on the same or different
VEEs within a site or across from different sites. However,
Reservoir architecture does not allow a component/service to
run on its duplicates on different VEEs; Moreover, computing
resources are abstracted as hosting service which might not be
necessarily true for all clouds. In [6], a software platform for
.NET based cloud computing named Aneka was introduced.
Aneka is a customizable and extensible service oriented runtime
environment that enables developers to build .NET applications
with the supports of APIs and multiple programming models.
Aneka is a service-oriented, pure PaaS cloud solution. In [7],
Rajkumar and his colleagues explained a market-oriented cloud
architecture in detail used by Aneka, which regulates the supply
and demand of cloud resources to achieve market equilibrium,
adds economic incentives for both cloud consumers and
providers, and promotes QoS-based resource allocation
mechanisms that differentiates service request based on their
utility. The key component of this architecture is SLA (Service
Level Agreement) Resource Allocator which is consisted of
Service Request Examiner and Access Control, VM (Virtual
Machines) monitor, Service Request Monitor, and Request
Dispatcher. Based on the feedback from VM and Service
Request monitors, the dispatcher routes the requests from
users/brokers to the cloud resources that can fulfill their QoS
requirements. In [8], Huang and her colleagues from IBM
described a service oriented cloud computing platform that
enables web-delivery of application-based services with a set of
common business and operational services. The platform

685

4. Service Oriented Cloud Computing
Architecture (SOCCA)

more flexible platform for enterprise to build their SOA
solutions. In other words, SOA and cloud computing will coexist, complement, and support each other.
There have been several initiatives at attempting bridging
SOA and cloud computing. Noticeably, the works in [6] [8]
have more service-oriented features than the other mentioned in
section 3.

4.1. Cloud Computing and SOA
SOA and cloud computing are related, specifically, SOA is
an architectural pattern that guides business solutions to create,
organize and reuse its computing components, while cloud
computing is a set of enabling technology that services a bigger,

Figure 2: Service-Oriented Cloud Computing Architecture
achieve maximum interoperability, uniform standards need to be
implemented. For example, SQL is de facto standard for
RDBMS data management, and many database vendors have
their own implementations. A cloud version of SQL needs to be
defined, so data manipulation logic of an application that works
on one cloud can also work other clouds. A distributed
computing framework standard to unify all different
implementations of Map/Reduce is also in need for the same
reason.
Cloud Ontology Mapping Layer: Cloud providers might not
conform to the standards rigidly; they might also have
implemented extra features that are not included in the
standards. Cloud Ontology Mapping Layer exists to mask the
differences among the different individual cloud providers and it
can help the migration of cloud application from one cloud to
another. Several important ontology systems are needed:
1. Storage Ontology: It defines the concepts and terms related
to data manipulation on the clouds, such as data update, date
insert, data delete, and data select, etc.

4.2. Layered Architecture of SOCCA
Our SOCCA is a layered architecture shown in Figure 2:
Individual Cloud Provider Layer: This layer resembles the
current cloud implementations. Each cloud provider builds its
own data centers that power the cloud services it provides. Each
cloud may have its own proprietary virtualization technology or
utilize open source virtualization technology, such as
Eucalyptus [14]. Similar to Market-Oriented Cloud Architecture
proposed in [7], within each individual cloud, there is a request
dispatcher working with Virtual Machine Monitor
and
Service/App Governance Service to allocate the requests to the
available recourses. The distinction from current cloud
implementations is that the cloud computing resources in
SOCCA are componentized into independent services such as
Storage Service, Computing Service and Communication
Service, with open-standardized interfaces, so they can be
combined with services from other cloud providers to build a
cross-platform virtual computer on the clouds. In order to

686

2. Computing Ontology: It defines the concepts and terms
related to distribute computing on the clouds, such as
Map/Reduce Framework.
3. Communication Ontology: It defines the concepts and terms
related Communication Schema among the clouds, such as data
encoding schema, message routing.
Cloud Broker Layer: Cloud brokers serve as the agents
between individual cloud providers and SOA layer. Each major
cloud service has an associated service broker type. Generally,
cloud brokers need to fulfill the following tasks:
1. Cloud Provider Information Publishing: Individual cloud
providers publish specifications and pricing info to the cloud
brokers. Important provider information includes:
Cloud Provider Basic Information: Company Name, Company
Address, Company Website, Company Contact Info, etc.
Resource Type and Specifications: Whether it is
computer/storage/communication resource and its specification
and limitation. For example, for the data storage service, the
data transmission rate can be as high as 2Gb/s.
Pricing Information: How the services charge. This varies the
most among different cloud providers. For example, currently,
Google does not charge for the first 500MB storage, and $0.15
per GB of data after, while Amazon charges $0.11 per GBmonth for its EBS Volumes service. Even within a cloud
provider, the pricing info might change as the market’s dynamic
changes.
2. Ranking: Like the service brokers in SOA, cloud brokers
also rank the cloud resources published. Services can be ranked
in several categories such as price, reliability, availability, and
security, etc. Ranking can be achieved through user voting or
historical service governance records.
3. Dynamic SLA Negotiation: Business is often dynamic, and
the IT infrastructure has to be adaptive to accommodate the
business needs, therefore to achieve the optimal ROI (Return of
Investment). It’s often the case that the IT resources a business
demands can be predicted. Cloud service brokers can help cloud
users and cloud providers negotiate on a SLA dynamically.
4. On-Demand Provision Model: Most services experience
seasonal or other periodic demand variation as well as some
unexpected demand bursts due to external events. The only way
to provide “on-demand” services, is to provision for them in
advance. Accurate demand prediction and provision become
critical for the successful of the cloud computing, which reduces
the waste of utility purchase and can therefore save money using
utility computing. We are investigating a demand prediction
model and model the evolution of multi-tenant as a discrete time
stochastic
process.
We
have
investigated
several
macroeconomic factors in a real mortgage service platform
[15][16], and the initial results show that the underlying
stochastic process may depend on a number of external factors
such as macroeconomic variables, as well as service internal
features. Some analysis results from real applications
demonstrate the effectiveness of our models. Due to the space
limitation, more details can be found in [15]. Specifically, the
process needs to answer the following question: What is the

forecast of tenant m days into the future? How to predict the
workload distribution at different services? How to optimize
the service provision process and minimize customers'
dissatisfaction?
SOA Layer: This layer fully takes the advantages of the
existing research and infrastructure from traditional SOA. Many
existing SOA frameworks, such as CCSOA [17], UCSOA
[18], GSE [19] and UISOA [13] can be integrated into this
layer. Figure 2 shows a possible SOA layer for SOCCA.
Similar to CCSOA, not only services but also many other
artifacts can be published and shared, such as workflow
templates, collaboration templates and test cases. The registry
for each type of artifacts is indexed and organized by its
according ontology. The fundamental difference of the SOA
layer of SOCCA from traditional SOA is that the service
providers no longer host the published services anymore.
Instead, they publish the services in deployable packages, which
can be easily replicated and redeployed to different cloud
hosting environments. Application developers can decide which
clouds they want to these services to run based a set of criteria.
The details will be discussed in section 4.4. Another major
improvement is multi-tenancy support that allows more
flexibility, which will be discussed in section 4.3. SOA layer of
SOCCA allows more flexibility than traditional SOA; it further
separates the roles of service providers and cloud providers, and
the service logics and its running environments.

4.3. Multi-tenancy Architecture (MTA)
As shown in Figure 2, SOCCA allows 3 different main multitenancy patterns. In [8], the authors discussed the left two multitenancy patterns: Multiple Application Instance (MAI) and
Single Application Instance (SAI). The authors pointed out, the
former does not scale as well as the latter, but it provides better
isolation among different tenants. Within SOCCA, a new multitenant pattern becomes possible: Single Application Instance
and Multiple Service Instances (SAIMSI). The motivation
behind this pattern is that the workloads are often not distributed
evenly among application components, and the performance of
the single application instance is limited by the application
components having lower throughput. Moreover, to enhance
scalability, we want to reduce unnecessary duplications as much
as possible as opposed to Multiple Application Instances
pattern. Figure 3 shows a simplified example. The example
application is composed by A, B, C, three services with C being
the computing intensive component. With C being the
bottleneck to support multiple tenants, 3 instances of C are
created to balance the workloads. Note that the 3 instances of
the services can also reside on different clouds.
Better scalability is not only benefit from the SAIMSI
pattern, easy customizability is another gain. Suppose in the
sample application, C is a payment service. Different tenants
might have different payment method requirements, such as
credit card, Paypal, or check.
The application runtime
environment (not described in this paper) will direct users of
each tenant to the correct service instance according to tenants’

687

Resource Files: Any resource files that the service depends
on, such as images, documents.

individual configuration. In the case that a future tenant has a
payment requirement that cannot be met by the existing service
instances, say money order, an according service instance can
be easily plugged into the existing service instances group. The
upcoming papers on multi-tenancy from our research group will
provide more details on this topic.

4.4.2. SOCCA Applications
Application development in SOCCA is similar to the
development in CCSOA. Developers first search if there is a
workflow template that matches the requirement. A workflow
template is composed of service stubs/specifications, which
specify the functionalities and interfaces of services. Later a
service stub is bound with a service package. Depending on the
QoS requirements and the budget for the application, cloud
brokers will negotiate with cloud providers on SLA, and deploy
the service packages on one or multiple clouds. An algorithm
for request dispatching for a service across its deployments on
different clouds needs to be applied. Due to the page number
constraints, it will be discussed in our upcoming papers. Figure
4 shows a typical application architecture on SOCCA.

Figure 3: Single Application Instance Multiple Service
Instances

Figure 4 SOCCA Application Architecture

5. Initial Prototype and Experiment

4.4. Application Development on SOCCA
4.4.1. Service Package
Service providers of traditional SOA develop the logic of a
service and provide its running environment. In SOCCA,
services are published as re-deployable packages, namely
service package. A service package contains the following
required/ optional information and files:
Compiled Code: If service providers only use the standard
APIs and protocols, a single version of complied code is
enough; if service providers optimize the performance of their
services by utilizing some platform unique APIs and features,
complied code for each platform is needed.
Source Code: This is optional. It is useful to help its user to
understand the service better, also gives the freedom to its users
to tweak the services to accommodate their specific
requirement.
Configuration File: Services might use external basic
services. For example, a computing intensive scientific service
which also uses a lot of storage might deploy its computing
logic on a cloud that provides high performance computing
power, but use the cheaper storage service provided by another
cloud. This requires a configuration file which specifies the
external service’s locations, partner link, etc. This can also be
achieved in a BPEL manner, however, since basic services such
as storage services, have a widely adopted standards, and are
frequently used, so it is more efficient to handle in a database
connection configuration file style.

Figure 5: Motto Application with GAE Database
This section shows an initial prototype and experiment to
demonstrate the possibility of SOCCA.
The demonstration web application has one easy requirement:
When each user visits the web page, he/she will be greeted by a
random message retrieved from a motto database.
1. We developed the application by using Google App
Engine. Note that a number of mottos are retrieved and stored
from and to Google cloud by using Datastore with JDO. Figure
5 shows a screenshot of motto application running on Google
App Engine.
2. We created a web service that wraps the Azure SQL
service that allows retrieving and storing mottos from the motto
databases deployed on Azure.
3. We utilized the Web Service Connector (WSC) tool
provided by [20] to generate Google App Engine compatible
client code in java to access the web service developed by step
2. WSC is a code-generation tool that takes a WSDL file and

688

7. References

generates an optimized java library that provides access to the
web service.
4.
We
created
a
class
that
implements
“javax.jdo.PersistenceManagerFactory”, which is the interface
GAE Datastore uses to manipulate the data on the cloud.
5.
We
created
an
instance
of
SQLPersistenceManagerFactory
that
implements
“javax.jdo.PersistenceManagerFactory”, which is the interface
GAE Datastore uses to manipulate the data on the cloud. Figure
6, a code snippet, shows that depending on the config file, the
application will be connected with either GAE Datastore
database or Azure SQL database. Figure 7 shows that after
changing the config file, the motto app is now connected with
Azure
SQL
database.
More
implementations
of
PersistenceManagerFactory can be added.

[1] Wikipedia

Cloud
Computing.
http://en.wikipedia.org/wiki/Cloud_computing

[Online].

[2] Parascale. [Online]. http://www.parascale.com/
[3] Elastra. [Online]. http://www.elastra.com/
[4] Appirio. [Online]. http://www.appirio.com/
[5] Rochwerger B et al., "The RESERVOIR Model and Architecture for,"
IBM Systems Journal, 2009.

[6] Christian Vecchiola, Xingchen Chu, and Rajkumar Buyya, "Aneka: A
Software Platform for.NET-based Cloud Computing," in High Speed and
Large Scale Scientific Computing, 2010.

[7] Rajkumar Buyya and Chee Shin Yeo, "Cloud Computing and Emerging

IT Platforms: Vision, Hype, and Reality for Delivering Computing as the
5th Utility," Future Generation Computer Systems, pp. 599-616, 2009.

[8] Ying Huang et al., "A Framework for Building a Low Cost, Scalable and
Secured Platform for Web-Delivered Business Services," , 2009.

[9] Bernard Golden. (2009, January) Computer World. [Online].
http://www.computerworld.com/s/article/9126620/The_case_against_clo
ud_computing_part_one

[10] Mark

Kyrnin.
About.com.
http://compreviews.about.com/od/general/a/BuildvsBuy.htm

Figure 6: Code snippet for Database Service Configuration

[Online].

[11] Galen

Moore. (2009, Jan) Mass High Tech. [Online].
http://www.masshightech.com/stories/2009/01/05/weekly10-Cloudcomputings-SLA-obstacles-clear-in-2009.html

[12] Bo Gao, Changjie Guo, Zhihu Wang, Wenhao An, and Wei Sun. (2009,

March) Develop and Deploy Multi-Tenant Web-delivered Solutions
using IBM middleware: Part 3: Resource sharing, isolation and
customization in the single instance multi-tenant application. [Online].
http://www.ibm.com/developerworks/webservices/library/wsmultitenant/index.html

Figure 7: Motto App with Azure Database

[13] Wei-Tek Tsai, Qian Huang, Jay Elston, and Yinong Chen, "Service-

The prototype demonstrates that a service package deployed
on one cloud can be configured to collaborate with services
from other clouds. However, it does not show that a service
package can be redeployed on a different cloud and the
instances for the same services can live on multiple clouds. This
is due to that currently, different clouds support different
language sets, and there is no powerful modeling language to
support developments for multiple platforms. We are currently
developing this feature using a modeling language PSML [21].

Oriented User Interface Modeling and Composition," in International
Conference on e-Busines Enginerring, Xi'an, 2008, pp. 21-28.

[14] Eucalyptus System. [Online]. http://www.eucalyptus.com/
[15] Qihong Shao et al., "Ranking Mortgage Origination Applications using
Customer, Product, Environment and Workflow Attributes.," in IEEE
Proceedings of Congress on Services, 2009.

[16] Wei-Tek Tsai et al., "Forecasting Loan Volumes For the Mortgage
Orgination Process," , under review.

[17] W.T. Tsai, Bingnan Xiao, Ray A Paul, and Yinong Chen, "Consumer-

Centric Service-Oriented Architecture: A New Approach," in SEUSWCCIA, 2006, pp. 175-180.

6. Conclusion

[18] Mark Chang, Jackson He, W.T. Tsai, Bingnan Xiao, and Yinong Chen,

This paper proposed a service-oriented cloud computing
architecture SOCCA that allows an application to run on
different clouds and interoperate with each other. The SOCCA
is a 4-layer architecture that supports both SOA and cloud
computing. SOCCA supports easy application migration from
one cloud to another and service redeployment to different
clouds by separating the roles of service logic provider and
service hosting/cloud providers. It promotes an open platform
on which open standards, ontology are embraced. The paper
also introduced related topics for future research, such as service
demand prediction and SLA negotiation, and service request
dispatching algorithms. More work will also be conducted to
devise the ontology systems needed for a working SOCCA, and
a prototype with all features discussed.

"UCSOA: User-Centric Service-Oriented Architecture," in IEEE
International Conference on e-Business Engineering, 2006, pp. 248-255.

[19] Wei-Tek Tsai, Bingnan Xiao, Ray Paul, Qian Huang, and Yinong Chen,

"Global Software Enterprise: A New Software Constructing
Architecture," in International Conference on E-Commerce, 2006, pp.
55-55.

[20] force.com. [Online]. http://developer.force.com/appengine
[21] W.T. Tsai et al., "Modeling and Simulation in Service-Oriented Software
Development," Simulation, vol. 83, no. 1, pp. 7-32, 2007.

[22] Carl Osipoy, German Goldszmidt, Mary Taylor, and Indrajit Poddar.
(2009, May) Develop and Deploy Multi-Tenant Web-delivered Solutions
using IBM middleware: Part 2: Approaches for enabling multi-tenancy.
[Online]. http://www.ibm.com/developerworks/webservices/library/wsmultitenantpart2/index.html

689

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

Web Coordination Bonds: A Simple Enhancement to Web Services
Infrastructure for Effective Collaboration
Sushil K. Prasad and Janaka Balasooriya
Computer Science Department
Georgia State University
sprasad@gsu.edu

Abstract
The Web Services need to extend beyond the basic
service architecture (invoke and respond) to selfcoordinating Web processes collaborating among
themselves in the desired configuration as per user’s
application (transient to long lasting). A core set of
artifacts are needed to allow these Web processes to
hook together in a desired structure to enforce
automatic information flow, group constraint
satisfaction, and data and control dependencies, all
without any central coordinating authority. We
propose Web Coordination Bonds, analogous to the
chemical bonds, as a set of such core artifacts for
effective collaboration among Web Services. There are
two types of Web bonds: subscription bonds allow
information, control and event flows whereas
negotiation bonds enforce dependencies and contracts.
Web bonds are simple yet powerful, and we
demonstrate how they can be employed to create
(model) and enforce (deploy and execute) producerconsumer and shared-resource relationships, workflow
scenarios, and atomic transactions. We have developed
and prototyped a middleware called System on Devices
(SyD) incorporating Web bonds, and have employed it
to prototype a few distributed applications which bond
existing Web Services together to collaborate. Much
remains to be done, including theoretical treatment of
Web coordination bonds.

1. Introduction
We aim to develop a few core artifacts for effective
coordination/collaboration among Web entities. A
good analogy would be the molecular bonds in
chemical compounds, which are too simple yet
extremely powerful to enable all sorts of basic and
complex chemical compounds to exist naturally and to
be manufactured artificially. Different atoms expose
sites with certain number of either excess or shortage

of electrons. For example, oxygen atom has two
negatively charged sites, and hydrogen has a deficit of
one electron, giving it a positively charged site. To
form water molecule, therefore, two hydrogen atoms
bond with an oxygen atom - each bond is just a sharing
of an electron between a donor and a recipient site. The
Web Services are simple or composite server objects
situated on the Web with well-defined interfaces and
are the “Web atoms.” Molecules are, therefore,
analogous to all collaborating processes involving
individual Web Service components. The list of such
“Web molecules” spans transient to long running
collaborative processes - transactions, client-server and
p2p distributed applications, workflows as well as
virtual organizations. Taking the analogy further, the
challenge is to (i) define the analogous “bonding sites”
or simple “Web hooks” in the Web Service interface
needed to mesh multiple Web entities together, and (ii)
develop the analogous concept of a few simple yet
powerful types of “Web bonds” which would be the
coordination threads to bind and produce the “Web
molecules” out of multiple “Web atoms.”
These “Web bond” artifacts should allow rapid
modeling and deployment of collaborative applications
of all kinds and complexities. As things stand today,
the hooks exposed by the Web Services are the basic
methods published and the bonds available are no more
capable than the one-time invocations of those methods
by a client Web entity. Section 5 contains discussion
on
relevant
technologies
to
enhance
the
threading/gluing of Web Services for transactions,
workflows, etc. However, much remains to be done in
terms of extracting the simple core bonding artifacts
which are necessary and sufficient, or to prove that
such an exercise in itself is flawed.
This paper is a proposal for Web coordination
bonds (also alternatively called Web bonds or
coordination bonds, for short, or coordination bonds to
generalize to Web and non-Web entities) as one such
set of core artifacts for Web Service coordination/

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

1

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

choreography and has been born out of our experience
with developing several collaborative peer-to-peer
distributed Web applications. The idea of Web
coordination bonds originated from our study of how
to setup a meeting using online calendars of schedules
of people with automatic negotiation among calendars
in case of individual cancellations. The result was the
artifact called coordination links to establish and
enforce dependencies among collaborating entities [34,
35, 24]. While checking the relevant literature recently,
a serendipitous find has been the “Coordination
Theory” work in the Information Systems and
Management literature [25], which validated our
approach: “coordination” is indeed about “establishing
and enforcing dependencies.” Much work remains to
formalize the concepts of Web coordination bonds, and
to rigorously prove their completeness (or, to
complement these or down-size them further, if so
needed). However, some preliminary artifacts and
applications have already been designed and developed
to warrant further investigation by the research
community.
Contributions: In what follows, therefore, we
present the basic idea of Web coordination bonds and
their usage in modeling a few aspects of collaborative
Web applications. Section 2 defines Web bonds and
describes an enhancement to the Web Service interface
(Web hooks) to enable ability to bond to other Web
processes and trigger those bonds at run-time. Web
bonds can establish (model) and enforce (deploy and
execute) dependencies of various kinds. Section 3.1
demonstrates this for producer-consumer relationships,
and Section 3.2 does the same for shared-resource
relationships. These two kinds of relationships have
been shown to yield the fundamental categories of
dependencies, of course with several flavors [25]. A
detailed meeting setup example is also presented to
further illustrate the resource-sharing paradigm. In
Section 4, we briefly describe a middleware that we
have developed and prototyped, called System on
Devices (SyD), which, among its several modules, has
a SyDLink module to enable Web Services with
Coordination Bonds, as well as a SyDListner module
acting as a light-weight wrapper and SOAP (Simple
Object Access Protocol) server for enabling Web
Service view for legacy data stores and server
applications, even for mobile devices. Section 5 briefly
discusses some relevant literature and Section 6
contains our conclusions and future work.
Note: We use terms such as “coordination,”
“collaboration,” and “choreography” interchangeably.
The associated applications encompass all distributed

Web applications wherein multiple constituent entities
need to coordinate.

2. Concept of Web Coordination Bonds
(Coordination Links)
Web bonds enable applications to create contracts
between entities and enforce interdependencies and
constraints, and carry out atomic transactions spanning
over a group of Web entities/processes. While it is
convenient to think of an entity as a row, a column, a
table, or a set of tables in a data-store, the concept
transcends these to any object or its component, and
here we specifically consider Web Services. There are
two types of Web bonds: subscription bonds and
negotiation bonds. Subscription bond allows automatic
flow of information from a source entity to other
entities that subscribe to it. This can be employed for
synchronization as well as more complex changes,
needing data or event flows. Negotiation bonds
enforce dependencies and constraints across entities
and trigger changes based on constraint satisfaction.
A Web bond is specified by its type (subscription/
negotiation), status (confirmed/tentative), references to
one or more Web entities, triggers associated with each
reference (event-condition-action rules [32]), a priority,
a constraint (and, or, xor), a bond creation time and a
bond expiry time, and a waiting list of tentative bonds
(a priority queue). A tentative bond may become
confirmed if the awaited confirmed bond is destroyed.
A bond may be tentative. This is useful, for
example, if an attendee cannot commit for a meeting at
the time meeting is scheduled, but if the initiator still
wants to schedule a tentative meeting, pending changes
in the schedule of the attendee at a later time. If this
attendee is a must attendee, then there is a tentative
bond created back to the initiator. Typically, the
reason that an attendee cannot commit is because of a
prior commitment, and hence a non-tentative
confirmed negotiation bond. Many such tentative
bonds may go out from an attendee, and therefore,
these tentative bonds are in a priority queue of waiting
list. If and when the confirmed bond is destroyed, the
top tentative bond in the waiting list is converted to a
confirmed bond, and the associated trigger is activated.
This trigger could allow the initiator of the meeting to
resolve the conflicts for this meeting and declare it
committed.
Let an entity A be bonded to entities B and C,
which may in turn be bonded to other entities. A
change in A may trigger changes in B and C, or A can
change only if B and C can be successfully changed. In
the following, the phrase "Change X" is employed to
refer to an action on X (action usually is a particular
method invocation on Web Service X with specified set

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

2

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

of parameters); "Mark X" refers to an attempted
change, which triggers any associated bond without an
actual change on X.
Subscription Bond: Mark A; If successful Change A
then Try: Change B, Change C. A ``try" may not
succeed.
Negotiation-and Bond: Change A only if B and C can
be successfully changed. (Implements atomic
transaction with "and" logic).
Semantics (may not be implemented this way):
Mark A for change and Lock A
If successful
Mark B and C for change and Lock B and C
If successful
Change A
Change B and C
Unlock B and C
Unlock A
Note that locks are only for the explanation of the
semantics. A reservation/locking mechanism to
implement this usually will have an expiry time to
obviate deadlocks. In a database Web Service, this
would usually indicate a “ready to commit" stage.
Negotiation-or Bond: Change A only if at least one of
B and C can be successfully changed. (Implements
atomic transaction with "or" logic and can be extended
to at least k out of n).
Semantics:
Mark A for change and lock A
Mark B and C for change; Obtain locks on those
entities that can be successfully changed.
If obtained at least one lock
Then Change A; Change the locked entities.
Unlock entities
Negotiation-xor Bond: Change A only if exactly one of
B and C can be successfully changed. (implements
atomic transaction with "xor" logic and can be
extended to exactly k out of n).
Semantics:
Mark A for change and lock A
Mark B and C for change. Obtain locks on those
entities that can be successfully changed.
If obtained exactly one lock
Then Change A; Change the locked entities.
Unlock entities

Notations: A subscription bond from A to B is denoted
as a dashed directed arrow from A to B. A negotiation
bond from A to B is denoted as a solid directed arrow
from A to B. A negotiation-and bond from A to B and
C is denoted by two solid arrows, one each to B and C,
with a "*" in between the arrows. Similarly, a
negotiation-or bond from A to B and C is denoted by
two solid arrows, one each to B and C, with a "+" in
between the arrows. A negotiation-xor bond from A to
B and C is denoted by two solid arrows, one each to B
and C, with a "^" in between the arrows. A tentative
bond, which is a negotiation bond in a waiting list, is
shown as a solid arrow with cuts.
Web Coordination Hooks
Current trend in Web Services is to embed
behavioral information to the Web Service interface
which enables complex interaction among Web
Services [10]. We propose the concept of Web process
(Figure 1), a simple but powerful modification to the
current Web Service architecture. Web process enables
Web Services to be bonded with other services via
Web coordination bonds.

Web Hooks
Web Bond
Manager

Web Bond
Data Store

Figure 1. Web Process with Coordination Hooks

This essentially requires ability to establish
subscription and negotiation coordination bonds to
other Web Services, and be able to trigger them. This
requires maintaining a storage to manage such
coordination bonds (storage could be just a flat file),
and be able to trigger any subscription and negotiation
bonds, if present, when executing a method. The Web
Service should allow creation and deletion of such
bonds associated with a specific method with a specific
set of parameters. Also, each public method ideally
should have a sub-transaction-like behavior, i.e., an
ability to partially execute the triggered method and go
to “ready to commit” state, which can either be
committed or aborted subsequently by the triggering
entity. Alternatively, a reservation/locking facility on

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

3

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

methods with specified parameters are needed (thus
indirectly reserving certain changes on specific data
components).
In order to support such behaviors, “Web Bond
Manager” provides two kinds of method invocations.
Assume a method/service S at a Web Service. One can
(i) normally execute method S (invoke(S)) or, (ii) to
support the dependency behavior of a negotiation
bond, partially execute S and reserve/lock it (Mark(S)),
and subsequently, based on a group decision, complete
the execution of S (Change(S)) or abort its execution
(Abort(S)).
Semantics: (may not be implemented this way)

producer has enough inventories such that the
corresponding “Accept Order( )” method will get
executed successfully. Before guaranteeing this, the
“Accept Order( )” probably will check the current and
projected inventory. A negotiation bond is created
from consumer Web process to producer Web process.
This is the basic situation for deploying a negotiation
bond. Once order has been placed by the consumer and
accepted by the producer, a subscription bond serves
notice to “Dispatch Goods( )” method. Note that the
Web bonds are useful within a Web process as well.
Again before “Dispatch Goods( )” executes, it needs to
ensure that consumers “Accept Delivery( )” method can
be completed successfully (ensuring that enough space
is available, for example).

Invoke (S)
Execute (S)
Return response
Consumer Web
Process

Producer Web
Process

Mark (S)
Lock (S)
Partially Execute S
If successful
Response Yes
Else
Unlock (S)
Response No

Place Order ( )

Accept Order ( )
Subscription
Bond (SB)

Change (S)
Complete the execution of S
Unlock (S)

Negotiation
Bond (NB)

NB
Dispatch Goods ( )

Abort (S)
Restore (S)
Unlock (S)

Accept Delivery ( )

Figure 2. Coordinating Producer-Consumer Web
Processes

3. Modeling Dependencies Using
Coordination Bonds
The modeling and execution capabilities of Web
bonds can be illustrated through typical scenarios of
dependencies. In [25], authors have identified common
dependencies between activities such as shared
resources, task assignment, task/subtask and
producer/consumer. In this section, we illustrate how
such dependencies can be modeled using Web
coordination bonds.
3.1 Producer-Consumer Dependencies
Figure 2 shows how a classic relationship of a
producer and consumer Web process can be bonded
using two negotiation bonds. The “Place Order( )”
method at a consumer process needs to ensure that the

Figure 3 illustrates how multiple producer scenario
can be easily integrated with a consumer. “Call for
Bids (I, C)” is executed announcing solicitation of bids
(at least I, an installment, but no more than C, the
capacity). At all the producers, which have subscribed
to this method at the consumer, their “Place Bid( )”
method is activated. Those producers who are able and
willing to place bids successfully activate the “Select
Bid( )” method of the consumer. These two steps are
carried out by the subscription bonds as no negotiation
is needed. Once a successful bid of a Producer Pi has
been chosen, the subscription bond from “Select Bid(
)” is triggered, which activates the “Place Order( )”
method at the consumer, and the scenario as in the
previous paragraph gets carried out.

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

4

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

Producer
Web Process
P 1: Place Bid ( )

Consumer
Web Process
SB’s
Call For
Bids ( I, C )

P 2: Place Bid ( )

…. Bid ( )
P 3: Place
Producer Web

.

Select Bid ( )

Process P i

SB

PI : iPlace Bid ( )

Place Order ( I,C )

Pi : Accept Order ( )
SB

NB’s
Accept
Delivery ( )

Pi : Dispatch Goods (I
<= N <= C )

3.2 Shared Resource Dependencies
Modeling dependencies between competing entities
for a shared resource is natural to Web bonds. Figure 4
shows the bonds: The “Acquire( )” methods of
competing processes have a negotiation bond to the
“Allocate( )” method of the shared resource Web
process; unless “Allocate( )” can be guaranteed,
“Acquire( )” can not succeed. Note that “Allocate ( )”
will guarantee reservation/lock to only one requesting
process, say A, by creating a negotiation bond back to
A, while wait-listing B’s request (using a tentative
bond to back B). Subsequently A executes its “Release(
)” thereby de-allocating its reservation and thus
deleting the negotiation bond that was created from the
shared resource to A. This will change the tentative
bond to B into a confirmed bond, triggering a round of
negotiation with “Acquire( )” process of B.
3.2.1 A Meeting Example

Figure 3. Coordinating Multiple Producers with a
Consumer Web Process

Web Process A
Acquire ( )
NB
Release ( )
SB

Web Process B

NB

Shared Resource
Process
Allocate ( )

DeAllocate ()

The potential of Web-bond-like artifacts and their
utility in modeling and enforcing contracts among
competing Web Services can be further illustrated by a
calendar of meeting example. For this application, we
demonstrate here how an empty time slot is found, how
a meeting is setup (tentative and confirmed), and how
voluntary and involuntary changes are automatically
handled. A simple scenario is as follows: A wants to
call a meeting between dates d1 and d2 involving B, C,
D and himself. The first step is to find the empty slots
in everybody's calendar. A then clicks the desired
empty slot.
This causes a series of steps. A
negotiation-and bond is created from A's slot to the
specific slot in each calendar table (Figure 5).
A’s Calendar

Acquire ( )

B’s Calendar

SB
Release ( )

Figure 4. Modeling Resource Sharing among
Competing Web Processes

*

Back Negotiation
Bond

Forward Negotiation
Bond
D’s Calendar

C’s Calendar

Figure 5. Scheduled Meeting

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

5

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

Choosing the desired slot attempts to write and reserve
that slot in A's calendar, triggering the negotiation-and
bond. The “action” of this bond is as follows:
1. Query each table for this desired slot, ensure that
it is not reserved, and reserve this slot.
2. If all succeed, then each corresponding slot at A,
B, C and D create a negotiation bond back to A's
slot.
Else, for those folks who could not be reserved, a
tentative bond back to A is queued up at the
corresponding slots to be triggered whenever the status
of the slot changes. The forward negotiation-and bond
to A, B, C and D are left in place. Back subscription
bonds to A from others are created to inform A of
subsequent changes in the other participants and to
help A decide to cancel this tentative meeting or try
another time slot.
Assume that C could not be reserved. Thus, C has
a tentative back bond to A, and others have
subscription bonds to A (Figure 6). Whenever C
becomes available, if the tentative bond back to A is of
highest priority, it will get triggered, informing A of
C's availability, and will attempt to change A's slot to
be reserved. This triggers the negotiation-and bond
from A to A, B, C and D, resulting in another round of
negotiation. If all succeed, then corresponding slots are
reserved, and the target slots at A, B, C and D create
negotiation bonds back to A's slot (Figure 5). Thus, a
tentative meeting has been converted to committed.

A’s Calendar

B’s Calendar

*

Tentative Bond

Committed
elsewhere
Waiting
list

C’s Calendar
D’s Calendar

Figure 6. A Tentative Meeting

Now suppose, D wants to change the schedule for this
meeting. This would trigger its bond to A, triggering
the forward negotiation-and bond from A to A, B, C
and D. If all succeed, then a new duration is reserved
at each calendar with all forward and back bonds
established. If not all can agree, then D would be
unable to change the schedule of the meeting.

4. Middleware Support: System on Devices
(SyD) Middleware
Our SyD middleware is useful in enabling Web
Service view of heterogeneous entities as well as in
linking Web Services through coordination bonds.
4.1 SyD Design
SyD is a recently prototyped middleware for a
novel Internet programming methodology and a
framework for developing collaborative e-Service and
other applications executing over a collection of
independent, possibly mobile, and heterogeneous data
stores, leveraging off the best in object-oriented design
and middleware technologies [34, 35, 24]. Each data
store is encapsulated as a SyD Web Service/SOAP
object (even on a small mobile device employing a tiny
SyD listener), and multiple SyD objects can
collaborate in a p2p fashion using XML-based SOAP
messages. SyD uses the simple yet powerful idea of
separating device management from management of
groups of users and/or data stores. Each device is
managed by a SyD deviceware that encapsulates it to
present a uniform and persistent object view of the
device data and methods. Groups of SyD devices are
managed by the SyD groupware that brokers all interdevice activities, and presents a uniform worldview to
the SyD application to be developed and executed on.
All objects hosted by each device are published with
the SyD groupware directory service that enables SyD
applications to dynamically form groups of objects
hosted by devices, and operate on them in a manner
independent of devices, data, and underlying networks.
The SyD groupware hosts the application and other
middleware objects, and provides a powerful set of
services for directory and group management, and for
performing group communication and other
functionalities across multiple devices. Web bond is
one of the key enabling components of the SyD
framework. SyD coordination bonds enable
applications to create and enforce interdependencies
and constraints, and carry out atomic transactions
spanning over a group of SyD and non-SyD
entities/processes.

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

6

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

updates among groups of SyD entities and Web
Services applying Web bonds.

4.2 Prototyped Modules
We have designed and implemented a modular SyD
Kernel utility in Java. SyD Kernel includes the
following five modules (Figure 7). All inter-device
communication employes Web Service protocols with
underlying XML/SOAP/WSDL standards.

SyDEventHandler: This module handles local and
global event registration, monitoring, and
triggering.
We have used SyD Kernel and prototyped calendar of
meeting application [35] and a mobile fleet
management application [33].

SyDDirectory

SyDAppO

1. Publish
2. Lookup
SyD Server
Application
Object
(SyDAppO)

SyDAppO

T
C
P
1. Invoke /
I
P

SyD
Listener

2. Invoke
Client UI
SyD
Engine
1. Execute

3. Remote Invoke

SyDAppO

SyDAppO

.

5 Remote Invoke
4. Execute Bond
Method
SyDLink

SyDAppO

3. Web bond
Triggered
Event Handler

Figure 7. SyD Kernel Architecture and The
Interactions Between Module

SyDDirectory: Provides user/group/Service publishing,
management, and lookup Services to SyD users
and device objects. Also supports intelligent proxy
maintenance for users/devices.
SyDListener: Enables SyD device objects to publish
their services (server functionalities as a uniform
Web Service view) as “listeners” locally on the
device and globally via the directory Services. It
then allows users on SyD network to invoke single
or group Services via remote invocations
seamlessly (location transparency).
SyDEngine: Allows users to execute single or group
Services remotely via SyDListener and aggregate
results. This yields a basic composer of mobile
Web Services.
SyDLink: Enables an application to create and enforce
interdependencies, constraints and automatic

5. Relevant Literature
We briefly discuss some relevant work on
workflow models, Web Service composition, and
coordination theory without attempting to be
exhaustive. Web Service composition and defining
workflows over Web Services has drawn great deal of
attention from the research as well as business
community. Thus, there is already a large number of
workflow modeling languages and Web Service
composition standards.
Application of workflow
management systems (WFMS’s) spans large number of
application domains including business process models
[21], scientific applications [26], and health care
systems [45]. Among WFMSs, FlowManager [5] is an
open source system based on Petri nets. OpenFlow
[31] is another open source WFMS. IBM’s FlowMaker
[22], Xerox’s InConcert and Fugitsu’s Regatta are
commercially successful WFMS’s [3]. An extensive
treatment of classifying WFMSs can be found in [17].
The workflow management coalition (WFMC) was
formed in 1993 to set standard for WFMSs. In 1995,
WFMC released the reference manual for workflow
management systems [20]. One drawback of most
WFMSs is they are based on database concepts [3] [2]
using extended/ advanced transaction principles. They
have the luxury of utilizing rich database
functionalities to provide execution environment,
correction criteria and communication. Thus, they do
not have required functionality to cater to today’s
heterogeneous, autonomous, distributed computing
paradigm. Another drawback of most workflow
management systems is their inability to adjust
according to runtime environment and QoS parameters.
[43] presents a QoS-aware transaction-processing
model using our current work on SyD.
Among Web Service composition standards, IBM’s
WSFL (Web Service Flow Language) [42],
Microsoft’s XLANG [38], and Intalio’s Web Service
Choreography Interface [41] are popular. Most recently
released standard, Business Process Execution
Language for Web Services [40] combines the block
structured features from XLANG and graph structured
process model from WSFL. Most Web Service

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

7

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

composition languages have exploited The analogy
between Web Service composition and WFMSs. For
example, WSFL is very similar to IBM’s
FlowMark/MQ [22].
Development of Web Service composition
techniques has added a new dimension to the workflow
management systems over Internet [21, 16]. In [36],
authors have pointed out the importance of integrating
Web Services in to workflow management systems.
[30] describes possible workflow application domains
over the Internet. The model discussed in [21] is based
on ODBC connectivity for data access, thus preventing
the usage of heterogeneous data sources. As large
number of existing workflow models are based on
database concepts [3, 2], different approaches are
required to address issues that may arise from nondatabase Web Services environment.
Workflow and Web Service composition demand
proper coordination between different entities to yield
more efficient and effective output. Even if substantial
number of Web Service composition languages and
standards exists, till now there is no clear semantics to
define dependencies among Web Services. In [25],
authors pointed out that the field of coordination theory
consists of partial frameworks and scattered results. As
suggested in [1], it is necessary to critically evaluate
such standards and develop unambiguous methodology
to define Web Service composition. In [7], authors
have pointed out that the lack of fundamental
framework to develop such collaborative applications
has resulted in plethora of products and standards.
They have taken good initiative toward such
framework by identifying various interaction patterns
in Web Service composition. Research efforts such as
[19] and [4] try to define dependencies between
component models using category theory. Nonetheless,
much research work need to be done in this area.

6. Conclusion
Next generation of Internet applications will be
various kinds of collaborative applications among
heterogeneous, autonomous entities. In this paper, we
have introduced the concept of Web coordination
bonds. Web bonds extend the current Web Service
architecture. Web coordination bonds enable Web
Services to create and enforce interdependencies and
constraints, and carry out atomic transactions spanning
over a group of Web entities/processes. Much remains
to be done, including theoretical treatment toward
completeness of Web coordination bonds. Deploying
workflows over Web Services has become an
interesting research issue. However, such deployment
should be augmented by well defined coordination

techniques to make them efficient and effective. Web
Coordination bond could provide such techniques.

7. References
[1] W. M. P. Van der Aalst, “Generic workflow models:
How to handle dynamic change and capture management
information?,” In Proc. 4th IFCIS Intl. Conf. Cooperative
Information Systems (CoopIS'99), Edinburgh, Scotland,
September 2-4, 1999, IEEE Computer Society Press, pp. 115126.
[2] G. Alonso, C. Mohan, “Workflow Management: The
Next Generation of Distributed Processing Tools,” Chapter 2
in Advanced Transaction Models and Architectures, S.
Jajodia, L. Kerschberg (Eds.), Kluwer Academic Publishers,
1997.
[3] G. Alonso, D. Agrawal, A. E. Abbadi, M. Kamath, R.
Gunthor, and C. Mohan, “Advanced transaction models in
workflow contexts,” In Proc. 12th Intl. Conf. Data
Engineering, New Orleans, February 1996, IEEE Computer
Society Press, pp. 574-583.
[4] L. Andrade and J. Fiadeiro, “Coordination: The
evolutionary dimension," In Proc. 8th Intl. Conf. Technology
of Object-Oriented Languages and Systems (TOOLS’01)
Europe 2001, Zürich, Switzerland , March 12-14, 2001,
IEEE Computer Society Press, pp. 136-147.
[5] Lerina Aversano, Aniello Cimitile, Pierpaolo Gallucci,
Maria Luisa Villan, “FlowManager: A Workflow
Management System Based on Petri Nets,” In Proc. 26th
Intl. Computer Software and Applications Conference
(COMPSAC’02), August 26-29, 2002, Oxford, England,
IEEE Computer Society Press , pp. 1054-1059.
[6] A. Bajaj, S. Ram, “SEAM: A state-entity-activity-model
for a well-defined workflow development methodology,”
IEEE Transactions on Knowledge and Data Engineering,
Vol: 14 Issue: 2, Mar/Apr 2002, IEEE Computer Society
Press, pp. 415 –431.
[7] B. Benatallah, M. Dumas, M. C. Fauvet, F. A. Rabhi, and
Quan Z. Sheng, “Overview of Some Patterns for Architecting
and Managing Composite Web Services,” ACM SIGecom
Exchanges (3), August 2002, ACM Press, pp. 9-18.
[8] B. Benatallah, M. Dumas, M. C. Fauvet and F. A. Rabhi,
“Towards Patterns of Web Services Composition,” In
Patterns and Skeletons for Parallel and Distributed
Computing, Springer Verlag (UK), 2002.
[9] C. Bussler,, S. Jablonski, “Implementing agent
coordination for workflow management systems using active
database systems,” Proc. of 4t0 Intl. Workshop on Research
Issues in Data Engineering: Active Database Systems,
February 14-15 1994, Houston, Texas, IEEE Computer
Society Press, pp. 53 –59.

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

8

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

[10] Francisco Curbera, A. Nagy and Sanjiva Weerawarna,
“Web Services: Why and How”, IBM T.J Watson Research
Center, August 2001.
[11] A. Datta, S. H. Son, “A study of concurrency control in
real-time, active database systems,” IEEE Trans. on
Knowledge and Data Engineering, Vol:14 Issue:3, May/Jun
2002, IEEE Computer Society Press June 2002, pp. 465484.
[12] W. Derks, J. Dehnert, P. Grefen, W. Jonker;
“Customized Atomicity Specifica-tionfor Transactional
Workflows,” Proc. 3rd Intl. Symp. Cooperative Data-base
Systems for Advanced Application (CODAS 2001), Beijing,
China, April 23- 24 2001, IEEE Computer Society Press
2001, pp. 155-164.
[13] Johann Eder, Walter Liebhart, “The Workflow Activity
Model WAMO”, Proc. 3rd Intl. Conf. on Cooperative
Information
Systems,
May
9-12
1995,
Schloss
Wilhelminenburg Hotel, Vienna, Austria, pp 87-98.
[14] Johann Eder, Walter Liebhart, “A Transaction -Oriented
Workflow Activity Model”, Proc. of 9th Intl. Symp. on
Computer and Information Systems (ISCIS 9) Antalya,
Turkey, Nov 1994, pp. 9 - 16
[15] R. Eshuis, R. Wieringa, “Verification support for
workflow design with UML activity graphs,” Proc. of 24th
Intel. Conf. Software Engineering, (ICSE‘02), Orlando,
Florida, USA , May 19-25, 2002, ACM Press, pp. 166 176.
[16] Yang Guangxin, Shi Meilin, Xiang Yong, Wu
Shangguang , “Wowww! :managing workflow on the World
Wide Web,” In Proc.
Intl. Conf.
Communication
Technology (ICCT '98), Oct 22-24, 1998, IEEE Computer
Society Press, pp. 1- 5.

[21] S. H. S. Huang, “Building business processes using a
state transition model on World Wide Web ApplicationSpecific Software Engineering Technology,” In Proc. 1st
IEEE
Workshop
on
Application-Specific
Software Engineering and Technology (ASSET'98),
Richardson, Texas, 26-28 Mar , 1998, IEEE Computer
Society Press, pp. 2 -7
[22] “IBM MQSeries Workflow Concepts and Architecture
Version 3. 1,” IBM Danmark A/S GH12-6285-00 , July
1998.
[23] Frank Leymann, "Web Services Flow Language (WSFL
1.0)." IBM Software Group, May 22, 2001.
[24] Vijay Madisetti, “SyD: A middleware infrastructure for
mobile
iAppliance
devices,"
EE
Times
Network,http://www.iapplianceWeb.com/story/OEG2002110
5S0031, November 5, 2002.
[25] T. W. Malone, and K. Crowston, “The interdisciplinary
study of coordination,” ACM Comput. Surv. Vol:26 Issue:1,
1994, pp. 87-120.
[26] J. Meidanis, G. Vossen, M. Weske, “Using workflow
management in DNA sequencing,” In Proc. 1st IFCIS Intl.
Conf. Cooperative Information Systems (CoopIS'96), June
19-21, 1996, Brussels, Belgium, IEEE Computer Society
Press, pp. 114-123.
[27] “Microsoft BizTalk Orchestration,” White
Paper,http://www.microsoft.com/biztalk/techinfo/biztalkorch
estration.htm, july 1999.
[28] C. Mohan, G. Alonso, R. Guenthoer, M. Kamath.
“Exotica: A Research Perspective on Workflow Management
Systems,” Data Engineering Bulletin (Special Issue on
Infrastructure for Business Process Management), Vol. 18,
No. 1, March 1995, IEEE Press, pp. 19-26.

[17] Paul Grefen, “Transactional workflows or workflow
transactions,” In Proc. 13th Intel. Workshop on Database
and Expert Systems Applications (DEXA 2002), September
02-06, 2002, Aix-en-Provence, France, LNCS 2453,
Springer-Verlag Berlin Heidelberg, pp. 60-69.

[29] C. Mohan, “Recent Trends in Workflow Management
Products, Standards and Research,” NATO ASI Series, Series
F: Computer and Systems Sciences, Volume 164, Springer
Verlag, pp. 396-409.

[18] X. Gu and K. Nahrstedt, "Visual Quality of Service
Programming for Distributed Heterogeneous Systems,"
Technical Report UIUCDCS-R-2000-2190, Univ. of Illinois
at Urbana-Champaign, Nov.2000

[30] C. Mohan, “Workflow Management in the Internet
Age,” Advances in Databases and Information Systems,” In
Proc. 2nd East-European Symp. Advances in Databases and
Information Systems (ADBIS'98), Poznan, Poland, September
1998, LNCS vol:1475 pp. 26-34.

[19] Jiang Guo, “Using Category Theory to Model Software
Component Dependencies,” Proc. 9th Annual IEEE Intl.
Conf. and Workshop on the Engineering of Computer-Based
Systems (ECBS 2002) , April 08 - 11, 2002 ,Lund, Sweden,
IEEE Computer Society Press, pp. 185-194.
[20] Hollingsworth D. “Workflow Management Coalition:
The Workflow Reference Model,” The Workflow
Management Coalition, Doc. No. TC00-1003, Issue 1.1,
Brussels, 1994.

[31] “OpenFlow
http://openflow.net/

Workflow

Management

System”

[32] Norman W. Paton, Oscar Diaz, “ Active Database
Systems,” ACM Computing Surveys, Vol. 31, No. 1, March
1999, pp 63 - 103.
[33] S. K. Prasad, M. Weeks, Y. Zhang, A. Zelikovsky, S.
Belkasim, R. Sunderraman, and V. Madisetti., "Mobile Fleet
Application Using SOAP and System on Devices (SyD)
Middleware Technologies," In Proc. Conf. Communications,

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

9

Proceedings of the 37th Hawaii International Conference on System Sciences - 2004

Internet and Information Technology (CIIT 2002), St.
Thomas, Virgin Islands, USA, November 18-20, 2002, pp.
426-431.
[34] Sushil K. Prasad, et al. “Enforcing Interdependencies
and Executing Transactions Atomically Over Autonomous
Mobile Data Stores Using SyD Link Technology,” In Proc.
Mobile Wireless Network Workshop held in conjunction with
The 23rd Intl. Conf.
Distributed Computing Systems
(ICDCS'03), May 19-22 2003, Providence, RhodeIsland,
IEEE Computer Society Press, pp. 803 –811.
[35] Sushil K. Prasad, et al. “Implementation of a Calendar
Application Based on SyD Coordination Links,” In Proc. 3rd
Intl. Workshop Internet Computing and E-Commerce in
conjunction with the 17th Annual Intl. Parallel &Distributed
Processing Symp. (IPDPS 2003) , 22-26 April, Nice, France,
IEEE Computer Society Press, pp. 242.

[44] Kam-Yiu Lam, Lee, T.S.H., Son, S. H. “READS: a
prototyping environment for real-time active applications,”
In Proc. 8th Intl. Workshop Database and Expert Systems
Applications, Toulouse, France , 1-2 Sep 1997, IEEE
Computer Society Press, pp. 265 –270.
[45] F. Yousfi, Bricon-Souf, N., Beuscart, R., Geib, J.M.
“PLACO: a cooperative architecture for solving coordination
problem in health care,” In Proc. IEEE 17th Annual Conf.
Engineering in Medicine and Biology Society, Sep 20-25,
1995, Vol: 1 pp. 747 –748.
[46] Hai Zhuge Pung, H.K., Cheung, T.Y., “Timed
workflow: concept, model, and method,” In Proc 1st Intl.
Conf. Web Information Systems Engineering, 2000. Vol:1,
pp. 183 –189.

[36] Gunter Preuner, Michael Schrefl, “Integration of Web
Services into Workflows through Multi-Level Schema
Architecture,” In Proc. 4th IEEE Intl. workshop on Advanced
issues of E-Commerce and Web-based Information Systems
(WECWIS’02), 26–28 June ,2002 , Newport Beach, CA,
IEEE Computer Society Press, pp. 51-60.
[37] Steffen Staab, Wil van der Aalst, V. Richard Benjamins,
Amit Sheth, John A. Miller, Christoph Bussler, Alexander
Maedche, Dieter Fensel, Dennis Gannon, “Web Services:
Been There, Done That?,” IEEE Intelligent Systems, Jan/Feb
2003, IEEE Computer Society Press, pp. 72-85.
[38] S. Thatte, “XLANG: Web Services for Business Process
Design," http://www.gotdotnet.com/team/xml wsspecs/xlangc/default.htm, May 2001.
[39] S. Müller-Wilken, F. Wienberg, W. Lamersdorf , “ On
Integrating Mobile Devices into a Workflow Management
Scenario,” In Proc. 11th Intl. Workshop on Database and
Expert Systems Applications (DEXA'00), September 06 - 08,
2000 ,Greenwich, London, U.K., IEEE Computer Society
Press, pp. 186-192.
[40] P. Wohed, W.M.P. van der Aalst, M. Dumas, and
A.H.M. ter Hofstede,
“ Pattern based analysis of
BPEL4WS”, Technical Report FIT-TR-2002-04, QUT,
Queensland University of Technology, 2002.
[41] W3C “Web Service Choreography Interface (WSCI)
1.0,” http:// www.w3.org/TR/wsci/, November 2002.
[42] IBM Corporation, “Web Services Flow Language
(WSFL1.0)", http://www-4.ibm.com/softwware/solutions/
WebServices/pdf/ WSFL.pdf, May 2001.
[43] Wanxia Xie , Shamkant B. Navathe, Sushil K. Prasad.
2003. "Supporting QoS-Aware Transaction in the
Middleware for a System of Mobile Devices (SyD)," In
Proc. Mobile Distributed Computing Workshop held in
conjunction with The 23rd Intl. Conf. Distributed Computing
Systems (ICDCS'03), May 19-22 2003, Providence,
RhodeIsland, IEEE Computer Society Press, pp. 498-502.

0-7695-2056-1/04 $17.00 (C) 2004 IEEE

10

Services Utility Prediction On a Cloud
W ei- Tek Tsai*+, Peide Zhong', J anaka Balasooriya*, Yinong Chen*, Xiaoying Bai+
*School of Computing, Informatics, and System Engineering, Arizona State University, Tempe, U.S.A.
"Department ofComputer Science and Technology Department, Tsinghua University, Beijing, China
Peide.Zhong@asu.edu
Abstract-Cloud computing and Software-as-a-Service
(SaaS) are being widely applied. In the near future, there
will be many cloud services providing similar services. One
of the issues is to dispatch service requests to available
services dynamically so that service requests can be served
in the most effective and efficient way. This paper proposes
an algorithm that efficiently serves requests for services by
predicting the number of services needed. Furthermore, a
cloud architectural framework to support the algorithm and
prediction model is introduced. The paper also presents a
simulation study to validate the algorithm proposed.
Keywords- Cloud computing, software-as-a-service (SaaS),
Service, Prediction

1. INTRODUCTION
Cloud computing and Software-as-a-Service (SaaS) are
becoming the main platform for hosting and the service
provision of data and computing applications. Leading
cloud computing projects include Microsoft's Azure [1],
Google's App Engine [2], and Amazon's EC2 [3]. Cloud
computing has the potential to provide benefits such as
cost effectiveness, dependability, scalability, and
performance. The bases of cloud users as well as the
services deployed on clouds have been increasing
dramatically in the recent year. One possible scenario is a
large number of users requesting the same or similar
services, resulting in a single cloud service cannot serve
all these requests simultaneously. On the other hand, user
requests may have time constraints. It is important to
match user's service and performance requests with
service capability and capacity. In traditional SOA, it is
difficult to solve the scheduling problem when service
requests proliferate suddenly. It is not easy to find an
available service so that can relieve the burdened service,
as it is difficult to judge if the two services can provide
the same service. It is impossible to fmd a global schedule
solution to make use of all services that provide the same
or similar functionality. In a cloud, service interface and
its implementation can be separate, so that user requests
for services [4-6] can be dispatched to different instance
services based on the same interface. Services interface
information can be organized as domain ontology. In this
way, the cloud can manage similar instance services and
their load balance. As a unified environment, cloud
computing can solve the problem. If the cloud knows how
many services will be needed, the cloud can easily predeployed sufficient services, as it is difficult to perform

dynamic service deployment. Thus, this paper proposes a
service request prediction model to estimate the service
workload and how many services will be needed when the
user arrival rate is taken into consideration. This paper
studies the following issues:
• Design of a service request dispatching framework
(SRDF) for service requests;
• A service selection algorithm to estimate the least
number of services can serve certain user requests;
• A service prediction model that considers the
requests' arrival rate;
• A simulation is performed to evaluate the proposed
prediction models.
This paper is organized as follows. Section 2 presents the
related work. Section 3 introduces a new service request
dispatching framework. Section 4 discusses service
requests dispatching algorithm based on the service and
service number prediction model. Section 5 presents the
simulation results. Section 6 concludes the paper.
2. RELATEDWORK
Gale-Shapley proposed an algorithm [7] to solve stable
marriage problem which is similar to the problem
discussed in this paper. However, the Gale-Shapley
algorithm assumed that number of women must be same
as the number of men. On the other hand, in a cloud, the
number of user requests can be much larger than that of
services. Second, women and men stable marriage
problem is not related to timing issue while user requests
often have timing constraints. This paper extends the
stable marriage algorithm so that it accommodates
constraints mentioned.
Interval Scheduling problem presented in [7] was also
similar to the problem described in this paper. Interval
Scheduling finds the maximum compatible jobs for a
machine so that selected jobs do not have time intervals
among them. However, it considers selecting fitting jobs
from a large volume of jobs to one machine only, while
this paper focuses on dispatching all user requests to
many services in the cloud. Each machine can operate one
job at a time while a service can serve many users at the
same time.
3. SYSTEM ARCHITURE
This section discusses the system architecture that
supports service utility prediction models described in

section 5. The overview of the system architecture is
shown in Fig. 1.

Figure 1. System Architecuture

The system architecture has three layers:
• Service Layer. This layer contains services. These
services may be provided by SaaS [8] providers, or by
providers of individual services not bundled as a SaaS
application, and they are hosted on PaaS or laaS.
• PaaS: This layer is used to provide fundamental
services used by SaaS.
• laaS [9]: This layer virtualizes hardware and provides
computation, networking and storage resources as
services.
In PaaS, some important services are described in [4].
They can be described as following:
• Gateway Service (GS): It plays same role as gateway
plays on the normal servers.
• Request Distribution Service (RDS): The RDS mainly
focuses on how to dispatch each user request to similar
services. The algorithm described in section IV can be
used here.
• Domain Ontology Service (DoS): It is in charge of
create, delete and update information in the domain
ontology, used to organize Interface Service (IntS),
test scripts, test cases and mapping between IntS and
the Instance Service (Ins S) as discussed in [4]. IntS is
used to describe service interface including methods
name, input-output parameter and, etc.
InsS
implements IntS used directly by users while IntS
cannot, which it must be mapped to one of its
implementations InsS .
• ESB Service: ESB is used to connect abstract services
to their instances.
• Cloud Management Service (CMS): CMS is used to
charge the process of service utility prediction in
section V part C. It also monitor the running of InsS.
If there is one InsS does not work well, it is CMS that
find a substitution to replace this InsS.
• Replication Service (RS): This handles service
replication. It can be implemented by two ways:
o Dynamic Service Replication (DSR): Services will
be dynamically replicated and deployed as
determined by CMS.

o Pre-deployed Service Replication (PSR): Services
are pre-deployed on the servers. Services remain in
a hibernating state when they are not processing
requests.
The service utility prediction process is illustrated in Fig.
2. The steps are explained as follows:
CD Users submit their requests to the cloud and cloud calls
the SNCS to estimate the number of services needed. The
algorithm in section 4 will be used.
@ SNCS returns the estimation to the next step to decide
if current InsS can satisfy user requests.
® The cloud will calculate the number of InsS available
to be used for user requests.
® DOS will be used for counting the number of InsS
exist in the cloud. As DOS maintains one-to-many
relations to InsS, it is easy to count their numbers by
estimating these relationships.
® The cloud will make a test request to each selected
InsS to make sure that they can be properly used.
® After the cloud obtains the number of InsS, it will
compare this number with the number from step CD. If it
is not satisfied, the cloud will ask CMS and RS to do
service replication and deployment.
(J) Replicated service information will be returned to RDS
for further processing.
@ RDS will match each service requests to fit services
by using the algorithm in section 4.
® Each user's service request is dispatched to fit service.
The result from the service will be returned to each user.
4. CLOUD SERVICE PREDICTION ALGORITHM
The regular information of user request can be received
from historical data. However, there are many other users
who use the service casually. Predicting their behavior
can be an issue. The following assumptions are made in
this paper:
• Users' service requests are independent of each other,
and they do not affect each other.
• Users' arriving rate conforms to a Poison distribution
and arriving rate can be predicted by average the
history information.
• Each cloud service is independent, and they do not
interfere with each other.
• The time that each service serves user requests
conforms to a negative exponential distribution and this
is normal as handling user requests needs more time if
service is already dealing many service requests.
Fig.2. illustrates a type of a scenario in which considering
user requests arriving rate. Here, we assume
• Service requests arrive at a rate that conforms to the
A Poison distribution in equation (1).
• The time that user requests can be fmished conforms
to exponential distribution J.1
•

There are N services can be used at any given time.

•

Each service can serve m user requests at any given
time. Here, each service is assumed to serve the same
user requests at the same time.

As service can normally serve more than one request on
the cloud at same time, n < N is impossible. So, the
probability of having n users' service requests can be
decided by p = pnFa . Here, we assume one service can
n Nn-N N!
serve m service requests at most. If the probability P; that
is less than a certain number p and p is small enough, each
service request can be properly served, which P, < P: For
example, p can be 0.1 %. Combining equation (3), the
inequality (4) can be got.

pnp
----.,;;,o-<p······(4)
Nn-NN!
Inequality (4) can be transformed to inequality (5) easily.
N-l pi
pN
p"
Nn-NN!(L-+
»_······(5)
i=O i! N!(I-p/N)
P
As N is a natural number and mmnntzmg number of
services as small as possible is needed, N is the smallest
natural number that can satisfy inequality (5). It can be
calculated by following algorithm.

Figure 2. Process of Service Utility Prediction

P(n) =

(Atf e- At

(1)

n!

Algorithm 1: Service prediction and service request scheduling algorithm
Input: A, the arriving rate of service requests; JJ, serving rate of each
service; m, the number of service requests that a service can serve
at same time; n, the total number of service requests; I, the list of
service request requirements
Output: N, the number of services is needed; the schedule of each
service S
1

pen) = probability of exactly n service

2 W

3

requests arriving over time t
n = number of service requests arriving

over time t

4.
8

A = average arrival rate

6

t = duration of time over which service

requests are counted

1

Fa = N-l i N · · · · · · (2)
L~+--P-i=O i! N!(l- pi N)

p
N < l,p

=-;;A

Probability of having n service requests can be presented
in equation (3).

p

n

==

p ==

n

pnFa
,
n.

for n

pnPo
Nn-NN!

T
8
9

From these assumptions, one can see service requests and
services become an M/M/N queue model. N is the number
of services that can serve service requests. Thus, the
probability of having no service requests can be described
in equation (2).

<N
...... (3)

for n ~ N

N

10
11

= 0;

hil

Nn-N N

e

L N++;

*

""n-1'. + N:.(1-})
~

!*(L...c=o
p'fJ.

1

<P

d

0

/ / calculate the number of services is needed by using the
prediction model 'Where p = %
List< service > S = new List-c service > 0;
while l is not empty do
take out a service u request from 1;
find a service k with the least load;
while k is not compatible with 'U do
find a different service k with the least load;

l

L

S[k].add (u); II schedule u to service k;

return N and S; / / S is the list that contains the schedule of
each s ervi ce

As we have already discussed that N is the mmnnurn
number of services we need to guarantee that all service
requests can be properly handled with confidence (1 - p),
we can decrease the number N if we increase p, which
means to reduce the confidence. The complexity of the
algorithm can be analyzed as follows:
• The first while loop can iterate N times while N is
much smaller than n, the number of users' service
requests.
• The second while loop can iterate n times, and the third
while loop can iterate N times at most. Thus, the total
cost of the second and third while loop is n*N at most.
• The complexity of this algorithm is O(n*N), which is a
polynomial algorithm.

Figure 3. Service Scheduling with service requests arrive rate

consideration

5. SIMULATION
To illustrate the service utility model proposed in
section 5, the simulation is conducted. Two sets of
parameter data are used to demonstrate the effect of
number, m, of serve requests that one service can serve at
same time, which they are:
a. A = 0.8, f.l = 0.1, P = 0.1, m = 2. The result is
illustrated as Fig 4.
b. A = 0.8, f.l = 0.1, P = 0.1, m = 3. The result is
presented as Fig 5.
• In Fig. 4, there are two user requests that have been
discarded.
• Comparing to first set of parameters' data, only one
parameter is changed in the second set.
• From the analysis above, we see if A, fl and p are fixed,
and we want to reduce the rate of discarding service
requests, we can increase the number of m that is the
number of user requests that each service can handle at
same time, as shown in Fig. 5.
We can also adjust fl and p to decrease the number of
discarding service requests. In general, this simulation
shows our utility model in section 4 works well.

Figure 4. Simulation Result for First Set of Parameter Data

Figure 5. Simulation Result for Forth Set of Parameter Data

6. CONCLUSION
In cloud computing, dispatching user requests to a
suitable service is an important problem. This paper
proposed a service utility prediction model to schedule the
user requests and estimate the number of service needed
based the service requests arrival rate. A framework was
designed to support the model. The model was evaluated
by simulation to demonstrate its effectiveness.
ACKNOWLEDGMENT

This project is sponsored by U.S. National Science
Foundation DUE 0942453, and Department of Defense,
the European Regional Development Fund and the
Government of Romania under the grant no.
181 of 18.06.2010. This work is also supported by the
National Natural Science Foundation of China under
Grant No. 61073003, and the National Grand
Fundamental Research 973 Program of China under Grant
No.2011CB302505.

REFERENCES
[1]
[2]
[3]
[4]
[5]
[6]

[7]
[8]
[9]

Microsoft, "Azure," http://www.microsoft.com/WindowsAzurel.
Google, "App Engine," vol. http://code.google.com/appengine/.
Amazon, "EC2," http://aws.amazon.com/ec2/.
W. T. Tsai, et al., "Preference Based Service Request Dispathing
On the Cloud," Submitted to the 7th International Conference on
Services Computing, 2010.
W. T. Tsai, et al., "Optimal Service Replication Strategies for
MapReduce On the Cloud," The International Symposium on
Autonomous Decentralized System (ISADS), 2011.
W. T. Tsai, et al., "Ontology-Based Dependency-Guided Service
Composition for User-Centric SOA," Submitted to the 22nd
International Conference on Software Engineering and Knowledge
Engineering, 2010.
J. Kleinberg and E. Tardos, Algorithm Design Addison Wesley,
March 26, 2005.
Y. Chen, W.T. Tsai, Service-Oriented Computing and Web
Software Integration, Third Edition, Kendall/Hunt Publishing,
2011.
W.
contributors,
"Infrastructure
As
a
Service,"
http://en.wikipedia.org/w/index.php?title=Infrastructure_as_a_serv
ice&0Idid=341154594, 2010.

Toward Fundamental Primitives and Infrastructure Enhancements for
Distributed Web Object Coordination and Workflows1
Janaka Balasooriya and Sushil K. Prasad
Georgia State University, Atlanta,30303
sprasad@gsu.edu
Abstract
We envision users discovering suitable web objects
and configuring them on-the-fly with their desired
high-level application logic, with the programming
and deployment carried out entirely on the web. Easy
configurability and interplay of web entities implies
evolution of a few common sense, yet powerful set of
core primitives for effective coordination, akin in
simplicity and strength to the HTTP protocol. Current
web services technology lacks Infrastructure support,
theoretical sound fundamental framework for web
services coordination and composition, and easy use
tools for web application development. Our Web
Coordination Bond system gears towards finding
solutions to aforementioned research challenges.

1. Introduction
Collaborative applications over web span domains as
diverse as enterprise e-commerce applications,
personal applications, and scientific biomedical
applications. Therefore, to find methodologies to
empower one and all to rapidly develop and deploy
robust collaborative applications is required. However,
current status of web service (object) coordination and
composition is a frenzied effort by many to shell out
myriad of ever-richer protocols and languages for web
service collaboration, suitable only for domain experts,
without substantial fundamental theoretical framework.
Moreover, web services are stateless, passive entities in
such composite applications requiring centralized
coordinator process to handle all the functionalities
from application logic to transaction management [5].
This makes such application development a tedious
limiting to experts. Furthermore, centralized
coordination is not desirable for highly distributed and
pervasive environment such as the Internet. Therefore,
we propose to explore (i) a fundamental set of bonding
primitives/artifacts, which are necessary and sufficient
in expressiveness and semantics, (ii) enhancements to
web service infrastructure to easily employ those core
artifacts, and (iii) a development and deployment
1

platform to configure distributed collaborative
applications over web services of interest.
We have proposed web coordination bonds as a
potential candidate for a set of core artifacts for web
service coordination/choreography [2]. Section 2
illustrates the ideas of web coordination bonds. Section
3 introduces the concept of
Web Process
Architecture, which is a simple but powerful
enhancement to the web services infrastructure that
makes web services stateful, coordination and
transaction aware capable enteritis. Section 4 describes
our BondFlow [5] system, which is a development and
deployment platform for collaborative distributed
applications over web objects including web services.

2. Web Coordination Bond Concepts
Web bonds have been born out of our experience
with developing several collaborative peer-to-peer
distributed web applications using our System on
Mobile Devices (SyD) middleware [1]. Web bonds
enable web services to create contracts between entities
and enforce interdependencies and constraints, and
carry out atomic transactions spanning over a group of
web entities/processes. There are two types of web
bonds: subscription bonds and negotiation bonds.
Subscription bonds allow automatic flow of
information and control from a source entity to other
entities that subscribe to it. This can be employed for
synchronization as well as more complex changes,
needing data or event flows. Negotiation bonds
enforce dependencies and constraints across entities,
and trigger changes based on constraint satisfaction [1,
2].
Modeling power and expressiveness of web
bonds: We have established that web bonds have the
modeling power of extended Petri nets (A Petri net
with inhibitor arcs) and the expressive power to model
all the benchmark patterns for workflow and for interprocess communication; feat that almost all previously
proposed artifacts and languages are not capable of
comprehensively, thus proving that web bonds are
superior despite their simplicity [2].

Two papers on web coordination bonds have been published. Please see reference [2].

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

Towards a core set of artifacts: Our current
research effort gears towards evaluating web service
composition and coordination technologies including
XL, BPEL4WS, DAMS-L, WSCI, WS-Transaction,
WS-Coordination, Petri-net, and Process algebra to
extract the essential core set of artifacts. Here, we
adopt the evaluation criteria (listed below) for
expressiveness of workflow languages described in [3].
The objective is to investigate closely how far those
criteria have been met and also to identify new
benchmark parameters that may need to define due to
unique nature of WWW.
a) Control flow (dataflow also): Activity execution
order (Workflow control flow patterns), optional tasks
and alternatives, time constrains and triggers.
b) Communication patterns (need for long-lived
coordination)

systems appeared in the form of web services with
WSDL interface. This reduced the house keeping work
from the application developer. However, individual
web services, encapsulating information and data
stores, with its access methods described using Web
Service Description Language (WSDL), lacks even the
basic management system (Figure 2a), not to mention
any support for transactions, composition, or
workflows. Application programmer has the burden of
capturing almost all the coordination logic. From this
perspective, web services infrastructure is still in its
early developmental stage.

3. Infrastructure Support

4. Application Development and Execution

Figure 1 illustrates the evolution of database
technologies from simple file system to a three-tier
system, equipped with layers to manage the database,
user interface, and workflows, progressively reducing
the burden of application development. In early 60’s,
application developer had the burden of capturing all
the logic of data manipulation, constraint checking,
concurrency control and many more (Figure 1a). With
the introduction of database management systems
(DMBS), most of the data handling functionalities
have been transferred to DBMSs. Development of
various
middleware
technologies,
workflow
management systems (WFMS), and user interface
development tools (UIMS) further reduces the burden
of application developer (Figure 1b).

Our BondFlow system, which is based on the
concept of web coordination bonds, provides an
environment for configuring and executing workflows
on the fly over heterogeneous web objects including
web services [5]. Users of the BondFlow system can
configure their workflow by selecting suitable web
services and bonding them using web coordination
bonds to enforce dependencies. Workflow coordination
architecture of the BondFlow system is inherently
distributed [5].

UIMS
APPL

APPL
Application

WFMS
DBMS

File
Filesystem
system
(a): File
systems

DB
(b): 3-Tier
(d):
-Tire
database
applications

APPL
APPL
WSCMS
WSCMS: Web
Service
Coordination
Web service Management
System
WSMS: Web
(a) 1- Tier web Service
Management
applications
System
WSDL

WSMS
Web Service
(b): 3-Tire
(d):
3-Tier
web service
applications

Figure 2. Proposed
enhancements for
web service
infrastructure
Analogously, web server based application and first
stage database applications have similar characteristics.
Application programmer has the burden of capturing
all the application logic as well as house keeping tasks.
However, later stage, akin to DBMS web server based
Figure 1. Evolution
of database
infrastructure [4]

Therefore, to address these issues we propose to
enhance the web service infrastructure so that it has a
Management System for web services (WSMS) akin to
DBMS and a Coordination Management system for
web services (WSCMS) akin to WFMS (Figure 2b).

5. References
[1] Sushil K. Prasad, V. Madisetti, et al. System on Mobile Devices
(SyD): A Middleware Testbed for Collaborative Applications over
Small Heterogeneous Devices and Data Stores, In Proc.
ACM/IFIP/USENIX 5th Intl. Middleware Conf., Toronto, Oct, 2004.
[2] Sushil K. Prasad and Janaka Balasoorya, 2005, “Fundamental
Capabilities of Web Coordination Bonds: Modeling Petri Nets and
Expressing Workflow and Communication Patterns over Web
Services “, In the Proc. HICSS-38, Big Island.
[3] Julian Jang, Alan Feteke, Paul Greenfield, Dean Kuo
“Expressiveness of Workflow Description Languages” proc. of
ICWS’03, June, 2003, Las Vegas, Nevada, USA, pp. 104-110.
[4] W. M. P. van der Aals, “The Application of Petri Nets to
Workflow Management,” Journal of Circuits, Systems and
Computers, Vol. 8, No. 1, 1998, pp. 21-66.
[5] Janaka Balasooriya, Mohini Padye , Sushil K. Prasad, and
Shamkant B. Navathe “BondFlow: A System for Distributed
Coordination of Workflows over Web Services,” In Proc. 14th HCW
in conjunction with IPDPS 2005. Denver, Colorado, USA, April 4.

Proceedings of the IEEE International Conference on Web Services (ICWS’05)
0-7695-2409-5/05 $20.00 IEEE

2011
2011Tenth
10th International
InternationalSymposium
Symposiumon
onAutonomous
AutonomousDecentralized
DecentralizedSystems
Systems

An Approach for Service Composition and Testing for Cloud Computing
Wei-Tek Tsai1,2, Peide Zhong , Janaka Balasooriya , Yinong Chen , Xiaoying Bai , Jay Elston
1

1

1

2

1

1

School of Computing, Informatics, and Decision System Engineering
Arizona State University
Tempe AZ 85287
2
Department of Computer Science and Technology, Tsinghua University, Beijing, China 100084
E-mail: Peide.Zhong@asu.edu
selecting service implementations. Thus, this paper proposes
service injection as a way to allow developers to designate
specific service implementations. In addition, the paper
elaborates the process of service testing with service
composition.
As service providers publish their services in clouds,
many of them will implement the same service specifications
and interfaces. If users use those service interfaces to
compose a workflow, there can be many possible
combinations. For example, in Figure 1, if a workflow uses n
interfaces, and each interface has m implementations, the
number of combinations becomes mn and this number can be
huge. Therefore, testing them quickly is challenging. This
paper proposes a voting mechanism based on service-level
MapReduce [1] to expedite the testing process.
This paper addresses following issues:
• To allow the service composition mechanism in [3] to
designate specific service implementations;
• To develop the testing mechanism for the workflow used
in service composition; and
• To study the parallel testing technique to accelerate the
testing process when the number of services
combinations for the workflow is large.
This paper is organized as follows. Section II presents the
related work. Section III introduces background of service
management and composition on the cloud. Section IV
discusses our approach in concurrent testing and service
composition. Section V gives a case study on a shipping
domain service composition system. Section VI presents
conclusions and future directions.

Abstract— As cloud services proliferate, it becomes difficult to
facilitate service composition and testing in clouds. In
traditional service-oriented computing, service composition
and testing are carried out independently. This paper proposes
a new approach to manage services on the cloud so that it can
facilitate service composition and testing. The paper uses
service implementation selection to facilitate service
composition similar to Google’s Guice and Spring tools, and
apply the group testing technique to identify the oracle, and
use the established oracle to perform continuous testing for
new services or compositions. The paper extends the existing
concept of template based service composition and focus on
testing the same workflow of service composition. In addition,
all these testing processes can be executed in parallel, and the
paper illustrates how to apply service-level MapReduce [1]
technique to accelerate the testing process.
Keywords: Cloud, Software as a Service (SaaS), Service
Composition, Workflow, and Testing.

I.

INTRODUCTION

As cloud computing proliferates, service composition and
testing for cloud applications bring new challenges. In
traditional Service-Oriented Computing (SOC), service
directory UDDI [2] is used to organize services information
and help providers to discover service. BPEL and OWL-S
are commonly used languages in service composition,
However, they do not consider testing of composed services.
Often, service composition and testing are distinct processes.
In [3], a template-based service composition is proposed
where service composition and testing are carried out in an
integrated manner. Also, in cloud computing, continuous
testing is proposed with testing in every stage of application
development and composition [4, 5].
A service has its specification, interface (such as input
and output), and implementation. Each service specification
defines an interface and the functionality, as well as
nonfunctional, of implementations. Note that multiple
implementations may implement one service specification.
A service interface describes the input/output information
and thus it cannot be executed. Domain ontology can be used
to organize and manage service specifications and interfaces,
and maintain one-to-many relationships to service
implementations. One way of service composition to design
a workflow with service specifications, and let the cloud
platform choose fit service implementations. Developers use
service interfaces to perform service composition and let the
cloud to discover the matching service implementations .
However, a developer may prefer to have more control in
978-0-7695-4349-9/11 $26.00 © 2011 IEEE
DOI 10.1109/ISADS.2011.90

II.

RELATED WORK

It is important to test cloud services to provide valid and
stable services for cloud users. In [6], an ontology-based
approach for web service testing is proposed, where a test
ontology model was used to define test concepts,
relationships, and semantics. In [7], a model-based adaptive
test (MAT) that can select and rank test cases to eliminate
redundant testing is proposed. The technique can be used to
test a group of software artifacts that implement same
specification.
Ontology is often used for knowledge representation,
sharing, classification, reasoning, and interoperability.
Ernestas and Lina [8] proposed a method of transforming
ontology representation in OWL to relational database and
developed algorithms that transform domain ontology to
relational database. Bianchini and Antonellis [9] presented
an ontology design approach called VISPO (Virtual-district
629
637
633
631

Internet-based Service Platform) that supported knowledge
sharing and service composition in virtual districts. In [10],
Woo and Radhika presented a task dependency approach for
web service composition driven by business rules statically.
In [3], domain ontology is used to organize service
interfaces (SInt) and one-to-many relations to service
implementations (SImp) and their use scenarios that is a
semi-formal specification of how the system can be used by
other systems [11]. Users can utilize service interfaces to
compose workflow applications and use scenarios, which
depends on how to map this service interface workflow to
implementations or to use scenarios. If it is mapped to
service implementations, it becomes a composite service.
Otherwise, it becomes a use scenario to drive composite
service testing with test input. By this way, service
composition and testing can share the same workflow.
However, this approach does not detail how to perform
testing. This paper extends the techniques in [3] and uses
group testing technology in [12] to do test the workflow.
Service composition is important in SOA and cloud
computing. Many service composition approaches are
available
including model-based approaches [13-15],
semantic-based
approaches
[16-18],
template-based
approaches [19, 20], and QoS-driven approaches [21-23].
Among cloud service composition approaches proposed, [24]
described an ontology-based dependency-guided service
composition approach for user centric SOA and applied this
approach to the cloud in [3]. The SRDF framework
presented in [24] proposed a domain ontology to manage
service interfaces. Users can employ these service interfaces
to do service composition, which it is the cloud’s
responsibility to map them to service implementations based
on users’ preference.
Guice is a dependency injection framework developed
by Google for Java platform [25]. It allows an interface to be
programmatically bound to implementation classes and
inject constructors, methods or other fields into the classes
by an @Inject annotation tool. When more than one
implementation of the same interface is needed, users can
create custom annotations to identify an implementation and
use that annotation when injecting. Spring is another
application framework for the Java platform [26], It
provides more functionality than Guice does as Sring has
inversion of control (IoC), injection, annotation and other
functions. IoC can be called dependency injection where
developers do not need to create their objects but describe
how they are created and do not directly connect components
but describes which components needed by objects in
configuration file. IoC container is in charge of these
operations. Spring-Annotation is a library that allows
developers to use annotations to configure their application
by spring-framework. It is possible to configure Spring’s
dependency injection using annotation. Both of them
proposed similar mechanism like dependency injection [27],
which use interfaces to inject class implementation later.
Injection and annotation functions of Spring are similar to
the functions that Guice provide, except Spring uses xml
script instead of Java program.

III.

CLOUD SERVICE MANAGEMENT AND COMPOSITION

A. Cloud service management and composition
Service Interface (SInt) describes service interface, and it
may include the service’s input, output, specification, test
cases, and use scenarios. Interface service can be organized
by a domain ontology, which maintains relationships among
service interfaces and service implementations. The
relationship between service interfaces and service
implementations is one-to-many.
Service Implementation
specification [28].

(Simp) implements an

service

Domain ontology: Domain ontology expresses domain
information and represents entities (as nodes), relationships
and constraints. It can organize and manage service
interfaces. One example is illustrated as Figure 1.
• Nodes: A node is a unique entity that represent an service
interface in domain ontology. Every node has zero or
more corresponding implementations that have been
verified. In addition, each node’s implementation must
have the same input and output so that they can be
dynamically replaced by each other.
• Relationships: It is a connection between two nodes in
the domain ontology.
• Service Workflow or Application Template: they are
composed by service interfaces represented by a domain
ontology and control structures as illustrated as Figure 3.
B. Extensions to allow users designate specific services
In [3], service implementations’ selection mainly
depends on dependency information among service
interfaces and users service selection history. Both of them
do not allow user to designate specific service
implementation programmatically. This paper extends
service selection mechanism using Service Injection (SI) that
allows users to compose workflow or application templates
by service interfaces and inject service implementation later.
Developers have two options to specify SI:
1) By Configuration: Developers can fill all service
selection information such as service name and method
names. Inputs and other related information can be added
into the the configuraion file “groundProfile.xml”. This
approach is based on the Spring tool. It is convenient for
users who want to do configuration rather than
programming.
Figure 2 gives an example of the groundProfile.xml. In the
upper part of groundProfile, a service interface
NotificationService is mapped to the method notification of
“Company A Notification Service”. Its input parameter is
username whose value is Tommy. In the bottom part of this
file, a workflow ChangeNotificationWay is defined. It uses
the reference “notificationServiceByCompanyA” defined in
the upper part. If developers want to use different service
implementations, they can add another service interface
mapping like “Company A Notification Service” and change

632
634
638
630

Tracking
system service

Use Scenario For
Notification Service
Test Case For
Notification Service

Company A
Notification Service

Notification
service

Company B
Notification Service

Tracking
service

Company C
Notification Service

Company A
Change Service

Tracking
Exception Service

Exception
change service
Company B
Change Service
Use Scenario For
Change Service

Use Scenario

Instance Service

Exception
service

Change service

Status change
service

System Exception
Service

Location
change service
Company A
Exception Service

Company C
Change Service
Test Case For
Change Service

Test Case For
Exception Service

Company C
Exception Service
Company B
Exception Service

Test Case

Abstract Service

SubClassOf

Implementation

TestingCaseOf

UseScenarioOf

Figure 1. Domain Ontology Example

Figure 2. A GroundProfile Example

the reference. By this way, developers can select service by
injecting service into a configuration file. The composed
workflows or application templates can be reused by others.

CompanyANotification ImpS = new CompanyANotification();
GroudService myBinder = new GroudService();
myBinder.bind(NotificationService,ImpS.notification(“Manager”));

In this way, application developers can designate their
service implementations. This is similar to the class
injection mechanism used in Google Guice [25].

2) By Programming: Developers can fill service
selection information by calling GroundService.bind()
method as illustrated as following code:

C. Code generation support
In [3], developers compose workflows by dragging and
dropping services from domain ontology, which is
implemented by a tool [29]. One workflow example is
illustrated as shown in Figure 3 and the generated source
code is presented as Figure 4. How to generate source codes
of SI is similar with Spring [26] and Guice [25]. And it can
be easily implanted into PSML-S.

[WebMethod]
public void bind(Object IntS, Object ImpS)
{
Bind binder = new Bind();
binder.bind(Ints).to(ImpS);
}

From the code one can see that, it mainly binds service
interface to the service implementation. Developers can use
GroundService like normal web service and fill in service
interface and service implementation as shown below.

633
635
639
631

the pass/fail of subsequent tests, i.e., a test case is established
(input, established oracle with a confidence level).
2) Unit Testing
Once a test case is formed with an established oracle, it
can be used to test new service implementation. Test cases
can also be ranked to help the cloud and users to select the
most potent test cases to run first and often.
After an oracle for a test input has been set up for a
workflow, integration testing can be used to test each
service by changing one service implementation at a time. If
testing results are consistent, the new service is considered
as correct with a confidence level with respect to the test
case. When a sufficient large number of test cases pass the
test, the new service implementation is considered as
validated with another confidence level, otherwise the new
implementation will be rejected.
3) Integration Testing
Once the workflow is completed, one can apply its use
scenarios [11] as test scripts to test the workflow. A user
scenario of a workflow or a service is essentially an
application that uses the workflow or the service
respectfully. One can say that the workflow in Figure 4 is a
use scenario of all the participating services such as
notification_service. Use scenarios for a service can be
collected and served as a part of the service specification,
and they can be used for service composition. A use
scenario for a service may involve other services, and thus
this use scenario provides a relationship between these two
services, the relationship indicates these two services are
linked to each other. During service composition, once a
service is selected, the linked service becomes a candidate
for composition. Furthermore, the use scenarios for a
workflow can be collected and used later for service
composition or as the basis for test scripts.
4) Continuous Testing
Continuous testing can be a part of the TDD (TestDriven Development) process. Continuous testing is a testing
process that is being applied during the development and
execution stages. In traditional continuous testing, testing
mostly in the form of regression testing is applied during the
entire development time 24 hours a day [32]. In clouds, as
new applications may be composed from existing services,
continuous testing can be applied before and after
application and service composition, and even during
execution as a part of the service monitoring and/or policy
enforcement processes.
Continuous testing can be used to test SaaS applications
[4] by embedding built-in test case generation with the
metadata database associated with a tenant in the SaaS. In
this case, test cases can be selected to test the SaaS
applications continuously. If a test script detects a failure, the
ranking of the test script with its associated test case will be
increased so that it will be used early and more often in
continuous testing. The cloud platform can run those test
scripts continuously selecting most potent test case with
dynamic ranking of test cases.
5) Metadata-driven Test Input Generation

Figure 3. Workflow Example

do ACTION Manager.Change_Service
if CONDITION::Manager.Exception
{
do ACTION Manager.System_exception_Service
}
else
{
do ACTION Manager.Notification_Service
}

Figure 4. Generated Source Code of Workflow

D. Service customization supports
Service customization is important for SaaS (software as
a service) [30]. One solution is to use a multi-layer
customization framework OIC to support customization [31].
In this framework, templates are used to assist SaaS
customization. However, services that compose the
templates are not easy to change. To better reuse templates,
they can be composed by service interface and do SI when
developers customize SaaS. So, developers do not need to
modify the template if they just want to change services.
IV.

TESTING WORKFLOWS OF SERVICE COMPOSITIONS

Both the number of cloud services available and the size
of data that cloud services need to handle are often large.
Testing workflows composed of those cloud services is a
challenge. This paper follows the service group testing [7,
12] to test workflows.
1) Oracle Generation of Composite Services
A test case is a pair (test input, expected output), but
often the expected output is difficult to obtain. As users
compose services by using SInts and each SInts can be
implemented by different providers (SImps), there is a large
number of combinations for the same workflow if the cloud
chooses different SImps. Oracle generation mechanisms in
[7, 12] can be used to determine the expected output. Oracle
generation uses a voting mechanism to establish an oracle
with a confidence level, and if the confidence level is high
enough, the corresponding oracle can be used to determine

634
636
640
632

For inputs and outputs of service interfaces, one can use
metadata to define test inputs [4]. For example, if the length
of user ID for a website must be 64 bits, the simple test
inputs can be generated by randomizing the 64 bits. One can
generate a collection of user IDs of 64 bits, another
collection with 128 bits or any other bits.
6) Execute testing processing by service-level
MapReduce way
As the number of SImp can be large on a cloud, testing
needs to be effective and efficient. So, group testing can be
applied using service-level MapReduce [1] to run tests in
parallel. The idea is to use different combinations of service
implementations for the same workflow in the map step. The
input of the workflow is either produced by developers or
generated from the metadata. The majority of immediate
results from the map step is reduced to generate an oracle in
the reduce step by the voting mechanism [7]. It can be
illustrated as in Figure 5:
a. Users submit the composed service to the cloud;
b. Cloud management service (CMS) calculates how many
workers needed based on configurations;
c. CMS finds enough available workers to run services.
d. CMS discovers service combinations for the composed
service and dispatches them to the workers;
e. CMS calls the input service or provides test input from
developers to start service-level MapReduce;
f. In the map step, service combinations are executed;
results are sent to cache services for shuffling;
e. In the reduce step, the voting is done to establish an
oracle;
g. If an oracle is found, it is sent back to users as an
validated oracle. If not, the composed service fails to
establish an oracle with this test input.
From Figure 5, one can see that:
a) Each service combination for the workflow is
running on different worker machine of the cloud with same
inputData service.

d) If output data produced are consistent with limited
deviation [32], i.e., a majority can be established, an oracle
can be established with a confidence level. Otherwise, no
such oracle can be established, and another test input need
to be run to establish its own oracle.
V.

CASE STUDY

The following case study illustrates the techniques
discussed for a cloud application. This study uses a shipping
domain service composition system to illustrate the
composition process. We obtained the requirements from
three different companies. According to applications’
requirements, three different application systems have been
developed. Now, a manager wants to incorporate certain
changes for the tracking system. She composes a workflow
by using service interfaces illustrated in Figure 1. The
manager chooses services provided by company A, one can
use the following code to map the service interfaces to
implementations.
CompanyANotification ImpS = new CompanyANotificationService();
GroudService myBinder = new GroudService();
myBinder.bind(NotificationService,ImpS.notification(“Manager”));
CompanyAExeceptionService ses = new CompanyAExeceptionService ();
myBinder.bind(SystemExceptionService,ses);
CompanyChangeService ccs = new CompanyChangeService();
myBinder.bind(ChangeService, ccs)

The cloud incorporates this information for the workflow,
as is illustrated as Figure 6.
Start

CompanyAChangeService

CONDITION:Manager
.Exception?

True

CompanyAExceptionService

False
CompanyANotificationService

After applying use scenarios to generate test scripts to
run testing, the oracle generation can then be used to
establish oracles for test cases. After all kinds of testing
have done, the workflow can be run in the cloud.

…...

…...

Figure 6. Workflow after Service Implementation Mapping

VI.
Figure 5. Oracle Generation Service Level MapReduce process

CONCLUSIONS

This paper proposed a new approach to manage services
on the cloud to allow users to compose services and test
them. Users use an service interface to perform service
composition and let the cloud environment to map the
interface to a suitable service implementation. Users can
designate a specific service by configuration or
programming. Test scripts and cases can be developed using
metadata or use scenarios. A voting mechanism is used to
create the test oracles with a confidence level. As the

b) All service combinations can be run in parallel.
c) Cache service can be used to shuffle the immediate
results of map process and dispatch them to different reduce
services to get final result. This process is controlled by
service-level MapReduce [1].

635
637
641
633

number of cloud services is large, a service-level
MapReduce is used to execute testing.

[14]
R. Gronmo and M. C. Jaeger, "Model-Driven Semantic Web
Service Composition," presented at the the 12th Asian-Pacific Software
Engineering Conference (APSEC), 2005, Taipei, Taiwan.
[15]
B. Orriens, et al., "Model Driven Service Composition,"
presented at the First International Conference on Service-Oriented
Computing (ICSOC), Trento, Italy, December 15-18.
[16]
K. Fujii and T. Suda, "Semantics-Based Context-Aware
Dynamic Service Composition," ACM Transactions on Autonomous and
Adaptive Systems (TAAS), 2009, vol. 4.
[17]
S. Kona, et al., "USDL: A Service-Semantics Description
Language for Automatic Service Discovery and Composition," Int. J. Web
Service Res., vol. 6, 2009, pp. 20-48.
[18]
A. Brogi, et al., "Semantics-based composition-oriented
discovery of Web services," ACM Trans. Internet Techn., vol. 8, 2008.
[19]
E. Sirin, et al., "Template-based composition of semantic web
services," 2005, pp. 85-92.
[20]
K. Geebelen, et al., "Dynamic reconfiguration using template
based web service composition," presented at the 3rd Middleware for
Service Oriented Computing (MW4SOC), 2008.
[21]
Y. Dai, et al., "QoS-Driven Self-Healing Web Service
Composition Based on Performance Prediction," J. Comput. Sci. Technol.,
vol. 24, 2009, pp. 250-261.
[22]
L. Yang, et al., "Performance Prediction Based EX-QoS Driven
Approach for Adaptive Service Composition," J. Inf. Sci. Eng., vol. 25,
2009, pp. 345-362.
[23]
S. Meng and F. Arbab, "QoS-Driven Service Selection and
Composition," presented at the 8th IEEE International Conference on
Application of Concurrency to System Design (ACSD), 2008.
[24]
W. T. Tsai, et al., "Dependency-Guided Service Composition
for User-Centric SOA," 2009 IEEE International Conference on e-Business
Engineering, vol. 0, pp. 149-156.
[25]
Google. Guice. Available: http://code.google.com/p/googleguice/
[26]
S. Source. Spring. Available: http://www.springsource.org/
[27]
Wikipedia.
Dependency
Injection.
Available:
http://en.wikipedia.org/w/index.php?title=Dependency_injection&oldid=35
3809060
[28]
W3C. Web Service. Available: http://www.w3.org/2002/ws/
[29]
W.T.Tsai, et al., "PSML-S: A Process Specification and
Modeling Language for Service Oriented Computing," The 9th IASTED
International Conference on Software Engineering and Applications (SEA),
Phoenix, November 2005.
[30]
Wikipedia,
"Software
As
a
Service,"
http://en.wikipedia.org/w/index.php?title=Software_as_a_service&oldid=3
41352621, 2010.
[31]
W. T. Tsai, et al., "OIC: Ontology-based intelligent
customization framework for saas," presented at the Int. Conf. on Service
Oriented Computing and Applications(SOCA'10), Perth, Australia, Dec,
2010.
[32]
E. Smith, "Continuous testing," Proceedings of the 17th
International Conference on Testing Computer Software, 2000.

ACKNOWLEDGMENT
This project is partly sponsored by U.S. Department of
Education FIPSE project P116B060433, U.S. National
Science Foundation project DUE 0942453, and Department
of Defense, Joint Interoperability Test Command. The
research is also partly sponsored by the European Regional
Development Fund and the Government of Romania under
the grant no. 181 of 18.06.2010.
REFERENCES
[1]
W. T. Tsai, et al., "Optimal Service Replication Strategies for
MapReduce On the Cloud," The International Symposium on Autonomous
Decentralized System (ISADS), 2011.
[2]
E. Newcomer, Understanding Web Services: XML, Wsdl, Soap,
and UDDI: Addison-Wesley Professional, 2002.
[3]
W. T. Tsai, et al., "Template-Based Service Composition for
User-Centric SOA," the 22nd International Conference on Software
Engineering and Knowledge Engineering, 2010.
[4]
W. T. Tsai, et al., "Towards a Scalable and Robust Multitenancy SaaS
" The Second Asia-Pacific Symposium on
Internetware (Internetware'10), Suzhou, China, Nov. 2010.
[5]
D. Saff and M. D. Emst, "Continuous testing in eclipse," In 2nd
Eclipse Technology Exahcange Workshop (eTX), Barcelona, Spain, March
2004.
[6]
X. Bai, et al., "Ontology-Based Test Modeling and Partition
Testing of Web Services," 2008, pp. 465-472.
[7]
W. Tsai, et al., "A Coverage Relationship Model for Test Case
Selection and Ranking for Multi-version Software," High Assurance
Services Computing, pp. 285-311, 2009.
[8]
V. Ernestas and N. Lina, "Transforming Ontology
Representation From OWL To Relational Database," Information
Technology and Control, vol. 35, 2006.
[9]
D. Bianchini and V. D. Antonellis, "Ontology-based Integration
for Sharing Knowledge over the Web," DiWeb2004 - 3rd International
Workshop on Data Integration over the Web, June 2004.
[10]
K. Jong Woo and J. Radhika, "Web Services Composition with
Traceability Centered on Dependency," in the 38th Hawaii International
Conference on System Sciences, 2005, pp. 89-89.
[11]
W. T. Tsai, et al., "Semantic Interoperability and Its
Verification and Validation in C2 Systems," presented at the 10th
International Command and Control Research and Technology Symposium
(ICCRTS), 2005.
[12]
R. Bryce, et al., "Biased covering arrays for progressive ranking
and composition of web services," International Journal of Simulation and
Process Modelling, 2007, vol. 3, pp. 80-87.
[13]
L. Chen, et al., "ECA Rule-Based Workflow Modeling and
Implementation for Service Composition," The Institute of Electronics,
Information and Communication Engineers (IEICE) Transactions, vol. 89D, 2006, pp. 624-630.

636
638
642
634

2009 IEEE International Conference on Services Computing

Ontology-based Information Sharing in Service-Oriented Database Systems
TszYan Chow*, Wei-Tek Tsai*+, Janaka Balasooriya*, Xiaoying Bai+
*Department of Computer Science and Engineering, School of Computing and Informatics
Arizona State University, Tempe, AZ, USA
+ Department of Computer Science and Technology, Tsinghua University, Beijing, China
Wei-Tek.Tsai@asu.edu, janakab@asu.edu
Abstract
As these services work collectively by communicating
with each other through an ESB (Enterprise Service Bus),
adding, replacing, or removing database services may not
require bringing the database system down.
b) The information hosted on a SODB can be tied to
services, not to any specific database system. The idea of
storing and representing data using services provides a
flexible mechanism in data storage as the information is
no longer subject to the schema structures. This provides
the capability to access and integrate data from
heterogeneous sources.
c) The built-in self-configuration mechanism allows
individual services in this framework to be combined,
configured, and/or reconfigured at runtime.
Section 3 presents an SODB architecture. An SODB needs to
facilitate different organizations to combine information from
multiple data providers into one logical form. Thus,
representing, accessing, maintaining, managing, analyzing, and
integrating data across heterogeneous possibly unstructured
data sources is critical in an Information Sharing System (ISS).
1.1 Need for Information Integration
Many information sharing applications such as those in
healthcare often face issues in integrating and sharing data [1,
3]. One example is the Arizona Healthcare Cost Containment
System (AHCCCS), and it has been created to handle
application and eligibility data for programs such as Arizona
Long Term Care System and KidsCare programs. Like
AHCCCS, Department of Economic Security (DES) and
Health-e-Arizona (HEA) also determine eligibility for nonmedical related programs, such as Temporary Assistance for
Needy Families (TANF) and Food Stamps. In many cases,
eligibility for such non-medical benefit programs accompanies
eligibility for Medicaid or other medical programs administered
by AHCCCS. For example, a family that applies for TANF
may have an income too high to qualify for that program but
low enough to be eligible for the AHCCCS KidsCare program.
Similarly, an AHCCCS eligibility worker may discover during
a KidsCare eligibility interview that a family’s income level is
low enough to qualify for one of the DES assistance programs.
Note that the information systems of these agencies are not
structured to diffuse with each other because each agency has
its own eligibility requirements and interests, the data
extraction process must be custom-made for each participated
agency. The need for information sharing is not only confined
to the Healthcare sectors. The Department of Defense (DoD)
has developed a Net-Centric Data Strategy Guideline [18] to
address information sharing. As stated in the guideline, data
interoperability and visibility can be achieved by having each
of the data providers or COIs (Community of Interests) to: (i)
use a common platform for exchanging their information; (ii)
publish shared information that can be searched; (iii) develop
an agreement on semantic and structural format on the shared
information; and (iv) use domain-specific vocabulary and
taxonomy for unambiguous communication.
The proposed ISS addresses these issues. It can be seen as a
third-party agent that manages the shared information that

This paper presents a novel information sharing framework
using Service-Oriented Database System (SODB) for service
registry and repository that facilitates data integration. A
SODB is a database architecture composed with reusable
services to support searching, querying, deleting, and storing
data. As SODB is organized in a service-oriented manner,
SODB can be easily changed or maintained by reusing
different services. Thus, it can be used to share information in
the cloud. The Information Sharing System (ISS) component of
the SODB employs domain ontology to share data sources. The
domain ontology utilizes mathematical equivalence relations to
map data sources into appropriate domain ontology. It also
facilitates dynamic query composition across data sources.
This paper also presents the design, implementation, and
performance evaluation of the ISS component. Our
implementation is based on a real application, the Arizona
Healthcare Cost Containment System (AHCCCS). This
application demonstrates that the ISS can facilitate complex
information integration. Finally, this paper presents the
performance of the ISS using WAPT (Web Application Testing)
for Microsoft Windows XP, and the response time consistently
fall in between 0.1 to 0.15 second for each request.
1. Introduction
Information sharing is important in a networked environment
where organizations exchange data extensively [2, 3]. Lack of
data integration in SaaS (Software as a Service) is a roadblock
in service computing [32]. Current solutions need ad-hoc,
custom-made, “hand coding” for each data integration
requirement. In [32], authors pointed out that data integration
can be solved by providing a) “modular software that can be
meshed, branded, and delivered as part of SaaS provider’s
application environment.” and b) “on demand service
delivery.” Recently, many SaaS applications are being moved
to cloud computing as a cloud infrastructure provides
virtualized computing and storage services with self-healing,
self-monitoring, resource registration and discovery [33, 36].
Data integration in cloud computing can be agile and
configurable as new services may be added into the system
without stopping the application, and new applications can be
composed from the existing services by altering the application
specification without changing the underlying framework. One
issue in cloud computing is to provide versatile components
that present resources to the cloud including a dependable and
fully functional service broker that provides a reliable and an
efficient service hosting and discovery [33, 35]. Consider a
registry and repository system that can support searching,
querying, storing and deleting services. A system with these
capabilities can be considered as a Service-Oriented Database
System (SODB). A SODB is a brokerage system in which,
a) Each database component can be classified according to
their function types such as data operations (insert, delete,
and update), concurrency control, caching, and data
formatting, and each function can be modeled as a service.
Thus, a SODB is a federated service registry repository.

This research was sponsored by Department of Education FIPSE, and the opinions expressed are of the authors not of the federal government.

978-0-7695-3811-2/09 $26.00 © 2009 IEEE
DOI 10.1109/SCC.2009.78

276

a)

Supports data publishing by utilizing an ontology service
that resides in a SODB to transform local business
information into commonly-agreed terms.
b) The shared information can be queried across multiple
domains using the standardized terminology and the
results of the query are available for others.
c) Supports real-time access to the source data.
Section 4 describes the proposed ISS.
2. Related Work
Data integration in cloud is a new research direction with many
issues. Yahoo PNUTS [33, 34], informatica’s SaaS data
integration platform [41], and IBM cloud computing initiative
[35] provide initial data integration frameworks in the cloud.
Databases with SOA features: In traditional database systems,
every database function is implemented in the system. In
contrast, components in the SODB can be implemented
remotely as services providing flexibility. SODB can be
integrated into a cloud infrastructure. Table 1, summarizes and
compares traditional databases and SODBs.
Microsoft SQL Server 2005 [23] applied SOA technology in a
database management system. In SQL Server 2005, native
service access is made available via a kernel-mode HTTP
driver, which allows SQL Server to register a portion of the
URL namespace without requiring the need for a web server as
an intermediary.

(WSMS) [26] proposed by Stanford University and Duke
University aims at enabling clients to query a collection of web
services in a transparent and integrated fashion. They focus on
query optimization for select-project-join queries spanning
multiple web services. Table 2 summaries and compares
various features. As shown in table 2, currently self
configurability and service broker features are not available in
most of the current systems.
Information Sharing: Information retrieval system that uses
ontology for data integration has prevailed recently. These
systems include TSIMMIS [14], InfoMaster [5] and InfoSleuth
[27]; they all use ontology to define database schema objects
and their constraints for the data source. The data-source
specific domain ontology will then be advertised at the broker
agent so that it can perform reasoning on the advertised
ontology and provide references to the appropriated data source.
VISPO, is another Web-based framework that supports
knowledge sharing using ontology [1].
IBM presented a service-based infrastructure for enabling
information sharing [20]. Spatial data integration in geographic
information system (E-GIS) using ontology and service-based
method was explored in [22]. MetaMatrix [17] integrates data
from multiple data sources (such as XML, services, databases,
spreadsheets, and media databases) and provides many data
services such as data query services, content search and
discovery services. WS02 [29] adopts W2-policies to control
data access, data caching and security for the underlying data
sources such as MySQL, Oracle, DB2, MS Excel, CSV, and
LDAP. Although WS02 data services offer a convenient way to
access data originated from many different places, service
queries cannot span over multiple data sources [19]. Data
exposed in WS02 data services is through the direct exposure
of the underlying databases objects, such as tables, service
functions and store procedures. Thus if these database artifacts
are modified, then the data services will fail.

Table 1: Traditional DB vs. SODB
Traditional
Databases

Service-Oriented Databases

Database
Functions
Implementing
methods
Database
Extensibility &
Portability

Implemented in the
management system

Service functions may be
implemented locally and
remotely

Version upgrades or
package installations
require the system to
be taken offline or
restarted

Data
Orientation

Data is closely tied to a
relational or objectoriented system
Data is stored either in
tables (by rows and
columns) or in objects
Need to define schema
before usage
Implemented locally in
the database system

Services work collectively by
communicating through ESB.
Adding, replacing, removing
services from the system may
not require the system to be
brought down.
Data may be tied to a domainspecific service and not to any
specific database system
Data may be stored in tables,
objects, or in terms of services

Data Storage
Database
Schema
Concurrency
Control

Database
Architecture
style
Entity
Relationship
Model

It can be centralized,
distributed, or
federated
Relational DB: Use
Primary and Foreign
Keys to define data
relations
Object-Oriented DB:
Use Inheritance or
Reference Pointers

Table 2: Databases with SOA Features: A Comparison
SOD
B
Yes

SQL
SERVER
Can be
added on top
of the
existing
brokerage
system.

DBNET
Can
be
added

WSM
S
Can
be
added

Amazo
n
Can be
added

Oracl
e
Yes

LooselyCoupled
System
Organization
Flexible Data
Storage
Web Service
Query
Optimization

Yes

No

Yes

n/a

Yes

No

Yes

Yes

Yes

Yes

Yes

Yes

Yes

Can be
added

Can
be
added

Yes

Can be
added

Can
be
added

Self
Configurable

Yes

Can be
added

can be
added

Can
be
added

Can be
added

Can
be
added

Service Broker
Feature
(To facilitate
Service
discovery &
matching)

Schema may be defined at
runtime as new data arrives
Possibly two concurrency
control (CC) mechanisms:
High level: CC among services
using policy
Low level: CC among the
native database functions
Mostly distributed and
federated.
Data relations may be
specified using service
ontology or policies

3. Service-Oriented Database (SODB)
An SODB architecture is shown in Fig. 1 and it is similar to
WebStrar [12] and IBM WebSphere Reference Architecture
[20]. WebStrar (Web Services Testing, Reliability Assessment,
and Ranking) is a collaborative infrastructure that supports the
development and verification of services. Services are
connected to an ESB to cooperate and communicate with each

Oracle Database 10g [24] comes with an enterprise SOA suite
that offers two service modes: a service consumers and
providers. Amazon SimpleDB™- Limited Beta [16] is a service
that provides simple query functions, creates and stores
multiple data sets and provides data look up over a schema-less
database storage. DBNet [9] is another system that provides
SOA-based architecture. Web Service Management System

277

other. The infrastructure allows users to publish, discover and
search verification mechanisms such as test cases, test scripts,
and reliability models, as well as to rank services and
verification mechanisms. In the IBM WebSphere Reference
Architecture, the system is composed using connectivity
services and a service bus such as ESB. A service bus provides
a communication channel for services to interact with each
other. The architecture has two main categories of services
connected to the ESB: business logic services, and application
and control services. The business logic services provide the
capabilities needed to execute the business logic as a
combination among existing applications, as newly
implemented services, or as connections to services provided
by other systems. Business data and services interactions are
control by interaction services, process services and
information services. The interaction services are used to
transport data and functions in proper formats and protocols to
users.

data streaming arising from sensor devices or data from other
web services that may contribute to the discovery process.
Caching Services: Multi-caching, in respect to service domain,
location, time period and special events, provides efficient
services by reducing round trips to the server.
Data Collection Services: To adjust the system performance,
the SODB need to assess each service performance within the
repository system. This service collects repository usage data
for evaluation.
Indexing Services: Services registered in the service registry
system can be indexed locally in SODB according to its domain
or keywords from the service description / specification to
facilitate the service discovery process.
Concurrency Control Services: This controls the concurrent
access or modification to the ontology data and service data
saved in SODB. An optimistic concurrency control can be used
to reduce dependencies between service components and
provide flexibility to alter the registered services.
Service Query Optimization: An SOA application usually
involves multiple services working with each other to
accomplish a task. The collaboration between service callers
and receivers can be arranged to optimize performance.
3.2 Custom Services
Data Transformation Services: When sending or requesting
data using service protocols, it may be necessary to transform
input or output data first prior to using the service. This service
provides a convenient way to transform different service data
into a user-specified data format either in real time or in a batch
mode. For example, XML publishing (transforming tuples to
XML) can be done by stream-reading each selected data row
and annotating each data value with the corresponding table
column name. XML shredding (converting XML to tuples) can
be accomplished by using techniques in [19]. Converting XML
data to strings can be achieved by using XLST or XQuery,
which requires the data service to generate an XML schema
based on the selected XML file and use it to produce the
stylesheet or XQuery script for extracting XML data.
Data Operation Services: These services support
update/add/delete operations within SODB. Service artifacts
stored in SODB may require update or change. For instance,
ontology definition may need to include a new terminology in
that specific domain; a service function may need to update its
specification to reflect the latest change.
Policy Services: Policies specify and enforce system constraints
[11] such as reliability, availability, security, performance and
communications. In an SODB, policies are being used to
control concurrent access to registered services, to regulate the
subscription right on the published data, and to specify the
service relations.
Ontology Services: These services provide a common reference
for a domain as well as enables users to identify services in the
domain.
Service consumers can subscribe the ontology
definition to create their data store [4] or use it to facilitate
information exchange through semantic mapping among
different data sources.
Template Services: These services explore reusable assets to
facilitate the development of SOA solutions. Templates are prebuilt components ready to bind to an existing application. For
example, the workflow template can be used to streamline
business processes within an organization by specifying the
detail relations among the service functions and the application
template can be used to create hierarchical application structure.
User Profiling Services:
These services track service
preferences (e.g., service publisher, service location, service

Service-Oriented Database System

Remote
Services
Custom
Services

Core Services
Data
Storage
Services
Process Controller
Data
Collection

SOA-DB
Configur
ation

Evaluation
DB
Operation

Dynamic
Compositi
on

Indexing
Services

Data Transformation
Services
Service Query
Optimization
Services

Ranking
Services

Data Services

Information Sharing Services

Service Specifications / Implementations (code)
Enterprise Service Bus

Caching
Services

Concurrency
Control
Services

Data
Operation
Services

XML

Tuples

Policies Services

Ontology Services

User Profiler Services

Testing Case Services

Template Services

Notification Services

Objects

Others

Figure 1: Service Oriented Database Architecture
Process Controller: This is an adaptive process with a feedback
loop to ensure system availability and service visibility. The
“Evaluation of DB Operations” service in the process controller
determines if service adjustment is needed by calculating the
probability of the service failure rate as well as the expected
service request processing time. The evaluation of both
reconfiguration criteria can be based on Bayesian analysis [25].
In an SODB, service functions are classified into two main
groups: (i) core and (ii) custom services. Core services, such as
caching management, service query optimization, indexing,
query execution, service usage analysis and concurrency
control, are vital to the brokerage system and they are the
foundation units. These services are implemented locally.
Custom services provide additional functionalities, and they
can be customized to fit applications. Sample custom services
are service ranking, application templates, and service testing
and policy services.
3.1 Core Services
Data Storage Services: Information and service data can be
stored in an SODB according to the user’s preference. The data
storage service contains query logic for retrieving data that
resides locally in the SODB, in a remote database system, in

278

ranking,), service usage patterns and the account information for
each user. The information collected can be used to provide
feedbacks for the service providers or to create collaboration
agreement for service consumers and providers.
Ranking Services: Services can be ranked according to the
service consumer’s evaluation and service provider’s
creditability. Service ranking may fluctuate depending on the
service subscription volume and the consumer’s feedback. This
service can be combined with the caching service to cache only
highly ranked services in the server to increase service
discovery performance.
Test Case Generation Services: These services provide a means
to generate test cases for the published services based on the
service specification and/or implementation. Consumers can
subscribe and reuse published test cases to evaluate published,
or to be published, services.
Notification Services:
These services can be used as
autonomous agents that continuously monitor the registered
queries within an SODB. For instance, a group of users may
want to subscribe certain information published in an SODB.
They can register their request with this service and it will
notify the consumer once the information is available. Another
example, the SODB indexing service may have locked certain
records in the repository system for index update. When the
update is finished, it will notify other services (through the
ESB) that the affected records are ready for access.
Data Services: These services provide a unified way to access
heterogeneous data sources from a single access point. A query
can be run against different data sources such as XML, Oracle,
SQL Server, DB2, packaged applications and Web Services. In
fact, numerous data services with these capabilities are available
today. For example, MetaMatrix Enterprise Data Service
Platform [21], Composite Application Data Service, Sybase
Real-Time Data Service, Oracle’s BEA AquaLogic [24, 2] and
Microsoft’s ADO.NET Data Service [23].
Information Sharing Services (ISSs): An ISS provides a way
for different business organizations to combine information
from multiple data providers into a logical form. Semantic
mapping between standardized ontology and shared information
is required to fracture the semantic barriers. This service can be
combined with policy services to restrict different data access
levels.
4. Information Sharing Service (ISS)
An ISS can be divided into three functional areas: (i) Data
access profile setup, (ii) Information publishing (data mapping)
and (iii) Information discovery (data querying).
Figures 2, 3 and 4 show the workflows for these areas.

The workflow involved four steps: (i) identify, (ii) conform, (iii)
publish and (iv) discover. First, the data provider identifies the
ontology needed. Second, the data provider creates a data
service object and conforms their data to the selected ontology
model. Third, the data provider maps the schema attributes
from the data service objects to the target domain ontology and
publishes their data on the network. Finally, users across
different levels and domain areas can search and discover the
shared information within the SODB.
1. Becoming a member. The data provider must register with the
SODB before using any services provided.
2. Discover domain ontology. After login, the data provider can
search for a suitable ontology through the ontology service to
depict their data (Fig. 2).
3. Building the data service. The abstracted data can come from
different sources, e.g., the information may be gathered from
database functions, store procedures, other database systems,
or even from another data services. The data service must
contain data attributes that can be mapped to the selected
ontology model (Fig. 2).
4. Initialize the ISS. When the abstraction layer is ready, the data
provider can initiate the information sharing service to start the
data sharing process.
5. Enable data access on-demand. To enable run-time discovery
and subscription of the source data, the data provider must be
willing to provide remote database server information (e.g.,
Server IP address, database name, and authentication
information). This enables the ISS to access their data during
runtime.
6. Mapping data elements through the web interface. The
procedure for mapping the local schema attributes to the remote
ontology must be done by the data publisher through the web
interface provided in this framework.
7. Data publishing. Once the mapping between the source
attributes and ontology has been completed, the mapping
references and database access information will be stored in the
ISS repository. The framework can discover and use the
information published by the data source providers.
8. Data or data source modification. Data providers have full
control over the mapping references stored in the information
sharing service. They can add or delete mapping attributes or
update the database access information to access different
database server. These operations can be performed through
the web interface.
9. Publish new information. As needs evolve, the associated data
may change or be replaced. The data provider can reiterate
steps 2 – 7 to update or add mapping references.
Note the domain ontology is reused throughout the process. It
was first used during the development phase and again at
runtime for data mapping. During the development phase, the
data provider subscribes to the ontology, analyzes it and then
determines if the ontology can be used to represent their data. If
the ontology fits the publisher’s needs, they can create data
service objects according to the selected domain model and
advance to the data mapping step. Before the data mapping
process occurs, the data provider will call the same ontology
service to establish direct mapping references between elements
from the abstraction objects and the domain terms. After
completing these processes, the information is published in the
SODB and will be available for subscription. To subscribe to
this published data, the ontology will be used as a query
language for retrieving information in the SODB.

Figure 2: Identify domain ontology

Figure 3: Publish information

Figure 4: Discover shared information

279

Transitive relation:
ei, ej , ek E and Rp R
ei Rp ej and ej Rp ek => ei Rp ek
Fig. 5 illustrates these equivalence relations for AHCCCS.
Here, each node in is labeled using its domain ontology name.
Symmetric: The domain “AZ State Eligibility Programs”
umbrellas multiple eligibility programs, one of which is the
state “Healthcare Eligibility”. One can say the Healthcare
eligibility program / domain is housed under the State’s
eligibility program domain establishing parent-of (Rp)
relationship. Also, the “Demographics” or “Eligibility_Inform
action” segments under “Healthcare Eligibility” are indirectly
relates to the “Unemployment Benefit” domain ontology. So,
“Healthcare Eligibility” and “Unemployment Benefit” ontology
systems show symmetric relation.

4.1 Domain Ontology
Ontology can be specified in XML, RDF or OWL, The
proposed ISS use equivalence relations to specify relationship.
Basic Terminology and Definitions:
Let E = {ei|ei is the ontology that represent domain i} be
ontology definitions
DSei be the ontology scope of the ontology ei
And R = {parent-of (Rp), sibling-of(Rs), child-of (Rc)}
be possible relationships among ontology systems.
Where Rp , Rc , and Rs relationships are defined as follows
DSei < DSej => ei Rp ej and ej Rc ei
ei Rp ej and ei Rp ek => ei Rs ek

AZ State
Eligibility
Programs

The above relationship between domains and domain’s
attributes within the ontology are defined through the XML
segment hierarchy as shown in table 3.
Table 3: Ontology Domain and Its Attribute's Relationship
Node(s)

Sample structure

Ei < E j
(Parent
of)

<ei>
<ej></ej>
<ei>

e1

e2

Ei = Ej
(sibling
of)

<…>
<ei> </ei>
<ej> </ej>
</…>
e2

….

e1

Node
Relationshi
p1
Ej is a
domain
attribute/att
ribute value
of ei

Node
Relationship 2

ei and ej
represent
two
separate
sub domain
area within
a domain

ei and ej can
be sub-domain
or domain
attribute/attrib
ute values
under another
common
domain

Healthcare
Eligibility

Demographics

Unemployment
Benefit

Eligibility
_informati
on

Figure 5: Domain Relations (Sample)

N/A

Transitive: The “Demographics” domain segment is listed
under “Healthcare Eligibility”, which in turns is also nested
under the “AZ State Eligibility Programs” domain. This implies
accessing domain information in “Demographics” is also
possible under the State’s eligibility program domain.
4.2 Information Sharing Architecture
Fig. 6 depicts the information sharing repository structure. To
make the domain ontology useful for data mapping, the domain
model must be parsed and saved in the ISS repository. In our
prototype we have used SQL SERVER 2008 to implement the
ontology. Here, the combination of Ontology, Ontology_Main
and Ontology_Detail tables represent the domain ontology in a
relational form. The Ontology table stores the ontology name
and number of sections. Ontology_Main stores the selected
ontology structure (as shown in figure 6and Ontology_Detail
stores the enumerated values for a specific domain element.
The data mapping procedure involves three relational tables
(MappingReference_Main, MappingReference_Detail, and
MappingReference_DataValue ) which will be shared among
different data providers for various domain ontology mapping
use. Finally, as there will be at least one data access profile
associated with each of the data providers, the ISSrepository
cooperates with User Profiling Service to maintain the data
access information for each providers using three tables
(Business, Business_Detail, and Business_Connection).
Business table stores each business entity’s ID which is
assigned upon registering their name with the SODB.
Business_Detail stores information about the business
organization and the Business_Connection table is used to store
the enterprise database connection information.

The summary of the domain concept is captured at the root level
element. All non-root elements can represent four entities: (i)
domain attributes, (ii) sub-domains, (iii) sub domain attributes
or (iv) attribute value type. Suppose the depth of the domain
ontology model is greater than one and the node level for the
root element also starts at one. Assume that there exist two
nodes, ei and ej, in the ontology file. If ei is smaller than ej, then
it is said that e1 is a parent of ej. In this scenario, ej can be a
domain or sub-domain attribute of ei, or ej is a specific attribute
value type that belongs to ei. In another scenario, if ei and ej are
at the same node level, which is often referred as siblings, then
ei and ej can be sub-domains that reside under the same domain,
or they can be the attributes under the same sub-domain, or
domain or they can be the attribute type under a specific domain
attribute. The node relationship is summarized in Table 3.
Domain Correlations: The domain correlations have been
defined using the equivalence relation. A binary relation
between two entities in ontology can be grouped together as
being equivalent.
Reflexive relation:
| ei E where ~ denote the reflexive relationship
ei ~ e i
Symmetric relation:
ei, ej E and Rs R
ei Rs ej => ej Rs ei

280

MappingReference_Main
-ID
-Business_ID
-From_Source
-To_Source

MappingReference_Detail
Ontology_Main
-ID
-Ont_ID
-NodeLevel
-Has_Type
-NodeName

Ontology_Detail
-Ont_Main_ID
-Type_Name

parts: select, from and where clauses. The select clause is built
based on the projection statements whereas the where clause is
assembled according to the evaluation statements. The from
clause is composed using the unique combination of projection
and evaluation sub-domain elements (Fig. 7). Each subdomain and its related components (such as attributes,
operators, and domain values) are parsed and stored in a
customized data structure object (P_List and E_List in Fig. 7)
according to its sub-domain type.
After parsing and storing the data query elements in the
customized data structure, each domain components will be
inserted into a temporary table within the information sharing
repository for mapping translation. The mapping translation
process accepts the data provider’s business ID as a parameter
to retrieve the corresponding mapping reference that was given
by the data provider. If the mapping reference exists in the
information sharing repository, then it will be returned to the
service caller. Otherwise, the original data query will not be
translated. As data services can be added / modified
dynamically, the dynamic query composition techniques
provides flexible and “on-the-fly” data integration based on
available data sources.
Dynamic Query Composition:

Business

Ontology
-ID
-Domain
-Min_segment
-Max_segment
-Version
-Timestamp

-ID
-MappingRef_Main_ID
-From_Source_Attributes
-To_Source_Attributes

MappingReference_DataReference
-Ont_ID
-Ont_Main_ID_Parent
-Ont_Main_ID_Child
-Mapped_To_Values
-Mapped_From_Values
-Business_ID

-ID
-Name

Business_Detail
-Business_ID
-Address_Line
-Phone
-Contact_Person
-Contact_Person_Phone
-Contact_Person_Email

Business_Connection
-Business_ID
-Server_Name
-DB_Login
-DB_Password
-DatabaseType
-DatabaseName
-Alias

Figure 6: The Information Sharing Repository structure
4.3 Data Querying
Using ontology as a query language is not new, e.g., OntoDB
[4, 6] use ontology to create database schemas as well as a
query method to access information stored. This paper adopts a
semantic-based query approach to access the shared data
resources. The chosen querying method requires the data
consumer to identify the information domain (e.g., domain
ontology) and the associated domain attributes to compose the
data query. The semantic-based querying method has an
advantage over other querying mechanisms (e.g., keywordbased) as it can effectively capture the semantic definition for
the published information.
Query Syntax. The data query mechanism consists of two main
parts: (i) projection and (ii) evaluation. Projection (the “select”)
is used to project domain elements in the result data set.
Evaluation (the “where”) is used to filter information that
should be included in or excluded from the result data set. A
simple data query consists of one or more sub domain elements
followed by their associated attribute names. Each sub domain
and their attribute name pair is connected by a single dot (“.”).
A comma (“,”) is used to distinguish two separate sub domain
fields. All elements in the data query are case insensitive. The
query syntax for the projection is almost as same as the
evaluation. The only different between the two is that
statements appearing in the evaluation always include an
operator followed by a specific value. Currently, the evaluation
process can support equal, not equal, less than, and greater than
operators.
If the selected ontology structure is known in advance, data
consumers can directly execute the querying service in their
application program. Otherwise, they can utilize the web
interface tool to compose the data query to access the shared
information. When using the data query web page, the data
consumer can select the domain area and the data providers
they are interested in for information retrieval. As it is vital for
data consumers to use the right domain terminology to access
the shared information, the content of the selected domain
model can be dynamically displayed on the interface as a lookup service to assist in the data query composition process.
Dynamic Query Composition: The ISS can dynamically
compose query statements based on selected domain attributes
and selection criteria such as filter conditions specified by the
consumers and the mapping references given by the data
providers upon request. Dynamic query composition algorithm
is shown in Fig. 7. A database query can be divided into three

Parse Projection Query
Parse Evaluation Query
For each selected Data Provider source
{
For each Projection attributes in a selected Sub Domain
{
Append [original source].[original attribute name] to the SELECT clause
Record each distinct mapping source (ex: table name, view name) in the P_List
}
For each Evaluation attribute in a selected Sub Domain
{
Append [original source].[original attribute name] [operator][value] to the AND clause
Record each distinct mapping source (ex: table name, view name) in the E_List
}
// build FROM clause and WHERE clause
If (P_List.Count = 1 and E.List.Count = 0)
{
FROM Clause + = P_LIST’s mapping source
WHERE Clause += “”
}
Else if ( P_List.Count = 1 and E_List.Count > 0)
{
FROM Clause += P_List’s mapping source
For each source Item in E_List
{
If the mapping source = P_List’s mapping source, ignore it
Else,
// each sub domain can be joined using the segment ids
1) FROM Clause + = E_LIST’s mapping source
2) WHERE Clause += prev_E_List’s mapping source segment Id =
curr_E_List’s mapping source segment Id
}
}
Else
{
For each p in P_List-1’s mapping source
{
If E_List contain (p), remove p from E_List
FROM Clause
+= P_List’s mapping source
WHERE Clause += Curr_P_List’s mapping source segment Id =
Next_P_List’s mapping source segment Id
}
For each e in E_List-1’s mapping source
{
FROM Clause
+= E_List’s mapping source
WHERE Clause += Curr_E_List’s mapping source segment Id =
Next_E_List’s mapping source segment Id
}
}
Entire Query = SELECT clause + From clause + Where Clause + And Clause
Send Query to the data provider source
Add Result to Data Set
}
Return Data Set

Figure 7: Dynamic Query Composition Algorithm
5. Case Study: Arizona Healthcare Cost Containment
System
We have modeled and implemented the AHCCCS to illustrate
the ISS.

281

Domain Ontology: Sample healthcare eligibility domain
ontology is shown in Fig. 8. The top most element of the
ontology denotes the business domain area “HealthCare Eligibility”. The “HealthCareEligibility” comprises of three
sub-domain
categories
“Demographics”,
“Eligibility_
Information”, and “Income_Information”. Each of the subdomains represents a distinctive unit within the domain
ontology. Sub-domain segments are different from each other
by the definition of their attributes.
For example, the
“Demographics” sub-domain segment contains all of the general
information of a person record (such as SSN, Name, DOB),
whereas the “Eligibility_Information” segment only contains
the healthcare application related information (ex: Status,
Program Name, etc) for an applicant. A finer level of subdomain definition may be found through attributes with specific
value types.
For example, “Race”, under “Demographics”, is used to
categorize race type like American Indian, Asian or Caucasia,
and “Status”, under “Eligibility_Information”, is used to classify
current eligibility status like Approved, Denied or Discontinued.
The relations mentioned earlier in the chapter can be applied to
the sample ontology as follows:
In the reflexive case, each node in the XML graph is
related to itself.
In the symmetric case, “Demographics” and “HealthCare
Eligibility”, “Status” and “Eligibility_Information”,
“ALTCS” and “MCS”, and “Applicant” and “Role_Type”,
etc, have either a symmetrical of (i) parent of, (ii) child
of, or (iii) sibling of relationships.
In the transitive case, all leaf and intermediate nodes in the
sample ontology are qualified in the transitive relationship.
For example, transitive relations for “DOB” and
“Demographics” and “Demographics” and “HealthCare
Eligibility” is “DOB” and “HealthCareEligibility”.

Query Access Demonstration. To demonstrate how to compose
a data query to access the published data, the
HealthCareEligibility model will be used in this demonstration.
Exampl : Suppose government agency G1 wants to obtain the
SSN, Person Name, and Eligibility Effective Date of the
currently active applicant information published by another
agency G2. The data query should be assembled as shown in
Fig. 9.
6. Performance Evaluation
To test the effectiveness of the proposed ISS discussed in the
preceding sections, service performance and V&V (verification
and validation) analyses have been performed to compare
different service calls with respect to different data query
requests, number of concurrent users and the correctness of the
data result. The ISS is written in C# with ASP.NET 3.5 using
Microsoft Visual Studio 2008 Professional Edition. All
experiments except the simulation program were run on 2.0
GHz Intel Core 2 Duo processor with 2 GB memory and 4MB
cache under Windows Vista operating system. The ISS is
hosted under COX communication residential network with the
maximum of 300 megabytes of traffic. To mock an actual data
sharing environment, the supporting database system (SQL
SERVER 2008) for the information sharing service has added
multiples databases, e.g., AHC_Database, ASU_Databases,
Business001_Databases, Business002_Databases to represent
different data providers’ sources. Testing data used in the
experiments are provided by the State of Arizona training unit
and is randomly distributed into one of these databases.

HealthCare
Eligibility
Eligibility
Information

Demographics

Applicant ID
Type

Income
Information

Effective_
Date

Applicant ID

Applicant ID
Type

Applicant ID
Type

Address

Income_fr
equency

Applicant ID
Applicant ID

City
First_Name

Employer
_name
Employer
Income_
_Address
amount
Employer
_Phone

State

Last_Name

Role_Type

ZipCode
Middle_Name

Income_Received
_Date

Status

Phone_Number
SSN

Race

Authorized
Representative

Program
_Applied
_for
Other

Denied
American
Indian
Black or African
American

Other

Caucasian

Pending
Medicaid
ALTCS

SSI/MAO

Other

Approved
Discontinued

MCS

Information Sharing Service Results

Asian or Pacific
Islander

5000

Figure 8: Health case domain ontology- tree view

Query Number

Preferred_Name

Other

Applicant

DOD
DOB

6.1 Service Response Time
Manual Testing (Fig. 10): The data query performance result
falls within the expected time range in both manual querying
and automated service testing. As the connection speed and the
bandwidth may fluctuate during the day, the slowness of the
internet is still the biggest barrier of the service testing.
Although all experiments were carried out in non-peak hours of
the day, the server response time and page load delay
contributed to the internet connection speed. According to the
log information within the proposed service, the query
composition process was relatively fast (0.1 seconds for data
source reference look-up) but when the query returned from the
service back to the web interface, the page post back took
almost 10 to 20 seconds to the load and display the result set on
the web page.
Automated Service Testing: A multi-threaded simulation
program was written to generate 500 (A), 1000 (B), 2500 (C)
and 5000 (D) data queries to concurrently request data
published within the SODB. To mimic the distributed
environment, the simulation program was purposely run on a
remote desktop that makes remote service call to the service
hosting machine. To maximize the run time for each query
request, the simulation program was configured to send out
various queries in an alternative manner.
4000
3000
Query number

2000
1000
0
0

20

40
Time (second)

60

80

Figure 10: Query Performance Result-Manual Processing

Figure 9 Result of the Query Example

282

Figure 11: Simulation result
with 1000 threads

[5] Genesereth, M., Keller, A., Duschka, O. (1997). Infomaster: an information
integration system. Proceedings of 1997 ACM SIGMOD Conference. pp. 539542.
[6] Jean, S., Dehainsala, H., Xuan, D.N., Pierra, G., Bellatreche, L., (2007).
OntoDB: It is time to embed your domain ontology in your database. Lecture
Notes in Computer Science. Springer Berlin / Heidelberg. Volume 4442/2008. pp.
1119-1122.
[7] Jiang, H., Ho, H., Popa, L., Han, W.S. (2007). Mapping-driven XML
transformation. Proceedings of the 16th international conference on World Wide
Web. pp. 1063-1072.
[8] Rakesh, A., Dmitri, A., Ramakrishnan, S. (2004). Enabling sovereign
information sharing using web services. Proceedings of the 2004 ACM SIGMOD
international conference on Management of Data, pp. 873-877.
[9]Tok, W.T., Bressan, S. (2006). DBNet: A Service-oriented database
architecture, Proceedings of the 17th International Conference on Database and
Expert Systems Applications. Pages 727-731.
[10]Tsai, W.T., Fan, C., Chen, Y., Paul, A.R., Chung, J.Y. (2006). Architecture
classification for SOA-based applications. Object and Component-Oriented RealTime Distributed Computing, Volume 9, pp.295-302.
[11]Tsai, W.T., Liu, X.X., Chen, Y. (2005). Distributed policy specification and
enforcement in service-oriented business systems. Proceedings of the IEEE
international conference on e-business engineering. pp. 10-17.
[12]Tsai, W.T., Zhang, D., Chen, Y., Huang, H., Paul, R.A., Liao, N., (2004). A
software reliability model or web services. Conference on Software Engineering
and Applications, Volume 436, pp.144-149.
[13]Tsai, W.T., Zhou, X.Y., Chen, Y., Xiao, B., Paul, A.R., Chu, W.(2007).
Roadmap to a full service broker in service-oriented architecture. Proceedings of
the IEEE International Conference on e-Business Engineering, ICEBE 2007,
pp.657-660.
[14] Tsai, W.T., Zhou, X.Y., Wei, X., (2008). A policy enforcement framework
for verification and control of service collaboration. Information System EBusiness Management 6, Volume 1, pp83-107.
[15]Uschold, M., Jasper, R. (1993). A framework for understanding and
classifying ontology applications. Proceedings of the IJCAI-99 workshop on
Ontologies and Problem-Solving Methods. Volume 18, pp.11:1-11:12.
[16] Amazon SimpleDB™- Limited Beta. (2008). http://aws.amazon.com/
simpledb/
[17] Cardwell, R. (2006). Government information sharing and interoperability
via data services and SOA. www.xml.gov/presentations/metamatrix/
dataservices.ppt
[18] Department of Defense, Net-Centric Data Strategy. (2003). http://www.
defenselink.mil/cio-nii/docs/Net-Centric-Data-Strategy-2003-05-092.pdf
[19]Gabhart, K. (2007). Data sources as Web Services http://www.xml.com
/pub/a/2007/10/25/data-sources-as-web-services.html
[20]IBM’s WebSphere. (2008) http://www-01.ibm.com/software/websphere/
[21] MetaMatrix, Inc. (2008). http://www.redhat.com/metamatrix/
[22] Microsoft .NET Data Service (2008). http://www.microsoft.com/NET/
http://www.microsoft.com/windowsserver2003/technologies/idm/uddi/
[23] Campbell D., Service Oriented Database Architecture: App Server-Lite?,
TechReport, MSR-TR-2005-129 , Microsoft Research, ACM, Sep
2005.http://www.microsoft.com/sqlserver/2005/en/us/white-papers.aspx
[24]Oracle.(2008).http://searchsoa.techtarget.com/news/interview/0,,sid26_gci12
97968,00.html
[25]Seaman, S.R., Richardson, S. (2001). Bayesian analysis of case-control
studies with categorical covariates. Biometrika, 88(4). pp. 10073-10088.
[26]Srivastava, U., Munagala, K., Widom, J., Motwani, R. (2006). Query
optimization over web services. Proceedings of the 32nd international conference
on Very large data bases, pp.225-366.
[27]The InfoSleuth Agent System. (2005). http://www.argreenhouse.com/
InfoSleuth
[28]Web
Application
Testing
(WAPT)
version
5.0.
(2008).
http://www.loadtestingtool.com/help/response-time.shtm.
[29]WS02. The open source SOA company. (2008) http://wso2.com/services/
consultancy/
[30]BEA WebLogic Server UDDI Registry (2003). http://www.bea.com/
framework.jsp
[31] Novell Nsure UDDI v3 (2007), http://developer.novell.com/uddi/
[32]Solving Cloud Data Integration: A Key Challenge for SAAS Providers,
White
paper,
by
Informatica.
http://www.ebizq.net/white_papers/
11162.html?related)
[33] An overview of cloud computing at Yahoo, Raghu Ramakrishnan , http://
us.apachecon.com/page_attachments/0000/0194/ ApacheCon-09cloud.ppt
[34] Cooper B., Ramakrishnan R., Srivastava U., Silberstein A., Bohannon P.,
Jacobsen H., Puz N., Weaver D., Yerneni R., PNUTS: Yahoo’s! Hosted Data
Serving Platform, (VLDB 2008)
[35]Seeding the Clouds: Key Infrastructure Elements for Cloud Computing, IBM
white paper, Feb 2009
(ftp://ftp.software.ibm.com/common/ssi/sa/wh/n
/oiw03022usen /OIW03022USEN.PDF
[36] Vouk Mladen A., Cloud Computing – Issues, Research and Implementations,
Journal of Computing and Information Technology - CIT 16, 2008, 4, 235–246.

Figure 12: Simulation result
with 500 threads

The service response time (with 500 and 1000 threads)
consistently fall in between 0.1 to 0.15 second for each request.
According to the web service response time benchmark from
WAPT [37], it is an ideal response time (Fig. 11, 12). In
addition, to ensure the proposed ISS is good for its intended use,
the various validation tests have been performed to show the
proposed service meets its requirements

Figure 13: Simulation result with
result with 2500 threads

Figure 14: Simulation
5000 threads

However, the service response time for scenario C and D (with
2500 and 5000 threads) degraded rapidly after the first 200
query requests. The response time for the subsequent requests
takes as much as 0.35 to 0.6 second to complete. The slowness
of the service response for simulation results was a direct result
of the memory and CPU limitation of the computer running the
simulation program. Fig. 15 shows the average and stand
deviation of automated service testing.

Figure 15: Query Performance Result – Simulation
7. Conclusions
This paper proposed an SODB system as a federated collection
of services that facilitate information sharing. The AHCCCS
case study implementation demonstrates the feasibility of the
SODB . Currently, data mapping from the source to the
domain ontology is done by the data service provider. In the
future we plan to investigate how to employ the newly
proposed probabilistic mapping method [14] to reduce the
mapping cost.
8. References
[1] Bianchini, D., De Antonellis, V., Melchiori, M. (2003). Domain ontologies
for knowledge sharing and service composition in virtual districts. Proceedings
of the 14thInternational Workshop on Database and Expert Systems Applications.
pp. 589-605.
[2] Campbell, D. (2005). Service Oriented Database Architecture App ServerLite?. Proceedings of the 2005 ACM SIGMOD international conference on
Management of Data. Pages 857-862.
[3] Dan, A., Johnson R., Arsanjani, A.(2007). Information as a Service: Modeling
and Realization, Systems Development in SOA Environments, ICSE Workshops
May 2007.
[4] Fankam, C., (2008). OntoDB2: support of multiple ontology models within
ontology based database. ACM International Conference Proceeding Series.
Volume 326, pp.21-27.

283

ARTICLE IN PRESS
Journal of Network and Computer Applications 33 (2010) 542–555

Contents lists available at ScienceDirect

Journal of Network and Computer Applications
journal homepage: www.elsevier.com/locate/jnca

A methodology for engineering collaborative and ad-hoc mobile applications
using SyD middleware
Praveen Madiraju b,n, Srilaxmi Malladi a, Janaka Balasooriya a, Arthi Hariharan a, Sushil K. Prasad a,
Anu Bourgeois a
a
b

Computer Science Department, Georgia State University, USA
Department of Mathematics, Statistics and Computer Science, Marquette University, 1313W. Wisconsin Avenue, CU #340, Milwaukee, WI 53233, USA

a r t i c l e in f o

a b s t r a c t

Article history:
Received 31 October 2009
Received in revised form
4 March 2010
Accepted 18 March 2010

Today’s web applications are more collaborative and utilize standard and ubiquitous Internet protocols.
We have earlier developed System on Mobile Devices (SyD) middleware to rapidly develop and deploy
collaborative applications over heterogeneous and possibly mobile devices hosting web objects. In this
paper, we present the software engineering methodology for developing SyD-enabled web applications
and illustrate it through a case study on two representative applications: (i) a calendar of meeting
application, which is a collaborative application and (ii) a travel application which is an ad-hoc
collaborative application. SyD-enabled web objects allow us to create a collaborative application rapidly
with limited coding effort. In this case study, the modular software architecture allowed us to hide the
inherent heterogeneity among devices, data stores, and networks by presenting a uniform and
persistent object view of mobile objects interacting through XML/SOAP requests and responses. The
performance results we obtained show that the application scales well as we increase the group size
and adapts well within the constraints of mobile devices.
& 2010 Elsevier Ltd. All rights reserved.

Keywords:
Collaborative applications
Ad-hoc applications
Middleware for mobile devices
SyD coordination bonds
Mobile web objects
Object and web service coordination

1. Introduction
Rapid development of coordinating distributed applications by
leveraging off existing web entities is key to bringing the
Internet’s collaborative potential to the users at large. Such
collaborative applications span domains as diverse as personal
applications (travel, calendaring and scheduling) to enterprise
e-commerce applications (supply chains, work ﬂows, and virtual
organizations), and scientiﬁc biomedical applications (biomedical
data and process integration, and experiment workﬂows). All the
coordinating applications themselves and the constituent autonomous entities are usually hosted on heterogeneous and autonomous, possibly mobile platforms (Krone et al., 1998). There is an
emerging need for a comprehensive middleware technology to
enable quick development and deployment of these collaborative
distributed applications over a collection of mobile (and wired)
devices. This has been identiﬁed as one of the key research
challenges (Edwards et al., 2002; Phan et al., 2002).
Limitations of current technology: The current technology for
the development of such collaborative applications over a set of
wired or wireless devices has several limitations. It requires
explicit and tedious programming on each kind of device, both for
data access and for inter-device and inter-application commu-

n

Corresponding author.
E-mail address: praveen@mscs.mu.edu (P. Madiraju).

1084-8045/$ - see front matter & 2010 Elsevier Ltd. All rights reserved.
doi:10.1016/j.jnca.2010.03.007

nication. The application code is speciﬁc to the type of device, data
format, and the network. Managing applications running across
mobile devices becomes complex due to lack of persistence data
and weak connectivity. A few existing middlewares have
addressed the stated requirements in a piecemeal fashion. The
current state-of-the-art still lacks in enabling mobile devices with
server capabilities, and developing collaborative applications is
restricted to few domains. It also suffers in providing group or
transaction functionalities and offers limited mobility support.
These issues are further elaborated by Prasad et al. (2004).
Contributions: Our work is an ongoing effort to address the
aforementioned limitations and in Prasad et al. (2004), we
reported our ﬁrst prototype design and implementation of a
middleware for mobile devices called System on Mobile Devices
(SyD). In this paper, we continue our work and utilize SyD’s highlevel programming platform to rapidly engineer group web
applications over a collection of heterogeneous, autonomous,
and possibly mobile data stores. We describe a software
engineering based design methodology with case studies on a
calendar of meetings application (a collaborative application)
(Prasad et al., 2005), and a travel application (an ad-hoc
application). We also show that SyD naturally extends to enabling
collaborative applications across web-based objects. The SyD
objects are stateful, web-based, and provide interfaces like web
services for method invocations. Furthermore, all method invocations and their responses in SyD employ SOAP-like XML
envelopes. Therefore, SyD objects, their interactions, and the

ARTICLE IN PRESS
P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

underlying techniques discussed in this paper have a direct
bearing on web services and their compositions and coordination,
making the development of coordinating applications over mobile
devices easier and faster. The middleware addresses the key
problems of heterogeneity of device, data format and network,
and of mobility. SyD achieves ease of application development,
transparency in mobility of code, and the scalability required for
large enterprise applications with a small footprint (total of 112
with 76 KB being device-resident) required by handheld devices.
SyD also allows creating ad-hoc collaborative applications by
composing or conﬁguring pre-existing SyD objects. The application development is both quick and streamlined using a design
methodology that includes realizing UML design phases with SyD
components (described in Section 4.). We illustrate this with two
sample SyD application case studies later in this work; we brieﬂy
introduce these two application cases below.
Sample SyD application case studies: Currently there are two key
SyD-based applications. We implemented these using various
technologies, including JDBC, SOAP, and SyD. The SyD-based
development was by far the quickest, with more functionalities,
due to high-level APIs of SyD (2–3 weeks each by 3–4 students),
with comparable execution efﬁciencies.
The calendar application is an example SyD application
wherein several individuals manage their time schedules. The
typical functionalities provided in a calendar application are:
(a) set up meeting among individuals with certain conditions to
be met such as a required quorum, (b) set up tentative meetings
that could not be set up otherwise due to unavailability of certain
individuals, and (c) remove oneself from a meeting resulting in
automatic triggers being executed. The triggers may possibly
convert tentative meetings into conﬁrmed meetings. The calendar
application showcases various aspects like constraint-satisfaction
in applications to achieve the required quorum, mobility of
devices, and heterogeneous data and devices as the individuals
maintain their schedules on their devices in a format suitable to
them. To implement our calendar application with the current
technology involves cumbersome programming, such as opening
authorized connections to respective database servers, executing
individual queries against several databases and accumulating
results of these queries, and manually enforcing constraints (by
writing code) that the databases as a whole need to satisfy.
Another problem with the current technology is that it is difﬁcult
to deal with multiple types of heterogeneity in the representation
of time-schedule information. One individual may have different
device, data format, or network from another individual. The
existing calendar systems also have considerable amount of
delays to conﬁrm the availability of all participants and schedule a
meeting. In a calendar application, each user has his own database
that is either stored locally or on a proxy. The application
programming can be logically divided into server side and client
side. The server side comprises of all the methods that interact
with the local data store and can be invoked remotely. The client
side consists of the user interface which enables the user to
interact with the application.
The second application of this study is the travel application. In
our previous work (Hariharan et al., 2004), we demonstrate a
travel application that allows for automatic rescheduling and
cancellation of itineraries. Once an itinerary is decided and the
trip is planned for the user, corresponding links are created and
maintained in the user’s database. If part of the itinerary is
cancelled, then automatic cancellation of further itinerary
schedule occurs. For example in a travel application, if a ﬂight is
cancelled, car and hotel reservations are automatically cancelled,
thus easing the burden on the user to have to manually cancel all
associated reservations. A SyD ad-hoc application developer’s
nook provides a simple GUI-based interface for the application

543

developer to initially set up and develop SyD-enabled collaborative applications.
The rest of the paper is organized as follows. Section 2 provides
a background on the SyD middleware. Section 3 details distributed and ad-hoc collaborative applications. Section 4 describes a design methodology for collaborative applications using
a case study on a calendar of meetings application. Section 5
describes ad-hoc collaborative applications design using a case
study on a travel application. We present implementation details
of an important module relevant to this work in Section 6. Section 7
discusses implementation of a calendar of meetings application and
its performance results. In Section 8, we compare our work with the
current state-of-the-art. Finally, we make concluding remarks in
Section 9.

2. SyD architecture and coordination bonds—background
In this section, we describe the design of System of Mobile
Devices (SyD) (Prasad et al., 2003a) and related issues, and
highlight important features of its architecture. Each individual
device in SyD may be a traditional database such as a relational or
object-oriented database, or may be an ad-hoc data store such as a
ﬂat ﬁle, an EXCEL worksheet or a list repository. These may be
residing in traditional computers, in personal digital assistants
(PDAs), or even in devices such as a utility meter or a set-top box.
These devices are assumed to be independent in that they do not
share a global schema and therefore rules out the possibility of
unique data representation. The devices in SyD cooperate with
each other to perform interesting tasks, and we envision a new
generation of collaborative applications built using this SyD
framework.
2.1. SyD architecture overview
The SyD architecture is shown in Fig. 1. SyD uses the simple yet
powerful idea of separating device management from
management of groups of users and/or data stores. The SyD
framework accomplishes distinct management of devices, user
data stores and their coordination when needed with its three
layered architecture. At the lowest layer, individual data stores
such as device data or personal data are represented by device
objects that encapsulate methods/operations for access, and
manipulation of data (SyD Deviceware). For example, the data
objects are high level wrappers for a ﬂat ﬁle or an excel ﬁle or an
XML ﬁle. At the middle layer, there is SyD Groupware, a logically
coherent collection of services, APIs, and objects to facilitate the
execution of application programs. This forms the middleware
kernel API. At the highest level are the SyD Applications
themselves such as the calendar and travel applications
discussed in this paper. The applications rely on middle and
lower layer SyD services, and are independent of device, data and
network, making the applications appealing to all kinds of
heterogeneity.
We have developed a prototype test bed of SyD middleware
that captures the essential features of SyD’s overall framework.
We have designed and implemented a modular SyD kernel in Java.
In Fig. 2, we present the internal architecture of the SyD
middleware. The SyD Kernel includes the following ﬁve modules:
SyDDirectory: Provides user/group/service publishing, management, and lookup services to SyD users and device objects. Also
supports intelligent proxy maintenance for users/devices.
SyDListener: Provides a uniform object view of device services,
and receives and responds to clients’ synchronous or asynchronous XML-based remote invocations of those services (Prasad
et al., 2004). Also allows SyD device objects to publish their

ARTICLE IN PRESS
544

P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

services locally to the listener and globally through the directory
service.
SyDEngine: Allows users/clients to invoke individual or group
services remotely via XML-based messaging and aggregate
responses. This yields a basic composer of mobile web services.
SyDBond: Enables an application to create and enforce
interdependencies, constraints and automatic updates among
groups of SyD entities and web Services (Prasad et al., 2003b;
Prasad and Balasooriya, 2004)
SyDEventHandler: This module handles local and global event
registration, monitoring, and triggering.
To register services with the middleware, the SyD Application
Object Server (shown in the left of Fig. 2) publishes applications
with SyDListener. The SyDListener then registers globally with

SyDDirectory. In order to call these services, the client user
interface (Client UI) makes a remote invocation for some of the
application services by invoking the SyDEngine. The SyDEngine
then makes a lookup with the SyDDirectoy, and ﬁnds the required
information for making a remote call such as URL information for
the application services. The SyDEngine then eventually makes a
remote invocation using TCP/IP on the SyD Application Objects
(SyDAppO). SyD applications are likely to be hosted on mobile
devices that frequently suffer from intermittent disconnections or
battery discharges. The SyD framework therefore provides
tolerance for disconnected devices through its proxy. Extended
details regarding the SyD middleware can found in Prasad et al.
(2003a).
A key goal of SyD is to enable SyD objects to coordinate in a
distributed fashion, possibly in an ad-hoc way. Each SyD object is
capable of embedding SyD coordination bonds to other entities
enabling it to enforce dependencies and act as a conduit for data
and control ﬂows. Over data store objects, this provides active
database like capabilities. In general, aspect-oriented properties
among various objects are created and enforced dynamically. Its
use in rapid conﬁguration of ad-hoc collaborative applications,
such as a set of calendars for a meeting setup (Prasad et al.,
2003b), or a set of inter-dependent web services in a travel
reservation application (Hariharan et al., 2004), has been demonstrated. The SyD bonds have the modeling capabilities of extended
Petri nets and can be employed as general-purpose artifacts for
expressing the benchmark workﬂow patterns (Prasad and
Balasooriya, 2004, 2005)

2.2. SyD coordination bonds

Fig. 1. SyD architecture.

Coordination bonds enable applications to create contracts
between entities and enforce interdependencies and constraints,
and carry out atomic transactions spanning over a group of
entities/processes. The constraints and dependencies can be of
QoS type like budget, deadline, etc., or member dynamics such as,
all inclusion (and), exclusion (xor), any inclusion (or), etc., or any
user deﬁned constraints. While it is convenient to think of an
entity as a row, a column, a table, or a set of tables in a data-store,
the concept transcends these to any SyD object or its component.
There are two types of bonds: subscription bonds and negotiation

Fig. 2. Interaction among modules of SyD kernel.

ARTICLE IN PRESS
P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

bonds. Subscription bonds allow automatic ﬂow of information
from a source entity to other reference entities that subscribe to
it. This can be employed for synchronization as well as more
complex changes, needing data or event ﬂows. Negotiation bonds
enforce dependencies and constraints across entities and trigger
changes based on constraint-satisfaction. SyD bonds may be
further combined with other constraint logics like and, or, xor,
which are user deﬁned (Joshi, 2005).
A SyD bond is speciﬁed by its type (subscription/negotiation),
status (conﬁrmed/tentative), references to one or more entities,
triggers associated with each reference (event-condition-action
rules), priority, constraints (and, or, xor), bond creation and expiry
times, and a waiting list of tentative bonds (a priority queue). A
tentative bond may become conﬁrmed if the awaited conﬁrmed
bond is destroyed. Let an entity A be bonded to entities B and C,
which may in turn be bonded to other entities. Under subscription
bond logic, a subscripted change in A may trigger changes in B and
C, and under negotiation bond logic, A can change only if B and C
can be successfully changed. In the following, the phrase ‘‘Change
X’’ is employed to refer to an action on X (action usually is a
particular method invocation on SyD object X with speciﬁed set of
parameters); ‘‘Mark X’’ refers to an attempted change that triggers
any associated bond without an actual change on X (Balasooriya
and Prasad, 2005; Prasad and Balasooriya, 2005).
Subscription Bond: Mark A; If successful, Change A then Try:
Change B, Change C. A ‘‘try’’ may not succeed.
Negotiation-and Bond: Change A only if B and C can be
successfully changed. (Implements atomic transaction with
’’and’’ logic.)
Semantics (may not be implemented this way):
Mark A for change and Lock A
If successful
Mark B and C for change and Lock B and C
If successful
Change A
Change B and C
Unlock B and C
Unlock A
Note that locks are only for the explanation of the bond
semantics. A reservation/locking mechanism to implement this
usually will have an expiry time to obviate deadlocks. In a
database web service, this would usually indicate a ‘‘ready to
commit’’ stage.
Negotiation-or Bond: Change A only if at least one of B and C can
be successfully changed. (Implements atomic transaction with
‘‘or’’ logic and can be extended to at least k out of n.)
Semantics:
Mark A for change and Lock A
Mark B and C for change; Obtain locks on those entities that
can be successfully changed.
If obtained at least one lock
Then Change A; Change the locked entities.
Unlock entities
Negotiation-xor Bond: Change A only if exactly one of B and C
can be successfully changed (implements atomic transaction with
’’xor’’ logic and can be extended to exactly k out of n).
Semantics:
Mark A for change and Lock A
Mark B and C for change. Obtain locks on those entities that can
be successfully changed.

545

If obtained exactly one lock
Then Change A; Change the locked entities.
Unlock entities
Notations: A subscription bond from A to B is denoted as a
dashed directed arrow from A to B. A negotiation bond from A to B
is denoted as a solid directed arrow from A to B. A negotiation—and
bond from A to B and C is denoted by two solid arrows, one each to
B and C, with a ‘‘n’’ in between the arrows. Similarly, a
negotiation—or bond from A to B and C is denoted by two solid
arrows, one each to B and C, with a ‘‘+ ’’ in between the arrows. A
negotiation-XOR bond from A to B and C is denoted by two solid
arrows, one each to B and C, with a ‘‘^’’ in between the arrows. A
tentative bond, which is a negotiation bond in a waiting list, is
shown as a solid arrow with cuts.
A negotiation bond has two interpretations: pre-execution and
post-execution. In case of pre-execution, in order to start activity
B, A needs to complete its execution. In case of post-execution, in
order to start activity B, B needs to make sure that A can be
completed afterwards. In this paper, we have primarily employed
the pre-execution type of negotiation bonds.

3. Collaborative applications—distributed and ad-hoc
In this section, we introduce two kinds of collaborative
applications, and illustrate them with our case studies on a
personal system of calendar application and travel application
used as case studies throughout the paper. Both distributed
applications of personal system of calendar application and adhoc travel application can be easily developed using the SyD
framework and showcase SyD capabilities effectively.
3.1. Collaborative SyD applications
Collaborative group applications leverage off multiple constituent web entities, where each of those entities is a server
application/component or an object or a data store. A centralized
coordinator application resides on one host and composes or
conﬁgures multiple SyD objects (which may themselves be
typically distributed). Composition is achieved through method
calls of constituent objects. Conﬁguration additionally employs
the SyD coordination bonds to establish ﬂow and dependency
structure between coordinator application and constituent objects. These get triggered at various points in execution of
coordinator application.
Centralized vs. distributed coordination: Not much work has
been done in the area of web service composition for small mobile
wireless devices. Disconnection and memory constraints are two
important issues considered while designing any application
targeted for small handheld devices. Chakraborty et al. (2004)
survey the issues related to service composition in mobile
environments and evaluate criteria for judging protocols that
enable such composition. It states that many of the current
technologies, still, do not cover all these aspects in their
implementation. Some of the proposed approaches that handle
centralized coordination of web services suffer from central point
of failure despite making the design and implementation simple.
As opposed to the prevailing centralized coordination, distributed
coordination has the following two advantages: (i) due to
security, privacy, or licensing imperatives, some web-based
objects will only allow direct pair-wise interactions without any
coordinating third-party entity; and (ii) centralized coordination/
workﬂows suffer from issues such as scalability, performance,
fault tolerance, etc. Achieving coordination in collaborative

ARTICLE IN PRESS
546

P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

applications consisting of composed web services for mobile
environment is still an evolving area and much work needs to be
done. A distributed coordinator application primarily employs
SyD bonds among constituent SyD objects and thus is co-hosted
distributively.
Ad-hoc Applications: Ad-hoc SyD applications leverage off preexisting objects and typically create coordinated application by
simple composition of constituent objects or simple conﬁguration
using SyD bonds. An ad-hoc application allows web-enabled
objects to ﬁnd services of common interest and compose them to
suit the application need. The composition and integration of
these objects may vary from being simple (without any
constraints enforced) to complex (with pre-deﬁned constraints
among the objects). The constraints can be deﬁned over a group of
users, objects and/or applications. We refer such a collection of
group dependency objects as an ad-hoc group SyD object. All SyD
objects are autonomous objects that can communicate in a
distributed, peer-to-peer fashion and can be made web-enabled.
SyD provides a way to build on-the-ﬂy applications by a proper
composition and integration of the pre-existing SyD objects for
simple applications and additionally conﬁguring SyD bonds for
complex applications. SyD gives a methodology to conﬁgure SyD
objects on-the-ﬂy via an ad-hoc application development. We
give a design methodology and calendar speciﬁc details of the
development methodology in Section 4.
Garbinato and Rupp (2003) deﬁne that ad-hoc applications
meet three essential criteria of: (i) mobility, (ii) peer-to-peer, and
(iii) collocation. SyD applications reside on mobile, heterogeneous, and autonomous devices giving application level mobility.
SyD enabled mobile devices can serve both as a client/server to
any service. SyD users communicate with each other in a peer-topeer fashion. By the deﬁnition of collocation, the application is
proximity-restricted and has to end up in a physical transaction.
SyD supports both logical and physical proximity based applications. The SyD applications qualify with these criteria.

3.2. A calendar of meetings application
A calendar of meetings application illustrates a distributed
coordinator application. Prasad et al. (2003b) demonstrated how
an empty time slot is found, how a meeting is setup (tentative and
conﬁrmed), and how voluntary and involuntary changes are
automatically handled. We now provide an overview here. A
simple scenario is as follows: A wants to call a meeting between
dates d1 and d2 involving B, C, D and himself. After the empty slots
in everybody’s calendar are found, a ‘‘negotiation-and bond’’ is
created from A’s slot to the speciﬁc slot in each calendar table
shown as solid lines (Fig. 3).
Choosing the desired slot involves an attempt to write and
reserve that slot in A’s calendar, triggering the negotiation—and
bond. The sequence of actions of this bond is to: query each table
for this desired slot, ensure that it is not reserved, and reserve this
slot. If this sequence of actions succeeds, then each corresponding
slot at A, B, C and D create a negotiation bond back to A’s slot. Else,
for those individuals who could not be reserved, a tentative back
bond to A is queued up at the corresponding slots to be triggered
whenever the status of the slot changes. Assume that C could not
be reserved. Thus, C has a tentative bond back to A (shown as solid
line with dashes), and others have subscription bond, shown as
dotted line, to A (Fig. 4). Whenever C becomes available, if the
tentative bond back to A is of highest priority, it will get triggered,
informing A of C’s availability, and will attempt to change A’s slot
to be conﬁrmed. This triggers the negotiation—and bond from A
to A, B, C and D, resulting in another round of negotiation. If all
succeed, then corresponding slots are conﬁrmed, and the target

Fig. 3. A scheduled meeting

Fig. 4. A tentative meeting.

slots at A, B, C, and D create negotiation bonds back to A’s slot
(Fig. 4). Thus, a tentative meeting has been converted to
conﬁrmed. Now suppose D wants to change the schedule for
this meeting. The reschedule meeting process happens
automatically in real time. A reschedule request from D triggers
its’ back bond to A, triggering the forward negotiation—and bond
from A to A, B, C, and D. If all succeed, then a new duration is
reserved at each calendar with all forward and back bond
established. If not all can agree, then D would be unable to
change the schedule of the meeting.

3.3. An ad-hoc travel application
The technologies with Web services have progressed a long
way now and have become more sophisticated, interconnected,
and interoperable. A travel application can integrate the reservations of ﬂights, rental cars, and hotel accommodations. Most
existing travel reservation applications do not combine and
maintain a global relation among these services. As a result,
manual changes need to be performed if one portion of the
itinerary changes. The process behind such applications would
not only integrate these Web services, but also enforces QoS
constraints, such as deadlines, budgets, etc. This application integrates
the reservations of ﬂights, rental cars, and hotel accommodations
using Web Bonds (further explained in Section 5). The development
of this application exploits the rapid application development feature
of SyD. SyD coordination bonds in web-enabled SyD objects serve as
web bonds. By leveraging off existing web services, the developer

ARTICLE IN PRESS
P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

547

needs only to select the desired services via UDDI and include the
required global logic to link the chosen services.
As mentioned above, the travel application allows for automatic rescheduling and cancellation of itineraries. Once an
itinerary is decided and the trip is planned for the user, bonds
that are created are maintained in the user’s database. This way,
the itinerary is still ’’alive,’’ meaning there is a global relation over
these web services and thus providing ‘statefulness’ to the web
services. Any changes made in any one of the web services will
affect the other web services associated with that current service.
If the ﬂight is cancelled, then automatic cancellation of car and
hotel reservations will be triggered, thus easing the burden of the
user to manually cancel all associated reservations.

4. Designing collaborative applications
In this section, we give a methodology for designing collaborative application using concepts of SyD.
4.1. Methodology
SyD middleware provides components to aid easy development of collaborative applications that span from centralized to
pure distributed. Collaborative applications interact with each
other and in the process may encounter data dependencies,
control dependencies, or both depending on the nature of the
application.
The SyD components provide an effective way of collaboration
with heterogeneous peer devices and also provide a way to
enforce dependencies. SyD bonds provide methodologies to
enforce data and control dependencies in such application
scenarios. The challenge is to associate SyD bonds in an early
stage of application design for its effective use. In fact, one can
follow standard UML design methods to design applications
(Fowler and Scott, 2002) and then insert SyD artifacts at
appropriate design phases as required. We will explain the design
process of a collaborative application using SyD middleware and
SyD bonds based on UML (Pressman, 1997).
The sequence of steps for designing distributed applications
using the concepts of SyD is (captured in Fig. 5):
Step 1: As an initial step, requirement speciﬁcation is given by
the user of the application system describing the way the system
is expected to work.
Step 2: A requirement analysis is carried out to identify actors
and use cases. An actor is an external entity (person, another
system, or object) that uses the system. Use cases are either text
descriptions or ﬂow descriptions of how actors interact with the
system in all scenarios encountered in the applications. From use
cases and actors, use case diagrams are drawn. Use case model
diagrams show interaction between actors and all use cases.
Step 3: Based on the derived use case diagrams, use cases and
actors from Step 2, activity diagrams are developed. UML activity
diagrams are equivalent to ﬂow charts and data ﬂow diagrams in
object-oriented paradigm. In activity diagrams, the data ﬂow
spans across use cases and allows one to identify data and method
inter-dependency of the use cases at an abstract level. These data
and control dependencies can be analyzed, attributed as SyDbondable and may be realized using SyD bonds in the later step.
Step 4: The identiﬁcation of classes and class diagrams follows
activity diagrams. Class diagrams represent the static behavior of
the system. Class diagrams describe the object types in a system
and their relationships. Class diagrams model class structure and
its contents using design elements such as classes, packages, and
object. The persistent or non-persistent data objects with
dependencies can be modeled using SyD methods to automate

Fig. 5. A collaborative application design process.

any method invocation needed for the application. Dynamic
behavior of the system is modeled using sequence diagrams and
collaboration diagrams. Both these diagrams help to identify
inter-service dependencies at method level where we can apply
SyD bonds to enforce them. Such design can further be clariﬁed
using communication diagrams that show the message ﬂow
between objects.
Once all the objects, data, data dependencies, and control
dependencies have been identiﬁed and modeled using SyD and
other components, implementation can begin. Server logic can be
coded starting from SyD-listener skeleton which is middleware
speciﬁc. Client coding can be started using SyDBond, SyDEngine,
SyDDoc directory logic which is application speciﬁc. Fig. 5 shows
our collaborative application design process.
4.2. Designing calendar application—A case study
Here, we illustrate the design process with a distributed
calendar application. We will limit the discussion to particular
scenarios in the system wherever appropriate.
Step 1: The requirements speciﬁcation details the view of user
and addresses the aspects of the beneﬁts of the new system,
interaction with other systems and system functionality. This
includes the details of available time slots, its representation,
need to collaborate before deciding on a place and time to meet,
any constraints to be met, etc. Based on the speciﬁcation, several
different use cases are identiﬁed for calendar application. The use
cases of interest are: get available times, setup meeting, cancel
meeting, view calendar, reschedule meeting, create bond, and delete
bond.
Step 2: The actors and its interactions are then modeled as use
case diagrams. The text description of the cancel meeting use case
is given in Table 1. The interaction between the actors and all use
cases of the system can be given in a use case model diagram.
Step 3: We extend use case diagram of cancel meeting to the
activity diagram for cancel meeting. For the calendar application,
the method call for cancel meeting checks for any dependencies
associated in its execution (see Fig. 6).

ARTICLE IN PRESS
548

P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

Table 1
CANCEL_MEETING Use Case.
Use case name

CANCEL_meeting

Participating actors
Entry condition

Application, initiator, system
1. Cancel meeting option is selected by the Initiator or
is invoked by system.
2. System invokes CANCEL_MEETING.
3. Conﬁrmation of cancel meeting sent to all attendees.
4. System checks for any associations waiting on the
initiator.
6. All the associations waiting up on are now converted
to conﬁrmed status.
7. All the associations are informed of the change.
8. Return to main menu.

Flow of events

Exit condition
Special requirements

composing and bonding existing and new constituent objects.
Within this section, we will describe the design process a user will
employ to develop such an ad-hoc application. The development
procedure involves using the developer’s nook, which is the SyD
ad-hoc application development environment. We will also
explain the detailed steps performed in developing the travel
application (our second case study application).
5.1. Ad-hoc application design
Users can develop and deploy ad-hoc collaborative applications on-the-ﬂy by leveraging off the pre-existing providers of
services/methods and data sources, SyD Client Objects (SyDCOs),
SyD Middleware Objects (SyDMWOs) and SyD Application Objects
(SyDAppOs), by composing the SyDCOs and non-SyD objects in an
application-speciﬁc structure through SyDBonds as follows:
(a) Search and locate the required SyDCOs and other objects by
employing the SyD Directory Service.
(b) Develop and deploy the ad-hoc SyD collaborative application
(SyDAppO) by employing a suitable domain-speciﬁc GUIbased SyD ad-hoc application developer service as follows:
1. Choose the desired SyDCOs and other objects to be part of this
ad-hoc application SyDAppO.
2. Create SyD bonds among the SyDCOs and other objects and
deﬁne the attributes of each bond thereby establishing the
required constraints and dependencies among the constituent
objects (or their parts), and verify the intended functionality
and QoS attributes by a simulated execution.
3. Launch the ad-hoc application SyDAppO thereby registering it
with the SyD Directory Service.

Fig. 6. CANCEL MEETING activity diagram.

As shown in Fig. 6, dependencies are managed using bonds and
deleting corresponding bonds make sure that all required
attendees agree on the cancellation. The presence of conﬁrmed
dependencies will result in its successful execution. However, in
case of tentative dependencies, a reschedule is triggered resulting
in an automatic execution of the scenario ‘‘conversion of status’’,
in case of no conﬂicts. These method dependencies indicate placeholders for SyD methods (Prasad and Balasooriya, 2004, 2005).
Step 4: The methods cancel meeting (attendeelist, starttime,
and endtime), reschedule (attendeelist, starttime, and endtime),
conﬁrm meeting (attendeelist, starttime, and endtime), etc., when
executed in the calendar application result in the update of
dependent data objects. These data dependencies indicate placeholders for SyD bonds. The identiﬁed objects and dependencies
that can be enforced using SyD bonds are identiﬁed in the
resulting class diagram.

5. Designing ad-hoc collaborative applications
SyD allows rapid development of a range of portable and
reliable collaborative applications, including ad-hoc applications
by the users. It provides well-deﬁned steps and a layered
middleware environment to quickly develop applications by

Register the resulting sydgroups and applications so that
further applications may be built.
All the devices with SyD middleware installed on them, can
host SyD enabled applications called SyDAppos. To run an
application, the application is launched on a home SyDMW (each
application may have a home SyDMW providing specialized
SyDMWOs), and registered with the home and other SyDMWs. A
typical user may run this application by joining the group of users
executing on the home SyDMW. Another option is that client’s
SyDMW downloads the application and launches it. The third
scenario is that the client’s SyDMW runs the application locally,
but employs the home SyDMW for its special services. As can be
seen, the process of developing SyD applications is highly
distributed. Data stores are accessed via SyDCOs that encapsulate
them, SyDAPPOs coordinate the collection of SyDCOs involved in
the application, and SyDMW provides the various services that
enable group and communication primitives. This highly distributed approach to application development creates ﬂexibility
and ease of programming, allowing rapid development of
applications.
5.2. Designing travel application: A case study
As mentioned in Section 3.3, the travel application integrates
the reservations of ﬂights, rental cars, and hotel accommodations
by using SyDBonds. The process behind this application is the web
services framework, so that the application not only integrates
these existing web services, but also enforces QoS constraints,
such as deadlines and budgets.
The centralized coordinator of the travel application is the
SyDBond module. It is the module that invokes the appropriate
methods and web services required. SyDBond also automatically
triggers requests to web services that are interlinked. It is

ARTICLE IN PRESS
P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

therefore in-charge of wrapping the method invocation into SOAP
requests, and getting back the response and returning only the
desired result back to the user. The travel application takes
advantage of the rapid application development feature of SyD. By
leveraging off of existing web services, the developer needs only
to select the desired services (by providing the WSDL) and include
the required global logic to bond the chosen services.
Rather than creating distributed bonds that are maintained
across each of the web service objects, the SyDBond module can
serve as a central coordinator. This is implemented in our travel
application. The web services that are collaborating with our
travel application are legacy web services and are not SyD
enabled. For this reason, these services are not capable of
coordination bonding between the various entities. To enable
legacy services with coordination bond logic, the SyDBond
module wraps the method invocations into SOAP requests, which
can then be processed by the legacy web services.

Since travel application involves negotiation bonds among
various phases of its itinerary, we need a mechanism to enforce
dependencies and constraints across entities and trigger changes
based on constraint-satisfaction. The non-SyD-enabled web
services will not be able to perform the constraint checking and
automatic triggering. By centralizing this control across the
entities at the SyDBond module, we are able to interlink existing
web services together with the coordination of multiple bonds.
The bond module holds all associated methods for a particular
service. As shown in Fig. 7, if one service is cancelled, this will
automatically trigger the deletion methods on all associated or
interlinked services.
Just as the SyDBond module is responsible for coordinating
particular methods across entities and automatically triggering
methods on services that are bonded together, it is also
responsible for enforcing speciﬁed constraints. Fig. 8 shows how
the SyDBond module is the centralized coordinator for checking

Fig. 7. Automatic triggers of methods.

Qu

Result

Application

Itinerary

SyDBonds

ery

a
av

ilab

ility

Query availability

Qu

ery

Global constraints if any

549

av

ail

ab

ility

SyDBond database

Fig. 8. SyDBond as centralized coordinator—travel reservation application.

ARTICLE IN PRESS
550

P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

these constraints. The bond module holds all associated methods
for a particular service. The enforcement of constraints is
performed across all entities that are interlinked, but it is
performed through the communications invoked by the
SyDBond module.

6. Implementation of SyDBond module
In the previous section, we have presented centralized
coordinating and constraint checking across multiple applications
using SyDBond module. The implementation details of SyDBond
module and SyD database are explained in this section. We
provide the details to set up the SyDBond database, its tables, and
how to identify and associate SyDBond methods. We also show
the procedure for initial set up of the travel application by using
the developer’s interface. The developer’s interface is simple and
menu driven. With just a few clicks, one can setup the necessary
SyDBond database, initialize tables, view the services available,
and specify constraint logic. The developer simply needs to
specify the database username, password and the jdbc connection
string and the tables are then setup automatically for the user.
6.1. Initial setup of SyDBond database
All the information concerning a bond is maintained in a bond
database that is stored locally by the user. This bond database is
created for a user when he/she installs a SyD application with
bond-enabled features. As of now, SyDBond is compliant only
with Oracle database.
Some of the important tables that are created include:

 syd_bond: main table that holds the details of bonds
 bond_method: holds the method names and corresponding




names of methods to be triggered upon automatic updates,
cancellations, etc.
waiting_bond: holds the waiting bond details
service_info: stores details of web services, its wsdl URL and
methods
global_constraint: used for maintaining global constraints such
as budget, deadlines, etc.

Population of SyDBond tables: This is an important event of the
initial set up. The application developer gives details of the web
services that are to be included in the application. The details
include the service name, the wsdl url, and optional features such
as the list of methods that can be invoked and an associated
priority. Once the developer feeds in the data, the parsewsdl
method in SyDBond may be invoked. This method parses the
speciﬁed wsdl ﬁle and stores the lists of methods that are listed in
the web service. All the required information is then stored in the
service_info table of SyDBond database. The developer has an
option to view service info table any time and see the list of web
services available, add or delete entries within the table in an easy
manner.
Enforcing constraints and interdependencies are some of the
vital features of SyDBond. In order to achieve this, the constraint
and bond_method tables have to be populated. The constraint table
holds information as to which methods of the web services are
related with constraints such as budgets, deadlines. Likewise, the
bond_method table holds the list of methods and their associated
methods to be triggered. This information is used for automatic
triggering on events in case of cancellations or reschedules. Once
the SyDBond tables are populated we can use the methods of
SyDBond to develop new applications in an ad-hoc manner.

6.1.1. Using SyD developer’s nook for initial set up
The SyD middleware provides a simple GUI-based interface for
the application developer to initially setup and SyDBond-enable
his/her application. We refer to this interface as the Developer’s
Nook, as it provides a separate working area for the application
developer. As SyDBond attempts to make things as automated as
possible, the developer needs to initialize certain entities based on
the business logic. He/she is given access to different GUI screens
to perform various functions such as setting up database tables,
populating table values, specifying constraints and methods that
qualify for auto-triggering. We will go through in depth details for
selective functions.
The application developer can also specify the constraints on
web services that are to be interlinked using the SyDBond module.
The developer speciﬁes a service name (e.g. Flight Service) and
gives its wsdl URL (e.g. http://www.xmethods.net/sd/2001/Flight
Service.wsdl). The developer also has an option to enumerate the
methods in the service. This in turn, invokes methods of SyDBond
that parses the wsdl. If the location of the URL is faulty, an
appropriate error message is thrown.
The application developer can specify constraints associated
with methods. This is also done using a simple GUI. When the
developer chooses the desired method and the associated
constraint, entries are made in the user’s database. This information is later used by the SyDBond module to check for constraints
associated with methods. Upon service method invocation
through SyDBond, it checks to see the associated constraints on
the methods. The application developer also chooses the methods
that are to be bonded. These details are stored in the database of
the user. SyDBond, upon any method invocation checks to see for
associated methods that are to be triggered. It then automatically
invokes the rest of the methods that are bonded.
After the initial set up is complete, the application developer
can ﬁnalize the details pertaining to the application. In the travel
application, this includes creating the login page and a main page
that offers the appropriate options that include viewing one’s
itinerary, making/rescheduling one’s reservation or viewing their
set up page.
For instance, the user makes reservations by selecting the
necessary itinerary entities. The user also has an option to specify
any constraints that needs to be considered such as budget, time,
etc. Once the user gives all these details, SyDBond ﬁrst packs the
details in a SOAP request, branches out to various web services
and invokes the corresponding methods. It then returns the
appropriate results back to the user. Once the user has decided on
the itinerary, after the conﬁrmation, SyDBond then forms the
bonds for this itinerary. The bonds are then ‘‘live’’ meaning that
any change in any one of the entities of the bond, causes an
automatic affect on the other entities.
When itineraries are displayed, the user has an option to
cancel his/her itineraries. When the user chooses any one of the
segments to be cancelled, automatic cancellations of the rest of
the trip is done by SyDBonds. When user chooses to cancel, say,
user’s ﬂight reservations, SyDBond checks to see if there are
any auto triggers associated with that method. It checks in the
database for associated methods to be triggered. Once
the methods are identiﬁed, it automatically invokes the rest of the
methods and all bonded segments of the itinerary are cancelled.

6.2. Signiﬁcant SyDBond methods
As we have seen, the effort taken by the application developer
to develop an application is minimal. An application developer
needs to mainly participate only in the initial set up and
developing the GUI. Listed below are some of the important

ARTICLE IN PRESS
P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

SyDBond methods that help to accomplish this ease of development of an application:

 createSyDBondDatabase: This method is invoked to create all

















the necessary tables of SyDBond. This call is done initially
when the application developer needs to make an application
SyDBond- enabled.
createSyDBond: This method is used to form associations or
bonds among entities. When a schedule is decided upon, bonds
are created. Details like source entity, destination entity, start
time, expiry time, constraints, priority, comments, etc., are
speciﬁed and a bond between the source and the destination
entities is created. These details are later used by the SyDBond
module for automatic reschedules, and updates.
parseWsdl: This method parses the wsdl ﬁle of the web
service, lists out the methods that can be invoked, parameters
to be used, etc. The application developer initially, gives the
url location of the web services which he desires to integrate.
This method is then invoked to parse the wsdl. A DOM parser
is used in this method to parse the XML document.
Methods names (and their parameter types) of the given web
service are then extracted and placed in a table for further
reference.
packAndSend: This method is used to invoke methods of web
services. This creates the SOAP envelope by packing the
necessary parameters and sends the request to the web
services. When a SOAP response it obtained, it then returns
the desired output back to the user.
packAndSendConstraints: This method is also used to
invoke methods of web services. This creates the SOAP
envelope by packing the necessary parameters and sends the
request to the web services. However, methods that are
associated with constraints like budget are executed
through this method of SyDBond. The resulting response is
aggregated and the only results that satisfy the constraints are
returned.
viewBonds: This method is used to view all the bonds
associated with a particular user. This is a simple yet useful
method of SyDBond. In case of a travel reservation application,
upon this method invocation, would result in the itineraries
being displayed.
autoTrigger: Before any method is executed, it is ﬁrst checked
to see if there are any methods coupled with it that need to be
triggered. This method of SyDBond is used to realize it. Multithreading of methods is employed to achieve faster execution
time.
checkOnWaitingBonds: This method is invoked upon any bond
deletion. A check is done to see if there are any waiting bonds
associated with the bond currently being deleted. If there is
such a case, then the waiting bond is converted to a permanent
bond and an entry is made in the bond table.
deleteBond: This method is invoked upon any bond deletion. A
check is done to see if there are any associated bonds to be
deleted (using autoTrigger method) and the bonds are
physically removed from the database.

551

meeting especially involves following all the interdependencies
and automatically converting a tentative meeting to permanent
based on priority. Using SyDBonds the application can call
deleteBond( ), which follows the following steps to achieve
automatic triggering.
1. Check to see if there are any associated waiting bonds.
2. If so, automatically convert status of waiting bonds from
tentative to permanent through SyDEngine.
3. Delete the local bond.
4. Invoke deleteBond on the rest of the associated bonds.
5. Update the calendar database of the user.
6. SyDEngine gets the remote URL of the associated users from
the SyDDirectory Service and invokes the necessary method.
7. Repeat steps 1 through 6 for each associated user.
7. Calendar application implementation and experiments
In this section, we discuss implementation and experiments on
the calendar of meetings application. The performance metrics
like response time, server processing time, etc., for various
meeting scenarios are evaluated and compared.
7.1. Calendar application implementation
The design of the calendar application has been implemented
on HP iPAQ H3600 and H3700 series running windows CE
operating system. Here, we describe implementation details
providing insights into the development process. These development logistics and device-level details should help developers of
similar applications for mobile devices.
Step 1: We implemented SyD Middleware (as a Java package)
and Calendar code using Java JDK 1.3. The system user interface
was designed using Java Applets. We used Oracle8i as the back
end database for storing SyD bond and application speciﬁc tables.
All were implemented on a PC. Calendar application code
interfaces with SyD Middleware application code for executing
method calls (SyDEngine), listening for incoming method calls
(SyDListener), and making directory service calls (SyDDirectory).
Step 2: We installed JVM for iPAQ, Jeode EVM Version 1.9. We
ported the SyD Middleware code and calendar application code on
the iPAQ using Microsoft ActiveSync version 3.5 and set the
classpath appropriately.
Step 3: After downloading the SyD Middleware, we installed
and ran the middleware components on the iPAQ. This involves:
(i) running a directory server (Oracle server) on a PC connected via
a wireless network with the base iPAQ and (ii) running listener.lnk
ﬁle (located in/syd/sydlistener path), which continuously listens
for incoming method calls.
Step 4: We then installed the calendar application code itself.
To do this, we executed the CalRegistrar.lnk ﬁle, which registers
the application with SyDDirectory, followed by the application
GUI to implement the various scenarios (set up meeting, cancel
meeting, and reschedule meeting).

6.3. An example usage of SyDBond module

7.2. Experiments and performance metrics

Here we discuss an example usage of SyDBond module
focusing on the cancel meeting scenario in the SyD Calendar
Application. This description will help to highlight some of the
methods of the SyDBond module and show the interaction of it
with the bond database and other modules of SyD Middleware.
The Calendar application is dependent on SyDBonds in order to
manage the interdependencies between various calendars. Cancel

We ran our experiments on a high performance/low power SA1110 (206 MHz) Compaq iPAQ H 3600 and 3700 series, with
32 MB of SD RAM and 32 MB of Flash ROM. We had three 3600
series and seven 3700 series iPAQ running middleware and
calendar applications connected through a wireless network using
a 2.4 GHz wireless router. The operating system was Windows CE.
We used JDK version 1.3 to code our programs and JVM for iPAQ

ARTICLE IN PRESS
552

P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

was Jeode EVM Version 1.9. The DBMS of the directory server was
Oracle 8i.
In Section 4 we have shown that SyD middleware enables
structured, streamlined and rapid application development on
mobile devices backed with theoretical and proven case study
implementations of the calendar application. However, in a
mobile setting, it is also signiﬁcant that the applications
developed scale well in terms of bandwidth, memory storage
and response time parameters, as these resources are scarce for
mobile devices. The motivations for considering aforementioned
parameters are as follows: (1) mobile devices cannot afford large
amounts of message transfers, as the network bandwidth is
limited; hence, we measured message size transferred; (2) storage
size on iPAQ is scarce and larger storage size for applications is
not desired; hence, we measured storage requirements;
(3) response time for executing method calls on mobile devices is
critical, as higher response times are possible when applications:
(a) consume more storage space, (b) transfer larger message sizes,
and (c) require higher memory; hence we measured response time.
We carried out experiments on calendar application for three
scenarios: set up meeting, cancel meeting, and reschedule meeting.
Our experiment results have been encouraging, as the application
has shown to scale well in terms of all the parameters.

Set up meeting
Reschedule meeting

7000
6000
5000
4000
3000
2000
1000
0
2

3

4

Cancel meeting

5
6
7
Group size

8

9

10

Fig. 9. Response time for three scenarios.

Set Up Meeting (Component Chart)
6000
5000
Response time (msec)

Response time (msec)

7.2.1. Setup meeting scenario
A constant message size of 50 bytes is transferred for each
participant in a meeting consisting of meeting details. The storage
size for group sizes of 2, 3, and 4 are: 120, 146, and 170 bytes,
respectively. For group sizes of more than 3, the storage size does
not increase linearly as we associated a meeting id for each
meeting, which avoids repetitive information such as start times,
end times, and comments.

Response time: Response time is the time required to execute
set up meeting method call. A set up meeting method call
includes time required to execute a get available time method
returning the available times of all the participants, time required
to execute the set up meeting for all involved meeting
participants, and time to write the meeting details of all the
participants to a ﬁle. It should also be noted that any method call
must go through SyD middleware components. More speciﬁcally,
it includes time required for (i) SyDEngine to contact SyDDirectory to get other user url information, (ii) SyDDoc to create a
request document, and (iii) SyDEngine to invoke SyDListener
remotely and get back the results.
In Fig. 9, we show the response time for all three scenarios
based on varying number of group sizes. We observe that
response time scales well (does not increase rapidly) for
increasing group size through parallelism in processing and this
behavior can be explained by analyzing different middleware
component timings that make up response time as can be seen
from Fig. 10. The different components and their timing analysis
are given below:
The ‘‘Engine to Directory Service’’ takes around 47–60 ms for
group sizes of 2–10, which is less than 1% of total time. The
‘‘Create SyDDoc’’ value ranges from 13 to 90 ms for group sizes of
2–10, which is again less than 1% of response time. Now, we go in
details on the components that make up a large share of the total
response time.
Engine to remote listener: SyDEngine invokes remote listener
for executing method call on remote devices by using the request
document generated from the above step. This involves sending
the request document to the remote listener, parsing the request
document at the remote listener end, invoking the method call on
the remote listener and writing the meeting details of each
individual participant to a ﬁle. For increased group sizes, we
achieve some concurrency as multiple remote listener calls are
made to participant devices and results are collected. This value
ranges from 1725 to 2900 ms for group sizes of 2–10 (takes
around 48% of total time).
Server processing: This refers to all other miscellaneous
processing times such as opening, writing, and closing of ﬁle at
initiator side, initializations for middleware components (SyDEngine, client side RMI registry components of directory server), and
different application speciﬁc objects such as vectors. Here, we
achieve concurrency for increased group sizes. This value ranges
from 1995 to 2100 ms for group sizes of 2–10 (takes around 50%
of total time).

Engine to Directory(round trip)

Create SyDDoc

Engine to Remote Listener

Server Processing

4000
3000
2000
1000
0
2

3

4

5

6
Group size

7

Fig. 10. Set up meeting response time for components.

8

9

10

ARTICLE IN PRESS
P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

553

Reschedule Meeting
Response time (msec)

7000
6000

Engine to Directory(roundtrip)
Engine to Remote Listener

Create SyDDoc
Client Processing

5000
4000
3000
2000
1000
0
2

3

4

5

6
Group size

7

8

9

10

9

10

Fig. 11. Reschedule meeting response time for components.

Cancel Meeting (Component Chart)

Response time (msec)

4000
3500

Engine to Directory(roundtrip)
Engine to Remote Listener

Create SyDDoc
Client Processing

2

5

3000
2500
2000
1500
1000
500
0
3

4

6
Group size

7

8

Fig. 12. Cancel meeting response time for components.

7.2.2. Other meeting scenarios
In a reschedule meeting scenario, from the initiator point of
view, size of message transferred is the message size transferred
to convey the information that meeting has been cancelled to the
other participants, and another message to send a conﬁrmation of
the meeting set up that has been tentative so far. The initiator
does not have to wait on any acknowledgements in either case as
one corresponds to cancel and for the tentative meeting the
timings have been already agreed as tentative. We assume that
only an initiator can cancel the meeting as he alone knows all the
participant details and the tentative meeting participant details.
This yields in a very small amount of data to be transferred, two
messages containing initiator name, start time, end time, and date
(around 20 bytes each). Cancel meeting also takes around 20
bytes of data transfer. Just like set up meeting scenario, we
present response time of components for cancel meeting and
reschedule meeting in Figs. 11 and 12.

8. Related work
Our literature survey broadly spans two areas: middleware
systems for collaborative applications and the ease of developing
and deploying collaborative applications, in particular calendar
and travel applications. In this section, we describe related work
in these two areas.

8.1. Middleware systems
Here, we compare our work with other mobile middleware
platforms supporting collaborative application development.
Although, there is an abundant body of research carried out in
middleware area in general, we review the ones that aim at
supporting colloborative application development on mobile devices.
Generally, mobile middleware systems can be classiﬁed as: (i) P2Pprotocol oriented systems (Fok et al., 2004; Kortuem, 2002; Mascolo
et al., 2001; Kotilainen et al., 2005), (ii) dynamic distributed
applications (e.g. JXTA) or IP-based client-server applications (e.g.
Jini, Microsoft .NET, and others), and, (iii) middleware infrastructures
supporting collaborative application development (Kortuem, 2002;
Krebs et al., 2003; Cugola and Picco, 2002; Kirda et al., 2002; Yamin
et al., 2002; Gupta et al., 2009).
As elaborated in Section 1, the current technology for the
development of collaborative web applications over a set of wired
or wireless devices has several limitations. A few existing
middleware systems have addressed the stated requirements in
a piecemeal fashion. For example, Proem (Kortuem, 2002) is one
such platform for developing and deploying peer-to-peer (P2P)
collaborative applications in a mobile ad-hoc networking environment. Similiarly, Kotilainen et al. (2005) also propose Mobile
Chedar, a peer-to-peer middleware for mobile devices using
Bluetooth technology. LIME (Fok et al., 2004) is a P2P-Protocol
oriented coordination model for ad-hoc networks. Commercial
products such as .NET compact framework (Neable, 2002) and
J2ME are also popular.

ARTICLE IN PRESS
554

P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

Juszczyk and Dustdar (2008) describe RESCUE, a service
oriented middleware for disaster and recover application which
uses efﬁcient P2P protocols for service advertisements and
discovery. Gu et al. (2005) describe a service oriented middleware
for developing context aware applications using an ontology
based approach. Chakraborty et al. (2004) describe issues related
to service composition in mobile environments and evaluate
criteria for judging protocols that enable such composition. A
distributed architecture and associated protocols for service
composition in mobile environments based on factors like
mobility, dynamic changing service topology and device resources
are presented. The composition protocols are based on distributed
brokerage mechanisms and utilize a distributed service discovery
process over ad-hoc network connectivity. The DISCIPLE System
(Krebs et al., 2003) also supports heterogeneous collaboration
over web, including mobile devices. ISAM (Yamin et al., 2002)
supports infrastructure for mobile collaborative applications
using java based middleware, similar to ours. MOTION (Kirda
et al., 2002) is another framework for developing collaborative
applications on mobile devices. Newer developments in mobile
middleware include developing a mobile middleware for social
networking applications (Pietiläinen et al., 2009; Gupta et al.,
2009), which falls under the broader category of collaborative
applications. Gupta et al. (2009) propose MobiSoc, a middleware
for mobile social computing applications.
All the aforementioned research works provide a middleware
for mobile devices targeting different features. The distinguishing
aspect of our work is we propose a software engineering
methodology for developing both collaborative and ad hoc
applications using middleware for mobile devices. Also, features
such as atomic transactions over group of web objects, constraints
on mobile web objects, and ease of application development
methodology that are supported in SyD middleware are simply
missing in the existing middleware systems. Other limitations of
current middleware systems include: restricting the usage of
mobile devices to only client-side programming and are incapable
of being used as servers, can be applied to only restricted domain
of applications like gaming, bidding, etc., or limited group or
transaction functionalities or mobility support, as further elaborated in our earlier work (Prasad et al., 2004). SyD, on the other
hand, addresses all these heterogeneous data and device problems and provides a new platform technology that makes
developing applications easy and independent of data format,
device type and device location.

8.2. Calendar application development
Many existing calendar system‘s main goal is setting up
meetings. Apart from setting up simple meetings, SyD calendar
also focuses on the logic and enforces interdependencies, if any in
context of meeting. Here, we compare SyD calendar with other
widely used industrial calendar systems like Novell GroupWise,
Microsoft Outlook, and Lotus Notes.
The Novell GroupWise offers the full range of workgroup
functions, messaging, calendaring, scheduling, task management,
document management, document imaging and editing, and web
publishing (Novell, 2003). SyD calendar targets only at the
calendar workgroup function with many inter-dependency
options and automated rescheduling in case of cancel meetings.
GroupWise leverages from pre-existing user proﬁles. The SyD
directory service for a wired device needs the account information
to be published only once. SyD emphasizing on the mobile work
group functionality needs the publishing of proxy information for
each account on to the directory to handle disconnectivity. The

existing account information is synchronized with proxy information when the original account is restored from disconnections.
The Lotus Notes directory is not smart because public address
book is a single-application directory, unlike GroupWise. Thus
user accounts for these workgroup products are created and
managed separately from existing Network Operating System
accounts—requiring double the time, effort, and cost to create. A
Notes application can however be rapidly built and deployed than
a GroupWise application (Lotus, 1999). Outlook calendars are
stored centrally and allow sharing calendar with other account’s
calendar (Outlook, 2001).
When a calendar is shared, it is visible to everyone or select
individuals. Outlook calendar keeps the privacy if we choose not to
share our calendar details, all others can see only the slots available.
Outlook allows meeting comments like conference room, details, etc.,
and synchronization with PDA calendar. The Exchange server 2003
provides Exchange ActiveSync for windows mobile-based devices
(Morimoto et al., 2003). When set-up meeting is initiated, Exchange
sends a message inviting all of the attendees. The participants can
agree to attend, tentatively agree to the time, or decline. If they agree,
the entry is marked in their calendar and the initiator is notiﬁed both
by email and in a tracking function for that event. Microsoft Exchange
server software enables Outlook’s collaborative groupware features.
The Exchange Server requires lot of space and the installation
procedure is complex, requires licensing and costly (Morimoto et al.,
2003). The SyD middleware is very light, easy to install and part of the
serving capability is hosted by mobile devices themselves.
The centralized storage of outlook calendars raises fault tolerance
issues. SyD calendars are stored in a distributed fashion. When set up
meeting is initiated on SyD calendars, the initiator ﬁrst gets the
available times from all participants. The initiator then picks a time
slot for meeting and blocks that particular slot. The participants
receive a meeting notiﬁcation along with other meeting details in a
simple text ﬁle format. A meeting can be set tentatively with
participants who are already booked for the timing initiator has
planned on. This provides an easy way to automate rescheduling
tentative meetings when the current meetings are cancelled. Both
SyD and outlook have the provision for priority of meetings. The other
group logic in SyD incorporates OR, AND, and XOR logic for the
inclusion or exclusion of various participants.

8.3. Travel application development
There is a lot of effort involved to induce the application logic and
requires proﬁciency in coding and other technical details with the
current state of art to compose existing web services. In the early
phases of internet, the customer had to manually navigate the
Internet, searching sites to organize his trip. Flights and cars had to be
reserved, hotels booked, all from different websites (Oellermann,
2001). Companies like Hotwire, Priceline, Orbitz, etc., made an initial
effort to transform a travel plan from multiple sites to a single
website. But even now, most portals do not combine and maintain a
global relation among these services (e.g. ﬂight reservation, rental car,
hotel, etc.). There is huge effort when changes are made to one aspect
of an itinerary (e.g., a cancelled ﬂight) resulting on manual changes to
other sequence of events in the planned trip (e.g., canceling the car,
changing hotel room reservation, etc.). Monolithic applications take a
great deal of time and resources to create. They are often tied to a
speciﬁc platform or to speciﬁc technologies, and they cannot be easily
extended and/or enhanced. There is no effortless way to access
information or perform a task without working through the graphical
user interface, which can be cumbersome over a slow connection or
unworkable on a portable device like a cell phone. SyD travel
application provides units of application logic that can be reused
between one application and another. Non-technical users will be

ARTICLE IN PRESS
P. Madiraju et al. / Journal of Network and Computer Applications 33 (2010) 542–555

able to easily and rapidly compose and link existing web services to
create ad-hoc applications using SyD travel (Hariharan et al., 2004).

9. Conclusions and future work
We have described the high-level programming and deployment methodology of System on Mobile Devices (SyD) middleware which supports an efﬁcient collaborative application
development environment for deployment on a collection of
mobile devices. One of the main advantages of SyD is a modular
architecture that hides inherent heterogeneity among devices,
data stores, and networks by presenting a uniform and persistent
object view of mobile server applications and data-stores
interacting through XML/SOAP requests and responses.
The paper has demonstrated the systematic and streamlined
application development and deployment capability of SyD for
collaborative applications composed over mobile web objects. We
illustrated this design process using two application case studies:
(i) a calendar of meetings application representing a collaborative
application, and (ii) a travel application which is an ad-hoc
collaborative application. We also presented implementation
details and performance metrics for the calendar of meetings
application. Speciﬁcally, we measured the bandwidth required,
the storage requirements, and the response timings. The results
we obtained show that the application scales well as we increase
the group size and ﬁts well within the framework of mobile
devices. Therefore, SyD objects, their interactions, and the underlying techniques discussed in this paper provide a direct beneﬁt to
web services and their compositions and coordination.
In future, we would like to design a secure platform for SyD
applications for different domains of applications such as social
networking, emergency, disaster, and recovery applications. We
also would like to expand the current architecture to include
cloud based applications by integrating our rapid application
development with generic interface for pluggable, web service
based applications.
References
Balasooriya J, Prasad SK. Toward fundamental primitives and infrastructure
enhancements for distributed web object coordination and workﬂows. In:
Proceedings of the IEEE international conference on web services, Orlando,
July, 2005.
Chakraborty D, Joshi A, Finin T, Yesha Y. Service composition for mobile
environments. Journal on Mobile Networking and Applications February
2004 [special issue on mobile services].
Cugola G, Picco GP. Peer-to-peer for collaborative applications. In: Proceedings of
the International Conference on Distributed Computing Systems Workshops
(ICDCSW), July 2002.
Edwards WK, Newman MW, Sedivy J, Smith T, Izadi S.Recombinant computing and
speakeasy approach. In: Proceedings of the MobiCom, Atlanta, September
2002. p. 279–86.
Fok C, Roman G, Hackmann G. A lightweight coordination middleware for mobile
computing. In: Proceedings of the 6th international conference on coordination models and languages, Italy, February 2004. p. 135–51.
Fowler M, Scott K. UML distilled: a brief guide to the standard object modeling
language, 2nd ed. Addison-Wesley Publication; 2002.
Garbinato B, Rupp P. From ad hoc networks to ad hoc applications. ERCIM News
Journal 2003. July.
Gu T, Pung HK, Zhang DQ. A service-oriented middleware for building context-aware
services. Journal of Network and Computer Applications 2005;28(1):1–18.
Gupta A, Kalra A, Boston D, Borcea C. MobiSoC: a middleware for mobile social
computing applications. ACM/Springer Mobile Networks and Applications
Journal (MONET) 2009;14(1):35–52.

555

Hariharan A, Prasad SK, Bourgeois AG, Dogdu E, Navathe S, Sunderraman R, et al.. A
framework for constraint-based collaborative web service applications and a
travel application case study. In: Proceedings of the international symposium
on web services and applications, 2004. p. 866–72.
Joshi J. A system for rapid conﬁguration of distributed workﬂows over web
services and their handheld-based coordination. Master’s thesis, Georgia State
University, 2005.
Kirda E, Fenkam P, Reif G, Gall H. A service architecture for mobile teamwork. In:
Proceedings of the 14th international conference on software engineering and
knowledge engineering, 2002.
Kotilainen N, Weber M, Vapa M, Vuori J. Mobile chedar—a peer-to-peer
middleware for mobile devices. In: Proceedings of the third IEEE international
conference on Pervasive Computing and Communications Workshops (PERCOMW’05), 2005. p. 86–90.
Kortuem G. Proem: a middleware platform for mobile peer-to-peer computing.
ACM SIGMOBILE Mobile Computing and Communications Review (MC2R)
2002;6(4). October.
Krebs AM, Ionescu MF, Dorohonceanu B, Marsic I. The DISCIPLE system for
collaboration over the heterogeneous web. In: Hawaii International Conference on Computer System Sciences, 2003.
Krone O, Chantemargue F, Dagaeff T, Schumacher M, Hirsbrunner B. Coordinating
autonomous entities. The Applied Computing Review, [special issue on
coordination models languages and applications] 1998.
Lotus. Moving from novell groupwise to lotus domino R5. IBM Redbooks
Publication; 1999.
Juszczyk Lukasz, Dustdar Schahram. A middleware for service-oriented communication in mobile disaster response environments. In: Proceedings of the 6th
international workshop on middleware for pervasive and ad-hoc computing,
Leuven, Belgium, 2008. p. 37–42.
Mascolo C, Capra L,Emmerich W. An XML-based middleware for peer-to-peer
computing. In: Proceedings of the international conference on peer-to-peer
computing, Linkoping, Sweden, 2001.
Morimoto R, Gardinier K, Noel M, Coca J. Microsoft exchange server unleashed, 1st
ed Sams Publication; 2003.
Neable C. The NET compact framework. IEEE Pervasive Computing Magazine;
2002. October–December.
Novell. The groupwise advantage, White papers from Novell, January 2003.
Oellermann WL. Architecting web services. Apress Publication; 2001.
Outlook. Building applications with microsoft outlook version 2002. Microsoft
Press Publication; 2001.
PhanT, Huang L,Dulan C. Integrating mobile wireless devices into the
computational grid. In: Proceedings of the MobiCom, Atlanta, September
2002. p. 271–8.
Pietiläinen A, Oliver E, LeBrun J, Varghese G,Diot C. MobiClique: middleware for
mobile social networking. In: Proceedings of the 2nd ACM Workshop on
Online Social Networks (WOSN ’09), Barcelona, Spain, 2009. p. 49–54.
Prasad SK, et al.. System on Mobile Devices (SyD): kernel design and
implementation. In: Proceedings of the international conference on mobile
systems, applications, and services, poster and demo presentation, San
Francisco, May 5–8, 2003a.
Prasad SK, et al.. Implementation of a calendar application based on SyD
coordination links. In: Proceedings of the 3rd international workshop on
internet computing and E-commerce in conjunction with the 17th annual
International Parallel & Distributed Processing Symposium (IPDPS), Nice,
France, April 22–26, 2003b.
Prasad SK,Balasooriya J. Web coordination bonds: a simple enhancement to web
services infrastructure for effective collaboration. In: Proceedings of the 37th
Hawaii International Conference on System Sciences (HICSS-37), Hawaii,
January 2004.
Prasad SK, et al.. System on mobile devices (SyD): a middleware testbed for
collaborative applications over small heterogeneous devices and data stores.
In: Proceedings of the ACM/IFIP/USENIX 5th international middleware
conference, Canada, October 2004.
Prasad, SK, Balasooriya, J. Fundamental capabilities of web coordination bonds:
modeling Petri nets and expressing workﬂow and communication patterns
over web services. In: Proceedings of the Hawaii International Conference on
System Sciences (HICSS-38), Hawaii, January 2005.
Prasad SK, Bourgeois AG, Madiraju P, Malladi S,Balasooriya.J. A methodology for
engineering collaborative applications over mobile web objects using SyD
middleware. In: Proceedings of the 2005 IEEE International Conference on
Web Services (ICWS 2005), Orlando, July 2005.
Pressman RS. Software engineering: a practitioner’s approach, 4th ed New York:
McGraw-Hill; 1997.
Yamin A, Augustin I, Barbosa J, Silva J, Geyer C,Cavalheiro G. Collaborative
multilevel adaptation in distributed mobile applications. In: Proceedings of the
international conference of the Chilean Computer Science Society (SCCC),
November 2002.

BondFlow: A System for Distributed Coordination of Workﬂows over Web
Services
Janaka Balasooriya, Mohini Padhye, Sushil K. Prasad
Georgia State University
Atlanta
sprasad@gsu.edu
Abstract
Today’s collaborative applications over the web span
domains as diverse as enterprise e-commerce applications and biomedical applications. We have previously
developed and formally investigated “Web Coordination Bonds,” a theoretically powerful artifact for interconnecting autonomous web objects for control and data
ﬂows, and for enforcing dependencies. Here, we describe BondFlow, a system that enables the conﬁguration
and execution of workﬂows using web bonds over heterogeneous web objects. The system automatically generates
lightweight proxy wrapper objects to enable encapsulated web services to be interconnected through web bonds.
The small footprint wrappers (less than 10 KB) can reside on Java-enabled handheld devices. We describe
the design, architecture and performance of the BondFlow system. Our initial performance results indicate that
both wrapper creation time and web bond related execution time are small. In contrast to our BondFlow
system, existing systems need expert programming to create workﬂows, do not easily allow distributed coordination
of workﬂows, and usually do not support heterogeneity of device, data and network. The system is preliminary,
and further research is ongoing to extend its conﬁguration and execution platforms.

1. Introduction
“Software as a Service” (SaaS) is the recent notable development in software engineering. These software services
will be running on heterogeneous platforms and distributed
information networks, providing services to other entities
in the network [13]. Web service infrastructure is arguably
the most important realization of the SaaS concept. Web service (WS) is deﬁned as a “self-contained modular application that can be described, published, located and invoked

Shamkant B. Navathe
Georgia Institute of Technology
Atlanta
sham@cc.gatech.edu

over the net” [18]. It encapsulates the computational complexity and device heterogeneity, and the client entities interact through the interface. Therefore, in the SaaS model,
WSs as service providers become the building blocks out
of which new applications are created. Thus, one can harness the true potential of WS infrastructure by composing different web services together to create sophisticated
useful applications and workﬂows [24]. Such composition
enables inter-organizational collaboration and coordination
(workﬂows and collaborative applications). Hence, integration/coordination technologies play an important role in WS
infrastructure [13].
However, there are several limitations with both the current web infrastructures and the application development
and integration technologies.
In [27], authors illustrate how existing WSs are tailored to develop business processes (composite web
processes) over the Internet. Such applications are long
running rather than mere invoke/response interactions.
Current state of the art in WS composition is to model
the composite web service as a separate state preserving web process, as WS are stateless, and not capable of actively participating in such application scenarios. The composite web process encapsulates the coordination logic that makes it a central coordinating
agent. This is a classic example of 2-tier application
development [15], which is not desirable for complex,
long-lived interactions. Two-tier systems have scalability and heterogeneity issues and also legacy object
integration difﬁculties [15]. Ironically, one of the main
objectives of the web is to solve these problems.
Even though web services technology is one of the
most highly talked about technologies, it is not widely
used. This is mainly due to the lack of easy to use, reliable, and robust development environment for web service application development. In [39], authors have
pointed out the difﬁculty of using BPEL and WSDL

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

especially for non-experts. In most cases, extensive
programming is required [26, 44].
Currently, there are many languages and standards for web services composition [13]. However,
as things stand today, these languages propose different techniques to perform WS composition and there
is no fundamental, theoretically sound WS composition/choreography framework [3, 44].
As opposed to the prevailing centralized coordination, distributed coordination has two categories of
advantage: (i) Due to security, privacy, or licensing
imperatives, some web-based objects will only allow
direct pair-wise interactions without any coordinating third-party entity; and (ii) Centralized coordination/workﬂows suffer from issues such as scalability,
performance, fault tolerance, etc.
We have recently proposed web coordination bonds
as a set of core artifacts for web Service coordination/choreography, and shown that they have the modeling
power of extended Petri nets, and that they can express all established workﬂow and communication patterns
[33, 34]. Web bond concept has evolved from our experience with developing several collaborative peer-to-peer
distributed web applications using our System on Mobile Devices (SyD) middleware [36]. Section 2 brieﬂy
explains web bond artifacts and the SyD middleware system.
Based on web coordination bonds and SyD middleware,
we have developed a prototype system, namely, BondFlow
system, which is an environment to develop and execute
collaborative applications including workﬂows over heterogeneous web services. The contributions of this paper are
to present the BondFlow system and illustrate its effectiveness. The key features distinguishing our system from others are (i) programming ease of workﬂow conﬁguration,
(ii) automatic encapsulation of heterogeneous web services
through lightweight proxy wrapper objects, providing capability of persistently embedding high-level workﬂow logic
and executing web bonds, and (iii) distributed coordination
of workﬂows. The lightweight wrappers enable these objects and the workﬂows to be hosted on small handhelds
as well. The system is preliminary, and further research
is needed to (i) extend its limited conﬁguration capabilities, (ii) implement the full coordination capabilities of web
bonds, and (iii) improve its execution platform.
Section 3 presents the BondFlow system from developer’s perspective, addressing both workﬂow conﬁguration
through proxy wrappers and web bonds, and their deployment and distributed coordination. The heterogeneous web
services are given a uniform object view and made capable of web-bonding by automatically generated proxy wrapper objects. The wrapper encapsulates logic for bond man-

agement along with web service method calls. The wrapper
objects communicate with each other and help enforce the
ﬂows and interdependencies. Section 4 describes the software architecture of the BondFlow system. Performance
measurements for the system operations and sample workﬂows are presented in Section 5. Section 6 presents related
work. Section 7 contains our conclusions and future research directions.

2. Background Concepts
Our BondFlow system provides an environment for conﬁguring and executing workﬂows on the ﬂy over heterogeneous web objects. The system is based on the concept of
web coordination bonds [34, 33] and SyD middleware system. Here, we brieﬂy explain the web bond concept and the
SyD middleware system [36].
Web coordination bonds: Web bonds enable applications to create data and control ﬂows between entities,
enforce interdependencies and constraints, and carry out
atomic transactions spanning over a group of web entities/processes. An entity may be part of a data-store or
an object or a software component, and here we speciﬁcally consider web services. There are two types of web
bonds: subscription bonds and negotiation bonds. Subscription bonds allow automatic ﬂow of information and control from a source entity to other entities that subscribe to it.
This can be employed for synchronization as well as more
complex changes, needing data or event ﬂows. If there is a
subscription bond from activity A to activity B, it implies
that once A completes its execution, B will be invoked with
suitable control and data as speciﬁed by the subscription
bond. Negotiation bonds enforce dependencies and constraints across entities and trigger changes based on constraint satisfaction. If there is a negotiation bond from activity A to activity B, then A must ensure that B can be also
be executed as well.
SyD middleware: SyD is a recently prototyped middleware for a novel Internet programming methodology and a
framework for developing collaborative e-Service and other
applications executing over a collection of independent,
possibly mobile, and heterogeneous data stores, leveraging
off the best in object-oriented design and middleware technologies. SyD middleware system is useful in enabling web
object view of heterogeneous entities as well as in linking
web objects through coordination bonds. Each data store is
encapsulated as a SyD object (even on a small mobile device employing a tiny SyD listener), and multiple SyD objects can collaborate in a p2p fashion using XML-based
messages. SyD uses the simple yet powerful idea of separating device management from management of groups of
users and/or data stores. Each device is managed by a SyD
deviceware that encapsulates it to present a uniform and per-

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

sistent object view of the device data and methods. Groups
of SyD devices are managed by the SyD groupware that
brokers all inter-device activities, and presents a uniform
worldview to the SyD application to be developed and executed on. All objects hosted by each device are published
with the SyD groupware directory service that enables SyD
applications to dynamically form groups of objects hosted
by devices, and operate on them in a manner independent
of devices, data, and underlying networks. The SyD groupware hosts the application and other middleware objects,
and provides a powerful set of services for directory and
group management, and for performing group communication and other functionalities across multiple devices. Web
bond is one of the key enabling components of the SyD
framework. SyD coordination bonds enable applications to
create and enforce interdependencies and constraints, and
carry out atomic transactions spanning over a group of SyD
and non-SyD entities/processes.

Search web service (WS)
UDDI directory
WSDL parser

Parsed WSDL

Select suitable WSs for the
workflow

Generated wrapper
objects

Configure workflow
Select WS
pairs for bonding

Create bonds between
methods of
selected WS pairs.

3. Developer’s View of BondFlow System
BondFlow system provides an easy to use platform to develop and deploy collaborative applications including workﬂows over web services. Users of the BondFlow system
can conﬁgure their workﬂow by selecting suitable web services and bonding them using web coordination bonds to
enforce dependencies. Workﬂow coordination architecture
of the BondFlow system is inherently distributed. Following
sections discuss the workﬂow conﬁguration, execution, and
coordination of the BondFlow system in developer’s perspective.

3.1. Conﬁguring and Executing Workﬂows
The BondFlow system initiates its operation by web service lookup and discovery (Fig. 1). The web service interface module contains a WS locator module and a WSDL
parser module. The WS locator helps in discovering the services of interest. The WSDL Parser parses the WSDL and
allows the service components to be viewed in the form of
summary of methods and parameter lists. Users can choose
to save the viewed services for future reference. An instance of java-enabled web service wrapper object is created when the user wishes to save the web service. Web
coordination bonds can be created among the chosen services at any point of time to reﬂect data and control ﬂow
(using “Subscription bonds”), and other dependencies (using “Negotiation bonds”). The most important information
provided at the bond creation time is the type of the bond
to be created. Dependency enforcement and entire operation of bond execution depends on the type of the bond that
has been created. Bond related information is stored in an
XML storage ﬁle. The wrapper encompasses all the coor-

Configured workflow

Execute
workflow

Figure 1. Use of BondFlow system

dination capabilities of the web bond artifacts (Fig. 2). As
shown in Fig. 2, each web service method call is encapsulated by negotiation and subscription bond check. This logic
makes sure that data and control dependencies are met before and after making the actual WS invocation. It hides the
heterogeneity of various objects including legacy web services distributed among the network by enabling them to
coordinate using the BondFlow system. Once the wrapper is
created and bonded, the basic skeleton of web service composition for BondFlow system is ready. The wrapper generation process can be centralized or distributed. However,
the bond execution process, though, is distributed. The footprint of the wrapper is small and can reside on a mobile device easily. The wrappers can communicate with each other
using the SyDListener [35] component of SyD middleware.
The BondFlow system makes the collaborative application
development very easy for small devices running SyD [30].
Once any of the wrappers is invoked, the presence of the
web bond is initially checked and depending upon the presence and type of the bond, coordination among components
is carried out by enforcing the speciﬁed constraints and dependencies.

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

WS

Y

Negotiation
bonds
(NB)?

Composed
Web Service
with
Coordination
logic

Enforce NB
constraints

N

WS

WS

Web service
method call

Figure 3. Traditional centralized WS coordination

Subscription
bonds
(SB)?

N

Y

Enforce SB
constraints

:6
WSWO

Continue
execution

:HE
%RQGV

:6

WSWO

Figure 2. Typical ﬂow within a proxy wrapper
object

WSWO

:6

WSWO: Web Service Wrapper Object

Figure 4. Distributed WS coordination

3.2. Workﬂow Coordination Architecture

At present, the web bond artifacts enable two different
ways of coordination. In the traditional centralized version,
a composed web service is created using web bond artifacts
(Fig. 3). The composed service contains all the coordination
logic and will invoke participating web services as required.
This is what most competing workﬂow development systems are capable of (without the high-level web bond programming). Alternatively, one can leverage the distributed
computing and communication capabilities of the devices
and networks with all the inherent advantages over a centralized coordination (concurrency, fault tolerance, availability, performance, to name a few). The BondFlow system enables both centralized and distributed coordination.
For distributed coordination, we create a web bond wrapper around each web service and instantiate the wrapped
web services distributed across the network (Fig. 4). The
proxy wrappers embed the workﬂow coordination logic so
that instances of wrapped web services become stateful
self-coordinating web objects. However, the proxy wrappers need to interact with the actual web service to complete each method invocation. These two implementations
provide a comparative test-bed to analyze quantitative (performance measurements) as well as qualitative (coding and
architectural) aspects of BondFlow system.

Web Services
Registry
(UDDI)

S
O
A
P

Lookup for Web
services
WSDL

Web Service
Interface
Module
WS Locator
WSDL Parser
Parsed WSDL

Workflow Execution
Module

Wrapper
Generator
Module

Web Bond
Runtime
Manager
SOAP/ SyD

Workflow
Configuration Module

JVM

Figure 5. BondFlow system architecture.

4. BondFlow System Architecture
The BondFlow system consists of web service interface module, wrapper generator module, workﬂow conﬁguration module, and execution module (Fig. 5). The WS Interface module uses SOAP and UDDI to locate the web service as shown. Web Bond Manager that deals with bond
creation and execution is a part of the workﬂow conﬁguration module and runtime module. Here, we brieﬂy describe each component of the system.

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

4.1. Web Service Interface Module
This module contains two components, Web Service Locator and WSDL Parser, as shown in Fig. 5. The WS Interface module is the system’s interface to the web services
infrastructure. It deals with locating the web services of interest for the user and parsing those web services for desired data. It interacts with the Wrapper Generator module,
which generate wrappers if a particular WS is selected for
the workﬂow. Following subsections brieﬂy discuss components of web service interface module.
Web Service Locator: When a user wishes to browse
through the services provided by a provider, he supplies the
WSDL url of that service. The web service Locator module locates the service by contacting UDDI, gets the WSDL
and passes it to the WSDL Parser module. We have used
Apache-Axis implementation of the web services.
WSDL Parser:The WSDL parser uses WSDL4J API for
WSDL parsing. It parses the WSDL ﬁle for required components. It stores the result in the XML storage for persistence, if the user opts to save the web service. Some of the
entities saved to the storage are the name of the service,
locationURI, namespaceURI, methods and parameter list.
NamespaceURI and locationURI are used for making a call
to the actual web service from the wrapper body. XML data
is stored in the persistent storage in a predeﬁned format.

4.2. Wrapper Object Generator Module

Wrapper generator
Parsed WSDL file

ity. The entire operation of bond management is transparent
to the user.

4.3. Workﬂow Conﬁguration Module

<Wrapper>
<WSName>flight</WSName>
<!--Bond information is stored as follows between <Bond> </Bond> tag, source
method name, destination web service and method name are the important
parameter that are stored at bond creation along with type of bond and presence of
trigger -->
<Bond bid="1">
<SrcMethod>addFlight</SrcMethod>
<DestWS>hotel</DestWS>
<DestMethod>addHotel</DestMethod>
<Type>S</Type>
<Trigger>Y</Trigger>
</Bond>
</Wrapper>

Figure 7. Embedded bond logic in XML format

Code
Web Bond Configuration
Manager
Proxy wrapper objects

XML file
with bond
information

Figure 8. Workﬂow conﬁguration module

template
Wrapper generator

Proxy wrapper object

Figure 6. Wrapper object generator module

This forms the heart of the system. It deals with the creation of the proxy wrapper objects corresponding to the web
services. Upon selection of a particular WS for the workﬂow a wrapper is generated (Fig. 6). Wrapper object code
is generated based on the parsed WSDL ﬁle of the selected
WS and the wrapper generator template (Fig. 2). The wrapper has the intelligence of managing the bonds dynamically
and enforcing dependencies to cater to the need of a particular workﬂow. The wrapper possesses a signature identical to the original web service. It encapsulates the original
web service methods along with bond management capabil-

Once suitable web services have been selected, the next
step is to use web bond artifacts to hook wrapper objects
to other wrappers in the workﬂow to reﬂect data and control ﬂow (using “Subscription bonds”), and other dependencies (using “Negotiation bonds”). The web bond conﬁguration manager deals with all the bond related operations,
such as creation, deletion and updating of the web bonds.
When the bond is created, bond related information is stored
in a persistent XML storage for future reference. Bond parameters are speciﬁed while creating the bonds. Once wrappers are created and bonded, the basic skeleton of the workﬂow is ready. The BondFlow system has capabilities to view
selected web services and their methods/parameters concurrently and to bond them together to enforce dependencies. After invoking a wrapper method, the dependencies
are checked and web bonds, if any, are executed according
to deﬁned criteria. Fig. 7 shows a code snippet that gives an
overview of data that is stored at bond creation and Fig. 8
gives a pictorial representation of a workﬂow conﬁguration
module.

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

Configured Workflow (Code/Data)

dependent and provides all the advantages of a typical
Java-built system.
Proxy wrapper
object invocations

Web Bond Runtime Module
SOAP/RPC (PC based )
SyD Middleware (handheld based)
WS invocations
JVM

Figure 9. Workﬂow execution module
As shown above, the important parameters stored in the
persistent storage are source and destination web service
name, method name, type of bond (S- Subscription and NNegotiation) and presence of the trigger in this bond.

4.4. Workﬂow Execution Module
Upon wrapper invocation, the wrapper consults the
workﬂow execution environment and carries out series
of operations depending upon the bond parameters speciﬁed at the bond creation time. Checking of the type of
bonds, getting bond parameters and executing the actual bond are some of the major operations by the Bonds
Management System. The ﬁnal call to the original web service is made by the wrapper using SOAP. The BondFlow
execution platform (Fig. 9) enforces dependencies by invoking the bonds.
At runtime wrapper objects can reside in a central location or they can be distributed over the network. If they
reside in a central location, then the communication is local. If the wrappers are distributed, then they can use SOAP
or other RPC communication protocol to send/receive data
and control. We have implemented SOAP based communication. The footprint of wrapper is small (Table 1), and a
workﬂow thus constructed can reside in a small handheld
device easily. If the wrappers reside in small handheld devices where even SOAP server/client components are usually not available, our SyD listener module enables them
to communicate [35]. SyD listener is a lightweight module in our SyD middleware framework for enabling mobile devices to host server objects [36].

4.5. Enabling Technologies
In this section we will brieﬂy describe the various technologies/products used to create a prototype of the BondFlow system.
JDK1.4.1: The Wrapper Generator system is implemented using Java. This makes the system platform in-

WSDL4J API [6]: The WSDL parser has been built
using WSDL4J API. WSLD4J API is an IBM reference implementation of the JSR-110 speciﬁcation
(Java API’s for WSDL). It facilitates efﬁcient creation,
representation and manipulation of WSDL documents
that describe the services. The web services Description Language (WSDL) which is an XML-based language for describing web services allows developers
to describe the inputs and outputs to an operation, the
set of operations that make up a service, the transport
and protocol information needed to access the service
and the endpoints via which the service is accessible.
WSDL4J is a very efﬁcient API for parsing and representing a WSDL document in Java.
NanoXML 2.2.1 [8]: Data persistency is achieved in
our system by using XML storage mechanism and a
lot of data manipulation is required during bond creation and execution. A lightweight parser for XML
was needed which is exactly what NanoXML provides. A tree-based parser is not efﬁcient to use with
small devices due to memory constraints. Event driven
parsers like NanoXML are best to use. NanoXML is a
small (about 6K), reasonably fast, non-validating XML
parser for JAVA that provides a set of APIs.
Axis 1.1 [35]: Locating the web services and subsequent communication with the web services is implemented using Apache Axis, which is essentially a
SOAP engine. It provides many other important features along with extensive support for WSDL and compatibility with Tomcat. Axis offers improved speed,
ﬂexibility and stability. Axis, along with apache web
server, provides an efﬁcient web service interface for
various applications. Other software that are used are
Oracle 8i, Apache 2.0.52, and Jakarta Tomcat 5.0.

5. Performance of the System
Here, we report results from preliminary experiments
and performance metrics obtained based on a few workﬂows that we have conﬁgured and executed using BondFlow system.
Hardware and Software Setup: We ran our experiments on a high performance SunOS 5.8 server. We built
wrappers using JDK 1.4.2. The WSDL parser has been
built using WSDL4J API. WSLD4J API is an IBM reference implementation of the JSR-110 speciﬁcation (Java
API’s for WSDL). NanoXML 2.2.1 is used as the XML
parser for JAVA. Xmethod’s SOAP based web services (eg:
http://www.xmethods.net/sd/2001/TemperatureService.wsdl)
have been used for experiments. For our experiments, we

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE









	

























	





!

"





	

$





!



(

1
2
4
5
8
17



)

+

2
2.3
8
12
16
32

-

/

0



2



)

20
23
32
40
46
76

2



/

)

+

-

AM

	

BN


eB

CE

/

2.2
2.3
2.6
2.5
3.5
5.7

Barnes and
Noble Price
Quote

6. Related Work
In [27], authors illustrate how existing WSs are tailored to develop business processes over the Internet.

Amazon
Query
Service

Currency

http://www.xmethods.net/sd/2001/BNQuoteService.wsdl
http://www.xmethods.net/sd/2001/EBayWatcherService.wsdl
http://majordojo.com/amazon query/amazon query.wsdl
http://www.atlaz.net/webservices/GetCurrencyExchange.wsdl

Table 1. Number of WS methods vs. Wrapper
creation time

have used these web services to create simple Workﬂows comprising subscription and negotiation bonds
(Fig. 10, Fig. 11). As shown in Fig. 11, there are subscription bonds from Barnes and Nobel web service
to eBay web service and eBay to Amazon and Amazon to Currency web service. This chain of subscription
bonds enable them to exchange book price data and control. By having negotiation bonds in reverse direction
makes sure they activate sequentially. For example, Amazon can only be invoked if eBay has ﬁnished its activity.
Similarly, Fig. 11 enforces control and dataﬂow using subscription bonds.
Size of WSDL (number of methods) vs. Wrapper creation time: As web bond wrapper is central to our system it
is important to analyze wrapper creation time and to investigate how wrapper creation time varies with different size
(number of methods) of web services. Table 1 shows that
wrapper creation time is very small and wrapper size is less
than 10 KB even for a web service with 17 methods. This
is an advantage as these wrappers can easily be placed in
memory constrained small handheld devices. The bond creation time for both types of bonds is less than 25ms. Also,
note that once wrappers are created and bonded, the basic
skeleton of the workﬂow is ready. Developers can add more
logic into it if needed. This will reduce the programming effort considerably.
Workﬂow execution time: Any workﬂow activity checks for bonds and veriﬁes that all the dependencies
are met before executing it. Table 2 shows the bond related timings vs. workﬂow execution time. Note that the
total execution time consists of time taken to invoke remote web service and get the result. The bond execution
time is only a small fraction of the total workﬂow execution time.

eBay Price
Watcher

Figure 10. BookPrice workﬂow.





"







@

-







!

6

7



9



)

-

2





/

)

-

2

0



/



)

2

	





=

-

/

	

SB’s=3,
NB’s=2
SB’s=3



C





2

!

=







)

	





G

48

17

17

5577

1.47%

46

0

21

6406

1.07%

/

Table 2. Workﬂow(WF) execution time, SB=
Subscription bond, NB= Negotiation bond.

TP

Temperature

TR

AF

EM

Traffic

AddressFinder

Email

http://www.xmethods.net/sd/2001/TemperatureService.wsdl
http://www.xmethods.net/sd/2001/CATrafﬁcService.wsdl
http://arcweb.esri.com/services/v2/AddressFinder.wsdl
http://www.cosme.nu/services/smtpserver.php?wsdl
Figure 11. Weather and trafﬁc condition
workﬂow.

Such composition enables inter-organizational collaboration and coordination. Those coordinated activities
are long running (workﬂows, transactions) and require much more beyond just invoke-response protocols
[18, 27]. Long-lived collaborative applications over the Internet require proper coordination between different web
entities to yield more efﬁcient and effective output. The latest advancement in web services technologies is the
introduction of middleware for web services. In [15], authors have argued that web services will play a major role
in electronic data exchange and transaction processing systems. They pointed out the requirement for middleware
platforms for such applications. Web service Transac-

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

tion Middleware (WSTMW) [37], is one such platform
developed by IBM to carry out transaction over web services. WSTMW resides in both the web service side
as well as the client (mediator) side. They have employed WS-Transaction, WS-Policy and BPEL4WS to prototype the system. Similar approach can be found in
[17], where they have extended the BPEL4WS to support transactions. However, such developments have
lacked scalability due to the use of centralized coordination. Net Traveler [14] is another middleware platform for
distributed coordination among web services. In their architecture QSB (Query service broker) together with RS
(Registration server) residing in the web services side provides query handing capabilities and distributed coordination. However, such developments are in very early stage
and warrant further research. Development of web service composition techniques has added a new dimension
to the workﬂow management systems over the Internet [21, 45]. In [20], authors have pointed out the
importance of integrating web services in to workﬂow management systems. [20] describes possible workﬂow application domains over the Internet. Application of workﬂow
management systems (WFMS’s) spans large number of application domains including business process models
[21], scientiﬁc applications [28], and health care systems [46]. Among WFMSs, FlowManager [25]is an open
source system based on Petri nets. OpenFlow [1]is another open source WFMS. IBM’s FlowMaker [7], Xerox’s InConcert and Fujitsu’s Regatta are commercially
successful WFMSs [11]. More extensive treatment of classifying WFMSs can be found in [66]. A drawback of
most WFMSs is that they are based on database concepts [11, 12] using extended/advanced transaction principles. They have the luxury of utilizing rich database
functionalities to provide execution environment, correction criteria and communication. As a result, they do not
have required functionality to cater to today’s heterogeneous, autonomous, distributed computing paradigm. Another drawback of most workﬂow management systems
is their inability to adjust according to runtime environment and QoS parameters.
In [39], authors have pointed out the difﬁculty of using BPEL and WSDL especially for non-programmers
(main beneﬁciaries of web services!). They propose alternative UML based visual development platform called
UML-WSC. The major WS workﬂow languages, BPEL,
XLANG, WSFL, BPML, and WSCI, are XML based textual languages [16, 41]. Even though there are many development platforms available, none of them have any
sound theoretical underpinning. Also, they do not provide enough easy to use tools to develop, modify (reprogram) and deploy workﬂows, long-lived transactions
and virtual organizations over web. Extensive program-

ming is required in most cases [26, 44]. Therefore, it is
necessary to build robust and reliable environment /deployment platform so that non-programmers such as natural
scientists, business executives and everyday users can develop such collaborative applications. Our BondFlow system is an effort in that direction.

7. Conclusions and Future work
The next generation of Internet applications will involve
various kinds of collaborative applications among heterogeneous, autonomous entities. The users will be scientists, engineers or ﬁnancial and trade experts that are essentially untrained in programming and application development. Web
Services are offering an important paradigm that is making
a variety of services available for shared use in the development of collaborative applications. However, the research
prototypes and the industrial middleware products or the
workﬂow products have not yet addressed the issue of conﬁguring and executing complex workﬂows that arise in the
challenging applications such as e-commerce or bioinformatics. In this paper, we have presented the BondFlow system as a framework to develop and deploy such collaborative applications and workﬂows. We have used and demonstrated the concept of “web bonds” which allow us to develop bonding among web-services and enable workﬂow
creation and execution without much programming. The paper has presented the architecture of the BondFlow system
and the workings of its components. We have implemented
a lightweight web bond wrapper object, which encompasses
all the coordination capabilities of web bond artifacts. Also,
we have demonstrated how these wrapper objects residing
in heterogeneous devices including on small handheld devices coordinate among themselves. Our performance results show that web bond operations take only a small fraction of the total execution time of the workﬂow.
In the future, we would like to build a complete IDE for
BondFlow system. It will have capabilities of web coordination bonds [34, 33] so that developers can enforce all the
workﬂow control ﬂow dependencies and distributed communication patterns [34]. Also, current menu driven system need to be enhanced towards drag and drop kind of
IDE. Further, we need to enhance the runtime engine of our
systems so that users can monitor the execution and make
changes while workﬂow is active. Finally, we would like to
further investigate the power consumption of workﬂow execution on small handhelds.

References
[1] OpenFlow
Workﬂow
”http://openﬂow.net”.

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

Management

System.

[2] Simple Object Access Protocol (SOAP) 1.1.
2000.
”http://www.w3.org/TR/SOAP/”.
[3] WSDL Web-service Description Language. World Wide Web
Consortium, 2001. ”http://www.w3.org /TR/wsdl/”.
[4] Universal Description, Discovery and Integration of Web
Services (UDDI) 3. OASIS, 2002. ”http://www.oasisopen.org/committees/uddi-spec/tcspecs.shtmluddiv3”.
[5] Web Services Architecture Overview.
IBM Web Services Architecture Team, September 2002. ”http://www106.ibm.com/developerworks/webservices/library/w-ovr/”.
[6] RDF/XML Syntax Speciﬁ cation (Revised) W3C Recommendation. February, 2004. ”http://www.w3.org/ TR/2004/
REC-rdf-syntax-grammar-20040210/”.
[7] Ibm mqseries workﬂow concepts and architecture version 3.
1. In IBM Danmark A/S GH12-6285-00, July 1998.
[8] XML Linking Language (XLink) Version 1.0, W3C Recommendation. June, 2001. ”http://www.w3.org/TR/xlink/”.
[9] The Business Process Modeling Notation. Nov. 2002.
”http://www.bpmi.org/bpmn-spec.esp”.
[10] T. Agerwala. Control of access to shared resources. In Hopkins Computer Research Report 36, Computer Sciences Program, The Johns Hopkins University, Baltimore, Md, Oct,
1974.
[11] G. Alonso, D. Agrawal, A. E. Abbadi, M. Kamath, R. Gunthor, and C. Mohan. Advanced transaction models in workﬂow contexts. In In Proc. 12th Intl. Conf. Data Engineering,
pages 574–573, New Orleans, February 1996.
[12] G. Alonso and C. Mohan. Workﬂow Management: The Next
Generation of Distributed Processing Tools. Kluwer Academic Publishers, 1997.
[13] B.Benatallah, M.Dumas, M.C.Fauvet, F.A.Rabhi, and
Q. Z.Sheng. Overview of some patterns for architecting and managing composite web services. pages 9–18,
August 2002.
[14] H. Caituiro-Monge and M. Rodriguez-Martinez. Net traveler: A framework for autonomic web services collaboration, orchestration and choreography in e-government information systems. In In Proc. IEEE ICWS 2004.
[15] L. Doug and V. Steve. Introduction - middleware for web services. IEEE Distributed Systems Online, 1(4), 2003.
[16] F. C. et al. Business Process Execution Language for Web
Services (Version 1.0), IBM. July 2002. ”http:// www106.ibm.com/developerworks/webservices/library/wsbpel”.
[17] T. Fletcher, P. Furniss, A. Green, and R. Haugen.
BPEL and Business Transaction Management.
2003.
”http://www.choreology.com/standards/BPEL.and.
Business.Transaction.Management.Choreology.Submission.html”.
[18] C. Francisco, K. Rania, M. Nirmal, T. Stefan, and W. Sanjiva.
Service-oriented computing: The next step in web services.
Communications of ACM, 46(10):29–34, October 2003.
[19] P. Grefen. Transactional workﬂows or workﬂow transactions. In In Proc. 13th Intel. Workshop on Database and
Expert Systems Applications (DEXA 2002), pages 60–69,
September 02-06, 2002, Aix-en-Provence, France.

[20] P. Gunter and S. Michael. Integration of web services
into workﬂows through multi-level schema architecture.
In In Proc. 4th IEEE Intl. workshop on Advanced issues of E-Commerce and Web-based Information Systems
(WECWIS02), pages 51–60, 26-28 June ,2002 , Newport
Beach, CA.
[21] S. H. S. Huang. Building business processes using a state
transition model on world wide web application-speciﬁ c
software engineering technology. In In Proc. 1st IEEE
Workshop on Application-Speciﬁ c Software Engineering and
Technology (ASSET’98), pages 2–7, Richardson, Texas, 2628 Mar , 1998.
[22] P. T. Johnson, T. Mathews, and G. George. Modeling of web
services ﬂow. In IEEE Intl. Conf. on ECommerce, pages
331–339, June 24 - 27, 2003 Newport Beach, California.
[23] B. Kiepuszewski. Expressiveness and Suitability of Languages for Control Flow ModelingWorkﬂows. 2002.
[24] I.-Y. Ko and R. Neches. Composing web services for largescale tasks. Internet Computing, IEEE, 5(7):52–59, Sep-Oct
2003.
[25] A. Lerina, C. Aniello, G. Pierpaolo, and V. Maria Luisa.
Flowmanager: A workﬂow management system based on
petri nets. In In Proc. 26th Intl. Computer Software and
Applications Conference (COMPSAC02), pages 1054–1059,
August 26-29, 2002, Oxford, England,.
[26] F. Leymann. Web Services Flow Language (WSFL 1.0),
IBM. May 2001. ”http://www-3.ibm.com/software/solutions
/webservices/pdf/WSFL.pdf”.
[27] F. Leymann, D. Roller, , and M. Schmidt. Web services and
business process management. IBM systems Journal, 41(2),
Sep-Oct 2002.
[28] J. Meidanis, G. Vossen, and M. Weske. Using workﬂow management in dna sequencing. In In Proc. 1st IFCIS Intl. Conf.
Cooperative Information Systems (CoopIS’96), pages 114–
123, June 19-21, 1996, Brussels, Belgium.
[29] C. Mohan. Workﬂow management in the internet age. In In
Proc. 2nd East-European Symp. Advances in Databases and
Information Systems (ADBIS’98), pages LNCS vol: 1475 pp.
26–34, Poznan, Poland, September 1998.
[30] M. Padhye. Coordinating heterogeneous web services
through handhelds using syd’s wrapper framework. In Master Thesis, Department of CS, Georgia State University, Atlanta, 2004.
[31] S. K. Prasad, G. B. Anu, D. Erdogan, and et al. Enforcing interdependencies and executing transactions atomically
over autonomous mobile data stores using syd link technology. In In Proc. Mobile Wireless Network Workshop held in
conjunction with The 23rd Intl. Conf. Distributed Computing Systems (ICDCS’03), pages 803–811, May 19-22, 2003,
Providence, Rhode Island.
[32] S. K. Prasad and J. Balasooriya. Web coordination bonds: A
simple and theoretically sound framework for effective collaboration among web services. In Technical Report CS-TR04-01, Department of Computer Science, Georgia State University, page 36 pages, 2004.

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

[33] S. K. Prasad and J. Balasooriya. Web coordination bonds: A
simple enhancement to web services infrastructure for effective collaboration. In Proc. 37th Hawai’i International Conference on System Science (HICSS 37), page 70192.1, Big
Island, Hawaii, January 5-8, 2004.
[34] S. K. Prasad and J. Balasooriya. Fundamental capabilities of
web coordination bonds: Modeling petri nets and expressing
workﬂow and communication patterns over web services. In
Proc. 38th Hawai’i International Conference on System Science (HICSS 38), pages 12–19, Big Island, Hawaii, January
5-8, 2005.
[35] S. K. Prasad, D. Erdogan, S. Raj, L. Bing, and M. Vijay. Design and implementation of a listener module for handheld
mobile devices. In Proceedings of 41st Annual ACM Southeast Conf., Savannah, Georgia, 2002, march 7-8.
[36] S. K. Prasad, V. Madisetti, S. Navathe, et al. System on
mobile devices (syd): A middleware testbed for collaborative applications over small heterogeneous devices and data
stores. In In Proc. ACM/IFIP/USENIX 5th International
Middleware Conference, Toronto, Ontario, Canada, October
18th - 22, 2004.
[37] T. Stefan, K. Rania, and M. Thomas. Composition of coordinated web services. In In Proc. ACM/IFIP/USENIX
5th International Middleware Conference, Toronto, Ontario,
Canada, October 18th - 22, 2004.
[38] T.Bray, J.Paoli, C.Sperberg-McQueen, and E.Maler. Extensible markup language (xml) 1.0 second edition w3c recommendation,technical report rec-xml-2001006. In WorldWide Web Consortium, Oct 2000.
[39] S. Thne, R. Depke, and G. Engels. Process-oriented, ﬂexible composition of web services with uml. In Proc. of
the Int. Workshop on Conceptual Modeling Approaches for
e-Business: A Web Service Perspective (eCOMO 2002).
Springer LNCS 2784, Tampere, Finland, Oct. 2002.
[40] E. J. J. v. Griethuysen. Iso- concepts and terminology for
the conceptual schema and the information base. In N695,
ISO/TC9/SC5/WG3, 1982.
[41] W. van der Aalst, M. Dumas, and A. ter Hofstede. Web service composition languages: Old wine in new bottles? In
Proc. of the 29th EUROMICRO Conf. on New Waves in System Architecture, pages 8–30, Los Alamitos, CA, 2003.
[42] W. van der Aalst and A. ter Hofstede. Workﬂow patterns:
On the expressive power of (petri-net-based) workﬂow languages. In Proc. of the 4th Workshop on the Practical Use
of Coloured Petri Nets and CPN Tools (CPN’02),pp. 1-20,
pages 1–20, Aarhus, Denmark, August 2002.
[43] W. M. P. van der Aalst. Workﬂow patterns.
2003.
”http:/tmitwww.tm.tue.nl/research/patterns”.
[44] P. Wohed, W. van der Aalst, M. Dumas, and A. ter Hofstede. Pattern based analysis of bpel4ws. In Technical Report FIT-TR-2002-04, QUT, Queensland University of Technology, 2002.
[45] G. Yang, M. Shi, Y. Xiang, and S. Wu. Wowww! :managing workﬂow on the world wide web. In In Proc. Intl. Conf.
Communication Technology (ICCT ’98), pages 1–5, Oct 2224, 1998, IEEE Computer Society Press.

[46] F. Yousﬁ , B.-S. N., R. Beuscart, and G. J.M. Placo: a cooperative architecture for solving coordination problem in health
care. In In Proc. IEEE 17th Annual Conf. Engineering in
Medicine and Biology Society, pages 747–748, Sep 20-25,
1995.

Biographies
Janaka Balasooriya is a P.h.D candidate in Computer
Science department at Georgia State University working
under the supervision of Prof. Sushil. K. Prasad with Prof.
Shamkant B. Navathe as a committee member. His dissertation work, “web coordination bonds”, is geared toward
ﬁnding a fundamental framework for web service coordination and composition and has already published several
papers. He received his B.S.in Computer Science and Engineering from university of Moratuwa, Colombo, Sri
Lanka in 1998. From 1998 to 2000 he worked as an Engineer at Sri Lanka Telecom. He joined the P.h.D program
in Fall 2001. Since 2001 Fall, he is serving as an executive committee member at GSU ACM student chapter. His
current research interests are web services, mobile computing, networks and databases. Contact Janaka at jbalasooriya@ieee.org.
Mohini Padhye was a M.S student in Computer Science department at Georgia State University and did her
theis under the supervision of Prof. Sushil K. Prasad.
Her M.S thesis ”Coordinating Heterogeneous web Services through Handhelds using SyD’s Wrapper Framework” is based on web coordination bonds and SyD middleware system.
Sushil K. Prasad is a Professor of Computer Science
at Georgia State University (GSU) and the Director of Yamacraw/GEDC Distributed, Mobile and Embedded Systems Program. Prasad has participated in external grants
and contracts with funding of over $4M. He has carried
out theoretical as well as experimental research in parallel
and distributed computing, with over 60 publications, and
made 3 utility patent applications and over a dozen provisional patent applications. His recent professional activities
include serving on NSF review panel for Networking Infrastructure program, in the program committees of several
international conferences including IPDPS-05, Colorado,
ICA3PP-05, Melbourne, HiPC-04, Bangalore, ICA3PP-02,
China, HIPC-01, India, DS-RT-2001, Cincinnati, PDCAT2001, Taiwan, as publicity chair for PADS-2001, LA, and as
proceeding chair of HiPC 2003-05. Recently, as P.I. of the
Yamacraw/GEDC Embedded Systems research contracts,
he has been leading a GSU team of seven faculty and 20
Ph.D./M.S. students on developing System on Mobile De-

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

vices (SyD) middleware for collaborative computing over
heterogeneous mobile devices and data sources. His current
research interests are Parallel Algorithms and Data Structures, Parallel Discrete Event Simulation, Web-based Distributed and Collaborative Computing, and Middlewares
and Collaborative Applications for Handheld Devices.
Prasad received his B. Tech. in Computer Science and
Engineering from Indian Institute of Technology, Kharagpur, in 1985, M.S. in Computer Science from Washington
State University, Pullman, in 1986, and Ph.D. in Computer Science from University of Central Florida, Orlando, in 1990.
Shamkant B. Navathe is a professor at the College of
Computing, Georgia Institute of Technology, Atlanta, USA.
He has published over 130 refereed papers in database research; his important contributions are in database modeling, database conversion, database design, conceptual clustering, distributed database allocation, and database integration. His recent work has been addressing issues of mobility, scalability, interoperability, and personalization. Current
projects include transaction models in P2P and web applications, text mining of medical literature databases, and data
mining for better understanding of genomic/proteomic and
medical data. Navathe is an author of the book, Fundamentals of Database Systems, with R. Elmasri (Addison Wesley, Edition4, 2004) which is currently the leading database
text-book worldwide. He also co-authored the book ”Conceptual Design: An Entity Relationship Approach” (Addison Wesley, 1992) with Carlo Batini and Stefano Ceri. He
has worked with IBM and Siemens in their research divisions and has been a consultant to various companies including Digital, CCA, HP and Equifax. He was the General
Co-chairman of the 1996 International VLDB (Very Large
Data Base) conference in Bombay, India. He was also program co-chair of SIGMOD 1985 and General Co-chair of
the IFIP WG 2.6 Data Semantics Workshop in 1995. He has
been an associate editor of ACM Computing Surveys, and
IEEE Transactions on Knowledge and Data Engineering.
He is also on the editorial boards of Information Systems
(Pergamon Press) and Distributed and Parallel Databases
(Kluwer Academic Publishers). His research interests span
human genome data management, intelligent information
retrieval, text mining, security risk modeling in information
systems, engineering data management, and mobile as well
as peer-to-peer information processing.
Navathe holds a Ph.D. from the University of Michigan
in 1976.

Proceedings of the 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS’05)
1530-2075/05 $ 20.00 IEEE

